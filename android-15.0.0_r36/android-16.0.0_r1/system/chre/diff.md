```diff
diff --git a/Android.bp b/Android.bp
index 49fe6f13..1e0cfda0 100644
--- a/Android.bp
+++ b/Android.bp
@@ -56,6 +56,11 @@ filegroup {
     ],
 }
 
+filegroup {
+    name: "bluetooth_socket_hal_core",
+    srcs: ["host/hal_generic/common/bluetooth_socket_fbs_hal.cc"],
+}
+
 filegroup {
     name: "contexthub_hal_common_srcs",
     srcs: [
@@ -64,6 +69,7 @@ filegroup {
         "host/common/host_protocol_host.cc",
         "host/common/log.cc",
         "host/hal_generic/common/context_hub_v4_impl.cc",
+        "host/hal_generic/common/host_protocol_host_v4.cc",
         "host/hal_generic/common/message_hub_manager.cc",
         "platform/shared/host_protocol_common.cc",
     ],
@@ -88,6 +94,7 @@ cc_defaults {
         "system/chre/host/hal_generic/aidl/",
         "system/chre/host/hal_generic/common/",
         "system/chre/platform/shared/include/",
+        "system/chre/platform/shared/fbs/include",
         "system/chre/util/include/",
     ],
     header_libs: [
@@ -131,6 +138,7 @@ cc_library_static {
     export_include_dirs: [
         "host/common/include",
         "platform/shared/include",
+        "platform/shared/fbs/include",
         "util/include",
     ],
     srcs: [
@@ -296,6 +304,7 @@ cc_binary {
     vendor: true,
     local_include_dirs: [
         "apps/power_test/common/include",
+        "apps/power_test/common/generated/include",
         "chre_api/include/chre_api",
         "util/include",
     ],
@@ -582,6 +591,7 @@ cc_test_host {
         "host/common/fragmented_load_transaction.cc",
         "host/common/hal_client.cc",
         "host/hal_generic/common/hal_client_manager.cc",
+        "host/hal_generic/common/message_hub_manager.cc",
         "host/test/**/*_test.cc",
     ],
     local_include_dirs: [
@@ -591,6 +601,7 @@ cc_test_host {
         "platform/android/include",
         "platform/include",
         "platform/shared/include/",
+        "platform/shared/fbs/include",
         "util/include/",
     ],
     static_libs: [
@@ -735,6 +746,7 @@ cc_library_static {
         "platform/include",
         "platform/linux/include",
         "platform/shared/include",
+        "platform/shared/fbs/include",
         "util/include",
     ],
     header_libs: [
@@ -778,6 +790,7 @@ cc_test_host {
         "platform/include",
         "platform/linux/include",
         "platform/shared/include",
+        "platform/shared/fbs/include",
         "platform/shared/pw_trace/include",
         "util/include",
     ],
@@ -789,6 +802,7 @@ cc_test_host {
         "libgmock",
         "pw_allocator",
         "pw_containers",
+        "pw_intrusive_ptr",
     ],
     defaults: [
         "chre_linux_cflags",
@@ -958,9 +972,15 @@ cc_test_host {
     static_libs: [
         "chre_linux",
         "chre_pal_linux",
+        "libgmock",
+        "libgtest",
         "libprotobuf-c-nano",
         "pw_allocator",
         "pw_containers",
+        "pw_intrusive_ptr",
+    ],
+    shared_libs: [
+        "libbase",
     ],
     defaults: [
         "chre_linux_cflags",
@@ -989,6 +1009,7 @@ cc_library_static {
         "core/gnss_manager.cc",
         "core/host_comms_manager.cc",
         "core/host_endpoint_manager.cc",
+        "core/host_message_hub_manager.cc",
         "core/init.cc",
         "core/nanoapp.cc",
         "core/sensor.cc",
@@ -1028,6 +1049,7 @@ cc_library_static {
         "platform/shared/chre_api_ble.cc",
         "platform/shared/chre_api_core.cc",
         "platform/shared/chre_api_gnss.cc",
+        "platform/shared/chre_api_msg.cc",
         "platform/shared/chre_api_re.cc",
         "platform/shared/chre_api_sensor.cc",
         "platform/shared/chre_api_user_settings.cc",
@@ -1059,6 +1081,7 @@ cc_library_static {
         "platform/linux/include",
         "platform/shared/audio_pal/include",
         "platform/shared/include",
+        "platform/shared/fbs/include",
         "platform/shared/public_platform_ble_pal",
         "platform/shared/public_platform_debug_dump_manager",
         "platform/shared/public_platform_gnss_pal",
@@ -1079,8 +1102,12 @@ cc_library_static {
         "libgmock",
         "libgtest",
         "pw_allocator",
+        "pw_intrusive_ptr",
         "pw_rpc_chre",
     ],
+    shared_libs: [
+        "libbase",
+    ],
     host_supported: true,
 }
 
@@ -1089,11 +1116,14 @@ cc_defaults {
     cflags: [
         "-DCHRE_ASSERTIONS_ENABLED=true",
         "-DCHRE_AUDIO_SUPPORT_ENABLED",
+        "-DCHRE_BLE_SOCKET_SUPPORT_ENABLED",
         "-DCHRE_BLE_SUPPORT_ENABLED",
         "-DCHRE_FILENAME=__FILE__",
         "-DCHRE_FIRST_SUPPORTED_API_VERSION=CHRE_API_VERSION_1_1",
         "-DCHRE_GNSS_SUPPORT_ENABLED",
         "-DCHRE_LARGE_PAYLOAD_MAX_SIZE=32000",
+        "-DCHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS=8",
+        "-DCHRE_MESSAGE_ROUTER_MAX_HOST_HUBS=2",
         "-DCHRE_MESSAGE_ROUTER_SUPPORT_ENABLED",
         "-DCHRE_MESSAGE_TO_HOST_MAX_SIZE=4096",
         "-DCHRE_MINIMUM_LOG_LEVEL=CHRE_LOG_LEVEL_DEBUG",
@@ -1121,6 +1151,7 @@ cc_defaults {
         "external/flatbuffers/include",
         "host/common/include",
         "platform/shared/include",
+        "platform/shared/fbs/include",
         "util/include",
     ],
     srcs: [
@@ -1241,3 +1272,21 @@ cc_aconfig_library {
     host_supported: true,
     vendor_available: true,
 }
+
+filegroup {
+    name: "chre_daemon_srcs",
+    srcs: [
+        "host/common/bt_snoop_log_parser.cc",
+        "host/common/config_util.cc",
+        "host/common/daemon_base.cc",
+        "host/common/fbs_daemon_base.cc",
+        "host/common/file_stream.cc",
+        "host/common/fragmented_load_transaction.cc",
+        "host/common/host_protocol_host.cc",
+        "host/common/log_message_parser.cc",
+        "host/common/socket_server.cc",
+        "host/common/st_hal_lpma_handler.cc",
+        "host/common/wifi_ext_hal_handler.cc",
+        "platform/shared/host_protocol_common.cc",
+    ],
+}
diff --git a/Makefile b/Makefile
index d8b072f6..da8bdaa6 100644
--- a/Makefile
+++ b/Makefile
@@ -40,6 +40,9 @@ endif
 # Optional BLE support
 ifeq ($(CHRE_BLE_SUPPORT_ENABLED), true)
 COMMON_CFLAGS += -DCHRE_BLE_SUPPORT_ENABLED
+ifeq ($(CHRE_BLE_SOCKET_SUPPORT_ENABLED), true)
+COMMON_CFLAGS += -DCHRE_BLE_SOCKET_SUPPORT_ENABLED
+endif
 endif
 
 # Optional GNSS support.
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
index 8f0c3af6..77d517de 100644
--- a/PREUPLOAD.cfg
+++ b/PREUPLOAD.cfg
@@ -16,5 +16,3 @@ checkstyle_hook = ${REPO_ROOT}/prebuilts/checkstyle/checkstyle.py
 todo_checker_hook = ${REPO_ROOT}/system/chre/tools/todo_checker.py
 
 run_sim = ${REPO_ROOT}/system/chre/run_sim.sh -b
-run_tests = ${REPO_ROOT}/system/chre/run_tests.sh -b
-run_pal_impl_tests = ${REPO_ROOT}/system/chre/run_pal_impl_tests.sh -b
diff --git a/apps/ble_world/ble_world.cc b/apps/ble_world/ble_world.cc
index 19b1df51..7d7c197a 100644
--- a/apps/ble_world/ble_world.cc
+++ b/apps/ble_world/ble_world.cc
@@ -234,6 +234,7 @@ void parseReport(const chreBleAdvertisingReport *report) {
        report->directAddress[1], report->directAddress[2],
        report->directAddress[3], report->directAddress[4],
        report->directAddress[5]);
+  LOGD("rssi value: %" PRIi8, report->rssi);
 }
 
 void handleAsyncResultEvent(const chreAsyncResult *result) {
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scan_record.h b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scan_record.h
index 7c0b207e..4ba81d90 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scan_record.h
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scan_record.h
@@ -45,7 +45,7 @@ struct BleScanRecord {
   // Returns a BLE scan record by parsing the data.
   // Note, the returned BleScanRecord has dependence on the lifetime of data,
   // and the return will be invalid if data is altered/destructed after parsing.
-  static BleScanRecord Parse(const uint8_t data[], const uint16_t size);
+  static BleScanRecord Parse(const uint8_t data[], uint16_t size);
   chre::DynamicVector<BleServiceData> service_data;
 
   static constexpr int8_t kDataTypeServiceData = 0x16;
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scanner.h b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scanner.h
index af2f45f0..c086f406 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scanner.h
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/ble_scanner.h
@@ -19,6 +19,8 @@
 
 #include <chre.h>
 
+#include <utility>
+
 #include "third_party/contexthub/chre/util/include/chre/util/dynamic_vector.h"
 #include "third_party/contexthub/chre/util/include/chre/util/time.h"
 
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/crypto/hmac.c b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/crypto/hmac.c
index f8aa1269..0eb0613e 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/crypto/hmac.c
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/crypto/hmac.c
@@ -18,6 +18,8 @@
 
 #include <string.h>
 
+#include "location/lbs/contexthub/nanoapps/nearby/crypto/sha2.h"
+
 static void sha2InitHmacKeyUpdate(struct HmacContext *ctx) {
   // initialize sha2 context and update hmac keys to the sha2 context
   sha2init(&ctx->sha2ctx);
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.cc b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.cc
index 8425ba14..2144b212 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.cc
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.cc
@@ -115,9 +115,10 @@ int32_t FilterExtension::FindOrCreateHostIndex(
  */
 size_t AddToFilterResults(
     const HostEndpointInfo &host,
-    chre::DynamicVector<FilterExtensionResult> *filter_results) {
+    chre::DynamicVector<FilterExtensionResult> *filter_results,
+    bool set_timeout = true) {
   FilterExtensionResult result(host.host_info.hostEndpointId,
-                               host.cache_expire_ms);
+                               host.cache_expire_ms, set_timeout);
   size_t idx = filter_results->find(result);
   if (filter_results->size() == idx) {
     filter_results->push_back(std::move(result));
@@ -130,7 +131,12 @@ void FilterExtension::Match(
     chre::DynamicVector<FilterExtensionResult> *filter_results,
     chre::DynamicVector<FilterExtensionResult> *screen_on_filter_results) {
   for (const HostEndpointInfo &host : host_list_) {
-    size_t idx = AddToFilterResults(host, filter_results);
+    // Get the index of the FilterExtensionResult to deliver immediately.
+    // The FilterExtensionResult is initialized without timeout so that it
+    // won't be expired.
+    size_t immediate_idx =
+        AddToFilterResults(host, filter_results, /*set_timeout=*/false);
+    // Get the index of the FilterExtensionResult to deliver on wake.
     size_t screen_on_idx = AddToFilterResults(host, screen_on_filter_results);
     for (const auto &ble_adv_report : ble_adv_list) {
       switch (
@@ -144,7 +150,7 @@ void FilterExtension::Match(
           continue;
         case CHREX_NEARBY_FILTER_ACTION_DELIVER_IMMEDIATELY:
           LOGD("Include BLE report to immediate delivery list.");
-          (*filter_results)[idx].reports.Push(ble_adv_report);
+          (*filter_results)[immediate_idx].reports.Push(ble_adv_report);
           continue;
       }
     }
@@ -171,60 +177,6 @@ bool FilterExtension::EncodeConfigResponse(
   return true;
 }
 
-bool FilterExtension::Encode(
-    const chre::DynamicVector<chreBleAdvertisingReport> &reports,
-    ByteArray data_buf, size_t *encoded_size) {
-  nearby_extension_FilterResult filter_result = kEmptyFilterResult;
-  size_t idx = 0;
-  for (const auto &report : reports) {
-    nearby_extension_ChreBleAdvertisingReport &report_proto =
-        filter_result.report[idx];
-    report_proto.has_timestamp = true;
-    report_proto.timestamp = report.timestamp;
-    report_proto.has_event_type_and_data_status = true;
-    report_proto.event_type_and_data_status = report.eventTypeAndDataStatus;
-    report_proto.has_address_type = true;
-    report_proto.address_type =
-        static_cast<nearby_extension_ChreBleAdvertisingReport_AddressType>(
-            report.addressType);
-    report_proto.has_address = true;
-    for (size_t i = 0; i < 6; i++) {
-      report_proto.address[i] = report.address[i];
-    }
-    report_proto.has_tx_power = true;
-    report_proto.tx_power = report.txPower;
-    report_proto.has_rssi = true;
-    report_proto.rssi = report.rssi;
-    report_proto.has_data_length = true;
-    report_proto.data_length = report.dataLength;
-    if (report.dataLength > 0) {
-      report_proto.has_data = true;
-    }
-    for (size_t i = 0; i < report.dataLength; i++) {
-      report_proto.data[i] = report.data[i];
-    }
-    idx++;
-  }
-  filter_result.report_count = static_cast<pb_size_t>(idx);
-  filter_result.has_error_code = true;
-  filter_result.error_code = nearby_extension_FilterResult_ErrorCode_SUCCESS;
-
-  if (!pb_get_encoded_size(encoded_size, nearby_extension_FilterResult_fields,
-                           &filter_result)) {
-    LOGE("Failed to get filter extension result size.");
-    return false;
-  }
-  pb_ostream_t ostream = pb_ostream_from_buffer(data_buf.data, data_buf.length);
-
-  if (!pb_encode(&ostream, nearby_extension_FilterResult_fields,
-                 &filter_result)) {
-    LOGE("Unable to encode protobuf for FilterExtensionResults, error %s",
-         PB_GET_ERROR(&ostream));
-    return false;
-  }
-  return true;
-}
-
 bool FilterExtension::EncodeAdvReport(chreBleAdvertisingReport &report,
                                       ByteArray data_buf,
                                       size_t *encoded_size) {
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.h b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.h
index 99c9b20c..e1944f96 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.h
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/filter_extension.h
@@ -31,11 +31,17 @@ struct FilterExtensionResult {
   const uint16_t end_point;
   AdvReportCache reports;
 
+  // Constructs FilterExtensionResult with host end point and cache expire time.
+  // If set_timeout is true, the cache will expire after expire_time_ms.
+  // Otherwise, the cache will not expire and be used for immediate delivery.
   explicit FilterExtensionResult(
       uint16_t end_point,
-      uint64_t expire_time_ms = kFilterExtensionReportExpireTimeMilliSec)
+      uint64_t expire_time_ms = kFilterExtensionReportExpireTimeMilliSec,
+      bool set_timeout = true)
       : end_point(end_point) {
-    reports.SetCacheTimeout(expire_time_ms);
+    if (set_timeout) {
+      reports.SetCacheTimeout(expire_time_ms);
+    }
   }
 
   FilterExtensionResult(FilterExtensionResult &&src)
@@ -53,11 +59,6 @@ struct FilterExtensionResult {
     reports.Clear();
   }
 
-  // Removes advertising reports older than the cache timeout.
-  void Refresh() {
-    reports.Refresh();
-  }
-
   // Removes advertising reports older than the cache timeout if the cache size
   // hits a threshold.
   void RefreshIfNeeded() {
@@ -114,12 +115,6 @@ class FilterExtension {
       const nearby_extension_ExtConfigResponse &config_response,
       ByteArray data_buf, size_t *encoded_size);
 
-  // Encodes reports into data_buf. The reports are converted to
-  // nearby_extension_FilterResult before the serialization.
-  static bool Encode(
-      const chre::DynamicVector<chreBleAdvertisingReport> &reports,
-      ByteArray data_buf, size_t *encoded_size);
-
   // Encodes a single report into data_buf. The report are converted to
   // nearby_extension_FilterResult before the serialization.
   static bool EncodeAdvReport(chreBleAdvertisingReport &report,
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_decoder_v1.h b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_decoder_v1.h
index 46d9fb91..7db0fcc7 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_decoder_v1.h
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_decoder_v1.h
@@ -33,7 +33,7 @@ struct DataElementHeaderV1 {
   // Decodes data and returns the first Data Element header.
   // Returns no value if decoding fails.
   static chre::Optional<DataElementHeaderV1> Decode(const uint8_t data[],
-                                                    const size_t data_size);
+                                                    size_t data_size);
 
   static constexpr uint64_t kSaltType = 0;
   static constexpr uint64_t kPrivateIdentityType = 1;
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_service_data.h b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_service_data.h
index 27920a2a..89aa3af8 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_service_data.h
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/presence_service_data.h
@@ -40,7 +40,7 @@ struct PresenceServiceData {
   // following the spec (go/nearby-presence-spec).
   // Returns no value if parse fails. Callee keeps the ownership of data.
   static chre::Optional<PresenceServiceData> Parse(const uint8_t data[],
-                                                   const uint16_t size);
+                                                   uint16_t size);
   chre::Optional<uint8_t> first_intent;
   chre::Optional<uint8_t> second_intent;
   bool has_fp_model_id = false;
diff --git a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/tracker_filter.cc b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/tracker_filter.cc
index 3dbf1fda..cfd1e3c9 100644
--- a/apps/nearby/location/lbs/contexthub/nanoapps/nearby/tracker_filter.cc
+++ b/apps/nearby/location/lbs/contexthub/nanoapps/nearby/tracker_filter.cc
@@ -51,7 +51,8 @@ void TrackerFilter::Update(
     hardware_filters.push_back(generic_filter);
   }
   scan_filter_config_.hardware_filters = std::move(hardware_filters);
-  scan_filter_config_.rssi_threshold = filter_config.rssi_threshold;
+  scan_filter_config_.rssi_threshold =
+      static_cast<int8_t>(filter_config.rssi_threshold);
   scan_filter_config_.active_interval_ms = filter_config.active_interval_ms;
   scan_filter_config_.active_window_ms = filter_config.active_window_ms;
   ConfigureActiveState();
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector.h
index 0b5fe014..abd777f2 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector.h
@@ -52,7 +52,7 @@ class DynamicVector : private DynamicVectorBase {
   DynamicVector(DynamicVector<ElementType> &&other);
 
   /**
-   * Move-constructs a dynamic vector from another. The other dynamic vector is
+   * Move assigns a dynamic vector from another. The other dynamic vector is
    * left in an empty state.
    */
   DynamicVector &operator=(DynamicVector<ElementType> &&other);
@@ -369,6 +369,6 @@ class DynamicVector : private DynamicVectorBase {
 
 }  // namespace chre
 
-#include "chre/util/dynamic_vector_impl.h"
+#include "chre/util/dynamic_vector_impl.h"  // IWYU pragma: export
 
 #endif  // CHRE_UTIL_DYNAMIC_VECTOR_H_
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector_impl.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector_impl.h
index 8baaf259..219de998 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector_impl.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/dynamic_vector_impl.h
@@ -17,8 +17,10 @@
 #ifndef CHRE_UTIL_DYNAMIC_VECTOR_IMPL_H_
 #define CHRE_UTIL_DYNAMIC_VECTOR_IMPL_H_
 
+// IWYU pragma: private
 #include "chre/util/dynamic_vector.h"
 
+#include <cstddef>
 #include <memory>
 #include <new>
 #include <utility>
@@ -105,6 +107,10 @@ bool DynamicVector<ElementType>::push_back(const ElementType &element) {
 template <typename ElementType>
 bool DynamicVector<ElementType>::doPushBack(const ElementType &element,
                                             std::true_type) {
+  if constexpr (alignof(ElementType) > alignof(std::max_align_t)) {
+    // This type requires aligned allocation, so use the non-trivial doPushBack.
+    return doPushBack(element, std::false_type());
+  }
   return DynamicVectorBase::doPushBack(static_cast<const void *>(&element),
                                        sizeof(ElementType));
 }
@@ -178,6 +184,10 @@ bool DynamicVector<ElementType>::reserve(size_type newCapacity) {
 template <typename ElementType>
 bool DynamicVector<ElementType>::doReserve(size_type newCapacity,
                                            std::true_type) {
+  if constexpr (alignof(ElementType) > alignof(std::max_align_t)) {
+    // This type requires aligned allocation, so use the non-trivial reserve.
+    return doReserve(newCapacity, std::false_type());
+  }
   return DynamicVectorBase::doReserve(newCapacity, sizeof(ElementType));
 }
 
@@ -186,8 +196,14 @@ bool DynamicVector<ElementType>::doReserve(size_type newCapacity,
                                            std::false_type) {
   bool success = (newCapacity <= mCapacity);
   if (!success) {
-    ElementType *newData = static_cast<ElementType *>(
-        memoryAlloc(newCapacity * sizeof(ElementType)));
+    ElementType *newData;
+    if constexpr (alignof(ElementType) > alignof(std::max_align_t)) {
+      newData = memoryAlignedAllocArray<ElementType>(newCapacity);
+    } else {
+      newData = static_cast<ElementType *>(
+          memoryAlloc(newCapacity * sizeof(ElementType)));
+    }
+
     if (newData != nullptr) {
       if (data() != nullptr) {
         uninitializedMoveOrCopy(data(), mSize, newData);
@@ -347,6 +363,11 @@ bool DynamicVector<ElementType>::prepareForPush() {
 
 template <typename ElementType>
 bool DynamicVector<ElementType>::doPrepareForPush(std::true_type) {
+  if constexpr (alignof(ElementType) > alignof(std::max_align_t)) {
+    // This type requires aligned allocation, so use the non-trivial
+    // doPrepareForPush.
+    return doPrepareForPush(std::false_type());
+  }
   return DynamicVectorBase::doPrepareForPush(sizeof(ElementType));
 }
 
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/nanoapp/assert.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/nanoapp/assert.h
index ddc7afe3..f4dbb859 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/nanoapp/assert.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/nanoapp/assert.h
@@ -37,7 +37,7 @@
 #define CHRE_ASSERT(condition)                                       \
   do {                                                               \
     if (!(condition)) {                                              \
-      chreLog(CHRE_LOG_ERROR, "CHRE_ASSERT at %s:%d", CHRE_FILENAME, \
+      chreLog(CHRE_LOG_ERROR, "CHRE_ASSERT at " CHRE_FILENAME ":%d", \
               __LINE__);                                             \
       chreAbort(UINT32_MAX);                                         \
     }                                                                \
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional.h
index 4437b73e..24394cc8 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional.h
@@ -36,7 +36,7 @@ class Optional {
   /**
    * Default constructs the optional object with no initial value.
    */
-  Optional() = default;
+  constexpr Optional() : mObject() {}
 
   /**
    * Default copy constructor.
@@ -180,6 +180,6 @@ class Optional {
 
 }  // namespace chre
 
-#include "chre/util/optional_impl.h"
+#include "chre/util/optional_impl.h"  // IWYU pragma: export
 
 #endif  // UTIL_CHRE_OPTIONAL_H_
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional_impl.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional_impl.h
index cc9834d8..86bb478a 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional_impl.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/optional_impl.h
@@ -17,6 +17,7 @@
 #ifndef UTIL_CHRE_OPTIONAL_IMPL_H_
 #define UTIL_CHRE_OPTIONAL_IMPL_H_
 
+// IWYU pragma: private
 #include <new>
 #include <utility>
 
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton.h
index 62fd034c..41369e4a 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton.h
@@ -90,6 +90,6 @@ class Singleton : public NonCopyable {
 
 }  // namespace chre
 
-#include "chre/util/singleton_impl.h"
+#include "chre/util/singleton_impl.h"  // IWYU pragma: export
 
 #endif  // CHRE_UTIL_SINGLETON_H_
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton_impl.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton_impl.h
index b0ec5e7f..f31b8bbf 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton_impl.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/singleton_impl.h
@@ -17,6 +17,7 @@
 #ifndef CHRE_UTIL_SINGLETON_IMPL_H_
 #define CHRE_UTIL_SINGLETON_IMPL_H_
 
+// IWYU pragma: private
 #include <new>
 #include <utility>
 
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time.h
index faef7dcf..3a4c6188 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time.h
@@ -308,6 +308,6 @@ constexpr bool operator>(const Nanoseconds &nanos_a,
 
 }  // namespace chre
 
-#include "chre/util/time_impl.h"
+#include "chre/util/time_impl.h"  // IWYU pragma: export
 
 #endif  // CHRE_UTIL_TIME_H_
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time_impl.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time_impl.h
index 5fe5712c..653e7c0f 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time_impl.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/time_impl.h
@@ -17,6 +17,7 @@
 #ifndef CHRE_UTIL_TIME_IMPL_H_
 #define CHRE_UTIL_TIME_IMPL_H_
 
+// IWYU pragma: private
 #include "chre/util/time.h"
 
 namespace chre {
diff --git a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/unique_ptr.h b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/unique_ptr.h
index e113c394..bf394924 100644
--- a/apps/nearby/third_party/contexthub/chre/util/include/chre/util/unique_ptr.h
+++ b/apps/nearby/third_party/contexthub/chre/util/include/chre/util/unique_ptr.h
@@ -231,6 +231,6 @@ UniquePtr<ObjectType> MakeUniqueZeroFill();
 
 }  // namespace chre
 
-#include "chre/util/unique_ptr_impl.h"
+#include "chre/util/unique_ptr_impl.h"  // IWYU pragma: export
 
 #endif  // CHRE_UTIL_UNIQUE_PTR_H_
diff --git a/apps/nearby/third_party/nanopb/pb.h b/apps/nearby/third_party/nanopb/pb.h
index 6db19c68..1fc7043a 100644
--- a/apps/nearby/third_party/nanopb/pb.h
+++ b/apps/nearby/third_party/nanopb/pb.h
@@ -152,8 +152,8 @@ typedef uint_least8_t pb_type_t;
 /**** Field data types ****/
 
 /* Numeric types */
-#define PB_LTYPE_BOOL 0x00    /* bool */
-#define PB_LTYPE_VARINT 0x01  /* int32, int64, enum, bool */
+#define PB_LTYPE_BOOL 0x00   /* bool */
+#define PB_LTYPE_VARINT 0x01 /* int32, int64, enum, bool */
 #define PB_LTYPE_UVARINT 0x02 /* uint32, uint64 */
 #define PB_LTYPE_SVARINT 0x03 /* sint32, sint64 */
 #define PB_LTYPE_FIXED32 0x04 /* fixed32, sfixed32, float */
@@ -404,8 +404,7 @@ struct pb_extension_s {
 /* Delta from start of one member to the start of another member. */
 #define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
 /* Marks the end of the field list */
-#define PB_LAST_FIELD \
-  { 0, (pb_type_t)0, 0, 0, 0, 0, 0 }
+#define PB_LAST_FIELD {0, (pb_type_t)0, 0, 0, 0, 0, 0}
 
 /* Macros for filling in the data_offset field */
 /* data_offset for first field in a message */
@@ -426,87 +425,122 @@ struct pb_extension_s {
  * previous field end, and the size of the field. Pointer is used for
  * submessages and default values.
  */
-#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr)       \
-  {                                                          \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, fd, 0, \
-        pb_membersize(st, m), 0, ptr                         \
-  }
+#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                \
+   PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype,        \
+   fd,                                                 \
+   0,                                                  \
+   pb_membersize(st, m),                               \
+   0,                                                  \
+   ptr}
 
 /* Optional fields add the delta to the has_ variable. */
-#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr)         \
-  {                                                            \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, fd,      \
-        pb_delta(st, has_##m, m), pb_membersize(st, m), 0, ptr \
-  }
-
-#define PB_SINGULAR_STATIC(tag, st, m, fd, ltype, ptr)       \
-  {                                                          \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, fd, 0, \
-        pb_membersize(st, m), 0, ptr                         \
-  }
+#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                \
+   PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype,        \
+   fd,                                                 \
+   pb_delta(st, has_##m, m),                           \
+   pb_membersize(st, m),                               \
+   0,                                                  \
+   ptr}
+
+#define PB_SINGULAR_STATIC(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                \
+   PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype,        \
+   fd,                                                 \
+   0,                                                  \
+   pb_membersize(st, m),                               \
+   0,                                                  \
+   ptr}
 
 /* Repeated fields have a _count field and also the maximum number of entries.
  */
-#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr)       \
-  {                                                          \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, fd,    \
-        pb_delta(st, m##_count, m), pb_membersize(st, m[0]), \
-        pb_arraysize(st, m), ptr                             \
-  }
+#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                \
+   PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype,        \
+   fd,                                                 \
+   pb_delta(st, m##_count, m),                         \
+   pb_membersize(st, m[0]),                            \
+   pb_arraysize(st, m),                                \
+   ptr}
 
 /* Allocated fields carry the size of the actual data, not the pointer */
-#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr)       \
-  {                                                           \
-    tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, fd, 0, \
-        pb_membersize(st, m[0]), 0, ptr                       \
-  }
+#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                 \
+   PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype,        \
+   fd,                                                  \
+   0,                                                   \
+   pb_membersize(st, m[0]),                             \
+   0,                                                   \
+   ptr}
 
 /* Optional fields don't need a has_ variable, as information would be redundant
  */
-#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)       \
-  {                                                           \
-    tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, fd, 0, \
-        pb_membersize(st, m[0]), 0, ptr                       \
-  }
+#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                 \
+   PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype,        \
+   fd,                                                  \
+   0,                                                   \
+   pb_membersize(st, m[0]),                             \
+   0,                                                   \
+   ptr}
 
 /* Same as optional fields*/
-#define PB_SINGULAR_POINTER(tag, st, m, fd, ltype, ptr)       \
-  {                                                           \
-    tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, fd, 0, \
-        pb_membersize(st, m[0]), 0, ptr                       \
-  }
+#define PB_SINGULAR_POINTER(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                 \
+   PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype,        \
+   fd,                                                  \
+   0,                                                   \
+   pb_membersize(st, m[0]),                             \
+   0,                                                   \
+   ptr}
 
 /* Repeated fields have a _count field and a pointer to array of pointers */
-#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr)             \
-  {                                                                 \
-    tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, fd,          \
-        pb_delta(st, m##_count, m), pb_membersize(st, m[0]), 0, ptr \
-  }
+#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                 \
+   PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype,        \
+   fd,                                                  \
+   pb_delta(st, m##_count, m),                          \
+   pb_membersize(st, m[0]),                             \
+   0,                                                   \
+   ptr}
 
 /* Callbacks are much like required fields except with special datatype. */
-#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr)       \
-  {                                                            \
-    tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, fd, 0, \
-        pb_membersize(st, m), 0, ptr                           \
-  }
-
-#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)       \
-  {                                                            \
-    tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, fd, 0, \
-        pb_membersize(st, m), 0, ptr                           \
-  }
-
-#define PB_SINGULAR_CALLBACK(tag, st, m, fd, ltype, ptr)       \
-  {                                                            \
-    tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, fd, 0, \
-        pb_membersize(st, m), 0, ptr                           \
-  }
-
-#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr)       \
-  {                                                            \
-    tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, fd, 0, \
-        pb_membersize(st, m), 0, ptr                           \
-  }
+#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                  \
+   PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype,        \
+   fd,                                                   \
+   0,                                                    \
+   pb_membersize(st, m),                                 \
+   0,                                                    \
+   ptr}
+
+#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                  \
+   PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype,        \
+   fd,                                                   \
+   0,                                                    \
+   pb_membersize(st, m),                                 \
+   0,                                                    \
+   ptr}
+
+#define PB_SINGULAR_CALLBACK(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                  \
+   PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype,        \
+   fd,                                                   \
+   0,                                                    \
+   pb_membersize(st, m),                                 \
+   0,                                                    \
+   ptr}
+
+#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
+  {tag,                                                  \
+   PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype,        \
+   fd,                                                   \
+   0,                                                    \
+   pb_membersize(st, m),                                 \
+   0,                                                    \
+   ptr}
 
 /* Optional extensions don't have the has_ field, as that would be redundant.
  * Furthermore, the combination of OPTIONAL without has_ field is used
@@ -514,11 +548,14 @@ struct pb_extension_s {
  * so they should be encoded according to proto2 rules. To avoid the conflict,
  * extensions are marked as REQUIRED instead.
  */
-#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr)        \
-  {                                                         \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, 0, 0, \
-        pb_membersize(st, m), 0, ptr                        \
-  }
+#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
+  {tag,                                              \
+   PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype,      \
+   0,                                                \
+   0,                                                \
+   pb_membersize(st, m),                             \
+   0,                                                \
+   ptr}
 
 #define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
   PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
@@ -572,28 +609,36 @@ struct pb_extension_s {
       PB_LTYPE_MAP_##type, ptr)
 
 /* Field description for repeated static fixed count fields.*/
-#define PB_REPEATED_FIXED_COUNT(tag, type, placement, message, field,       \
-                                prevfield, ptr)                             \
-  {                                                                         \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | PB_LTYPE_MAP_##type,         \
-        PB_DATAOFFSET_##placement(message, field, prevfield), 0,            \
-        pb_membersize(message, field[0]), pb_arraysize(message, field), ptr \
-  }
+#define PB_REPEATED_FIXED_COUNT(tag, type, placement, message, field, \
+                                prevfield, ptr)                       \
+  {tag,                                                               \
+   PB_ATYPE_STATIC | PB_HTYPE_REPEATED | PB_LTYPE_MAP_##type,         \
+   PB_DATAOFFSET_##placement(message, field, prevfield),              \
+   0,                                                                 \
+   pb_membersize(message, field[0]),                                  \
+   pb_arraysize(message, field),                                      \
+   ptr}
 
 /* Field description for oneof fields. This requires taking into account the
  * union name also, that's why a separate set of macros is needed.
  */
-#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr)               \
-  {                                                                  \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, fd,               \
-        pb_delta(st, which_##u, u.m), pb_membersize(st, u.m), 0, ptr \
-  }
-
-#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr)                 \
-  {                                                                     \
-    tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, fd,                 \
-        pb_delta(st, which_##u, u.m), pb_membersize(st, u.m[0]), 0, ptr \
-  }
+#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
+  {tag,                                                \
+   PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype,           \
+   fd,                                                 \
+   pb_delta(st, which_##u, u.m),                       \
+   pb_membersize(st, u.m),                             \
+   0,                                                  \
+   ptr}
+
+#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
+  {tag,                                                 \
+   PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype,           \
+   fd,                                                  \
+   pb_delta(st, which_##u, u.m),                        \
+   pb_membersize(st, u.m[0]),                           \
+   0,                                                   \
+   ptr}
 
 #define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, \
                        message, field, prevfield, ptr)                      \
@@ -603,16 +648,22 @@ struct pb_extension_s {
       PB_LTYPE_MAP_##type, ptr)
 
 #define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
-  {                                                              \
-    tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, fd,           \
-        pb_delta(st, which_##u, m), pb_membersize(st, m), 0, ptr \
-  }
-
-#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr)   \
-  {                                                                 \
-    tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, fd,             \
-        pb_delta(st, which_##u, m), pb_membersize(st, m[0]), 0, ptr \
-  }
+  {tag,                                                          \
+   PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype,                     \
+   fd,                                                           \
+   pb_delta(st, which_##u, m),                                   \
+   pb_membersize(st, m),                                         \
+   0,                                                            \
+   ptr}
+
+#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
+  {tag,                                                           \
+   PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype,                     \
+   fd,                                                            \
+   pb_delta(st, which_##u, m),                                    \
+   pb_membersize(st, m[0]),                                       \
+   0,                                                             \
+   ptr}
 
 #define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation,  \
                                  placement, message, field, prevfield, ptr) \
diff --git a/apps/nearby/third_party/nanopb/pb_encode.h b/apps/nearby/third_party/nanopb/pb_encode.h
index d2921907..9700d5e9 100644
--- a/apps/nearby/third_party/nanopb/pb_encode.h
+++ b/apps/nearby/third_party/nanopb/pb_encode.h
@@ -107,11 +107,9 @@ pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
  *    printf("Message size is %d\n", stream.bytes_written);
  */
 #ifndef PB_NO_ERRMSG
-#define PB_OSTREAM_SIZING \
-  { 0, 0, 0, 0, 0 }
+#define PB_OSTREAM_SIZING {0, 0, 0, 0, 0}
 #else
-#define PB_OSTREAM_SIZING \
-  { 0, 0, 0, 0 }
+#define PB_OSTREAM_SIZING {0, 0, 0, 0}
 #endif
 
 /* Function to write into a pb_ostream_t stream. You can use this if you need
diff --git a/apps/power_test/common/include/generated/chre_power_test_generated.h b/apps/power_test/common/generated/include/generated/chre_power_test_generated.h
similarity index 100%
rename from apps/power_test/common/include/generated/chre_power_test_generated.h
rename to apps/power_test/common/generated/include/generated/chre_power_test_generated.h
diff --git a/apps/power_test/common/idl/update.sh b/apps/power_test/common/idl/update.sh
index c207f14a..c349b60d 100755
--- a/apps/power_test/common/idl/update.sh
+++ b/apps/power_test/common/idl/update.sh
@@ -7,7 +7,7 @@ exit
 fi
 
 # Generate the CHRE-side header file
-flatc --cpp -o ../include/generated/ --scoped-enums \
+flatc --cpp -o ../generated/include/generated/ --scoped-enums \
   --cpp-ptr-type chre::UniquePtr chre_power_test.fbs
 
 # Generate the AP-side header file with some extra goodies
diff --git a/apps/power_test/common/power_test.mk b/apps/power_test/common/power_test.mk
index e287c66d..de681c2b 100644
--- a/apps/power_test/common/power_test.mk
+++ b/apps/power_test/common/power_test.mk
@@ -22,6 +22,7 @@ NANOAPP_VERSION = 0x00020000
 
 # Include paths.
 COMMON_CFLAGS += -I$(CHRE_PREFIX)/apps/power_test/common/include
+COMMON_CFLAGS += -I$(CHRE_PREFIX)/apps/power_test/common/generated/include
 COMMON_CFLAGS += -I$(CHRE_PREFIX)/external/flatbuffers/include
 COMMON_CFLAGS += -I$(CHRE_PREFIX)/util/include
 
diff --git a/apps/test/chqts/src/busy_startup/busy_startup.cc b/apps/test/chqts/src/busy_startup/busy_startup.cc
index 79443f9b..6bf3286c 100644
--- a/apps/test/chqts/src/busy_startup/busy_startup.cc
+++ b/apps/test/chqts/src/busy_startup/busy_startup.cc
@@ -46,6 +46,7 @@
 
 #include <chre/util/nanoapp/log.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/test_success_marker.h>
 #include <shared/time_util.h>
@@ -54,8 +55,7 @@
 #define LOG_TAG "[BusyStartup]"
 
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
-using nanoapp_testing::sendFatalFailureToHostUint8;
+
 using nanoapp_testing::sendMessageToHost;
 using nanoapp_testing::sendSuccessToHost;
 using nanoapp_testing::TestSuccessMarker;
@@ -84,23 +84,23 @@ constexpr uint16_t kEventType = CHRE_EVENT_FIRST_USER_VALUE;
 static void checkSelfEvent(uint16_t eventType, const uint32_t *eventData) {
   if (eventType != kEventType) {
     uint32_t e = eventType;
-    sendFatalFailureToHost("Event from self, bad event type:", &e);
+    EXPECT_FAIL_RETURN("Event from self, bad event type:", &e);
   }
   if (eventData == nullptr) {
-    sendFatalFailureToHost("Event from self, null data");
+    EXPECT_FAIL_RETURN("Event from self, null data");
   }
   if (*eventData != gInstanceId) {
-    sendFatalFailureToHost("Event from self, bad data:", eventData);
+    EXPECT_FAIL_RETURN("Event from self, bad data:", eventData);
   }
   gTestSuccessMarker.markStageAndSuccessOnFinish(BUSY_STARTUP_STAGE_SELF_EVENT);
 }
 
 static void checkTimerEvent(const uint32_t *eventData) {
   if (eventData == nullptr) {
-    sendFatalFailureToHost("TimerEvent, null data");
+    EXPECT_FAIL_RETURN("TimerEvent, null data");
   }
   if (*eventData != gInstanceId) {
-    sendFatalFailureToHost("TimerEvent, bad data:", eventData);
+    EXPECT_FAIL_RETURN("TimerEvent, bad data:", eventData);
   }
   gTestSuccessMarker.markStageAndSuccessOnFinish(BUSY_STARTUP_STAGE_TIMER);
 }
@@ -109,26 +109,25 @@ static void checkSensorEvent(const void *eventData) {
   const chreSensorDataHeader *header =
       static_cast<const chreSensorDataHeader *>(eventData);
   if (header == nullptr) {
-    sendFatalFailureToHost("sensorEvent, null data");
+    EXPECT_FAIL_RETURN("sensorEvent, null data");
   }
   if (header->sensorHandle != gSensorHandle) {
-    sendFatalFailureToHost("sensorEvent for wrong handle",
-                           &header->sensorHandle);
+    EXPECT_FAIL_RETURN("sensorEvent for wrong handle", &header->sensorHandle);
   }
   if (header->readingCount == 0) {
-    sendFatalFailureToHost("sensorEvent has readingCount of 0");
+    EXPECT_FAIL_RETURN("sensorEvent has readingCount of 0");
   }
   if (header->reserved != 0) {
-    sendFatalFailureToHost("sensorEvent has non-zero reserved field");
+    EXPECT_FAIL_RETURN("sensorEvent has non-zero reserved field");
   }
 
   if (chreGetApiVersion() < CHRE_API_VERSION_1_3) {
     if (header->accuracy != 0) {
-      sendFatalFailureToHost("sensorEvent has non-zero reserved field");
+      EXPECT_FAIL_RETURN("sensorEvent has non-zero reserved field");
     }
   } else if (header->accuracy > CHRE_SENSOR_ACCURACY_HIGH) {
-    sendFatalFailureToHostUint8("Sensor accuracy is not within valid range: ",
-                                header->accuracy);
+    EXPECT_FAIL_RETURN_UINT8("Sensor accuracy is not within valid range: ",
+                             header->accuracy);
   }
 
   gTestSuccessMarker.markStageAndSuccessOnFinish(BUSY_STARTUP_STAGE_SENSOR);
@@ -137,7 +136,7 @@ static void checkSensorEvent(const void *eventData) {
 extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
                                    uint16_t eventType, const void *eventData) {
   if (gInMethod) {
-    sendFatalFailureToHost("CHRE reentered nanoapp");
+    EXPECT_FAIL_RETURN("CHRE reentered nanoapp");
   }
   gInMethod = true;
   const uint32_t *intData = static_cast<const uint32_t *>(eventData);
@@ -155,10 +154,10 @@ extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
       // sensor.  We just ignore it.
     } else {
       uint32_t e = eventType;
-      sendFatalFailureToHost("Unexpected event from CHRE:", &e);
+      EXPECT_FAIL_RETURN("Unexpected event from CHRE:", &e);
     }
   } else {
-    sendFatalFailureToHost("Unexpected senderInstanceId", &senderInstanceId);
+    EXPECT_FAIL_RETURN("Unexpected senderInstanceId", &senderInstanceId);
   }
   gInMethod = false;
 }
@@ -222,12 +221,12 @@ extern "C" bool nanoappStart(void) {
 extern "C" void nanoappEnd(void) {
   if (!chreSensorConfigureModeOnly(gSensorHandle,
                                    CHRE_SENSOR_CONFIGURE_MODE_DONE)) {
-    sendFatalFailureToHost("Unable to configure sensor mode to DONE");
+    EXPECT_FAIL_RETURN("Unable to configure sensor mode to DONE");
   }
 
   if (gInMethod) {
     // This message won't be noticed by the host; but hopefully the
     // fatal failure prevents a clean unload of the app and fails the test.
-    sendFatalFailureToHost("nanoappEnd called in reentrant manner");
+    EXPECT_FAIL_RETURN("nanoappEnd called in reentrant manner");
   }
 }
diff --git a/apps/test/chqts/src/echo_message/echo_message.cc b/apps/test/chqts/src/echo_message/echo_message.cc
index f5911389..e35ea256 100644
--- a/apps/test/chqts/src/echo_message/echo_message.cc
+++ b/apps/test/chqts/src/echo_message/echo_message.cc
@@ -25,6 +25,7 @@
 #include <cstdint>
 #include <cstring>
 
+#include <shared/macros.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
 
@@ -34,8 +35,6 @@
 namespace chre {
 namespace {
 
-using nanoapp_testing::sendFatalFailureToHost;
-
 void messageFreeCallback(void *message, size_t size) {
   UNUSED_VAR(size);
 
@@ -48,13 +47,13 @@ extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
     auto *msg = static_cast<const chreMessageFromHostData *>(eventData);
 
     if (senderInstanceId != CHRE_INSTANCE_ID) {
-      sendFatalFailureToHost("Invalid sender instance ID:", &senderInstanceId);
+      EXPECT_FAIL_RETURN("Invalid sender instance ID:", &senderInstanceId);
     }
 
     uint8_t *messageBuffer =
         static_cast<uint8_t *>(chreHeapAlloc(msg->messageSize));
     if (msg->messageSize != 0 && messageBuffer == nullptr) {
-      sendFatalFailureToHost("Failed to allocate memory for message buffer");
+      EXPECT_FAIL_RETURN("Failed to allocate memory for message buffer");
     }
 
     std::memcpy(static_cast<void *>(messageBuffer),
@@ -63,7 +62,7 @@ extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
     if (!chreSendMessageToHostEndpoint(
             static_cast<void *>(messageBuffer), msg->messageSize,
             msg->messageType, msg->hostEndpoint, messageFreeCallback)) {
-      sendFatalFailureToHost("Failed to send message to host");
+      EXPECT_FAIL_RETURN("Failed to send message to host");
     }
   }
 }
diff --git a/apps/test/chqts/src/general_test/app.cc b/apps/test/chqts/src/general_test/app.cc
index a3095487..43e52555 100644
--- a/apps/test/chqts/src/general_test/app.cc
+++ b/apps/test/chqts/src/general_test/app.cc
@@ -52,6 +52,7 @@
 #include <general_test/wwan_capabilities_test.h>
 #include <general_test/wwan_cell_info_test.h>
 #include <shared/abort.h>
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
@@ -60,7 +61,7 @@
 
 using nanoapp_testing::AbortBlame;
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendInternalFailureToHost;
 
 namespace general_test {
@@ -135,7 +136,7 @@ chreMessageFromHostData App::adjustHostMessageForNYC(
   chreMessageFromHostData ret;
 
   if (data->messageSize < sizeof(uint32_t)) {
-    sendFatalFailureToHost("Undersized message in adjustHostMessageForNYC");
+    sendInternalFailureToHost("Undersized message in adjustHostMessageForNYC");
   }
   const uint8_t *messageBytes = static_cast<const uint8_t *>(data->message);
   nanoapp_testing::memcpy(&(ret.reservedMessageType), messageBytes,
@@ -170,12 +171,12 @@ void App::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
   // us which test to run.  We fail if it's anything else.
   if (eventType != CHRE_EVENT_MESSAGE_FROM_HOST) {
     uint32_t localEventType = eventType;
-    sendFatalFailureToHost("Unexpected event type with no established test:",
-                           &localEventType);
+    EXPECT_FAIL_RETURN("Unexpected event type with no established test:",
+                       &localEventType);
   }
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("Got MESSAGE_FROM_HOST not from CHRE_INSTANCE_ID:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("Got MESSAGE_FROM_HOST not from CHRE_INSTANCE_ID:",
+                       &senderInstanceId);
   }
   createTest(eventData);
 }
@@ -238,8 +239,8 @@ void App::createTest(const void *eventData) {
 #undef CASE
 
     default:
-      sendFatalFailureToHost("Unexpected message type:",
-                             &(data->reservedMessageType));
+      EXPECT_FAIL_RETURN("Unexpected message type:",
+                         &(data->reservedMessageType));
   }
 
   if (mCurrentTest != nullptr) {
diff --git a/apps/test/chqts/src/general_test/basic_audio_test.cc b/apps/test/chqts/src/general_test/basic_audio_test.cc
index 6c2b7a02..48a28574 100644
--- a/apps/test/chqts/src/general_test/basic_audio_test.cc
+++ b/apps/test/chqts/src/general_test/basic_audio_test.cc
@@ -21,6 +21,7 @@
 
 #include <general_test/basic_audio_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/time_util.h>
 
@@ -30,7 +31,7 @@ using chre::test_shared::checkAudioSamplesAllSame;
 using chre::test_shared::checkAudioSamplesAllZeros;
 
 using nanoapp_testing::kOneSecondInNanoseconds;
-using nanoapp_testing::sendFatalFailureToHost;
+using nanoapp_testing::sendFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -112,19 +113,19 @@ bool validateAudioSource(uint32_t handle,
                          const struct chreAudioSource &source) {
   bool valid = false;
   if (!verifyStringWithLength(source.name, CHRE_AUDIO_SOURCE_NAME_MAX_SIZE)) {
-    sendFatalFailureToHost("Invalid audio source name for handle ", &handle);
+    sendFailureToHost("Invalid audio source name for handle ", &handle);
   } else if (source.sampleRate > kMaxAudioSampleRate ||
              source.sampleRate < kMinAudioSampleRate) {
-    sendFatalFailureToHost("Invalid audio sample rate for handle ", &handle);
+    sendFailureToHost("Invalid audio sample rate for handle ", &handle);
   } else if (source.minBufferDuration < kMinBufferDuration ||
              source.minBufferDuration > kMaxBufferDuration) {
-    sendFatalFailureToHost("Invalid min buffer duration for handle ", &handle);
+    sendFailureToHost("Invalid min buffer duration for handle ", &handle);
   } else if (source.maxBufferDuration < kMinBufferDuration ||
              source.maxBufferDuration > kMaxBufferDuration) {
-    sendFatalFailureToHost("Invalid max buffer duration for handle ", &handle);
+    sendFailureToHost("Invalid max buffer duration for handle ", &handle);
   } else if (source.format != CHRE_AUDIO_DATA_FORMAT_8_BIT_U_LAW &&
              source.format != CHRE_AUDIO_DATA_FORMAT_16_BIT_SIGNED_PCM) {
-    sendFatalFailureToHost("Invalid audio format for handle ", &handle);
+    sendFailureToHost("Invalid audio format for handle ", &handle);
   } else {
     valid = true;
   }
@@ -159,7 +160,7 @@ void validateAudioSources() {
     if (sourceFound) {
       validHandleCount++;
       if (!previousSourceFound) {
-        sendFatalFailureToHost("Gap detected in audio handles at ", &handle);
+        EXPECT_FAIL_RETURN("Gap detected in audio handles at ", &handle);
       } else {
         bool valid = validateAudioSource(handle, audioSource);
         if (valid && !minimumRequirementMet) {
@@ -173,12 +174,11 @@ void validateAudioSources() {
 
   if (validHandleCount > 0) {
     if (!minimumRequirementMet) {
-      sendFatalFailureToHost(
-          "Failed to meet minimum audio source requirements");
+      EXPECT_FAIL_RETURN("Failed to meet minimum audio source requirements");
     }
 
     if (validHandleCount == kMaxAudioSources) {
-      sendFatalFailureToHost("System is reporting too many audio sources");
+      EXPECT_FAIL_RETURN("System is reporting too many audio sources");
     }
   }
 }
@@ -192,11 +192,11 @@ void requestAudioData() {
   struct chreAudioSource audioSource;
 
   if (!chreAudioGetSource(kAudioHandle, &audioSource)) {
-    sendFatalFailureToHost("Failed to query source for handle 0");
+    EXPECT_FAIL_RETURN("Failed to query source for handle 0");
   } else if (!chreAudioConfigureSource(kAudioHandle, true /* enable */,
                                        audioSource.minBufferDuration,
                                        audioSource.minBufferDuration)) {
-    sendFatalFailureToHost("Failed to request audio data for handle 0");
+    EXPECT_FAIL_RETURN("Failed to request audio data for handle 0");
   }
 }
 
@@ -208,15 +208,15 @@ void handleAudioDataEvent(const chreAudioDataEvent *dataEvent) {
   static uint8_t numDataEventsSoFar = 1;
 
   if (dataEvent == nullptr) {
-    sendFatalFailureToHost("Null event data");
+    EXPECT_FAIL_RETURN("Null event data");
   } else if (dataEvent->samplesS16 == nullptr) {
-    sendFatalFailureToHost("Null audio data frame");
+    EXPECT_FAIL_RETURN("Null audio data frame");
   } else if (dataEvent->sampleCount == 0) {
-    sendFatalFailureToHost("0 samples in audio data frame");
+    EXPECT_FAIL_RETURN("0 samples in audio data frame");
   } else {
     struct chreAudioSource audioSource;
     if (!chreAudioGetSource(kAudioHandle, &audioSource)) {
-      sendFatalFailureToHost("Failed to get audio source for handle 0");
+      EXPECT_FAIL_RETURN("Failed to get audio source for handle 0");
     } else {
       // Per the CHRE Audio API requirements, it is expected that we exactly
       // the number of samples that we ask for - we verify that here.
@@ -230,25 +230,25 @@ void handleAudioDataEvent(const chreAudioDataEvent *dataEvent) {
             (kNumSamplesExpected > dataEvent->sampleCount)
                 ? (kNumSamplesExpected - dataEvent->sampleCount)
                 : (dataEvent->sampleCount - kNumSamplesExpected);
-        sendFatalFailureToHost("Unexpected number of samples received",
-                               &sampleCountDifference);
+        EXPECT_FAIL_RETURN("Unexpected number of samples received",
+                           &sampleCountDifference);
       }
     }
   }
 
   if (!checkAudioSamplesAllZeros(dataEvent->samplesS16,
                                  dataEvent->sampleCount)) {
-    sendFatalFailureToHost("All audio samples were zeros");
+    EXPECT_FAIL_RETURN("All audio samples were zeros");
   } else if (!checkAudioSamplesAllSame(dataEvent->samplesS16,
                                        dataEvent->sampleCount)) {
-    sendFatalFailureToHost("All audio samples were identical");
+    EXPECT_FAIL_RETURN("All audio samples were identical");
   }
 
   if (numDataEventsSoFar == 2) {
     if (!chreAudioConfigureSource(kAudioHandle, false /* enable */,
                                   0 /* bufferDuration */,
                                   0 /* deliveryInterval */)) {
-      sendFatalFailureToHost("Failed to disable audio source for handle 0");
+      EXPECT_FAIL_RETURN("Failed to disable audio source for handle 0");
     } else {
       sendSuccessToHost();
     }
@@ -271,8 +271,8 @@ BasicAudioTest::BasicAudioTest()
 
 void BasicAudioTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Beginning message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Beginning message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   if (!isAudioSupported()) {
@@ -292,7 +292,7 @@ void BasicAudioTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
   UNUSED_VAR(senderInstanceId);
 
   if (mInMethod) {
-    sendFatalFailureToHost("handleEvent() invoked while already in method.");
+    EXPECT_FAIL_RETURN("handleEvent() invoked while already in method.");
   }
 
   mInMethod = true;
diff --git a/apps/test/chqts/src/general_test/basic_ble_test.cc b/apps/test/chqts/src/general_test/basic_ble_test.cc
index e27432f0..48545a66 100644
--- a/apps/test/chqts/src/general_test/basic_ble_test.cc
+++ b/apps/test/chqts/src/general_test/basic_ble_test.cc
@@ -15,6 +15,7 @@
  */
 
 #include <general_test/basic_ble_test.h>
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre/util/nanoapp/ble.h"
@@ -30,7 +31,6 @@ namespace general_test {
 
 using chre::createBleScanFilterForKnownBeacons;
 using chre::ble_constants::kNumScanFilters;
-using nanoapp_testing::sendFatalFailureToHost;
 
 namespace {
 const uint32_t gFlushCookie = 0;
@@ -50,7 +50,7 @@ void testScanSessionAsync(bool supportsBatching, bool supportsFiltering) {
   if (!chreBleStartScanAsync(CHRE_BLE_SCAN_MODE_FOREGROUND /* mode */,
                              reportDelayMs,
                              supportsFiltering ? &filter : nullptr)) {
-    sendFatalFailureToHost("Failed to start a BLE scan in the foreground");
+    EXPECT_FAIL_RETURN("Failed to start a BLE scan in the foreground");
   }
 }
 
@@ -61,8 +61,8 @@ BasicBleTest::BasicBleTest()
 
 void BasicBleTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Expected 0 byte message, got more bytes:",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   }
 
   mSupportsBatching =
@@ -85,13 +85,13 @@ void BasicBleTest::setUp(uint32_t messageSize, const void * /* message */) {
 
 void BasicBleTest::handleBleAsyncResult(const chreAsyncResult *result) {
   if (result == nullptr) {
-    sendFatalFailureToHost("Received null BLE async result");
+    EXPECT_FAIL_RETURN("Received null BLE async result");
     return;
   }
   if (!result->success) {
     LOGE("Received unsuccessful BLE async result, error code %" PRIu8,
          result->errorCode);
-    sendFatalFailureToHost("Received unsuccessful BLE async result");
+    EXPECT_FAIL_RETURN("Received unsuccessful BLE async result");
     return;
   }
 
@@ -101,20 +101,20 @@ void BasicBleTest::handleBleAsyncResult(const chreAsyncResult *result) {
       // and be verified by handleAdvertisementEvent.
       if (chreTimerSet(chre::kOneSecondInNanoseconds, nullptr, true) ==
           CHRE_TIMER_INVALID) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "Failed to start a timer after BLE started scanning");
       }
       break;
     case CHRE_BLE_REQUEST_TYPE_FLUSH:
       if (result->cookie != &gFlushCookie) {
-        sendFatalFailureToHost("Cookie values do not match");
+        EXPECT_FAIL_RETURN("Cookie values do not match");
       }
       break;
     case CHRE_BLE_REQUEST_TYPE_STOP_SCAN:
       mTestSuccessMarker.markStageAndSuccessOnFinish(BASIC_BLE_TEST_STAGE_SCAN);
       break;
     default:
-      sendFatalFailureToHost("Unexpected request type");
+      EXPECT_FAIL_RETURN("Unexpected request type");
       break;
   }
 }
@@ -122,18 +122,18 @@ void BasicBleTest::handleBleAsyncResult(const chreAsyncResult *result) {
 void BasicBleTest::handleAdvertisementEvent(
     const chreBleAdvertisementEvent *event) {
   if (event == nullptr) {
-    sendFatalFailureToHost("Invalid chreBleAdvertisementEvent");
+    EXPECT_FAIL_RETURN("Invalid chreBleAdvertisementEvent");
   } else if (event->reserved != kGoodReservedValue) {
-    sendFatalFailureToHost("chreBleAdvertisementEvent: reserved != 0");
+    EXPECT_FAIL_RETURN("chreBleAdvertisementEvent: reserved != 0");
   } else {
     for (uint16_t i = 0; i < event->numReports; ++i) {
       const struct chreBleAdvertisingReport &report = event->reports[i];
       if (report.advertisingSid != CHRE_BLE_ADI_NONE &&
           report.advertisingSid > kMaxReportAdvertisingSid) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "chreBleAdvertisingReport: advertisingSid is invalid");
       } else if (report.reserved != kGoodReservedValue) {
-        sendFatalFailureToHost("chreBleAdvertisingReport: reserved is invalid");
+        EXPECT_FAIL_RETURN("chreBleAdvertisingReport: reserved is invalid");
       }
     }
   }
@@ -142,17 +142,17 @@ void BasicBleTest::handleAdvertisementEvent(
 void BasicBleTest::handleTimerEvent() {
   if (mSupportsBatching) {
     if (!chreBleFlushAsync(&gFlushCookie)) {
-      sendFatalFailureToHost("Failed to BLE flush");
+      EXPECT_FAIL_RETURN("Failed to BLE flush");
     }
     mFlushWasCalled = true;
   } else {
     if (chreBleFlushAsync(&gFlushCookie)) {
-      sendFatalFailureToHost(
+      EXPECT_FAIL_RETURN(
           "chreBleFlushAsync should return false if batching is not supported");
     }
 
     if (!chreBleStopScanAsync()) {
-      sendFatalFailureToHost("Failed to stop a BLE scan session");
+      EXPECT_FAIL_RETURN("Failed to stop a BLE scan session");
     }
   }
 }
@@ -165,12 +165,12 @@ void BasicBleTest::handleEvent(uint32_t /* senderInstanceId */,
       break;
     case CHRE_EVENT_BLE_FLUSH_COMPLETE:
       if (!mFlushWasCalled) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "Received CHRE_EVENT_BLE_FLUSH_COMPLETE event when "
             "chreBleFlushAsync was not called");
       }
       if (!chreBleStopScanAsync()) {
-        sendFatalFailureToHost("Failed to stop a BLE scan session");
+        EXPECT_FAIL_RETURN("Failed to stop a BLE scan session");
       }
       mTestSuccessMarker.markStageAndSuccessOnFinish(
           BASIC_BLE_TEST_STAGE_FLUSH);
diff --git a/apps/test/chqts/src/general_test/basic_flush_async_test.cc b/apps/test/chqts/src/general_test/basic_flush_async_test.cc
index 5e44df56..f8bfd5c0 100644
--- a/apps/test/chqts/src/general_test/basic_flush_async_test.cc
+++ b/apps/test/chqts/src/general_test/basic_flush_async_test.cc
@@ -29,7 +29,7 @@
 
 using nanoapp_testing::kOneMillisecondInNanoseconds;
 using nanoapp_testing::kOneSecondInNanoseconds;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -43,15 +43,15 @@ void BasicSensorFlushAsyncTest::setUp(uint32_t messageSize,
       kFlushTestLatencyNs / 2;  // start the test at (now + 1/2*latency)
 
   if (messageSize != 0) {
-    sendFatalFailureToHost("Expected 0 byte message, got more bytes:",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   }
 
   // TODO: Generalize this test for all sensors by making
   // BasicSensorFlushAsyncTest a base class for sensor specific tests for the
   // FlushAsync API
   if (!chreSensorFindDefault(CHRE_SENSOR_TYPE_ACCELEROMETER, &mSensorHandle)) {
-    sendFatalFailureToHost("Default Accelerometer not found");
+    EXPECT_FAIL_RETURN("Default Accelerometer not found");
   }
 
   // We set the sampling period of the sensor to 2x the min interval,
@@ -60,13 +60,13 @@ void BasicSensorFlushAsyncTest::setUp(uint32_t messageSize,
   // 'wiggle room' from when we start the flush request.
   struct chreSensorInfo info;
   if (!chreGetSensorInfo(mSensorHandle, &info)) {
-    sendFatalFailureToHost("Failed to get sensor info");
+    EXPECT_FAIL_RETURN("Failed to get sensor info");
   }
   mFlushTestTimeWiggleRoomNs = 20 * info.minInterval;
 
   if (!chreSensorConfigure(mSensorHandle, CHRE_SENSOR_CONFIGURE_MODE_CONTINUOUS,
                            2 * info.minInterval, kFlushTestLatencyNs)) {
-    sendFatalFailureToHost("Failed to configure the accelerometer");
+    EXPECT_FAIL_RETURN("Failed to configure the accelerometer");
   }
 
   // To exercise the test, we need to confirm that we actually get sensor
@@ -78,7 +78,7 @@ void BasicSensorFlushAsyncTest::setUp(uint32_t messageSize,
       chreTimerSet(kFlushTestStartTimerValueNs, &mFlushStartTimerHandle,
                    true /* one shot */);
   if (CHRE_TIMER_INVALID == mFlushStartTimerHandle) {
-    sendFatalFailureToHost("Failed to set flush start timer");
+    EXPECT_FAIL_RETURN("Failed to set flush start timer");
   }
 }
 
@@ -119,7 +119,7 @@ void BasicSensorFlushAsyncTest::start() {
       chreTimerSet(CHRE_SENSOR_FLUSH_COMPLETE_TIMEOUT_NS,
                    &mFlushTimeoutTimerHandle, true /* oneShot */);
   if (CHRE_TIMER_INVALID == mFlushTimeoutTimerHandle) {
-    sendFatalFailureToHost("Failed to set flush start timer");
+    EXPECT_FAIL_RETURN("Failed to set flush start timer");
   }
 }
 
@@ -132,12 +132,13 @@ void BasicSensorFlushAsyncTest::finish(bool succeeded, const char *message) {
 
   if (!chreSensorConfigureModeOnly(mSensorHandle,
                                    CHRE_SENSOR_CONFIGURE_MODE_DONE)) {
-    sendFatalFailureToHost("Failed to release sensor handle");
+    EXPECT_FAIL_RETURN("Failed to release sensor handle");
   }
 
   if (!succeeded) {
-    ASSERT_NE(message, nullptr, "message cannot be null when the test failed");
-    sendFatalFailureToHost(message);
+    EXPECT_NE_OR_RETURN(message, nullptr,
+                        "message cannot be null when the test failed");
+    EXPECT_FAIL_RETURN(message);
   } else {
     sendSuccessToHost();
   }
@@ -155,7 +156,8 @@ void BasicSensorFlushAsyncTest::handleDataReceived(
 void BasicSensorFlushAsyncTest::handleFlushComplete(
     const struct chreSensorFlushCompleteEvent *eventData) {
   if (mStarted) {
-    ASSERT_NE(mLatestSensorDataTimestamp, 0, "No sensor data was received");
+    EXPECT_NE_OR_RETURN(mLatestSensorDataTimestamp, 0,
+                        "No sensor data was received");
 
     // we should fail the test if we receive too old a sensor sample.
     // ideally, we don't receive any samples that was sampled after
@@ -165,22 +167,22 @@ void BasicSensorFlushAsyncTest::handleFlushComplete(
     uint64_t oldestValidTimestamp =
         mFlushRequestTime - mFlushTestTimeWiggleRoomNs;
 
-    ASSERT_GE(mLatestSensorDataTimestamp, oldestValidTimestamp,
-              "Received very old data");
+    EXPECT_GE_OR_RETURN(mLatestSensorDataTimestamp, oldestValidTimestamp,
+                        "Received very old data");
 
     LOGI("Flush test: flush request to complete time: %" PRIu64 " ms",
          (chreGetTime() - mFlushRequestTime) / kOneMillisecondInNanoseconds);
 
     // verify event data
-    ASSERT_NE(eventData, nullptr, "null event data");
-    ASSERT_EQ(eventData->sensorHandle, mSensorHandle,
-              "Got flush event from a different sensor handle");
-    ASSERT_EQ(eventData->errorCode, CHRE_ERROR_NONE,
-              "Flush Error code was not CHRE_ERROR_NONE");
-    ASSERT_NE(eventData->cookie, nullptr,
-              "Null cookie in flush complete event");
-    ASSERT_EQ(*(static_cast<const uint32_t *>(eventData->cookie)), mCookie,
-              "unexpected cookie in flush complete event");
+    EXPECT_NE_OR_RETURN(eventData, nullptr, "null event data");
+    EXPECT_EQ_OR_RETURN(eventData->sensorHandle, mSensorHandle,
+                        "Got flush event from a different sensor handle");
+    EXPECT_EQ_OR_RETURN(eventData->errorCode, CHRE_ERROR_NONE,
+                        "Flush Error code was not CHRE_ERROR_NONE");
+    EXPECT_NE_OR_RETURN(eventData->cookie, nullptr,
+                        "Null cookie in flush complete event");
+    EXPECT_EQ_OR_RETURN(*(static_cast<const uint32_t *>(eventData->cookie)),
+                        mCookie, "unexpected cookie in flush complete event");
 
     finish(true /* succeeded */, nullptr /* message */);
   }
@@ -195,10 +197,10 @@ void BasicSensorFlushAsyncTest::handleTimerExpired(
       finish(false /* succeeded */,
              "Did not receive flush complete event in time");
     } else {
-      sendFatalFailureToHost("Unexpected timer handle received");
+      EXPECT_FAIL_RETURN("Unexpected timer handle received");
     }
   } else {
-    sendFatalFailureToHost("Null timer handle received");
+    EXPECT_FAIL_RETURN("Null timer handle received");
   }
 }
 
diff --git a/apps/test/chqts/src/general_test/basic_gnss_test.cc b/apps/test/chqts/src/general_test/basic_gnss_test.cc
index 6e4be8da..61133ff6 100644
--- a/apps/test/chqts/src/general_test/basic_gnss_test.cc
+++ b/apps/test/chqts/src/general_test/basic_gnss_test.cc
@@ -16,10 +16,13 @@
 
 #include <general_test/basic_gnss_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
+using nanoapp_testing::sendFailureToHost;
+
 /*
  * Test to check expected functionality of the CHRE GNSS APIs.
  */
@@ -27,29 +30,27 @@ namespace general_test {
 
 namespace {
 
-using nanoapp_testing::sendFatalFailureToHost;
-
 void testLocationSessionAsync() {
   if (!chreGnssLocationSessionStartAsync(1000 /* minIntervalMs */,
                                          0 /* minTimeToNextFixMs */,
                                          nullptr /* cookie */)) {
-    sendFatalFailureToHost("Failed to start a location session");
+    EXPECT_FAIL_RETURN("Failed to start a location session");
   }
 }
 
 void testMeasurementSessionAsync() {
   if (!chreGnssMeasurementSessionStartAsync(1000 /* minIntervalMs */,
                                             nullptr /* cookie */)) {
-    sendFatalFailureToHost("Failed to start a measurement session");
+    EXPECT_FAIL_RETURN("Failed to start a measurement session");
   }
 }
 
 bool testPassiveListener() {
   bool success = false;
   if (!chreGnssConfigurePassiveLocationListener(true /* enable */)) {
-    sendFatalFailureToHost("Failed to enable passive location listener");
+    sendFailureToHost("Failed to enable passive location listener");
   } else if (!chreGnssConfigurePassiveLocationListener(false /* enable */)) {
-    sendFatalFailureToHost("Failed to disable passive location listener");
+    sendFailureToHost("Failed to disable passive location listener");
   } else {
     success = true;
   }
@@ -63,8 +64,8 @@ BasicGnssTest::BasicGnssTest() : Test(CHRE_API_VERSION_1_1) {}
 
 void BasicGnssTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Expected 0 byte message, got more bytes:",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     if (isCapabilitySet(CHRE_GNSS_CAPABILITIES_LOCATION)) {
       testLocationSessionAsync();
@@ -93,13 +94,13 @@ void BasicGnssTest::setUp(uint32_t messageSize, const void * /* message */) {
 
 void BasicGnssTest::handleGnssAsyncResult(const chreAsyncResult *result) {
   if (!result->success) {
-    sendFatalFailureToHost("Received unsuccessful GNSS async result");
+    EXPECT_FAIL_RETURN("Received unsuccessful GNSS async result");
   }
 
   switch (result->requestType) {
     case CHRE_GNSS_REQUEST_TYPE_LOCATION_SESSION_START: {
       if (!chreGnssLocationSessionStopAsync(nullptr /* cookie */)) {
-        sendFatalFailureToHost("Failed to stop a location session");
+        EXPECT_FAIL_RETURN("Failed to stop a location session");
       }
       break;
     }
@@ -110,7 +111,7 @@ void BasicGnssTest::handleGnssAsyncResult(const chreAsyncResult *result) {
     }
     case CHRE_GNSS_REQUEST_TYPE_MEASUREMENT_SESSION_START: {
       if (!chreGnssMeasurementSessionStopAsync(nullptr /* cookie */)) {
-        sendFatalFailureToHost("Failed to stop a measurement session");
+        EXPECT_FAIL_RETURN("Failed to stop a measurement session");
       }
       break;
     }
@@ -120,7 +121,7 @@ void BasicGnssTest::handleGnssAsyncResult(const chreAsyncResult *result) {
       break;
     }
     default:
-      sendFatalFailureToHost("Unexpected request type");
+      EXPECT_FAIL_RETURN("Unexpected request type");
       break;
   }
 }
diff --git a/apps/test/chqts/src/general_test/basic_sensor_test_base.cc b/apps/test/chqts/src/general_test/basic_sensor_test_base.cc
index 90284936..127fb99b 100644
--- a/apps/test/chqts/src/general_test/basic_sensor_test_base.cc
+++ b/apps/test/chqts/src/general_test/basic_sensor_test_base.cc
@@ -19,6 +19,7 @@
 #include <cinttypes>
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/time_util.h>
 
@@ -30,8 +31,7 @@
 using nanoapp_testing::kOneMillisecondInNanoseconds;
 using nanoapp_testing::kOneSecondInNanoseconds;
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
-using nanoapp_testing::sendFatalFailureToHostUint8;
+
 using nanoapp_testing::sendInternalFailureToHost;
 using nanoapp_testing::sendStringToHost;
 using nanoapp_testing::sendSuccessToHost;
@@ -75,6 +75,16 @@ bool isBiasEventType(uint16_t eventType) {
          (eventType == CHRE_EVENT_SENSOR_GEOMAGNETIC_FIELD_BIAS_INFO);
 }
 
+// Helper function to call chreSensorConfigure and log the result
+bool configureSensor(uint32_t handle, enum chreSensorConfigureMode mode,
+                     uint64_t intervalNs, uint64_t latencyNs) {
+  bool success = chreSensorConfigure(handle, mode, intervalNs, latencyNs);
+  LOGI("Enabled sensor with handle %" PRIu32 " mode %d interval %" PRIu64
+       " latency %" PRIu64 " success=%d",
+       handle, mode, intervalNs, latencyNs, success);
+  return success;
+}
+
 }  // anonymous namespace
 
 BasicSensorTestBase::BasicSensorTestBase()
@@ -88,8 +98,8 @@ BasicSensorTestBase::BasicSensorTestBase()
 void BasicSensorTestBase::setUp(uint32_t messageSize,
                                 const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Beginning message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Beginning message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   sendStartTestMessage();
@@ -102,7 +112,7 @@ void BasicSensorTestBase::sendStartTestMessage() {
   // test, we don't start until after the class has been fully
   // constructed.
   if (!chreSendEvent(kStartEvent, nullptr, nullptr, mInstanceId)) {
-    sendFatalFailureToHost("Failed chreSendEvent to begin test");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent to begin test");
   }
   mInMethod = false;
 }
@@ -115,14 +125,14 @@ void BasicSensorTestBase::checkPassiveConfigure() {
   if (mApiVersion == CHRE_API_VERSION_1_0) {
     // Any attempt to make a PASSIVE call with a non-default interval
     // or latency should fail.
-    if (chreSensorConfigure(mSensorHandle, mode, CHRE_SENSOR_INTERVAL_DEFAULT,
-                            999)) {
-      sendFatalFailureToHost(
+    if (configureSensor(mSensorHandle, mode, CHRE_SENSOR_INTERVAL_DEFAULT,
+                        999)) {
+      EXPECT_FAIL_RETURN(
           "chreSensorConfigure() allowed passive with different latency");
     }
-    if (chreSensorConfigure(mSensorHandle, mode, 999,
-                            CHRE_SENSOR_LATENCY_DEFAULT)) {
-      sendFatalFailureToHost(
+    if (configureSensor(mSensorHandle, mode, 999,
+                        CHRE_SENSOR_LATENCY_DEFAULT)) {
+      EXPECT_FAIL_RETURN(
           "chreSensorConfigure() allowed passive with different interval");
     }
     // TODO: In a more in-depth test, we should test passive mode
@@ -134,41 +144,41 @@ void BasicSensorTestBase::checkPassiveConfigure() {
     //     the system.
   } else {
     bool configureSuccess =
-        chreSensorConfigure(mSensorHandle, mode, CHRE_SENSOR_INTERVAL_DEFAULT,
-                            kOneSecondInNanoseconds);
+        configureSensor(mSensorHandle, mode, CHRE_SENSOR_INTERVAL_DEFAULT,
+                        kOneSecondInNanoseconds);
     if (mSupportsPassiveMode && !configureSuccess) {
-      sendFatalFailureToHost(
+      EXPECT_FAIL_RETURN(
           "chreSensorConfigure() failed passive with default interval and "
           "non-default latency");
     } else if (!mSupportsPassiveMode && configureSuccess) {
-      sendFatalFailureToHost(
+      EXPECT_FAIL_RETURN(
           "chreSensorConfigure() accepted passive with default interval and "
           "non-default latency");
     }
 
     if (!isOneShotSensor()) {
       configureSuccess =
-          chreSensorConfigure(mSensorHandle, mode, kOneSecondInNanoseconds,
-                              CHRE_SENSOR_LATENCY_DEFAULT);
+          configureSensor(mSensorHandle, mode, kOneSecondInNanoseconds,
+                          CHRE_SENSOR_LATENCY_DEFAULT);
       if (mSupportsPassiveMode && !configureSuccess) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "chreSensorConfigure() failed passive with non-default interval "
             "and default latency");
       } else if (!mSupportsPassiveMode && configureSuccess) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "chreSensorConfigure() accepted passive with non-default "
             "interval and default latency");
       }
 
       configureSuccess =
-          chreSensorConfigure(mSensorHandle, mode, kOneSecondInNanoseconds,
-                              kOneSecondInNanoseconds);
+          configureSensor(mSensorHandle, mode, kOneSecondInNanoseconds,
+                          kOneSecondInNanoseconds);
       if (mSupportsPassiveMode && !configureSuccess) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "chreSensorConfigure() failed passive with non-default interval "
             "and latency");
       } else if (!mSupportsPassiveMode && configureSuccess) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "chreSensorConfigure() accepted passive with non-default interval "
             "and latency");
       }
@@ -188,7 +198,7 @@ void BasicSensorTestBase::startTest() {
     found = chreSensorFind(mSensorType, mCurrentSensorIndex, &mSensorHandle);
     if (!found &&
         chreSensorFind(mSensorType, mCurrentSensorIndex + 1, &mSensorHandle)) {
-      sendFatalFailureToHostUint8("Missing sensor index ", mCurrentSensorIndex);
+      EXPECT_FAIL_RETURN_UINT8("Missing sensor index ", mCurrentSensorIndex);
       return;
     }
   } else {
@@ -205,32 +215,37 @@ void BasicSensorTestBase::startTest() {
 
   chreSensorInfo info;
   if (!chreGetSensorInfo(mSensorHandle, &info)) {
-    sendFatalFailureToHost("GetSensorInfo() call failed");
+    EXPECT_FAIL_RETURN("GetSensorInfo() call failed");
   }
   if (info.sensorName == nullptr) {
-    sendFatalFailureToHost("chreSensorInfo::sensorName is NULL");
+    EXPECT_FAIL_RETURN("chreSensorInfo::sensorName is NULL");
   }
   if (info.sensorType != mSensorType) {
     uint32_t type = info.sensorType;
-    sendFatalFailureToHost(
-        "chreSensorInfo::sensorType is not expected value, is:", &type);
+    EXPECT_FAIL_RETURN("chreSensorInfo::sensorType is not expected value, is:",
+                       &type);
   }
   if (info.isOnChange != isOnChangeSensor()) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "chreSensorInfo::isOnChange is opposite of what we expected");
   }
   if (info.isOneShot != isOneShotSensor()) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "chreSensorInfo::isOneShot is opposite of what we expected");
   }
   if (mApiVersion >= CHRE_API_VERSION_1_4) {
     mSupportsPassiveMode = info.supportsPassiveMode;
   } else if (info.supportsPassiveMode != 0) {
-    sendFatalFailureToHost("chreSensorInfo::supportsPassiveMode should be 0");
+    EXPECT_FAIL_RETURN("chreSensorInfo::supportsPassiveMode should be 0");
   }
 
   if (!chreGetSensorSamplingStatus(mSensorHandle, &mOriginalStatus)) {
-    sendFatalFailureToHost("chreGetSensorSamplingStatus() failed");
+    EXPECT_FAIL_RETURN("chreGetSensorSamplingStatus() failed");
+  } else {
+    LOGI("Original sampling status interval=%" PRIu64 " latency=%" PRIu64
+         " enabled %d",
+         mOriginalStatus.interval, mOriginalStatus.latency,
+         mOriginalStatus.enabled);
   }
 
   // Set the base timestamp to compare against before configuring the sensor.
@@ -246,11 +261,12 @@ void BasicSensorTestBase::startTest() {
                                      ? CHRE_SENSOR_CONFIGURE_MODE_ONE_SHOT
                                      : CHRE_SENSOR_CONFIGURE_MODE_CONTINUOUS;
 
-  if (!chreSensorConfigure(mSensorHandle, mode, mNewStatus.interval,
-                           mNewStatus.latency)) {
-    sendFatalFailureToHost(
+  if (!configureSensor(mSensorHandle, mode, mNewStatus.interval,
+                       mNewStatus.latency)) {
+    EXPECT_FAIL_RETURN(
         "chreSensorConfigure() call failed with default interval and latency");
   }
+
   // handleEvent may start getting events, and our testing continues there.
   // (Note: The CHRE is not allow to call handleEvent() while we're still
   // in this method, so it's not a race to set this state here.)
@@ -272,9 +288,9 @@ void BasicSensorTestBase::startTest() {
 
   // Skip one-shot sensors for non-default interval configurations.
   if (!isOneShotSensor() &&
-      !chreSensorConfigure(mSensorHandle, mode, mNewStatus.interval,
-                           mNewStatus.latency)) {
-    sendFatalFailureToHost("chreSensorConfigure() call failed");
+      !configureSensor(mSensorHandle, mode, mNewStatus.interval,
+                       mNewStatus.latency)) {
+    EXPECT_FAIL_RETURN("chreSensorConfigure() call failed");
   }
 
   if (isOnChangeSensor()) {
@@ -297,25 +313,30 @@ void BasicSensorTestBase::finishTest() {
 
   if (!chreSensorConfigureModeOnly(mSensorHandle,
                                    CHRE_SENSOR_CONFIGURE_MODE_DONE)) {
-    sendFatalFailureToHost("Unable to configure sensor mode to DONE");
+    EXPECT_FAIL_RETURN("Unable to configure sensor mode to DONE");
+  } else {
+    LOGI("Successfully disabled sensor");
   }
   mDoneTimestamp = chreGetTime();
   chreSensorSamplingStatus status;
   if (!chreGetSensorSamplingStatus(mSensorHandle, &status)) {
-    sendFatalFailureToHost("Could not get final sensor info");
+    EXPECT_FAIL_RETURN("Could not get final sensor info");
   }
+  LOGI("Final sampling status interval=%" PRIu64 " latency=%" PRIu64
+       " enabled %d",
+       status.interval, status.latency, status.enabled);
   if (!mExternalSamplingStatusChange) {
     // No one else changed this, so it should be what we had before.
     if (status.enabled != mOriginalStatus.enabled) {
-      sendFatalFailureToHost("SensorInfo.enabled not back to original");
+      EXPECT_FAIL_RETURN("SensorInfo.enabled not back to original");
     }
     // Interval and latency values are only relevent if the sensor is enabled.
     if (status.enabled) {
       if (status.interval != mOriginalStatus.interval) {
-        sendFatalFailureToHost("SensorInfo.interval not back to original");
+        EXPECT_FAIL_RETURN("SensorInfo.interval not back to original");
       }
       if (status.latency != mOriginalStatus.latency) {
-        sendFatalFailureToHost("SensorInfo.latency not back to original");
+        EXPECT_FAIL_RETURN("SensorInfo.latency not back to original");
       }
     }
   }
@@ -347,8 +368,8 @@ void BasicSensorTestBase::verifyEventHeader(const chreSensorDataHeader *header,
                                             uint16_t eventType,
                                             uint64_t eventDuration) {
   if (header->sensorHandle != mSensorHandle) {
-    sendFatalFailureToHost("SensorDataHeader for wrong handle",
-                           &header->sensorHandle);
+    EXPECT_FAIL_RETURN("SensorDataHeader for wrong handle",
+                       &header->sensorHandle);
   }
 
   // Bias and on-change sensor events may have timestamps from before any of our
@@ -388,34 +409,34 @@ void BasicSensorTestBase::verifyEventHeader(const chreSensorDataHeader *header,
            " kEventLoopSlack %" PRIu64,
            header->baseTimestamp, minTimeWithSlack, *minTime, eventDuration,
            kEventLoopSlack);
-      sendFatalFailureToHost("SensorDataHeader is in the past");
+      EXPECT_FAIL_RETURN("SensorDataHeader is in the past");
     }
     if ((mState == State::kFinished) &&
         (header->baseTimestamp > mDoneTimestamp)) {
-      sendFatalFailureToHost("SensorDataHeader is from after DONE");
+      EXPECT_FAIL_RETURN("SensorDataHeader is from after DONE");
     }
     *timeToUpdate = header->baseTimestamp;
   }
 
   if (header->baseTimestamp > chreGetTime()) {
-    sendFatalFailureToHost("SensorDataHeader is in the future");
+    EXPECT_FAIL_RETURN("SensorDataHeader is in the future");
   }
 
   if (header->readingCount == 0) {
-    sendFatalFailureToHost("SensorDataHeader has readingCount of 0");
+    EXPECT_FAIL_RETURN("SensorDataHeader has readingCount of 0");
   }
 
   if (header->reserved != 0) {
-    sendFatalFailureToHost("SensorDataHeader has non-zero reserved field");
+    EXPECT_FAIL_RETURN("SensorDataHeader has non-zero reserved field");
   }
 
   if (mApiVersion < CHRE_API_VERSION_1_3) {
     if (header->accuracy != 0) {
-      sendFatalFailureToHost("SensorDataHeader has non-zero reserved field");
+      EXPECT_FAIL_RETURN("SensorDataHeader has non-zero reserved field");
     }
   } else if (header->accuracy > CHRE_SENSOR_ACCURACY_HIGH) {
-    sendFatalFailureToHostUint8("Sensor accuracy is not within valid range: ",
-                                header->accuracy);
+    EXPECT_FAIL_RETURN_UINT8("Sensor accuracy is not within valid range: ",
+                             header->accuracy);
   }
 }
 
@@ -434,7 +455,7 @@ void BasicSensorTestBase::handleBiasEvent(
   }
 
   if (expectedSensorType != getSensorType()) {
-    sendFatalFailureToHost("Unexpected bias event:", &eType);
+    EXPECT_FAIL_RETURN("Unexpected bias event:", &eType);
   }
   verifyEventHeader(&eventData->header, eventType, getEventDuration(eventData));
 
@@ -444,6 +465,10 @@ void BasicSensorTestBase::handleBiasEvent(
 
 void BasicSensorTestBase::handleSamplingChangeEvent(
     const chreSensorSamplingStatusEvent *eventData) {
+  LOGI("handleSamplingChangeEvent interval=%" PRIu64 " latency=%" PRIu64
+       " enabled=%d",
+       eventData->status.interval, eventData->status.latency,
+       eventData->status.enabled);
   if (mPrevSensorHandle.has_value() &&
       (mPrevSensorHandle.value() == eventData->sensorHandle)) {
     // We can get a "DONE" event from the previous sensor for multi-sensor
@@ -452,18 +477,19 @@ void BasicSensorTestBase::handleSamplingChangeEvent(
   }
 
   if (eventData->sensorHandle != mSensorHandle) {
-    sendFatalFailureToHost("SamplingChangeEvent for wrong sensor handle:",
-                           &eventData->sensorHandle);
+    EXPECT_FAIL_RETURN("SamplingChangeEvent for wrong sensor handle:",
+                       &eventData->sensorHandle);
   }
 
   // TODO: If we strictly define whether this event is or isn't
   //     generated upon being DONE with a sensor, then we can perform
   //     a strict check here.  For now, we just let this go.
   if (mState != State::kFinished) {
-    // Passive sensor requests do not guarantee sensors will always be enabled.
-    // Bypass 'enabled' check for passive configurations.
+    // We received a sensor disabled status change event. While it's not
+    // expected, it's possible we received an event that was originated prior to
+    // the test run, so we just log a warning rather than failing the test.
     if (!eventData->status.enabled) {
-      sendFatalFailureToHost("SamplingChangeEvent disabled the sensor.");
+      LOGW("SamplingChangeEvent disabled the sensor.");
     }
 
     if ((mNewStatus.interval != eventData->status.interval) ||
@@ -478,7 +504,7 @@ void BasicSensorTestBase::handleSamplingChangeEvent(
 void BasicSensorTestBase::handleSensorDataEvent(uint16_t eventType,
                                                 const void *eventData) {
   if ((mState == State::kPreStart) || (mState == State::kPreConfigure)) {
-    sendFatalFailureToHost("SensorDataEvent sent too early.");
+    EXPECT_FAIL_RETURN("SensorDataEvent sent too early.");
   }
   // Note, if mState is kFinished, we could be getting batched data which
   // hadn't been delivered yet at the time we were DONE.  We'll consistency
@@ -505,7 +531,7 @@ void BasicSensorTestBase::handleEvent(uint32_t senderInstanceId,
                                       uint16_t eventType,
                                       const void *eventData) {
   if (mInMethod) {
-    sendFatalFailureToHost("handleEvent() invoked while already in method.");
+    EXPECT_FAIL_RETURN("handleEvent() invoked while already in method.");
   }
   mInMethod = true;
   const uint16_t dataEventType =
@@ -516,11 +542,11 @@ void BasicSensorTestBase::handleEvent(uint32_t senderInstanceId,
       startTest();
     }
   } else if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("Unexpected senderInstanceId:", &senderInstanceId);
+    EXPECT_FAIL_RETURN("Unexpected senderInstanceId:", &senderInstanceId);
 
   } else if (eventData == nullptr) {
     uint32_t eType = eventType;
-    sendFatalFailureToHost("Got NULL eventData for event:", &eType);
+    EXPECT_FAIL_RETURN("Got NULL eventData for event:", &eType);
 
   } else if (eventType == dataEventType) {
     handleSensorDataEvent(eventType, eventData);
diff --git a/apps/test/chqts/src/general_test/basic_sensor_tests.cc b/apps/test/chqts/src/general_test/basic_sensor_tests.cc
index a60f6031..6ca57819 100644
--- a/apps/test/chqts/src/general_test/basic_sensor_tests.cc
+++ b/apps/test/chqts/src/general_test/basic_sensor_tests.cc
@@ -16,18 +16,17 @@
 
 #include <general_test/basic_sensor_tests.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre/util/macros.h"
 
-using nanoapp_testing::sendFatalFailureToHost;
-
 namespace general_test {
 
 static void checkFloat(float value, float extremeLow, float extremeHigh) {
   if ((value < extremeLow) || (value > extremeHigh)) {
     uint32_t i = static_cast<uint32_t>(value);
-    sendFatalFailureToHost("Value beyond extreme.  As int:", &i);
+    EXPECT_FAIL_RETURN("Value beyond extreme.  As int:", &i);
   }
 }
 
@@ -38,8 +37,7 @@ static void checkTimestampDelta(uint32_t delta, size_t index) {
   }
   if (delta == 0) {
     uint32_t indexInt = static_cast<uint32_t>(index);
-    sendFatalFailureToHost("timestampDelta was 0 for reading index ",
-                           &indexInt);
+    EXPECT_FAIL_RETURN("timestampDelta was 0 for reading index ", &indexInt);
   }
 }
 
@@ -106,11 +104,11 @@ void BasicProximityTest::confirmDataIsSane(const void *eventData) {
     // 'invalid' is a sane reading for v1.1 or lower.  But our padding should
     // always be zero'd.
     if (mApiVersion >= CHRE_API_VERSION_1_2 && data->readings[i].invalid) {
-      sendFatalFailureToHost("Invalid flag must not be set for proximity");
+      EXPECT_FAIL_RETURN("Invalid flag must not be set for proximity");
     }
     if (data->readings[i].padding0 != 0) {
       uint32_t padding = data->readings[i].padding0;
-      sendFatalFailureToHost("padding0 is data is non-zero:", &padding);
+      EXPECT_FAIL_RETURN("padding0 is data is non-zero:", &padding);
     }
   }
 }
diff --git a/apps/test/chqts/src/general_test/basic_wifi_test.cc b/apps/test/chqts/src/general_test/basic_wifi_test.cc
index 0e9e0616..6f14a833 100644
--- a/apps/test/chqts/src/general_test/basic_wifi_test.cc
+++ b/apps/test/chqts/src/general_test/basic_wifi_test.cc
@@ -29,8 +29,6 @@
 #include "chre/util/unique_ptr.h"
 #include "chre_api/chre.h"
 
-using nanoapp_testing::sendFatalFailureToHost;
-using nanoapp_testing::sendFatalFailureToHostUint8;
 using nanoapp_testing::sendSuccessToHost;
 
 #define LOG_TAG "[BasicWifiTest]"
@@ -99,9 +97,9 @@ void testConfigureScanMonitorAsync(bool enable, const void *cookie) {
   LOGI("Starts scan monitor configure test: %s", enable ? "enable" : "disable");
   if (!chreWifiConfigureScanMonitorAsync(enable, cookie)) {
     if (enable) {
-      sendFatalFailureToHost("Failed to request to enable scan monitor.");
+      EXPECT_FAIL_RETURN("Failed to request to enable scan monitor.");
     } else {
-      sendFatalFailureToHost("Failed to request to disable scan monitor.");
+      EXPECT_FAIL_RETURN("Failed to request to disable scan monitor.");
     }
   }
 }
@@ -123,7 +121,7 @@ void testRequestScanAsync() {
       /*.radioChainPref=*/CHRE_WIFI_RADIO_CHAIN_PREF_DEFAULT,
       /*.channelSet=*/CHRE_WIFI_CHANNEL_SET_NON_DFS};
   if (!chreWifiRequestScanAsync(&kParams, &kOnDemandScanCookie)) {
-    sendFatalFailureToHost("Failed to request for on-demand WiFi scan.");
+    EXPECT_FAIL_RETURN("Failed to request for on-demand WiFi scan.");
   }
 }
 
@@ -141,8 +139,8 @@ void testRequestRangingAsync(const struct chreWifiScanResult *aps,
 
   auto targetList =
       chre::MakeUniqueArray<struct chreWifiRangingTarget[]>(targetLength);
-  ASSERT_NE(targetList, nullptr,
-            "Failed to allocate array for issuing a ranging request");
+  EXPECT_NE_OR_RETURN(targetList, nullptr,
+                      "Failed to allocate array for issuing a ranging request");
 
   // Save the last spot for any available RTT APs in case they didn't make it
   // in the array earlier. This first loop allows non-RTT compatible APs as a
@@ -165,8 +163,7 @@ void testRequestRangingAsync(const struct chreWifiScanResult *aps,
   struct chreWifiRangingParams params = {.targetListLen = targetLength,
                                          .targetList = targetList.get()};
   if (!chreWifiRequestRangingAsync(&params, &kRequestRangingCookie)) {
-    sendFatalFailureToHost(
-        "Failed to request ranging for a list of WiFi scans.");
+    EXPECT_FAIL_RETURN("Failed to request ranging for a list of WiFi scans.");
   }
 }
 
@@ -223,14 +220,14 @@ void validatePrimaryChannel(const chreWifiScanResult &result) {
 
 /**
  * Validates centerFreqPrimary and centerFreqSecondary
- * TODO (jacksun) add test when channelWidth is 20, 40, 80, or 160 MHz
+ * TODO(b/396133301): add test when channelWidth is 20, 40, 80, or 160 MHz
  */
 void validateCenterFreq(const chreWifiScanResult &result) {
   if (result.channelWidth != CHRE_WIFI_CHANNEL_WIDTH_80_PLUS_80_MHZ &&
       result.centerFreqSecondary != 0) {
-    // TODO (jacksun) Format the centerFreqSecondary into the message
-    // after redesigning of sendFatalFailureToHost()
-    sendFatalFailureToHost(
+    // TODO(b/396133301): Format the centerFreqSecondary into the message
+    // after redesigning of EXPECT_FAIL_RETURN()
+    EXPECT_FAIL_RETURN(
         "centerFreqSecondary must be 0 if channelWidth is not 80+80MHZ");
   }
 }
@@ -243,7 +240,7 @@ void validateRssi(int8_t rssi) {
   // right next to a high-power AP (e.g. transmitting at 20 dBm),
   // in which case RSSI will be < 20 dBm. Place a high threshold to check
   // against values likely to be erroneous (36 dBm/4W).
-  ASSERT_LT(rssi, 36, "RSSI is greater than 36");
+  EXPECT_LT_OR_RETURN(rssi, 36, "RSSI is greater than 36");
 }
 
 /**
@@ -256,9 +253,10 @@ void validateRangingEventArray(const struct chreWifiScanResult *results,
                                const struct chreWifiRangingEvent *event) {
   size_t expectedArraySize = std::min(
       resultsSize, static_cast<size_t>(CHRE_WIFI_RANGING_LIST_MAX_LEN));
-  ASSERT_EQ(event->resultCount, expectedArraySize,
-            "RTT ranging result count was not the same as the requested target "
-            "list size");
+  EXPECT_EQ_OR_RETURN(
+      event->resultCount, expectedArraySize,
+      "RTT ranging result count was not the same as the requested target "
+      "list size");
 
   uint8_t matchesFound = 0;
 
@@ -272,7 +270,7 @@ void validateRangingEventArray(const struct chreWifiScanResult *results,
     }
   }
 
-  ASSERT_EQ(
+  EXPECT_EQ_OR_RETURN(
       matchesFound, expectedArraySize,
       "BSSID(s) from the ranging request were not found in the ranging result");
 }
@@ -286,17 +284,18 @@ void validateLci(const struct chreWifiRangingResult::chreWifiLci *lci) {
   // used for lat / lng so verify that no bits outside those are used.
   constexpr int64_t kMaxLat = INT64_C(90) << 25;
   constexpr int64_t kMaxLng = INT64_C(180) << 25;
-  ASSERT_IN_RANGE(lci->latitude, -1 * kMaxLat, kMaxLat,
-                  "LCI's latitude is outside the range of -90 to 90");
-  ASSERT_IN_RANGE(lci->longitude, -1 * kMaxLng, kMaxLng,
-                  "LCI's longitude is outside the range of -180 to 180");
+  EXPECT_IN_RANGE_OR_RETURN(lci->latitude, -1 * kMaxLat, kMaxLat,
+                            "LCI's latitude is outside the range of -90 to 90");
+  EXPECT_IN_RANGE_OR_RETURN(
+      lci->longitude, -1 * kMaxLng, kMaxLng,
+      "LCI's longitude is outside the range of -180 to 180");
 
   // According to RFC 6225, values greater than 34 are reserved
   constexpr uint8_t kMaxLatLngUncertainty = 34;
-  ASSERT_LE(lci->latitudeUncertainty, kMaxLatLngUncertainty,
-            "LCI's latitude uncertainty is greater than 34");
-  ASSERT_LE(lci->longitudeUncertainty, kMaxLatLngUncertainty,
-            "LCI's longitude uncertainty is greater than 34");
+  EXPECT_LE_OR_RETURN(lci->latitudeUncertainty, kMaxLatLngUncertainty,
+                      "LCI's latitude uncertainty is greater than 34");
+  EXPECT_LE_OR_RETURN(lci->longitudeUncertainty, kMaxLatLngUncertainty,
+                      "LCI's longitude uncertainty is greater than 34");
 
   if (lci->altitudeType == CHRE_WIFI_LCI_ALTITUDE_TYPE_METERS) {
     // Highest largely populated city in the world, El Alto, Bolivia, is 4300
@@ -307,23 +306,23 @@ void validateLci(const struct chreWifiRangingResult::chreWifiLci *lci) {
     // Lowest largely populated city in the world, Baku, Azerbaijan, is 28
     // meters below sea level so -100 meters should be a good lower bound.
     constexpr int32_t kMinAltitudeMeters = (100 << 8) * -1;
-    ASSERT_IN_RANGE(
+    EXPECT_IN_RANGE_OR_RETURN(
         lci->altitude, kMinAltitudeMeters, kMaxAltitudeMeters,
         "LCI's altitude is outside of the range of -25 to 500 meters");
 
     // According to RFC 6225, values greater than 30 are reserved
     constexpr uint8_t kMaxAltitudeUncertainty = 30;
-    ASSERT_LE(lci->altitudeUncertainty, kMaxAltitudeUncertainty,
-              "LCI's altitude certainty is greater than 30");
+    EXPECT_LE_OR_RETURN(lci->altitudeUncertainty, kMaxAltitudeUncertainty,
+                        "LCI's altitude certainty is greater than 30");
   } else if (lci->altitudeType == CHRE_WIFI_LCI_ALTITUDE_TYPE_FLOORS) {
     // Tallest building has 163 floors. Assume -5 to 100 floors is a sane range.
     constexpr int32_t kMaxAltitudeFloors = 100 << 8;
     constexpr int32_t kMinAltitudeFloors = (5 << 8) * -1;
-    ASSERT_IN_RANGE(
+    EXPECT_IN_RANGE_OR_RETURN(
         lci->altitude, kMinAltitudeFloors, kMaxAltitudeFloors,
         "LCI's altitude is outside of the range of -5 to 100 floors");
   } else if (lci->altitudeType != CHRE_WIFI_LCI_ALTITUDE_TYPE_UNKNOWN) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "LCI's altitude type was not unknown, floors, or meters");
   }
 }
@@ -334,8 +333,8 @@ BasicWifiTest::BasicWifiTest() : Test(CHRE_API_VERSION_1_1) {}
 
 void BasicWifiTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Expected 0 byte message, got more bytes:",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     mWifiCapabilities = chreWifiGetCapabilities();
     startScanMonitorTestStage();
@@ -344,7 +343,7 @@ void BasicWifiTest::setUp(uint32_t messageSize, const void * /* message */) {
 
 void BasicWifiTest::handleEvent(uint32_t /* senderInstanceId */,
                                 uint16_t eventType, const void *eventData) {
-  ASSERT_NE(eventData, nullptr, "Received null eventData");
+  EXPECT_NE_OR_RETURN(eventData, nullptr, "Received null eventData");
   LOGI("Received event type %" PRIu16, eventType);
   switch (eventType) {
     case CHRE_EVENT_WIFI_ASYNC_RESULT:
@@ -359,7 +358,7 @@ void BasicWifiTest::handleEvent(uint32_t /* senderInstanceId */,
       }
 
       if (!scanEventExpected()) {
-        sendFatalFailureToHost("WiFi scan event received when not requested");
+        EXPECT_FAIL_RETURN("WiFi scan event received when not requested");
       }
       const auto *result = static_cast<const chreWifiScanEvent *>(eventData);
       LOGI("Received wifi scan result, result count: %" PRIu8,
@@ -377,7 +376,7 @@ void BasicWifiTest::handleEvent(uint32_t /* senderInstanceId */,
       bool delayExceeded = (mStartTimestampNs != 0) &&
                            (chreGetTime() - mStartTimestampNs > maxDelayNs);
       if (delayExceeded) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "Did not receive chreWifiScanResult within 100 milliseconds.");
       }
       // Do not reset mStartTimestampNs here, because it is used for the
@@ -387,8 +386,7 @@ void BasicWifiTest::handleEvent(uint32_t /* senderInstanceId */,
     }
     case CHRE_EVENT_WIFI_RANGING_RESULT: {
       if (!rangingEventExpected()) {
-        sendFatalFailureToHost(
-            "WiFi ranging event received when not requested");
+        EXPECT_FAIL_RETURN("WiFi ranging event received when not requested");
       }
       const auto *result = static_cast<const chreWifiRangingEvent *>(eventData);
       // Allow some wiggle room between the expected timeout and when the event
@@ -396,7 +394,7 @@ void BasicWifiTest::handleEvent(uint32_t /* senderInstanceId */,
       if (mStartTimestampNs != 0 &&
           chreGetTime() - mStartTimestampNs >
               CHRE_WIFI_RANGING_RESULT_TIMEOUT_NS + kTimeoutWiggleRoomNs) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "Did not receive chreWifiRangingEvent within the ranging timeout");
       }
       validateRangingEvent(result);
@@ -424,7 +422,7 @@ void BasicWifiTest::handleEvent(uint32_t /* senderInstanceId */,
 
 void BasicWifiTest::handleChreWifiAsyncEvent(const chreAsyncResult *result) {
   if (!mCurrentWifiRequest.has_value()) {
-    nanoapp_testing::sendFailureToHost("Unexpected async result");
+    EXPECT_FAIL_RETURN("Unexpected async result");
   }
   LOGI("Received a wifi async event. request type: %" PRIu8
        " error code: %" PRIu8,
@@ -476,8 +474,8 @@ void BasicWifiTest::processChreWifiAsyncResult(const chreAsyncResult *result) {
       }
       break;
     default:
-      sendFatalFailureToHostUint8("Received unexpected requestType %d",
-                                  result->requestType);
+      EXPECT_FAIL_RETURN_UINT8("Received unexpected requestType %d",
+                               result->requestType);
       break;
   }
 }
@@ -552,14 +550,14 @@ void BasicWifiTest::resetCurrentWifiRequest(const void *cookie,
 
 void BasicWifiTest::validateWifiScanEvent(const chreWifiScanEvent *eventData) {
   if (eventData->version != CHRE_WIFI_SCAN_EVENT_VERSION) {
-    sendFatalFailureToHostUint8("Got unexpected scan event version %d",
-                                eventData->version);
+    EXPECT_FAIL_RETURN_UINT8("Got unexpected scan event version %d",
+                             eventData->version);
   }
 
   if (mNextExpectedIndex != eventData->eventIndex) {
     LOGE("Expected index: %" PRIu32 ", received index: %" PRIu8,
          mNextExpectedIndex, eventData->eventIndex);
-    sendFatalFailureToHost("Received out-of-order events");
+    EXPECT_FAIL_RETURN("Received out-of-order events");
   }
   mNextExpectedIndex++;
 
@@ -569,7 +567,7 @@ void BasicWifiTest::validateWifiScanEvent(const chreWifiScanEvent *eventData) {
   if (mWiFiScanResultRemaining < eventData->resultCount) {
     LOGE("Remaining scan results %" PRIu32 ", received %" PRIu8,
          mWiFiScanResultRemaining, eventData->resultCount);
-    sendFatalFailureToHost("Received too many WiFi scan results");
+    EXPECT_FAIL_RETURN("Received too many WiFi scan results");
   }
   mWiFiScanResultRemaining -= eventData->resultCount;
 
@@ -606,8 +604,7 @@ void BasicWifiTest::validateWifiScanResult(uint8_t count,
                                            const chreWifiScanResult *results) {
   for (uint8_t i = 0; i < count; ++i) {
     if (results[i].ssidLen > CHRE_WIFI_SSID_MAX_LEN) {
-      sendFatalFailureToHostUint8("Got unexpected ssidLen %d",
-                                  results[i].ssidLen);
+      EXPECT_FAIL_RETURN_UINT8("Got unexpected ssidLen %d", results[i].ssidLen);
     }
 
     // TODO: Enable fatal failures on band, RSSI, and primary channel
@@ -627,8 +624,8 @@ void BasicWifiTest::validateWifiScanResult(uint8_t count,
 void BasicWifiTest::validateRangingEvent(
     const chreWifiRangingEvent *eventData) {
   if (eventData->version != CHRE_WIFI_RANGING_EVENT_VERSION) {
-    sendFatalFailureToHostUint8("Got unexpected ranging event version %d",
-                                eventData->version);
+    EXPECT_FAIL_RETURN_UINT8("Got unexpected ranging event version %d",
+                             eventData->version);
   }
 
   validateRangingEventArray(mLatestWifiScanResults.data(),
@@ -642,19 +639,19 @@ void BasicWifiTest::validateRangingEvent(
       LOGE("Invalid Ranging result timestamp = %" PRIu64 " (%" PRIu64
            ", %" PRIu64 "). Status = %" PRIu8,
            result.timestamp, mStartTimestampNs, currentTime, result.status);
-      sendFatalFailureToHost("Invalid ranging result timestamp");
+      EXPECT_FAIL_RETURN("Invalid ranging result timestamp");
     }
 
     if (result.status != CHRE_WIFI_RANGING_STATUS_SUCCESS) {
       if (result.rssi != 0 || result.distance != 0 ||
           result.distanceStdDev != 0) {
-        sendFatalFailureToHost(
+        EXPECT_FAIL_RETURN(
             "Ranging result with failure status had non-zero state");
       }
     } else {
       validateRssi(result.rssi);
 
-      // TODO(b/289432591): Use sendFatalFailureToHost to check ranging distance
+      // TODO(b/289432591): Use EXPECT_FAIL to check ranging distance
       // results.
       constexpr uint32_t kMaxDistanceMillimeters = 100 * 1000;
       if (result.distance > kMaxDistanceMillimeters) {
diff --git a/apps/test/chqts/src/general_test/cell_info_base.cc b/apps/test/chqts/src/general_test/cell_info_base.cc
index acb91aff..48b1f787 100644
--- a/apps/test/chqts/src/general_test/cell_info_base.cc
+++ b/apps/test/chqts/src/general_test/cell_info_base.cc
@@ -15,6 +15,7 @@
  */
 #include <general_test/cell_info_base.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 namespace general_test {
@@ -37,16 +38,16 @@ bool CellInfoBase::isBoundedInt64(int64_t value, int64_t lower, int64_t upper,
 
 void CellInfoBase::sendFatalFailureInt32(const char *message, int32_t value) {
   uint32_t val = static_cast<uint32_t>(value);
-  nanoapp_testing::sendFatalFailureToHost(message, &val);
+  EXPECT_FAIL_RETURN(message, &val);
 }
 
 void CellInfoBase::sendFatalFailureUint8(const char *message, uint8_t value) {
   uint32_t val = value;
-  nanoapp_testing::sendFatalFailureToHost(message, &val);
+  EXPECT_FAIL_RETURN(message, &val);
 }
 
 void CellInfoBase::sendFatalFailure(const char *message) {
-  nanoapp_testing::sendFatalFailureToHost(message, nullptr /* value */);
+  EXPECT_FAIL_RETURN(message, nullptr /* value */);
 }
 
 }  // namespace general_test
diff --git a/apps/test/chqts/src/general_test/estimated_host_time_test.cc b/apps/test/chqts/src/general_test/estimated_host_time_test.cc
index 0e705322..761383ab 100644
--- a/apps/test/chqts/src/general_test/estimated_host_time_test.cc
+++ b/apps/test/chqts/src/general_test/estimated_host_time_test.cc
@@ -16,6 +16,7 @@
 
 #include <general_test/estimated_host_time_test.h>
 
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
@@ -39,8 +40,7 @@ void EstimatedHostTimeTest::setUp(uint32_t /* messageSize */,
       chreTimerSet(timerInterval, &mTimerHandle, false /* oneShot */);
 
   if (mTimerHandle == CHRE_TIMER_INVALID) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Unable to set timer for time verification");
+    EXPECT_FAIL_RETURN("Unable to set timer for time verification");
   }
 }
 
@@ -72,7 +72,7 @@ void EstimatedHostTimeTest::verifyIncreasingTime() {
 
     --mRemainingIterations;
   } else {
-    nanoapp_testing::sendFatalFailureToHost("Unable to verify increasing time");
+    EXPECT_FAIL_RETURN("Unable to verify increasing time");
   }
 }
 
diff --git a/apps/test/chqts/src/general_test/event_between_apps_test.cc b/apps/test/chqts/src/general_test/event_between_apps_test.cc
index 2dda072a..f216f4c6 100644
--- a/apps/test/chqts/src/general_test/event_between_apps_test.cc
+++ b/apps/test/chqts/src/general_test/event_between_apps_test.cc
@@ -21,6 +21,7 @@
 #include <cstddef>
 
 #include <shared/abort.h>
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
@@ -28,7 +29,7 @@
 #include "chre_api/chre.h"
 
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -42,8 +43,8 @@ EventBetweenApps0::EventBetweenApps0()
 void EventBetweenApps0::setUp(uint32_t messageSize,
                               const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Initial message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Initial message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   NanoappInfo info;
@@ -57,7 +58,7 @@ void EventBetweenApps0::handleEvent(uint32_t senderInstanceId,
       senderInstanceId, eventType, eventData, MessageType::kContinue,
       sizeof(app1InstanceId));
   if (mContinueCount > 0) {
-    sendFatalFailureToHost("Multiple kContinue messages sent");
+    EXPECT_FAIL_RETURN("Multiple kContinue messages sent");
   }
 
   mContinueCount++;
@@ -79,8 +80,8 @@ EventBetweenApps1::EventBetweenApps1()
 void EventBetweenApps1::setUp(uint32_t messageSize,
                               const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Initial message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Initial message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   NanoappInfo appInfo;
@@ -97,24 +98,24 @@ void EventBetweenApps1::handleEvent(uint32_t senderInstanceId,
     if (mApp0InstanceId != CHRE_INSTANCE_ID) {
       // We know app0's instance ID can't be CHRE_INSTANCE_ID, otherwise
       // we would have aborted this test in commonInit().
-      sendFatalFailureToHost("Multiple kContinue messages from host.");
+      EXPECT_FAIL_RETURN("Multiple kContinue messages from host.");
     }
     nanoapp_testing::memcpy(&mApp0InstanceId, message, sizeof(mApp0InstanceId));
     mApp0InstanceId = nanoapp_testing::littleEndianToHost(mApp0InstanceId);
 
   } else if (eventType == EventBetweenApps0::kEventType) {
     if (mReceivedInstanceId != CHRE_INSTANCE_ID) {
-      sendFatalFailureToHost("Multiple messages from other nanoapp.");
+      EXPECT_FAIL_RETURN("Multiple messages from other nanoapp.");
     }
     if (senderInstanceId == CHRE_INSTANCE_ID) {
-      sendFatalFailureToHost(
+      EXPECT_FAIL_RETURN(
           "Received event from other nanoapp with CHRE_INSTANCE_ID for sender");
     }
     mReceivedInstanceId = senderInstanceId;
     uint32_t magic;
     nanoapp_testing::memcpy(&magic, eventData, sizeof(magic));
     if (magic != EventBetweenApps0::kMagic) {
-      sendFatalFailureToHost("Got incorrect magic data: ", &magic);
+      EXPECT_FAIL_RETURN("Got incorrect magic data: ", &magic);
     }
 
   } else {
@@ -126,8 +127,8 @@ void EventBetweenApps1::handleEvent(uint32_t senderInstanceId,
     if (mApp0InstanceId == mReceivedInstanceId) {
       sendSuccessToHost();
     } else {
-      sendFatalFailureToHost("Got bad sender instance ID for nanoapp event: ",
-                             &mReceivedInstanceId);
+      EXPECT_FAIL_RETURN("Got bad sender instance ID for nanoapp event: ",
+                         &mReceivedInstanceId);
     }
   }
 }
diff --git a/apps/test/chqts/src/general_test/event_between_apps_test.h b/apps/test/chqts/src/general_test/event_between_apps_test.h
index 68d0037f..501a9f6a 100644
--- a/apps/test/chqts/src/general_test/event_between_apps_test.h
+++ b/apps/test/chqts/src/general_test/event_between_apps_test.h
@@ -18,6 +18,7 @@
 #define _GTS_NANOAPPS_GENERAL_TEST_EVENT_BETWEEN_APPS_TEST_H_
 
 #include <general_test/test.h>
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 namespace general_test {
diff --git a/apps/test/chqts/src/general_test/get_time_test.cc b/apps/test/chqts/src/general_test/get_time_test.cc
index ea780f6a..62198416 100644
--- a/apps/test/chqts/src/general_test/get_time_test.cc
+++ b/apps/test/chqts/src/general_test/get_time_test.cc
@@ -19,13 +19,13 @@
 #include <cstddef>
 
 #include <shared/abort.h>
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
 
 namespace general_test {
 
@@ -33,13 +33,13 @@ GetTimeTest::GetTimeTest() : Test(CHRE_API_VERSION_1_0), mContinueCount(0) {}
 
 void GetTimeTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("GetTime message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("GetTime message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   uint64_t firstTime = chreGetTime();
   if (firstTime == UINT64_C(0)) {
-    sendFatalFailureToHost("chreGetTime() gave 0 well after system boot.");
+    EXPECT_FAIL_RETURN("chreGetTime() gave 0 well after system boot.");
   }
 
   uint64_t prevTime = firstTime;
@@ -53,14 +53,14 @@ void GetTimeTest::setUp(uint32_t messageSize, const void * /* message */) {
     // We don't require this to have increased, because maybe we're
     // on a relatively fast processor, or have a low resolution clock.
     if (nextTime < prevTime) {
-      sendFatalFailureToHost("chreGetTime() is not monotonically increasing");
+      EXPECT_FAIL_RETURN("chreGetTime() is not monotonically increasing");
     }
 
     prevTime = nextTime;
   }
 
   if (prevTime == firstTime) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "chreGetTime() is not increasing after a large number of calls");
   }
 
@@ -76,7 +76,7 @@ void GetTimeTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
   getMessageDataFromHostEvent(senderInstanceId, eventType, eventData,
                               MessageType::kContinue, 0);
   if (mContinueCount > 0) {
-    sendFatalFailureToHost("Multiple kContinue messages sent");
+    EXPECT_FAIL_RETURN("Multiple kContinue messages sent");
   }
 
   mContinueCount++;
diff --git a/apps/test/chqts/src/general_test/gnss_capabilities_test.cc b/apps/test/chqts/src/general_test/gnss_capabilities_test.cc
index 635b82e9..765c7f2c 100644
--- a/apps/test/chqts/src/general_test/gnss_capabilities_test.cc
+++ b/apps/test/chqts/src/general_test/gnss_capabilities_test.cc
@@ -15,6 +15,7 @@
  */
 #include <general_test/gnss_capabilities_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
@@ -26,8 +27,8 @@ GnssCapabilitiesTest::GnssCapabilitiesTest() : Test(CHRE_API_VERSION_1_1) {}
 void GnssCapabilitiesTest::setUp(uint32_t messageSize,
                                  const void * /* message */) {
   if (messageSize != 0) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Expected 0 byte message, got more bytes:", &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     uint32_t allCapabilities = CHRE_GNSS_CAPABILITIES_NONE;
 
@@ -46,12 +47,10 @@ void GnssCapabilitiesTest::setUp(uint32_t messageSize,
     // Clear out known capabilities, any remaining are unknown
     if ((capabilities & ~allCapabilities) != 0) {
       if (mApiVersion > CHRE_API_VERSION_1_2) {
-        nanoapp_testing::sendFatalFailureToHost(
-            "New version with unknown capabilities encountered:",
-            &capabilities);
+        EXPECT_FAIL_RETURN("New version with unknown capabilities encountered:",
+                           &capabilities);
       } else {
-        nanoapp_testing::sendFatalFailureToHost(
-            "Received unexpected capabilities:", &capabilities);
+        EXPECT_FAIL_RETURN("Received unexpected capabilities:", &capabilities);
       }
     } else {
       nanoapp_testing::sendSuccessToHost();
diff --git a/apps/test/chqts/src/general_test/heap_alloc_stress_test.cc b/apps/test/chqts/src/general_test/heap_alloc_stress_test.cc
index cd5b595f..439e0a0a 100644
--- a/apps/test/chqts/src/general_test/heap_alloc_stress_test.cc
+++ b/apps/test/chqts/src/general_test/heap_alloc_stress_test.cc
@@ -20,12 +20,13 @@
 
 #include <general_test/test_names.h>
 #include <shared/abort.h>
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
 using nanoapp_testing::sendFailureToHost;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -36,7 +37,6 @@ static void tryAbsurdMalloc(uint32_t hugeSize) {
     sendFailureToHost("chreHeapAlloc claimed allocation of huge size ",
                       &hugeSize);
     chreHeapFree(ptr);
-    nanoapp_testing::abort();
   }
 }
 
@@ -45,7 +45,7 @@ HeapAllocStressTest::HeapAllocStressTest() : Test(CHRE_API_VERSION_1_0) {}
 void HeapAllocStressTest::setUp(uint32_t messageSize,
                                 const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "HeapAllocStress message expects 0 additional bytes, got ",
         &messageSize);
   }
@@ -73,7 +73,7 @@ void HeapAllocStressTest::setUp(uint32_t messageSize,
       reinterpret_cast<void **>(chreHeapAlloc(kNumPtrs * sizeof(void *)));
   if (ptrs == NULL) {
     // Oh, the irony.
-    sendFatalFailureToHost("Insufficient free heap to test heap exhaustion.");
+    EXPECT_FAIL_RETURN("Insufficient free heap to test heap exhaustion.");
   }
 
   size_t index;
@@ -95,7 +95,7 @@ void HeapAllocStressTest::setUp(uint32_t messageSize,
     ptrs[index] = ptr;
   }
   if (index == 0) {
-    sendFatalFailureToHost("Failed to allocate anything for heap exhaustion");
+    EXPECT_FAIL_RETURN("Failed to allocate anything for heap exhaustion");
   }
 
   // We should be able to free this allocation, and then obtain it again.
@@ -103,7 +103,7 @@ void HeapAllocStressTest::setUp(uint32_t messageSize,
   chreHeapFree(ptrs[index]);
   ptrs[index] = chreHeapAlloc(last_alloc_size);
   if (ptrs[index] == NULL) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "After exhausting heap and then free'ing, unable to alloc again for "
         "size",
         &last_alloc_size);
diff --git a/apps/test/chqts/src/general_test/heap_exhaustion_stability_test.cc b/apps/test/chqts/src/general_test/heap_exhaustion_stability_test.cc
index 5bc7cd97..3cb37897 100644
--- a/apps/test/chqts/src/general_test/heap_exhaustion_stability_test.cc
+++ b/apps/test/chqts/src/general_test/heap_exhaustion_stability_test.cc
@@ -19,6 +19,7 @@
 #include <cinttypes>
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/time_util.h>
 
@@ -30,7 +31,7 @@
 using nanoapp_testing::kOneMillisecondInNanoseconds;
 using nanoapp_testing::kOneSecondInNanoseconds;
 using nanoapp_testing::sendFailureToHost;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendSuccessToHost;
 
 /*
@@ -69,7 +70,7 @@ void HeapExhaustionStabilityTest::exhaustHeap() {
       chreHeapAlloc(kNumPtrs * sizeof(*mExhaustionPtrs)));
   if (mExhaustionPtrs == nullptr) {
     // Oh, the irony.
-    sendFatalFailureToHost("Insufficient free heap to exhaust the heap.");
+    EXPECT_FAIL_RETURN("Insufficient free heap to exhaust the heap.");
   }
 
   // We start by trying to allocate massive sizes (256MB to start).
@@ -93,7 +94,7 @@ void HeapExhaustionStabilityTest::exhaustHeap() {
     mExhaustionPtrs[mExhaustionPtrCount] = ptr;
   }
   if (mExhaustionPtrCount == 0) {
-    sendFatalFailureToHost("Failed to allocate anything for heap exhaustion");
+    EXPECT_FAIL_RETURN("Failed to allocate anything for heap exhaustion");
   }
 }
 
@@ -111,14 +112,14 @@ void HeapExhaustionStabilityTest::setUp(uint32_t messageSize,
                                         const void * /* message */) {
   mInMethod = true;
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "HeapExhaustionStability message expects 0 additional bytes, got ",
         &messageSize);
   }
 
   if (chreTimerSet(kExhaustionDuration, &kExhaustionDuration, true) ==
       CHRE_TIMER_INVALID) {
-    sendFatalFailureToHost("Unable to set initial timer");
+    EXPECT_FAIL_RETURN("Unable to set initial timer");
   }
 
   exhaustHeap();
@@ -170,21 +171,21 @@ void HeapExhaustionStabilityTest::testSensor() {
   uint32_t handle;
   if (!chreSensorFindDefault(kSensorType, &handle)) {
     // We still expect this to succeed without any heap left.
-    sendFatalFailureToHost("chreSensorFindDefault failed");
+    EXPECT_FAIL_RETURN("chreSensorFindDefault failed");
   }
   chreSensorInfo info;
   if (!chreGetSensorInfo(handle, &info)) {
     // We still expect this to succeed, since we're supplying the memory.
-    sendFatalFailureToHost("chreGetSensorInfo failed");
+    EXPECT_FAIL_RETURN("chreGetSensorInfo failed");
   }
   if (info.sensorType != kSensorType) {
-    sendFatalFailureToHost("Invalid sensor info provided");
+    EXPECT_FAIL_RETURN("Invalid sensor info provided");
   }
 
   chreSensorSamplingStatus samplingStatus;
   if (!chreGetSensorSamplingStatus(handle, &samplingStatus)) {
     // We still expect this to succeed, since we're supplying the memory.
-    sendFatalFailureToHost("chreGetSensorSamplingStatus failed");
+    EXPECT_FAIL_RETURN("chreGetSensorSamplingStatus failed");
   }
 
   // TODO: We might want to consider calling chreSensorConfigure() for a
@@ -213,7 +214,7 @@ void HeapExhaustionStabilityTest::handleEvent(uint32_t senderInstanceId,
                                               uint16_t eventType,
                                               const void *eventData) {
   if (mInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   mInMethod = true;
@@ -231,8 +232,8 @@ void HeapExhaustionStabilityTest::handleEvent(uint32_t senderInstanceId,
 void HeapExhaustionStabilityTest::handleTimer(uint32_t senderInstanceId,
                                               const void *eventData) {
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("handleTimer with unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleTimer with unexpected sender:",
+                       &senderInstanceId);
   }
   if (eventData == &kShortDuration) {
     // This was the timer we triggered while the heap was exhausted.
@@ -242,24 +243,24 @@ void HeapExhaustionStabilityTest::handleTimer(uint32_t senderInstanceId,
     // Our test is done.
     freeMemory();
     if (mFinishedBitmask != kAllFinished) {
-      sendFatalFailureToHost("Done with test, but not all stages done.",
-                             &mFinishedBitmask);
+      EXPECT_FAIL_RETURN("Done with test, but not all stages done.",
+                         &mFinishedBitmask);
     }
     sendSuccessToHost();
 
   } else {
-    sendFatalFailureToHost("Unexpected timer eventData");
+    EXPECT_FAIL_RETURN("Unexpected timer eventData");
   }
 }
 
 void HeapExhaustionStabilityTest::handleSelfEvent(uint32_t senderInstanceId,
                                                   const void *eventData) {
   if (senderInstanceId != chreGetInstanceId()) {
-    sendFatalFailureToHost("handleSelfEvent with unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleSelfEvent with unexpected sender:",
+                       &senderInstanceId);
   }
   if (eventData != nullptr) {
-    sendFatalFailureToHost("Unexpected data for event to self");
+    EXPECT_FAIL_RETURN("Unexpected data for event to self");
   }
   markSuccess(kEventStage);
 }
@@ -268,12 +269,12 @@ void HeapExhaustionStabilityTest::markSuccess(uint32_t stage) {
   LOGD("Stage %" PRIu32 " succeeded", stage);
   uint32_t finishedBit = (1 << stage);
   if ((kAllFinished & finishedBit) == 0) {
-    sendFatalFailureToHost("markSuccess bad stage", &stage);
+    EXPECT_FAIL_RETURN("markSuccess bad stage", &stage);
   }
   if ((mFinishedBitmask & finishedBit) != 0) {
     // This could be when a timer/event method returned 'false', but
     // actually did end up triggering an event.
-    sendFatalFailureToHost("markSuccess stage triggered twice", &stage);
+    EXPECT_FAIL_RETURN("markSuccess stage triggered twice", &stage);
   }
   mFinishedBitmask |= finishedBit;
   // Note that unlike many markSuccess() implementations, we do not
diff --git a/apps/test/chqts/src/general_test/hello_world_test.cc b/apps/test/chqts/src/general_test/hello_world_test.cc
index 4129baa1..d198d583 100644
--- a/apps/test/chqts/src/general_test/hello_world_test.cc
+++ b/apps/test/chqts/src/general_test/hello_world_test.cc
@@ -16,9 +16,9 @@
 
 #include <general_test/hello_world_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
-using nanoapp_testing::sendFatalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -27,8 +27,8 @@ HelloWorldTest::HelloWorldTest() : Test(CHRE_API_VERSION_1_0) {}
 
 void HelloWorldTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost("Expected 0 byte message, got more bytes:",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     sendSuccessToHost();
   }
diff --git a/apps/test/chqts/src/general_test/host_awake_suspend_test.cc b/apps/test/chqts/src/general_test/host_awake_suspend_test.cc
index 2a7ad938..439823ff 100644
--- a/apps/test/chqts/src/general_test/host_awake_suspend_test.cc
+++ b/apps/test/chqts/src/general_test/host_awake_suspend_test.cc
@@ -16,6 +16,7 @@
 
 #include <general_test/host_awake_suspend_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
@@ -30,8 +31,8 @@ HostAwakeSuspendTest::HostAwakeSuspendTest() : Test(CHRE_API_VERSION_1_2) {}
 void HostAwakeSuspendTest::setUp(uint32_t messageSize,
                                  const void * /* message */) {
   if (messageSize != 0) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Expected 0 byte message, got more bytes:", &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     // Invoke to verify that this API is implemented
     chreConfigureHostSleepStateEvents(true /* enable */);
@@ -39,8 +40,7 @@ void HostAwakeSuspendTest::setUp(uint32_t messageSize,
     // Assume that GTS tests are performed under USB connection,
     // in which the host should be awake.
     if (!chreIsHostAwake()) {
-      nanoapp_testing::sendFatalFailureToHost(
-          "Host must be awake during testing");
+      EXPECT_FAIL_RETURN("Host must be awake during testing");
     }
 
     nanoapp_testing::sendSuccessToHost();
diff --git a/apps/test/chqts/src/general_test/logging_consistency_test.cc b/apps/test/chqts/src/general_test/logging_consistency_test.cc
index 3b99ab12..d5f2328c 100644
--- a/apps/test/chqts/src/general_test/logging_consistency_test.cc
+++ b/apps/test/chqts/src/general_test/logging_consistency_test.cc
@@ -19,6 +19,7 @@
 #include <cstddef>
 #include <limits>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include <chre/util/nanoapp/log.h>
@@ -29,7 +30,6 @@
 
 #define LOG_TAG "[LoggingConsistencyTest]"
 
-using nanoapp_testing::sendFatalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -39,7 +39,7 @@ LoggingConsistencyTest::LoggingConsistencyTest() : Test(CHRE_API_VERSION_1_0) {}
 void LoggingConsistencyTest::setUp(uint32_t messageSize,
                                    const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "LoggingConsistency message expects 0 additional bytes, got ",
         &messageSize);
   }
diff --git a/apps/test/chqts/src/general_test/nanoapp_info.cc b/apps/test/chqts/src/general_test/nanoapp_info.cc
index bd3972e8..6abe45f5 100644
--- a/apps/test/chqts/src/general_test/nanoapp_info.cc
+++ b/apps/test/chqts/src/general_test/nanoapp_info.cc
@@ -16,11 +16,14 @@
 
 #include <general_test/nanoapp_info.h>
 
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
+using nanoapp_testing::sendFailureToHost;
+
 namespace general_test {
 
 struct AppInfo {
@@ -31,8 +34,7 @@ struct AppInfo {
 NanoappInfo::NanoappInfo()
     : mAppId(chreGetAppId()), mInstanceId(chreGetInstanceId()) {
   if (mInstanceId == CHRE_INSTANCE_ID) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Given CHRE_INSTANCE_ID for my instance ID");
+    EXPECT_FAIL_RETURN("Given CHRE_INSTANCE_ID for my instance ID");
   }
 }
 
@@ -49,10 +51,10 @@ void NanoappInfo::sendToHost() {
 bool NanoappInfo::validate(uint64_t appId, uint32_t instanceId) {
   bool result = true;
   if (appId != mAppId) {
-    nanoapp_testing::sendFatalFailureToHost("app IDs do not match");
+    sendFailureToHost("app IDs do not match");
     result = false;
   } else if (instanceId != mInstanceId) {
-    nanoapp_testing::sendFatalFailureToHost("instance IDs do not match");
+    sendFailureToHost("instance IDs do not match");
     result = false;
   }
 
@@ -63,8 +65,7 @@ bool NanoappInfo::queryByAppId(struct chreNanoappInfo *info) {
   bool result = chreGetNanoappInfoByAppId(mAppId, info);
 
   if (!result) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Unable to get nanoapp info by app ID");
+    sendFailureToHost("Unable to get nanoapp info by app ID");
   }
 
   return result;
@@ -74,8 +75,7 @@ bool NanoappInfo::queryByInstanceId(struct chreNanoappInfo *info) {
   bool result = chreGetNanoappInfoByInstanceId(mInstanceId, info);
 
   if (!result) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Unable to get nanoapp info by instance ID");
+    sendFailureToHost("Unable to get nanoapp info by instance ID");
   }
 
   return result;
diff --git a/apps/test/chqts/src/general_test/nanoapp_info_by_app_id_test.cc b/apps/test/chqts/src/general_test/nanoapp_info_by_app_id_test.cc
index bc115dec..16a62d30 100644
--- a/apps/test/chqts/src/general_test/nanoapp_info_by_app_id_test.cc
+++ b/apps/test/chqts/src/general_test/nanoapp_info_by_app_id_test.cc
@@ -18,6 +18,7 @@
 
 #include <general_test/running_info.h>
 
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
diff --git a/apps/test/chqts/src/general_test/nanoapp_info_by_instance_id_test.cc b/apps/test/chqts/src/general_test/nanoapp_info_by_instance_id_test.cc
index d505b683..20e89fb4 100644
--- a/apps/test/chqts/src/general_test/nanoapp_info_by_instance_id_test.cc
+++ b/apps/test/chqts/src/general_test/nanoapp_info_by_instance_id_test.cc
@@ -18,6 +18,7 @@
 
 #include <general_test/running_info.h>
 
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
diff --git a/apps/test/chqts/src/general_test/nanoapp_info_events_test_observer.cc b/apps/test/chqts/src/general_test/nanoapp_info_events_test_observer.cc
index ee32e30e..261e8258 100644
--- a/apps/test/chqts/src/general_test/nanoapp_info_events_test_observer.cc
+++ b/apps/test/chqts/src/general_test/nanoapp_info_events_test_observer.cc
@@ -90,16 +90,15 @@ void NanoAppInfoEventsTestObserver::processStartStopHistory(
   }
 
   if (startCount > 1) {
-    nanoapp_testing::sendFatalFailureToHost("Received too many Start events");
+    EXPECT_FAIL_RETURN("Received too many Start events");
   } else if (startCount == 0) {
-    nanoapp_testing::sendFatalFailureToHost("Did not receive Start event");
+    EXPECT_FAIL_RETURN("Did not receive Start event");
   } else if (stopCount > 1) {
-    nanoapp_testing::sendFatalFailureToHost("Received too many Stop events");
+    EXPECT_FAIL_RETURN("Received too many Stop events");
   } else if (stopCount == 0) {
-    nanoapp_testing::sendFatalFailureToHost("Did not receive Stop event");
+    EXPECT_FAIL_RETURN("Did not receive Stop event");
   } else if (!eventsOrdered) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Start and Stop events were not in order");
+    EXPECT_FAIL_RETURN("Start and Stop events were not in order");
   } else {
     nanoapp_testing::sendSuccessToHost();
   }
diff --git a/apps/test/chqts/src/general_test/running_info.cc b/apps/test/chqts/src/general_test/running_info.cc
index 5f447a37..83f42a1b 100644
--- a/apps/test/chqts/src/general_test/running_info.cc
+++ b/apps/test/chqts/src/general_test/running_info.cc
@@ -16,8 +16,11 @@
 
 #include <general_test/running_info.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
+using nanoapp_testing::sendFailureToHost;
+
 namespace general_test {
 
 bool RunningInfo::queryByAppId() {
@@ -31,16 +34,13 @@ bool RunningInfo::queryByInstanceId() {
 bool RunningInfo::validate(uint32_t appVersion) {
   bool result;
   if (mRunningInfo.version != appVersion) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Running info version does not match app version");
+    sendFailureToHost("Running info version does not match app version");
     result = false;
   } else if (mRunningInfo.appId != NANOAPP_ID) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Running info appId does not match build constant");
+    sendFailureToHost("Running info appId does not match build constant");
     result = false;
   } else if (mRunningInfo.version != NANOAPP_VERSION) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Running info version does not match build constant");
+    sendFailureToHost("Running info version does not match build constant");
     result = false;
   } else {
     result =
diff --git a/apps/test/chqts/src/general_test/send_event_stress_test.cc b/apps/test/chqts/src/general_test/send_event_stress_test.cc
index df6d3507..19577895 100644
--- a/apps/test/chqts/src/general_test/send_event_stress_test.cc
+++ b/apps/test/chqts/src/general_test/send_event_stress_test.cc
@@ -18,11 +18,11 @@
 
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
-using nanoapp_testing::sendFatalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
 /*
@@ -59,7 +59,7 @@ void SendEventStressTest::setUp(uint32_t messageSize,
   sInMethod = true;
 
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "SendEventStress message expects 0 additional bytes, got ",
         &messageSize);
   }
@@ -81,7 +81,7 @@ void SendEventStressTest::setUp(uint32_t messageSize,
 
   // We want at least 2 events for this to pretend to be an exhaustion test.
   if (sEventsLeft < 2) {
-    sendFatalFailureToHost("Insufficient events available");
+    EXPECT_FAIL_RETURN("Insufficient events available");
   }
 
   // If kMaxEventsToSend events are sent, we need to reset
@@ -99,19 +99,19 @@ void SendEventStressTest::handleEvent(uint32_t senderInstanceId,
                                       uint16_t eventType,
                                       const void *eventData) {
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   sInMethod = true;
   if (senderInstanceId != mInstanceId) {
-    sendFatalFailureToHost("handleEvent got event from unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent got event from unexpected sender:",
+                       &senderInstanceId);
   }
   verifyEvent(eventType, eventData, 0);
 
   --sEventsLeft;
   if (sEventsLeft < 0) {
-    sendFatalFailureToHost("Too many events delivered");
+    EXPECT_FAIL_RETURN("Too many events delivered");
   }
 
   sInMethod = false;
@@ -124,7 +124,7 @@ void SendEventStressTest::verifyEvent(uint16_t eventType, const void *data,
   }
   if (data != kEventData) {
     // 0: handleEvent, 1: completeCallback
-    sendFatalFailureToHost("bad event data:", &num);
+    EXPECT_FAIL_RETURN("bad event data:", &num);
   }
 }
 
@@ -140,7 +140,7 @@ void SendEventStressTest::completeCallback(uint16_t eventType, void *data) {
   }
 
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "completeCallback invoked while another nanoapp method is running");
   }
   verifyEvent(eventType, data, 1);
@@ -148,16 +148,15 @@ void SendEventStressTest::completeCallback(uint16_t eventType, void *data) {
   --sCompleteCallbacksLeft;
   if (sCompleteCallbacksLeft == 0) {
     if (sEventsLeft != 0) {
-      sendFatalFailureToHost("completeCallbacks delivered before events");
+      EXPECT_FAIL_RETURN("completeCallbacks delivered before events");
     }
     sendSuccessToHost();
   } else if (sCompleteCallbacksLeft < 0) {
     // It's too late for the Host to catch this failure, but perhaps
     // the abort will screw up our unload, and trigger a failure that way.
-    sendFatalFailureToHost("completeCallback called too many times");
+    EXPECT_FAIL_RETURN("completeCallback called too many times");
   } else if (sEventsLeft <= 0 && sCompleteCallbacksLeft > 0) {
-    sendFatalFailureToHost(
-        "completeCallback called less times than events sent");
+    EXPECT_FAIL_RETURN("completeCallback called less times than events sent");
   }
 }
 
diff --git a/apps/test/chqts/src/general_test/send_event_test.cc b/apps/test/chqts/src/general_test/send_event_test.cc
index 132f2f54..0d4c9269 100644
--- a/apps/test/chqts/src/general_test/send_event_test.cc
+++ b/apps/test/chqts/src/general_test/send_event_test.cc
@@ -20,11 +20,11 @@
 
 #include <shared/abort.h>
 #include <shared/array_length.h>
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
-using nanoapp_testing::sendFatalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
 /*
@@ -68,12 +68,12 @@ uint8_t SendEventTest::sCallbacksInvoked = 0;
 template <uint8_t kCallbackIndex>
 void SendEventTest::completeCallback(uint16_t eventType, void *data) {
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "completeCallback called while another nanoapp method is running.");
   }
   sInMethod = true;
   if ((data == nullptr) || (data == kOddData)) {
-    sendFatalFailureToHost("completeCallback called with nullptr or odd data.");
+    EXPECT_FAIL_RETURN("completeCallback called with nullptr or odd data.");
   }
   uint32_t num = *(reinterpret_cast<uint32_t *>(data));
   uint16_t expectedEventType = 0xFFFF;
@@ -96,24 +96,23 @@ void SendEventTest::completeCallback(uint16_t eventType, void *data) {
       expectedCallbackIndex = 1;
       break;
     default:
-      sendFatalFailureToHost("completeCallback given bad data.", &num);
+      EXPECT_FAIL_RETURN("completeCallback given bad data.", &num);
   }
   if (expectedEventType != eventType) {
-    sendFatalFailureToHost("completeCallback bad/eventType mismatch.");
+    EXPECT_FAIL_RETURN("completeCallback bad/eventType mismatch.");
   }
   if (expectedCallbackIndex != kCallbackIndex) {
-    sendFatalFailureToHost("Incorrect callback function called.");
+    EXPECT_FAIL_RETURN("Incorrect callback function called.");
   }
   uint8_t mask = static_cast<uint8_t>(1 << num);
   if ((sCallbacksInvoked & mask) != 0) {
-    sendFatalFailureToHost("Complete callback invoked multiple times for ",
-                           &num);
+    EXPECT_FAIL_RETURN("Complete callback invoked multiple times for ", &num);
   }
   sCallbacksInvoked |= mask;
 
   if (!chreSendEvent(kEventTypeCallback, nullptr, nullptr,
                      chreGetInstanceId())) {
-    sendFatalFailureToHost("Failed chreSendEvent in callback.");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent in callback.");
   }
   sInMethod = false;
 }
@@ -131,8 +130,8 @@ SendEventTest::SendEventTest() : Test(CHRE_API_VERSION_1_0), mNextNum(0) {}
 void SendEventTest::setUp(uint32_t messageSize, const void * /* message */) {
   sInMethod = true;
   if (messageSize != 0) {
-    sendFatalFailureToHost("SendEvent message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("SendEvent message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   const uint32_t id = chreGetInstanceId();
@@ -142,42 +141,42 @@ void SendEventTest::setUp(uint32_t messageSize, const void * /* message */) {
 
   // num: 0
   if (!chreSendEvent(kEventType0, &mData[0], completeCallback0, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 0");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 0");
   }
 
   // num: 1
   if (!chreSendEvent(kEventType0, &mData[1], completeCallback1, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 1");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 1");
   }
 
   // num: 2
   if (!chreSendEvent(kEventType1, &mData[2], completeCallback0, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 2");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 2");
   }
 
   // num: 3
   if (!chreSendEvent(kEventType1, &mData[3], completeCallback1, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 3");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 3");
   }
 
   // num: 4
   if (!chreSendEvent(kEventType0, &mData[4], nullptr, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 4");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 4");
   }
 
   // num: 5
   if (!chreSendEvent(kEventType1, &mData[5], nullptr, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 5");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 5");
   }
 
   // num: 6
   if (!chreSendEvent(kEventType0, nullptr, nullptr, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 6");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 6");
   }
 
   // num: 7
   if (!chreSendEvent(kEventType1, kOddData, nullptr, id)) {
-    sendFatalFailureToHost("Failed chreSendEvent num 7");
+    EXPECT_FAIL_RETURN("Failed chreSendEvent num 7");
   }
 
   sInMethod = false;
@@ -186,13 +185,13 @@ void SendEventTest::setUp(uint32_t messageSize, const void * /* message */) {
 void SendEventTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
                                 const void *eventData) {
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   sInMethod = true;
   if (senderInstanceId != chreGetInstanceId()) {
-    sendFatalFailureToHost("handleEvent got event from unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent got event from unexpected sender:",
+                       &senderInstanceId);
   }
 
   if (mNextNum < 8) {
@@ -222,15 +221,15 @@ void SendEventTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
     }
 
     if (expectedEventType != eventType) {
-      sendFatalFailureToHost("Incorrect event type sent for num ", &mNextNum);
+      EXPECT_FAIL_RETURN("Incorrect event type sent for num ", &mNextNum);
     }
     if (expectedData != eventData) {
-      sendFatalFailureToHost("Incorrect data sent for num ", &mNextNum);
+      EXPECT_FAIL_RETURN("Incorrect data sent for num ", &mNextNum);
     }
 
   } else {
     if (eventType != kEventTypeCallback) {
-      sendFatalFailureToHost("Unexpected event type for num ", &mNextNum);
+      EXPECT_FAIL_RETURN("Unexpected event type for num ", &mNextNum);
     }
     if (mNextNum == 11) {
       // This was our last callback.  Everything is good.
diff --git a/apps/test/chqts/src/general_test/send_message_to_host_test.cc b/apps/test/chqts/src/general_test/send_message_to_host_test.cc
index 1a4284ee..8227f285 100644
--- a/apps/test/chqts/src/general_test/send_message_to_host_test.cc
+++ b/apps/test/chqts/src/general_test/send_message_to_host_test.cc
@@ -19,6 +19,7 @@
 #include <cinttypes>
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/nano_endian.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
@@ -31,7 +32,7 @@
 #define LOG_TAG "[SendMessageToHostTest]"
 
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendInternalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
@@ -97,22 +98,21 @@ template <uint8_t kCallbackIndex>
 void SendMessageToHostTest::smallMessageCallback(void *message,
                                                  size_t messageSize) {
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "smallMessageCallback called while another nanoapp method is running");
   }
   sInMethod = true;
   if (message == nullptr) {
-    sendFatalFailureToHost("smallMessageCallback given null message");
+    EXPECT_FAIL_RETURN("smallMessageCallback given null message");
   }
   if (messageSize != kSmallMessageSize) {
     uint32_t size = static_cast<uint32_t>(messageSize);
-    sendFatalFailureToHost("smallMessageCallback given bad messageSize:",
-                           &size);
+    EXPECT_FAIL_RETURN("smallMessageCallback given bad messageSize:", &size);
   }
   const uint8_t *msg = static_cast<const uint8_t *>(message);
   for (size_t i = 0; i < messageSize; i++) {
     if (msg[i] != kDataByte) {
-      sendFatalFailureToHost("Corrupt data in smallMessageCallback");
+      EXPECT_FAIL_RETURN("Corrupt data in smallMessageCallback");
     }
   }
 
@@ -127,13 +127,13 @@ void SendMessageToHostTest::smallMessageCallback(void *message,
       expectedCallbackIndex = 1;
       break;
     case 2:
-      sendFatalFailureToHost("callback invoked when null callback given");
+      EXPECT_FAIL_RETURN("callback invoked when null callback given");
       break;
     default:
       sendInternalFailureToHost("Invalid index", &stage);
   }
   if (expectedCallbackIndex != kCallbackIndex) {
-    sendFatalFailureToHost("Incorrect callback function called.");
+    EXPECT_FAIL_RETURN("Incorrect callback function called.");
   }
 
   markSuccess(stage);
@@ -157,7 +157,7 @@ uint32_t SendMessageToHostTest::getSmallDataIndex(const uint8_t *data) {
       return i;
     }
   }
-  sendFatalFailureToHost("Bad memory sent to smallMessageCallback");
+  sendInternalFailureToHost("Bad memory sent to smallMessageCallback");
   // We should never get here.
   return kSmallMessageTestCount;
 }
@@ -165,12 +165,12 @@ uint32_t SendMessageToHostTest::getSmallDataIndex(const uint8_t *data) {
 void SendMessageToHostTest::largeMessageCallback(void *message,
                                                  size_t messageSize) {
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "largeMessageCallback called while another nanoapp method is running");
   }
   sInMethod = true;
   if (message == nullptr) {
-    sendFatalFailureToHost("largeMessageCallback given null message");
+    EXPECT_FAIL_RETURN("largeMessageCallback given null message");
   }
   uint32_t index = 2;
   if (message == sLargeMessageData[0]) {
@@ -178,18 +178,18 @@ void SendMessageToHostTest::largeMessageCallback(void *message,
   } else if (message == sLargeMessageData[1]) {
     index = 1;
   } else {
-    sendFatalFailureToHost("largeMessageCallback given bad message");
+    EXPECT_FAIL_RETURN("largeMessageCallback given bad message");
   }
 
   size_t expectedMessageSize = index == 0 ? chreGetMessageToHostMaxSize() + 1
                                           : chreGetMessageToHostMaxSize();
   if (messageSize != expectedMessageSize) {
-    sendFatalFailureToHost("largeMessageCallback given incorrect messageSize");
+    EXPECT_FAIL_RETURN("largeMessageCallback given incorrect messageSize");
   }
   const uint8_t *msg = static_cast<const uint8_t *>(message);
   for (size_t i = 0; i < messageSize; i++) {
     if (msg[i] != kDataByte) {
-      sendFatalFailureToHost("Corrupt data in largeMessageCallback");
+      EXPECT_FAIL_RETURN("Corrupt data in largeMessageCallback");
     }
   }
   chreHeapFree(sLargeMessageData[index]);
@@ -203,10 +203,10 @@ void SendMessageToHostTest::markSuccess(uint32_t stage) {
   LOGD("Stage %" PRIu32 " succeeded", stage);
   uint32_t finishedBit = (1 << stage);
   if (sFinishedBitmask & finishedBit) {
-    sendFatalFailureToHost("callback called multiple times for stage:", &stage);
+    EXPECT_FAIL_RETURN("callback called multiple times for stage:", &stage);
   }
   if ((kAllFinished & finishedBit) == 0) {
-    sendFatalFailureToHost("markSuccess bad stage", &stage);
+    EXPECT_FAIL_RETURN("markSuccess bad stage", &stage);
   }
   sFinishedBitmask |= finishedBit;
   if (sFinishedBitmask == kAllFinished) {
@@ -223,7 +223,7 @@ void SendMessageToHostTest::prepTestMemory() {
                                 : chreGetMessageToHostMaxSize();
     sLargeMessageData[i] = chreHeapAlloc(messageSize);
     if (sLargeMessageData[i] == nullptr) {
-      sendFatalFailureToHost("Insufficient heap memory for test");
+      EXPECT_FAIL_RETURN("Insufficient heap memory for test");
     }
     nanoapp_testing::memset(sLargeMessageData[i], kDataByte, messageSize);
   }
@@ -276,7 +276,7 @@ void SendMessageToHostTest::setUp(uint32_t messageSize,
 
   sInMethod = true;
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "SendMessageToHost message expects 0 additional bytes, got ",
         &messageSize);
   }
@@ -286,19 +286,19 @@ void SendMessageToHostTest::setUp(uint32_t messageSize,
   // stage: 0
   if (!sendMessageToHost(sSmallMessageData[0], kSmallMessageSize,
                          kUntestedMessageType, smallMessageCallback0)) {
-    sendFatalFailureToHost("Failed chreSendMessageToHost stage 0");
+    EXPECT_FAIL_RETURN("Failed chreSendMessageToHost stage 0");
   }
 
   // stage: 1
   if (!sendMessageToHost(sSmallMessageData[1], kSmallMessageSize,
                          kUntestedMessageType, smallMessageCallback1)) {
-    sendFatalFailureToHost("Failed chreSendMessageToHost stage 1");
+    EXPECT_FAIL_RETURN("Failed chreSendMessageToHost stage 1");
   }
 
   // stage: 2
   if (!sendMessageToHost(sSmallMessageData[2], kSmallMessageSize,
                          kUntestedMessageType, nullptr)) {
-    sendFatalFailureToHost("Failed chreSendMessageToHost stage 2");
+    EXPECT_FAIL_RETURN("Failed chreSendMessageToHost stage 2");
   }
   // There's no callback, so we mark this as a success.
   markSuccess(2);
@@ -306,12 +306,12 @@ void SendMessageToHostTest::setUp(uint32_t messageSize,
   // stage: 3
   if (!sendMessageToHost(sSmallMessageData[3], kSmallMessageSize,
                          kUntestedMessageType, smallMessageCallback0)) {
-    sendFatalFailureToHost("Failed chreSendMessageToHost stage 3");
+    EXPECT_FAIL_RETURN("Failed chreSendMessageToHost stage 3");
   }
 
   // stage: 4
   if (!sendMessageToHost(nullptr, 0, kUntestedMessageType, nullptr)) {
-    sendFatalFailureToHost("Failed chreSendMessageToHost stage 4");
+    EXPECT_FAIL_RETURN("Failed chreSendMessageToHost stage 4");
   }
   // There's no callback, so we mark this as a success.
   markSuccess(4);
@@ -324,14 +324,14 @@ void SendMessageToHostTest::setUp(uint32_t messageSize,
   // stage: 6
   if (sendMessageToHost(sLargeMessageData[0], chreGetMessageToHostMaxSize() + 1,
                         kUntestedMessageType, largeMessageCallback)) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "Oversized data to chreSendMessageToHost claimed success");
   }
 
   // stage: 7
   if (!sendMessageToHost(sLargeMessageData[1], chreGetMessageToHostMaxSize(),
                          kUntestedMessageType, largeMessageCallback)) {
-    sendFatalFailureToHost("Failed chreSendMessageToHost stage 7");
+    EXPECT_FAIL_RETURN("Failed chreSendMessageToHost stage 7");
   }
 
   sInMethod = false;
@@ -341,7 +341,7 @@ void SendMessageToHostTest::handleEvent(uint32_t senderInstanceId,
                                         uint16_t eventType,
                                         const void *eventData) {
   if (sInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   sInMethod = true;
@@ -349,8 +349,8 @@ void SendMessageToHostTest::handleEvent(uint32_t senderInstanceId,
   // TODO(b/32114261): Use getMessageDataFromHostEvent().  We can't do
   //     that now because our messageType is probably wrong.
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("handleEvent got event from unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent got event from unexpected sender:",
+                       &senderInstanceId);
   }
   if (eventType != CHRE_EVENT_MESSAGE_FROM_HOST) {
     unexpectedEvent(eventType);
@@ -359,8 +359,8 @@ void SendMessageToHostTest::handleEvent(uint32_t senderInstanceId,
   auto dataStruct = static_cast<const chreMessageFromHostData *>(eventData);
   // TODO(b/32114261): Test the message type.
   if (dataStruct->messageSize != 0) {
-    sendFatalFailureToHost("handleEvent got non-zero message size",
-                           &dataStruct->messageSize);
+    EXPECT_FAIL_RETURN("handleEvent got non-zero message size",
+                       &dataStruct->messageSize);
   }
   // We don't test dataStruct->message.  We don't require this to be
   // nullptr.  If a CHRE chooses to deal in 0-sized memory blocks, that's
diff --git a/apps/test/chqts/src/general_test/sensor_info_test.cc b/apps/test/chqts/src/general_test/sensor_info_test.cc
index ab4e3714..53b1e362 100644
--- a/apps/test/chqts/src/general_test/sensor_info_test.cc
+++ b/apps/test/chqts/src/general_test/sensor_info_test.cc
@@ -15,6 +15,7 @@
  */
 #include <general_test/sensor_info_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 namespace general_test {
@@ -23,17 +24,16 @@ SensorInfoTest::SensorInfoTest() : Test(CHRE_API_VERSION_1_1) {}
 
 void SensorInfoTest::setUp(uint32_t messageSize, const void * /* message */) {
   if (messageSize != 0) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Expected 0 byte message, got more bytes:", &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else if (!chreSensorFindDefault(CHRE_SENSOR_TYPE_ACCELEROMETER,
                                     &mSensorHandle)) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "CHRE implementation does not have an accelerometer");
+    EXPECT_FAIL_RETURN("CHRE implementation does not have an accelerometer");
   } else {
     struct chreSensorInfo info;
 
     if (!chreGetSensorInfo(mSensorHandle, &info)) {
-      nanoapp_testing::sendFatalFailureToHost("Failed to gather sensor info");
+      EXPECT_FAIL_RETURN("Failed to gather sensor info");
     } else {
       mCompleted = true;
       validateSensorInfo(info);
@@ -44,20 +44,16 @@ void SensorInfoTest::setUp(uint32_t messageSize, const void * /* message */) {
 void SensorInfoTest::validateSensorInfo(
     const struct chreSensorInfo &info) const {
   if ((mApiVersion < CHRE_API_VERSION_1_1) && (info.minInterval != 0)) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Sensor minimum interval is non-zero");
+    EXPECT_FAIL_RETURN("Sensor minimum interval is non-zero");
   } else if (info.minInterval == 0) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Sensor minimum interval is unknown");
+    EXPECT_FAIL_RETURN("Sensor minimum interval is unknown");
   } else if (!chreSensorConfigure(
                  mSensorHandle, CHRE_SENSOR_CONFIGURE_MODE_CONTINUOUS,
                  info.minInterval, CHRE_SENSOR_LATENCY_DEFAULT)) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Sensor failed configuration with minimum interval");
+    EXPECT_FAIL_RETURN("Sensor failed configuration with minimum interval");
   } else if (!chreSensorConfigureModeOnly(mSensorHandle,
                                           CHRE_SENSOR_CONFIGURE_MODE_DONE)) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Unable to configure sensor mode to DONE");
+    EXPECT_FAIL_RETURN("Unable to configure sensor mode to DONE");
   } else {
     nanoapp_testing::sendSuccessToHost();
   }
diff --git a/apps/test/chqts/src/general_test/simple_heap_alloc_test.cc b/apps/test/chqts/src/general_test/simple_heap_alloc_test.cc
index 76e4d9ef..521c6eee 100644
--- a/apps/test/chqts/src/general_test/simple_heap_alloc_test.cc
+++ b/apps/test/chqts/src/general_test/simple_heap_alloc_test.cc
@@ -21,13 +21,14 @@
 #include <general_test/test_names.h>
 #include <shared/abort.h>
 #include <shared/array_length.h>
+#include <shared/macros.h>
 #include <shared/nano_string.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
 using nanoapp_testing::MessageType;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendMessageToHost;
 using nanoapp_testing::sendSuccessToHost;
 
@@ -77,7 +78,7 @@ static void testMaxAlignment(uint32_t zero) {
   mfArray[1] = static_cast<MyFloat>(zero) + FLOAT_C(3.0);
   mfArray[2] = mfArray[0] / mfArray[1];
   if ((mfArray[0] * mfArray[1] + mfArray[2]) / FLOAT_C(3.0) == FLOAT_C(1.0)) {
-    sendFatalFailureToHost("Float math is wrong");
+    EXPECT_FAIL_RETURN("Float math is wrong");
   }
 
   constexpr size_t kUllSize = sizeof(unsigned long long);
@@ -94,7 +95,7 @@ static void testMaxAlignment(uint32_t zero) {
   unsigned long long result = ullArray[2] / 12345ULL;
   if (((kUllSize == 8) && (result != kExpected)) ||
       ((kUllSize > 8) && (result <= kExpected))) {
-    sendFatalFailureToHost("Long long math is wrong");
+    EXPECT_FAIL_RETURN("Long long math is wrong");
   }
 }
 #endif  // CHRE_CUSTOM_MAX_ALIGNMENT
@@ -107,7 +108,7 @@ void SimpleHeapAllocTest::setUp(uint32_t messageSize,
   nanoapp_testing::memset(mPtrs, 0, sizeof(mPtrs));
 
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "SimpleHeapAlloc message expects 0 additional bytes, got ",
         &messageSize);
   }
@@ -124,7 +125,7 @@ void SimpleHeapAllocTest::setUp(uint32_t messageSize,
   // We want to mix in a free among the allocs, just to make sure there
   // isn't some issue there.
   if (mPtrs[2] == nullptr) {
-    sendFatalFailureToHost("Failed first allocation of mPtrs[2]");
+    EXPECT_FAIL_RETURN("Failed first allocation of mPtrs[2]");
   } else {
     chreHeapFree(mPtrs[2]);
   }
@@ -136,11 +137,11 @@ void SimpleHeapAllocTest::setUp(uint32_t messageSize,
       // If we're getting this failure, but convinced the CHRE is
       // correct, make sure that we're actually performing an allocation
       // for each element of mPtrs.
-      sendFatalFailureToHost("Failed to allocate index ", &i);
+      EXPECT_FAIL_RETURN("Failed to allocate index ", &i);
     }
     const uintptr_t ptrValue = reinterpret_cast<uintptr_t>(mPtrs[i]);
     if ((ptrValue & (kMaxAlignment - 1)) != 0) {
-      sendFatalFailureToHost("Misaligned allocation at index ", &i);
+      EXPECT_FAIL_RETURN("Misaligned allocation at index ", &i);
     }
     // Make sure all of the bytes are addressable.  Our assumption
     // is we'll crash here if that's not the case.  Not the most
@@ -163,7 +164,7 @@ void SimpleHeapAllocTest::handleEvent(uint32_t senderInstanceId,
   getMessageDataFromHostEvent(senderInstanceId, eventType, eventData,
                               MessageType::kContinue, 0);
   if (mHasFreed) {
-    sendFatalFailureToHost("Multiple kContinue messages sent");
+    EXPECT_FAIL_RETURN("Multiple kContinue messages sent");
   }
 
   chreHeapFree(mPtrs[3]);
diff --git a/apps/test/chqts/src/general_test/test.cc b/apps/test/chqts/src/general_test/test.cc
index 761d7006..b64b3136 100644
--- a/apps/test/chqts/src/general_test/test.cc
+++ b/apps/test/chqts/src/general_test/test.cc
@@ -17,8 +17,10 @@
 #include <general_test/test.h>
 
 #include <shared/abort.h>
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/time_util.h>
+#include <cinttypes>
 
 #include <chre/util/nanoapp/log.h>
 
@@ -26,8 +28,7 @@
 
 #define LOG_TAG "[Test]"
 
-using nanoapp_testing::sendFatalFailureToHost;
-using nanoapp_testing::sendFatalFailureToHostUint8;
+using nanoapp_testing::sendInternalFailureToHost;
 
 namespace general_test {
 
@@ -52,37 +53,36 @@ void Test::testHandleEvent(uint32_t senderInstanceId, uint16_t eventType,
 
 void Test::unexpectedEvent(uint16_t eventType) {
   uint32_t localEvent = eventType;
-  sendFatalFailureToHost("Test received unexpected event:", &localEvent);
+  EXPECT_FAIL_RETURN("Test received unexpected event:", &localEvent);
 }
 
 void Test::validateChreAsyncResult(const chreAsyncResult *result,
                                    const chreAsyncRequest &request) {
   if (!result->success) {
-    sendFatalFailureToHostUint8("chre async result error: %d",
-                                result->errorCode);
+    EXPECT_FAIL_RETURN_UINT8("chre async result error: ", result->errorCode);
   }
   if (result->success && result->errorCode != CHRE_ERROR_NONE) {
-    sendFatalFailureToHostUint8(
-        "Request was successfully processed, but got errorCode: %d",
+    EXPECT_FAIL_RETURN_UINT8(
+        "Request was successfully processed, but got errorCode: ",
         result->errorCode);
   }
   if (result->reserved != 0) {
-    sendFatalFailureToHostUint8("reserved should be 0, got: %d",
-                                result->reserved);
+    EXPECT_FAIL_RETURN_UINT8("reserved should be 0, got: ", result->reserved);
   }
   if (result->cookie != request.cookie) {
     LOGE("Request cookie is %p, got %p", request.cookie, result->cookie);
-    sendFatalFailureToHost("Request cookie mismatch");
+    EXPECT_FAIL_RETURN("Request cookie mismatch");
   }
   if (result->requestType != request.requestType) {
     LOGE("Request requestType is %d, got %d", request.requestType,
          result->requestType);
-    sendFatalFailureToHost("Request requestType mismatch");
+    EXPECT_FAIL_RETURN("Request requestType mismatch");
   }
   if (chreGetTime() - request.requestTimeNs > request.timeoutNs) {
-    nanoapp_testing::sendFatalFailureToHostUint8(
-        "Did not receive chreWifiAsyncEvent within %d seconds.",
-        request.timeoutNs / nanoapp_testing::kOneSecondInNanoseconds);
+    uint32_t time =
+        request.timeoutNs / nanoapp_testing::kOneSecondInNanoseconds;
+    EXPECT_FAIL_RETURN("Did not receive chreWifiAsyncEvent within time (sec): ",
+                       &time);
   }
 }
 
@@ -91,21 +91,21 @@ const void *Test::getMessageDataFromHostEvent(
     nanoapp_testing::MessageType expectedMessageType,
     uint32_t expectedMessageSize) {
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("Unexpected sender ID:", &senderInstanceId);
+    sendInternalFailureToHost("Unexpected sender ID:", &senderInstanceId);
   }
   if (eventType != CHRE_EVENT_MESSAGE_FROM_HOST) {
     unexpectedEvent(eventType);
   }
   if (eventData == nullptr) {
-    sendFatalFailureToHost("NULL eventData given");
+    sendInternalFailureToHost("NULL eventData given");
   }
   auto data = static_cast<const chreMessageFromHostData *>(eventData);
   if (data->reservedMessageType != uint32_t(expectedMessageType)) {
-    sendFatalFailureToHost("Unexpected reservedMessageType:",
-                           &(data->reservedMessageType));
+    sendInternalFailureToHost("Unexpected reservedMessageType:",
+                              &(data->reservedMessageType));
   }
   if (data->messageSize != expectedMessageSize) {
-    sendFatalFailureToHost("Unexpected messageSize:", &(data->messageSize));
+    sendInternalFailureToHost("Unexpected messageSize:", &(data->messageSize));
   }
   return data->message;
 }
diff --git a/apps/test/chqts/src/general_test/test.h b/apps/test/chqts/src/general_test/test.h
index 88bdc5c9..13b01b66 100644
--- a/apps/test/chqts/src/general_test/test.h
+++ b/apps/test/chqts/src/general_test/test.h
@@ -17,6 +17,7 @@
 #ifndef _GTS_NANOAPPS_GENERAL_TEST_TEST_H_
 #define _GTS_NANOAPPS_GENERAL_TEST_TEST_H_
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
diff --git a/apps/test/chqts/src/general_test/timer_cancel_test.cc b/apps/test/chqts/src/general_test/timer_cancel_test.cc
index 846fdaf1..c623426b 100644
--- a/apps/test/chqts/src/general_test/timer_cancel_test.cc
+++ b/apps/test/chqts/src/general_test/timer_cancel_test.cc
@@ -19,6 +19,7 @@
 #include <cinttypes>
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/time_util.h>
 
@@ -29,7 +30,7 @@
 #define LOG_TAG "[TimerCancelTest]"
 
 using nanoapp_testing::kOneMillisecondInNanoseconds;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendInternalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
@@ -51,7 +52,7 @@ void TimerCancelTest::startStages() {
     Stage *stage = &mStages[i];
     stage->timerId = chreTimerSet(kDuration, stage, stage->oneShot);
     if (stage->timerId == CHRE_TIMER_INVALID) {
-      sendFatalFailureToHost("Unable to set timer:", &i);
+      EXPECT_FAIL_RETURN("Unable to set timer:", &i);
     }
     if (stage->expectCallback) {
       // Go on to the next stage.  Note this stage will markSuccess()
@@ -59,10 +60,10 @@ void TimerCancelTest::startStages() {
       continue;
     }
     if (!chreTimerCancel(stage->timerId)) {
-      sendFatalFailureToHost("Unable to cancel timer:", &i);
+      EXPECT_FAIL_RETURN("Unable to cancel timer:", &i);
     }
     if (chreTimerCancel(stage->timerId)) {
-      sendFatalFailureToHost("Claimed success in second cancel:", &i);
+      EXPECT_FAIL_RETURN("Claimed success in second cancel:", &i);
     }
     markSuccess(i);
   }
@@ -88,14 +89,14 @@ void TimerCancelTest::setUp(uint32_t messageSize, const void * /* message */) {
   mInMethod = true;
 
   if (messageSize != 0) {
-    sendFatalFailureToHost(
-        "TimerCancel message expects 0 additional bytes, got ", &messageSize);
+    EXPECT_FAIL_RETURN("TimerCancel message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   constexpr uint32_t kUnownedTimer = 0;
   static_assert((kUnownedTimer != CHRE_TIMER_INVALID), "Bad test");
   if (chreTimerCancel(kUnownedTimer)) {
-    sendFatalFailureToHost("Claimed success canceling timer we don't own");
+    EXPECT_FAIL_RETURN("Claimed success canceling timer we don't own");
   }
 
   startStages();
@@ -107,7 +108,7 @@ void TimerCancelTest::setUp(uint32_t messageSize, const void * /* message */) {
 
 void TimerCancelTest::handleStageEvent(Stage *stage) {
   if (!stage->expectCallback) {
-    sendFatalFailureToHost("Timer didn't cancel:", &stage->stage);
+    EXPECT_FAIL_RETURN("Timer didn't cancel:", &stage->stage);
   }
   // Now we're going to cancel the timer, so we don't expect an
   // additional call.
@@ -116,17 +117,16 @@ void TimerCancelTest::handleStageEvent(Stage *stage) {
   bool cancelSucceeded = chreTimerCancel(stage->timerId);
   if (stage->oneShot) {
     if (cancelSucceeded) {
-      sendFatalFailureToHost(
-          "Claimed success canceling one-shot after it fired:", &stage->stage);
+      EXPECT_FAIL_RETURN("Claimed success canceling one-shot after it fired:",
+                         &stage->stage);
     }
   } else {
     if (!cancelSucceeded) {
-      sendFatalFailureToHost("Unable to cancel recurring timer:",
-                             &stage->stage);
+      EXPECT_FAIL_RETURN("Unable to cancel recurring timer:", &stage->stage);
     }
   }
   if (chreTimerCancel(stage->timerId)) {
-    sendFatalFailureToHost("Claimed success in second cancel:", &stage->stage);
+    EXPECT_FAIL_RETURN("Claimed success in second cancel:", &stage->stage);
   }
   markSuccess(stage->stage);
 }
@@ -134,20 +134,20 @@ void TimerCancelTest::handleStageEvent(Stage *stage) {
 void TimerCancelTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
                                   const void *eventData) {
   if (mInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   mInMethod = true;
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("handleEvent got event from unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent got event from unexpected sender:",
+                       &senderInstanceId);
   }
   if (eventType != CHRE_EVENT_TIMER) {
     unexpectedEvent(eventType);
   }
   const Stage *stage = static_cast<const Stage *>(eventData);
   if (stage->stage >= kStageCount) {
-    sendFatalFailureToHost("Invalid handleEvent data:", &stage->stage);
+    EXPECT_FAIL_RETURN("Invalid handleEvent data:", &stage->stage);
   }
   handleStageEvent(const_cast<Stage *>(stage));
 
@@ -158,7 +158,7 @@ void TimerCancelTest::markSuccess(uint32_t stage) {
   LOGD("Stage %" PRIu32 " succeeded", stage);
   uint32_t finishedBit = (1 << stage);
   if ((kAllFinished & finishedBit) == 0) {
-    sendFatalFailureToHost("markSuccess bad stage:", &stage);
+    EXPECT_FAIL_RETURN("markSuccess bad stage:", &stage);
   }
   if ((mFinishedBitmask & finishedBit) != 0) {
     sendInternalFailureToHost("markSuccess multiple times:", &stage);
diff --git a/apps/test/chqts/src/general_test/timer_set_test.cc b/apps/test/chqts/src/general_test/timer_set_test.cc
index 720ab69d..58e8618c 100644
--- a/apps/test/chqts/src/general_test/timer_set_test.cc
+++ b/apps/test/chqts/src/general_test/timer_set_test.cc
@@ -20,6 +20,7 @@
 #include <cstddef>
 #include <new>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/time_util.h>
 
@@ -31,7 +32,7 @@
 
 using nanoapp_testing::kOneMillisecondInNanoseconds;
 using nanoapp_testing::kOneSecondInNanoseconds;
-using nanoapp_testing::sendFatalFailureToHost;
+
 using nanoapp_testing::sendInternalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
@@ -69,10 +70,10 @@ void TimerSetTest::Stage::start() {
   mSetTime = chreGetTime();
   mTimerHandle = chreTimerSet(mDuration, mCookie, mOneShot);
   if (mTimerHandle == CHRE_TIMER_INVALID) {
-    sendFatalFailureToHost("Unable to set timer ", &mStage);
+    EXPECT_FAIL_RETURN("Unable to set timer ", &mStage);
   }
   if (mSetTime == 0) {
-    sendFatalFailureToHost("chreGetTime() gave 0");
+    EXPECT_FAIL_RETURN("chreGetTime() gave 0");
   }
 }
 
@@ -84,16 +85,16 @@ void TimerSetTest::Stage::processEvent(uint64_t timestamp, TimerSetTest *test) {
 
   uint64_t expectedTime = mSetTime + (mEventCount * mDuration);
   if (timestamp < expectedTime) {
-    sendFatalFailureToHost("Timer triggered too soon ", &mStage);
+    EXPECT_FAIL_RETURN("Timer triggered too soon ", &mStage);
   }
   // TODO(b/32179037): Make this check much stricter.
   if (timestamp > (expectedTime + kOneSecondInNanoseconds)) {
-    sendFatalFailureToHost("Timer triggered over a second late ", &mStage);
+    EXPECT_FAIL_RETURN("Timer triggered over a second late ", &mStage);
   }
 
   if (mOneShot) {
     if (mEventCount > 1) {
-      sendFatalFailureToHost("One shot timer called multiple times ", &mStage);
+      EXPECT_FAIL_RETURN("One shot timer called multiple times ", &mStage);
     } else {
       test->markSuccess(mStage);
     }
@@ -103,7 +104,7 @@ void TimerSetTest::Stage::processEvent(uint64_t timestamp, TimerSetTest *test) {
     if (chreTimerCancel(mTimerHandle)) {
       test->markSuccess(mStage);
     } else {
-      sendFatalFailureToHost("Could not cancel recurring timer", &mStage);
+      EXPECT_FAIL_RETURN("Could not cancel recurring timer", &mStage);
     }
   }
 }
@@ -113,7 +114,7 @@ void TimerSetTest::initStages() {
   // placement new to initialize it.
   mStages = static_cast<Stage *>(chreHeapAlloc(sizeof(*mStages) * kStageCount));
   if (mStages == nullptr) {
-    sendFatalFailureToHost("Insufficient heap");
+    EXPECT_FAIL_RETURN("Insufficient heap");
   }
 
 #define COOKIE(num) reinterpret_cast<const void *>(num)
@@ -142,8 +143,8 @@ void TimerSetTest::setUp(uint32_t messageSize, const void * /* message */) {
   mInMethod = true;
 
   if (messageSize != 0) {
-    sendFatalFailureToHost("TimerSet message expects 0 additional bytes, got ",
-                           &messageSize);
+    EXPECT_FAIL_RETURN("TimerSet message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   initStages();
@@ -162,20 +163,20 @@ void TimerSetTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
                                const void *eventData) {
   uint64_t timestamp = chreGetTime();
   if (mInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   mInMethod = true;
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("handleEvent got event from unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent got event from unexpected sender:",
+                       &senderInstanceId);
   }
   if (eventType != CHRE_EVENT_TIMER) {
     unexpectedEvent(eventType);
   }
   Stage *stage = getStageFromCookie(eventData);
   if (stage == nullptr) {
-    sendFatalFailureToHost("handleEvent got invalid eventData");
+    EXPECT_FAIL_RETURN("handleEvent got invalid eventData");
   }
   stage->processEvent(timestamp, this);
 
@@ -186,7 +187,7 @@ void TimerSetTest::markSuccess(uint32_t stage) {
   LOGD("Stage %" PRIu32 " succeeded", stage);
   uint32_t finishedBit = (1 << stage);
   if ((kAllFinished & finishedBit) == 0) {
-    sendFatalFailureToHost("markSuccess bad stage", &stage);
+    EXPECT_FAIL_RETURN("markSuccess bad stage", &stage);
   }
   mFinishedBitmask |= finishedBit;
   if (mFinishedBitmask == kAllFinished) {
diff --git a/apps/test/chqts/src/general_test/timer_stress_test.cc b/apps/test/chqts/src/general_test/timer_stress_test.cc
index 4d65c4d1..5b4a5171 100644
--- a/apps/test/chqts/src/general_test/timer_stress_test.cc
+++ b/apps/test/chqts/src/general_test/timer_stress_test.cc
@@ -19,6 +19,7 @@
 #include <cinttypes>
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include <chre/util/nanoapp/log.h>
@@ -27,7 +28,6 @@
 
 #define LOG_TAG "[TimerStressTest]"
 
-using nanoapp_testing::sendFatalFailureToHost;
 using nanoapp_testing::sendInternalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
@@ -72,7 +72,7 @@ const uint32_t kCookies[] = {0, 1, 2};
 void TimerStressTest::startStages() {
   uint32_t cancelId = chreTimerSet(kDuration, &kCookies[0], true);
   if (cancelId == CHRE_TIMER_INVALID) {
-    sendFatalFailureToHost("No timers available");
+    EXPECT_FAIL_RETURN("No timers available");
   }
 
   mStage1CallbacksLeft = 0;
@@ -84,14 +84,14 @@ void TimerStressTest::startStages() {
     mStage1CallbacksLeft++;
   }
   if (mStage1CallbacksLeft == 0) {
-    sendFatalFailureToHost("Insufficient timers available");
+    EXPECT_FAIL_RETURN("Insufficient timers available");
   }
   if (!chreTimerCancel(cancelId)) {
-    sendFatalFailureToHost("Unable to cancel timer");
+    EXPECT_FAIL_RETURN("Unable to cancel timer");
   }
   markSuccess(0);
   if (chreTimerSet(kDuration, &kCookies[2], true) == CHRE_TIMER_INVALID) {
-    sendFatalFailureToHost("Unable to set new timer after successful cancel.");
+    EXPECT_FAIL_RETURN("Unable to set new timer after successful cancel.");
   }
 }
 
@@ -105,8 +105,8 @@ void TimerStressTest::setUp(uint32_t messageSize, const void * /* message */) {
   mInMethod = true;
 
   if (messageSize != 0) {
-    sendFatalFailureToHost(
-        "TimerStress message expects 0 additional bytes, got ", &messageSize);
+    EXPECT_FAIL_RETURN("TimerStress message expects 0 additional bytes, got ",
+                       &messageSize);
   }
 
   startStages();
@@ -117,7 +117,7 @@ void TimerStressTest::setUp(uint32_t messageSize, const void * /* message */) {
 void TimerStressTest::handleStageEvent(uint32_t index) {
   switch (index) {
     case 0:
-      sendFatalFailureToHost("Canceled timer fired:", &index);
+      EXPECT_FAIL_RETURN("Canceled timer fired:", &index);
       break;
 
     case 1:
@@ -132,20 +132,20 @@ void TimerStressTest::handleStageEvent(uint32_t index) {
       break;
 
     default:
-      sendFatalFailureToHost("Unexpected event stage:", &index);
+      EXPECT_FAIL_RETURN("Unexpected event stage:", &index);
   }
 }
 
 void TimerStressTest::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
                                   const void *eventData) {
   if (mInMethod) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "handleEvent invoked while another nanoapp method is running");
   }
   mInMethod = true;
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    sendFatalFailureToHost("handleEvent got event from unexpected sender:",
-                           &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent got event from unexpected sender:",
+                       &senderInstanceId);
   }
   if (eventType != CHRE_EVENT_TIMER) {
     unexpectedEvent(eventType);
@@ -161,10 +161,10 @@ void TimerStressTest::markSuccess(uint32_t stage) {
   LOGD("Stage %" PRIu32 " succeeded", stage);
   uint32_t finishedBit = (1 << stage);
   if ((kAllFinished & finishedBit) == 0) {
-    sendFatalFailureToHost("markSuccess bad stage:", &stage);
+    EXPECT_FAIL_RETURN("markSuccess bad stage:", &stage);
   }
   if ((mFinishedBitmask & finishedBit) != 0) {
-    sendFatalFailureToHost("timer over-triggered:", &stage);
+    EXPECT_FAIL_RETURN("timer over-triggered:", &stage);
   }
   mFinishedBitmask |= finishedBit;
   if (mFinishedBitmask == kAllFinished) {
diff --git a/apps/test/chqts/src/general_test/version_consistency_test.cc b/apps/test/chqts/src/general_test/version_consistency_test.cc
index 2a367ec1..ae1ac958 100644
--- a/apps/test/chqts/src/general_test/version_consistency_test.cc
+++ b/apps/test/chqts/src/general_test/version_consistency_test.cc
@@ -18,12 +18,12 @@
 
 #include <cstddef>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre/util/macros.h"
 #include "chre_api/chre.h"
 
-using nanoapp_testing::sendFatalFailureToHost;
 using nanoapp_testing::sendSuccessToHost;
 
 namespace general_test {
@@ -33,24 +33,23 @@ VersionConsistencyTest::VersionConsistencyTest() : Test(CHRE_API_VERSION_1_0) {}
 void VersionConsistencyTest::setUp(uint32_t messageSize,
                                    const void * /* message */) {
   if (messageSize != 0) {
-    sendFatalFailureToHost(
+    EXPECT_FAIL_RETURN(
         "VersionConsistency message expects 0 additional bytes, got ",
         &messageSize);
   }
 
   if (mApiVersion < CHRE_API_VERSION_1_0) {
-    sendFatalFailureToHost("API version less than 1.0", &mApiVersion);
+    EXPECT_FAIL_RETURN("API version less than 1.0", &mApiVersion);
   }
   if ((mApiVersion & UINT32_C(0xFFFF)) != 0) {
-    sendFatalFailureToHost("API version has two LSB set", &mApiVersion);
+    EXPECT_FAIL_RETURN("API version has two LSB set", &mApiVersion);
   }
   uint32_t platformVersion = chreGetVersion();
   constexpr uint32_t kMajorMinorMask = UINT32_C(0xFFFF0000);
   // Both mApiVersion and platformVersion refer to what the CHRE was
   // built against, so they must agree in major and minor version.
   if ((platformVersion & kMajorMinorMask) != (mApiVersion & kMajorMinorMask)) {
-    sendFatalFailureToHost("API and platform version mismatch",
-                           &platformVersion);
+    EXPECT_FAIL_RETURN("API and platform version mismatch", &platformVersion);
   }
 
   // Confirm that our app (CHRE_API_VERSION) and CHRE (mApiVersion) were
@@ -59,13 +58,13 @@ void VersionConsistencyTest::setUp(uint32_t messageSize,
   constexpr uint32_t kMajorMask = UINT32_C(0xFF000000);
   if ((mApiVersion & kMajorMask) != (CHRE_API_VERSION & kMajorMask)) {
     uint32_t appVersion = CHRE_API_VERSION;
-    sendFatalFailureToHost("App built against different major version",
-                           &appVersion);
+    EXPECT_FAIL_RETURN("App built against different major version",
+                       &appVersion);
   }
 
   uint64_t platformId = chreGetPlatformId();
   if ((platformId == UINT64_C(0)) || (platformId == UINT64_C(-1))) {
-    sendFatalFailureToHost("Bogus platform ID");
+    EXPECT_FAIL_RETURN("Bogus platform ID");
   }
   // TODO(b/30077401): We should send the Platform ID back to the Host, and
   //     have the Host confirm this is the Platform ID we used for loading
diff --git a/apps/test/chqts/src/general_test/wifi_capabilities_test.cc b/apps/test/chqts/src/general_test/wifi_capabilities_test.cc
index 208641aa..4fd68c6e 100644
--- a/apps/test/chqts/src/general_test/wifi_capabilities_test.cc
+++ b/apps/test/chqts/src/general_test/wifi_capabilities_test.cc
@@ -15,6 +15,7 @@
  */
 #include <general_test/wifi_capabilities_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include "chre_api/chre.h"
 
@@ -25,8 +26,8 @@ WifiCapabilitiesTest::WifiCapabilitiesTest() : Test(CHRE_API_VERSION_1_1) {}
 void WifiCapabilitiesTest::setUp(uint32_t messageSize,
                                  const void * /* message */) {
   if (messageSize != 0) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Expected 0 byte message, got more bytes:", &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     uint32_t allCapabilities = CHRE_WIFI_CAPABILITIES_NONE;
 
@@ -48,12 +49,10 @@ void WifiCapabilitiesTest::setUp(uint32_t messageSize,
     // Clear out known capabilities, any remaining are unknown
     if ((capabilities & ~allCapabilities) != 0) {
       if (mApiVersion > CHRE_API_VERSION_1_2) {
-        nanoapp_testing::sendFatalFailureToHost(
-            "New version with unknown capabilities encountered:",
-            &capabilities);
+        EXPECT_FAIL_RETURN("New version with unknown capabilities encountered:",
+                           &capabilities);
       } else {
-        nanoapp_testing::sendFatalFailureToHost(
-            "Received unexpected capabilities:", &capabilities);
+        EXPECT_FAIL_RETURN("Received unexpected capabilities:", &capabilities);
       }
     } else {
       nanoapp_testing::sendSuccessToHost();
diff --git a/apps/test/chqts/src/general_test/wwan_capabilities_test.cc b/apps/test/chqts/src/general_test/wwan_capabilities_test.cc
index b0557eb6..a6ec9919 100644
--- a/apps/test/chqts/src/general_test/wwan_capabilities_test.cc
+++ b/apps/test/chqts/src/general_test/wwan_capabilities_test.cc
@@ -15,6 +15,7 @@
  */
 #include <general_test/wwan_capabilities_test.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
@@ -26,8 +27,8 @@ WwanCapabilitiesTest::WwanCapabilitiesTest() : Test(CHRE_API_VERSION_1_1) {}
 void WwanCapabilitiesTest::setUp(uint32_t messageSize,
                                  const void * /* message */) {
   if (messageSize != 0) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Expected 0 byte message, got more bytes:", &messageSize);
+    EXPECT_FAIL_RETURN("Expected 0 byte message, got more bytes:",
+                       &messageSize);
   } else {
     uint32_t allCapabilities = CHRE_WWAN_CAPABILITIES_NONE;
 
@@ -35,18 +36,20 @@ void WwanCapabilitiesTest::setUp(uint32_t messageSize,
       allCapabilities |= CHRE_WWAN_GET_CELL_INFO;
     }
 
+    if (mApiVersion >= CHRE_API_VERSION_1_11) {
+      allCapabilities |= CHRE_WWAN_GET_CELL_NEIGHBOR_INFO;
+    }
+
     // Call the new API
     uint32_t capabilities = chreWwanGetCapabilities();
 
     // Clear out known capabilities, any remaining are unknown
     if ((capabilities & ~allCapabilities) != 0) {
       if (mApiVersion > CHRE_API_VERSION_1_2) {
-        nanoapp_testing::sendFatalFailureToHost(
-            "New version with unknown capabilities encountered:",
-            &capabilities);
+        EXPECT_FAIL_RETURN("New version with unknown capabilities encountered:",
+                           &capabilities);
       } else {
-        nanoapp_testing::sendFatalFailureToHost(
-            "Received unexpected capabilities:", &capabilities);
+        EXPECT_FAIL_RETURN("Received unexpected capabilities:", &capabilities);
       }
     } else {
       nanoapp_testing::sendSuccessToHost();
diff --git a/apps/test/chqts/src/general_test/wwan_cell_info_test.cc b/apps/test/chqts/src/general_test/wwan_cell_info_test.cc
index bdafefa7..0491773b 100644
--- a/apps/test/chqts/src/general_test/wwan_cell_info_test.cc
+++ b/apps/test/chqts/src/general_test/wwan_cell_info_test.cc
@@ -23,6 +23,7 @@
 #include <general_test/cell_info_tdscdma.h>
 #include <general_test/cell_info_wcdma.h>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre/util/macros.h"
@@ -45,15 +46,13 @@ void WwanCellInfoTest::setUp(uint32_t messageSize, const void *message) {
   if ((chreWwanGetCapabilities() & CHRE_WWAN_GET_CELL_INFO) == 0) {
     sendMessageToHost(nanoapp_testing::MessageType::kSkipped);
   } else if (!chreWwanGetCellInfoAsync(&mTimerHandle)) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "chreWwanGetCellInfo failed unexpectedly");
+    EXPECT_FAIL_RETURN("chreWwanGetCellInfo failed unexpectedly");
   } else {
     mTimerHandle = chreTimerSet(CHRE_ASYNC_RESULT_TIMEOUT_NS, &mTimerHandle,
                                 true /* oneShot */);
 
     if (mTimerHandle == CHRE_TIMER_INVALID) {
-      nanoapp_testing::sendFatalFailureToHost(
-          "Unable to set timer for automatic failure");
+      EXPECT_FAIL_RETURN("Unable to set timer for automatic failure");
     }
   }
 }
@@ -67,19 +66,16 @@ void WwanCellInfoTest::handleEvent(uint32_t senderInstanceId,
                                    uint16_t eventType, const void *eventData) {
   // The only expected message is from the async call
   if (senderInstanceId != CHRE_INSTANCE_ID) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "handleEvent received event from unexpected sender:",
-        &senderInstanceId);
+    EXPECT_FAIL_RETURN("handleEvent received event from unexpected sender:",
+                       &senderInstanceId);
   } else if (eventType == CHRE_EVENT_WWAN_CELL_INFO_RESULT) {
     cancelTimer();
     validateCellInfoResult(eventData);
   } else if (eventType == CHRE_EVENT_TIMER) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "chreWwanGetCellInfo did not return data in time");
+    EXPECT_FAIL_RETURN("chreWwanGetCellInfo did not return data in time");
   } else {
     uint32_t type = eventType;
-    nanoapp_testing::sendFatalFailureToHost(
-        "handleEvent received an unexpected eventType:", &type);
+    EXPECT_FAIL_RETURN("handleEvent received an unexpected eventType:", &type);
   }
 }
 
@@ -141,18 +137,17 @@ void WwanCellInfoTest::validateCellInfoResult(const void *eventData) const {
       static_cast<const chreWwanCellInfoResult *>(eventData);
 
   if (eventData == nullptr) {
-    nanoapp_testing::sendFatalFailureToHost("Received eventData is null");
+    EXPECT_FAIL_RETURN("Received eventData is null");
   } else if (result->version != CHRE_WWAN_CELL_INFO_RESULT_VERSION) {
-    nanoapp_testing::sendFatalFailureToHost(
-        "Received version is unexpected value");
+    EXPECT_FAIL_RETURN("Received version is unexpected value");
   } else if (result->reserved != 0) {
-    nanoapp_testing::sendFatalFailureToHost("Received reserved field non-zero");
+    EXPECT_FAIL_RETURN("Received reserved field non-zero");
   } else {
     const uint32_t *receivedCookie =
         static_cast<const uint32_t *>(result->cookie);
 
     if (receivedCookie != &mTimerHandle) {
-      nanoapp_testing::sendFatalFailureToHost("Received cookie does not match");
+      EXPECT_FAIL_RETURN("Received cookie does not match");
     } else if (result->cellInfoCount != 0) {
       validateCellInfo(result->cellInfoCount, result->cells);
     } else {
diff --git a/apps/test/chqts/src/shared/macros.h b/apps/test/chqts/src/shared/macros.h
index 937064dc..39534496 100644
--- a/apps/test/chqts/src/shared/macros.h
+++ b/apps/test/chqts/src/shared/macros.h
@@ -19,47 +19,79 @@
 
 #include "send_message.h"
 
+/**
+ * A helper macro to perform an assertion in tests that leverage
+ * nanoapp_testing::sendFailureToHost and returns from the current function.
+ *
+ * This macro can be used in the following ways:
+ * 1. EXPECT_FAIL_RETURN(const char *message)
+ * 2. EXPECT_FAIL_RETURN(const char *message, uint32_t *value)
+ *
+ * In usage (2), an integer value will be encoded at the end of the message
+ * string, and will be forwarded to the test host through sendFailureToHost.
+ *
+ * Note that this macro can only be used in functions that return a `void`.
+ */
+#define EXPECT_FAIL_RETURN(...)                      \
+  do {                                               \
+    nanoapp_testing::sendFailureToHost(__VA_ARGS__); \
+    return;                                          \
+  } while (0)
+
+/**
+ * An additional helper macro that can be used to print a uint8 instead of
+ * uint32 in usage (2) of EXPECT_FAIL_RETURN.
+ *
+ * TODO(b/396134028): Consolidate this with the EXPECT_FAIL_RETURN macro.
+ */
+#define EXPECT_FAIL_RETURN_UINT8(message, value)    \
+  static_assert(sizeof(value) <= sizeof(uint32_t)); \
+  do {                                              \
+    uint32_t valueU32 = value;                      \
+    EXPECT_FAIL_RETURN(message, &valueU32);         \
+  } while (0)
+
 /**
  * Asserts the two provided values are equal. If the assertion fails, then a
  * fatal failure occurs.
  */
-#define ASSERT_EQ(val1, val2, failureMessage) \
-  if ((val1) != (val2)) sendFatalFailureToHost(failureMessage)
+#define EXPECT_EQ_OR_RETURN(val1, val2, failureMessage) \
+  if ((val1) != (val2)) EXPECT_FAIL_RETURN(failureMessage)
 
 /**
  * Asserts the two provided values are not equal. If the assertion fails, then
  * a fatal failure occurs.
  */
-#define ASSERT_NE(val1, val2, failureMessage) \
-  if ((val1) == (val2)) sendFatalFailureToHost(failureMessage)
+#define EXPECT_NE_OR_RETURN(val1, val2, failureMessage) \
+  if ((val1) == (val2)) EXPECT_FAIL_RETURN(failureMessage)
 
 /**
  * Asserts the given value is greater than or equal to value of lower. If the
  * value fails this assertion, then a fatal failure occurs.
  */
-#define ASSERT_GE(value, lower, failureMessage) \
-  if ((value) < (lower)) sendFatalFailureToHost(failureMessage)
+#define EXPECT_GE_OR_RETURN(value, lower, failureMessage) \
+  if ((value) < (lower)) EXPECT_FAIL_RETURN(failureMessage)
 
 /**
  * Asserts the given value is less than or equal to value of upper. If the value
  * fails this assertion, then a fatal failure occurs.
  */
-#define ASSERT_LE(value, upper, failureMessage) \
-  if ((value) > (upper)) sendFatalFailureToHost(failureMessage)
+#define EXPECT_LE_OR_RETURN(value, upper, failureMessage) \
+  if ((value) > (upper)) EXPECT_FAIL_RETURN(failureMessage)
 
 /**
  * Asserts the given value is less than the value of upper. If the value fails
  * this assertion, then a fatal failure occurs.
  */
-#define ASSERT_LT(value, upper, failureMessage) \
-  if ((value) >= (upper)) sendFatalFailureToHost(failureMessage)
+#define EXPECT_LT_OR_RETURN(value, upper, failureMessage) \
+  if ((value) >= (upper)) EXPECT_FAIL_RETURN(failureMessage)
 
 /**
  * Asserts the given value is within the range defined by lower and upper
  * (inclusive). If the value is outside the range, then a fatal failure occurs.
  */
-#define ASSERT_IN_RANGE(value, lower, upper, failureMessage) \
-  ASSERT_GE((value), (lower), failureMessage);               \
-  ASSERT_LE((value), (upper), failureMessage)
+#define EXPECT_IN_RANGE_OR_RETURN(value, lower, upper, failureMessage) \
+  EXPECT_GE_OR_RETURN((value), (lower), failureMessage);               \
+  EXPECT_LE_OR_RETURN((value), (upper), failureMessage)
 
 #endif  // _GTS_NANOAPPS_SHARED_MACROS_H_
\ No newline at end of file
diff --git a/apps/test/chqts/src/shared/nano_string.cc b/apps/test/chqts/src/shared/nano_string.cc
index 213b38b9..2caee586 100644
--- a/apps/test/chqts/src/shared/nano_string.cc
+++ b/apps/test/chqts/src/shared/nano_string.cc
@@ -18,6 +18,7 @@
 
 #ifndef INTERNAL_TESTING
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #define REPORT_INTERNAL_ERROR(msg) sendInternalFailureToHost(msg)
 
diff --git a/apps/test/chqts/src/shared/send_message.cc b/apps/test/chqts/src/shared/send_message.cc
index 75972368..c0b76b9f 100644
--- a/apps/test/chqts/src/shared/send_message.cc
+++ b/apps/test/chqts/src/shared/send_message.cc
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include <inttypes.h>
@@ -31,6 +32,12 @@
 
 namespace nanoapp_testing {
 
+namespace {
+// If true, indicates that a test has failed. This variable is used to guard
+// against sending additional messages to the host when the test already failed.
+bool gTestFailed = false;
+}  // namespace
+
 constexpr size_t kAllocSize = 128;
 
 static ChunkAllocator<kAllocSize, 4> gChunkAlloc;
@@ -38,14 +45,13 @@ static ChunkAllocator<kAllocSize, 4> gChunkAlloc;
 static void freeChunkAllocMessage(void *message, size_t messageSize) {
   if (messageSize > kAllocSize) {
     uint32_t localSize = uint32_t(messageSize);
-    sendFatalFailureToHost("freeChunkAllocMessage given oversized message:",
-                           &localSize);
+    EXPECT_FAIL_RETURN("freeChunkAllocMessage given oversized message:",
+                       &localSize);
   }
   if (!gChunkAlloc.free(message)) {
     uint32_t localPtr =
         reinterpret_cast<size_t>(message) & UINT32_C(0xFFFFFFFF);
-    sendFatalFailureToHost("freeChunkAllocMessage given bad pointer:",
-                           &localPtr);
+    EXPECT_FAIL_RETURN("freeChunkAllocMessage given bad pointer:", &localPtr);
   }
 }
 
@@ -53,8 +59,7 @@ static void freeHeapMessage(void *message, size_t /* messageSize */) {
   if (gChunkAlloc.contains(message)) {
     uint32_t localPtr =
         reinterpret_cast<size_t>(message) & UINT32_C(0xFFFFFFFF);
-    sendFatalFailureToHost("freeHeapMessage given ChunkAlloc pointer:",
-                           &localPtr);
+    EXPECT_FAIL_RETURN("freeHeapMessage given ChunkAlloc pointer:", &localPtr);
   }
   chreHeapFree(message);
 }
@@ -112,6 +117,15 @@ static void *prependMessageType(MessageType messageType, void *memory) {
 
 static void internalSendMessage(MessageType messageType, void *data,
                                 size_t dataSize, bool ChunkAlloc) {
+  if (gTestFailed) {
+    LOGW("Test already failed: skipping sending message type %" PRIu32,
+         messageType);
+    return;
+  } else if (messageType == MessageType::kFailure ||
+             messageType == MessageType::kInternalFailure) {
+    gTestFailed = true;
+  }
+
   // Note that if the CHRE implementation occasionally drops a message
   // here, then tests will become flaky.  For now, we consider that to
   // be a flaky CHRE implementation which should fail testing.
@@ -166,34 +180,18 @@ void sendStringToHost(MessageType messageType, const char *message,
   internalSendMessage(messageType, fullMessage, fullMessageLen, ChunkAlloc);
 }
 
-// Before we abort the nanoapp, we also put this message in the LOGI().
-// We have no assurance our message will make it to the Host (not required
-// for CHRE implementations), but this will at least make sure our message
-// hits the log.
-static void logFatalMessage(const char *message, const uint32_t *value) {
+void logFailureMessage(const char *message, const uint32_t *value) {
   if (value != nullptr) {
-    LOGE("TEST ABORT: %s0x%08" PRIX32, message, *value);
+    LOGE("TEST FAIL: %s0x%08" PRIX32, message, *value);
   } else {
-    LOGE("TEST ABORT: %s", message);
+    LOGE("TEST FAIL: %s", message);
   }
 }
 
-void sendFatalFailureToHost(const char *message, const uint32_t *value,
-                            AbortBlame reason) {
-  sendFailureToHost(message, value);
-  logFatalMessage(message, value);
-  nanoapp_testing::abort(reason);
-}
-
-void sendFatalFailureToHostUint8(const char *message, uint8_t value) {
-  uint32_t val = value;
-  sendFatalFailureToHost(message, &val);
-}
-
 void sendInternalFailureToHost(const char *message, const uint32_t *value,
                                AbortBlame reason) {
   sendStringToHost(MessageType::kInternalFailure, message, value);
-  logFatalMessage(message, value);
+  logFailureMessage(message, value);
   nanoapp_testing::abort(reason);
 }
 
diff --git a/apps/test/chqts/src/shared/send_message.h b/apps/test/chqts/src/shared/send_message.h
index f8ccf364..845b3080 100644
--- a/apps/test/chqts/src/shared/send_message.h
+++ b/apps/test/chqts/src/shared/send_message.h
@@ -134,33 +134,21 @@ void sendStringToHost(MessageType messageType, const char *message,
                       const uint32_t *value = nullptr);
 
 /**
- * Same as sendStringToHost(), but using MessageType::kFailure for the 'status'.
+ * The semantics of this method is the same as sendFailureToHost, except the
+ * message is logged through chreLog.
+ */
+void logFailureMessage(const char *message, const uint32_t *value = nullptr);
+
+/**
+ * Same as sendStringToHost(), but using MessageType::kFailure for the 'status',
+ * and also logs the message using chreLog.
  */
 inline void sendFailureToHost(const char *message,
                               const uint32_t *value = nullptr) {
   sendStringToHost(MessageType::kFailure, message, value);
+  logFailureMessage(message, value);
 }
 
-/**
- * Same as sendFailureToHost(), but aborts the test with the given 'reason',
- * and never returns.
- */
-void sendFatalFailureToHost(const char *message,
-                            const uint32_t *value = nullptr,
-                            AbortBlame reason = AbortBlame::kChre);
-
-/**
- * Helper function to invoke sendFatalFailureToHost() with uint8_t type.
- * It is needed since sendFatalFailureToHost() only accepts uint32_t type.
- *
- * TODO: Deprecate this function and redesign sendFatalFailureToHost()
- * so that a generic string message is accepted.
- *
- * @param message a text message to be sent to host.
- * @param value a value output into the message.
- */
-void sendFatalFailureToHostUint8(const char *message, const uint8_t value);
-
 /**
  * Same as sendStringToHost(), but uses MessageType::kInternalFailure for the
  * 'status', and aborts the test with the given 'reason' and never returns.
diff --git a/apps/test/chqts/src/shared/test_success_marker.cc b/apps/test/chqts/src/shared/test_success_marker.cc
index 2719fcb0..42104df6 100644
--- a/apps/test/chqts/src/shared/test_success_marker.cc
+++ b/apps/test/chqts/src/shared/test_success_marker.cc
@@ -15,6 +15,7 @@
  */
 
 #include <chre/util/nanoapp/log.h>
+#include <shared/macros.h>
 #include <shared/send_message.h>
 #include <shared/test_success_marker.h>
 
@@ -24,8 +25,8 @@ namespace nanoapp_testing {
 
 TestSuccessMarker::TestSuccessMarker(uint32_t numStages) {
   if (numStages > 32) {
-    sendFatalFailureToHost(
-        "Total number of stage should be less than 33, got %d", &numStages);
+    EXPECT_FAIL_RETURN("Total number of stage should be less than 33, got %d",
+                       &numStages);
   }
   mAllFinished = (UINT64_C(1) << numStages) - 1;
 }
@@ -33,7 +34,7 @@ TestSuccessMarker::TestSuccessMarker(uint32_t numStages) {
 void TestSuccessMarker::markStage(uint32_t stage) {
   uint32_t finishedBit = (1 << stage);
   if ((mAllFinished & finishedBit) == 0) {
-    sendFatalFailureToHost("markSuccess invalid stage", &stage);
+    EXPECT_FAIL_RETURN("markSuccess invalid stage", &stage);
   }
   if ((mFinishedBitmask & finishedBit) == 0) {
     LOGD("Stage %" PRIu32 " succeeded", stage);
diff --git a/apps/test/chqts/src/who_am_i/who_am_i.cc b/apps/test/chqts/src/who_am_i/who_am_i.cc
index 00c4e6cd..7b2d8ad7 100644
--- a/apps/test/chqts/src/who_am_i/who_am_i.cc
+++ b/apps/test/chqts/src/who_am_i/who_am_i.cc
@@ -25,12 +25,11 @@
 #include <cstdint>
 #include <cstring>
 
+#include <shared/macros.h>
 #include <shared/send_message.h>
 
 #include "chre_api/chre.h"
 
-using nanoapp_testing::sendFatalFailureToHost;
-
 namespace chre {
 namespace {
 
@@ -45,7 +44,7 @@ extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
     auto *msg = static_cast<const chreMessageFromHostData *>(eventData);
 
     if (senderInstanceId != CHRE_INSTANCE_ID) {
-      sendFatalFailureToHost("Invalid sender instance ID:", &senderInstanceId);
+      EXPECT_FAIL_RETURN("Invalid sender instance ID:", &senderInstanceId);
     }
 
     messageBuffer[0] = (msg->hostEndpoint & 0xff00) >> 8;
@@ -54,7 +53,7 @@ extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
                                        sizeof(messageBuffer), msg->messageType,
                                        msg->hostEndpoint,
                                        nullptr /* messageFreeCallback */)) {
-      sendFatalFailureToHost("Failed to send message to host");
+      EXPECT_FAIL_RETURN("Failed to send message to host");
     }
   }
 }
diff --git a/apps/test/common/chre_api_test/chre_api_test.mk b/apps/test/common/chre_api_test/chre_api_test.mk
index 1dd56f7a..edc3947a 100644
--- a/apps/test/common/chre_api_test/chre_api_test.mk
+++ b/apps/test/common/chre_api_test/chre_api_test.mk
@@ -33,7 +33,6 @@ COMMON_SRCS += $(CHRE_PREFIX)/util/nanoapp/string.cc
 COMMON_CFLAGS += -DNANOAPP_MINIMUM_LOG_LEVEL=CHRE_LOG_LEVEL_DEBUG
 COMMON_CFLAGS += -DCHRE_ASSERTIONS_ENABLED
 COMMON_CFLAGS += -DPB_FIELD_16BIT
-COMMON_CFLAGS += -fno-threadsafe-statics
 
 # Includes
 COMMON_CFLAGS += -I$(NANOAPP_PATH)/inc
diff --git a/apps/test/common/chre_cross_validator_sensor/Makefile b/apps/test/common/chre_cross_validator_sensor/Makefile
index 7602d0e6..cd3162ba 100644
--- a/apps/test/common/chre_cross_validator_sensor/Makefile
+++ b/apps/test/common/chre_cross_validator_sensor/Makefile
@@ -42,7 +42,7 @@ COMMON_SRCS += $(CHRE_PREFIX)/util/nanoapp/callbacks.cc
 # Compiler Flags ###############################################################
 
 # Defines
-COMMON_CFLAGS += -DNANOAPP_MINIMUM_LOG_LEVEL=CHRE_LOG_LEVEL_INFO
+COMMON_CFLAGS += -DNANOAPP_MINIMUM_LOG_LEVEL=CHRE_LOG_LEVEL_DEBUG
 COMMON_CFLAGS += -DCHRE_ASSERTIONS_ENABLED
 
 # Includes
diff --git a/apps/test/common/chre_cross_validator_sensor/inc/chre_cross_validator_sensor_manager.h b/apps/test/common/chre_cross_validator_sensor/inc/chre_cross_validator_sensor_manager.h
index 89b6a801..e6c61b27 100644
--- a/apps/test/common/chre_cross_validator_sensor/inc/chre_cross_validator_sensor_manager.h
+++ b/apps/test/common/chre_cross_validator_sensor/inc/chre_cross_validator_sensor_manager.h
@@ -25,9 +25,7 @@
 #include "chre/util/optional.h"
 #include "chre/util/singleton.h"
 
-namespace chre {
-
-namespace cross_validator_sensor {
+namespace chre::cross_validator_sensor {
 
 // TODO(b/154271551): Break up the Manager class into more fine-grained classes
 // to avoid it becoming to complex.
@@ -269,7 +267,7 @@ class Manager {
    * @return The Data proto message that is ready to be sent to host with three
    * axis data.
    */
-  chre_cross_validation_sensor_Data makeSensorThreeAxisData(
+  static chre_cross_validation_sensor_Data makeSensorThreeAxisData(
       const chreSensorThreeAxisData *threeAxisDataFromChre, uint8_t sensorType);
 
   /**
@@ -279,7 +277,7 @@ class Manager {
    * @return The Data proto message that is ready to be sent to host with float
    * data.
    */
-  chre_cross_validation_sensor_Data makeSensorFloatData(
+  static chre_cross_validation_sensor_Data makeSensorFloatData(
       const chreSensorFloatData *floatDataFromChre, uint8_t sensorType);
 
   /**
@@ -289,7 +287,7 @@ class Manager {
    * @return The Data proto message that is ready to be sent to host with float
    * data.
    */
-  chre_cross_validation_sensor_Data makeSensorProximityData(
+  static chre_cross_validation_sensor_Data makeSensorProximityData(
       const chreSensorByteData *proximityDataFromChre);
 
   /**
@@ -299,7 +297,7 @@ class Manager {
    * @return The Data proto message that is ready to be sent to host with float
    * data.
    */
-  chre_cross_validation_sensor_Data makeSensorStepCounterData(
+  static chre_cross_validation_sensor_Data makeSensorStepCounterData(
       const chreSensorUint64Data *stepCounterDataFromChre);
 
   /**
@@ -349,7 +347,7 @@ class Manager {
    * @param hostEndpoint The endpoint to send the response to.
    * @param infoResponse The info response to be encoded and sent.
    */
-  void sendInfoResponse(
+  static void sendInfoResponse(
       uint16_t hostEndpoint,
       const chre_cross_validation_sensor_SensorInfoResponse &infoResponse);
 
@@ -386,14 +384,13 @@ class Manager {
    *
    * @return true if the sensor corresponding to the input is available.
    */
-  bool getSensor(uint32_t sensorType, uint32_t sensorIndex, uint32_t *handle);
+  static bool getSensor(uint32_t sensorType, uint32_t sensorIndex,
+                        uint32_t *handle);
 };
 
 // The chre cross validator manager singleton.
 typedef chre::Singleton<Manager> ManagerSingleton;
 
-}  // namespace cross_validator_sensor
-
-}  // namespace chre
+}  // namespace chre::cross_validator_sensor
 
 #endif  // CHRE_CROSS_VALIDATOR_MANAGER_H_
diff --git a/apps/test/common/chre_cross_validator_sensor/src/chre_cross_validator_sensor_manager.cc b/apps/test/common/chre_cross_validator_sensor/src/chre_cross_validator_sensor_manager.cc
index dfb60221..c779b0c7 100644
--- a/apps/test/common/chre_cross_validator_sensor/src/chre_cross_validator_sensor_manager.cc
+++ b/apps/test/common/chre_cross_validator_sensor/src/chre_cross_validator_sensor_manager.cc
@@ -25,31 +25,50 @@
 #include "chre/util/macros.h"
 #include "chre/util/nanoapp/callbacks.h"
 #include "chre/util/nanoapp/log.h"
-#include "chre/util/optional.h"
 #include "chre/util/time.h"
 #include "chre_api/chre.h"
-#include "chre_cross_validation_sensor.nanopb.h"
 #include "send_message.h"
 
 #define LOG_TAG "[ChreCrossValidator]"
 
-namespace chre {
-
-namespace cross_validator_sensor {
+namespace chre::cross_validator_sensor {
 
 namespace {
 
+struct SensorNameCallbackData {
+  const void *sensorName;
+  size_t size;
+};
+
 bool decodeSensorName(pb_istream_t *stream, const pb_field_s *field,
                       void **arg) {
   UNUSED_VAR(field);
+  auto *name = static_cast<unsigned char *>(*arg);
 
-  unsigned char *name = static_cast<unsigned char *>(*arg);
-
-  if (stream->bytes_left > kMaxSensorNameSize - 1) return false;
+  if (stream->bytes_left > kMaxSensorNameSize - 1) {
+    return false;
+  }
 
   size_t bytesToCopy = stream->bytes_left;
-  if (!pb_read(stream, name, stream->bytes_left)) return false;
+  if (!pb_read(stream, name, stream->bytes_left)) {
+    return false;
+  }
+
   name[bytesToCopy] = '\0';
+  return true;
+}
+
+bool encodeSensorName(pb_ostream_t *stream, const pb_field_t *field,
+                      void *const *arg) {
+  auto *sensorNameData = static_cast<const SensorNameCallbackData *>(*arg);
+
+  if (sensorNameData->size > 0) {
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(
+               stream,
+               static_cast<const pb_byte_t *>(sensorNameData->sensorName),
+               sensorNameData->size);
+  }
 
   return true;
 }
@@ -61,21 +80,12 @@ Manager::~Manager() {
 }
 
 void Manager::cleanup() {
-  if (mCrossValidatorState.has_value()) {
-    switch (mCrossValidatorState->crossValidatorType) {
-      case CrossValidatorType::SENSOR:
-        if (!chreSensorConfigureModeOnly(mCrossValidatorState->sensorHandle,
-                                         CHRE_SENSOR_CONFIGURE_MODE_DONE)) {
-          LOGE(
-              "Sensor cleanup failed when trying to configure sensor with "
-              "handle "
-              "%" PRIu32 " to done mode",
-              mCrossValidatorState->sensorHandle);
-        }
-        break;
-      default:
-        break;
-    }
+  if (mCrossValidatorState.has_value() &&
+      mCrossValidatorState->crossValidatorType == CrossValidatorType::SENSOR &&
+      !chreSensorConfigureModeOnly(mCrossValidatorState->sensorHandle,
+                                   CHRE_SENSOR_CONFIGURE_MODE_DONE)) {
+    LOGE("Sensor cleanup failed to set mode to DONE. handle=%" PRIu32,
+         mCrossValidatorState->sensorHandle);
   }
 }
 
@@ -123,9 +133,8 @@ void Manager::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
       // Ignore sampling state changes
       break;
     default:
-      LOGE("Got unknown event type from senderInstanceId %" PRIu32
-           " and with eventType %" PRIu16,
-           senderInstanceId, eventType);
+      LOGE("Got unknown event type %" PRIu16 " from senderInstanceId %" PRIu32,
+           eventType, senderInstanceId);
   }
 }
 
@@ -135,7 +144,7 @@ bool Manager::encodeThreeAxisSensorDatapointValues(pb_ostream_t *stream,
   const auto *sensorThreeAxisDataSample = static_cast<
       const chreSensorThreeAxisData::chreSensorThreeAxisSampleData *>(*arg);
 
-  for (size_t i = 0; i < 3; i++) {
+  for (const float &value : sensorThreeAxisDataSample->values) {
     if (!pb_encode_tag_for_field(
             stream,
             &chre_cross_validation_sensor_SensorDatapoint_fields
@@ -143,7 +152,7 @@ bool Manager::encodeThreeAxisSensorDatapointValues(pb_ostream_t *stream,
                  1])) {
       return false;
     }
-    if (!pb_encode_fixed32(stream, &sensorThreeAxisDataSample->values[i])) {
+    if (!pb_encode_fixed32(stream, &value)) {
       return false;
     }
   }
@@ -165,16 +174,12 @@ bool Manager::encodeFloatSensorDatapointValue(pb_ostream_t *stream,
                                               void *const *arg) {
   const auto *sensorFloatDataSample =
       static_cast<const chreSensorFloatData::chreSensorFloatSampleData *>(*arg);
-  if (!pb_encode_tag_for_field(
-          stream,
-          &chre_cross_validation_sensor_SensorDatapoint_fields
-              [chre_cross_validation_sensor_SensorDatapoint_values_tag - 1])) {
-    return false;
-  }
-  if (!pb_encode_fixed32(stream, &sensorFloatDataSample->value)) {
-    return false;
-  }
-  return true;
+  return pb_encode_tag_for_field(
+             stream,
+             &chre_cross_validation_sensor_SensorDatapoint_fields
+                 [chre_cross_validation_sensor_SensorDatapoint_values_tag -
+                  1]) &&
+         pb_encode_fixed32(stream, &sensorFloatDataSample->value);
 }
 
 bool Manager::encodeProximitySensorDatapointValue(pb_ostream_t *stream,
@@ -182,40 +187,29 @@ bool Manager::encodeProximitySensorDatapointValue(pb_ostream_t *stream,
                                                   void *const *arg) {
   const auto *sensorFloatDataSample =
       static_cast<const chreSensorByteData::chreSensorByteSampleData *>(*arg);
-  if (!pb_encode_tag_for_field(
-          stream,
-          &chre_cross_validation_sensor_SensorDatapoint_fields
-              [chre_cross_validation_sensor_SensorDatapoint_values_tag - 1])) {
-    return false;
-  }
   float isNearFloat = sensorFloatDataSample->isNear ? 0.0 : 1.0;
-  if (!pb_encode_fixed32(stream, &isNearFloat)) {
-    return false;
-  }
-  return true;
+  return pb_encode_tag_for_field(
+             stream,
+             &chre_cross_validation_sensor_SensorDatapoint_fields
+                 [chre_cross_validation_sensor_SensorDatapoint_values_tag -
+                  1]) &&
+         pb_encode_fixed32(stream, &isNearFloat);
 }
 
-bool Manager::encodeStepCounterSensorDatapointValue(pb_ostream_t *stream,
-                                                    const pb_field_t *field,
-                                                    void *const *arg) {
-  UNUSED_VAR(field);
-
+bool Manager::encodeStepCounterSensorDatapointValue(
+    pb_ostream_t *stream, const pb_field_t * /*field*/, void *const *arg) {
   const auto *sensorUint64DataSample =
       static_cast<const chreSensorUint64Data::chreSensorUint64SampleData *>(
           *arg);
-  if (!pb_encode_tag_for_field(
-          stream,
-          &chre_cross_validation_sensor_SensorDatapoint_fields
-              [chre_cross_validation_sensor_SensorDatapoint_values_tag - 1])) {
-    return false;
-  }
   // This value is casted to a float for the Java sensors framework so do it
   // here to make it easier to encode into the existing proto message.
-  float stepValue = float(sensorUint64DataSample->value);
-  if (!pb_encode_fixed32(stream, &stepValue)) {
-    return false;
-  }
-  return true;
+  auto stepValue = static_cast<float>(sensorUint64DataSample->value);
+  return pb_encode_tag_for_field(
+             stream,
+             &chre_cross_validation_sensor_SensorDatapoint_fields
+                 [chre_cross_validation_sensor_SensorDatapoint_values_tag -
+                  1]) &&
+         pb_encode_fixed32(stream, &stepValue);
 }
 
 bool Manager::encodeThreeAxisSensorDatapoints(pb_ostream_t *stream,
@@ -302,10 +296,8 @@ bool Manager::encodeProximitySensorDatapoints(pb_ostream_t *stream,
 }
 
 bool Manager::encodeStepCounterSensorDatapoints(pb_ostream_t *stream,
-                                                const pb_field_t *field,
+                                                const pb_field_t * /*field*/,
                                                 void *const *arg) {
-  UNUSED_VAR(field);
-
   const auto *sensorStepCounterData =
       static_cast<const chreSensorUint64Data *>(*arg);
   uint64_t currentTimestamp = sensorStepCounterData->header.baseTimestamp +
@@ -333,7 +325,6 @@ bool Manager::encodeStepCounterSensorDatapoints(pb_ostream_t *stream,
 
 bool Manager::handleStartSensorMessage(
     const chre_cross_validation_sensor_StartSensorCommand &startSensorCommand) {
-  bool success = false;
   uint8_t sensorType = startSensorCommand.chreSensorType;
   uint64_t intervalFromApInNs =
       startSensorCommand.intervalInMs * kOneMillisecondInNanoseconds;
@@ -344,38 +335,38 @@ bool Manager::handleStartSensorMessage(
 
   uint32_t handle;
   if (!getSensor(sensorType, sensorIndex, &handle)) {
+    // TODO(b/146052784): Test other sensor configure modes
     LOGE("Could not find default sensor for sensorType %" PRIu8
          " index %" PRIu32,
          sensorType, sensorIndex);
-    // TODO(b/146052784): Test other sensor configure modes
-  } else {
-    LOGI("Starting x-validation for sensor type %" PRIu8 " index %" PRIu32,
-         sensorType, sensorIndex);
-    chreSensorInfo sensorInfo;
-    if (!chreGetSensorInfo(handle, &sensorInfo)) {
-      LOGE("Error getting sensor info for sensor");
-    } else {
-      // TODO(b/154271547): Send minInterval to AP and have the AP decide from
-      // both CHRE and AP min and max interval.
-      uint64_t intervalInNs =
-          std::max(intervalFromApInNs, sensorInfo.minInterval);
-      // Copy hostEndpoint param from previous version of cross validator
-      // state
-      mCrossValidatorState = CrossValidatorState(
-          CrossValidatorType::SENSOR, sensorType, handle, chreGetTime(),
-          mCrossValidatorState->hostEndpoint, isContinuous);
-      if (!chreSensorConfigure(handle, CHRE_SENSOR_CONFIGURE_MODE_CONTINUOUS,
-                               intervalInNs, latencyInNs)) {
-        LOGE("Error configuring sensor with sensorType %" PRIu8
-             ", interval %" PRIu64 "ns, and latency %" PRIu64 "ns",
-             sensorType, intervalInNs, latencyInNs);
-      } else {
-        LOGD("Sensor with sensor type %" PRIu8 " configured", sensorType);
-        success = true;
-      }
-    }
+    return false;
   }
-  return success;
+
+  LOGI("Starting x-validation for sensor type %" PRIu8 " index %" PRIu32,
+       sensorType, sensorIndex);
+  chreSensorInfo sensorInfo{};
+  if (!chreGetSensorInfo(handle, &sensorInfo)) {
+    LOGE("Error getting sensor info for sensor");
+    return false;
+  }
+
+  // TODO(b/154271547): Send minInterval to AP and have the AP decide from
+  // both CHRE and AP min and max interval.
+  uint64_t intervalInNs = std::max(intervalFromApInNs, sensorInfo.minInterval);
+  // Copy hostEndpoint param from previous version of cross validator
+  // state
+  mCrossValidatorState = CrossValidatorState(
+      CrossValidatorType::SENSOR, sensorType, handle, chreGetTime(),
+      mCrossValidatorState->hostEndpoint, isContinuous);
+  if (!chreSensorConfigure(handle, CHRE_SENSOR_CONFIGURE_MODE_CONTINUOUS,
+                           intervalInNs, latencyInNs)) {
+    LOGE("Error configuring sensor with sensorType %" PRIu8
+         ", interval %" PRIu64 "ns, and latency %" PRIu64 "ns",
+         sensorType, intervalInNs, latencyInNs);
+    return false;
+  }
+  LOGD("Sensor with type %" PRIu8 " is configured", sensorType);
+  return true;
 }
 
 bool Manager::isValidHeader(const chreSensorDataHeader &header) {
@@ -433,38 +424,42 @@ void Manager::handleInfoMessage(uint16_t hostEndpoint,
                  chre_cross_validation_sensor_SensorInfoCommand_fields,
                  &infoCommand)) {
     LOGE("Could not decode info command");
-  } else {
-    uint32_t handle;
-    infoResponse.has_chreSensorType = true;
-    infoResponse.chreSensorType = infoCommand.chreSensorType;
-    infoResponse.has_isAvailable = true;
-    infoResponse.isAvailable = false;
-    infoResponse.has_sensorIndex = false;
-
-    bool supportsMultiSensors =
-        chreSensorFind(infoCommand.chreSensorType, 1, &handle);
-    for (uint8_t i = 0; chreSensorFind(infoCommand.chreSensorType, i, &handle);
-         i++) {
-      struct chreSensorInfo info;
-      if (!chreGetSensorInfo(handle, &info)) {
-        LOGE("Failed to get sensor info");
-      } else {
-        bool equal = true;
-        if (supportsMultiSensors) {
-          equal = (strcmp(info.sensorName, mSensorNameArray) == 0);
-          LOGI("Got sensor name %s in-name %s, equal %d", info.sensorName,
-               mSensorNameArray, equal);
-        }
-        if (equal) {
-          infoResponse.isAvailable = true;
-          infoResponse.has_sensorIndex = true;
-          infoResponse.sensorIndex = i;
-          break;
-        }
-      }
-    }
+    sendInfoResponse(hostEndpoint, infoResponse);
+    return;
   }
+  LOGI("Global sensor name: %s", mSensorNameArray);
 
+  struct SensorNameCallbackData nameData{};
+  uint32_t handle;
+  infoResponse.has_chreSensorType = true;
+  infoResponse.chreSensorType = infoCommand.chreSensorType;
+  infoResponse.has_isAvailable = true;
+  infoResponse.isAvailable = false;
+  infoResponse.has_sensorIndex = false;
+
+  bool supportsMultiSensors =
+      chreSensorFind(infoCommand.chreSensorType, 1, &handle);
+  for (uint8_t i = 0; chreSensorFind(infoCommand.chreSensorType, i, &handle);
+       i++) {
+    struct chreSensorInfo info{};
+    if (!chreGetSensorInfo(handle, &info)) {
+      LOGE("Failed to get sensor info");
+      continue;
+    }
+    LOGI("Found sensor %" PRIu8 ". name: %s", i, info.sensorName);
+    bool hasValidSensor =
+        !supportsMultiSensors || strcmp(info.sensorName, mSensorNameArray) == 0;
+    if (hasValidSensor) {
+      infoResponse.isAvailable = true;
+      infoResponse.has_sensorIndex = true;
+      infoResponse.sensorIndex = i;
+      nameData.sensorName = info.sensorName;
+      nameData.size = strlen(info.sensorName);
+      infoResponse.sensorName.funcs.encode = encodeSensorName;
+      infoResponse.sensorName.arg = &nameData;
+      break;
+    }
+  }
   sendInfoResponse(hostEndpoint, infoResponse);
 }
 
@@ -472,25 +467,25 @@ void Manager::handleMessageFromHost(uint32_t senderInstanceId,
                                     const chreMessageFromHostData *hostData) {
   if (senderInstanceId != CHRE_INSTANCE_ID) {
     LOGE("Incorrect sender instance id: %" PRIu32, senderInstanceId);
+    return;
+  }
+  uint16_t hostEndpoint;
+  if (hostData->hostEndpoint != CHRE_HOST_ENDPOINT_UNSPECIFIED) {
+    hostEndpoint = hostData->hostEndpoint;
   } else {
-    uint16_t hostEndpoint;
-    if (hostData->hostEndpoint != CHRE_HOST_ENDPOINT_UNSPECIFIED) {
-      hostEndpoint = hostData->hostEndpoint;
-    } else {
-      hostEndpoint = CHRE_HOST_ENDPOINT_BROADCAST;
-    }
+    hostEndpoint = CHRE_HOST_ENDPOINT_BROADCAST;
+  }
 
-    switch (hostData->messageType) {
-      case chre_cross_validation_sensor_MessageType_CHRE_CROSS_VALIDATION_START:
-        handleStartMessage(hostEndpoint, hostData);
-        break;
-      case chre_cross_validation_sensor_MessageType_CHRE_CROSS_VALIDATION_INFO:
-        handleInfoMessage(hostEndpoint, hostData);
-        break;
-      default:
-        LOGE("Unknown message type %" PRIu32 " for host message",
-             hostData->messageType);
-    }
+  switch (hostData->messageType) {
+    case chre_cross_validation_sensor_MessageType_CHRE_CROSS_VALIDATION_START:
+      handleStartMessage(hostEndpoint, hostData);
+      break;
+    case chre_cross_validation_sensor_MessageType_CHRE_CROSS_VALIDATION_INFO:
+      handleInfoMessage(hostEndpoint, hostData);
+      break;
+    default:
+      LOGE("Unknown message type %" PRIu32 " for host message",
+           hostData->messageType);
   }
 }
 
@@ -663,6 +658,4 @@ bool Manager::getSensor(uint32_t sensorType, uint32_t sensorIndex,
   return success;
 }
 
-}  // namespace cross_validator_sensor
-
-}  // namespace chre
+}  // namespace chre::cross_validator_sensor
diff --git a/apps/test/common/chre_cross_validator_wwan/Makefile b/apps/test/common/chre_cross_validator_wwan/Makefile
new file mode 100644
index 00000000..dac17da8
--- /dev/null
+++ b/apps/test/common/chre_cross_validator_wwan/Makefile
@@ -0,0 +1,59 @@
+#
+# CHRE Cross Validator Nanoapp Makefile
+#
+
+# Environment Checks ###########################################################
+ifeq ($(CHRE_PREFIX),)
+  ifneq ($(ANDROID_BUILD_TOP),)
+    CHRE_PREFIX = $(ANDROID_BUILD_TOP)/system/chre
+  else
+    $(error "You must run 'lunch' to setup ANDROID_BUILD_TOP, or explicitly \
+    define the CHRE_PREFIX environment variable to point to the CHRE root \
+    directory.")
+  endif
+endif
+
+# Nanoapp Configuration ########################################################
+
+NANOAPP_NAME = chre_cross_validator_wwan
+NANOAPP_ID = 0x476f6f6754000011
+NANOAPP_NAME_STRING = \"Chre\ Cross\ Validator\ WWAN\"
+NANOAPP_VERSION = 0x00000001
+
+NANOAPP_PATH = $(CHRE_PREFIX)/apps/test/common/chre_cross_validator_wwan
+TEST_SHARED_PATH = $(CHRE_PREFIX)/apps/test/common/shared
+
+
+# Protobuf Sources #############################################################
+
+NANOPB_EXTENSION = nanopb
+
+NANOPB_SRCS += $(NANOAPP_PATH)/../proto/chre_cross_validation_wwan.proto
+NANOPB_SRCS += $(NANOAPP_PATH)/../proto/chre_test_common.proto
+NANOPB_INCLUDES = $(NANOAPP_PATH)/../proto
+
+# Source Code ##################################################################
+
+COMMON_SRCS += $(NANOAPP_PATH)/src/chre_cross_validator_wwan.cc
+COMMON_SRCS += $(NANOAPP_PATH)/src/chre_cross_validator_wwan_manager.cc
+COMMON_SRCS += $(TEST_SHARED_PATH)/src/send_message.cc
+COMMON_SRCS += $(CHRE_PREFIX)/util/nanoapp/callbacks.cc
+
+# Compiler Flags ###############################################################
+
+# Defines
+COMMON_CFLAGS += -DNANOAPP_MINIMUM_LOG_LEVEL=CHRE_LOG_LEVEL_INFO
+COMMON_CFLAGS += -DLOG_TAG=\"[ChreCrossValidatorWwan]\"
+COMMON_CFLAGS += -DCHRE_ASSERTIONS_ENABLED
+
+# Includes
+COMMON_CFLAGS += -I$(NANOAPP_PATH)/inc
+COMMON_CFLAGS += -I$(TEST_SHARED_PATH)/inc
+
+# Permission declarations ######################################################
+
+CHRE_NANOAPP_USES_WWAN = true
+
+# Makefile Includes ############################################################
+
+include $(CHRE_PREFIX)/build/nanoapp/app.mk
diff --git a/apps/test/common/chre_cross_validator_wwan/inc/chre_cross_validator_wwan_manager.h b/apps/test/common/chre_cross_validator_wwan/inc/chre_cross_validator_wwan_manager.h
new file mode 100644
index 00000000..58f1ffe7
--- /dev/null
+++ b/apps/test/common/chre_cross_validator_wwan/inc/chre_cross_validator_wwan_manager.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHRE_CROSS_VALIDATOR_WWAN_MANAGER_H_
+#define CHRE_CROSS_VALIDATOR_WWAN_MANAGER_H_
+
+#include <pb_common.h>
+#include <pb_decode.h>
+#include <pb_encode.h>
+
+#include <cinttypes>
+#include <cstdint>
+
+#include "chre/util/dynamic_vector.h"
+#include "chre/util/singleton.h"
+#include "chre_api/chre.h"
+#include "chre_api/chre/wwan.h"
+#include "chre_cross_validation_wwan.nanopb.h"
+#include "chre_test_common.nanopb.h"
+
+namespace chre::cross_validator_wwan {
+
+/**
+ * Class to manage a CHRE cross validator wwan nanoapp.
+ */
+class Manager {
+ public:
+  /**
+   * Handle a CHRE event.
+   *
+   * @param senderInstanceId The instand ID that sent the event.
+   * @param eventType The type of the event.
+   * @param eventData The data for the event.
+   */
+  void handleEvent(uint32_t senderInstanceId, uint16_t eventType,
+                   const void *eventData);
+
+ private:
+  /**
+   * Handle a message from the host.
+   * @param senderInstanceId The instance id of the sender.
+   * @param data The message from the host's data.
+   */
+  void handleMessageFromHost(uint32_t senderInstanceId,
+                             const chreMessageFromHostData *data);
+
+  /*
+   * Send the capabilities of the wwan to the host.
+   */
+  void sendCapabilitiesToHost();
+
+  /**
+   * @param capabilitiesFromChre The number with flags that represent the
+   *        different wwan capabilities.
+   * @return The wwan capabilities proto message for the host.
+   */
+  chre_cross_validation_wwan_WwanCapabilities makeWwanCapabilitiesMessage(
+      uint32_t capabilitiesFromChre);
+
+  /**
+   * Handle a wwan cell info result event from a CHRE event.
+   *
+   * @param event the wwan cell info event from CHRE api.
+   */
+  void handleWwanCellInfoResult(const chreWwanCellInfoResult *event);
+
+  // Helper functions to convert CHRE results to proto
+  chre_cross_validation_wwan_WwanCellInfoResult toWwanCellInfoResultProto(
+      const chreWwanCellInfoResult &cell_info_result);
+
+  // Host endpoint for sending responses. Updated on message receipt.
+  uint16_t mHostEndpoint = 0;
+};
+
+// The chre cross validator manager singleton.
+typedef chre::Singleton<Manager> ManagerSingleton;
+
+}  // namespace chre::cross_validator_wwan
+
+#endif  // CHRE_CROSS_VALIDATOR_WWAN_MANAGER_H_
diff --git a/apps/test/common/chre_cross_validator_wwan/src/chre_cross_validator_wwan.cc b/apps/test/common/chre_cross_validator_wwan/src/chre_cross_validator_wwan.cc
new file mode 100644
index 00000000..524dfad5
--- /dev/null
+++ b/apps/test/common/chre_cross_validator_wwan/src/chre_cross_validator_wwan.cc
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cinttypes>
+
+#include "chre_cross_validator_wwan_manager.h"
+
+#include "chre_api/chre.h"
+
+namespace chre {
+
+extern "C" void nanoappHandleEvent(uint32_t senderInstanceId,
+                                   uint16_t eventType, const void *eventData) {
+  cross_validator_wwan::ManagerSingleton::get()->handleEvent(
+      senderInstanceId, eventType, eventData);
+}
+
+extern "C" bool nanoappStart(void) {
+  cross_validator_wwan::ManagerSingleton::init();
+  return true;
+}
+
+extern "C" void nanoappEnd(void) {
+  cross_validator_wwan::ManagerSingleton::deinit();
+}
+
+}  // namespace chre
diff --git a/apps/test/common/chre_cross_validator_wwan/src/chre_cross_validator_wwan_manager.cc b/apps/test/common/chre_cross_validator_wwan/src/chre_cross_validator_wwan_manager.cc
new file mode 100644
index 00000000..8005a4dc
--- /dev/null
+++ b/apps/test/common/chre_cross_validator_wwan/src/chre_cross_validator_wwan_manager.cc
@@ -0,0 +1,429 @@
+/* * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "chre_cross_validator_wwan_manager.h"
+
+#include <stdio.h>
+#include <algorithm>
+#include <cinttypes>
+#include <cstring>
+
+#include "chre/util/nanoapp/assert.h"
+#include "chre/util/nanoapp/callbacks.h"
+#include "chre/util/nanoapp/log.h"
+#include "chre_api/chre.h"
+#include "chre_api/chre/wwan.h"
+#include "chre_cross_validation_wwan.nanopb.h"
+#include "chre_test_common.nanopb.h"
+#include "send_message.h"
+
+namespace chre {
+
+namespace cross_validator_wwan {
+
+void Manager::handleEvent(uint32_t senderInstanceId, uint16_t eventType,
+                          const void *eventData) {
+  switch (eventType) {
+    case CHRE_EVENT_MESSAGE_FROM_HOST:
+      handleMessageFromHost(
+          senderInstanceId,
+          static_cast<const chreMessageFromHostData *>(eventData));
+      break;
+    case CHRE_EVENT_WWAN_CELL_INFO_RESULT:
+      handleWwanCellInfoResult(
+          static_cast<const chreWwanCellInfoResult *>(eventData));
+      break;
+    default:
+      LOGE("Unknown message type %" PRIu16 "received when handling event",
+           eventType);
+  }
+}
+
+void Manager::handleMessageFromHost(uint32_t senderInstanceId,
+                                    const chreMessageFromHostData *hostData) {
+  LOGI("Received message from host");
+  if (senderInstanceId != CHRE_INSTANCE_ID) {
+    LOGE("Incorrect sender instance id: %" PRIu32, senderInstanceId);
+    return;
+  }
+
+  switch (hostData->messageType) {
+    case chre_cross_validation_wwan_MessageType_WWAN_CAPABILITIES_REQUEST:
+      mHostEndpoint = hostData->hostEndpoint;
+      sendCapabilitiesToHost();
+      break;
+    case chre_cross_validation_wwan_MessageType_WWAN_CELL_INFO_REQUEST:
+      LOGI("Received WWAN_CELL_INFO_REQUEST, calling chreWwanGetCellInfoAsync");
+      if (!chreWwanGetCellInfoAsync(/*cookie=*/nullptr)) {
+        LOGE("chreWwanGetCellInfoAsync() failed");
+        test_shared::sendTestResultWithMsgToHost(
+            mHostEndpoint,
+            chre_cross_validation_wwan_MessageType_WWAN_NANOAPP_ERROR,
+            /*success=*/false,
+            /*errMessage=*/"chreWwanGetCellInfoAsync failed",
+            /*abortOnFailure=*/false);
+      }
+      break;
+    default:
+      LOGE("Unknown message type %" PRIu32 " for host message",
+           hostData->messageType);
+      break;
+  }
+}
+
+void Manager::sendCapabilitiesToHost() {
+  LOGI("Sending capabilites to host");
+  chre_cross_validation_wwan_WwanCapabilities wwanCapabilities =
+      makeWwanCapabilitiesMessage(chreWwanGetCapabilities());
+  test_shared::sendMessageToHost(
+      mHostEndpoint, &wwanCapabilities,
+      chre_cross_validation_wwan_WwanCapabilities_fields,
+      chre_cross_validation_wwan_MessageType_WWAN_CAPABILITIES);
+}
+
+void Manager::handleWwanCellInfoResult(const chreWwanCellInfoResult *event) {
+  if (event->errorCode != CHRE_ERROR_NONE) {
+    LOGE("chreWwanCellInfoResult received with errorCode: 0x%" PRIu8,
+         event->errorCode);
+  }
+
+  LOGI("Sending wwan scan results to host");
+  chre_cross_validation_wwan_WwanCellInfoResult result =
+      toWwanCellInfoResultProto(*event);
+
+  test_shared::sendMessageToHostWithPermissions(
+      mHostEndpoint, &result,
+      chre_cross_validation_wwan_WwanCellInfoResult_fields,
+      chre_cross_validation_wwan_MessageType_WWAN_CELL_INFO_RESULTS,
+      NanoappPermissions::CHRE_PERMS_WWAN);
+}
+
+chre_cross_validation_wwan_WwanCapabilities
+Manager::makeWwanCapabilitiesMessage(uint32_t capabilitiesFromChre) {
+  chre_cross_validation_wwan_WwanCapabilities capabilities;
+  capabilities.has_wwanCapabilities = true;
+  capabilities.wwanCapabilities = capabilitiesFromChre;
+  return capabilities;
+}
+
+// Converts chreWwanCellTimestampType to the corresponding
+// chre_cross_validation_wwan_CellTimestampType.
+chre_cross_validation_wwan_CellTimestampType ToCellTimestampType(
+    uint8_t cell_timestamp_type) {
+  switch (cell_timestamp_type) {
+    case CHRE_WWAN_CELL_TIMESTAMP_TYPE_ANTENNA:
+      return chre_cross_validation_wwan_CellTimestampType_CELL_TIMESTAMP_TYPE_ANTENNA;
+    case CHRE_WWAN_CELL_TIMESTAMP_TYPE_MODEM:
+      return chre_cross_validation_wwan_CellTimestampType_CELL_TIMESTAMP_TYPE_MODEM;
+    case CHRE_WWAN_CELL_TIMESTAMP_TYPE_OEM_RIL:
+      return chre_cross_validation_wwan_CellTimestampType_CELL_TIMESTAMP_TYPE_OEM_RIL;
+    case CHRE_WWAN_CELL_TIMESTAMP_TYPE_JAVA_RIL:
+      return chre_cross_validation_wwan_CellTimestampType_CELL_TIMESTAMP_TYPE_JAVA_RIL;
+    default:
+      return chre_cross_validation_wwan_CellTimestampType_CELL_TIMESTAMP_TYPE_UNKNOWN;
+  }
+}
+
+chre_cross_validation_wwan_WwanCellInfo toWwanCellInfoProto(
+    const chreWwanCellInfo &cell_info) {
+  chre_cross_validation_wwan_WwanCellInfo cell_info_proto;
+  cell_info_proto.has_timestamp_ns = true;
+  cell_info_proto.timestamp_ns = cell_info.timeStamp;
+  cell_info_proto.has_timestamp_type = true;
+  cell_info_proto.timestamp_type = ToCellTimestampType(cell_info.timeStampType);
+  cell_info_proto.has_is_registered = true;
+  cell_info_proto.is_registered = cell_info.registered;
+  cell_info_proto.has_cell_info_type = true;
+  cell_info_proto.cell_info_type =
+      chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_UNKNOWN;
+  LOGI("Encoding chreWwanCellInfo to proto");
+
+  switch (cell_info.cellInfoType) {
+    case CHRE_WWAN_CELL_INFO_TYPE_GSM:
+      LOGI("Encoding GSM cellInfoType to proto");
+      cell_info_proto.which_cell_info =
+          chre_cross_validation_wwan_WwanCellInfo_gsm_tag;
+      cell_info_proto.cell_info_type =
+          chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_GSM;
+      cell_info_proto.cell_info.gsm = {
+          .has_cell_identity = true,
+          .cell_identity =
+              {
+                  .has_mcc = true,
+                  .mcc = cell_info.CellInfo.gsm.cellIdentityGsm.mcc,
+                  .has_mnc = true,
+                  .mnc = cell_info.CellInfo.gsm.cellIdentityGsm.mnc,
+                  .has_lac = true,
+                  .lac = cell_info.CellInfo.gsm.cellIdentityGsm.lac,
+                  .has_cid = true,
+                  .cid = cell_info.CellInfo.gsm.cellIdentityGsm.cid,
+                  .has_arfcn = true,
+                  .arfcn = cell_info.CellInfo.gsm.cellIdentityGsm.arfcn,
+                  .has_bsic = true,
+                  .bsic = cell_info.CellInfo.gsm.cellIdentityGsm.bsic,
+              },
+          .has_signal_strength = true,
+          .signal_strength = {
+              .has_signal_strength = true,
+              .signal_strength =
+                  cell_info.CellInfo.gsm.signalStrengthGsm.signalStrength,
+              .has_bit_error_rate = true,
+              .bit_error_rate =
+                  cell_info.CellInfo.gsm.signalStrengthGsm.bitErrorRate,
+              .has_timing_advance = true,
+              .timing_advance =
+                  cell_info.CellInfo.gsm.signalStrengthGsm.timingAdvance,
+          }};
+      break;
+    case CHRE_WWAN_CELL_INFO_TYPE_WCDMA:
+      LOGI("Encoding WCDMA cellInfoType to proto");
+      cell_info_proto.which_cell_info =
+          chre_cross_validation_wwan_WwanCellInfo_wcdma_tag;
+      cell_info_proto.cell_info_type =
+          chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_WCDMA;
+      cell_info_proto.cell_info.wcdma = {
+          .has_cell_identity = true,
+          .cell_identity =
+              {
+                  .has_mcc = true,
+                  .mcc = cell_info.CellInfo.wcdma.cellIdentityWcdma.mcc,
+                  .has_mnc = true,
+                  .mnc = cell_info.CellInfo.wcdma.cellIdentityWcdma.mnc,
+                  .has_lac = true,
+                  .lac = cell_info.CellInfo.wcdma.cellIdentityWcdma.lac,
+                  .has_cid = true,
+                  .cid = cell_info.CellInfo.wcdma.cellIdentityWcdma.cid,
+                  .has_psc = true,
+                  .psc = cell_info.CellInfo.wcdma.cellIdentityWcdma.psc,
+                  .has_uarfcn = true,
+                  .uarfcn = cell_info.CellInfo.wcdma.cellIdentityWcdma.uarfcn,
+              },
+          .has_signal_strength = true,
+          .signal_strength = {
+              .has_signal_strength = true,
+              .signal_strength =
+                  cell_info.CellInfo.wcdma.signalStrengthWcdma.signalStrength,
+              .has_bit_error_rate = true,
+              .bit_error_rate =
+                  cell_info.CellInfo.wcdma.signalStrengthWcdma.bitErrorRate,
+          }};
+      break;
+    case CHRE_WWAN_CELL_INFO_TYPE_CDMA:
+      LOGI("Encoding CDMA cellInfoType to proto");
+      cell_info_proto.which_cell_info =
+          chre_cross_validation_wwan_WwanCellInfo_cdma_tag;
+      cell_info_proto.cell_info_type =
+          chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_CDMA;
+      cell_info_proto.cell_info.cdma = {
+          .has_cell_identity = true,
+          .cell_identity =
+              {
+                  .has_network_id = true,
+                  .network_id =
+                      cell_info.CellInfo.cdma.cellIdentityCdma.networkId,
+                  .has_system_id = true,
+                  .system_id =
+                      cell_info.CellInfo.cdma.cellIdentityCdma.systemId,
+                  .has_basestation_id = true,
+                  .basestation_id =
+                      cell_info.CellInfo.cdma.cellIdentityCdma.basestationId,
+                  .has_longitude = true,
+                  .longitude =
+                      cell_info.CellInfo.cdma.cellIdentityCdma.longitude,
+                  .has_latitude = true,
+                  .latitude = cell_info.CellInfo.cdma.cellIdentityCdma.latitude,
+              },
+          .has_signal_strength_cdma = true,
+          .signal_strength_cdma =
+              {
+                  .has_dbm = true,
+                  .dbm = cell_info.CellInfo.cdma.signalStrengthCdma.dbm,
+                  .has_ecio = true,
+                  .ecio = cell_info.CellInfo.cdma.signalStrengthCdma.ecio,
+              },
+          .has_signal_strength_evdo = true,
+          .signal_strength_evdo = {
+              .has_dbm = true,
+              .dbm = cell_info.CellInfo.cdma.signalStrengthEvdo.dbm,
+              .has_ecio = true,
+              .ecio = cell_info.CellInfo.cdma.signalStrengthEvdo.ecio,
+              .has_signal_noise_ratio = true,
+              .signal_noise_ratio =
+                  cell_info.CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio,
+          }};
+      break;
+    case CHRE_WWAN_CELL_INFO_TYPE_LTE:
+      LOGI("Encoding LTE cellInfoType to proto");
+      cell_info_proto.which_cell_info =
+          chre_cross_validation_wwan_WwanCellInfo_lte_tag;
+      cell_info_proto.cell_info_type =
+          chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_LTE;
+      cell_info_proto.cell_info.lte = {
+          .has_cell_identity = true,
+          .cell_identity =
+              {
+                  .has_mcc = true,
+                  .mcc = cell_info.CellInfo.lte.cellIdentityLte.mcc,
+                  .has_mnc = true,
+                  .mnc = cell_info.CellInfo.lte.cellIdentityLte.mnc,
+                  .has_ci = true,
+                  .ci = cell_info.CellInfo.lte.cellIdentityLte.ci,
+                  .has_pci = true,
+                  .pci = cell_info.CellInfo.lte.cellIdentityLte.pci,
+                  .has_tac = true,
+                  .tac = cell_info.CellInfo.lte.cellIdentityLte.tac,
+                  .has_earfcn = true,
+                  .earfcn = cell_info.CellInfo.lte.cellIdentityLte.earfcn,
+              },
+          .has_signal_strength = true,
+          .signal_strength = {
+              .has_signal_strength = true,
+              .signal_strength =
+                  cell_info.CellInfo.lte.signalStrengthLte.signalStrength,
+              .has_rsrp = true,
+              .rsrp = cell_info.CellInfo.lte.signalStrengthLte.rsrp,
+              .has_rsrq = true,
+              .rsrq = cell_info.CellInfo.lte.signalStrengthLte.rsrq,
+              .has_rssnr = true,
+              .rssnr = cell_info.CellInfo.lte.signalStrengthLte.rssnr,
+              .has_cqi = true,
+              .cqi = cell_info.CellInfo.lte.signalStrengthLte.cqi,
+              .has_timing_advance = true,
+              .timing_advance =
+                  cell_info.CellInfo.lte.signalStrengthLte.timingAdvance,
+          }};
+      break;
+    case CHRE_WWAN_CELL_INFO_TYPE_TD_SCDMA:
+      LOGI("Encoding TD_SCDMA cellInfoType to proto");
+      cell_info_proto.which_cell_info =
+          chre_cross_validation_wwan_WwanCellInfo_tdscdma_tag;
+      cell_info_proto.cell_info_type =
+          chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_TD_SCDMA;
+      cell_info_proto.cell_info.tdscdma = {
+          .has_cell_identity = true,
+          .cell_identity =
+              {
+                  .has_mcc = true,
+                  .mcc = cell_info.CellInfo.tdscdma.cellIdentityTdscdma.mcc,
+                  .has_mnc = true,
+                  .mnc = cell_info.CellInfo.tdscdma.cellIdentityTdscdma.mnc,
+                  .has_lac = true,
+                  .lac = cell_info.CellInfo.tdscdma.cellIdentityTdscdma.lac,
+                  .has_cid = true,
+                  .cid = cell_info.CellInfo.tdscdma.cellIdentityTdscdma.cid,
+                  .has_cpid = true,
+                  .cpid = cell_info.CellInfo.tdscdma.cellIdentityTdscdma.cpid,
+              },
+          .has_signal_strength = true,
+          .signal_strength = {
+              .has_rscp = true,
+              .rscp = cell_info.CellInfo.tdscdma.signalStrengthTdscdma.rscp,
+          }};
+      break;
+    case CHRE_WWAN_CELL_INFO_TYPE_NR:
+      LOGI("Encoding NR cellInfoType to proto");
+      cell_info_proto.which_cell_info =
+          chre_cross_validation_wwan_WwanCellInfo_nr_tag;
+      cell_info_proto.cell_info_type =
+          chre_cross_validation_wwan_WwanCellInfoType_WWAN_CELL_INFO_TYPE_NR;
+      cell_info_proto.cell_info.nr = {
+          .has_cell_identity = true,
+          .cell_identity =
+              {
+                  .has_mcc = true,
+                  .mcc = cell_info.CellInfo.nr.cellIdentityNr.mcc,
+                  .has_mnc = true,
+                  .mnc = cell_info.CellInfo.nr.cellIdentityNr.mnc,
+                  .has_nci = true,
+                  .nci = chreWwanUnpackNrNci(
+                      &cell_info.CellInfo.nr.cellIdentityNr),
+                  .has_pci = true,
+                  .pci = cell_info.CellInfo.nr.cellIdentityNr.pci,
+                  .has_tac = true,
+                  .tac = cell_info.CellInfo.nr.cellIdentityNr.tac,
+                  .has_nrarfcn = true,
+                  .nrarfcn = cell_info.CellInfo.nr.cellIdentityNr.nrarfcn,
+              },
+          .has_signal_strength = true,
+          .signal_strength = {
+              .has_ss_rsrp = true,
+              .ss_rsrp = cell_info.CellInfo.nr.signalStrengthNr.ssRsrp,
+              .has_ss_rsrq = true,
+              .ss_rsrq = cell_info.CellInfo.nr.signalStrengthNr.ssRsrq,
+              .has_ss_sinr = true,
+              .ss_sinr = cell_info.CellInfo.nr.signalStrengthNr.ssSinr,
+              .has_csi_rsrp = true,
+              .csi_rsrp = cell_info.CellInfo.nr.signalStrengthNr.csiRsrp,
+              .has_csi_rsrq = true,
+              .csi_rsrq = cell_info.CellInfo.nr.signalStrengthNr.csiRsrq,
+              .has_csi_sinr = true,
+              .csi_sinr = cell_info.CellInfo.nr.signalStrengthNr.csiSinr,
+          }};
+      break;
+    default:
+      LOGE("Unknown cellInfoType %" PRIu8 " received", cell_info.cellInfoType);
+      break;
+  }
+
+  return cell_info_proto;
+}
+
+// A nanopb callback for encoding the cell infos in a chreWwanCellInfoResult to
+// repeated chre_cross_validation_wwan_WwanCellInfo.
+bool EncodeWwanCellInfos(pb_ostream_t *stream, const pb_field_t *field,
+                         void *const *arg) {
+  const chreWwanCellInfoResult *cell_scan =
+      static_cast<const chreWwanCellInfoResult *>(*arg);
+
+  LOGI("Encoding %d cell infos to proto", cell_scan->cellInfoCount);
+  for (int i = 0; i < cell_scan->cellInfoCount; ++i) {
+    if (!pb_encode_tag_for_field(stream, field)) {
+      LOGE("Failed to encode Cell Info tag.");
+      return false;
+    }
+
+    chre_cross_validation_wwan_WwanCellInfo cell_info_proto =
+        toWwanCellInfoProto(cell_scan->cells[i]);
+    if (!pb_encode_submessage(stream,
+                              chre_cross_validation_wwan_WwanCellInfo_fields,
+                              &cell_info_proto)) {
+      LOGE("Failed to encode Cell Info.");
+      return false;
+    }
+  }
+
+  return true;
+}
+
+chre_cross_validation_wwan_WwanCellInfoResult
+Manager::toWwanCellInfoResultProto(
+    const chreWwanCellInfoResult &cell_info_result) {
+  chre_cross_validation_wwan_WwanCellInfoResult cell_info_result_proto;
+
+  // fill in header
+  cell_info_result_proto.version = cell_info_result.version;
+  cell_info_result_proto.errorCode = cell_info_result.errorCode;
+
+  cell_info_result_proto.cell_info = {
+      .funcs = {.encode = EncodeWwanCellInfos},
+      .arg = const_cast<chreWwanCellInfoResult *>(&cell_info_result),
+  };
+
+  return cell_info_result_proto;
+}
+
+}  // namespace cross_validator_wwan
+
+}  // namespace chre
diff --git a/apps/test/common/chre_settings_test/inc/chre_settings_test_manager.h b/apps/test/common/chre_settings_test/inc/chre_settings_test_manager.h
index ece5b41a..b1da2f00 100644
--- a/apps/test/common/chre_settings_test/inc/chre_settings_test_manager.h
+++ b/apps/test/common/chre_settings_test/inc/chre_settings_test_manager.h
@@ -198,6 +198,9 @@ class Manager {
 
   //! The number of retries available for requesting wifi scans before quitting
   uint8_t mWifiRequestRetries;
+
+  //! The number of retries available for requesting cell info before quitting
+  uint8_t mWwanRequestRetries;
 };
 
 // The settings test manager singleton.
diff --git a/apps/test/common/chre_settings_test/src/chre_settings_test_manager.cc b/apps/test/common/chre_settings_test/src/chre_settings_test_manager.cc
index 8ffb6ee1..336ade71 100644
--- a/apps/test/common/chre_settings_test/src/chre_settings_test_manager.cc
+++ b/apps/test/common/chre_settings_test/src/chre_settings_test_manager.cc
@@ -57,8 +57,12 @@ constexpr uint32_t kAudioDataTimerCookie = 0xc001cafe;
 uint32_t gAudioStatusTimerHandle = CHRE_TIMER_INVALID;
 constexpr uint32_t kAudioStatusTimerCookie = 0xb01dcafe;
 uint32_t gRangingRequestRetryTimerHandle = CHRE_TIMER_INVALID;
+constexpr uint32_t kRangingRequestSetupRetryTimerCookie = 0x600ccafe;
 constexpr uint32_t kRangingRequestRetryTimerCookie = 0x600dcafe;
+uint32_t gWwanRequestRetryTimerHandle = CHRE_TIMER_INVALID;
+constexpr uint32_t kWwanRequestRetryTimerCookie = 0x01d3cafe;
 
+constexpr uint8_t kMaxWwanRequestRetries = 3;
 constexpr uint8_t kMaxWifiRequestRetries = 3;
 
 bool getFeature(const chre_settings_test_TestCommand &command,
@@ -320,6 +324,10 @@ void Manager::handleDataFromChre(uint16_t eventType, const void *eventData) {
 }
 
 bool Manager::requestRangingForFeatureWifiRtt() {
+  if (!mCachedRangingTarget.has_value()) {
+    LOGE("No cached WiFi RTT ranging target");
+    return false;
+  }
   struct chreWifiRangingParams params = {
       .targetListLen = 1, .targetList = &mCachedRangingTarget.value()};
   return chreWifiRequestRangingAsync(&params, &kWifiRttCookie);
@@ -333,12 +341,8 @@ bool Manager::startTestForFeature(Feature feature) {
       break;
 
     case Feature::WIFI_RTT: {
-      if (!mCachedRangingTarget.has_value()) {
-        LOGE("No cached WiFi RTT ranging target");
-      } else {
-        mWifiRequestRetries = 0;
-        success = requestRangingForFeatureWifiRtt();
-      }
+      mWifiRequestRetries = 0;
+      success = requestRangingForFeatureWifiRtt();
       break;
     }
 
@@ -354,6 +358,7 @@ bool Manager::startTestForFeature(Feature feature) {
       break;
 
     case Feature::WWAN_CELL_INFO:
+      mWwanRequestRetries = 0;
       success = chreWwanGetCellInfoAsync(&kWwanCellInfoCookie);
       break;
 
@@ -419,7 +424,8 @@ void Manager::handleWifiAsyncResult(const chreAsyncResult *result) {
   switch (result->requestType) {
     case CHRE_WIFI_REQUEST_TYPE_REQUEST_SCAN: {
       if (mTestSession->feature == Feature::WIFI_RTT) {
-        if (result->errorCode == CHRE_ERROR_BUSY) {
+        if (result->errorCode == CHRE_ERROR ||
+            result->errorCode == CHRE_ERROR_BUSY) {
           if (mWifiRequestRetries >= kMaxWifiRequestRetries) {
             // The request has failed repeatedly and we are no longer retrying
             // Return success=false to the host rather than timeout.
@@ -429,15 +435,19 @@ void Manager::handleWifiAsyncResult(const chreAsyncResult *result) {
             break;
           }
 
-          // Retry on CHRE_ERROR_BUSY after a short delay
+          // Retry on CHRE_ERROR/CHRE_ERROR_BUSY after a short delay
           mWifiRequestRetries++;
           uint64_t delay = kOneSecondInNanoseconds * 2;
-          gRangingRequestRetryTimerHandle = chreTimerSet(
-              delay, &kRangingRequestRetryTimerCookie, /*oneShot=*/true);
+          const uint32_t *cookie = mTestSession->step == TestStep::SETUP
+                                       ? &kRangingRequestSetupRetryTimerCookie
+                                       : &kRangingRequestRetryTimerCookie;
+          gRangingRequestRetryTimerHandle =
+              chreTimerSet(delay, cookie, /*oneShot=*/true);
           LOGW(
-              "Request failed due to CHRE_ERROR_BUSY. Retrying after "
-              "delay=%" PRIu64 "ns, num_retries=%" PRIu8 "/%" PRIu8,
-              delay, mWifiRequestRetries, kMaxWifiRequestRetries);
+              "Request failed during %s step. Retrying "
+              "after delay=%" PRIu64 "ns, num_retries=%" PRIu8 "/%" PRIu8,
+              mTestSession->step == TestStep::SETUP ? "SETUP" : "START", delay,
+              mWifiRequestRetries, kMaxWifiRequestRetries);
           return;
         }
 
@@ -556,8 +566,27 @@ void Manager::handleWwanCellInfoResult(const chreWwanCellInfoResult *result) {
     LOGE("WWAN cell info result failed: error code %" PRIu8, result->errorCode);
   } else if (mTestSession->featureState == FeatureState::DISABLED &&
              result->cellInfoCount > 0) {
-    LOGE("WWAN cell info result should be empty when disabled: count %" PRIu8,
-         result->cellInfoCount);
+    // Allow some retries to wait for the modem to clear the cell info cache.
+    if (mWwanRequestRetries >= kMaxWwanRequestRetries) {
+      LOGE(
+          "WWAN cell info result should be empty when disabled. Hit retry "
+          "limit (%" PRIu8 "), cell_info_count= %" PRIu8,
+          kMaxWwanRequestRetries, result->cellInfoCount);
+    } else {
+      mWwanRequestRetries++;
+      uint64_t delay = kOneSecondInNanoseconds * 1;
+      gWwanRequestRetryTimerHandle =
+          chreTimerSet(delay, &kWwanRequestRetryTimerCookie, /*oneShot=*/true);
+      if (gWwanRequestRetryTimerHandle != CHRE_TIMER_INVALID) {
+        LOGW("WWAN cell info result should be empty when disabled: count %" PRIu8
+            " Retrying after delay=%" PRIu64 "ns, num_retries=%" PRIu8
+            "/%" PRIu8,
+            result->cellInfoCount, delay, mWwanRequestRetries,
+            kMaxWwanRequestRetries);
+        return;
+      }
+      LOGE("Failed to set WWAN cell info retry timer");
+    }
   } else {
     success = true;
   }
@@ -669,12 +698,26 @@ void Manager::handleTimerEvent(const void *eventData) {
   bool testSuccess = false;
   auto *cookie = static_cast<const uint32_t *>(eventData);
 
+  if (*cookie == kRangingRequestSetupRetryTimerCookie) {
+    gRangingRequestRetryTimerHandle = CHRE_TIMER_INVALID;
+    chreWifiRequestScanAsyncDefault(&kWifiScanningCookie);
+    return;
+  }
+
   if (*cookie == kRangingRequestRetryTimerCookie) {
     gRangingRequestRetryTimerHandle = CHRE_TIMER_INVALID;
     requestRangingForFeatureWifiRtt();
     return;
   }
 
+  if (*cookie == kWwanRequestRetryTimerCookie) {
+    gWwanRequestRetryTimerHandle = CHRE_TIMER_INVALID;
+    if (chreWwanGetCellInfoAsync(&kWwanCellInfoCookie)) {
+      return;
+    }
+    LOGE("Failed to re-request WWAN cell info, rejected for processing");
+  }
+
   // Ignore the audio status timer if the suspended status was received.
   if (*cookie == kAudioStatusTimerCookie && !mAudioSamplingEnabled) {
     gAudioStatusTimerHandle = CHRE_TIMER_INVALID;
diff --git a/apps/test/common/proto/Android.bp b/apps/test/common/proto/Android.bp
index 98cb3ae4..0f98e8cb 100644
--- a/apps/test/common/proto/Android.bp
+++ b/apps/test/common/proto/Android.bp
@@ -48,6 +48,18 @@ java_library {
     sdk_version: "system_current",
 }
 
+java_library {
+    name: "chrecrossvalidation_wwan_java_proto",
+    host_supported: true,
+    srcs: [
+        "./chre_cross_validation_wwan.proto",
+    ],
+    proto: {
+        type: "lite",
+    },
+    sdk_version: "system_current",
+}
+
 java_library {
     name: "chre_settings_test_java_proto",
     host_supported: true,
diff --git a/apps/test/common/proto/chre_cross_validation_sensor.proto b/apps/test/common/proto/chre_cross_validation_sensor.proto
index ea0129a8..7c949de8 100644
--- a/apps/test/common/proto/chre_cross_validation_sensor.proto
+++ b/apps/test/common/proto/chre_cross_validation_sensor.proto
@@ -62,6 +62,7 @@ message SensorInfoResponse {
   optional uint32 chreSensorType = 1;
   optional bool isAvailable = 2;
   optional uint32 sensorIndex = 3;
+  optional bytes sensorName = 4;
 }
 
 message Data {
diff --git a/apps/test/common/proto/chre_cross_validation_wwan.proto b/apps/test/common/proto/chre_cross_validation_wwan.proto
new file mode 100644
index 00000000..f9c3c51b
--- /dev/null
+++ b/apps/test/common/proto/chre_cross_validation_wwan.proto
@@ -0,0 +1,212 @@
+syntax = "proto2";
+
+package chre_cross_validation_wwan;
+
+option java_package = "com.google.android.chre.nanoapp.proto";
+option java_outer_classname = "ChreCrossValidationWwan";
+
+enum MessageType {
+  // Reserved for corrupted messages
+  UNDEFINED = 0;
+
+  // CHRE to Host: Indicates an error occurred in the nanoapp. The payload is
+  // in the format of ChreTestCommon.TestResult
+  WWAN_NANOAPP_ERROR = 1;
+
+  // Host to CHRE: Requests CHRE to provide the WWAN Capabilities. No payload.
+  WWAN_CAPABILITIES_REQUEST = 2;
+
+  // CHRE to Host: Nanoapp response to WWAN_CAPABILITIES_REQUEST. The payload
+  // must be a WwanCapabilities message.
+  WWAN_CAPABILITIES = 3;
+
+  // Host to CHRE: Requests Cell Info. No payload.
+  WWAN_CELL_INFO_REQUEST = 4;
+
+  // CHRE to Host: Nanoapp response to WWAN_CELL_INFO_REQUEST. The payload must
+  // be a WwanScanResult
+  WWAN_CELL_INFO_RESULTS = 5;
+}
+
+/*
+ * The wwan capabilities listed in
+ * //system/chre/chre_api/include/chre_api/chre/wwan.h
+ */
+message WwanCapabilities {
+  optional uint32 wwanCapabilities = 1;
+}
+
+// From chreWwanCellTimeStampType in /chre_api/chre/wwan.h
+enum CellTimestampType {
+  CELL_TIMESTAMP_TYPE_UNKNOWN = 0;
+  CELL_TIMESTAMP_TYPE_ANTENNA = 1;
+  CELL_TIMESTAMP_TYPE_MODEM = 2;
+  CELL_TIMESTAMP_TYPE_OEM_RIL = 3;
+  CELL_TIMESTAMP_TYPE_JAVA_RIL = 4;
+}
+
+// From chreWwanCellInfoType in /chre_api/chre/wwan.h
+enum WwanCellInfoType {
+  WWAN_CELL_INFO_TYPE_UNKNOWN = 0;
+  WWAN_CELL_INFO_TYPE_GSM = 1;
+  WWAN_CELL_INFO_TYPE_CDMA = 2;
+  WWAN_CELL_INFO_TYPE_LTE = 3;
+  WWAN_CELL_INFO_TYPE_WCDMA = 4;
+  WWAN_CELL_INFO_TYPE_TD_SCDMA = 5;
+  WWAN_CELL_INFO_TYPE_NR = 6;
+}
+
+/*
+ * Derived from the chreWwanCellInfoResult in the wwan CHRE API @
+ * //system/chre/chre_api/include/chre_api/chre/wwan.h
+ */
+message WwanCellInfoResult {
+  // Version of the struct, for compatibility purposes.
+  optional uint32 version = 1;
+  // The error code taken from the chreWwanCellInfoResult
+  optional uint32 errorCode = 2;
+  // The list of cell info results.
+  repeated WwanCellInfo cell_info = 3;
+}
+
+message WwanCellInfo {
+  optional uint64 timestamp_ns = 1;
+  optional WwanCellInfoType cell_info_type = 2;
+  optional CellTimestampType timestamp_type = 3;
+  optional bool is_registered = 4;
+  oneof cell_info {
+    CellInfoGsm gsm = 5;
+    CellInfoWcdma wcdma = 6;
+    CellInfoCdma cdma = 7;
+    CellInfoLte lte = 8;
+    CellInfoTdscdma tdscdma = 9;
+    CellInfoNr nr = 10;
+  }
+}
+
+message CellInfoGsm {
+  optional CellIdentityGsm cell_identity = 1;
+  optional SignalStrengthGsm signal_strength = 2;
+}
+
+message CellInfoWcdma {
+  optional CellIdentityWcdma cell_identity = 1;
+  optional SignalStrengthWcdma signal_strength = 2;
+}
+
+message CellInfoCdma {
+  optional CellIdentityCdma cell_identity = 1;
+  optional SignalStrengthCdma signal_strength_cdma = 2;
+  optional SignalStrengthEvdo signal_strength_evdo = 3;
+}
+
+message CellInfoLte {
+  optional CellIdentityLte cell_identity = 1;
+  optional SignalStrengthLte signal_strength = 2;
+}
+
+message CellInfoTdscdma {
+  optional CellIdentityTdscdma cell_identity = 1;
+  optional SignalStrengthTdscdma signal_strength = 2;
+}
+
+message CellInfoNr {
+  optional CellIdentityNr cell_identity = 1;
+  optional SignalStrengthNr signal_strength = 2;
+}
+
+message CellIdentityGsm {
+  optional int32 mcc = 1;
+  optional int32 mnc = 2;
+  optional int32 lac = 3;
+  optional int32 cid = 4;
+  optional int32 arfcn = 5;
+  optional int32 bsic = 6;
+}
+
+message CellIdentityWcdma {
+  optional int32 mcc = 1;
+  optional int32 mnc = 2;
+  optional int32 lac = 3;
+  optional int32 cid = 4;
+  optional int32 psc = 5;
+  optional int32 uarfcn = 6;
+}
+
+message CellIdentityCdma {
+  optional int32 network_id = 1;
+  optional int32 system_id = 2;
+  optional int32 basestation_id = 3;
+  optional int32 longitude = 4;
+  optional int32 latitude = 5;
+}
+
+message CellIdentityLte {
+  optional int32 mcc = 1;
+  optional int32 mnc = 2;
+  optional int32 ci = 3;
+  optional int32 pci = 4;
+  optional int32 tac = 5;
+  optional int32 earfcn = 6;
+}
+
+message CellIdentityTdscdma {
+  optional int32 mcc = 1;
+  optional int32 mnc = 2;
+  optional int32 lac = 3;
+  optional int32 cid = 4;
+  optional int32 cpid = 5;
+}
+
+message CellIdentityNr {
+  optional int32 mcc = 1;
+  optional int32 mnc = 2;
+  optional int64 nci = 3;
+  optional int32 pci = 4;
+  optional int32 tac = 5;
+  optional int32 nrarfcn = 6;
+}
+
+message SignalStrengthGsm {
+  optional int32 signal_strength = 1;
+  optional int32 bit_error_rate = 2;
+  optional int32 timing_advance = 3;
+}
+
+message SignalStrengthWcdma {
+  optional int32 signal_strength = 1;
+  optional int32 bit_error_rate = 2;
+}
+
+message SignalStrengthCdma {
+  optional int32 dbm = 1;
+  optional int32 ecio = 2;
+}
+
+message SignalStrengthEvdo {
+  optional int32 dbm = 1;
+  optional int32 ecio = 2;
+  optional int32 signal_noise_ratio = 3;
+}
+
+message SignalStrengthLte {
+  optional int32 signal_strength = 1;
+  optional int32 rsrp = 2;
+  optional int32 rsrq = 3;
+  optional int32 rssnr = 4;
+  optional int32 cqi = 5;
+  optional int32 timing_advance = 6;
+}
+
+message SignalStrengthTdscdma {
+  optional int32 rscp = 1;
+}
+
+message SignalStrengthNr {
+  optional int32 ss_rsrp = 1;
+  optional int32 ss_rsrq = 2;
+  optional int32 ss_sinr = 3;
+  optional int32 csi_rsrp = 4;
+  optional int32 csi_rsrq = 5;
+  optional int32 csi_sinr = 6;
+}
\ No newline at end of file
diff --git a/apps/test/common/rpc_service_test/Makefile b/apps/test/common/rpc_service_test/Makefile
index 6ae2ee28..74dc4629 100644
--- a/apps/test/common/rpc_service_test/Makefile
+++ b/apps/test/common/rpc_service_test/Makefile
@@ -33,7 +33,6 @@ COMMON_SRCS += $(NANOAPP_PATH)/src/rpc_service_test.cc
 # Defines
 COMMON_CFLAGS += -DNANOAPP_MINIMUM_LOG_LEVEL=CHRE_LOG_LEVEL_INFO
 COMMON_CFLAGS += -DCHRE_ASSERTIONS_ENABLED
-COMMON_CFLAGS += -fno-threadsafe-statics
 
 # Includes
 COMMON_CFLAGS += -I$(TEST_SHARED_PATH)/inc
diff --git a/apps/test/common/shared/inc/send_message.h b/apps/test/common/shared/inc/send_message.h
index cd41e348..49c84ad5 100644
--- a/apps/test/common/shared/inc/send_message.h
+++ b/apps/test/common/shared/inc/send_message.h
@@ -46,7 +46,9 @@ void sendTestResultToHost(uint16_t hostEndpointId, uint32_t messageType,
  * @param success True if the test succeeded.
  * @param errMessage Nullable error message to send to the host. Error message
  *     will only be sent if success is false.
- * @param abortOnFailure If true, calls chreAbort() if success is false.
+ * @param abortOnFailure If true, calls chreAbort() if success is false. This
+ *     should only be set to true in legacy tests, as crashing CHRE makes the
+ *     test failure more difficult to understand.
  */
 void sendTestResultWithMsgToHost(uint16_t hostEndpointId, uint32_t messageType,
                                  bool success, const char *errMessage,
diff --git a/apps/wwan_world/wwan_world.cc b/apps/wwan_world/wwan_world.cc
index 0972b3e9..1c420955 100644
--- a/apps/wwan_world/wwan_world.cc
+++ b/apps/wwan_world/wwan_world.cc
@@ -67,13 +67,13 @@ void logNrCellInfo(const chreWwanCellInfoNr &nr) {
   LOGI("    ssRsrp %" PRId32 ", %" PRId32 " dBm", nr.signalStrengthNr.ssRsrp,
        -1 * nr.signalStrengthNr.ssRsrp);
   LOGI("    ssRsrq %" PRId32 ", %.1f dB", nr.signalStrengthNr.ssRsrq,
-       static_cast<float>(nr.signalStrengthNr.ssRsrp) / 2.0f);
+       static_cast<float>(nr.signalStrengthNr.ssRsrq) / 2.0f);
   LOGI("    ssSinr %" PRId32 ", %.1f dB", nr.signalStrengthNr.ssSinr,
        static_cast<float>(nr.signalStrengthNr.ssSinr) / 2.0f);
   LOGI("    csiRsrp %" PRId32 ", %" PRId32 " dBm", nr.signalStrengthNr.csiRsrp,
        -1 * nr.signalStrengthNr.csiRsrp);
   LOGI("    csiRsrq %" PRId32 ", %.1f dB", nr.signalStrengthNr.csiRsrq,
-       static_cast<float>(nr.signalStrengthNr.csiRsrp) / 2.0f);
+       static_cast<float>(nr.signalStrengthNr.csiRsrq) / 2.0f);
   LOGI("    csiSinr %" PRId32 ", %.1f dB", nr.signalStrengthNr.csiSinr,
        static_cast<float>(nr.signalStrengthNr.csiSinr) / 2.0f);
 }
@@ -158,8 +158,14 @@ bool nanoappStart() {
   const char *wwanCapabilitiesStr;
   uint32_t wwanCapabilities = chreWwanGetCapabilities();
   switch (wwanCapabilities) {
+    case (CHRE_WWAN_GET_CELL_NEIGHBOR_INFO | CHRE_WWAN_GET_CELL_INFO):
+      wwanCapabilitiesStr = "GET_CELL_INFO & CHRE_WWAN_GET_CELL_NEIGHBOR_INFO";
+      break;
+    case CHRE_WWAN_GET_CELL_NEIGHBOR_INFO:
+      wwanCapabilitiesStr = "CHRE_WWAN_GET_CELL_NEIGHBOR_INFO";
+      break;
     case CHRE_WWAN_GET_CELL_INFO:
-      wwanCapabilitiesStr = "GET_CELL_INFO";
+      wwanCapabilitiesStr = "GET_CELL_INFO (NO CELL_NEIGHBOR GUARANTEE)";
       break;
     case CHRE_WWAN_CAPABILITIES_NONE:
       wwanCapabilitiesStr = "NONE";
diff --git a/build/arch/arm64.mk b/build/arch/arm64.mk
index 2e7993af..1f704c3b 100644
--- a/build/arch/arm64.mk
+++ b/build/arch/arm64.mk
@@ -4,14 +4,14 @@
 
 # arm64 Environment Checks #####################################################
 
-ifeq ($(ANDROID_NDK_PREFIX),)
-$(error "You should supply an ANDROID_NDK_PREFIX environment variable \
-         containing a path to a generated Android NDK toolchain. i.e. \
-         ./build/tools/make-standalone-toolchain.sh --arch=arm64 \
-         --platform=android-26 --install-dir=$$ANDROID_NDK_PREFIX")
+ifeq ($(ANDROID_BUILD_TOP),)
+$(error "You should supply an ANDROID_BUILD_TOP environment variable \
+         containing a path to the Android source tree. This is typically \
+         provided by initializing the Android build environment.")
 endif
 
-export ARM64_TOOLS_PREFIX=$(ANDROID_NDK_PREFIX)/bin
+include $(CHRE_PREFIX)/build/clang.mk
+export ARM64_TOOLS_PREFIX=$(CLANG_TOOLCHAIN_PATH)/bin
 
 # arm64 Tools ##################################################################
 
diff --git a/build/build_template.mk b/build/build_template.mk
index 74dcd399..441e6896 100644
--- a/build/build_template.mk
+++ b/build/build_template.mk
@@ -304,22 +304,22 @@ $$(OUT)/$(1):
 $$($(1)_CC_DEPS): $(OUT)/$$($(1)_OBJS_DIR)/%.d: %.cc
 	$(V)mkdir -p $$(dir $$@)
 	$(V)$(3) $(DEP_CFLAGS) $(COMMON_CXX_CFLAGS) \
-		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) -c $$< -o $$@
+		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) $$< -o $$@
 
 $$($(1)_CPP_DEPS): $(OUT)/$$($(1)_OBJS_DIR)/%.d: %.cpp
 	$(V)mkdir -p $$(dir $$@)
 	$(V)$(3) $(DEP_CFLAGS) $(COMMON_CXX_CFLAGS) \
-		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) -c $$< -o $$@
+		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) $$< -o $$@
 
 $$($(1)_C_DEPS): $(OUT)/$$($(1)_OBJS_DIR)/%.d: %.c
 	$(V)mkdir -p $$(dir $$@)
 	$(V)$(3) $(DEP_CFLAGS) $(COMMON_C_CFLAGS) \
-		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) -c $$< -o $$@
+		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) $$< -o $$@
 
 $$($(1)_S_DEPS): $(OUT)/$$($(1)_OBJS_DIR)/%.d: %.S
 	$(V)mkdir -p $$(dir $$@)
 	$(V)$(3) $(DEP_CFLAGS) \
-		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) -c $$< -o $$@
+		-DCHRE_FILENAME=\"$$(notdir $$<)\" $(2) $$< -o $$@
 
 # Include generated dependency files if they are in the requested build target.
 # This avoids dependency generation from occuring for a debug target when a
diff --git a/build/clang.mk b/build/clang.mk
index e5768ced..d68b8356 100644
--- a/build/clang.mk
+++ b/build/clang.mk
@@ -10,5 +10,5 @@ $(error "You should supply an ANDROID_BUILD_TOP environment variable \
 endif
 
 # Clang toolchain path ########################################################
-CLANG_TOOLCHAIN_PATH=$(ANDROID_BUILD_TOP)/prebuilts/clang/host/linux-x86/clang-r530567
+CLANG_TOOLCHAIN_PATH=$(ANDROID_BUILD_TOP)/prebuilts/clang/host/linux-x86/clang-r547379
 IS_CLANG_TOOLCHAIN=true
diff --git a/build/nanoapp/app.mk b/build/nanoapp/app.mk
index e1305478..16c02472 100644
--- a/build/nanoapp/app.mk
+++ b/build/nanoapp/app.mk
@@ -103,6 +103,14 @@ ifneq ($(NANOAPP_NO_UTILS_INCLUDE),true)
 COMMON_CFLAGS += -I$(CHRE_PREFIX)/util/include
 endif
 
+# As one nanaopp should only run in one thread, we don't want the compiler to
+# generate __cxa_guard_acquire/__cxa_guard_release which could be not supported
+# by platforms.
+# Note: this flag is clang/GCC-specific, so ideally it would go in a
+# compiler-specific area, but today there is no good place and we do not build
+# with other toolchains using this build system.
+COMMON_CFLAGS += -fno-threadsafe-statics
+
 # Allows a nanoapp to know that is compiled separately from the CHRE system.
 COMMON_CFLAGS += -DCHRE_IS_NANOAPP_BUILD
 
diff --git a/build/variant/google_arm64_android.mk b/build/variant/google_arm64_android.mk
index 285b6d3b..acd4f9e1 100644
--- a/build/variant/google_arm64_android.mk
+++ b/build/variant/google_arm64_android.mk
@@ -14,6 +14,7 @@ TARGET_CFLAGS += $(GOOGLE_ARM64_ANDROID_CFLAGS)
 TARGET_PLATFORM_ID = 0x476f6f676c000001
 
 TARGET_CFLAGS += $(SIM_CFLAGS)
+TARGET_CFLAGS += -DCHRE_FIRST_SUPPORTED_API_VERSION=CHRE_API_VERSION_1_2
 TARGET_VARIANT_SRCS += $(SIM_SRCS)
 
 ifneq ($(filter $(TARGET_NAME)% all, $(MAKECMDGOALS)),)
diff --git a/chpp/Android.bp b/chpp/Android.bp
index d969812e..7394e982 100644
--- a/chpp/Android.bp
+++ b/chpp/Android.bp
@@ -229,10 +229,20 @@ cc_test_host {
     name: "chre_chpp_fake_link_sync_tests",
     defaults: ["chre_chpp_core_without_link"],
     cflags: [
+        "-DCHPP_CLIENT_ENABLED_DISCOVERY",
+        "-DCHPP_CLIENT_ENABLED_WIFI",
+        "-DCHPP_DEBUG_ASSERT_ENABLED",
+        "-DCHPP_ENABLE_WORK_MONITOR",
+        "-DCHPP_WIFI_DEFAULT_CAPABILITIES=0xf",
         // Speed up tests by setting timeouts to 50 ms.
         // Note: the value shouldn't be too low to avoid timeouts on slow test servers.
         "-DCHPP_TRANSPORT_RX_TIMEOUT_NS=50000000",
         "-DCHPP_TRANSPORT_TX_TIMEOUT_NS=50000000",
+        // App layer timeout should be higher than transport; at least MAX_RESET * MAX_RETX * TX_TIMEOUT.
+        "-DCHPP_CLIENT_ENABLED_VENDOR",
+        "-DCHPP_REQUEST_TIMEOUT_DEFAULT=1000000000",
+        "-DCHPP_TRANSPORT_MAX_RESET=2",
+        "-DCHPP_TRANSPORT_MAX_RETX=2",
     ],
     local_include_dirs: [
         "include",
@@ -243,7 +253,12 @@ cc_test_host {
         "platform/linux/include",
     ],
     srcs: [
+        "clients/discovery.c",
+        "clients/wifi.c",
+        "common/wifi_convert.c",
+        "common/wifi_utils.c",
         "test/fake_link.cpp",
+        "test/fake_link_client.cpp",
         "test/fake_link_sync_test.cpp",
         "test/packet_util.cpp",
     ],
diff --git a/chpp/app.c b/chpp/app.c
index 55d6bc6a..93da2baf 100644
--- a/chpp/app.c
+++ b/chpp/app.c
@@ -722,6 +722,31 @@ void chppAppProcessRxDatagram(struct ChppAppState *context, uint8_t *buf,
   chppDatagramProcessDoneCb(context->transportContext, buf);
 }
 
+void chppAppProcessTimeout(struct ChppAppState *context,
+                           uint64_t currentTimeNs) {
+  CHPP_DEBUG_NOT_NULL(context);
+  for (uint8_t i = 0; i < context->registeredClientCount; i++) {
+    const struct ChppClient *client = context->registeredClients[i];
+    struct ChppEndpointState *endpointState =
+        context->registeredClientStates[i];
+    if ((currentTimeNs >= endpointState->nextTimerTimeoutNs) &&
+        client->timeoutFunctionPtr != NULL) {
+      client->timeoutFunctionPtr(endpointState->context);
+      endpointState->nextTimerTimeoutNs = CHPP_TIME_MAX;
+    }
+  }
+  for (uint8_t i = 0; i < context->registeredServiceCount; i++) {
+    const struct ChppService *service = context->registeredServices[i];
+    struct ChppEndpointState *endpointState =
+        context->registeredServiceStates[i];
+    if ((currentTimeNs >= endpointState->nextTimerTimeoutNs) &&
+        service->timeoutFunctionPtr != NULL) {
+      service->timeoutFunctionPtr(endpointState->context);
+      endpointState->nextTimerTimeoutNs = CHPP_TIME_MAX;
+    }
+  }
+}
+
 void chppAppProcessReset(struct ChppAppState *context) {
   CHPP_DEBUG_NOT_NULL(context);
 
@@ -1239,4 +1264,35 @@ void chppCloseOpenRequests(struct ChppEndpointState *endpointState,
   if (recalcNeeded) {
     chppRecalculateNextTimeout(appState, type);
   }
+}
+
+bool chppAppRequestTimerTimeout(struct ChppEndpointState *endpointState,
+                                uint64_t timeoutNs) {
+  if (endpointState->nextTimerTimeoutNs != CHPP_TIME_MAX) {
+    CHPP_LOGE("Timer already scheduled for %" PRIu64 "ns",
+              endpointState->nextTimerTimeoutNs);
+    return false;
+  }
+
+  endpointState->nextTimerTimeoutNs = chppGetCurrentTimeNs() + timeoutNs;
+  return true;
+}
+
+void chppAppCancelTimerTimeout(struct ChppEndpointState *endpointState) {
+  endpointState->nextTimerTimeoutNs = CHPP_TIME_MAX;
+}
+
+uint64_t chppAppGetNextTimerTimeoutNs(struct ChppAppState *context) {
+  CHPP_DEBUG_NOT_NULL(context);
+  uint64_t timeoutNs = CHPP_TIME_MAX;
+  for (uint8_t i = 0; i < context->registeredClientCount; i++) {
+    timeoutNs =
+        MIN(timeoutNs, context->registeredClientStates[i]->nextTimerTimeoutNs);
+  }
+  for (uint8_t i = 0; i < context->registeredServiceCount; i++) {
+    timeoutNs =
+        MIN(timeoutNs, context->registeredServiceStates[i]->nextTimerTimeoutNs);
+  }
+
+  return timeoutNs;
 }
\ No newline at end of file
diff --git a/chpp/clients.c b/chpp/clients.c
index 4c3df54e..2be5fa35 100644
--- a/chpp/clients.c
+++ b/chpp/clients.c
@@ -191,6 +191,7 @@ void chppRegisterClient(struct ChppAppState *appContext, void *clientContext,
   clientState->outReqStates = outReqStates;
   clientState->index = appContext->registeredClientCount;
   clientState->context = clientContext;
+  clientState->nextTimerTimeoutNs = CHPP_TIME_MAX;
   appContext->registeredClientStates[appContext->registeredClientCount] =
       clientState;
 
@@ -323,6 +324,11 @@ bool chppClientSendTimestampedRequestOrFail(
   CHPP_DEBUG_NOT_NULL(buf);
 
   if (!chppIsClientApiReady(clientState)) {
+    if (clientState->initialized &&
+        clientState->openState == CHPP_OPEN_STATE_CLOSED) {
+      CHPP_LOGW("Trying to send request when closed - link broken?");
+      chppTransportForceReset(clientState->appContext->transportContext);
+    }
     CHPP_FREE_AND_NULLIFY(buf);
     return false;
   }
@@ -387,7 +393,7 @@ bool chppClientSendOpenRequest(struct ChppEndpointState *clientState,
     CHPP_LOGD("Opening service - non-blocking");
     result = chppClientSendTimestampedRequestOrFail(
         clientState, openReqState, request, sizeof(*request),
-        CHPP_REQUEST_TIMEOUT_INFINITE);
+        CHPP_REQUEST_TIMEOUT_DEFAULT);
   }
 
   if (!result) {
diff --git a/chpp/clients/gnss.c b/chpp/clients/gnss.c
index 18b0e941..6f02dc05 100644
--- a/chpp/clients/gnss.c
+++ b/chpp/clients/gnss.c
@@ -110,6 +110,9 @@ static const struct ChppClient kGnssClientConfig = {
     // Service notification dispatch function pointer
     .deinitFunctionPtr = &chppGnssClientDeinit,
 
+    // Client timeout function pointer
+    .timeoutFunctionPtr = NULL,  // Not used
+
     // Number of request-response states in the outReqStates array.
     .outReqCount = ARRAY_SIZE(gGnssClientContext.outReqStates),
 
diff --git a/chpp/clients/loopback.c b/chpp/clients/loopback.c
index c92ae68a..d8d8b991 100644
--- a/chpp/clients/loopback.c
+++ b/chpp/clients/loopback.c
@@ -23,12 +23,11 @@
 
 #include "chpp/app.h"
 #include "chpp/clients.h"
+#include "chpp/clients/discovery.h"
 #include "chpp/log.h"
 #include "chpp/memory.h"
 #include "chpp/transport.h"
 
-#include "chpp/clients/discovery.h"
-
 /************************************************
  *  Prototypes
  ***********************************************/
@@ -49,6 +48,10 @@ struct ChppLoopbackClientState {
   const uint8_t *loopbackData;               // Pointer to loopback data
 };
 
+// A loopback test buffer used for chppRunLoopbackTestAsync.
+#define LOOPBACK_BUF_LEN 3
+static const uint8_t gLoopbackBuf[LOOPBACK_BUF_LEN] = {1, 2, 3};
+
 /************************************************
  *  Public Functions
  ***********************************************/
@@ -56,6 +59,10 @@ struct ChppLoopbackClientState {
 void chppLoopbackClientInit(struct ChppAppState *appState) {
   CHPP_LOGD("Loopback client init");
   CHPP_DEBUG_NOT_NULL(appState);
+  if (appState->loopbackClientContext != NULL) {
+    CHPP_LOGE("Loopback client already initialized");
+    return;
+  }
 
   appState->loopbackClientContext =
       chppMalloc(sizeof(struct ChppLoopbackClientState));
@@ -94,6 +101,7 @@ bool chppDispatchLoopbackServiceResponse(struct ChppAppState *appState,
 
   struct ChppLoopbackTestResult *result = &state->testResult;
 
+  chppMutexLock(&state->client.syncResponse.mutex);
   result->error = CHPP_APP_ERROR_NONE;
   result->responseLen = len;
   result->firstError = len;
@@ -116,14 +124,13 @@ bool chppDispatchLoopbackServiceResponse(struct ChppAppState *appState,
     }
   }
 
-  CHPP_LOGD("Loopback client RX err=0x%" PRIx16 " len=%" PRIuSIZE
+  CHPP_LOGI("Loopback client RX err=0x%" PRIx16 " len=%" PRIuSIZE
             " req len=%" PRIuSIZE " first err=%" PRIuSIZE
             " total err=%" PRIuSIZE,
             result->error, result->responseLen, result->requestLen,
             result->firstError, result->byteErrors);
 
   // Notify waiting (synchronous) client
-  chppMutexLock(&state->client.syncResponse.mutex);
   state->client.syncResponse.ready = true;
   chppConditionVariableSignal(&state->client.syncResponse.condVar);
   chppMutexUnlock(&state->client.syncResponse.mutex);
@@ -131,67 +138,116 @@ bool chppDispatchLoopbackServiceResponse(struct ChppAppState *appState,
   return true;
 }
 
-struct ChppLoopbackTestResult chppRunLoopbackTest(struct ChppAppState *appState,
-                                                  const uint8_t *buf,
-                                                  size_t len) {
-  CHPP_LOGD("Loopback client TX len=%" PRIuSIZE,
-            len + CHPP_LOOPBACK_HEADER_LEN);
-
+static enum ChppAppErrorCode chppLoopbackCheckPreconditions(
+    struct ChppAppState *appState) {
   if (appState == NULL) {
     CHPP_LOGE("Cannot run loopback test with null app");
-    struct ChppLoopbackTestResult result;
-    result.error = CHPP_APP_ERROR_UNSUPPORTED;
-    return result;
+    return CHPP_APP_ERROR_UNSUPPORTED;
   }
 
   if (!chppWaitForDiscoveryComplete(appState, 0 /* timeoutMs */)) {
-    struct ChppLoopbackTestResult result;
-    result.error = CHPP_APP_ERROR_NOT_READY;
-    return result;
+    return CHPP_APP_ERROR_NOT_READY;
   }
 
-  struct ChppLoopbackClientState *state = appState->loopbackClientContext;
-  CHPP_NOT_NULL(state);
-  struct ChppLoopbackTestResult *result = &state->testResult;
-
-  if (result->error == CHPP_APP_ERROR_BLOCKED) {
-    CHPP_DEBUG_ASSERT_LOG(false, "Another loopback in progress");
-    return *result;
-  }
+  return CHPP_APP_ERROR_NONE;
+}
 
-  result->error = CHPP_APP_ERROR_BLOCKED;
-  result->requestLen = len + CHPP_LOOPBACK_HEADER_LEN;
-  result->responseLen = 0;
-  result->firstError = 0;
-  result->byteErrors = 0;
-  result->rttNs = 0;
-  state->runLoopbackTest.requestTimeNs = CHPP_TIME_NONE;
-  state->runLoopbackTest.responseTimeNs = CHPP_TIME_NONE;
+/**
+ * Internal method for running the loopback test (sync or async).
+ *
+ * Note that the input buf must be valid for duration of the loopback test, so
+ * it is recommended to use a read-only constant.
+ *
+ * @param appState Application layer state.
+ * @param buf Input data. Cannot be null.
+ * @param len Length of input data in bytes.
+ * @param sync If true, runs the loopback test in synchronous mode.
+ * @param result A non-null pointer to store the detailed result of the test.
+ *
+ * @return true if the test was successfully started
+ */
+static bool chppRunLoopbackTestInternal(struct ChppAppState *appState,
+                                        const uint8_t *buf, size_t len,
+                                        bool sync,
+                                        struct ChppLoopbackTestResult *out) {
+  CHPP_NOT_NULL(out);
+  bool success = false;
+  CHPP_LOGD("Loopback client TX len=%" PRIuSIZE,
+            len + CHPP_LOOPBACK_HEADER_LEN);
 
-  if (len == 0) {
+  enum ChppAppErrorCode error = chppLoopbackCheckPreconditions(appState);
+  if (error != CHPP_APP_ERROR_NONE) {
+    out->error = error;
+  } else if (len == 0) {
     CHPP_LOGE("Loopback payload=0!");
-    result->error = CHPP_APP_ERROR_INVALID_LENGTH;
-    return *result;
-  }
-
-  uint8_t *loopbackRequest =
-      (uint8_t *)chppAllocClientRequest(&state->client, result->requestLen);
+    out->error = CHPP_APP_ERROR_INVALID_LENGTH;
+  } else {
+    struct ChppLoopbackClientState *state = appState->loopbackClientContext;
+    CHPP_NOT_NULL(state);
+    chppMutexLock(&state->client.syncResponse.mutex);
+    struct ChppLoopbackTestResult *result = &state->testResult;
+
+    if (result->error == CHPP_APP_ERROR_BLOCKED) {
+      CHPP_DEBUG_ASSERT_LOG(false, "Another loopback in progress");
+      out->error = CHPP_APP_ERROR_BLOCKED;
+    } else {
+      memset(result, 0, sizeof(struct ChppLoopbackTestResult));
+      result->error = CHPP_APP_ERROR_BLOCKED;
+      result->requestLen = len + CHPP_LOOPBACK_HEADER_LEN;
+
+      uint8_t *loopbackRequest =
+          (uint8_t *)chppAllocClientRequest(&state->client, result->requestLen);
+
+      if (loopbackRequest == NULL) {
+        CHPP_LOG_OOM();
+        result->error = CHPP_APP_ERROR_OOM;
+      } else {
+        state->loopbackData = buf;
+        memcpy(&loopbackRequest[CHPP_LOOPBACK_HEADER_LEN], buf, len);
+
+        chppMutexUnlock(&state->client.syncResponse.mutex);
+        if (sync) {
+          if (!chppClientSendTimestampedRequestAndWaitTimeout(
+                  &state->client, &state->runLoopbackTest, loopbackRequest,
+                  result->requestLen, 5 * CHPP_NSEC_PER_SEC)) {
+            result->error = CHPP_APP_ERROR_UNSPECIFIED;
+          } else {
+            success = true;
+          }
+        } else {
+          if (!chppClientSendTimestampedRequestOrFail(
+                  &state->client, &state->runLoopbackTest, loopbackRequest,
+                  result->requestLen, 5 * CHPP_NSEC_PER_SEC)) {
+            result->error = CHPP_APP_ERROR_UNSPECIFIED;
+          } else {
+            success = true;
+          }
+        }
+        chppMutexLock(&state->client.syncResponse.mutex);
+
+        *out = state->testResult;
+      }
+    }
 
-  if (loopbackRequest == NULL) {
-    result->requestLen = 0;
-    result->error = CHPP_APP_ERROR_OOM;
-    CHPP_LOG_OOM();
-    return *result;
+    chppMutexUnlock(&state->client.syncResponse.mutex);
   }
 
-  state->loopbackData = buf;
-  memcpy(&loopbackRequest[CHPP_LOOPBACK_HEADER_LEN], buf, len);
-
-  if (!chppClientSendTimestampedRequestAndWaitTimeout(
-          &state->client, &state->runLoopbackTest, loopbackRequest,
-          result->requestLen, 5 * CHPP_NSEC_PER_SEC)) {
-    result->error = CHPP_APP_ERROR_UNSPECIFIED;
-  }
+  return success;
+}
 
-  return *result;
+struct ChppLoopbackTestResult chppRunLoopbackTest(struct ChppAppState *appState,
+                                                  const uint8_t *buf,
+                                                  size_t len) {
+  struct ChppLoopbackTestResult result;
+  chppRunLoopbackTestInternal(appState, buf, len, /* sync= */ true, &result);
+  return result;
 }
+
+enum ChppAppErrorCode chppRunLoopbackTestAsync(struct ChppAppState *appState) {
+  struct ChppLoopbackTestResult result;
+  bool success = chppRunLoopbackTestInternal(
+      appState, gLoopbackBuf, LOOPBACK_BUF_LEN, /* sync= */ false, &result);
+  // Override the result for the success case because for async, the stored
+  // error code would be CHPP_APP_ERROR_BLOCKED until the response arrives.
+  return success ? CHPP_APP_ERROR_NONE : result.error;
+}
\ No newline at end of file
diff --git a/chpp/clients/wifi.c b/chpp/clients/wifi.c
index 87f28a30..e4c78876 100644
--- a/chpp/clients/wifi.c
+++ b/chpp/clients/wifi.c
@@ -28,6 +28,9 @@
 #ifdef CHPP_CLIENT_ENABLED_TIMESYNC
 #include "chpp/clients/timesync.h"
 #endif
+#ifdef CHPP_CLIENT_ENABLED_LOOPBACK
+#include "chpp/clients/loopback.h"
+#endif
 #include "chpp/common/standard_uuids.h"
 #include "chpp/common/wifi.h"
 #include "chpp/common/wifi_types.h"
@@ -66,6 +69,7 @@ static bool chppWifiClientInit(void *clientContext, uint8_t handle,
 static void chppWifiClientDeinit(void *clientContext);
 static void chppWifiClientNotifyReset(void *clientContext);
 static void chppWifiClientNotifyMatch(void *clientContext);
+static void chppWifiClientProcessTimeout(void *clientContext);
 
 /************************************************
  *  Private Definitions
@@ -88,6 +92,7 @@ struct ChppWifiClientState {
                                     // service reset
   bool capabilitiesValid;  // Flag to indicate if the capabilities result
                            // is valid
+  bool scanTimeoutPending;
 };
 
 // Note: This global definition of gWifiClientContext supports only one
@@ -125,6 +130,9 @@ static const struct ChppClient kWifiClientConfig = {
     // Service notification dispatch function pointer
     .deinitFunctionPtr = &chppWifiClientDeinit,
 
+    // Client timeout function pointer
+    .timeoutFunctionPtr = &chppWifiClientProcessTimeout,
+
     // Number of request-response states in the outReqStates array.
     .outReqCount = ARRAY_SIZE(gWifiClientContext.outReqStates),
 
@@ -365,6 +373,34 @@ static void chppWifiClientDeinit(void *clientContext) {
   chppClientDeinit(&wifiClientContext->client);
 }
 
+static void chppWifiClientProcessTimeout(void *clientContext) {
+  UNUSED_VAR(clientContext);
+  struct ChppWifiClientState *wifiClientContext =
+      (struct ChppWifiClientState *)clientContext;
+  if (wifiClientContext->scanTimeoutPending) {
+    wifiClientContext->scanTimeoutPending = false;
+    // In some scenarios, it's possible that a WiFi scan event is lost due to
+    // some issues at the remote WiFi service. We trigger a loopback request in
+    // this case, in the hopes of triggering the link to receive the scan event.
+    // TODO(b/393371508): Remove this workaround when the issue is fixed
+    CHPP_LOGE("WiFi scan event did not arrive on time!");
+#ifdef CHPP_CLIENT_ENABLED_LOOPBACK
+    if (!wifiClientContext->client.appContext->clientServiceSet
+             .loopbackClient) {
+      CHPP_LOGW("Loopback client not enabled, scan may be delayed");
+    } else {
+      enum ChppAppErrorCode error =
+          chppRunLoopbackTestAsync(wifiClientContext->client.appContext);
+      if (error != CHPP_APP_ERROR_NONE) {
+        CHPP_LOGE("Failed to request loopback");
+      } else {
+        CHPP_LOGI("Async loopback request sent");
+      }
+    }
+#endif
+  }
+}
+
 /**
  * Notifies the client of an incoming reset.
  *
@@ -538,6 +574,14 @@ static void chppWifiRequestScanResult(struct ChppWifiClientState *clientContext,
     struct ChppWifiRequestScanResponseParameters *result =
         &((struct ChppWifiRequestScanResponse *)buf)->params;
     CHPP_LOGI("Scan request success=%d at service", result->pending);
+    if (result->pending) {
+      if (!chppAppRequestTimerTimeout(&clientContext->client,
+                                      CHRE_NSEC_PER_SEC)) {
+        CHPP_LOGE("Failed to schedule scan timeout");
+      } else {
+        clientContext->scanTimeoutPending = true;
+      }
+    }
     gCallbacks->scanResponseCallback(result->pending, result->errorCode);
   }
 }
@@ -653,6 +697,10 @@ static void chppWifiScanEventNotification(
 #endif
 
     CHPP_DEBUG_ASSERT(chppCheckWifiScanEventNotification(chre));
+    if (!chppCheckWifiScanEventPending()) {
+      chppAppCancelTimerTimeout(&clientContext->client);
+      clientContext->scanTimeoutPending = false;
+    }
 
     gCallbacks->scanEventCallback(chre);
   }
diff --git a/chpp/clients/wwan.c b/chpp/clients/wwan.c
index 396a1008..2beffe34 100644
--- a/chpp/clients/wwan.c
+++ b/chpp/clients/wwan.c
@@ -110,6 +110,9 @@ static const struct ChppClient kWwanClientConfig = {
     // Service notification dispatch function pointer
     .deinitFunctionPtr = &chppWwanClientDeinit,
 
+    // Client timeout function pointer
+    .timeoutFunctionPtr = NULL,  // Not used
+
     // Number of request-response states in the outReqStates array.
     .outReqCount = ARRAY_SIZE(gWwanClientContext.outReqStates),
 
diff --git a/chpp/common/wifi_utils.c b/chpp/common/wifi_utils.c
index 45495366..c1c70af0 100644
--- a/chpp/common/wifi_utils.c
+++ b/chpp/common/wifi_utils.c
@@ -70,3 +70,7 @@ bool chppCheckWifiScanEventNotification(const struct chreWifiScanEvent *chre) {
 
   return success;
 }
+
+bool chppCheckWifiScanEventPending(void) {
+  return gResultAcc != gResultTotal;
+}
\ No newline at end of file
diff --git a/chpp/include/chpp/app.h b/chpp/include/chpp/app.h
index 907a07b4..5c35c8a5 100644
--- a/chpp/include/chpp/app.h
+++ b/chpp/include/chpp/app.h
@@ -274,6 +274,11 @@ typedef void(ChppClientDeinitFunction)(void *context);
  */
 typedef void(ChppNotifierFunction)(void *context);
 
+/**
+ * Function type that processes a timeout for any client or service
+ */
+typedef void(ChppTimeoutFunction)(void *context);
+
 /**
  * Length of a service UUID and its human-readable printed form in bytes
  */
@@ -343,6 +348,9 @@ struct ChppService {
   //! Errors returned by the dispatch function are logged.
   ChppDispatchFunction *responseDispatchFunctionPtr;
 
+  //! Processes a timeout for the client.
+  ChppTimeoutFunction *timeoutFunctionPtr;
+
   //! Number of outgoing requests supported by this service.
   //! ChppAppHeader.command must be in the range [0, outReqCount - 1]
   //! ChppEndpointState.outReqStates must contains that many elements.
@@ -404,6 +412,9 @@ struct ChppClient {
   //! Deinitializes the client.
   ChppClientDeinitFunction *deinitFunctionPtr;
 
+  //! Processes a timeout for the client.
+  ChppTimeoutFunction *timeoutFunctionPtr;
+
   //! Number of outgoing requests supported by this client.
   //! ChppAppHeader.command must be in the range [0, outReqCount - 1]
   //! ChppEndpointState.outReqStates must contains that many elements.
@@ -513,6 +524,8 @@ struct ChppEndpointState {
   bool pseudoOpen : 1;       //!< Client to be opened upon a reset
   bool initialized : 1;      //!< Client is initialized
   bool everInitialized : 1;  //!< Client sync primitives initialized
+
+  uint64_t nextTimerTimeoutNs;  //!< The next timer timeout in nanoseconds.
 };
 
 struct ChppAppState {
@@ -629,6 +642,18 @@ void chppAppProcessRxDatagram(struct ChppAppState *context, uint8_t *buf,
  */
 void chppAppProcessReset(struct ChppAppState *context);
 
+/**
+ * Processes a timeout event. This method is called by the transport layer when
+ * a timeout has occurred, based on the next timer timeout specified through
+ * chppAppGetNextTimerTimeoutNs().
+ *
+ * @param context Maintains status for each app layer instance.
+ * @param currentTimeNs The current time to check the timeout against, used as
+ * an argument to save processing overhead to call chppGetCurrentTimeNs().
+ */
+void chppAppProcessTimeout(struct ChppAppState *context,
+                           uint64_t currentTimeNs);
+
 /**
  * Convert UUID to a human-readable, null-terminated string.
  *
@@ -909,6 +934,31 @@ uint64_t *getNextRequestTimeoutNs(struct ChppAppState *appState,
 void chppCloseOpenRequests(struct ChppEndpointState *endpointState,
                            enum ChppEndpointType type, bool clearOnly);
 
+/**
+ * Schedules a timer for the given endpoint.
+ *
+ * @param endpointState State of the endpoint.
+ * @param timeoutNs The timeout in nanoseconds.
+ * @return True if the timer was scheduled successfully.
+ */
+bool chppAppRequestTimerTimeout(struct ChppEndpointState *endpointState,
+                                uint64_t timeoutNs);
+
+/**
+ *  Cancels a timer for the given endpoint.
+ *
+ * @param endpointState State of the endpoint.
+ */
+void chppAppCancelTimerTimeout(struct ChppEndpointState *endpointState);
+
+/**
+ * Returns the next timer timeout for endpoints.
+ *
+ * @param appState State of the app layer.
+ * @return The next timer timeout in nanoseconds.
+ */
+uint64_t chppAppGetNextTimerTimeoutNs(struct ChppAppState *appState);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/chpp/include/chpp/clients/loopback.h b/chpp/include/chpp/clients/loopback.h
index 5f2b3829..c6154d6f 100644
--- a/chpp/include/chpp/clients/loopback.h
+++ b/chpp/include/chpp/clients/loopback.h
@@ -82,11 +82,27 @@ bool chppDispatchLoopbackServiceResponse(struct ChppAppState *appState,
  * Note that only one loopback test may be run at any time on each client.
  *
  * @param appState Application layer state.
+ * @param buf Input data. Cannot be null.
+ * @param len Length of input data in bytes.
+ *
+ * @return The result of the loopback test.
  */
 struct ChppLoopbackTestResult chppRunLoopbackTest(struct ChppAppState *appState,
                                                   const uint8_t *buf,
                                                   size_t len);
 
+/**
+ * Asynchronously starts a loopback tests. The result of the loopback test will
+ * be processed in chppDispatchLoopbackServiceResponse at a later time.
+ *
+ * Unlike the sync chppRunLoopbackTest(), this method does not expose the buffer
+ * as an input, and the loopback payload is preconfigured for simplicity.
+ *
+ * @return CHPP_ERROR_NONE if the request was accepted and the loopback test
+ * started.
+ */
+enum ChppAppErrorCode chppRunLoopbackTestAsync(struct ChppAppState *appState);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/chpp/include/chpp/common/wifi_utils.h b/chpp/include/chpp/common/wifi_utils.h
index 24a10194..e189dd9d 100644
--- a/chpp/include/chpp/common/wifi_utils.h
+++ b/chpp/include/chpp/common/wifi_utils.h
@@ -42,6 +42,15 @@ void chppCheckWifiScanEventNotificationReset(void);
  */
 bool chppCheckWifiScanEventNotification(const struct chreWifiScanEvent *chre);
 
+/**
+ * Helper function to determine whether we are still waiting for more WiFi scan
+ * events. This method must be used in conjunction with
+ * chppCheckWifiScanEventNotification().
+ *
+ * @return true if more WiFi scan events are pending.
+ */
+bool chppCheckWifiScanEventPending(void);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/chpp/include/chpp/transport.h b/chpp/include/chpp/transport.h
index 32d8cfe0..37e84f53 100644
--- a/chpp/include/chpp/transport.h
+++ b/chpp/include/chpp/transport.h
@@ -58,7 +58,7 @@ extern "C" {
  * attempted. Setting this to zero disables retransmissions.
  */
 #ifndef CHPP_TRANSPORT_MAX_RETX
-#define CHPP_TRANSPORT_MAX_RETX UINT16_C(4)
+#define CHPP_TRANSPORT_MAX_RETX UINT16_C(6)
 #endif
 
 /**
@@ -169,6 +169,8 @@ enum ChppTransportErrorCode {
   CHPP_TRANSPORT_ERROR_TIMEOUT = 6,
   //! Too many retries
   CHPP_TRANSPORT_ERROR_MAX_RETRIES = 7,
+  //! Forced reset at the transport
+  CHPP_TRANSPORT_ERROR_FORCED_RESET = 8,
   //! Message incomprehensible at App Layer
   CHPP_TRANSPORT_ERROR_APPLAYER = 0xF,
 };
@@ -340,10 +342,6 @@ struct ChppTxStatus {
   //! ACKed or not)
   uint8_t sentSeq;
 
-  //! Does the transport layer have any packets (with or without payload) it
-  //! needs to send out?
-  bool hasPacketsToSend;
-
   //! Error code, if any, of the next packet the transport layer will send out.
   uint8_t packetCodeToSend;
 
@@ -536,6 +534,14 @@ bool chppEnqueueTxDatagramOrFail(struct ChppTransportState *context, void *buf,
 void chppEnqueueTxErrorDatagram(struct ChppTransportState *context,
                                 enum ChppTransportErrorCode errorCode);
 
+/**
+ * Forces a tranport layer reset. This function can be called from the app
+ * layer.
+ *
+ * @param context Maintains state for each transport layer instance.
+ */
+void chppTransportForceReset(struct ChppTransportState *context);
+
 /**
  * Provides systems that do not use chppWorkThreadStart() and its associated
  * timeout mechanisms (that relies on chppNotifierTimedWait()) how long they
@@ -687,14 +693,16 @@ uint8_t chppRunTransportLoopback(struct ChppTransportState *context,
  * chppWorkThreadStart() would require to call this function after initializing
  * CHPP.
  *
+ * ChppTransportState->mutex must be held while invoking this method.
+ *
  * @param context Maintains state for each transport layer instance.
  * @param resetType Distinguishes a reset from a reset-ack, as defined in the
  * ChppTransportPacketAttributes struct.
  * @param error Provides the error that led to the reset.
  */
-void chppTransportSendReset(struct ChppTransportState *context,
-                            enum ChppTransportPacketAttributes resetType,
-                            enum ChppTransportErrorCode error);
+void chppTransportSendResetLocked(struct ChppTransportState *context,
+                                  enum ChppTransportPacketAttributes resetType,
+                                  enum ChppTransportErrorCode error);
 
 /**
  * Returns the Tx MTU size at the transport layer in bytes.
diff --git a/chpp/include/chpp/transport_signals.h b/chpp/include/chpp/transport_signals.h
index befd4fcb..bb5473f8 100644
--- a/chpp/include/chpp/transport_signals.h
+++ b/chpp/include/chpp/transport_signals.h
@@ -34,6 +34,9 @@ extern "C" {
 //! the next timeout can be recalculated
 #define CHPP_TRANSPORT_SIGNAL_RECALC_TIMEOUT UINT32_C(1 << 2)
 
+//! Triggers a forced RESET at the transport layer
+#define CHPP_TRANSPORT_SIGNAL_FORCE_RESET UINT32_C(1 << 3)
+
 //! These bits are reserved for platform use (e.g. in the platform-specific
 //! link layer implementation).
 #define CHPP_TRANSPORT_SIGNAL_PLATFORM_MASK UINT32_C(0xFFFF0000)
diff --git a/chpp/platform/linux/include/chpp/platform/platform_link.h b/chpp/platform/linux/include/chpp/platform/platform_link.h
index 886ee747..5a004d3f 100644
--- a/chpp/platform/linux/include/chpp/platform/platform_link.h
+++ b/chpp/platform/linux/include/chpp/platform/platform_link.h
@@ -69,10 +69,6 @@ struct ChppLinuxLinkState {
   //! will cause the CHPP link layer to fail to send/receive messages.
   bool isLinkActive;
 
-  //! Whether to wait for cycleSendThread to be called to unblock the send
-  //! thread loop.
-  bool manualSendCycle;
-
   //! State of the associated transport layer.
   struct ChppTransportState *transportContext;
 
@@ -89,10 +85,12 @@ struct ChppLinuxLinkState {
 const struct ChppLinkApi *getLinuxLinkApi(void);
 
 /**
- * Starts the send thread loop when manualSendCycle is true.
- * This function is a noop when manualSendCycle is false.
+ * Waits for chppLinkSendDoneCb to invoked, indicating that a previously
+ * enqueued TX packet has been sent over the link API.
+ *
+ * It is not valid to call this function when no packets are pending.
  */
-void cycleSendThread(void);
+void waitForLinkSendDone(void);
 
 #ifdef __cplusplus
 }
diff --git a/chpp/platform/linux/include/chpp/platform/platform_notifier.h b/chpp/platform/linux/include/chpp/platform/platform_notifier.h
index 0b0b429d..dce4b7a8 100644
--- a/chpp/platform/linux/include/chpp/platform/platform_notifier.h
+++ b/chpp/platform/linux/include/chpp/platform/platform_notifier.h
@@ -29,7 +29,8 @@ extern "C" {
 struct ChppNotifier {
   pthread_cond_t cond;     // Condition variable
   struct ChppMutex mutex;  // Platform-specific mutex
-  uint32_t signal;
+  uint32_t signal;         // The 32-bit signal value stored when calling
+                           // chppNotifierSignal().
 };
 
 /**
diff --git a/chpp/platform/linux/link.c b/chpp/platform/linux/link.c
index f3c67bfb..1b4cd0ae 100644
--- a/chpp/platform/linux/link.c
+++ b/chpp/platform/linux/link.c
@@ -32,10 +32,15 @@
 #define SIGNAL_DATA UINT32_C(1 << 1)
 #define SIGNAL_DATA_RX UINT32_C(1 << 2)
 
-struct ChppNotifier gCycleSendThreadNotifier;
-
-void cycleSendThread(void) {
-  chppNotifierSignal(&gCycleSendThreadNotifier, 1);
+struct ChppNotifier gLinkSendDoneNotifier;
+
+void waitForLinkSendDone(void) {
+  // We use a sufficiently long timeout here to avoid tests from hanging.
+  const uint64_t kTimeoutNs = 5 * CHPP_NSEC_PER_SEC;
+  uint32_t signal = chppNotifierTimedWait(&gLinkSendDoneNotifier, kTimeoutNs);
+  if (signal == 0) {
+    CHPP_LOGE("waitForLinkSendDone timed out");
+  }
 }
 
 /**
@@ -47,9 +52,6 @@ static void *linkSendThread(void *linkContext) {
   struct ChppLinuxLinkState *context =
       (struct ChppLinuxLinkState *)(linkContext);
   while (true) {
-    if (context->manualSendCycle) {
-      chppNotifierWait(&gCycleSendThreadNotifier);
-    }
     uint32_t signal = chppNotifierTimedWait(&context->notifier, CHPP_TIME_MAX);
 
     if (signal & SIGNAL_EXIT) {
@@ -62,7 +64,6 @@ static void *linkSendThread(void *linkContext) {
       chppMutexLock(&context->mutex);
 
       if (context->remoteLinkState == NULL) {
-        CHPP_LOGW("remoteLinkState is NULL");
         error = CHPP_LINK_ERROR_NONE_SENT;
 
       } else if (!context->linkEstablished) {
@@ -89,6 +90,7 @@ static void *linkSendThread(void *linkContext) {
 
       context->bufLen = 0;
       chppLinkSendDoneCb(context->transportContext, error);
+      chppNotifierSignal(&gLinkSendDoneNotifier, 1);
 
       chppMutexUnlock(&context->mutex);
     }
@@ -116,7 +118,7 @@ static void init(void *linkContext,
   chppMutexInit(&context->mutex);
   chppNotifierInit(&context->notifier);
   chppNotifierInit(&context->rxNotifier);
-  chppNotifierInit(&gCycleSendThreadNotifier);
+  chppNotifierInit(&gLinkSendDoneNotifier);
   pthread_create(&context->linkSendThread, NULL /* attr */, linkSendThread,
                  context);
   if (context->linkThreadName != NULL) {
@@ -129,14 +131,10 @@ static void deinit(void *linkContext) {
       (struct ChppLinuxLinkState *)(linkContext);
   context->bufLen = 0;
   chppNotifierSignal(&context->notifier, SIGNAL_EXIT);
-  if (context->manualSendCycle) {
-    // Unblock the send thread so it exits.
-    cycleSendThread();
-  }
   pthread_join(context->linkSendThread, NULL /* retval */);
   chppNotifierDeinit(&context->notifier);
   chppNotifierDeinit(&context->rxNotifier);
-  chppNotifierDeinit(&gCycleSendThreadNotifier);
+  chppNotifierDeinit(&gLinkSendDoneNotifier);
   chppMutexDeinit(&context->mutex);
 }
 
diff --git a/chpp/platform/linux/notifier.c b/chpp/platform/linux/notifier.c
index eac77016..5702f3ce 100644
--- a/chpp/platform/linux/notifier.c
+++ b/chpp/platform/linux/notifier.c
@@ -32,6 +32,7 @@
  ***********************************************/
 
 void chppPlatformNotifierInit(struct ChppNotifier *notifier) {
+  notifier->signal = 0;
   chppMutexInit(&notifier->mutex);
   pthread_cond_init(&notifier->cond, NULL);
 }
diff --git a/chpp/services.c b/chpp/services.c
index 0420bfe6..004028ce 100644
--- a/chpp/services.c
+++ b/chpp/services.c
@@ -102,6 +102,7 @@ void chppRegisterService(struct ChppAppState *appContext, void *serviceContext,
   serviceState->appContext = appContext;
   serviceState->outReqStates = outReqStates;
   serviceState->context = serviceContext;
+  serviceState->nextTimerTimeoutNs = CHPP_TIME_MAX;
 
   if (numServices >= CHPP_MAX_REGISTERED_SERVICES) {
     CHPP_LOGE("Max services registered: # %" PRIu8, numServices);
diff --git a/chpp/services/gnss.c b/chpp/services/gnss.c
index 57bdf246..8e21cf24 100644
--- a/chpp/services/gnss.c
+++ b/chpp/services/gnss.c
@@ -63,6 +63,9 @@ static const struct ChppService kGnssServiceConfig = {
     // Client notification dispatch function pointer
     .notificationDispatchFunctionPtr = NULL,  // Not supported
 
+    // Client timeout function pointer
+    .timeoutFunctionPtr = NULL,  // Not used
+
     // Min length is the entire header
     .minLength = sizeof(struct ChppAppHeader),
 };
diff --git a/chpp/services/wifi.c b/chpp/services/wifi.c
index 090e599d..e925f67c 100644
--- a/chpp/services/wifi.c
+++ b/chpp/services/wifi.c
@@ -64,6 +64,9 @@ static const struct ChppService kWifiServiceConfig = {
     // Client notification dispatch function pointer
     .notificationDispatchFunctionPtr = NULL,  // Not supported
 
+    // Service timeout function pointer
+    .timeoutFunctionPtr = NULL,  // Not used
+
     // Min length is the entire header
     .minLength = sizeof(struct ChppAppHeader),
 };
diff --git a/chpp/services/wwan.c b/chpp/services/wwan.c
index 7f173c82..26c77014 100644
--- a/chpp/services/wwan.c
+++ b/chpp/services/wwan.c
@@ -65,6 +65,9 @@ static const struct ChppService kWwanServiceConfig = {
     // Client notification dispatch function pointer
     .notificationDispatchFunctionPtr = NULL,  // Not supported
 
+    // Service timeout function pointer
+    .timeoutFunctionPtr = NULL,  // Not used
+
     // Min length is the entire header
     .minLength = sizeof(struct ChppAppHeader),
 };
diff --git a/chpp/test/fake_link.cpp b/chpp/test/fake_link.cpp
index 243bd874..cd3ef794 100644
--- a/chpp/test/fake_link.cpp
+++ b/chpp/test/fake_link.cpp
@@ -31,7 +31,7 @@ void FakeLink::appendTxPacket(uint8_t *data, size_t len) {
   {
     std::lock_guard<std::mutex> lock(mMutex);
     mTxPackets.emplace_back(std::move(pkt));
-    mCondVar.notify_all();
+    mTxCondVar.notify_all();
   }
 }
 
@@ -43,21 +43,25 @@ int FakeLink::getTxPacketCount() {
 bool FakeLink::waitForTxPacket(std::chrono::milliseconds timeout) {
   std::unique_lock<std::mutex> lock(mMutex);
   auto now = std::chrono::system_clock::now();
-  CHPP_LOGD("FakeLink::WaitForTxPacket waiting...");
-  while (mTxPackets.empty()) {
-    std::cv_status status = mCondVar.wait_until(lock, now + timeout);
-    if (status == std::cv_status::timeout) {
-      return false;
-    }
-  }
-  return true;
+  CHPP_LOGD("FakeLink::waitForTxPacket waiting...");
+  return mTxCondVar.wait_until(lock, now + timeout,
+                               [this] { return !mTxPackets.empty(); });
+}
+
+bool FakeLink::waitForEmpty(std::chrono::milliseconds timeout) {
+  std::unique_lock<std::mutex> lock(mMutex);
+  auto now = std::chrono::system_clock::now();
+  CHPP_LOGD("FakeLink::waitForEmpty waiting...");
+  return mRxCondVar.wait_until(lock, now + timeout,
+                               [this] { return mTxPackets.empty(); });
 }
 
 std::vector<uint8_t> FakeLink::popTxPacket() {
   std::lock_guard<std::mutex> lock(mMutex);
   assert(!mTxPackets.empty());
-  std::vector<uint8_t> vec = std::move(mTxPackets.back());
-  mTxPackets.pop_back();
+  std::vector<uint8_t> vec = std::move(mTxPackets.front());
+  mTxPackets.pop_front();
+  mRxCondVar.notify_all();
   return vec;
 }
 
diff --git a/chpp/test/fake_link.h b/chpp/test/fake_link.h
index 3a77444c..7097bafb 100644
--- a/chpp/test/fake_link.h
+++ b/chpp/test/fake_link.h
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <atomic>
 #include <chrono>
 #include <condition_variable>
 #include <cstdint>
@@ -23,6 +24,7 @@
 
 #include <android-base/thread_annotations.h>
 
+#include "chpp/log.h"
 #include "chpp/transport.h"
 
 using ::std::literals::chrono_literals::operator""ms;
@@ -62,6 +64,12 @@ class FakeLink {
    */
   bool waitForTxPacket(std::chrono::milliseconds timeout = kDefaultTimeout);
 
+  /**
+   * Similar to waitForTxPacket, but the inverse (waits until the queue is
+   * empty).
+   */
+  bool waitForEmpty(std::chrono::milliseconds timeout = kDefaultTimeout);
+
   //! Pop and return the oldest packet on the TX queue, or assert if queue is
   //! empty
   std::vector<uint8_t> popTxPacket();
@@ -69,10 +77,27 @@ class FakeLink {
   //! Empties the TX packet queue
   void reset();
 
+  bool isEnabled() const {
+    return mEnabled.load();
+  }
+
+  void disable() {
+    CHPP_LOGI("Link disabled");
+    mEnabled.store(false);
+  }
+
+  void enable() {
+    CHPP_LOGI("Link enabled");
+    mEnabled.store(true);
+  }
+
  private:
   std::mutex mMutex;
-  std::condition_variable mCondVar;
+  std::condition_variable mTxCondVar;
+  std::condition_variable mRxCondVar;
   std::deque<std::vector<uint8_t>> mTxPackets GUARDED_BY(mMutex);
+
+  std::atomic_bool mEnabled{true};
 };
 
 }  // namespace chpp::test
\ No newline at end of file
diff --git a/chpp/test/fake_link_client.cpp b/chpp/test/fake_link_client.cpp
new file mode 100644
index 00000000..f63f795d
--- /dev/null
+++ b/chpp/test/fake_link_client.cpp
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "fake_link_client.h"
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "chpp/app.h"
+#include "chpp/clients.h"
+#include "chpp/condition_variable.h"
+#include "chpp/log.h"
+#include "chpp/macros.h"
+#include "chpp/mutex.h"
+#ifdef CHPP_CLIENT_ENABLED_VENDOR
+#include "chpp/platform/vendor_clients.h"
+#endif
+
+/************************************************
+ *  Prototypes
+ ***********************************************/
+
+static bool chppTestClientInit(void *clientContext, uint8_t handle,
+                               struct ChppVersion serviceVersion);
+static void chppTestClientDeinit(void *clientContext);
+static void chppTestClientProcessTimeout(void *clientContext);
+
+/************************************************
+ *  Private Definitions
+ ***********************************************/
+
+#define CHPP_TESTCLIENT_REQUEST_MAX 0
+
+/**
+ * Structure to maintain state for the Context client and its Request/Response
+ * (RR) functionality.
+ */
+struct ChppTestClientState {
+  struct ChppEndpointState client;  // CHPP client state
+  struct ChppOutgoingRequestState outReqStates[CHPP_TESTCLIENT_REQUEST_MAX + 1];
+  bool timeoutPending;
+};
+
+// Note: This global definition of gTestClientContext supports only one
+// instance of the CHPP Context client at a time.
+struct ChppTestClientState gTestClientContext;
+struct ChppConditionVariable gTestClientTimeoutCondition;
+struct ChppMutex gTestClientTimeoutMutex;
+
+/**
+ * Test Client UUID
+ */
+#define CHPP_UUID_CLIENT_TEST                      \
+  {0x3d, 0x29, 0x78, 0x28, 0x79, 0xf0, 0x4a, 0xad, \
+   0x8f, 0x72, 0x22, 0x15, 0x2f, 0x7d, 0xcc, 0x04}
+
+/**
+ * Configuration parameters for this client
+ */
+static const struct ChppClient kTestClientConfig = {
+    .descriptor.uuid = CHPP_UUID_CLIENT_TEST,
+
+    // Version
+    .descriptor.version.major = 1,
+    .descriptor.version.minor = 0,
+    .descriptor.version.patch = 0,
+
+    // Notifies client if CHPP is reset
+    .resetNotifierFunctionPtr = NULL,
+
+    // Notifies client if they are matched to a service
+    .matchNotifierFunctionPtr = NULL,
+
+    // Service response dispatch function pointer
+    .responseDispatchFunctionPtr = NULL,
+
+    // Service notification dispatch function pointer
+    .notificationDispatchFunctionPtr = NULL,
+
+    // Service response dispatch function pointer
+    .initFunctionPtr = &chppTestClientInit,
+
+    // Service notification dispatch function pointer
+    .deinitFunctionPtr = &chppTestClientDeinit,
+
+    // Client timeout function pointer
+    .timeoutFunctionPtr = &chppTestClientProcessTimeout,
+
+    // Number of request-response states in the outReqStates array.
+    .outReqCount = ARRAY_SIZE(gTestClientContext.outReqStates),
+
+    // Min length is the entire header
+    .minLength = sizeof(struct ChppAppHeader),
+};
+
+/************************************************
+ *  Private Functions
+ ***********************************************/
+
+static bool chppTestClientInit(void *clientContext, uint8_t handle,
+                               struct ChppVersion serviceVersion) {
+  CHPP_LOGI("%s", __func__);
+  UNUSED_VAR(serviceVersion);
+
+  struct ChppTestClientState *TestClientContext =
+      (struct ChppTestClientState *)clientContext;
+  chppClientInit(&TestClientContext->client, handle);
+
+  return true;
+}
+
+/**
+ * Deinitializes the client.
+ *
+ * @param clientContext Maintains status for each client instance.
+ */
+static void chppTestClientDeinit(void *clientContext) {
+  struct ChppTestClientState *TestClientContext =
+      (struct ChppTestClientState *)clientContext;
+  chppClientDeinit(&TestClientContext->client);
+}
+
+/************************************************
+ *  Public Functions
+ ***********************************************/
+
+void chppRegisterVendorClients(struct ChppAppState *context) {
+  CHPP_DEBUG_NOT_NULL(context);
+
+  if (context->clientServiceSet.vendorClients) {
+    chppRegisterTestClient(context);
+  }
+}
+
+void chppDeregisterVendorClients(struct ChppAppState *context) {
+  CHPP_DEBUG_NOT_NULL(context);
+
+  if (context->clientServiceSet.vendorClients) {
+    chppDeregisterTestClient(context);
+  }
+}
+
+void chppRegisterTestClient(struct ChppAppState *appContext) {
+  CHPP_LOGI("%s", __func__);
+  memset(&gTestClientContext, 0, sizeof(gTestClientContext));
+  chppRegisterClient(appContext, (void *)&gTestClientContext,
+                     &gTestClientContext.client,
+                     gTestClientContext.outReqStates, &kTestClientConfig);
+
+  // Trigger a timeout to test the timeout mechanism
+  chppMutexLock(&gTestClientTimeoutMutex);
+  gTestClientContext.timeoutPending = true;
+  chppAppRequestTimerTimeout(&gTestClientContext.client,
+                             CHPP_TEST_CLIENT_TIMEOUT_MS * CHPP_NSEC_PER_MSEC);
+  chppMutexUnlock(&gTestClientTimeoutMutex);
+}
+
+void chppDeregisterTestClient(struct ChppAppState *appContext) {
+  CHPP_LOGI("%s", __func__);
+  UNUSED_VAR(appContext);
+}
+
+void chppTestClientProcessTimeout(void *clientContext) {
+  CHPP_LOGI("%s", __func__);
+  UNUSED_VAR(clientContext);
+  chppMutexLock(&gTestClientTimeoutMutex);
+  gTestClientContext.timeoutPending = false;
+  chppConditionVariableSignal(&gTestClientTimeoutCondition);
+  chppMutexUnlock(&gTestClientTimeoutMutex);
+}
+
+bool chppTestClientWaitForTimeout(uint64_t timeoutMs) {
+  bool timeoutTriggered = false;
+  chppMutexLock(&gTestClientTimeoutMutex);
+  if (gTestClientContext.timeoutPending) {
+    chppConditionVariableTimedWait(&gTestClientTimeoutCondition,
+                                   &gTestClientTimeoutMutex,
+                                   timeoutMs * CHPP_NSEC_PER_MSEC);
+  }
+  timeoutTriggered = !gTestClientContext.timeoutPending;
+  chppMutexUnlock(&gTestClientTimeoutMutex);
+  return timeoutTriggered;
+}
+
+struct ChppEndpointState *getChppTestClientState(void) {
+  return &gTestClientContext.client;
+}
diff --git a/chpp/test/fake_link_client.h b/chpp/test/fake_link_client.h
new file mode 100644
index 00000000..751c2e58
--- /dev/null
+++ b/chpp/test/fake_link_client.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHPP_FAKE_LINK_CLIENTS_H_
+#define CHPP_FAKE_LINK_CLIENTS_H_
+
+#include <stdbool.h>
+#include <stddef.h>
+
+#include "chpp/app.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// The timeout at which the test client will trigger a timeout during init.
+#define CHPP_TEST_CLIENT_TIMEOUT_MS 500
+
+/************************************************
+ *  Public functions
+ ***********************************************/
+
+/**
+ * Registers vendor specific services with the CHPP app layer.
+ * These services are enabled by CHPP_CLIENT_ENABLED_VENDOR definition.
+ * This function is automatically called by chppAppInit().
+ *
+ * @param context State of the app layer.
+ */
+void chppRegisterTestClient(struct ChppAppState *context);
+
+/**
+ * Deregisters vendor specific clients with the CHPP app layer.
+ * These services are enabled by CHPP_CLIENT_ENABLED_VENDOR definition.
+ * This function is automatically called by chppAppDeinit().
+ *
+ * @param context State of the app layer.
+ */
+void chppDeregisterTestClient(struct ChppAppState *context);
+
+/**
+ * Waits for a timeout timer to trigger.
+ *
+ * @param timeoutMs The timeout to wait for the trigger, in milliseconds.
+ * @return true if the timeout timer triggered, false otherwise.
+ */
+bool chppTestClientWaitForTimeout(uint64_t timeoutMs);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // CHPP_FAKE_LINK_CLIENTS_H_
diff --git a/chpp/test/fake_link_sync_test.cpp b/chpp/test/fake_link_sync_test.cpp
index d35152ba..1de87d11 100644
--- a/chpp/test/fake_link_sync_test.cpp
+++ b/chpp/test/fake_link_sync_test.cpp
@@ -18,17 +18,24 @@
 
 #include <string.h>
 #include <cstdint>
+#include <future>
 #include <iostream>
 #include <thread>
 #include <type_traits>
+#include <vector>
 
 #include "chpp/app.h"
-#include "chpp/crc.h"
+#include "chpp/clients/wifi.h"
+#include "chpp/common/wifi.h"
 #include "chpp/link.h"
 #include "chpp/log.h"
+#include "chpp/macros.h"
 #include "chpp/platform/platform_link.h"
 #include "chpp/transport.h"
+#include "chre/pal/wifi.h"
+#include "chre/platform/shared/pal_system_api.h"
 #include "fake_link.h"
+#include "fake_link_client.h"
 #include "packet_util.h"
 
 using chpp::test::FakeLink;
@@ -51,8 +58,15 @@ static void deinit(void *linkContext) {
 static enum ChppLinkErrorCode send(void *linkContext, size_t len) {
   auto context = static_cast<struct ChppTestLinkState *>(linkContext);
   auto *fake = reinterpret_cast<FakeLink *>(context->fake);
+  // At the test layer, we expect things to be serialized such that
+  // packets are fetched before the next one can be sent.
+  if (!fake->waitForEmpty()) {
+    CHPP_LOGW("Timed out waiting for TX queue to become empty");
+  }
   fake->appendTxPacket(&context->txBuffer[0], len);
-  return CHPP_LINK_ERROR_NONE_SENT;
+
+  return fake->isEnabled() ? CHPP_LINK_ERROR_NONE_SENT
+                           : CHPP_LINK_ERROR_UNSPECIFIED;
 }
 
 static void doWork(void * /*linkContext*/, uint32_t /*signal*/) {}
@@ -88,15 +102,36 @@ namespace chpp::test {
 class FakeLinkSyncTests : public testing::Test {
  protected:
   void SetUp() override {
+    pthread_setname_np(pthread_self(), "test");
     memset(&mLinkContext, 0, sizeof(mLinkContext));
     chppTransportInit(&mTransportContext, &mAppContext, &mLinkContext,
                       &gLinkApi);
-    chppAppInitWithClientServiceSet(&mAppContext, &mTransportContext,
-                                    /*clientServiceSet=*/{});
+    initChppAppLayer();
     mFakeLink = reinterpret_cast<FakeLink *>(mLinkContext.fake);
 
-    mWorkThread = std::thread(chppWorkThreadStart, &mTransportContext);
+    // Note that while the tests tend to primarily execute in the main thread,
+    // some behaviors rely on the work thread, which can create some flakiness,
+    // e.g. if the thread doesn't get scheduled within the timeout. It would be
+    // possible to "pause" the work thread by sending a link signal that blocks
+    // indefinitely, so we can execute any pending operations synchronously in
+    // waitForTxPacket(), but it would be best to combine this approach with
+    // simulated timestamps/delays so we can guarantee no unexpected timeouts
+    // and so we can force timeout behavior without having to delay test
+    // execution (as seen in CHRE's TransactionManagerTest).
+    mWorkThread = std::thread([this] {
+      pthread_setname_np(pthread_self(), "worker");
+      chppWorkThreadStart(&mTransportContext);
+    });
+    performHandshake();
+  }
+
+  virtual void initChppAppLayer() {
+    chppAppInitWithClientServiceSet(&mAppContext, &mTransportContext,
+                                    /*clientServiceSet=*/{});
+    mAppContext.isDiscoveryComplete = true;  // Skip discovery
+  }
 
+  void performHandshake() {
     // Proceed to the initialized state by performing the CHPP 3-way handshake
     CHPP_LOGI("Send a RESET packet");
     ASSERT_TRUE(mFakeLink->waitForTxPacket());
@@ -109,7 +144,13 @@ class FakeLinkSyncTests : public testing::Test {
     chppRxDataCb(&mTransportContext, reinterpret_cast<uint8_t *>(&resetAck),
                  sizeof(resetAck));
 
-    // chppProcessResetAck() results in sending a no error packet.
+    // Handling of the ACK to RESET-ACK depends on configuration
+    handleFirstPacket();
+  }
+
+  virtual void handleFirstPacket() {
+    // chppProcessResetAck() results in sending a no error packet, with no
+    // payload when discovery is disabled
     CHPP_LOGI("Send CHPP_TRANSPORT_ERROR_NONE packet");
     ASSERT_TRUE(mFakeLink->waitForTxPacket());
     std::vector<uint8_t> ackPkt = mFakeLink->popTxPacket();
@@ -118,6 +159,41 @@ class FakeLinkSyncTests : public testing::Test {
     CHPP_LOGI("CHPP handshake complete");
   }
 
+  void discardTxPacket() {
+    ASSERT_TRUE(mFakeLink->waitForTxPacket());
+    EXPECT_EQ(mFakeLink->getTxPacketCount(), 1);
+    (void)mFakeLink->popTxPacket();
+  }
+
+  std::vector<uint8_t> getNextPacket() {
+    if (!mFakeLink->waitForTxPacket()) {
+      CHPP_LOGE("Didn't get expected packet");
+      return std::vector<uint8_t>();
+    }
+    EXPECT_EQ(mFakeLink->getTxPacketCount(), 1);
+    return mFakeLink->popTxPacket();
+  }
+
+  bool compareNextPacket(const ChppEmptyPacket &expected) {
+    return comparePacket(getNextPacket(), expected);
+  }
+
+  bool compareNextPacket(const ChppResetPacket &expected) {
+    return comparePacket(getNextPacket(), expected);
+  }
+
+  template <typename PacketType>
+  bool deliverRxPacket(const PacketType &packet) {
+    CHPP_LOGW("Debug dump of RX packet:");
+    std::vector<uint8_t> vec;
+    vec.resize(sizeof(packet));
+    memcpy(vec.data(), &packet, sizeof(packet));
+    std::cout << asChpp(vec);
+    return chppRxDataCb(&mTransportContext,
+                        reinterpret_cast<const uint8_t *>(&packet),
+                        sizeof(packet));
+  }
+
   void TearDown() override {
     chppWorkThreadStop(&mTransportContext);
     mWorkThread.join();
@@ -139,6 +215,98 @@ class FakeLinkSyncTests : public testing::Test {
   std::thread mWorkThread;
 };
 
+class FakeLinkWithClientSyncTests : public FakeLinkSyncTests {
+ public:
+  void initChppAppLayer() override {
+    // We use the WiFi client to simulate real-world integrations, but any
+    // service (including a dedicated test client/service) would work
+    ChppClientServiceSet set = {
+        .wifiClient = 1,
+    };
+    chppAppInitWithClientServiceSet(&mAppContext, &mTransportContext, set);
+    mAppContext.isDiscoveryComplete = true;  // Bypass initial discovery
+  }
+
+  virtual void handleFirstPacket() override {
+    ASSERT_TRUE(mFakeLink->waitForTxPacket());
+    std::vector<uint8_t> ackPkt = mFakeLink->popTxPacket();
+    ASSERT_TRUE(comparePacket(ackPkt, generateEmptyPacket()))
+        << "Full packet: " << asChpp(ackPkt);
+    CHPP_LOGI("CHPP handshake complete");
+
+    mAppContext.matchedClientCount = mAppContext.discoveredServiceCount = 1;
+    // Initialize the client similar to how discovery would
+    EXPECT_TRUE(mAppContext.registeredClients[0]->initFunctionPtr(
+        mAppContext.registeredClientStates[0]->context,
+        CHPP_SERVICE_HANDLE_OF_INDEX(0), /*version=*/{1, 0, 0}));
+  }
+
+  void sendOpenResp(const ChppPacketWithAppHeader &openReq) {
+    ChppAppHeader appHdr = {
+        .handle = openReq.appHeader.handle,
+        .type = CHPP_MESSAGE_TYPE_SERVICE_RESPONSE,
+        .transaction = openReq.appHeader.transaction,
+        .error = CHPP_APP_ERROR_NONE,
+        .command = openReq.appHeader.command,
+    };
+    std::span<uint8_t, sizeof(appHdr)> payload(
+        reinterpret_cast<uint8_t *>(&appHdr), sizeof(appHdr));
+    auto rsp = generatePacketWithPayload<sizeof(appHdr)>(
+        openReq.transportHeader.seq + 1, openReq.transportHeader.ackSeq,
+        &payload);
+    deliverRxPacket(rsp);
+  }
+
+  void openWifiPal(const struct chrePalWifiApi *api,
+                   const struct chrePalWifiCallbacks *callbacks = nullptr) {
+    ASSERT_NE(api, nullptr);
+
+    // Calling open() blocks until the open response is received, so spin off
+    // another thread to wait on the open request and post the response.
+    // This puts us in the opened state - we are mainly interested in testing
+    auto result = std::async(std::launch::async, [this] {
+      if (mFakeLink->waitForTxPacket()) {
+        std::vector<uint8_t> rawPkt = mFakeLink->popTxPacket();
+        const ChppPacketWithAppHeader &pkt = asApp(rawPkt);
+        ASSERT_EQ(pkt.appHeader.command, CHPP_WIFI_OPEN);
+        sendOpenResp(pkt);
+      }
+    });
+    ASSERT_TRUE(api->open(&chre::gChrePalSystemApi, callbacks));
+
+    // Confirm our open response was ACKed
+    ASSERT_TRUE(comparePacket(getNextPacket(), generateEmptyPacket(2)));
+  }
+
+  void waitForReopenRequest() {
+    // Confirm we get OPEN request, send OPEN response
+    ASSERT_TRUE(mFakeLink->waitForTxPacket());
+    auto rawPkt = getNextPacket();
+    const ChppPacketWithAppHeader &pkt = asApp(rawPkt);
+    ASSERT_EQ(pkt.appHeader.command, CHPP_WIFI_OPEN);
+    sendOpenResp(pkt);
+
+    // Confirm we got an ACK to our OPEN_RESP
+    ASSERT_TRUE(mFakeLink->waitForTxPacket());
+    rawPkt = getNextPacket();
+    EXPECT_TRUE(comparePacket(rawPkt, generateEmptyPacket(2)))
+        << "Full packet: " << asChpp(rawPkt);
+  }
+
+  void waitForWifiClientOpenState(uint8_t openState) {
+    ChppEndpointState *wifiClientState = mAppContext.registeredClientStates[0];
+    ASSERT_NE(wifiClientState, nullptr);
+    chppMutexLock(&wifiClientState->syncResponse.mutex);
+    while (!wifiClientState->syncResponse.ready) {
+      chppConditionVariableTimedWait(&wifiClientState->syncResponse.condVar,
+                                     &wifiClientState->syncResponse.mutex,
+                                     CHPP_REQUEST_TIMEOUT_DEFAULT);
+    }
+    chppMutexUnlock(&wifiClientState->syncResponse.mutex);
+    ASSERT_EQ(wifiClientState->openState, openState);
+  }
+};
+
 TEST_F(FakeLinkSyncTests, CheckRetryOnTimeout) {
   txPacket();
   ASSERT_TRUE(mFakeLink->waitForTxPacket());
@@ -191,15 +359,48 @@ TEST_F(FakeLinkSyncTests, MultipleNotifications) {
   EXPECT_FALSE(mFakeLink->waitForTxPacket());
 }
 
+// This test validates that the CHPP transport maintains 1 un-ACKed packet when
+// multiple packets are pending in the queue
+TEST_F(FakeLinkSyncTests, OutboundThrottling) {
+  txPacket();
+  ASSERT_TRUE(mFakeLink->waitForTxPacket());
+  EXPECT_EQ(mFakeLink->getTxPacketCount(), 1);
+
+  // Enqueuing more packets should not trigger sending again
+  txPacket();
+  txPacket();
+  EXPECT_EQ(mFakeLink->getTxPacketCount(), 1);
+
+  // Delivering an ACK should unblock the second packet
+  ChppEmptyPacket ack = generateAck(mFakeLink->popTxPacket());
+  deliverRxPacket(ack);
+  ASSERT_TRUE(mFakeLink->waitForTxPacket());
+  EXPECT_EQ(mFakeLink->getTxPacketCount(), 1);
+  std::vector<uint8_t> pkt2 = mFakeLink->popTxPacket();
+  EXPECT_EQ(asChpp(pkt2).header.seq, 2);
+
+  // Receiving a duplicate ACK should not result in sending again
+  deliverRxPacket(ack);
+  EXPECT_EQ(mFakeLink->getTxPacketCount(), 0);
+
+  // Now send the final ACKs
+  deliverRxPacket(generateAck(pkt2));
+  ASSERT_TRUE(mFakeLink->waitForTxPacket());
+  EXPECT_EQ(mFakeLink->getTxPacketCount(), 1);
+  std::vector<uint8_t> pkt3 = mFakeLink->popTxPacket();
+  deliverRxPacket(generateAck(pkt3));
+
+  EXPECT_EQ(asChpp(pkt3).header.seq, 3);
+  EXPECT_FALSE(mFakeLink->waitForTxPacket());
+}
+
 // This test is essentially CheckRetryOnTimeout but with a twist: we send a
 // packet, then don't send an ACK in the expected time so it gets retried, then
 // after the retry, we send two equivalent ACKs back-to-back
 TEST_F(FakeLinkSyncTests, DelayedThenDupeAck) {
-  // Post the TX packet
+  // Post the TX packet, discard the first ACK
   txPacket();
-  ASSERT_TRUE(mFakeLink->waitForTxPacket());
-  ASSERT_EQ(mFakeLink->getTxPacketCount(), 1);
-  (void)mFakeLink->popTxPacket();  // discard the first packet
+  discardTxPacket();
 
   // Second wait should yield timeout + retry
   ASSERT_TRUE(mFakeLink->waitForTxPacket());
@@ -266,4 +467,117 @@ TEST_F(FakeLinkSyncTests, ResendAckOnDupe) {
       << "Expected ACK for seq 2 but got: " << asEmptyPacket(pkt);
 }
 
+TEST_F(FakeLinkWithClientSyncTests, RecoverFromAbortedOpen) {
+  // Setting all callbacks as null here since none should be invoked
+  const struct chrePalWifiCallbacks kCallbacks = {};
+  const struct chrePalWifiApi *api =
+      chppPalWifiGetApi(CHPP_PAL_WIFI_API_VERSION);
+  ASSERT_NO_FATAL_FAILURE(openWifiPal(api, &kCallbacks));
+
+  // Now we're in the opened state and can trigger the test condition: feed in a
+  // RESET, discard the RESET_ACK, confirm we got OPEN_REQ, but instead of
+  // OPEN_RESP, send another RESET, then confirm we can open successfully
+  CHPP_LOGI("Triggering RESET after successful open");
+  auto resetPkt = generateResetPacket();
+  deliverRxPacket(resetPkt);
+  auto rawPkt = getNextPacket();
+  ASSERT_TRUE(comparePacket(rawPkt, generateResetAckPacket()));
+  // It shouldn't send anything until we ack RESET-ACK, which we aren't going to
+  // do here
+  ASSERT_EQ(mFakeLink->getTxPacketCount(), 0);
+
+  CHPP_LOGI("Triggering abort of open request via another RESET");
+  deliverRxPacket(resetPkt);
+  rawPkt = getNextPacket();
+  ASSERT_TRUE(comparePacket(rawPkt, generateResetAckPacket()));
+  auto ackForResetAck = generateEmptyPacket();
+  deliverRxPacket(ackForResetAck);
+
+  ASSERT_NO_FATAL_FAILURE(waitForReopenRequest());
+}
+
+// This test is similar to RecoverFromAbortedOpen, but the link is disabled
+// while a RESET is triggered from the remote endpoint.
+TEST_F(FakeLinkWithClientSyncTests, ReopenFromBrokenLink) {
+  // Setting all callbacks as null here since none should be invoked
+  const struct chrePalWifiCallbacks kCallbacks = {};
+  const struct chrePalWifiApi *api =
+      chppPalWifiGetApi(CHPP_PAL_WIFI_API_VERSION);
+  ASSERT_NO_FATAL_FAILURE(openWifiPal(api, &kCallbacks));
+  ASSERT_NO_FATAL_FAILURE(waitForWifiClientOpenState(CHPP_OPEN_STATE_OPENED));
+
+  // Disable the link and trigger a RESET from the remote endpoint. This will
+  // cause the local client to attempt a re-open of the WiFi API. But since the
+  // local link is disabled, the transport will enter a "PERMANENT_FAILURE"
+  // state, and the re-open will time out.
+  mFakeLink->disable();
+
+  CHPP_LOGI("Triggering RESET after successful open");
+  auto resetPkt = generateResetPacket();
+  deliverRxPacket(resetPkt);
+  for (uint32_t i = 0; i < CHPP_TRANSPORT_MAX_RETX + 1; i++) {
+    ASSERT_TRUE(compareNextPacket(generateResetAckPacket()));
+  }
+
+  CHPP_LOGI("Expecting RESET from local transport");
+  for (uint32_t i = 0; i < CHPP_TRANSPORT_MAX_RESET; i++) {
+    uint8_t error = (i == 0) ? CHPP_TRANSPORT_ERROR_MAX_RETRIES
+                             : CHPP_TRANSPORT_ERROR_TIMEOUT;
+    ASSERT_TRUE(compareNextPacket(generateResetPacket(1, 0, error)));
+
+    // TODO(b/392728565): Fix inconsistent counting of retx in transport code
+    for (uint32_t j = 0; j < CHPP_TRANSPORT_MAX_RETX + 1; j++) {
+      ASSERT_TRUE(compareNextPacket(
+          generateResetPacket(1, 0, CHPP_TRANSPORT_ERROR_NONE)));
+    }
+  }
+
+  ASSERT_NO_FATAL_FAILURE(waitForWifiClientOpenState(CHPP_OPEN_STATE_CLOSED));
+
+  // We then re-enable the link and attempt a new request from the Wifi API.
+  // This request will fail, but triggers a re-open that now should succeed.
+  mFakeLink->enable();
+
+  CHPP_LOGI("Triggering a new request after re-open failure");
+  ASSERT_FALSE(api->configureScanMonitor(true));
+  ASSERT_TRUE(compareNextPacket(
+      generateResetPacket(1, 0, CHPP_TRANSPORT_SIGNAL_FORCE_RESET)));
+  auto ackForReset = generateResetAckPacket();
+  deliverRxPacket(ackForReset);
+
+  ASSERT_NO_FATAL_FAILURE(waitForReopenRequest());
+}
+
+class FakeLinkWithTestClientSyncTests : public FakeLinkSyncTests {
+ public:
+  void initChppAppLayer() override {
+    // We use a vendor client which triggers a client-layer timeout during init.
+    // This is used to test the timeout mechanism.
+    ChppClientServiceSet set = {
+        .vendorClients = 1,
+    };
+    chppAppInitWithClientServiceSet(&mAppContext, &mTransportContext, set);
+    mAppContext.isDiscoveryComplete = true;  // Bypass initial discovery
+  }
+
+  virtual void handleFirstPacket() override {
+    ASSERT_TRUE(mFakeLink->waitForTxPacket());
+    std::vector<uint8_t> ackPkt = mFakeLink->popTxPacket();
+    ASSERT_TRUE(comparePacket(ackPkt, generateEmptyPacket()))
+        << "Full packet: " << asChpp(ackPkt);
+    CHPP_LOGI("CHPP handshake complete");
+
+    mAppContext.matchedClientCount = mAppContext.discoveredServiceCount = 1;
+    // Initialize the client similar to how discovery would
+    EXPECT_TRUE(mAppContext.registeredClients[0]->initFunctionPtr(
+        mAppContext.registeredClientStates[0]->context,
+        CHPP_SERVICE_HANDLE_OF_INDEX(0), /*version=*/{1, 0, 0}));
+  }
+};
+
+TEST_F(FakeLinkWithTestClientSyncTests, SampleTimeoutTest) {
+  EXPECT_TRUE(chppTestClientWaitForTimeout(
+      /* timeoutMs=*/CHPP_MSEC_PER_SEC));
+}
+
 }  // namespace chpp::test
diff --git a/chpp/test/include/fake_link/chpp/platform/vendor_clients.h b/chpp/test/include/fake_link/chpp/platform/vendor_clients.h
new file mode 100644
index 00000000..b5c3aa7e
--- /dev/null
+++ b/chpp/test/include/fake_link/chpp/platform/vendor_clients.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHPP_VENDOR_CLIENTS_H_
+#define CHPP_VENDOR_CLIENTS_H_
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#include "chpp/app.h"
+#include "chpp/macros.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/************************************************
+ *  Public functions
+ ***********************************************/
+
+/**
+ * Registers vendor specific services with the CHPP app layer.
+ * These services are enabled by CHPP_CLIENT_ENABLED_VENDOR definition.
+ * This function is automatically called by chppAppInit().
+ *
+ * @param context State of the app layer.
+ */
+void chppRegisterVendorClients(struct ChppAppState *context);
+
+/**
+ * Deregisters vendor specific clients with the CHPP app layer.
+ * These services are enabled by CHPP_CLIENT_ENABLED_VENDOR definition.
+ * This function is automatically called by chppAppDeinit().
+ *
+ * @param context State of the app layer.
+ */
+void chppDeregisterVendorClients(struct ChppAppState *context);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // CHPP_VENDOR_CLIENTS_H_
\ No newline at end of file
diff --git a/chpp/test/packet_util.cpp b/chpp/test/packet_util.cpp
index 36172272..ebe508a8 100644
--- a/chpp/test/packet_util.cpp
+++ b/chpp/test/packet_util.cpp
@@ -44,7 +44,8 @@ ChppEmptyPacket generateEmptyPacket(uint8_t ackSeq, uint8_t seq,
   return pkt;
 }
 
-ChppResetPacket generateResetPacket(uint8_t ackSeq, uint8_t seq) {
+ChppResetPacket generateResetPacket(uint8_t ackSeq, uint8_t seq,
+                                    uint8_t error) {
   // clang-format off
   ChppResetPacket pkt = {
     .preamble = kPreamble,
@@ -52,7 +53,7 @@ ChppResetPacket generateResetPacket(uint8_t ackSeq, uint8_t seq) {
       .flags = CHPP_TRANSPORT_FLAG_FINISHED_DATAGRAM,
       .packetCode = static_cast<uint8_t>(CHPP_ATTR_AND_ERROR_TO_PACKET_CODE(
           CHPP_TRANSPORT_ATTR_RESET,
-          CHPP_TRANSPORT_ERROR_NONE
+          error
       )),
       .ackSeq = ackSeq,
       .seq = seq,
@@ -373,7 +374,7 @@ void checkPacketValidity(std::vector<uint8_t> &received) {
   EXPECT_EQ(pkt.header.reserved, 0);
 
   uint8_t error = CHPP_TRANSPORT_GET_ERROR(pkt.header.packetCode);
-  EXPECT_TRUE(error <= CHPP_TRANSPORT_ERROR_MAX_RETRIES ||
+  EXPECT_TRUE(error <= CHPP_TRANSPORT_SIGNAL_FORCE_RESET ||
               error == CHPP_TRANSPORT_ERROR_APPLAYER);
   uint8_t attrs = CHPP_TRANSPORT_GET_ATTR(pkt.header.packetCode);
   EXPECT_TRUE(attrs <= CHPP_TRANSPORT_ATTR_LOOPBACK_RESPONSE);
diff --git a/chpp/test/packet_util.h b/chpp/test/packet_util.h
index 42bcedad..699ac884 100644
--- a/chpp/test/packet_util.h
+++ b/chpp/test/packet_util.h
@@ -79,7 +79,8 @@ uint32_t computeCrc(const PktType &pkt) {
                    sizeof(pkt) - sizeof(pkt.preamble) - sizeof(pkt.footer));
 }
 
-ChppResetPacket generateResetPacket(uint8_t ackSeq = 0, uint8_t seq = 0);
+ChppResetPacket generateResetPacket(uint8_t ackSeq = 0, uint8_t seq = 0,
+                                    uint8_t error = CHPP_TRANSPORT_ERROR_NONE);
 ChppResetPacket generateResetAckPacket(uint8_t ackSeq = 1, uint8_t seq = 0);
 ChppEmptyPacket generateEmptyPacket(uint8_t ackSeq = 1, uint8_t seq = 0,
                                     uint8_t error = CHPP_TRANSPORT_ERROR_NONE);
diff --git a/chpp/test/transport_test.cpp b/chpp/test/transport_test.cpp
index 14c4776c..8d863f5c 100644
--- a/chpp/test/transport_test.cpp
+++ b/chpp/test/transport_test.cpp
@@ -72,7 +72,6 @@ class TransportTests : public testing::TestWithParam<int> {
   void SetUp() override {
     chppClearTotalAllocBytes();
     memset(&gChppLinuxLinkContext, 0, sizeof(struct ChppLinuxLinkState));
-    gChppLinuxLinkContext.manualSendCycle = true;
     gChppLinuxLinkContext.linkEstablished = true;
     gChppLinuxLinkContext.isLinkActive = true;
     const struct ChppLinkApi *linkApi = getLinuxLinkApi();
@@ -143,9 +142,8 @@ TEST_P(TransportTests, RxPayloadOfZeros) {
   size_t len = static_cast<size_t>(GetParam());
   bool isLenValid = (len <= chppTransportRxMtuSize(&mTransportContext));
 
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   if (len <= kMaxChunkSize) {
     size_t loc = 0;
@@ -212,7 +210,7 @@ TEST_P(TransportTests, RxPayloadOfZeros) {
                 CHPP_TRANSPORT_ERROR_NONE);
       EXPECT_EQ(mTransportContext.txDatagramQueue.pending, 0);
 
-      WaitForTransport(&mTransportContext);
+      waitForLinkSendDone();
 
       // Check response packet fields
       struct ChppTransportHeader *txHeader =
@@ -249,9 +247,8 @@ TEST_F(TransportTests, LinkSendDonePreamble) {
   size_t partLenPreamble = CHPP_PREAMBLE_LEN_BYTES - 1;
 
   mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   size_t loc = 0;
   addPreambleToBuf(mBuf, &loc);
@@ -277,9 +274,8 @@ TEST_F(TransportTests, LinkSendDoneHeader) {
       CHPP_PREAMBLE_LEN_BYTES + sizeof(ChppTransportHeader) - 1;
 
   mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   size_t loc = 0;
   addPreambleToBuf(mBuf, &loc);
@@ -305,9 +301,8 @@ TEST_F(TransportTests, LinkSendDonePayload) {
   size_t partLenPayload = 500;
 
   mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   size_t loc = 0;
   addPreambleToBuf(mBuf, &loc);
@@ -338,9 +333,8 @@ TEST_F(TransportTests, LinkSendDoneFooter) {
                          payloadLen + sizeof(ChppTransportFooter) - 1;
 
   mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   size_t loc = 0;
   addPreambleToBuf(mBuf, &loc);
@@ -415,9 +409,8 @@ TEST_P(TransportTests, LoopbackPayloadOfZeros) {
   mTransportContext.rxStatus.state = CHPP_STATE_PREAMBLE;
   size_t len = static_cast<size_t>(GetParam());
 
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
   chppWorkThreadStop(&mTransportContext);
   t1.join();
 
@@ -447,9 +440,8 @@ TEST_P(TransportTests, DiscoveryAndTransactionID) {
   uint8_t transactionID = static_cast<uint8_t>(GetParam());
   size_t len = 0;
 
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
   chppWorkThreadStop(&mTransportContext);
   t1.join();
 
@@ -579,9 +571,8 @@ TEST_F(TransportTests, CRC32DaisyChained) {
  * WWAN service Open and GetCapabilities.
  */
 TEST_F(TransportTests, WwanOpen) {
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   uint8_t ackSeq = 1;
   uint8_t seq = 0;
@@ -622,9 +613,8 @@ TEST_F(TransportTests, WwanOpen) {
  * WiFi service Open and GetCapabilities.
  */
 TEST_F(TransportTests, WifiOpen) {
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   uint8_t ackSeq = 1;
   uint8_t seq = 0;
@@ -666,9 +656,8 @@ TEST_F(TransportTests, WifiOpen) {
  * GNSS service Open and GetCapabilities.
  */
 TEST_F(TransportTests, GnssOpen) {
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   uint8_t ackSeq = 1;
   uint8_t seq = 0;
@@ -713,9 +702,8 @@ TEST_F(TransportTests, GnssOpen) {
 TEST_F(TransportTests, Discovery) {
   size_t len = 0;
 
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   addPreambleToBuf(mBuf, &len);
 
@@ -770,9 +758,8 @@ TEST_F(TransportTests, UnopenedClient) {
   size_t len = 0;
   uint8_t *buf = (uint8_t *)chppMalloc(100);
 
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
   chppWorkThreadStop(&mTransportContext);
   t1.join();
 
@@ -791,9 +778,8 @@ TEST_F(TransportTests, UnopenedClient) {
 }
 
 TEST_F(TransportTests, DiscardedPacketTest) {
-  mTransportContext.txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, &mTransportContext);
-  WaitForTransport(&mTransportContext);
+  waitForLinkSendDone();
 
   // Send packet to RX thread after manually setting to resetting state.
   // We expect this packet to get dropped, but this test checks for any
@@ -845,9 +831,8 @@ void messageToInvalidHandle(ChppTransportState *transportContext,
   size_t len = 0;
   uint8_t *buf = (uint8_t *)chppMalloc(100);
 
-  transportContext->txStatus.hasPacketsToSend = true;
   std::thread t1(chppWorkThreadStart, transportContext);
-  WaitForTransport(transportContext);
+  waitForLinkSendDone();
   chppWorkThreadStop(transportContext);
   t1.join();
 
diff --git a/chpp/test/transport_util.cpp b/chpp/test/transport_util.cpp
index ffa033a0..9c89d986 100644
--- a/chpp/test/transport_util.cpp
+++ b/chpp/test/transport_util.cpp
@@ -34,6 +34,7 @@
 #include "chpp/common/wifi_types.h"
 #include "chpp/common/wwan.h"
 #include "chpp/crc.h"
+#include "chpp/log.h"
 #include "chpp/macros.h"
 #include "chpp/memory.h"
 #include "chpp/platform/platform_link.h"
@@ -45,21 +46,6 @@
 
 namespace chpp::test {
 
-/**
- * Wait for chppTransportDoWork() to finish after it is notified by
- * chppEnqueueTxPacket to run.
- */
-void WaitForTransport(struct ChppTransportState *transportContext) {
-  // Start sending data out.
-  cycleSendThread();
-  // Wait for data to be received and processed.
-  std::this_thread::sleep_for(std::chrono::milliseconds(50));
-
-  // Should have reset loc and length for next packet / datagram
-  EXPECT_EQ(transportContext->rxStatus.locInDatagram, 0);
-  EXPECT_EQ(transportContext->rxDatagram.length, 0);
-}
-
 /**
  * Validates a ChppTestResponse. Since the error field within the
  * ChppAppHeader struct is optional (and not used for common services), this
@@ -76,23 +62,23 @@ void WaitForTransport(struct ChppTransportState *transportContext) {
  */
 uint8_t validateChppTestResponse(void *buf, uint8_t ackSeq, uint8_t handle,
                                  uint8_t transactionID) {
-  struct ChppTestResponse *response = (ChppTestResponse *)buf;
+  struct ChppTestResponse response = *(ChppTestResponse *)buf;
 
   // Check preamble
-  EXPECT_EQ(response->preamble0, kChppPreamble0);
-  EXPECT_EQ(response->preamble1, kChppPreamble1);
+  EXPECT_EQ(response.preamble0, kChppPreamble0);
+  EXPECT_EQ(response.preamble1, kChppPreamble1);
 
   // Check response transport headers
-  EXPECT_EQ(response->transportHeader.packetCode, CHPP_TRANSPORT_ERROR_NONE);
-  EXPECT_EQ(response->transportHeader.ackSeq, ackSeq);
+  EXPECT_EQ(response.transportHeader.packetCode, CHPP_TRANSPORT_ERROR_NONE);
+  EXPECT_EQ(response.transportHeader.ackSeq, ackSeq);
 
   // Check response app headers
-  EXPECT_EQ(response->appHeader.handle, handle);
-  EXPECT_EQ(response->appHeader.type, CHPP_MESSAGE_TYPE_SERVICE_RESPONSE);
-  EXPECT_EQ(response->appHeader.transaction, transactionID);
+  EXPECT_EQ(response.appHeader.handle, handle);
+  EXPECT_EQ(response.appHeader.type, CHPP_MESSAGE_TYPE_SERVICE_RESPONSE);
+  EXPECT_EQ(response.appHeader.transaction, transactionID);
 
   // Return optional response error to be checked if desired
-  return response->appHeader.error;
+  return response.appHeader.error;
 }
 
 /**
@@ -234,7 +220,7 @@ void openService(ChppTransportState *transportContext, uint8_t *buf,
   EXPECT_EQ(transportContext->rxStatus.state, CHPP_STATE_PREAMBLE);
 
   // Wait for response
-  WaitForTransport(transportContext);
+  waitForLinkSendDone();
 
   // Validate common response fields
   EXPECT_EQ(validateChppTestResponse(chppLinuxLinkContext.buf, nextSeq, handle,
@@ -288,7 +274,7 @@ void sendCommandToService(ChppTransportState *transportContext, uint8_t *buf,
   EXPECT_EQ(transportContext->rxStatus.state, CHPP_STATE_PREAMBLE);
 
   // Wait for response
-  WaitForTransport(transportContext);
+  waitForLinkSendDone();
 
   // Validate common response fields
   EXPECT_EQ(validateChppTestResponse(chppLinuxLinkContext.buf, nextSeq, handle,
diff --git a/chpp/test/transport_util.h b/chpp/test/transport_util.h
index 17ebd069..f59c027a 100644
--- a/chpp/test/transport_util.h
+++ b/chpp/test/transport_util.h
@@ -57,12 +57,6 @@ constexpr uint8_t kChppPreamble1 = 0x43;
  *  Helper functions available for other tests
  ***********************************************/
 
-/**
- * Wait for chppTransportDoWork() to finish after it is notified by
- * chppEnqueueTxPacket to run.
- */
-void WaitForTransport(struct ChppTransportState *transportContext);
-
 /**
  * Validates a ChppTestResponse. Since the error field within the
  * ChppAppHeader struct is optional (and not used for common services), this
diff --git a/chpp/transport.c b/chpp/transport.c
index 5ba5751a..ffab94aa 100644
--- a/chpp/transport.c
+++ b/chpp/transport.c
@@ -65,10 +65,15 @@ static void chppClearRxDatagram(struct ChppTransportState *context);
 static bool chppRxChecksumIsOk(const struct ChppTransportState *context);
 static enum ChppTransportErrorCode chppRxHeaderCheck(
     const struct ChppTransportState *context);
-static void chppRegisterRxAck(struct ChppTransportState *context);
+static bool chppRegisterRxAck(struct ChppTransportState *context);
 
 static void chppEnqueueTxPacket(struct ChppTransportState *context,
                                 uint8_t packetCode);
+static bool chppHavePendingTxPayload(const struct ChppTransportState *context);
+static bool chppShouldAttachPayload(const struct ChppTransportState *context,
+                                    bool resendPayload);
+static bool chppShouldSendPossiblyEmptyPacket(
+    const struct ChppTransportState *context);
 static size_t chppAddPreamble(uint8_t *buf);
 static struct ChppTransportHeader *chppAddHeader(
     struct ChppTransportState *context);
@@ -77,12 +82,14 @@ static void chppAddFooter(struct ChppTransportState *context);
 // Can not be static (used in tests).
 size_t chppDequeueTxDatagram(struct ChppTransportState *context);
 static void chppClearTxDatagramQueue(struct ChppTransportState *context);
-static void chppTransportDoWork(struct ChppTransportState *context);
+static void chppTransportDoWork(struct ChppTransportState *context,
+                                bool resendPayload);
 static void chppAppendToPendingTxPacket(struct ChppTransportState *context,
                                         const uint8_t *buf, size_t len);
 static const char *chppGetPacketAttrStr(uint8_t packetCode);
-static bool chppEnqueueTxDatagram(struct ChppTransportState *context,
-                                  uint8_t packetCode, void *buf, size_t len);
+static bool chppEnqueueTxDatagramLocked(struct ChppTransportState *context,
+                                        uint8_t packetCode, void *buf,
+                                        size_t len);
 static enum ChppLinkErrorCode chppSendPendingPacket(
     struct ChppTransportState *context);
 
@@ -95,6 +102,8 @@ struct ChppAppHeader *chppTransportGetRequestTimeoutResponse(
 static const char *chppGetRxStatusLabel(enum ChppRxState state);
 static void chppWorkHandleTimeout(struct ChppTransportState *context);
 
+void chppCheckRxPacketTimeout(struct ChppTransportState *context, uint64_t now);
+
 /************************************************
  *  Private Functions
  ***********************************************/
@@ -590,7 +599,7 @@ static void chppProcessRxPacket(struct ChppTransportState *context) {
   uint64_t now = chppGetCurrentTimeNs();
   context->rxStatus.lastGoodPacketTimeMs = (uint32_t)(now / CHPP_NSEC_PER_MSEC);
   context->rxStatus.receivedPacketCode = context->rxHeader.packetCode;
-  chppRegisterRxAck(context);
+  bool gotExpectedAck = chppRegisterRxAck(context);
 
   enum ChppTransportErrorCode errorCode = CHPP_TRANSPORT_ERROR_NONE;
   if (context->rxHeader.length > 0 &&
@@ -599,9 +608,9 @@ static void chppProcessRxPacket(struct ChppTransportState *context) {
     errorCode = CHPP_TRANSPORT_ERROR_ORDER;
   }
 
-  if (context->txDatagramQueue.pending > 0 ||
+  if ((gotExpectedAck && chppHavePendingTxPayload(context)) ||
       errorCode == CHPP_TRANSPORT_ERROR_ORDER) {
-    // There are packets to send out (could be new or retx)
+    // A pending packet was ACKed, or we need to send a NAK or duplicate ACK.
     // Note: For a future ACK window > 1, makes more sense to cap the NACKs
     // to one instead of flooding with out of order NACK errors.
 
@@ -610,7 +619,11 @@ static void chppProcessRxPacket(struct ChppTransportState *context) {
     enum ChppTransportErrorCode errorCodeToSend = errorCode;
     if (context->rxHeader.length > 0 &&
         context->rxHeader.seq == context->rxStatus.expectedSeq - 1) {
+      // Pretend like we didn't actually send that last ackSeq so we'll send it
+      // again
+      context->txStatus.sentAckSeq--;
       errorCodeToSend = CHPP_TRANSPORT_ERROR_NONE;
+      CHPP_LOGW("Got duplicate payload, resending ACK");
     }
 
     chppEnqueueTxPacket(
@@ -628,7 +641,7 @@ static void chppProcessRxPacket(struct ChppTransportState *context) {
   } else if (context->rxHeader.length > 0) {
     // Process payload and send ACK
     chppProcessRxPayload(context);
-  } else if (!context->txStatus.hasPacketsToSend) {
+  } else if (!chppHavePendingTxPayload(context)) {
     // Nothing to send and nothing to receive, i.e. this is an ACK before an
     // indefinite period of inactivity. Kick the work thread so it recalculates
     // the notifier timeout.
@@ -753,9 +766,11 @@ static enum ChppTransportErrorCode chppRxHeaderCheck(
  * popped from the TX queue.
  *
  * @param context State of the transport layer.
+ * @return true if we got an ACK for a pending TX packet
  */
-static void chppRegisterRxAck(struct ChppTransportState *context) {
+static bool chppRegisterRxAck(struct ChppTransportState *context) {
   uint8_t rxAckSeq = context->rxHeader.ackSeq;
+  bool gotExpectedAck = false;
 
   if (context->rxStatus.receivedAckSeq != rxAckSeq) {
     // A previously sent packet was actually ACKed
@@ -773,7 +788,7 @@ static void chppRegisterRxAck(struct ChppTransportState *context) {
           context->txStatus.ackedLocInDatagram,
           context->txDatagramQueue.datagram[context->txDatagramQueue.front]
               .length);
-
+      gotExpectedAck = true;
       context->rxStatus.receivedAckSeq = rxAckSeq;
       if (context->txStatus.txAttempts > 1) {
         CHPP_LOGW("Seq %" PRIu8 " ACK'd after %" PRIuSIZE " reTX",
@@ -796,12 +811,12 @@ static void chppRegisterRxAck(struct ChppTransportState *context) {
         // position of the datagram being sent as well (relative to the
         // front-of-queue). e.g. context->txStatus.datagramBeingSent--;
 
-        if (chppDequeueTxDatagram(context) == 0) {
-          context->txStatus.hasPacketsToSend = false;
-        }
+        chppDequeueTxDatagram(context);
       }
     }
   }  // else {nothing was ACKed}
+
+  return gotExpectedAck;
 }
 
 /**
@@ -825,7 +840,6 @@ static void chppRegisterRxAck(struct ChppTransportState *context) {
  */
 static void chppEnqueueTxPacket(struct ChppTransportState *context,
                                 uint8_t packetCode) {
-  context->txStatus.hasPacketsToSend = true;
   context->txStatus.packetCodeToSend = packetCode;
 
   CHPP_LOGD("chppEnqueueTxPacket called with packet code=0x%" PRIx8,
@@ -835,6 +849,46 @@ static void chppEnqueueTxPacket(struct ChppTransportState *context,
   chppNotifierSignal(&context->notifier, CHPP_TRANSPORT_SIGNAL_EVENT);
 }
 
+/**
+ * @return true if we have payload on the TX queue that either hasn't been sent
+ *         or has been sent but not ACKed
+ */
+static bool chppHavePendingTxPayload(const struct ChppTransportState *context) {
+  return (context->txDatagramQueue.pending > 0);
+}
+
+/**
+ * @return true if we have pending payload that should be included in the next
+ *         outbound packet
+ */
+static bool chppShouldAttachPayload(const struct ChppTransportState *context,
+                                    bool resendPayload) {
+  // We should attach payload to an outbound packet if and only if:
+  // - We have payload to send on the queue AND
+  // - We haven't sent it yet, OR we are resending it (i.e. a retry)
+  bool havePayloadToSend = chppHavePendingTxPayload(context);
+  bool haventSentPayloadYet = (context->txStatus.txAttempts == 0);
+  if (resendPayload && !havePayloadToSend) {
+    CHPP_LOGE("Trying to resend non-existent payload!");
+  }
+  return (havePayloadToSend && (haventSentPayloadYet || resendPayload));
+}
+
+/**
+ * @return true if we should send a packet even if we don't have payload
+ */
+static bool chppShouldSendPossiblyEmptyPacket(
+    const struct ChppTransportState *context) {
+  // We should send a packet (even if we have no payload) if and only if:
+  // - We're sending an ACK for a newly received packet (we've updated our
+  //   expectedSeq but haven't sent this yet)
+  // - We're sending a special packet code, e.g. RESET/RESET-ACK/NAK
+  return (context->rxStatus.expectedSeq != context->txStatus.sentAckSeq ||
+          context->txStatus.packetCodeToSend !=
+              CHPP_ATTR_AND_ERROR_TO_PACKET_CODE(CHPP_TRANSPORT_ATTR_NONE,
+                                                 CHPP_TRANSPORT_ERROR_NONE));
+}
+
 /**
  * Adds a CHPP preamble to the beginning of buf.
  *
@@ -973,10 +1027,9 @@ size_t chppDequeueTxDatagram(struct ChppTransportState *context) {
  * @param context State of the transport layer.
  */
 static void chppClearTxDatagramQueue(struct ChppTransportState *context) {
-  while (context->txDatagramQueue.pending > 0) {
+  while (chppHavePendingTxPayload(context)) {
     chppDequeueTxDatagram(context);
   }
-  context->txStatus.hasPacketsToSend = false;
 }
 
 /**
@@ -991,16 +1044,20 @@ static void chppClearTxDatagramQueue(struct ChppTransportState *context) {
  * i.e. we have registered an explicit or implicit NACK.
  *
  * @param context State of the transport layer.
+ * @param resendPayload true if we should always attach the queued
+ *        payload to the packet, false to only send it if it's the first attempt
  */
-static void chppTransportDoWork(struct ChppTransportState *context) {
+static void chppTransportDoWork(struct ChppTransportState *context,
+                                bool resendPayload) {
   bool havePacketForLinkLayer = false;
   struct ChppTransportHeader *txHeader;
 
   // Note: For a future ACK window >1, there needs to be a loop outside the lock
   chppMutexLock(&context->mutex);
 
-  if (context->txStatus.hasPacketsToSend && !context->txStatus.linkBusy) {
-    // There are pending outgoing packets and the link isn't busy
+  bool sendPayload = chppShouldAttachPayload(context, resendPayload);
+  if (!context->txStatus.linkBusy &&
+      (sendPayload || chppShouldSendPossiblyEmptyPacket(context))) {
     havePacketForLinkLayer = true;
     context->txStatus.linkBusy = true;
 
@@ -1016,14 +1073,13 @@ static void chppTransportDoWork(struct ChppTransportState *context) {
     // Add header
     txHeader = chppAddHeader(context);
 
-    // If applicable, add payload
-    if ((context->txDatagramQueue.pending > 0)) {
+    if (sendPayload) {
+      // Either we haven't sent this payload yet, or we are retrying it
       // Note: For a future ACK window >1, we need to rewrite this payload
       // adding code to base the next packet on the sent location within the
       // last sent datagram, except for the case of a NACK (explicit or
       // timeout). For a NACK, we would need to base the next packet off the
       // last ACKed location.
-
       txHeader->seq = context->rxStatus.receivedAckSeq;
       context->txStatus.sentSeq = txHeader->seq;
 
@@ -1041,22 +1097,20 @@ static void chppTransportDoWork(struct ChppTransportState *context) {
         chppAddPayload(context);
         context->txStatus.txAttempts++;
       }
-
-    } else {
-      // No payload
-      context->txStatus.hasPacketsToSend = false;
+    } else if (chppHavePendingTxPayload(context)) {
+      // We have pending payload but aren't sending it, for example if we're
+      // just sending a NAK for a bad incoming payload-bearing packet
+      CHPP_LOGI("Skipping attaching pending payload");
     }
 
     chppAddFooter(context);
 
   } else {
-    CHPP_LOGW(
-        "DoWork nothing to send. hasPackets=%d, linkBusy=%d, pending=%" PRIu8
-        ", RX ACK=%" PRIu8 ", TX seq=%" PRIu8 ", RX state=%s",
-        context->txStatus.hasPacketsToSend, context->txStatus.linkBusy,
-        context->txDatagramQueue.pending, context->rxStatus.receivedAckSeq,
-        context->txStatus.sentSeq,
-        chppGetRxStatusLabel(context->rxStatus.state));
+    CHPP_LOGW("DoWork nothing to send. linkBusy=%d, pending=%" PRIu8
+              ", RX ACK=%" PRIu8 ", TX seq=%" PRIu8 ", RX state=%s",
+              context->txStatus.linkBusy, context->txDatagramQueue.pending,
+              context->rxStatus.receivedAckSeq, context->txStatus.sentSeq,
+              chppGetRxStatusLabel(context->rxStatus.state));
   }
 
   chppMutexUnlock(&context->mutex);
@@ -1155,6 +1209,8 @@ static const char *chppGetPacketAttrStr(uint8_t packetCode) {
  * If enqueueing is unsuccessful, it is up to the caller to decide when or if
  * to free the payload and/or resend it later.
  *
+ * ChppTransportState->mutex must be locked prior to invoking this method.
+ *
  * @param context State of the transport layer.
  * @param packetCode Error code and packet attributes to be sent.
  * @param buf Datagram payload allocated through chppMalloc. Cannot be null.
@@ -1163,8 +1219,9 @@ static const char *chppGetPacketAttrStr(uint8_t packetCode) {
  * @return True informs the sender that the datagram was successfully enqueued.
  * False informs the sender that the queue was full.
  */
-static bool chppEnqueueTxDatagram(struct ChppTransportState *context,
-                                  uint8_t packetCode, void *buf, size_t len) {
+static bool chppEnqueueTxDatagramLocked(struct ChppTransportState *context,
+                                        uint8_t packetCode, void *buf,
+                                        size_t len) {
   bool success = false;
 
   if (len == 0) {
@@ -1186,8 +1243,6 @@ static bool chppEnqueueTxDatagram(struct ChppTransportState *context,
           header->command, (uint8_t)(context->txDatagramQueue.pending + 1));
     }
 
-    chppMutexLock(&context->mutex);
-
     if (context->txDatagramQueue.pending >= CHPP_TX_DATAGRAM_QUEUE_LEN) {
       CHPP_LOGE("Cannot enqueue TX datagram");
 
@@ -1206,8 +1261,6 @@ static bool chppEnqueueTxDatagram(struct ChppTransportState *context,
 
       success = true;
     }
-
-    chppMutexUnlock(&context->mutex);
   }
 
   return success;
@@ -1302,8 +1355,8 @@ static void chppReset(struct ChppTransportState *transportContext,
   transportContext->rxStatus.expectedSeq = transportContext->rxHeader.seq + 1;
 
   // Send reset or reset-ACK
+  chppTransportSendResetLocked(transportContext, resetType, error);
   chppMutexUnlock(&transportContext->mutex);
-  chppTransportSendReset(transportContext, resetType, error);
 
   // Inform the App Layer that a reset has completed
   if (resetType == CHPP_TRANSPORT_ATTR_RESET_ACK) {
@@ -1479,14 +1532,7 @@ bool chppRxDataCb(struct ChppTransportState *context, const uint8_t *buf,
   CHPP_NOT_NULL(buf);
   CHPP_NOT_NULL(context);
 
-  chppMutexLock(&context->mutex);
-  if (context->rxStatus.state != CHPP_STATE_PREAMBLE &&
-      chppGetCurrentTimeNs() >
-          context->rxStatus.packetStartTimeNs + CHPP_TRANSPORT_RX_TIMEOUT_NS) {
-    CHPP_LOGE("Packet RX timeout");
-    chppAbortRxPacket(context);
-  }
-  chppMutexUnlock(&context->mutex);
+  chppCheckRxPacketTimeout(context, chppGetCurrentTimeNs());
 
   CHPP_LOGD("RX %" PRIuSIZE " bytes: state=%s", len,
             chppGetRxStatusLabel(context->rxStatus.state));
@@ -1548,12 +1594,14 @@ void chppRxPacketCompleteCb(struct ChppTransportState *context) {
 bool chppEnqueueTxDatagramOrFail(struct ChppTransportState *context, void *buf,
                                  size_t len) {
   bool success = false;
+
+  chppMutexLock(&context->mutex);
   bool resetting = (context->resetState == CHPP_RESET_STATE_RESETTING);
 
   if (len == 0) {
     CHPP_DEBUG_ASSERT_LOG(false, "Enqueue datagram len=0!");
 
-  } else if (resetting || !chppEnqueueTxDatagram(
+  } else if (resetting || !chppEnqueueTxDatagramLocked(
                               context, CHPP_TRANSPORT_ERROR_NONE, buf, len)) {
     uint8_t *handle = buf;
     CHPP_LOGE("Resetting=%d. Discarding %" PRIuSIZE " bytes for H#%" PRIu8,
@@ -1564,6 +1612,7 @@ bool chppEnqueueTxDatagramOrFail(struct ChppTransportState *context, void *buf,
   } else {
     success = true;
   }
+  chppMutexUnlock(&context->mutex);
 
   return success;
 }
@@ -1597,17 +1646,24 @@ void chppEnqueueTxErrorDatagram(struct ChppTransportState *context,
   chppMutexUnlock(&context->mutex);
 }
 
+void chppTransportForceReset(struct ChppTransportState *context) {
+  CHPP_LOGW("Forcing transport reset");
+  chppNotifierSignal(&context->notifier, CHPP_TRANSPORT_SIGNAL_FORCE_RESET);
+}
+
 uint64_t chppTransportGetTimeUntilNextDoWorkNs(
     struct ChppTransportState *context) {
   uint64_t currentTime = chppGetCurrentTimeNs();
   // This function is called in the context of the transport worker thread.
   // As we do not know if the transport is used in the context of a service
   // or a client, we use the min of both timeouts.
-  uint64_t nextDoWorkTime =
-      MIN(context->appContext->nextClientRequestTimeoutNs,
-          context->appContext->nextServiceRequestTimeoutNs);
+  uint64_t nextDoWorkTime = chppAppGetNextTimerTimeoutNs(context->appContext);
+  nextDoWorkTime =
+      MIN(nextDoWorkTime, context->appContext->nextClientRequestTimeoutNs);
+  nextDoWorkTime =
+      MIN(nextDoWorkTime, context->appContext->nextServiceRequestTimeoutNs);
 
-  if (context->txStatus.hasPacketsToSend ||
+  if (chppHavePendingTxPayload(context) ||
       context->resetState == CHPP_RESET_STATE_RESETTING) {
     nextDoWorkTime =
         MIN(nextDoWorkTime, CHPP_TRANSPORT_TX_TIMEOUT_NS +
@@ -1616,6 +1672,11 @@ uint64_t chppTransportGetTimeUntilNextDoWorkNs(
                                      : context->txStatus.lastTxTimeNs));
   }
 
+  if (context->rxStatus.state != CHPP_STATE_PREAMBLE) {
+    nextDoWorkTime = MIN(nextDoWorkTime, context->rxStatus.packetStartTimeNs +
+                                             CHPP_TRANSPORT_RX_TIMEOUT_NS);
+  }
+
   if (nextDoWorkTime == CHPP_TIME_MAX) {
     CHPP_LOGD("NextDoWork=n/a currentTime=%" PRIu64,
               currentTime / CHPP_NSEC_PER_MSEC);
@@ -1633,8 +1694,10 @@ uint64_t chppTransportGetTimeUntilNextDoWorkNs(
 }
 
 void chppWorkThreadStart(struct ChppTransportState *context) {
-  chppTransportSendReset(context, CHPP_TRANSPORT_ATTR_RESET,
-                         CHPP_TRANSPORT_ERROR_NONE);
+  chppMutexLock(&context->mutex);
+  chppTransportSendResetLocked(context, CHPP_TRANSPORT_ATTR_RESET,
+                               CHPP_TRANSPORT_ERROR_NONE);
+  chppMutexUnlock(&context->mutex);
   CHPP_LOGD("CHPP Work Thread started");
 
   uint32_t signals;
@@ -1667,8 +1730,12 @@ bool chppWorkThreadHandleSignal(struct ChppTransportState *context,
       // Triggered by timeout.
       chppWorkHandleTimeout(context);
     } else {
+      if (signals & CHPP_TRANSPORT_SIGNAL_FORCE_RESET) {
+        chppReset(context, CHPP_TRANSPORT_ATTR_RESET,
+                  CHPP_TRANSPORT_ERROR_FORCED_RESET);
+      }
       if (signals & CHPP_TRANSPORT_SIGNAL_EVENT) {
-        chppTransportDoWork(context);
+        chppTransportDoWork(context, /*resendPayload=*/false);
       }
       if (signals & CHPP_TRANSPORT_SIGNAL_PLATFORM_MASK) {
         context->linkApi->doWork(context->linkContext,
@@ -1699,8 +1766,9 @@ bool chppWorkThreadHandleSignal(struct ChppTransportState *context,
  */
 static void chppWorkHandleTimeout(struct ChppTransportState *context) {
   const uint64_t currentTimeNs = chppGetCurrentTimeNs();
-  const bool isTxTimeout = currentTimeNs - context->txStatus.lastTxTimeNs >=
-                           CHPP_TRANSPORT_TX_TIMEOUT_NS;
+  const bool isTxTimeout = chppHavePendingTxPayload(context) &&
+                           (currentTimeNs - context->txStatus.lastTxTimeNs >=
+                            CHPP_TRANSPORT_TX_TIMEOUT_NS);
   const bool isResetting = context->resetState == CHPP_RESET_STATE_RESETTING;
 
   // Call chppTransportDoWork for both TX and request timeouts.
@@ -1708,14 +1776,14 @@ static void chppWorkHandleTimeout(struct ChppTransportState *context) {
     CHPP_LOGE("ACK timeout. Tx t=%" PRIu64 ", attempt %zu, isResetting=%d",
               context->txStatus.lastTxTimeNs / CHPP_NSEC_PER_MSEC,
               context->txStatus.txAttempts, isResetting);
-    chppTransportDoWork(context);
+    chppTransportDoWork(context, /*resendPayload=*/true);
   } else {
     const uint64_t requestTimeoutNs =
         MIN(context->appContext->nextClientRequestTimeoutNs,
             context->appContext->nextServiceRequestTimeoutNs);
     const bool isRequestTimeout = requestTimeoutNs <= currentTimeNs;
     if (isRequestTimeout) {
-      chppTransportDoWork(context);
+      chppTransportDoWork(context, /*resendPayload=*/false);
     }
   }
 
@@ -1731,8 +1799,25 @@ static void chppWorkHandleTimeout(struct ChppTransportState *context) {
       context->txStatus.txAttempts = 0;
       context->resetState = CHPP_RESET_STATE_PERMANENT_FAILURE;
       chppClearTxDatagramQueue(context);
+      context->txStatus.packetCodeToSend = 0;
     }
   }
+
+  chppAppProcessTimeout(context->appContext, currentTimeNs);
+  chppCheckRxPacketTimeout(context, currentTimeNs);
+}
+
+void chppCheckRxPacketTimeout(struct ChppTransportState *context,
+                              uint64_t now) {
+  chppMutexLock(&context->mutex);
+  if (context->rxStatus.state != CHPP_STATE_PREAMBLE &&
+      now >
+          context->rxStatus.packetStartTimeNs + CHPP_TRANSPORT_RX_TIMEOUT_NS) {
+    CHPP_LOGE("Packet RX timeout");
+    chppAbortRxPacket(context);
+    chppEnqueueTxPacket(context, CHPP_TRANSPORT_ERROR_TIMEOUT);  // NACK
+  }
+  chppMutexUnlock(&context->mutex);
 }
 
 void chppWorkThreadStop(struct ChppTransportState *context) {
@@ -1840,9 +1925,9 @@ uint8_t chppRunTransportLoopback(struct ChppTransportState *context,
   return result;
 }
 
-void chppTransportSendReset(struct ChppTransportState *context,
-                            enum ChppTransportPacketAttributes resetType,
-                            enum ChppTransportErrorCode error) {
+void chppTransportSendResetLocked(struct ChppTransportState *context,
+                                  enum ChppTransportPacketAttributes resetType,
+                                  enum ChppTransportErrorCode error) {
   // Make sure CHPP is in an initialized state
   CHPP_ASSERT_LOG((context->txDatagramQueue.pending == 0 &&
                    context->txDatagramQueue.front == 0),
@@ -1871,9 +1956,9 @@ void chppTransportSendReset(struct ChppTransportState *context,
 
     context->resetTimeNs = chppGetCurrentTimeNs();
 
-    chppEnqueueTxDatagram(context,
-                          CHPP_ATTR_AND_ERROR_TO_PACKET_CODE(resetType, error),
-                          config, sizeof(*config));
+    chppEnqueueTxDatagramLocked(
+        context, CHPP_ATTR_AND_ERROR_TO_PACKET_CODE(resetType, error), config,
+        sizeof(*config));
   }
 }
 
@@ -1889,4 +1974,4 @@ size_t chppTransportRxMtuSize(const struct ChppTransportState *context) {
       context->linkApi->getConfig(context->linkContext);
 
   return linkConfig.rxBufferLen - CHPP_TRANSPORT_ENCODING_OVERHEAD_BYTES;
-}
\ No newline at end of file
+}
diff --git a/chre_api/CMakeLists.txt b/chre_api/CMakeLists.txt
index 26e429d4..20c20960 100644
--- a/chre_api/CMakeLists.txt
+++ b/chre_api/CMakeLists.txt
@@ -17,6 +17,7 @@ pw_add_facade(chre.chre_api INTERFACE
     include/chre_api/chre/common.h
     include/chre_api/chre/event.h
     include/chre_api/chre/gnss.h
+    include/chre_api/chre/msg.h
     include/chre_api/chre/nanoapp.h
     include/chre_api/chre/re.h
     include/chre_api/chre/sensor.h
diff --git a/chre_api/include/chre_api/chre.h b/chre_api/include/chre_api/chre.h
index 9b87d08b..c67e52ad 100644
--- a/chre_api/include/chre_api/chre.h
+++ b/chre_api/include/chre_api/chre.h
@@ -33,6 +33,7 @@
 #include <chre/common.h>
 #include <chre/event.h>
 #include <chre/gnss.h>
+#include <chre/msg.h>
 #include <chre/nanoapp.h>
 #include <chre/re.h>
 #include <chre/sensor.h>
diff --git a/chre_api/include/chre_api/chre/ble.h b/chre_api/include/chre_api/chre/ble.h
index 230fe7d3..06a88ec8 100644
--- a/chre_api/include/chre_api/chre/ble.h
+++ b/chre_api/include/chre_api/chre/ble.h
@@ -201,11 +201,12 @@ extern "C" {
 /**
  * nanoappHandleEvent argument: struct chreBleSocketConnectionEvent
  *
- * This is a unicast event that is sent to a nanoapp when an offloaded socket is
- * connected and is available to be used by the nanoapp. The nanoapp must call
- * chreBleSocketAccept() to accept ownership of the socket and
- * subscribe to CHRE_EVENT_BLE_SOCKET_PACKET events.
+ * This event is sent to a nanoapp when ownership of a connected BLE socket is
+ * being transferred to the nanoapp. If the nanoapp does not call
+ * chreBleSocketAccept() while handling this event, then the transfer is
+ * aborted.
  *
+ * @see chreBleSocketAccept()
  * @since v1.11
  */
 #define CHRE_EVENT_BLE_SOCKET_CONNECTION CHRE_BLE_EVENT_ID(6)
@@ -213,8 +214,8 @@ extern "C" {
 /**
  * nanoappHandleEvent argument: struct chreBleSocketDisconnectionEvent
  *
- * This is a unicast event that is sent to a nanoapp when an offloaded socket is
- * disconnected and can no longer be used by the nanoapp.
+ * This event is sent to a nanoapp when a socket it previously accepted via
+ * chreBleSocketAccept() can no longer be used by the nanoapp.
  *
  * @since v1.11
  */
@@ -223,8 +224,8 @@ extern "C" {
 /**
  * nanoappHandleEvent argument: struct chreBleSocketPacketEvent
  *
- * This event is sent when the nanoapp receives a packet from the offload
- * socket.
+ * This event is sent when a packet is received over a socket owned by the
+ * nanoapp.
  *
  * @since v1.11
  */
@@ -233,8 +234,10 @@ extern "C" {
 /**
  * nanoappHandleEvent argument: NULL
  *
- * This event is sent when the socket is available to send packets again.
+ * This event is sent when a socket is ready to accept packets after
+ * encountering CHRE_BLE_SOCKET_SEND_STATUS_QUEUE_FULL.
  *
+ * @see chreBleSocketSend()
  * @since v1.11
  */
 #define CHRE_EVENT_BLE_SOCKET_SEND_AVAILABLE CHRE_BLE_EVENT_ID(9)
@@ -722,10 +725,7 @@ struct chreBleScanStatus {
 };
 
 /**
- * Notifies a nanoapp that a socket has been connected and offloaded and is
- * ready to be used. The nanoapp is expected to accept ownership of the socket
- * by calling the chreBleSocketAccept() API. If the nanoapp does not accept
- * ownership of the socket, the transfer of ownership to the nanoapp is aborted.
+ * Data associated with CHRE_EVENT_BLE_SOCKET_CONNECTION.
  *
  * @since v1.11
  */
@@ -751,20 +751,20 @@ struct chreBleSocketConnectionEvent {
 };
 
 /**
- * Notifies a nanoapp that a socket has been disconnected and can no longer be
- * used by the nanoapp. Once a socket is disconnected, the same socket ID will
- * not be reconnected. If the nanoapp wants to continue using an offloaded
- * socket, a new offloaded socket must be created and connected.
+ * Data associated with CHRE_EVENT_BLE_SOCKET_DISCONNECTION.
  *
  * @since v1.11
  */
 struct chreBleSocketDisconnectionEvent {
+  //! Identifier for the disconnected socket. Once a socket is disconnected, the
+  //! same socket ID will not be reconnected. To resume communication, a new
+  //! socket must be created and transferred to the nanoapp.
   //! @see chreBleSocketConnectionEvent.socketId
   uint64_t socketId;
 };
 
 /**
- * Notifies a nanoapp that it has received a packet from a socket.
+ * Incoming socket data, sent with CHRE_EVENT_BLE_SOCKET_PACKET.
  *
  * @since v1.11
  */
@@ -1079,11 +1079,11 @@ bool chreBleReadRssiAsync(uint16_t connectionHandle, const void *cookie);
 bool chreBleGetScanStatus(struct chreBleScanStatus *status);
 
 /**
- * Accepts that this nanoapp owns the socket and subscribes to
- * CHRE_EVENT_BLE_SOCKET_PACKET events from this socket. This API is only
+ * Accepts transfer of ownership of a connected socket and subscribes to
+ * CHRE_EVENT_BLE_SOCKET_PACKET events for this socket. This API is only
  * valid to call while handling the CHRE_EVENT_BLE_SOCKET_CONNECTION event.
  *
- * @param socketId @see chreBleSocketConnectionEvent.socketId
+ * @param socketId ID passed in chreBleSocketConnectionEvent.socketId
  * @return True if CHRE confirms that socket ownership has been transferred.
  *
  * @since v1.11
diff --git a/chre_api/include/chre_api/chre/common.h b/chre_api/include/chre_api/chre/common.h
index beecc46b..61214fcf 100644
--- a/chre_api/include/chre_api/chre/common.h
+++ b/chre_api/include/chre_api/chre/common.h
@@ -136,7 +136,7 @@ enum chreError {
     //!< Do not exceed this value when adding new error codes
     CHRE_ERROR_LAST = UINT8_MAX,
 };
-// LINT.ThenChange(../../../../core/include/chre/core/api_manager_common.h)
+// LINT.ThenChange(../../../../util/include/chre/util/system/chre_error_util.h)
 
 /**
  * Generic data structure to indicate the result of an asynchronous operation.
diff --git a/chre_api/include/chre_api/chre/event.h b/chre_api/include/chre_api/chre/event.h
index fb567333..e9cc30ac 100644
--- a/chre_api/include/chre_api/chre/event.h
+++ b/chre_api/include/chre_api/chre/event.h
@@ -30,6 +30,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 
+#include <chre/common.h>
 #include <chre/toolchain.h>
 
 #ifdef __cplusplus
@@ -202,31 +203,6 @@ extern "C" {
  */
 #define CHRE_EVENT_RELIABLE_MSG_ASYNC_RESULT UINT16_C(0x000B)
 
-/**
- * nanoappHandleEvent argument: struct chreMessageFromEndpointData
- *
- * The format of the 'message' part of this structure is left undefined,
- * and it's up to the nanoapp and endpoint to have an established protocol
- * beforehand.
- *
- * On receiving the first message from an endpoint, the nanoapp can assume
- * a session with the sessionId has been created and can be used to send
- * messages to the endpoint. The nanoapp will receive a
- * CHRE_EVENT_ENDPOINT_SESSION_CLOSED event when the session is closed.
- *
- * @since v1.11
- */
-#define CHRE_EVENT_MESSAGE_FROM_ENDPOINT UINT16_C(0x000C)
-
-/**
- * nanoappHandleEvent argument: struct chreEndpointSessionClosedData
- *
- * Indicates that a session with an endpoint has been closed.
- *
- * @since v1.11
- */
-#define CHRE_EVENT_ENDPOINT_SESSION_CLOSED UINT16_C(0x000D)
-
 /**
  * First possible value for CHRE_EVENT_SENSOR events.
  *
@@ -287,6 +263,13 @@ extern "C" {
 #define CHRE_EVENT_BLE_FIRST_EVENT UINT16_C(0x0350)
 #define CHRE_EVENT_BLE_LAST_EVENT  UINT16_C(0x035F)
 
+/**
+ * First event in the block reserved for session-based messaging. These events
+ * are defined in chre/msg.h.
+ */
+#define CHRE_EVENT_MSG_FIRST_EVENT UINT16_C(0x0360)
+#define CHRE_EVENT_MSG_LAST_EVENT UINT16_C(0x036F)
+
 /**
  * First in the extended range of values dedicated for internal CHRE
  * implementation usage.
@@ -450,68 +433,6 @@ struct chreMessageFromHostData {
     uint16_t hostEndpoint;
 };
 
-/**
- * Data provided with CHRE_EVENT_MESSAGE_FROM_ENDPOINT.
- */
-struct chreMessageFromEndpointData {
-    /**
-     * Message type supplied by the endpoint.
-     */
-    uint32_t messageType;
-
-    /**
-     * Message permissions supplied by the endpoint. The format is specified by
-     * the CHRE_MESSAGE_PERMISSION_* values if the endpoint is a nanoapp, else
-     * it is specified by the endpoint. These permissions are enforced by CHRE.
-     * A nanoapp without the required permissions will not receive the message.
-     */
-    uint32_t messagePermissions;
-
-    /**
-     * The message from the endpoint.
-     *
-     * These contents are of a format that the endpoint and nanoapp must have
-     * established beforehand.
-     *
-     * This data is 'messageSize' bytes in length.  Note that if 'messageSize'
-     * is 0, this might contain NULL.
-     */
-    const void *message;
-
-    /**
-     * The size, in bytes of the following 'message'.
-     *
-     * This can be 0.
-     */
-    size_t messageSize;
-
-    /**
-     * The session ID of the message. A session is the active connection between
-     * two endpoints. The receiving nanoapp or endpoint initiated the session
-     * before sending this message. If the nanoapp has not yet received a
-     * message with this session ID, it can assume the session was created by
-     * the nanoapp or other endpoint. The nanoapp may send messages to the other
-     * endpoint with this session ID.
-     */
-    uint16_t sessionId;
-};
-
-/**
- * Data provided with CHRE_EVENT_ENDPOINT_SESSION_CLOSED.
- */
-struct chreEndpointSessionClosedData {
-    /**
-     * The message hub ID and endpoint ID of the other party in the session.
-     */
-    uint64_t hubId;
-    uint64_t endpointId;
-
-    /**
-     * The ID of the session that was closed.
-     */
-    uint16_t sessionId;
-};
-
 /**
  * Provides metadata for a nanoapp in the system.
  */
@@ -1097,6 +1018,18 @@ bool chreConfigureHostEndpointNotifications(uint16_t hostEndpointId,
  * @return true if the publishing is successful.
  *
  * @since v1.6
+ *
+ * @deprecated Use chreMsgPublishServices() instead. If this function is
+ * called with CHRE API version v1.11 or above, it will convert each
+ * struct chreNanoappRpcService to a struct chreMsgEndpointServiceInfo and
+ * call chreMsgPublishServices() instead. The conversion will be mapped as
+ * follows:
+ *   - majorVersion = chreNanoappRpcService.version
+ *   - minorVersion = 0
+ *   - serviceDescriptor = FORMAT_STRING(
+ *     "chre.nanoapp_0x%016" PRIX64 ".service_0x%016" PRIX64, nanoapp_id,
+ *     service_id)
+ *   - serviceFormat = CHRE_ENDPOINT_SERVICE_FORMAT_PW_RPC_PROTOBUF
  */
 bool chrePublishRpcServices(struct chreNanoappRpcService *services,
                             size_t numServices);
diff --git a/chre_api/include/chre_api/chre/gnss.h b/chre_api/include/chre_api/chre/gnss.h
index 75d01683..74e8649d 100644
--- a/chre_api/include/chre_api/chre/gnss.h
+++ b/chre_api/include/chre_api/chre/gnss.h
@@ -71,6 +71,12 @@ extern "C" {
 #define CHRE_GNSS_CAPABILITIES_GNSS_ENGINE_BASED_PASSIVE_LISTENER \
                                              (UINT32_C(1) << 2)
 
+//! GNSS data from remote sources is supported via
+//! chreGnssLocationSessionStartAsyncV1_11() and
+//! chreGnssMeasurementSessionStartAsyncV1_11()
+//! @since v1.11
+#define CHRE_GNSS_CAPABILITIES_REMOTE_SOURCE (UINT32_C(1) << 3)
+
 /** @} */
 
 /**
@@ -215,6 +221,25 @@ enum chreGnssMultipathIndicator {
     CHRE_GNSS_MULTIPATH_INDICATOR_NOT_PRESENT = 2,
 };
 
+/**
+ * Enumeration of available values for the GNSS source type associated with
+ * a location fix, measurement data, a location session or a measurement
+ * session
+ */
+enum chreGnssSource {
+  //! In the request context, indicates that there is no preference for a
+  //! particular GNSS engine, so if there are multiple, allow the system to
+  //! decide which one is used (the selected engine may change over the course
+  //! of a session).
+  //! In the result context, indicates that the GNSS engine used was not
+  //! explicitly reported.
+  CHRE_GNSS_SOURCE_UNSPECIFIED = 0,
+  //! References the GNSS system local to this device
+  CHRE_GNSS_SOURCE_LOCAL = 1,
+  //! References a GNSS system on a remote device
+  CHRE_GNSS_SOURCE_REMOTE = 2,
+};
+
 /**
  * Represents an estimate of the GNSS clock time (see the Android GPS HAL for
  * more detailed information)
@@ -331,8 +356,13 @@ struct chreGnssDataEvent {
     //! the range [0, CHRE_GNSS_MAX_MEASUREMENT]
     uint8_t measurement_count;
 
+    //! The source of the GNSS data
+    //! @see #chreGnssSource
+    //! @since v1.11
+    uint8_t gnss_source;
+
     //! Reserved for future use; set to 0
-    uint8_t reserved[6];
+    uint8_t reserved[5];
 
     struct chreGnssClock clock;
 
@@ -377,9 +407,14 @@ struct chreGnssLocationEvent {
     //! @see #GpsLocationFlags
     uint16_t flags;
 
+    //! The source of the GNSS data
+    //! @see #chreGnssSource
+    //! @since v1.11
+    uint8_t gnss_source;
+
     //! Reserved for future use; set to 0
     //! @since v1.3
-    uint8_t reserved[2];
+    uint8_t reserved[1];
 
     //! Expected vertical accuracy in meters such that a range of
     //! 2 * altitude_accuracy centered around altitude has a 68% probability of
@@ -426,6 +461,18 @@ uint32_t chreGnssGetCapabilities(void);
  */
 #if defined(CHRE_NANOAPP_USES_GNSS) || !defined(CHRE_IS_NANOAPP_BUILD)
 
+/**
+ * Initiates a GNSS positioning session, or changes the requested interval of an
+ * existing session.
+ *
+ * @see chreGnssLocationSessionStartAsyncV1_11 for further details. This
+ * function behaves the same as calling that function with
+ * CHRE_GNSS_SOURCE_UNSPECIFIED.
+ */
+bool chreGnssLocationSessionStartAsync(uint32_t minIntervalMs,
+                                       uint32_t minTimeToNextFixMs,
+                                       const void *cookie);
+
 /**
  * Initiates a GNSS positioning session, or changes the requested interval of an
  * existing session. If starting or modifying the session was successful, then
@@ -437,8 +484,12 @@ uint32_t chreGnssGetCapabilities(void);
  * the CHRE implementation is expected to return a result with
  * CHRE_ERROR_FUNCTION_DISABLED.
  *
- * If chreGnssGetCapabilities() returns a value that does not have the
- * CHRE_GNSS_CAPABILITIES_LOCATION flag set, then this method will return false.
+ * If chreGnssGetCapabilities() does not include
+ * CHRE_GNSS_CAPABILITIES_REMOTE_SOURCE, calling this function with
+ * CHRE_GNSS_SOURCE_REMOTE will return false. Calling this function with
+ * CHRE_GNSS_SOURCE_LOCAL or CHRE_GNSS_SOURCE_UNSPECIFIED will elicit the same
+ * behavior as chreGnssLocationSessionStartAsync(), including when run on CHRE
+ * versions prior to v1.11.
  *
  * @param minIntervalMs The desired minimum interval between location fixes
  *        delivered to the client via CHRE_EVENT_GNSS_LOCATION, in milliseconds.
@@ -452,15 +503,17 @@ uint32_t chreGnssGetCapabilities(void);
  *        has elapsed.
  * @param cookie An opaque value that will be included in the chreAsyncResult
  *        sent in relation to this request.
+ * @param source The source of the GNSS data to request.
  *
  * @return true if the request was accepted for processing, false otherwise
  *
- * @since v1.1
+ * @since v1.11
  * @note Requires GNSS permission
  */
-bool chreGnssLocationSessionStartAsync(uint32_t minIntervalMs,
-                                       uint32_t minTimeToNextFixMs,
-                                       const void *cookie);
+bool chreGnssLocationSessionStartAsyncV1_11(uint32_t minIntervalMs,
+                                            uint32_t minTimeToNextFixMs,
+                                            const void *cookie,
+                                            enum chreGnssSource source);
 
 /**
  * Terminates an existing GNSS positioning session. If no positioning session
@@ -488,6 +541,16 @@ bool chreGnssLocationSessionStartAsync(uint32_t minIntervalMs,
  */
 bool chreGnssLocationSessionStopAsync(const void *cookie);
 
+/**
+ * Initiates a request to receive raw GNSS measurements.
+ *
+ * @see chreGnssMeasurementSessionStartAsyncV1_11 for further details. This
+ * function behaves the same as calling that function with
+ * CHRE_GNSS_SOURCE_UNSPECIFIED.
+ */
+bool chreGnssMeasurementSessionStartAsync(uint32_t minIntervalMs,
+                                          const void *cookie);
+
 /**
  * Initiates a request to receive raw GNSS measurements. A GNSS measurement
  * session can exist independently of location sessions. In other words, a
@@ -500,9 +563,12 @@ bool chreGnssLocationSessionStopAsync(const void *cookie);
  * the CHRE implementation is expected to return a result with
  * CHRE_ERROR_FUNCTION_DISABLED.
  *
- * If chreGnssGetCapabilities() returns a value that does not have the
- * CHRE_GNSS_CAPABILITIES_MEASUREMENTS flag set, then this method will return
- * false.
+ * If chreGnssGetCapabilities() does not include
+ * CHRE_GNSS_CAPABILITIES_REMOTE_SOURCE, calling this function with
+ * CHRE_GNSS_SOURCE_REMOTE will return false. Calling this function with
+ * CHRE_GNSS_SOURCE_LOCAL or CHRE_GNSS_SOURCE_UNSPECIFIED will elicit the same
+ * behavior as chreGnssMeasurementSessionStartAsync(), including when run on
+ * CHRE versions prior to v1.11.
  *
  * @param minIntervalMs The desired minimum interval between measurement reports
  *        delivered via CHRE_EVENT_GNSS_DATA. When requested at 1000ms or
@@ -511,14 +577,16 @@ bool chreGnssLocationSessionStopAsync(const void *cookie);
  *        once every 1000ms, on average.
  * @param cookie An opaque value that will be included in the chreAsyncResult
  *        sent in relation to this request.
+ * @param source The source of the GNSS data to request.
  *
  * @return true if the request was accepted for processing, false otherwise
  *
- * @since v1.1
+ * @since v1.11
  * @note Requires GNSS permission
  */
-bool chreGnssMeasurementSessionStartAsync(uint32_t minIntervalMs,
-                                          const void *cookie);
+bool chreGnssMeasurementSessionStartAsyncV1_11(uint32_t minIntervalMs,
+                                               const void *cookie,
+                                               enum chreGnssSource source);
 
 /**
  * Terminates an existing raw GNSS measurement session. If no measurement
diff --git a/chre_api/include/chre_api/chre/msg.h b/chre_api/include/chre_api/chre/msg.h
new file mode 100644
index 00000000..f02fd400
--- /dev/null
+++ b/chre_api/include/chre_api/chre/msg.h
@@ -0,0 +1,644 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// IWYU pragma: private, include "chre_api/chre.h"
+// IWYU pragma: friend chre/.*\.h
+
+#ifndef _CHRE_MSG_H_
+#define _CHRE_MSG_H_
+
+/**
+ * @file
+ * Context Hub Runtime Environment API for session-based messaging with generic
+ * endpoints.
+ *
+ * Key concepts:
+ * - **Endpoint**: an entity in the system that can send and receive messages.
+ *   Example endpoints include nanoapps, other offload components outside of
+ *   CHRE, privileged Android applications or Android system components
+ *   (registered via the ContextHubManager.registerEndpoint() API), vendor
+ *   processes (e.g. HALs) registered with the Context Hub HAL, etc.
+ * - **Message**: a datagram sent over a session.
+ * - **Session**: an active connection between two endpoints, optionally scoped
+ *   to a specific service. All messages must be sent over an established
+ *   session. A session will be automatically closed if sending a message fails
+ *   or the remote endpoint otherwise disconnects.
+ * - **Service**: a defined interface and wire format associated with some
+ *   functionality. Endpoints can choose to not register any services, for
+ *   example in cases where the endpoint only functions as a client, or if its
+ *   interface is implied and internal (e.g. a nanoapp that is tightly coupled
+ *   with its host-side code). Endpoints may also register 1 or more services,
+ *   and multiple endpoints may register the same service. This enables
+ *   abstraction between the interface/functionality and the entity/endpoint
+ *   that implements it.
+ *
+ * This API provides a single interface for nanoapps to communicate with other
+ * parts of the system, regardless of location.  Nanoapps should use these APIs
+ * rather than chreSendEvent(), chreSendMessageToHostEndpoint(), and related
+ * APIs if they do not need to support Android versions prior to Android 16 nor
+ * CHRE APIs older than v1.11.
+ *
+ * The general order of API usage as a client (session initiator) is:
+ *
+ * 1. The nanoapp should know the target service and/or endpoint ID it wants to
+ *    interact with, and optionally the target hub ID, and provide this to
+ *    chreMsgConfigureEndpointReadyEvents() or
+ *    chreMsgConfigureServiceReadyEvents().
+ * 2. The nanoapp will receive an event when a suitable endpoint is found. The
+ *    nanoapp then calls chreMsgSessionOpenAsync() to initiate communication.
+ * 3. Once the session is established, the nanoapp receives a
+ *    CHRE_EVENT_MSG_SESSION_OPENED event. If a failure occurred or the target
+ *    endpoint did not accept the session, a CHRE_EVENT_MSG_SESSION_CLOSED event
+ *    will be provided instead.
+ * 4. Assuming the session was opened successfully, the nanoapp can now send
+ *    messages over the session using chreMsgSend() and will receive messages
+ *    via CHRE_EVENT_MSG_FROM_ENDPOINT.
+ * 5. The session may be left open indefinitely, or closed by either endpoint,
+ *    or by the system on error or if one endpoint crashes/disconnects. If the
+ *    target endpoint crashes and then recovers, a new ready event will be
+ *    generated and communication can resume at step 2.
+ *
+ * As a server (session responder), the high-level flow is:
+ *
+ * 1. (Optional) Register one or more services via chreMsgPublishServices().
+ * 2. The nanoapp receives CHRE_EVENT_MSG_SESSION_OPENED when another endpoint
+ *    initiates a session. The session can either be used immediately, or the
+ *    nanoapp can use chreMsgSessionCloseAsync() to reject the session.
+ * 3. Once a session is established, it functions the same regardless of which
+ *    endpoint initiated the session.
+ *
+ * @since v1.11
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <chre/common.h>
+#include <chre/event.h>
+#include <chre/toolchain.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * The type of endpoint.
+ * Backing type: uint32_t.
+ */
+enum chreMsgEndpointType {
+  CHRE_MSG_ENDPOINT_TYPE_INVALID = 0,
+  CHRE_MSG_ENDPOINT_TYPE_HOST_FRAMEWORK = 1,
+  CHRE_MSG_ENDPOINT_TYPE_HOST_APP = 2,
+  CHRE_MSG_ENDPOINT_TYPE_HOST_NATIVE = 3,
+  CHRE_MSG_ENDPOINT_TYPE_NANOAPP = 4,
+  CHRE_MSG_ENDPOINT_TYPE_GENERIC = 5,
+};
+
+/**
+ * The service RPC format.
+ * Backing type: uint32_t.
+ */
+enum chreMsgEndpointServiceFormat {
+  CHRE_MSG_ENDPOINT_SERVICE_FORMAT_INVALID = 0,
+  CHRE_MSG_ENDPOINT_SERVICE_FORMAT_CUSTOM = 1,
+  CHRE_MSG_ENDPOINT_SERVICE_FORMAT_AIDL = 2,
+  CHRE_MSG_ENDPOINT_SERVICE_FORMAT_PW_RPC_PROTOBUF = 3,
+};
+
+/**
+ * The reason for a session closure event or an endpoint notification
+ * event.
+ * Backing type: uint8_t.
+ */
+enum chreMsgEndpointReason {
+  CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED = 0,
+  CHRE_MSG_ENDPOINT_REASON_OUT_OF_MEMORY = 1,
+  CHRE_MSG_ENDPOINT_REASON_TIMEOUT = 2,
+  CHRE_MSG_ENDPOINT_REASON_OPEN_ENDPOINT_SESSION_REQUEST_REJECTED = 3,
+  CHRE_MSG_ENDPOINT_REASON_CLOSE_ENDPOINT_SESSION_REQUESTED = 4,
+  CHRE_MSG_ENDPOINT_REASON_ENDPOINT_INVALID = 5,
+  CHRE_MSG_ENDPOINT_REASON_ENDPOINT_GONE = 6,
+  CHRE_MSG_ENDPOINT_REASON_ENDPOINT_CRASHED = 7,
+  CHRE_MSG_ENDPOINT_REASON_HUB_RESET = 8,
+  CHRE_MSG_ENDPOINT_REASON_PERMISSION_DENIED = 9,
+};
+
+/**
+ * The message hub ID reserved for the Android framework (Context Hub Service).
+ */
+#define CHRE_MSG_HUB_ID_ANDROID UINT64_C(0x416E64726F696400)
+
+#define CHRE_MSG_HUB_ID_INVALID UINT64_C(0)
+#define CHRE_MSG_HUB_ID_RESERVED UINT64_C(-1)
+#define CHRE_MSG_ENDPOINT_ID_INVALID UINT64_C(0)
+#define CHRE_MSG_ENDPOINT_ID_RESERVED UINT64_C(-1)
+#define CHRE_MSG_SESSION_ID_INVALID UINT16_MAX
+
+/**
+ * Wildcard hub ID for use with chreMsgConfigureEndpointReadyEvents() and
+ * chreMsgConfigureServiceReadyEvents().
+ */
+#define CHRE_MSG_HUB_ID_ANY CHRE_MSG_HUB_ID_INVALID
+
+/**
+ * Wildcard endpoint ID for use with chreMsgConfigureEndpointReadyEvents() and
+ * chreMsgSessionOpenAsync().
+ */
+#define CHRE_MSG_ENDPOINT_ID_ANY CHRE_MSG_ENDPOINT_ID_INVALID
+
+/**
+ * The maximum length of an endpoint's name.
+ */
+#define CHRE_MSG_MAX_NAME_LEN (51)
+
+/**
+ * The maximum length of a service descriptor (including null terminator).
+ */
+#define CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN (128)
+
+/**
+ * @see chreMsgPublishServices
+ */
+#define CHRE_MSG_MINIMUM_SERVICE_LIMIT UINT8_C(4)
+
+/**
+ * Produce an event ID in the block of IDs reserved for session-based messaging.
+ *
+ * Valid input range is [0, 15]. Do not add new events with ID > 15
+ * (see chre/event.h)
+ *
+ * @param offset Index into MSG event ID block; valid range is [0, 15].
+ *
+ * @defgroup CHRE_MSG_EVENT_ID
+ * @{
+ */
+#define CHRE_MSG_EVENT_ID(offset) (CHRE_EVENT_MSG_FIRST_EVENT + (offset))
+
+/**
+ * nanoappHandleEvent argument: struct chreMsgMessageFromEndpointData
+ *
+ * The format of the 'message' part of this structure is left undefined,
+ * and it's up to the nanoapp and endpoint to have an established protocol
+ * beforehand.
+ *
+ * On receiving the first message from an endpoint, the nanoapp can assume
+ * a session with the sessionId has been created and can be used to send
+ * messages to the endpoint. The nanoapp will receive a
+ * CHRE_EVENT_MSG_SESSION_CLOSED event when the session is closed.
+ *
+ * @since v1.11
+ */
+#define CHRE_EVENT_MSG_FROM_ENDPOINT CHRE_MSG_EVENT_ID(0)
+
+/**
+ * nanoappHandleEvent argument: struct chreMsgSessionInfo
+ *
+ * Indicates that a session with an endpoint has been opened.
+ *
+ * @since v1.11
+ */
+#define CHRE_EVENT_MSG_SESSION_OPENED CHRE_MSG_EVENT_ID(1)
+
+/**
+ * nanoappHandleEvent argument: struct chreMsgSessionInfo
+ *
+ * Indicates that a session with an endpoint has been closed.
+ *
+ * @since v1.11
+ */
+#define CHRE_EVENT_MSG_SESSION_CLOSED CHRE_MSG_EVENT_ID(2)
+
+/**
+ * nanoappHandleEvent argument: struct chreMsgEndpointReadyEvent
+ *
+ * Notifications event regarding a generic endpoint.
+ *
+ * @see chreConfigureEndpointNotifications
+ * @since v1.11
+ */
+#define CHRE_EVENT_MSG_ENDPOINT_READY CHRE_MSG_EVENT_ID(3)
+
+/**
+ * nanoappHandleEvent argument: struct chreMsgServiceReadyEvent
+ *
+ * Notifications event regarding a generic endpoint with a service.
+ *
+ * @see chreConfigureEndpointServiceNotifications
+ * @since v1.11
+ */
+#define CHRE_EVENT_MSG_SERVICE_READY CHRE_MSG_EVENT_ID(4)
+
+// NOTE: Do not add new events with ID > 15
+/** @} */
+
+/**
+ * Provides metadata for an endpoint.
+ */
+struct chreMsgEndpointInfo {
+  /**
+   * The message hub ID and endpoint ID of the endpoint.
+   */
+  uint64_t hubId;
+  uint64_t endpointId;
+
+  /**
+   * The type of the endpoint. One of chreMsgEndpointType enum values.
+   */
+  uint32_t type;
+
+  /**
+   * The version of the endpoint.
+   */
+  uint32_t version;
+
+  /**
+   * The required permissions of the endpoint, a bitmask of
+   * CHRE_MESSAGE_PERMISSION_* values.
+   */
+  uint32_t requiredPermissions;
+
+  /**
+   * The maximum size of a message that can be sent to the endpoint.
+   *
+   * For endpoints on CHRE_MSG_HUB_ID_ANDROID, this is the same as
+   * chreGetMessageToHostMaxSize().
+   */
+  uint32_t maxMessageSize;
+
+  /**
+   * The name of the endpoint, an ASCII null-terminated string. This name is
+   * specified by the endpoint when it is registered by its message hub.
+   */
+  char name[CHRE_MSG_MAX_NAME_LEN];
+};
+
+/**
+ * Provides metadata for an endpoint service.
+ */
+struct chreMsgServiceInfo {
+  /**
+   * The major version of the service.
+   */
+  uint32_t majorVersion;
+
+  /**
+   * The minor version of the service.
+   */
+  uint32_t minorVersion;
+
+  /**
+   * The descriptor of the service, an ASCII null-terminated string. This must
+   * be valid for the lifetime of the nanoapp.
+   */
+  const char *serviceDescriptor;
+
+  /**
+   * The format of the service. One of chreMsgEndpointServiceFormat enum values.
+   */
+  uint32_t serviceFormat;
+};
+
+/**
+ * Data provided with CHRE_EVENT_MSG_SESSION_OPENED,
+ * CHRE_EVENT_MSG_SESSION_CLOSED or chreGetSessionInfo().
+ */
+struct chreMsgSessionInfo {
+  /**
+   * The message hub ID and endpoint ID of the other party in the session.
+   */
+  uint64_t hubId;
+  uint64_t endpointId;
+
+  /**
+   * The descriptor of the service, an ASCII null-terminated string. This
+   * will be an empty string if the session was not opened with a service.
+   */
+  char serviceDescriptor[CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN];
+
+  /**
+   * The ID of the session.
+   */
+  uint16_t sessionId;
+
+  /**
+   * The reason for the event. Used for sessions closure. For all other uses,
+   * this value will be CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED. One of
+   * chreMsgEndpointReason enum values.
+   */
+  uint8_t reason;
+};
+
+/**
+ * Data provided with CHRE_EVENT_MSG_FROM_ENDPOINT.
+ */
+struct chreMsgMessageFromEndpointData {
+  /**
+   * Message type supplied by the endpoint.
+   */
+  uint32_t messageType;
+
+  /**
+   * Message permissions supplied by the endpoint. The format is specified by
+   * the CHRE_MESSAGE_PERMISSION_* values if the endpoint is a nanoapp, else
+   * it is specified by the endpoint. These permissions are enforced by CHRE.
+   * A nanoapp without the required permissions will not receive the message.
+   */
+  uint32_t messagePermissions;
+
+  /**
+   * The message from the endpoint.
+   *
+   * These contents are of a format that the endpoint and nanoapp must have
+   * established beforehand.
+   *
+   * This data is 'messageSize' bytes in length.  Note that if 'messageSize'
+   * is 0, this might contain NULL.
+   */
+  const void *message;
+
+  /**
+   * The size, in bytes of the following 'message'.
+   *
+   * This can be 0.
+   */
+  size_t messageSize;
+
+  /**
+   * The session ID of the message. A session is the active connection between
+   * two endpoints. The receiving nanoapp or endpoint initiated the session
+   * before sending this message. If the nanoapp has not yet received a
+   * message with this session ID, it can assume the session was created by
+   * the nanoapp or other endpoint. The nanoapp may send messages to the other
+   * endpoint with this session ID.
+   */
+  uint16_t sessionId;
+};
+
+/**
+ * Data provided in CHRE_EVENT_MSG_ENDPOINT_READY.
+ */
+struct chreMsgEndpointReadyEvent {
+  /**
+   * The message hub ID and endpoint ID of the endpoint.
+   */
+  uint64_t hubId;
+  uint64_t endpointId;
+};
+
+/**
+ * Data provided in CHRE_EVENT_MSG_SERVICE_READY.
+ */
+struct chreMsgServiceReadyEvent {
+  /**
+   * The message hub ID and endpoint ID of the endpoint.
+   */
+  uint64_t hubId;
+  uint64_t endpointId;
+
+  /**
+   * The descriptor of the service, an ASCII null-terminated string.
+   */
+  char serviceDescriptor[CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN];
+};
+
+/**
+ * Retrieves metadata for a given endpoint.
+ *
+ * If the given message hub ID and endpoint ID are not associated with a valid
+ * endpoint, this method will return false and info will not be populated.
+ *
+ * @param hubId The message hub ID of the endpoint for which to get info.
+ * @param endpointId The endpoint ID of the endpoint for which to get info.
+ * @param info The non-null pointer to where the metadata will be stored.
+ *
+ * @return true if info has been successfully populated.
+ *
+ * @since v1.11
+ */
+bool chreMsgGetEndpointInfo(uint64_t hubId, uint64_t endpointId,
+                            struct chreMsgEndpointInfo *info);
+
+/**
+ * Configures whether this nanoapp will receive updates regarding an endpoint
+ * that is connected with a message hub and a specific service.  The hubId can
+ * be CHRE_MSG_HUB_ID_ANY to configure notifications for matching endpoints that
+ * are connected with any message hub. The endpoint ID can be
+ * CHRE_MSG_ENDPOINT_ID_ANY to configure notifications for all endpoints that
+ * match the given hub.
+ *
+ * If this API succeeds, the nanoapp will receive endpoint notifications via
+ * CHRE_EVENT_MSG_ENDPOINT_READY with chreMsgEndpointReadyEvent.
+ *
+ * If one or more endpoints matching the filter are already ready when this
+ * function is called, CHRE_EVENT_MSG_ENDPOINT_READY will be immediately
+ * posted to this nanoapp.
+ *
+ * @param hubId The message hub ID of the endpoint for which to configure
+ *     notifications for all endpoints that are connected with any message hub.
+ * @param endpointId The endpoint ID of the endpoint for which to configure
+ *     notifications.
+ * @param enable true to enable notifications.
+ *
+ * @return true on success
+ *
+ * @since v1.11
+ */
+bool chreMsgConfigureEndpointReadyEvents(uint64_t hubId, uint64_t endpointId,
+                                         bool enable);
+
+/**
+ * Configures whether this nanoapp will receive updates regarding all endpoints
+ * that are connected with the message hub that provide the specified service.
+ *
+ * If this API succeeds, the nanoapp will receive endpoint notifications via
+ * CHRE_EVENT_MSG_SERVICE_READY with chreMsgServiceReadyEvent.
+ *
+ * If one or more endpoints matching the filter are already ready when this
+ * function is called, CHRE_EVENT_MSG_SERVICE_READY will be immediately posted
+ * to this nanoapp.
+ *
+ * @param hubId The message hub ID of the endpoint for which to configure
+ *     notifications for all endpoints that are connected with any message hub.
+ * @param serviceDescriptor The descriptor of the service associated with the
+ *     endpoint for which to configure notifications, a null-terminated ASCII
+ *     string. If not NULL, the underlying memory must outlive the notifications
+ *     configuration. If NULL, this will return false.
+ * @param enable true to enable notifications.
+ *
+ * @return true on success
+ *
+ * @see chreMsgConfigureEndpointReadyEvents
+ * @since v1.11
+ */
+bool chreMsgConfigureServiceReadyEvents(uint64_t hubId,
+                                        const char *serviceDescriptor,
+                                        bool enable);
+
+/**
+ * Retrieves metadata for a currently active session ID.
+ *
+ * If the given session ID is not associated with a valid session or if the
+ * caller nanoapp is not a participant in the session, this method will return
+ * false and info will not be populated.
+ *
+ * @param sessionId The session ID of the session for which to get info.
+ * @param info The non-null pointer to where the metadata will be stored.
+ *
+ * @return true if info has been successfully populated.
+ *
+ * @since v1.11
+ */
+bool chreMsgSessionGetInfo(uint16_t sessionId, struct chreMsgSessionInfo *info);
+
+/**
+ * Publishes services exposed by this nanoapp, which will be included with the
+ * endpoint metadata visible to other endpoints in the system.
+ *
+ * This function must be invoked from nanoappStart(), which ensures stable
+ * output of the list of services supported by the nanoapp. Calls made outside
+ * of nanoappStart() will have no effect.
+ *
+ * Although nanoapps are recommended to only call this API once with all
+ * services it intends to publish, if called multiple times, each call will
+ * append to the list of published services.
+ *
+ * The implementation must allow for a nanoapp to publish at least
+ * CHRE_MSG_MINIMUM_SERVICE_LIMIT services and at most UINT8_MAX services. If
+ * calling this function would result in exceeding the limit, the services must
+ * not be published and it must return false.
+ *
+ * @param services A non-null pointer to the list of services to publish.
+ * @param numServices The number of services to publish, i.e. the length of the
+ *     services array.
+ *
+ * @return true if the publishing is successful.
+ *
+ * @since v1.11
+ */
+bool chreMsgPublishServices(const struct chreMsgServiceInfo *services,
+                            size_t numServices);
+
+/**
+ * Opens a session with an endpoint.
+ *
+ * If this function returns true, the result of session initiation will be
+ * provided by a CHRE_EVENT_MSG_SESSION_OPENED or CHRE_EVENT_MSG_SESSION_CLOSED
+ * event containing the same hub ID, endpoint ID, and service descriptor
+ * parameters. Nanoapps may only open one session for each unique combination of
+ * parameters.
+ *
+ * @param hubId The message hub ID of the endpoint. Can be CHRE_MSG_HUB_ID_ANY
+ *     to open a session with the default endpoint.
+ * @param endpointId The endpoint ID of the endpoint. Can be
+ *     CHRE_MSG_ENDPOINT_ID_ANY to open a session with a specified service. The
+ *     service cannot be NULL in this case.
+ * @param serviceDescriptor The descriptor of the service associated with the
+ *     endpoint with which to open the session, a null-terminated ASCII string.
+ *     Can be NULL. The underlying memory must remain valid at least until the
+ *     session is closed - for example, it should be a pointer to a static const
+ *     variable hard-coded in the nanoapp.
+ *     NOTE: as event data supplied to nanoapps does not live beyond the
+ *     nanoappHandleEvent() invocation, it is NOT valid to use the serviceData
+ *     array provided inside chreMsgServiceReadyEvent here.
+ *
+ * @return true if the request was successfully dispatched, or false if a
+ *     synchronous error occurred, in which case no subsequent event will be
+ *     sent.
+ *
+ * @since v1.11
+ */
+bool chreMsgSessionOpenAsync(uint64_t hubId, uint64_t endpointId,
+                             const char *serviceDescriptor);
+
+/**
+ * Closes a session with an endpoint.
+ *
+ * If the given session ID is not associated with a valid session or if the
+ * calling nanoapp is not a participant in the session, this method will return
+ * false.
+ *
+ * The nanoapp will receive a CHRE_EVENT_MSG_SESSION_CLOSED event when the
+ * session teardown is complete. The session is immediately unavailable for
+ * sending. It is unspecified whether any in-flight messages sent by the
+ * other endpoint will be received prior to CHRE_EVENT_MSG_SESSION_CLOSED, but
+ * once this event is delivered, no further data will be received.
+ *
+ * @param sessionId ID of the session to close.
+ *
+ * @return true if the session closure process was initiated.
+ *
+ * @since v1.11
+ */
+bool chreMsgSessionCloseAsync(uint16_t sessionId);
+
+/**
+ * Send a message to an endpoint over an active session.
+ *
+ * This is similar to the stateless host message APIs, such as
+ * chreSendMessageWithPermissions(), but it supports sending data to an
+ * arbitrary endpoint, which could be a host app, another nanoapp, or something
+ * else.
+ *
+ * Messages are guaranteed to be delivered in the order they were sent. If an
+ * error occurs while attempting to deliver the message, the session will be
+ * closed by the system with a suitable reason provided in the data sent with
+ * CHRE_EVENT_MSG_SESSION_CLOSED. While this covers most scenarios, no explicit
+ * end-to-end acknowledgement is provided, and any internal timeouts and/or
+ * retries are implementation-dependent. Similar to chreMsgSessionCloseAsync(),
+ * if the session is closed by the other endpoint or system, it is unspecified
+ * whether any in-flight messages were delivered. The option to send reliable
+ * messages over a socket is planned for a future release. In the meantime, if
+ * full reliability is desired for host communication, use
+ * chreSendReliableMessageAsync().
+ *
+ * @param message Pointer to a block of memory to send to the other endpoint in
+ *     this session. NULL is acceptable only if messageSize is 0. This function
+ *     transfers ownership of the provided memory to the system, so the data
+ *     must stay valid and unmodified until freeCallback is invoked.
+ * @param messageSize The size, in bytes, of the given message. Maximum allowed
+ *     size for the destination endpoint is provided in chreMsgEndpointInfo.
+ * @param messageType An opaque value passed along with the message payload,
+ *     using an application/service-defined scheme.
+ * @param sessionId The session over which to send this message, which also
+ *     implicitly identifies the destination service (if used), endpoint, and
+ *     hub. Provided in chreMsgSessionInfo.
+ * @param messagePermissions Bitmask of permissions that must be held to receive
+ *     this message, and will be attributed to the recipient. Primarily relevant
+ *     when the destination endpoint is an Android application. Refer to
+ *     CHRE_MESSAGE_PERMISSIONS.
+ * @param freeCallback Invoked when the system no longer needs the memory
+ *     holding the message. Note that this does not necessarily mean that the
+ *     message has been delivered. If message is non-NULL, this must be
+ *     non-NULL, and if message is NULL, this must be NULL.
+ *
+ * @return true if the message was accepted for transmission, false otherwise.
+ *     Note that even if this method returns false, the freeCallback will be
+ *     invoked, if non-NULL. In either case, the freeCallback may be invoked
+ *     synchronously, so it must not call chreMsgSend() to avoid recursion.
+ *
+ * @since v1.11
+ */
+bool chreMsgSend(void *message, size_t messageSize, uint32_t messageType,
+                 uint16_t sessionId, uint32_t messagePermissions,
+                 chreMessageFreeFunction *freeCallback);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _CHRE_MSG_H_ */
diff --git a/chre_api/include/chre_api/chre/re.h b/chre_api/include/chre_api/chre/re.h
index 24ebff64..3987b013 100644
--- a/chre_api/include/chre_api/chre/re.h
+++ b/chre_api/include/chre_api/chre/re.h
@@ -73,11 +73,15 @@ extern "C" {
  */
 
 //! None of the optional capabilities are supported
-#define CHRE_CAPABILITIES_NONE                 (UINT32_C(0))
+#define CHRE_CAPABILITIES_NONE                          (UINT32_C(0))
 
 //! Support for reliable messages.
-//! @see chreSendReliableMessageAsync()
-#define CHRE_CAPABILITIES_RELIABLE_MESSAGES    (UINT32_C(1) << 0)
+//! @see chreSendReliableMessageAsync
+#define CHRE_CAPABILITIES_RELIABLE_MESSAGES             (UINT32_C(1) << 0)
+
+//! Support for generic endpoint messaging.
+//! @see chreMsgSend
+#define CHRE_CAPABILITIES_GENERIC_ENDPOINT_MESSAGES     (UINT32_C(1) << 1)
 
 /** @} */
 
diff --git a/chre_api/include/chre_api/chre/version.h b/chre_api/include/chre_api/chre/version.h
index 3dc4984d..467bb85e 100644
--- a/chre_api/include/chre_api/chre/version.h
+++ b/chre_api/include/chre_api/chre/version.h
@@ -171,11 +171,9 @@ extern "C" {
 /**
  * Value for version 1.11 of the Context Hub Runtime Environment API interface.
  *
- * This version of the CHRE API is shipped with Android 16. It adds definitions
- * for WWAN Cell Neighbors.
- *
- * @note This version of the CHRE API has not been finalized yet, and is
- * currently considered a preview that is subject to change.
+ * This version of the CHRE API is shipped with Android 16. It adds support for
+ * for session-based generic endpoint messaging (msg.h), BLE socket offload,
+ * remote source GNSS, and explicit WWAN cell neighbor capability indication.
  *
  * @see CHRE_API_VERSION
  */
@@ -281,6 +279,8 @@ uint32_t chreGetVersion(void);
  * to have code that can conditionally work around the bug on a buggy version.
  * Thus, we require this uniqueness to allow such a setup to work.
  *
+ * This platform ID is also the message hub ID for CHRE.
+ *
  * @return The platform ID.
  *
  * @see CHRE_EXTRACT_VENDOR_ID
diff --git a/chre_api/legacy/v1_10/chre/common.h b/chre_api/legacy/v1_10/chre/common.h
index beecc46b..61214fcf 100644
--- a/chre_api/legacy/v1_10/chre/common.h
+++ b/chre_api/legacy/v1_10/chre/common.h
@@ -136,7 +136,7 @@ enum chreError {
     //!< Do not exceed this value when adding new error codes
     CHRE_ERROR_LAST = UINT8_MAX,
 };
-// LINT.ThenChange(../../../../core/include/chre/core/api_manager_common.h)
+// LINT.ThenChange(../../../../util/include/chre/util/system/chre_error_util.h)
 
 /**
  * Generic data structure to indicate the result of an asynchronous operation.
diff --git a/chre_api/legacy/v1_6/chre/common.h b/chre_api/legacy/v1_6/chre/common.h
index 8f5292ee..1fb06d1f 100644
--- a/chre_api/legacy/v1_6/chre/common.h
+++ b/chre_api/legacy/v1_6/chre/common.h
@@ -121,7 +121,7 @@ enum chreError {
     //!< Do not exceed this value when adding new error codes
     CHRE_ERROR_LAST = UINT8_MAX,
 };
-// LINT.ThenChange(core/include/chre/core/api_manager_common.h)
+// LINT.ThenChange(util/include/chre/util/system/chre_error_util.h)
 
 /**
  * Generic data structure to indicate the result of an asynchronous operation.
diff --git a/chre_api/legacy/v1_7/chre/common.h b/chre_api/legacy/v1_7/chre/common.h
index 8f5292ee..1fb06d1f 100644
--- a/chre_api/legacy/v1_7/chre/common.h
+++ b/chre_api/legacy/v1_7/chre/common.h
@@ -121,7 +121,7 @@ enum chreError {
     //!< Do not exceed this value when adding new error codes
     CHRE_ERROR_LAST = UINT8_MAX,
 };
-// LINT.ThenChange(core/include/chre/core/api_manager_common.h)
+// LINT.ThenChange(util/include/chre/util/system/chre_error_util.h)
 
 /**
  * Generic data structure to indicate the result of an asynchronous operation.
diff --git a/chre_api/legacy/v1_8/chre/common.h b/chre_api/legacy/v1_8/chre/common.h
index 8e2df597..b5c2147e 100644
--- a/chre_api/legacy/v1_8/chre/common.h
+++ b/chre_api/legacy/v1_8/chre/common.h
@@ -121,7 +121,7 @@ enum chreError {
     //!< Do not exceed this value when adding new error codes
     CHRE_ERROR_LAST = UINT8_MAX,
 };
-// LINT.ThenChange(../../../../core/include/chre/core/api_manager_common.h)
+// LINT.ThenChange(../../../../util/include/chre/util/system/chre_error_util.h)
 
 /**
  * Generic data structure to indicate the result of an asynchronous operation.
diff --git a/chre_api/legacy/v1_9/chre/common.h b/chre_api/legacy/v1_9/chre/common.h
index 3b270af5..b53533bf 100644
--- a/chre_api/legacy/v1_9/chre/common.h
+++ b/chre_api/legacy/v1_9/chre/common.h
@@ -124,7 +124,7 @@ enum chreError {
     //!< Do not exceed this value when adding new error codes
     CHRE_ERROR_LAST = UINT8_MAX,
 };
-// LINT.ThenChange(../../../../core/include/chre/core/api_manager_common.h)
+// LINT.ThenChange(../../../../util/include/chre/util/system/chre_error_util.h)
 
 /**
  * Generic data structure to indicate the result of an asynchronous operation.
diff --git a/chre_flags.aconfig b/chre_flags.aconfig
index 4348fd4c..3707a8d0 100644
--- a/chre_flags.aconfig
+++ b/chre_flags.aconfig
@@ -148,3 +148,10 @@ flag {
     purpose: PURPOSE_BUGFIX
   }
 }
+
+flag {
+  name: "bt_socket_hal_supported"
+  namespace: "context_hub"
+  description: "Flag guarding whether a working implementation of the BT socket HAL is supported in the ContextHub HAL process or a stub version"
+  bug: "380946927"
+}
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
index 3d5485fb..8093eb50 100644
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -5,7 +5,6 @@ pw_add_library(chre.core STATIC
     include/chre/core/host_comms_manager.h
     include/chre/core/settings.h
     include/chre/core/audio_request_manager.h
-    include/chre/core/api_manager_common.h
     include/chre/core/wifi_request_manager.h
     include/chre/core/event_ref_queue.h
     include/chre/core/sensor_request_multiplexer.h
@@ -13,7 +12,6 @@ pw_add_library(chre.core STATIC
     include/chre/core/gnss_manager.h
     include/chre/core/init.h
     include/chre/core/timer_pool.h
-    include/chre/core/event_loop_common.h
     include/chre/core/sensor_type.h
     include/chre/core/wwan_request_manager.h
     include/chre/core/event_loop.h
@@ -35,6 +33,8 @@ pw_add_library(chre.core STATIC
     include/chre/core/event.h
     include/chre/core/ble_request.h
     include/chre/core/host_endpoint_manager.h
+    include/chre/core/ble_l2cap_coc_socket_data.h
+    include/chre/core/ble_socket_manager.h
   PUBLIC_INCLUDES
     include
   PUBLIC_DEPS
diff --git a/core/chre_message_hub_manager.cc b/core/chre_message_hub_manager.cc
index 96ed194b..7b3c46e8 100644
--- a/core/chre_message_hub_manager.cc
+++ b/core/chre_message_hub_manager.cc
@@ -17,35 +17,417 @@
 #ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
 
 #include "chre/core/chre_message_hub_manager.h"
-#include "chre/core/event_loop_common.h"
+#include "chre/core/event_loop.h"
 #include "chre/core/event_loop_manager.h"
 #include "chre/core/nanoapp.h"
+#include "chre/platform/context.h"
+#include "chre/platform/fatal_error.h"
+#include "chre/target_platform/log.h"
+#include "chre/util/conditional_lock_guard.h"
+#include "chre/util/lock_guard.h"
+#include "chre/util/nested_data_ptr.h"
+#include "chre/util/system/event_callbacks.h"
 #include "chre/util/system/message_common.h"
 #include "chre/util/system/message_router.h"
+#include "chre/util/system/service_helpers.h"
+#include "chre/util/system/system_callback_type.h"
 #include "chre/util/unique_ptr.h"
+#include "chre_api/chre.h"
+
+#include "pw_allocator/unique_ptr.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
 
 #include <cinttypes>
+#include <cstddef>
+#include <cstdlib>
+#include <cstring>
 #include <optional>
 
 using ::chre::message::Endpoint;
+using ::chre::message::ENDPOINT_ID_ANY;
+using ::chre::message::ENDPOINT_ID_INVALID;
 using ::chre::message::EndpointId;
 using ::chre::message::EndpointInfo;
 using ::chre::message::EndpointType;
+using ::chre::message::extractNanoappIdAndServiceId;
 using ::chre::message::Message;
+using ::chre::message::MESSAGE_HUB_ID_ANY;
+using ::chre::message::MESSAGE_HUB_ID_INVALID;
+using ::chre::message::MessageHubId;
+using ::chre::message::MessageHubInfo;
 using ::chre::message::MessageRouter;
 using ::chre::message::MessageRouterSingleton;
+using ::chre::message::Reason;
+using ::chre::message::RpcFormat;
+using ::chre::message::ServiceInfo;
 using ::chre::message::Session;
+using ::chre::message::SESSION_ID_INVALID;
+using ::chre::message::SessionId;
 
 namespace chre {
 
+namespace {
+
+//! Sends a ready event to the nanoapp with the given instance ID. If
+//! serviceDescriptor is null, then the ready event is for an endpoint, else it
+//! is for a service.
+template <typename T>
+void sendReadyEventToNanoapp(uint16_t nanoappInstanceId,
+                             MessageHubId messageHubId, EndpointId endpointId,
+                             const char *serviceDescriptor) {
+  static_assert(std::is_same_v<T, chreMsgServiceReadyEvent> ||
+                std::is_same_v<T, chreMsgEndpointReadyEvent>);
+
+  UniquePtr<T> event = MakeUnique<T>();
+  if (event.isNull()) {
+    FATAL_ERROR_OOM();
+    return;
+  }
+
+  event->hubId = messageHubId;
+  event->endpointId = endpointId;
+  if constexpr (std::is_same_v<T, chreMsgServiceReadyEvent>) {
+    std::strncpy(event->serviceDescriptor, serviceDescriptor,
+                 CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN);
+    event->serviceDescriptor[CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN - 1] = '\0';
+  }
+
+  EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(
+      std::is_same_v<T, chreMsgServiceReadyEvent>
+          ? CHRE_EVENT_MSG_SERVICE_READY
+          : CHRE_EVENT_MSG_ENDPOINT_READY,
+      event.release(), freeEventDataCallback, nanoappInstanceId);
+}
+
+//! Sends a ready event to the nanoapp with the given instance ID. If
+//! serviceDescriptor is null, then the ready event is for an endpoint, else it
+//! is for a service.
+void sendReadyEventToNanoapp(uint16_t nanoappInstanceId,
+                             MessageHubId messageHubId, EndpointId endpointId,
+                             const char *serviceDescriptor) {
+  if (serviceDescriptor == nullptr) {
+    sendReadyEventToNanoapp<chreMsgEndpointReadyEvent>(
+        nanoappInstanceId, messageHubId, endpointId, serviceDescriptor);
+  } else {
+    sendReadyEventToNanoapp<chreMsgServiceReadyEvent>(
+        nanoappInstanceId, messageHubId, endpointId, serviceDescriptor);
+  }
+}
+
+}  // anonymous namespace
+
+ChreMessageHubManager::ChreMessageHubManager()
+    : mAllocator(ChreMessageHubManager::onMessageFreeCallback,
+                 mFreeCallbackRecords, /* doEraseRecord= */ false) {}
+
+ChreMessageHubManager::~ChreMessageHubManager() {
+  mChreMessageHub.unregister();
+  mChreMessageHubCallback->clearManager();
+}
+
 void ChreMessageHubManager::init() {
+  ChreMessageHubCallback *callbackPtr =
+      memoryAlloc<ChreMessageHubCallback>(*this);
+  if (callbackPtr == nullptr) {
+    FATAL_ERROR_OOM();
+    return;
+  }
+  mChreMessageHubCallback =
+      pw::IntrusivePtr<ChreMessageHubCallback>(callbackPtr);
+
   std::optional<MessageRouter::MessageHub> chreMessageHub =
       MessageRouterSingleton::get()->registerMessageHub(
-          "CHRE", kChreMessageHubId, *this);
+          "CHRE", kChreMessageHubId, mChreMessageHubCallback);
   if (chreMessageHub.has_value()) {
     mChreMessageHub = std::move(*chreMessageHub);
   } else {
-    LOGE("Failed to register the CHRE MessageHub");
+    FATAL_ERROR("Failed to register the CHRE MessageHub");
+  }
+}
+
+bool ChreMessageHubManager::getEndpointInfo(MessageHubId hubId,
+                                            EndpointId endpointId,
+                                            chreMsgEndpointInfo &info) {
+  std::optional<EndpointInfo> endpointInfo =
+      MessageRouterSingleton::get()->getEndpointInfo(hubId, endpointId);
+  if (!endpointInfo.has_value()) {
+    return false;
+  }
+
+  info.hubId = hubId;
+  info.endpointId = endpointId;
+  info.type = toChreEndpointType(endpointInfo->type);
+  info.version = endpointInfo->version;
+  info.requiredPermissions = endpointInfo->requiredPermissions;
+  // TODO(b/404241918): populate maxMessageSize from MessageRouter
+  info.maxMessageSize = chreGetMessageToHostMaxSize();
+  std::strncpy(info.name, endpointInfo->name, CHRE_MAX_ENDPOINT_NAME_LEN);
+  info.name[CHRE_MAX_ENDPOINT_NAME_LEN - 1] = '\0';
+  return true;
+}
+
+bool ChreMessageHubManager::configureReadyEvents(
+    uint16_t nanoappInstanceId, EndpointId fromEndpointId, MessageHubId hubId,
+    EndpointId endpointId, const char *serviceDescriptor, bool enable) {
+  CHRE_ASSERT(inEventLoopThread());
+
+  if (hubId == MESSAGE_HUB_ID_INVALID && endpointId == ENDPOINT_ID_INVALID &&
+      serviceDescriptor == nullptr) {
+    LOGE(
+        "Invalid arguments to configureReadyEvents: hubId, endpointId and "
+        "serviceDescriptor cannot all be invalid");
+    return false;
+  }
+
+  if (!enable) {
+    disableReadyEvents(fromEndpointId, hubId, endpointId, serviceDescriptor);
+    return true;
+  }
+
+  if (!mEndpointReadyEventRequests.push_back(
+          EndpointReadyEventData{.fromEndpointId = fromEndpointId,
+                                 .messageHubId = hubId,
+                                 .endpointId = endpointId,
+                                 .serviceDescriptor = serviceDescriptor})) {
+    LOG_OOM();
+    return false;
+  }
+
+  std::optional<Endpoint> endpoint =
+      searchForEndpoint(hubId, endpointId, serviceDescriptor);
+  if (endpoint.has_value()) {
+    sendReadyEventToNanoapp(nanoappInstanceId, endpoint->messageHubId,
+                            endpoint->endpointId, serviceDescriptor);
+  }
+  return true;
+}
+
+bool ChreMessageHubManager::getSessionInfo(EndpointId fromEndpointId,
+                                           SessionId sessionId,
+                                           chreMsgSessionInfo &info) {
+  std::optional<Session> session = mChreMessageHub.getSessionWithId(sessionId);
+  if (!session.has_value()) {
+    return false;
+  }
+
+  bool initiatorIsNanoapp =
+      session->initiator.messageHubId == kChreMessageHubId &&
+      session->initiator.endpointId == fromEndpointId;
+  bool peerIsNanoapp = session->peer.messageHubId == kChreMessageHubId &&
+                       session->peer.endpointId == fromEndpointId;
+  if (!initiatorIsNanoapp && !peerIsNanoapp) {
+    LOGE("Nanoapp with ID 0x%" PRIx64
+         " is not the initiator or peer of session with ID %" PRIu16,
+         fromEndpointId, sessionId);
+    return false;
+  }
+
+  info.hubId = initiatorIsNanoapp ? session->peer.messageHubId
+                                  : session->initiator.messageHubId;
+  info.endpointId = initiatorIsNanoapp ? session->peer.endpointId
+                                       : session->initiator.endpointId;
+
+  if (session->hasServiceDescriptor) {
+    std::strncpy(info.serviceDescriptor, session->serviceDescriptor,
+                 CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN);
+    info.serviceDescriptor[CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN - 1] = '\0';
+  } else {
+    info.serviceDescriptor[0] = '\0';
+  }
+
+  info.sessionId = sessionId;
+  info.reason = chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED;
+  return true;
+}
+
+bool ChreMessageHubManager::openSessionAsync(EndpointId fromEndpointId,
+                                             MessageHubId toHubId,
+                                             EndpointId toEndpointId,
+                                             const char *serviceDescriptor) {
+  SessionId sessionId = EventLoopManagerSingleton::get()
+                            ->getChreMessageHubManager()
+                            .getMessageHub()
+                            .openSession(fromEndpointId, toHubId, toEndpointId,
+                                         serviceDescriptor);
+  return sessionId != SESSION_ID_INVALID;
+}
+
+bool ChreMessageHubManager::openDefaultSessionAsync(
+    EndpointId fromEndpointId, MessageHubId toHubId, EndpointId toEndpointId,
+    const char *serviceDescriptor) {
+  std::optional<Endpoint> endpoint =
+      searchForEndpoint(toHubId, toEndpointId, serviceDescriptor);
+  return endpoint.has_value() &&
+         openSessionAsync(fromEndpointId, endpoint->messageHubId,
+                          endpoint->endpointId, serviceDescriptor);
+}
+
+bool ChreMessageHubManager::closeSession(EndpointId fromEndpointId,
+                                         SessionId sessionId) {
+  std::optional<Session> session = mChreMessageHub.getSessionWithId(sessionId);
+  if (!session.has_value()) {
+    LOGE("Failed to close session with ID %" PRIu16 ": session not found",
+         sessionId);
+    return false;
+  }
+
+  Endpoint nanoapp(kChreMessageHubId, fromEndpointId);
+  if (session->initiator != nanoapp && session->peer != nanoapp) {
+    LOGE("Nanoapp with ID 0x%" PRIx64
+         " is not the initiator or peer of session with ID %" PRIu16,
+         fromEndpointId, sessionId);
+    return false;
+  }
+  return mChreMessageHub.closeSession(sessionId);
+}
+
+bool ChreMessageHubManager::sendMessage(void *message, size_t messageSize,
+                                        uint32_t messageType,
+                                        uint16_t sessionId,
+                                        uint32_t messagePermissions,
+                                        chreMessageFreeFunction *freeCallback,
+                                        EndpointId fromEndpointId) {
+  bool success = false;
+  if ((message == nullptr) != (freeCallback == nullptr)) {
+    // We don't allow this because a null callback with non-null message is
+    // susceptible to bugs where the nanoapp modifies the data while it is still
+    // being used by the system, and a non-null callback with null message is
+    // not meaningful since there is no data to release and we make no
+    // guarantees about when the callback is invoked.
+    LOGE("Mixing null and non-null message and free callback is not allowed");
+  } else {
+    pw::UniquePtr<std::byte[]> messageData =
+        mAllocator.MakeUniqueArrayWithCallback(
+            reinterpret_cast<std::byte *>(message), messageSize,
+            MessageFreeCallbackData{.freeCallback = freeCallback,
+                                    .nanoappId = fromEndpointId});
+    if (messageData == nullptr) {
+      LOG_OOM();
+    } else {
+      success = mChreMessageHub.sendMessage(std::move(messageData), messageType,
+                                            messagePermissions, sessionId,
+                                            fromEndpointId);
+    }
+  }
+
+  if (!success && freeCallback != nullptr) {
+    freeCallback(message, messageSize);
+  }
+  return success;
+}
+
+bool ChreMessageHubManager::publishServices(
+    EndpointId fromEndpointId, const chreMsgServiceInfo *serviceInfos,
+    size_t numServices) {
+  CHRE_ASSERT(inEventLoopThread());
+
+  LockGuard<Mutex> lockGuard(mNanoappPublishedServicesMutex);
+  if (!validateServicesLocked(fromEndpointId, serviceInfos, numServices)) {
+    return false;
+  }
+
+  if (!mNanoappPublishedServices.reserve(mNanoappPublishedServices.size() +
+                                         numServices)) {
+    LOG_OOM();
+    return false;
+  }
+
+  for (size_t i = 0; i < numServices; ++i) {
+    // Cannot fail as we reserved space for the push above
+    mNanoappPublishedServices.push_back(NanoappServiceData{
+        .nanoappId = fromEndpointId, .serviceInfo = serviceInfos[i]});
+  }
+  return true;
+}
+
+void ChreMessageHubManager::unregisterEndpoint(EndpointId endpointId) {
+  UniquePtr<EndpointId> endpointIdPtr = MakeUnique<EndpointId>(endpointId);
+  if (endpointIdPtr.isNull()) {
+    FATAL_ERROR_OOM();
+    return;
+  }
+
+  EventLoopManagerSingleton::get()->deferCallback(
+      SystemCallbackType::EndpointCleanupNanoappEvent, std::move(endpointIdPtr),
+      [](SystemCallbackType /* type */, UniquePtr<EndpointId> &&endpointId) {
+        EventLoopManagerSingleton::get()
+            ->getChreMessageHubManager()
+            .cleanupEndpointResources(*endpointId);
+      });
+
+  mChreMessageHub.unregisterEndpoint(endpointId);
+}
+
+void ChreMessageHubManager::cleanupEndpointResources(EndpointId endpointId) {
+  CHRE_ASSERT(inEventLoopThread());
+
+  {
+    LockGuard<Mutex> lockGuard(mNanoappPublishedServicesMutex);
+    for (size_t i = 0; i < mNanoappPublishedServices.size();) {
+      if (mNanoappPublishedServices[i].nanoappId == endpointId) {
+        mNanoappPublishedServices.erase(i);
+      } else {
+        ++i;
+      }
+    }
+  }
+
+  for (size_t i = 0; i < mEndpointReadyEventRequests.size(); ++i) {
+    if (mEndpointReadyEventRequests[i].fromEndpointId == endpointId) {
+      mEndpointReadyEventRequests.erase(i);
+    } else {
+      ++i;
+    }
+  }
+}
+
+chreMsgEndpointType ChreMessageHubManager::toChreEndpointType(
+    EndpointType type) {
+  switch (type) {
+    case EndpointType::HOST_FRAMEWORK:
+      return chreMsgEndpointType::CHRE_MSG_ENDPOINT_TYPE_HOST_FRAMEWORK;
+    case EndpointType::HOST_APP:
+      return chreMsgEndpointType::CHRE_MSG_ENDPOINT_TYPE_HOST_APP;
+    case EndpointType::HOST_NATIVE:
+      return chreMsgEndpointType::CHRE_MSG_ENDPOINT_TYPE_HOST_NATIVE;
+    case EndpointType::NANOAPP:
+      return chreMsgEndpointType::CHRE_MSG_ENDPOINT_TYPE_NANOAPP;
+    case EndpointType::GENERIC:
+      return chreMsgEndpointType::CHRE_MSG_ENDPOINT_TYPE_GENERIC;
+    default:
+      LOGE("Unknown endpoint type: %" PRIu8, type);
+      return chreMsgEndpointType::CHRE_MSG_ENDPOINT_TYPE_INVALID;
+  }
+}
+
+chreMsgEndpointReason ChreMessageHubManager::toChreEndpointReason(
+    Reason reason) {
+  switch (reason) {
+    case Reason::UNSPECIFIED:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED;
+    case Reason::OUT_OF_MEMORY:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_OUT_OF_MEMORY;
+    case Reason::TIMEOUT:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_TIMEOUT;
+    case Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED:
+      return chreMsgEndpointReason::
+          CHRE_MSG_ENDPOINT_REASON_OPEN_ENDPOINT_SESSION_REQUEST_REJECTED;
+    case Reason::CLOSE_ENDPOINT_SESSION_REQUESTED:
+      return chreMsgEndpointReason::
+          CHRE_MSG_ENDPOINT_REASON_CLOSE_ENDPOINT_SESSION_REQUESTED;
+    case Reason::ENDPOINT_INVALID:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_ENDPOINT_INVALID;
+    case Reason::ENDPOINT_GONE:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_ENDPOINT_GONE;
+    case Reason::ENDPOINT_CRASHED:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_ENDPOINT_CRASHED;
+    case Reason::HUB_RESET:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_HUB_RESET;
+    case Reason::PERMISSION_DENIED:
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_PERMISSION_DENIED;
+    default:
+      LOGE("Unknown endpoint reason: %" PRIu8, reason);
+      return chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED;
   }
 }
 
@@ -71,7 +453,7 @@ void ChreMessageHubManager::onMessageToNanoappCallback(
          data->messageToNanoapp.messagePermissions);
   } else if (!EventLoopManagerSingleton::get()
                   ->getEventLoop()
-                  .distributeEventSync(CHRE_EVENT_MESSAGE_FROM_ENDPOINT,
+                  .distributeEventSync(CHRE_EVENT_MSG_FROM_ENDPOINT,
                                        &data->messageToNanoapp,
                                        nanoapp->getInstanceId())) {
     LOGE("Unable to distribute message to nanoapp with ID 0x%" PRIx64,
@@ -89,35 +471,350 @@ void ChreMessageHubManager::onMessageToNanoappCallback(
   }
 }
 
-void ChreMessageHubManager::onSessionClosedCallback(
-    SystemCallbackType /* type */,
-    UniquePtr<SessionClosedCallbackData> &&data) {
+void ChreMessageHubManager::onSessionStateChangedCallback(
+    SystemCallbackType /* type */, UniquePtr<SessionCallbackData> &&data) {
   Nanoapp *nanoapp =
       EventLoopManagerSingleton::get()->getEventLoop().findNanoappByAppId(
           data->nanoappId);
   if (nanoapp == nullptr) {
     LOGE("Unable to find nanoapp with ID 0x%" PRIx64
          " to close the session with ID %" PRIu16,
-         data->nanoappId, data->sessionClosedData.sessionId);
+         data->nanoappId, data->sessionData.sessionId);
     return;
   }
 
   bool success =
       EventLoopManagerSingleton::get()->getEventLoop().distributeEventSync(
-          CHRE_EVENT_ENDPOINT_SESSION_CLOSED, &data->sessionClosedData,
-          nanoapp->getInstanceId());
+          data->isClosed ? CHRE_EVENT_MSG_SESSION_CLOSED
+                         : CHRE_EVENT_MSG_SESSION_OPENED,
+          &data->sessionData, nanoapp->getInstanceId());
   if (!success) {
     LOGE("Unable to process session closed event to nanoapp with ID 0x%" PRIx64,
          nanoapp->getAppId());
   }
 }
 
-bool ChreMessageHubManager::onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
-                                              size_t length,
-                                              uint32_t messageType,
-                                              uint32_t messagePermissions,
-                                              const Session &session,
-                                              bool sentBySessionInitiator) {
+void ChreMessageHubManager::onSessionOpenCompleteCallback(
+    uint16_t /* type */, void *data, void * /* extraData */) {
+  NestedDataPtr<SessionId> sessionId(data);
+  EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .getMessageHub()
+      .onSessionOpenComplete(sessionId);
+}
+
+void ChreMessageHubManager::onMessageFreeCallback(
+    std::byte *message, size_t /* length */,
+    MessageFreeCallbackData && /* callbackData */) {
+  EventLoopManagerSingleton::get()->deferCallback(
+      SystemCallbackType::EndpointMessageFreeEvent, message,
+      ChreMessageHubManager::handleMessageFreeCallback);
+}
+
+void ChreMessageHubManager::handleMessageFreeCallback(uint16_t /* type */,
+                                                      void *data,
+                                                      void * /* extraData */) {
+  std::optional<CallbackAllocator<MessageFreeCallbackData>::CallbackRecord>
+      record = EventLoopManagerSingleton::get()
+                   ->getChreMessageHubManager()
+                   .getAndRemoveFreeCallbackRecord(data);
+  if (!record.has_value()) {
+    LOGE("Unable to find free callback record for message with message: %p",
+         data);
+    return;
+  }
+
+  if (record->metadata.freeCallback == nullptr) {
+    return;
+  }
+
+  EventLoopManagerSingleton::get()->getEventLoop().invokeMessageFreeFunction(
+      record->metadata.nanoappId, record->metadata.freeCallback,
+      record->message, record->messageSize);
+}
+
+void ChreMessageHubManager::onSessionStateChanged(
+    const Session &session, std::optional<Reason> reason) {
+  for (const Endpoint &endpoint : {session.initiator, session.peer}) {
+    if (endpoint.messageHubId != kChreMessageHubId) {
+      continue;
+    }
+
+    auto sessionCallbackData = MakeUnique<SessionCallbackData>();
+    if (sessionCallbackData.isNull()) {
+      FATAL_ERROR_OOM();
+      return;
+    }
+
+    const Endpoint &otherParty =
+        session.initiator == endpoint ? session.peer : session.initiator;
+    uint64_t nanoappId = endpoint.endpointId;
+    sessionCallbackData->nanoappId = nanoappId;
+    sessionCallbackData->isClosed = reason.has_value();
+    sessionCallbackData->sessionData = {
+        .hubId = otherParty.messageHubId,
+        .endpointId = otherParty.endpointId,
+        .sessionId = session.sessionId,
+    };
+    sessionCallbackData->sessionData.reason =
+        reason.has_value()
+            ? toChreEndpointReason(*reason)
+            : chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED;
+    if (session.serviceDescriptor[0] != '\0') {
+      std::strncpy(sessionCallbackData->sessionData.serviceDescriptor,
+                   session.serviceDescriptor,
+                   CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN);
+      sessionCallbackData->sessionData
+          .serviceDescriptor[CHRE_MSG_MAX_SERVICE_DESCRIPTOR_LEN - 1] = '\0';
+    } else {
+      sessionCallbackData->sessionData.serviceDescriptor[0] = '\0';
+    }
+
+    EventLoopManagerSingleton::get()->deferCallback(
+        SystemCallbackType::EndpointSessionStateChangedEvent,
+        std::move(sessionCallbackData),
+        ChreMessageHubManager::onSessionStateChangedCallback);
+
+    if (session.initiator == session.peer) {
+      // Session between self - only deliver one event
+      return;
+    }
+  }
+}
+
+//! Called when a session open is requested.
+void ChreMessageHubManager::onSessionOpenComplete(
+    message::SessionId sessionId) {
+  EventLoopManagerSingleton::get()->deferCallback(
+      SystemCallbackType::EndpointSessionRequestedEvent,
+      NestedDataPtr<SessionId>(sessionId),
+      ChreMessageHubManager::onSessionOpenCompleteCallback);
+}
+
+void ChreMessageHubManager::onEndpointReadyEvent(MessageHubId messageHubId,
+                                                 EndpointId endpointId) {
+  CHRE_ASSERT(inEventLoopThread());
+
+  for (size_t i = 0; i < mEndpointReadyEventRequests.size(); ++i) {
+    EndpointReadyEventData &data = mEndpointReadyEventRequests[i];
+    bool messageHubIdMatches = data.messageHubId == MESSAGE_HUB_ID_ANY ||
+                               data.messageHubId == messageHubId;
+    bool endpointIdMatches =
+        data.endpointId == ENDPOINT_ID_ANY || data.endpointId == endpointId;
+    if (messageHubIdMatches && endpointIdMatches) {
+      Nanoapp *nanoapp =
+          EventLoopManagerSingleton::get()->getEventLoop().findNanoappByAppId(
+              data.fromEndpointId);
+      if (nanoapp == nullptr) {
+        LOGW("Could not find nanoapp with ID 0x%" PRIx64 " to send ready event",
+             data.fromEndpointId);
+        continue;
+      }
+
+      if (data.serviceDescriptor == nullptr ||
+          MessageRouterSingleton::get()->doesEndpointHaveService(
+              messageHubId, endpointId, data.serviceDescriptor)) {
+        sendReadyEventToNanoapp(nanoapp->getInstanceId(), messageHubId,
+                                endpointId, data.serviceDescriptor);
+      }
+    }
+  }
+}
+
+MessageHubId ChreMessageHubManager::findDefaultMessageHubId(
+    EndpointId endpointId) {
+  struct SearchContext {
+    MessageHubId toMessageHubId = MESSAGE_HUB_ID_INVALID;
+    EndpointId toEndpointId;
+  };
+  SearchContext context = {
+      .toEndpointId = endpointId,
+  };
+
+  MessageRouterSingleton::get()->forEachEndpoint(
+      [&context](const MessageHubInfo &hubInfo,
+                 const EndpointInfo &endpointInfo) {
+        if (context.toMessageHubId == MESSAGE_HUB_ID_INVALID &&
+            endpointInfo.id == context.toEndpointId) {
+          context.toMessageHubId = hubInfo.id;
+        }
+      });
+  return context.toMessageHubId;
+}
+
+bool ChreMessageHubManager::doesNanoappHaveLegacyService(uint64_t nanoappId,
+                                                         uint64_t serviceId) {
+  struct SearchContext {
+    uint64_t nanoappId;
+    uint64_t serviceId;
+    bool found;
+  };
+  SearchContext context = {
+      .nanoappId = nanoappId,
+      .serviceId = serviceId,
+      .found = false,
+  };
+
+  EventLoopManagerSingleton::get()->getEventLoop().forEachNanoapp(
+      [](const Nanoapp *nanoapp, void *data) {
+        SearchContext *context = static_cast<SearchContext *>(data);
+        if (!context->found && nanoapp->getAppId() == context->nanoappId) {
+          context->found = nanoapp->hasRpcService(context->serviceId);
+        }
+      },
+      &context);
+  return context.found;
+}
+
+bool ChreMessageHubManager::validateServicesLocked(
+    uint64_t nanoappId, const chreMsgServiceInfo *serviceInfos,
+    size_t numServices) {
+  if (serviceInfos == nullptr || numServices == 0) {
+    LOGE("Failed to publish service for nanoapp with ID 0x%" PRIx64
+         ": serviceInfos is null or numServices is 0",
+         nanoappId);
+    return false;
+  }
+
+  for (size_t i = 0; i < numServices; ++i) {
+    const chreMsgServiceInfo &serviceInfo = serviceInfos[i];
+
+    if (serviceInfo.serviceDescriptor == nullptr ||
+        serviceInfo.serviceDescriptor[0] == '\0') {
+      LOGE("Failed to publish service for nanoapp with ID 0x%" PRIx64
+           ": service descriptor is null or empty",
+           nanoappId);
+      return false;
+    }
+
+    uint64_t unused;
+    if (extractNanoappIdAndServiceId(serviceInfo.serviceDescriptor, unused,
+                                     unused)) {
+      LOGE("Failed to publish service for nanoapp with ID 0x%" PRIx64
+           ": service descriptor is in the legacy format",
+           nanoappId);
+      return false;
+    }
+
+    for (const NanoappServiceData &service : mNanoappPublishedServices) {
+      if (std::strcmp(service.serviceInfo.serviceDescriptor,
+                      serviceInfo.serviceDescriptor) == 0) {
+        LOGE("Failed to publish service for nanoapp with ID 0x%" PRIx64
+             ": service descriptor: %s is already published by another "
+             "nanoapp",
+             nanoappId, service.serviceInfo.serviceDescriptor);
+        return false;
+      }
+    }
+
+    for (size_t j = i + 1; j < numServices; ++j) {
+      if (std::strcmp(serviceInfo.serviceDescriptor,
+                      serviceInfos[j].serviceDescriptor)) {
+        LOGE("Failed to publish service for nanoapp with ID 0x%" PRIx64
+             ": service descriptor: %s repeats in list of services to publish",
+             nanoappId, serviceInfo.serviceDescriptor);
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+std::optional<Endpoint> ChreMessageHubManager::searchForEndpoint(
+    MessageHubId messageHubId, EndpointId endpointId,
+    const char *serviceDescriptor) {
+  if (endpointId == ENDPOINT_ID_INVALID) {
+    if (serviceDescriptor == nullptr) {
+      LOGD(
+          "Failed to search for an endpoint: no endpoint ID or service "
+          "descriptor");
+      return std::nullopt;
+    }
+    return MessageRouterSingleton::get()->getEndpointForService(
+        messageHubId, serviceDescriptor);
+  }
+
+  if (serviceDescriptor != nullptr) {
+    if (messageHubId == MESSAGE_HUB_ID_INVALID) {
+      LOGD(
+          "Failed to search for an endpoint: no message hub ID provided with "
+          "endpoint and service descriptor");
+      return std::nullopt;
+    }
+
+    if (!MessageRouterSingleton::get()->doesEndpointHaveService(
+            messageHubId, endpointId, serviceDescriptor)) {
+      LOGD("Failed to search for an endpoint: endpoint 0x%" PRIx64
+           " on hub 0x%" PRIx64 " does not have service %s",
+           messageHubId, endpointId, serviceDescriptor);
+      return std::nullopt;
+    }
+    return Endpoint(messageHubId, endpointId);
+  }
+
+  if (messageHubId == MESSAGE_HUB_ID_INVALID) {
+    messageHubId = findDefaultMessageHubId(endpointId);
+    if (messageHubId == MESSAGE_HUB_ID_INVALID) {
+      LOGD(
+          "Failed to search for an endpoint: no default message hub ID "
+          "found");
+      return std::nullopt;
+    }
+  } else if (!MessageRouterSingleton::get()
+                  ->getEndpointInfo(messageHubId, endpointId)
+                  .has_value()) {
+    LOGD("Failed to search for an endpoint: endpoint 0x%" PRIx64
+         " on hub 0x%" PRIx64 " does not exist",
+         messageHubId, endpointId);
+    return std::nullopt;
+  }
+  return Endpoint(messageHubId, endpointId);
+}
+
+void ChreMessageHubManager::disableReadyEvents(EndpointId fromEndpointId,
+                                               MessageHubId hubId,
+                                               EndpointId endpointId,
+                                               const char *serviceDescriptor) {
+  for (size_t i = 0; i < mEndpointReadyEventRequests.size(); ++i) {
+    EndpointReadyEventData &request = mEndpointReadyEventRequests[i];
+    if (request.fromEndpointId == fromEndpointId &&
+        request.messageHubId == hubId && request.endpointId == endpointId) {
+      bool servicesAreNull =
+          request.serviceDescriptor == nullptr && serviceDescriptor == nullptr;
+      bool servicesAreSame =
+          request.serviceDescriptor != nullptr &&
+          serviceDescriptor != nullptr &&
+          std::strcmp(request.serviceDescriptor, serviceDescriptor) == 0;
+      if (servicesAreNull || servicesAreSame) {
+        mEndpointReadyEventRequests.erase(i);
+        break;
+      }
+    }
+  }
+}
+
+RpcFormat ChreMessageHubManager::toMessageRpcFormat(
+    chreMsgEndpointServiceFormat format) {
+  switch (format) {
+    case chreMsgEndpointServiceFormat::CHRE_MSG_ENDPOINT_SERVICE_FORMAT_AIDL:
+      return RpcFormat::AIDL;
+    case chreMsgEndpointServiceFormat::
+        CHRE_MSG_ENDPOINT_SERVICE_FORMAT_PW_RPC_PROTOBUF:
+      return RpcFormat::PW_RPC_PROTOBUF;
+    default:
+      return RpcFormat::CUSTOM;
+  }
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::clearManager() {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  mChreMessageHubManager = nullptr;
+}
+
+bool ChreMessageHubManager::ChreMessageHubCallback::onMessageReceived(
+    pw::UniquePtr<std::byte[]> &&data, uint32_t messageType,
+    uint32_t messagePermissions, const Session &session,
+    bool sentBySessionInitiator) {
   Endpoint receiver = sentBySessionInitiator ? session.peer : session.initiator;
   auto messageCallbackData = MakeUnique<MessageCallbackData>();
   if (messageCallbackData.isNull()) {
@@ -129,61 +826,195 @@ bool ChreMessageHubManager::onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
       .messageType = messageType,
       .messagePermissions = messagePermissions,
       .message = data.get(),
-      .messageSize = length,
+      .messageSize = data.size(),
       .sessionId = session.sessionId,
   };
   messageCallbackData->data = std::move(data);
   messageCallbackData->nanoappId = receiver.endpointId;
 
-  EventLoopManagerSingleton::get()->deferCallback(
+  return EventLoopManagerSingleton::get()->deferCallback(
       SystemCallbackType::EndpointMessageToNanoappEvent,
       std::move(messageCallbackData),
       ChreMessageHubManager::onMessageToNanoappCallback);
-  return true;
 }
 
-void ChreMessageHubManager::onSessionClosed(const Session &session) {
-  auto sessionClosedCallbackData = MakeUnique<SessionClosedCallbackData>();
-  if (sessionClosedCallbackData.isNull()) {
-    LOG_OOM();
+void ChreMessageHubManager::ChreMessageHubCallback::onSessionOpenRequest(
+    const Session &session) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mChreMessageHubManager == nullptr) {
+    LOGW("The ChreMessageHubManager has been destroyed.");
     return;
   }
 
-  Endpoint otherParty;
-  uint64_t nanoappId;
-  if (session.initiator.messageHubId == kChreMessageHubId) {
-    otherParty = session.peer;
-    nanoappId = session.initiator.endpointId;
-  } else {
-    otherParty = session.initiator;
-    nanoappId = session.peer.endpointId;
+  mChreMessageHubManager->onSessionOpenComplete(session.sessionId);
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::onSessionOpened(
+    const Session &session) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mChreMessageHubManager == nullptr) {
+    LOGW("The ChreMessageHubManager has been destroyed.");
+    return;
   }
 
-  sessionClosedCallbackData->sessionClosedData = {
-      .hubId = otherParty.messageHubId,
-      .endpointId = otherParty.endpointId,
-      .sessionId = session.sessionId,
-  };
-  sessionClosedCallbackData->nanoappId = nanoappId;
+  mChreMessageHubManager->onSessionStateChanged(session,
+                                                /* reason= */ std::nullopt);
+}
 
-  EventLoopManagerSingleton::get()->deferCallback(
-      SystemCallbackType::EndpointSessionClosedEvent,
-      std::move(sessionClosedCallbackData),
-      ChreMessageHubManager::onSessionClosedCallback);
+void ChreMessageHubManager::ChreMessageHubCallback::onSessionClosed(
+    const Session &session, Reason reason) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mChreMessageHubManager == nullptr) {
+    LOGW("The ChreMessageHubManager has been destroyed.");
+    return;
+  }
+
+  mChreMessageHubManager->onSessionStateChanged(session, reason);
 }
 
-void ChreMessageHubManager::forEachEndpoint(
+void ChreMessageHubManager::ChreMessageHubCallback::forEachEndpoint(
     const pw::Function<bool(const EndpointInfo &)> &function) {
   EventLoopManagerSingleton::get()->getEventLoop().onMatchingNanoappEndpoint(
       function);
 }
 
-std::optional<EndpointInfo> ChreMessageHubManager::getEndpointInfo(
+std::optional<EndpointInfo>
+ChreMessageHubManager::ChreMessageHubCallback::getEndpointInfo(
     EndpointId endpointId) {
   return EventLoopManagerSingleton::get()->getEventLoop().getEndpointInfo(
       endpointId);
 }
 
+std::optional<EndpointId>
+ChreMessageHubManager::ChreMessageHubCallback::getEndpointForService(
+    const char *serviceDescriptor) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mChreMessageHubManager == nullptr) {
+    LOGW("The ChreMessageHubManager has been destroyed.");
+    return std::nullopt;
+  }
+
+  if (serviceDescriptor == nullptr || serviceDescriptor[0] == '\0') {
+    return std::nullopt;
+  }
+
+  {
+    ConditionalLockGuard<Mutex> lockGuard(
+        mChreMessageHubManager->mNanoappPublishedServicesMutex,
+        !inEventLoopThread());
+    for (const NanoappServiceData &service :
+         mChreMessageHubManager->mNanoappPublishedServices) {
+      if (std::strcmp(serviceDescriptor,
+                      service.serviceInfo.serviceDescriptor) == 0) {
+        return service.nanoappId;
+      }
+    }
+  }
+
+  // Check for the legacy service format
+  uint64_t nanoappId;
+  uint64_t serviceId;
+  return extractNanoappIdAndServiceId(serviceDescriptor, nanoappId,
+                                      serviceId) &&
+                 mChreMessageHubManager->doesNanoappHaveLegacyService(nanoappId,
+                                                                      serviceId)
+             ? std::make_optional(nanoappId)
+             : std::nullopt;
+}
+
+bool ChreMessageHubManager::ChreMessageHubCallback::doesEndpointHaveService(
+    EndpointId endpointId, const char *serviceDescriptor) {
+  // Endpoints are unique, so if we find it, then the endpoint has the service
+  // if and only if the endpoint ID matches the endpoint ID we are looking for
+  std::optional<EndpointId> endpoint = getEndpointForService(serviceDescriptor);
+  return endpoint.has_value() && endpoint.value() == endpointId;
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::forEachService(
+    const pw::Function<bool(const EndpointInfo &, const ServiceInfo &)>
+        &function) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mChreMessageHubManager == nullptr) {
+    LOGW("The ChreMessageHubManager has been destroyed.");
+    return;
+  }
+
+  {
+    ConditionalLockGuard<Mutex> lockGuard(
+        mChreMessageHubManager->mNanoappPublishedServicesMutex,
+        !inEventLoopThread());
+    for (const NanoappServiceData &service :
+         mChreMessageHubManager->mNanoappPublishedServices) {
+      std::optional<EndpointInfo> endpointInfo =
+          EventLoopManagerSingleton::get()->getEventLoop().getEndpointInfo(
+              service.nanoappId);
+      if (endpointInfo.has_value()) {
+        ServiceInfo serviceInfo(service.serviceInfo.serviceDescriptor,
+                                service.serviceInfo.majorVersion,
+                                service.serviceInfo.minorVersion,
+                                mChreMessageHubManager->toMessageRpcFormat(
+                                    static_cast<chreMsgEndpointServiceFormat>(
+                                        service.serviceInfo.serviceFormat)));
+        if (function(endpointInfo.value(), serviceInfo)) {
+          return;
+        }
+      }
+    }
+  }
+
+  EventLoopManagerSingleton::get()->getEventLoop().onMatchingNanoappService(
+      function);
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::onHubRegistered(
+    const MessageHubInfo & /*info*/) {
+  // We don't depend on this notification.
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::onHubUnregistered(
+    MessageHubId /*id*/) {
+  // We don't depend on this notification.
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::onEndpointRegistered(
+    MessageHubId messageHubId, EndpointId endpointId) {
+  if (messageHubId == MESSAGE_HUB_ID_INVALID ||
+      endpointId == ENDPOINT_ID_INVALID) {
+    LOGE(
+        "Invalid input to onEndpointRegistered: %s %s",
+        messageHubId == MESSAGE_HUB_ID_INVALID ? "messageHubId is invalid" : "",
+        endpointId == ENDPOINT_ID_INVALID ? "endpointId is invalid" : "");
+    return;
+  }
+
+  UniquePtr<Endpoint> endpoint = MakeUnique<Endpoint>(messageHubId, endpointId);
+  if (endpoint.isNull()) {
+    FATAL_ERROR_OOM();
+    return;
+  }
+
+  // We defer here to do all processing in the event loop thread. This allows
+  // for no locks as well as fast callbacks due to the potentially large
+  // number of nanoapps that may be waiting for events generated by this
+  // callback.
+  EventLoopManagerSingleton::get()->deferCallback(
+      SystemCallbackType::EndpointRegisteredEvent, std::move(endpoint),
+      [](SystemCallbackType /* type */, UniquePtr<Endpoint> &&data) {
+        EventLoopManagerSingleton::get()
+            ->getChreMessageHubManager()
+            .onEndpointReadyEvent(data->messageHubId, data->endpointId);
+      });
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::onEndpointUnregistered(
+    MessageHubId /* messageHubId */, EndpointId /* endpointId */) {
+  // Ignore - we only care about registered endpoints
+}
+
+void ChreMessageHubManager::ChreMessageHubCallback::pw_recycle() {
+  memoryFreeAndDestroy(this);
+}
+
 }  // namespace chre
 
 #endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
diff --git a/core/core.mk b/core/core.mk
index d931458e..3d571988 100644
--- a/core/core.mk
+++ b/core/core.mk
@@ -17,6 +17,7 @@ COMMON_SRCS += $(CHRE_PREFIX)/core/event_loop_manager.cc
 COMMON_SRCS += $(CHRE_PREFIX)/core/event_ref_queue.cc
 COMMON_SRCS += $(CHRE_PREFIX)/core/host_comms_manager.cc
 COMMON_SRCS += $(CHRE_PREFIX)/core/host_endpoint_manager.cc
+COMMON_SRCS += $(CHRE_PREFIX)/core/host_message_hub_manager.cc
 COMMON_SRCS += $(CHRE_PREFIX)/core/init.cc
 COMMON_SRCS += $(CHRE_PREFIX)/core/nanoapp.cc
 COMMON_SRCS += $(CHRE_PREFIX)/core/settings.cc
diff --git a/core/debug_dump_manager.cc b/core/debug_dump_manager.cc
index da41fe95..49826447 100644
--- a/core/debug_dump_manager.cc
+++ b/core/debug_dump_manager.cc
@@ -72,7 +72,6 @@ void DebugDumpManager::appendNanoappLog(const Nanoapp &nanoapp,
 void DebugDumpManager::collectFrameworkDebugDumps() {
   auto *eventLoopManager = EventLoopManagerSingleton::get();
   eventLoopManager->getMemoryManager().logStateToBuffer(mDebugDump);
-  eventLoopManager->getEventLoop().handleNanoappWakeupBuckets();
   eventLoopManager->getEventLoop().logStateToBuffer(mDebugDump);
 #ifdef CHRE_SENSORS_SUPPORT_ENABLED
   eventLoopManager->getSensorRequestManager().logStateToBuffer(mDebugDump);
diff --git a/core/event_loop.cc b/core/event_loop.cc
index d5063e83..d51ff81c 100644
--- a/core/event_loop.cc
+++ b/core/event_loop.cc
@@ -17,6 +17,7 @@
 #include "chre/core/event_loop.h"
 #include <cinttypes>
 #include <cstdint>
+#include <cstdlib>
 #include <type_traits>
 
 #include "chre/core/event.h"
@@ -31,6 +32,7 @@
 #include "chre/util/lock_guard.h"
 #include "chre/util/system/debug_dump.h"
 #include "chre/util/system/event_callbacks.h"
+#include "chre/util/system/message_common.h"
 #include "chre/util/system/stats_container.h"
 #include "chre/util/throttle.h"
 #include "chre/util/time.h"
@@ -38,14 +40,18 @@
 
 using ::chre::message::EndpointInfo;
 using ::chre::message::EndpointType;
+using ::chre::message::RpcFormat;
+using ::chre::message::ServiceInfo;
 
 namespace chre {
 
-// Out of line declaration required for nonintegral static types
-constexpr Nanoseconds EventLoop::kIntervalWakeupBucket;
-
 namespace {
 
+//! The time interval of nanoapp wakeup buckets, adjust in conjunction with
+//! Nanoapp::kMaxSizeWakeupBuckets.
+constexpr Nanoseconds kIntervalWakeupBucket =
+    Nanoseconds(180 * kOneMinuteInNanoseconds);
+
 #ifndef CHRE_STATIC_EVENT_LOOP
 using DynamicMemoryPool =
     SynchronizedExpandableMemoryPool<Event, CHRE_EVENT_PER_BLOCK,
@@ -148,6 +154,7 @@ void EventLoop::invokeMessageFreeFunction(uint64_t appId,
 
 void EventLoop::run() {
   LOGI("EventLoop start");
+  setCycleWakeupBucketsTimer();
 
   while (mRunning) {
     // Events are delivered in a single stage: they arrive in the inbound event
@@ -221,6 +228,12 @@ bool EventLoop::startNanoapp(UniquePtr<Nanoapp> &nanoapp) {
                       /*nanoappStarted=*/false);
       } else {
         notifyAppStatusChange(CHRE_EVENT_NANOAPP_STARTED, *newNanoapp);
+
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+        eventLoopManager->getChreMessageHubManager()
+            .getMessageHub()
+            .registerEndpoint(newNanoapp->getAppId());
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
       }
     }
   }
@@ -484,6 +497,38 @@ void EventLoop::onMatchingNanoappEndpoint(
   }
 }
 
+void EventLoop::onMatchingNanoappService(
+    const pw::Function<bool(const EndpointInfo &, const ServiceInfo &)>
+        &function) {
+  ConditionalLockGuard<Mutex> lock(mNanoappsLock, !inEventLoopThread());
+
+  // Format for legacy service descriptors:
+  // serviceDescriptor = FORMAT_STRING(
+  //     "chre.nanoapp_0x%016" PRIX64 ".service_0x%016" PRIX64, nanoapp_id,
+  //     service_id)
+  // The length of the buffer is the length of the string above, plus one for
+  // the null terminator.
+  // The arguments to the ServiceInfo constructor are specified in the CHRE API.
+  // @see chrePublishRpcServices
+  constexpr size_t kBufferSize = 59;
+  char buffer[kBufferSize];
+
+  for (const UniquePtr<Nanoapp> &app : mNanoapps) {
+    const DynamicVector<struct chreNanoappRpcService> &services =
+        app->getRpcServices();
+    for (const struct chreNanoappRpcService &service : services) {
+      std::snprintf(buffer, kBufferSize,
+                    "chre.nanoapp_0x%016" PRIX64 ".service_0x%016" PRIX64,
+                    app->getAppId(), service.id);
+      ServiceInfo serviceInfo(buffer, service.version, /* minorVersion= */ 0,
+                              RpcFormat::PW_RPC_PROTOBUF);
+      if (function(getEndpointInfoFromNanoappLocked(*app.get()), serviceInfo)) {
+        return;
+      }
+    }
+  }
+}
+
 std::optional<EndpointInfo> EventLoop::getEndpointInfo(uint64_t appId) {
   ConditionalLockGuard<Mutex> lock(mNanoappsLock, !inEventLoopThread());
   Nanoapp *app = lookupAppByAppId(appId);
@@ -691,6 +736,12 @@ void EventLoop::unloadNanoappAtIndex(size_t index, bool nanoappStarted) {
   logDanglingResources("BLE scan", numDisabledBleScans);
 #endif  // CHRE_BLE_SUPPORT_ENABLED
 
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .unregisterEndpoint(nanoapp->getAppId());
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+
   const uint32_t numCancelledTimers =
       getTimerPool().cancelAllNanoappTimers(nanoapp.get());
   logDanglingResources("timers", numCancelledTimers);
@@ -706,15 +757,30 @@ void EventLoop::unloadNanoappAtIndex(size_t index, bool nanoappStarted) {
   mCurrentApp = nullptr;
 }
 
+void EventLoop::setCycleWakeupBucketsTimer() {
+  if (mCycleWakeupBucketsHandle != CHRE_TIMER_INVALID) {
+    EventLoopManagerSingleton::get()->cancelDelayedCallback(
+        mCycleWakeupBucketsHandle);
+  }
+
+  auto callback = [](uint16_t /*type*/, void * /*data*/, void * /*extraData*/) {
+    EventLoopManagerSingleton::get()
+        ->getEventLoop()
+        .handleNanoappWakeupBuckets();
+  };
+  mCycleWakeupBucketsHandle =
+      EventLoopManagerSingleton::get()->setDelayedCallback(
+          SystemCallbackType::CycleNanoappWakeupBucket, nullptr /*data*/,
+          callback, kIntervalWakeupBucket);
+}
+
 void EventLoop::handleNanoappWakeupBuckets() {
-  Nanoseconds now = SystemTime::getMonotonicTime();
-  Nanoseconds duration = now - mTimeLastWakeupBucketCycled;
-  if (duration > kIntervalWakeupBucket) {
-    mTimeLastWakeupBucketCycled = now;
-    for (auto &nanoapp : mNanoapps) {
-      nanoapp->cycleWakeupBuckets(now);
-    }
+  mTimeLastWakeupBucketCycled = SystemTime::getMonotonicTime();
+  for (auto &nanoapp : mNanoapps) {
+    nanoapp->cycleWakeupBuckets(mTimeLastWakeupBucketCycled);
   }
+  mCycleWakeupBucketsHandle = CHRE_TIMER_INVALID;
+  setCycleWakeupBucketsTimer();
 }
 
 void EventLoop::logDanglingResources(const char *name, uint32_t count) {
diff --git a/core/event_loop_manager.cc b/core/event_loop_manager.cc
index e8021357..269c8e88 100644
--- a/core/event_loop_manager.cc
+++ b/core/event_loop_manager.cc
@@ -16,12 +16,12 @@
 
 #include "chre/core/event_loop_manager.h"
 
-#include "chre/core/event_loop_common.h"
 #include "chre/event.h"
 #include "chre/platform/atomic.h"
 #include "chre/platform/fatal_error.h"
 #include "chre/platform/memory.h"
 #include "chre/util/lock_guard.h"
+#include "chre/util/system/system_callback_type.h"
 
 namespace chre {
 
diff --git a/core/host_comms_manager.cc b/core/host_comms_manager.cc
index 1dc6b790..493d4f91 100644
--- a/core/host_comms_manager.cc
+++ b/core/host_comms_manager.cc
@@ -21,7 +21,6 @@
 #include <type_traits>
 #include <utility>
 
-#include "chre/core/event_loop_common.h"
 #include "chre/core/event_loop_manager.h"
 #include "chre/platform/assert.h"
 #include "chre/platform/context.h"
@@ -31,6 +30,7 @@
 #include "chre/util/macros.h"
 #include "chre/util/nested_data_ptr.h"
 #include "chre/util/optional.h"
+#include "chre/util/system/system_callback_type.h"
 #include "chre_api/chre.h"
 
 namespace chre {
@@ -235,7 +235,7 @@ void HostCommsManager::sendMessageToNanoappFromHost(
   MessageFromHost *craftedMessage = output.second;
 
   if (error == CHRE_ERROR_NONE) {
-    auto callback = [](uint16_t /*type*/, void *data, void* /* extraData */) {
+    auto callback = [](uint16_t /*type*/, void *data, void * /* extraData */) {
       MessageFromHost *craftedMessage = static_cast<MessageFromHost *>(data);
       EventLoopManagerSingleton::get()
           ->getHostCommsManager()
@@ -320,12 +320,11 @@ HostCommsManager::validateAndCraftMessageFromHostToNanoapp(
   } else {
     craftedMessage = craftNanoappMessageFromHost(
         appId, hostEndpoint, messageType, messageData,
-        static_cast<uint32_t>(messageSize), isReliable,
-        messageSequenceNumber);
+        static_cast<uint32_t>(messageSize), isReliable, messageSequenceNumber);
     if (craftedMessage == nullptr) {
       LOGE("Out of memory - rejecting message to app ID 0x%016" PRIx64
-            "(size %zu)",
-            appId, messageSize);
+           "(size %zu)",
+           appId, messageSize);
       error = CHRE_ERROR_NO_MEMORY;
     }
   }
@@ -345,9 +344,9 @@ void HostCommsManager::deliverNanoappMessageFromHost(
                           .findNanoappInstanceIdByAppId(craftedMessage->appId,
                                                         &targetInstanceId);
   bool shouldDeliverMessage = !craftedMessage->isReliable ||
-                                shouldSendReliableMessageToNanoapp(
-                                    craftedMessage->messageSequenceNumber,
-                                    craftedMessage->fromHostData.hostEndpoint);
+                              shouldSendReliableMessageToNanoapp(
+                                  craftedMessage->messageSequenceNumber,
+                                  craftedMessage->fromHostData.hostEndpoint);
   if (!foundNanoapp) {
     error = CHRE_ERROR_DESTINATION_NOT_FOUND;
   } else if (shouldDeliverMessage) {
@@ -383,9 +382,6 @@ bool HostCommsManager::doSendMessageToHostFromNanoapp(
   }
 
   if (wokeHost) {
-    EventLoopManagerSingleton::get()
-        ->getEventLoop()
-        .handleNanoappWakeupBuckets();
     mIsNanoappBlamedForWakeup = true;
     nanoapp->blameHostWakeup();
   }
@@ -448,16 +444,15 @@ void HostCommsManager::onTransactionFailure(uint32_t messageSequenceNumber,
 
 void HostCommsManager::handleDuplicateAndSendMessageDeliveryStatus(
     [[maybe_unused]] uint32_t messageSequenceNumber,
-    [[maybe_unused]] uint16_t hostEndpoint,
-    [[maybe_unused]] chreError error) {
+    [[maybe_unused]] uint16_t hostEndpoint, [[maybe_unused]] chreError error) {
 #ifdef CHRE_RELIABLE_MESSAGE_SUPPORT_ENABLED
   bool success = mDuplicateMessageDetector.findAndSetError(
       messageSequenceNumber, hostEndpoint, error);
   if (!success) {
-    LOGW("Failed to set error for message with message sequence number: %"
-          PRIu32 " and host endpoint: 0x%" PRIx16,
-          messageSequenceNumber,
-          hostEndpoint);
+    LOGW(
+        "Failed to set error for message with message sequence number: %" PRIu32
+        " and host endpoint: 0x%" PRIx16,
+        messageSequenceNumber, hostEndpoint);
   }
   sendMessageDeliveryStatus(messageSequenceNumber, error);
 #endif  // CHRE_RELIABLE_MESSAGE_SUPPORT_ENABLED
diff --git a/core/host_message_hub_manager.cc b/core/host_message_hub_manager.cc
new file mode 100644
index 00000000..48fbed7d
--- /dev/null
+++ b/core/host_message_hub_manager.cc
@@ -0,0 +1,517 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "chre/core/host_message_hub_manager.h"
+#include "chre/target_platform/log.h"
+
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+
+#include <cstring>
+#include <optional>
+
+#include "chre/core/event_loop_manager.h"
+#include "chre/platform/assert.h"
+#include "chre/platform/log.h"
+#include "chre/platform/memory.h"
+#include "chre/platform/mutex.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
+#include "chre/platform/shared/host_protocol_chre.h"
+#include "chre/util/lock_guard.h"
+#include "chre/util/memory.h"
+#include "chre/util/system/message_common.h"
+#include "chre/util/system/message_router.h"
+
+#include "pw_allocator/unique_ptr.h"
+#include "pw_function/function.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
+#include "pw_span/span.h"
+
+namespace chre {
+
+using ::chre::message::EndpointId;
+using ::chre::message::EndpointInfo;
+using ::chre::message::MESSAGE_HUB_ID_INVALID;
+using ::chre::message::MessageHubId;
+using ::chre::message::MessageHubInfo;
+using ::chre::message::MessageRouter;
+using ::chre::message::MessageRouterSingleton;
+using ::chre::message::Reason;
+using ::chre::message::ServiceInfo;
+using ::chre::message::Session;
+using ::chre::message::SessionId;
+
+HostMessageHubManager::~HostMessageHubManager() {
+  LockGuard<Mutex> hostLock(mHubsLock);
+  clearHubsLocked();
+}
+
+void HostMessageHubManager::onHostTransportReady(HostCallback &cb) {
+  CHRE_ASSERT_LOG(mCb == nullptr,
+                  "HostMessageHubManager::init() called more than once");
+  mCb = &cb;
+}
+
+void HostMessageHubManager::reset() {
+  LOGI("Resetting HostMessageHubManager");
+  CHRE_ASSERT_NOT_NULL(mCb);
+  LockGuard<Mutex> hostLock(mHubsLock);
+  clearHubsLocked();
+
+  // Serialize the following against any other embedded hub or endpoint
+  // registration events.
+  LockGuard<Mutex> embeddedLock(mEmbeddedHubOpLock);
+
+  // Notify the HAL to accept embedded hub/endpoint registrations.
+  mCb->onReset();
+  MessageRouterSingleton::get()->forEachMessageHub(
+      [this](const MessageHubInfo &info) {
+        mCb->onHubRegistered(info);
+        return false;
+      });
+  MessageRouterSingleton::get()->forEachEndpoint(
+      [this](const MessageHubInfo &hub, const EndpointInfo &endpoint) {
+        mCb->onEndpointRegistered(hub.id, endpoint);
+      });
+  MessageRouterSingleton::get()->forEachService(
+      [this](const MessageHubInfo &hub, const EndpointInfo &endpoint,
+             const ServiceInfo &service) {
+        mCb->onEndpointService(hub.id, endpoint.id, service);
+        return false;
+      });
+  MessageRouterSingleton::get()->forEachEndpoint(
+      [this](const MessageHubInfo &hub, const EndpointInfo &endpoint) {
+        mCb->onEndpointReady(hub.id, endpoint.id);
+      });
+  LOGI("Initialized HostMessageHubManager");
+}
+
+void HostMessageHubManager::registerHub(const MessageHubInfo &info) {
+  LockGuard<Mutex> lock(mHubsLock);
+  pw::IntrusiveList<Endpoint> endpoints;
+  HostMessageHubManager::Hub::createLocked(this, info, endpoints);
+}
+
+void HostMessageHubManager::unregisterHub(MessageHubId id) {
+  LockGuard<Mutex> lock(mHubsLock);
+
+  for (auto it = mHubs.begin(); it != mHubs.end(); ++it) {
+    if ((*it)->getMessageHub().getId() == id) {
+      (*it)->clear();
+      mHubs.erase(it);
+      return;
+    }
+  }
+  LOGE("No host hub 0x%" PRIx64 " for unregister", id);
+}
+
+void HostMessageHubManager::registerEndpoint(
+    MessageHubId hubId, const EndpointInfo &info,
+    DynamicVector<ServiceInfo> &&services) {
+  LockGuard<Mutex> lock(mHubsLock);
+  for (auto &hub : mHubs) {
+    if (hub->getMessageHub().getId() != hubId) continue;
+    hub->addEndpoint(info, std::move(services));
+    return;
+  }
+  LOGE("No host hub 0x%" PRIx64 " for add endpoint", hubId);
+}
+
+void HostMessageHubManager::unregisterEndpoint(MessageHubId hubId,
+                                               EndpointId id) {
+  LockGuard<Mutex> lock(mHubsLock);
+  for (auto &hub : mHubs) {
+    if (hub->getMessageHub().getId() != hubId) continue;
+    hub->removeEndpoint(id);
+    hub->getMessageHub().unregisterEndpoint(id);
+    return;
+  }
+  LOGE("No host hub 0x%" PRIx64 " for unregister endpoint", hubId);
+}
+
+void HostMessageHubManager::openSession(MessageHubId hubId,
+                                        EndpointId endpointId,
+                                        MessageHubId destinationHubId,
+                                        EndpointId destinationEndpointId,
+                                        SessionId sessionId,
+                                        const char *serviceDescriptor) {
+  LockGuard<Mutex> lock(mHubsLock);
+  for (auto &hub : mHubs) {
+    if (hub->getMessageHub().getId() != hubId) continue;
+    if (hub->getMessageHub().openSession(
+            endpointId, destinationHubId, destinationEndpointId,
+            serviceDescriptor, sessionId) != sessionId) {
+      mCb->onSessionClosed(hubId, sessionId,
+                           Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED);
+    }
+    return;
+  }
+  LOGE("No host hub 0x%" PRIx64 " for open session", hubId);
+}
+
+void HostMessageHubManager::ackSession(MessageHubId hubId,
+                                       SessionId sessionId) {
+  LockGuard<Mutex> lock(mHubsLock);
+  for (auto &hub : mHubs) {
+    if (hub->getMessageHub().getId() != hubId) continue;
+    hub->getMessageHub().onSessionOpenComplete(sessionId);
+    mCb->onSessionOpened(hubId, sessionId);
+    return;
+  }
+  LOGE("No host hub 0x%" PRIx64 " for ack session", hubId);
+}
+
+void HostMessageHubManager::closeSession(MessageHubId hubId,
+                                         SessionId sessionId, Reason reason) {
+  LockGuard<Mutex> lock(mHubsLock);
+  for (auto &hub : mHubs) {
+    if (hub->getMessageHub().getId() != hubId) continue;
+    hub->getMessageHub().closeSession(sessionId, reason);
+    return;
+  }
+  LOGE("No host hub 0x%" PRIx64 " for close session", hubId);
+}
+
+void HostMessageHubManager::sendMessage(MessageHubId hubId, SessionId sessionId,
+                                        pw::span<const std::byte> data,
+                                        uint32_t type, uint32_t permissions) {
+  LockGuard<Mutex> lock(mHubsLock);
+  for (auto &hub : mHubs) {
+    if (hub->getMessageHub().getId() != hubId) continue;
+    auto dataCopy = mMsgAllocator.MakeUniqueArray<std::byte>(data.size());
+    if (dataCopy == nullptr) {
+      LOGE("Failed to allocate endpoint message from host hub 0x%" PRIx64
+           " over session %" PRIu16,
+           hubId, sessionId);
+      return;
+    }
+    std::memcpy(dataCopy.get(), data.data(), data.size());
+
+    // Note: We are assuming here that no host hubs will create sessions with
+    // themselves as it is not allowed by the HAL API.
+    hub->getMessageHub().sendMessage(std::move(dataCopy), type, permissions,
+                                     sessionId);
+    return;
+  }
+  LOGE("No host hub 0x%" PRIx64 " for send message", hubId);
+}
+
+bool HostMessageHubManager::Hub::createLocked(
+    HostMessageHubManager *manager, const MessageHubInfo &info,
+    pw::IntrusiveList<Endpoint> &endpoints) {
+  CHRE_ASSERT(manager != nullptr);
+
+  // If there is an available slot, create a new Hub and try to register it with
+  // MessageRouter, cleaning it up on failure.
+  if (manager->mHubs.full()) {
+    LOGE("No space to register new host hub 0x%" PRIx64, info.id);
+    deallocateEndpoints(endpoints);
+    return false;
+  }
+
+  Hub *hubPtr = memoryAlloc<Hub>(manager, info.name, endpoints);
+  if (hubPtr == nullptr) {
+    LOGE("Failed to allocate storage for new host hub %" PRIu64, info.id);
+    deallocateEndpoints(endpoints);
+    return false;
+  }
+
+  pw::IntrusivePtr<Hub> hub(hubPtr);
+  manager->mHubs.push_back(hub);
+  std::optional<MessageRouter::MessageHub> maybeHub =
+      MessageRouterSingleton::get()->registerMessageHub(hub->kName, info.id,
+                                                        hub);
+  if (!maybeHub) {
+    LOGE("Failed to register host hub 0x%" PRIx64, info.id);
+    manager->mHubs.pop_back();
+    return false;
+  }
+  hub->mMessageHub = std::move(*maybeHub);
+  return true;
+}
+
+HostMessageHubManager::Hub::Hub(HostMessageHubManager *manager,
+                                const char *name,
+                                pw::IntrusiveList<Endpoint> &endpoints)
+    : mManager(manager) {
+  std::strncpy(kName, name, kNameMaxLen);
+  kName[kNameMaxLen] = 0;
+  mEndpoints.splice_after(mEndpoints.before_begin(), endpoints);
+}
+
+HostMessageHubManager::Hub::~Hub() {
+  // clear() should be explicitly called before destruction.
+  CHRE_ASSERT_LOG(!mMessageHub.isRegistered(),
+                  "Hub destroyed while registered");
+}
+
+void HostMessageHubManager::Hub::clear() {
+  getMessageHub().unregister();
+
+  // This lock needs to be held to ensure the manager does not destruct
+  // while deallocating endpoints are called.
+  LockGuard<Mutex> managerLock(mManagerLock);
+  mManager = nullptr;
+
+  LockGuard<Mutex> lock(mEndpointsLock);
+  deallocateEndpoints(mEndpoints);
+}
+
+void HostMessageHubManager::Hub::addEndpoint(
+    const EndpointInfo &info, DynamicVector<ServiceInfo> &&services) {
+  Endpoint *endpoint = nullptr;
+  {
+    LockGuard<Mutex> managerLock(mManagerLock);
+    CHRE_ASSERT_LOG(mManager != nullptr,
+                    "The HostMessageHubManager has been destroyed.");
+
+    endpoint = mManager->mEndpointAllocator.allocate(info, std::move(services));
+    if (endpoint == nullptr) {
+      LOGE("Failed to allocate storage for endpoint (0x%" PRIx64 ", 0x%" PRIx64
+           ")",
+           mMessageHub.getId(), info.id);
+      for (const auto &service : services)
+        memoryFree(const_cast<char *>(service.serviceDescriptor));
+      return;
+    }
+  }
+
+  {
+    LockGuard<Mutex> lock(mEndpointsLock);
+    mEndpoints.push_back(*endpoint);
+  }
+  mMessageHub.registerEndpoint(info.id);
+}
+
+void HostMessageHubManager::Hub::removeEndpoint(EndpointId id) {
+  Endpoint *endpoint = nullptr;
+  {
+    LockGuard<Mutex> lock(mEndpointsLock);
+    for (auto it = mEndpoints.begin(), eraseIt = mEndpoints.before_begin();
+         it != mEndpoints.end(); ++it, ++eraseIt) {
+      if (it->kInfo.id == id) {
+        mEndpoints.erase_after(eraseIt);
+        endpoint = &(*it);
+        break;
+      }
+    }
+  }
+  if (endpoint) {
+    LockGuard<Mutex> managerLock(mManagerLock);
+    CHRE_ASSERT_LOG(mManager != nullptr,
+                    "The HostMessageHubManager has been destroyed.");
+    mManager->mEndpointAllocator.deallocate(endpoint);
+  }
+}
+
+bool HostMessageHubManager::Hub::onMessageReceived(
+    pw::UniquePtr<std::byte[]> &&data, uint32_t messageType,
+    uint32_t messagePermissions, const Session &session,
+    bool /*sentBySessionInitiator*/) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return false;
+  }
+
+  return mManager->mCb->onMessageReceived(mMessageHub.getId(),
+                                          session.sessionId, std::move(data),
+                                          messageType, messagePermissions);
+}
+
+void HostMessageHubManager::Hub::onSessionOpenRequest(const Session &session) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+
+  return mManager->mCb->onSessionOpenRequest(session);
+}
+
+void HostMessageHubManager::Hub::onSessionOpened(const Session &session) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+
+  return mManager->mCb->onSessionOpened(mMessageHub.getId(), session.sessionId);
+}
+
+void HostMessageHubManager::Hub::onSessionClosed(const Session &session,
+                                                 Reason reason) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+
+  return mManager->mCb->onSessionClosed(mMessageHub.getId(), session.sessionId,
+                                        reason);
+}
+
+void HostMessageHubManager::Hub::forEachEndpoint(
+    const pw::Function<bool(const EndpointInfo &)> &function) {
+  LockGuard<Mutex> lock(mEndpointsLock);
+  for (const auto &endpoint : mEndpoints)
+    if (function(endpoint.kInfo)) break;
+}
+
+std::optional<EndpointInfo> HostMessageHubManager::Hub::getEndpointInfo(
+    EndpointId endpointId) {
+  LockGuard<Mutex> lock(mEndpointsLock);
+  for (const auto &endpoint : mEndpoints)
+    if (endpoint.kInfo.id == endpointId) return endpoint.kInfo;
+  return {};
+}
+
+std::optional<EndpointId> HostMessageHubManager::Hub::getEndpointForService(
+    const char *serviceDescriptor) {
+  LockGuard<Mutex> lock(mEndpointsLock);
+  for (const auto &endpoint : mEndpoints) {
+    for (const auto &service : endpoint.mServices) {
+      if (!std::strcmp(serviceDescriptor, service.serviceDescriptor))
+        return endpoint.kInfo.id;
+    }
+  }
+  return {};
+}
+
+bool HostMessageHubManager::Hub::doesEndpointHaveService(
+    EndpointId endpointId, const char *serviceDescriptor) {
+  LockGuard<Mutex> lock(mEndpointsLock);
+  for (const auto &endpoint : mEndpoints) {
+    if (endpoint.kInfo.id != endpointId) continue;
+    for (const auto &service : endpoint.mServices) {
+      if (!std::strcmp(serviceDescriptor, service.serviceDescriptor))
+        return true;
+    }
+    return false;
+  }
+  return false;
+}
+
+void HostMessageHubManager::Hub::forEachService(
+    const pw::Function<bool(const message::EndpointInfo &,
+                            const message::ServiceInfo &)> &function) {
+  LockGuard<Mutex> lock(mEndpointsLock);
+  for (const auto &endpoint : mEndpoints) {
+    for (const auto &service : endpoint.mServices)
+      function(endpoint.kInfo, service);
+  }
+}
+
+void HostMessageHubManager::Hub::onHubRegistered(const MessageHubInfo &info) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+
+  LockGuard<Mutex> lock(mManager->mEmbeddedHubOpLock);
+  mManager->mCb->onHubRegistered(info);
+}
+
+void HostMessageHubManager::Hub::onHubUnregistered(MessageHubId id) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+
+  LockGuard<Mutex> lock(mManager->mEmbeddedHubOpLock);
+  mManager->mCb->onHubUnregistered(id);
+}
+
+void HostMessageHubManager::Hub::onEndpointRegistered(MessageHubId messageHubId,
+                                                      EndpointId endpointId) {
+  std::optional<EndpointInfo> endpoint =
+      MessageRouterSingleton::get()->getEndpointInfo(messageHubId, endpointId);
+  if (!endpoint) return;
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+  LockGuard<Mutex> lock(mManager->mEmbeddedHubOpLock);
+
+  mManager->mCb->onEndpointRegistered(messageHubId, *endpoint);
+  struct {
+    HostCallback *cb;
+    MessageHubId hub;
+    EndpointId endpoint;
+  } context = {
+      .cb = mManager->mCb, .hub = messageHubId, .endpoint = endpointId};
+  MessageRouterSingleton::get()->forEachService(
+      [&context](const MessageHubInfo &hub, const EndpointInfo &endpoint,
+                 const ServiceInfo &service) {
+        if (context.hub != hub.id) return false;
+        if (context.endpoint != endpoint.id) return false;
+        context.cb->onEndpointService(hub.id, endpoint.id, service);
+        return false;
+      });
+  mManager->mCb->onEndpointReady(messageHubId, endpointId);
+}
+
+void HostMessageHubManager::Hub::onEndpointUnregistered(
+    MessageHubId messageHubId, EndpointId endpointId) {
+  LockGuard<Mutex> managerLock(mManagerLock);
+  if (mManager == nullptr) {
+    LOGW("The HostMessageHubManager has been destroyed.");
+    return;
+  }
+
+  LockGuard<Mutex> lock(mManager->mEmbeddedHubOpLock);
+  mManager->mCb->onEndpointUnregistered(messageHubId, endpointId);
+}
+
+void HostMessageHubManager::Hub::pw_recycle() {
+  memoryFreeAndDestroy(this);
+}
+
+void *HostMessageHubManager::ChreAllocator::DoAllocate(Layout layout) {
+  return memoryAlloc(layout.size());
+}
+
+void HostMessageHubManager::ChreAllocator::DoDeallocate(void *ptr) {
+  memoryFree(ptr);
+}
+
+void HostMessageHubManager::deallocateEndpoints(
+    pw::IntrusiveList<Endpoint> &endpoints) {
+  while (!endpoints.empty()) {
+    auto &endpoint = endpoints.front();
+    endpoints.pop_front();
+    EventLoopManagerSingleton::get()
+        ->getHostMessageHubManager()
+        .mEndpointAllocator.deallocate(&endpoint);
+  }
+}
+
+void HostMessageHubManager::clearHubsLocked() {
+  // Deactivate all existing message hubs. We need to call clear() on each hub
+  // to unregister it from MessageRouter as both MessageRouter and the
+  // HostMessageHubManager have a pw::IntrusivePtr to the Hub, which will not
+  // deallocate the Hub until both references are gone.
+  for (auto &hub : mHubs) {
+    hub->clear();
+  }
+  mHubs.clear();
+}
+
+}  // namespace chre
+
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
diff --git a/core/include/chre/core/ble_l2cap_coc_socket_data.h b/core/include/chre/core/ble_l2cap_coc_socket_data.h
new file mode 100644
index 00000000..e1be75b9
--- /dev/null
+++ b/core/include/chre/core/ble_l2cap_coc_socket_data.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+/**
+ * Parameters for a direction of packet flow in an LE L2CAP COC socket.
+ */
+struct L2capCocConfig {
+  //! Channel identifier of the endpoint.
+  uint16_t cid;
+
+  //! Maximum Transmission Unit.
+  uint16_t mtu;
+
+  //! Maximum PDU payload Size.
+  uint16_t mps;
+
+  //! Currently available credits for sending or receiving K-frames in LE
+  //! Credit Based Flow Control mode.
+  uint16_t credits;
+};
+
+/**
+ * Data for the offloaded LE L2CAP COC socket.
+ */
+struct BleL2capCocSocketData {
+  //! Unique identifier for this socket connection. This ID in the offload
+  //! domain matches the ID used on the host side. It is valid only while the
+  //! socket is connected.
+  uint64_t socketId;
+
+  //! The ID of the Hub endpoint for hardware offload data path.
+  uint64_t endpointId;
+
+  //! ACL connection handle for the socket.
+  uint16_t connectionHandle;
+
+  //! The originating or destination client ID on the host side, used to direct
+  //! responses only to the client that sent the request.
+  uint16_t hostClientId;
+
+  L2capCocConfig rxConfig;
+
+  L2capCocConfig txConfig;
+};
diff --git a/core/include/chre/core/ble_socket_manager.h b/core/include/chre/core/ble_socket_manager.h
new file mode 100644
index 00000000..f011dc39
--- /dev/null
+++ b/core/include/chre/core/ble_socket_manager.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifdef CHRE_BLE_SOCKET_SUPPORT_ENABLED
+
+#include "chre/core/ble_l2cap_coc_socket_data.h"
+#include "chre_api/chre.h"
+
+namespace chre {
+
+/**
+ * Manages offloaded BLE sockets. Handles sending packets between nanoapps and
+ * BLE sockets.
+ */
+class BleSocketManager : public NonCopyable {
+ public:
+  chreError socketConnected(const BleL2capCocSocketData & /* socketData */) {
+    return CHRE_ERROR_NOT_SUPPORTED;
+  }
+
+  bool acceptBleSocket(uint64_t /*socketId*/) {
+    return false;
+  }
+
+  int32_t sendBleSocketPacket(
+      uint64_t /*socketId*/, const void * /*data*/, uint16_t /*length*/,
+      chreBleSocketPacketFreeFunction * /*freeCallback*/) {
+    return CHRE_ERROR_NOT_SUPPORTED;
+  }
+};
+
+}  // namespace chre
+
+#endif  // CHRE_BLE_SOCKET_SUPPORT_ENABLED
diff --git a/core/include/chre/core/chre_message_hub_manager.h b/core/include/chre/core/chre_message_hub_manager.h
index 15aaea99..49038009 100644
--- a/core/include/chre/core/chre_message_hub_manager.h
+++ b/core/include/chre/core/chre_message_hub_manager.h
@@ -19,71 +19,313 @@
 
 #ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
 
-#include "chre/core/event_loop_common.h"
+#include "chre/platform/mutex.h"
+#include "chre/util/dynamic_vector.h"
 #include "chre/util/non_copyable.h"
+#include "chre/util/system/callback_allocator.h"
 #include "chre/util/system/message_common.h"
 #include "chre/util/system/message_router.h"
+#include "chre/util/system/system_callback_type.h"
 #include "chre/util/unique_ptr.h"
+#include "chre_api/chre.h"
 
-#include <cinttypes>
+#include "pw_containers/vector.h"
+#include "pw_intrusive_ptr/recyclable.h"
+
+#include <cstdint>
 #include <optional>
 
 namespace chre {
 
 //! Manager class for the CHRE Message Hub.
-class ChreMessageHubManager
-    : public NonCopyable,
-      public message::MessageRouter::MessageHubCallback {
+class ChreMessageHubManager : public NonCopyable {
  public:
   //! The ID of the CHRE MessageHub
   constexpr static message::MessageHubId kChreMessageHubId = CHRE_PLATFORM_ID;
 
+  ChreMessageHubManager();
+  ~ChreMessageHubManager();
+
   //! Initializes the ChreMessageHubManager
   void init();
 
-  //! Returns the MessageHub for the CHRE Message Hub
+  //! @return the MessageHub for the CHRE Message Hub
   message::MessageRouter::MessageHub &getMessageHub() {
     return mChreMessageHub;
   }
 
+  //! Gets endpoint information for the given hub and endpoint IDs.
+  //! @return whether the endpoint information was successfully populated.
+  bool getEndpointInfo(message::MessageHubId hubId,
+                       message::EndpointId endpointId,
+                       chreMsgEndpointInfo &info);
+
+  //! Configures ready events for the given endpoint or service.
+  //! This function must be called from the event loop thread.
+  //! @return true if the ready events were configured successfully, false
+  //! otherwise.
+  bool configureReadyEvents(uint16_t nanoappInstanceId,
+                            message::EndpointId fromEndpointId,
+                            message::MessageHubId hubId,
+                            message::EndpointId endpointId,
+                            const char *serviceDescriptor, bool enable);
+
+  //! Gets session information for the given session ID.
+  //! @return whether the session information was successfully populated.
+  bool getSessionInfo(message::EndpointId fromEndpointId,
+                      message::SessionId sessionId, chreMsgSessionInfo &info);
+
+  //! Opens a session from the given endpoint to the other endpoint in an
+  //! asynchronous manner.
+  //! @return true if the session was opened successfully, false otherwise
+  bool openSessionAsync(message::EndpointId fromEndpointId,
+                        message::MessageHubId toHubId,
+                        message::EndpointId toEndpointId,
+                        const char *serviceDescriptor);
+
+  //! Opens a session from the given endpoint to the other endpoint in an
+  //! asynchronous manner. Either toHubId, toEndpointId, or serviceDescriptor
+  //! can be set to CHRE_MSG_HUB_ID_INVALID, ENDPOINT_ID_INVALID, or nullptr,
+  //! respectively. If they are set to invalid values, the default values will
+  //! be used if available. If no default values are available, the session will
+  //! not be opened and this function will return false.
+  //! @return true if the session was opened successfully, false otherwise
+  bool openDefaultSessionAsync(message::EndpointId fromEndpointId,
+                               message::MessageHubId toHubId,
+                               message::EndpointId toEndpointId,
+                               const char *serviceDescriptor);
+
+  //! Closes the session and verifies the fromEndpointId is a member of the
+  //! session.
+  //! @return true if the session was closed successfully, false otherwise
+  bool closeSession(message::EndpointId fromEndpointId,
+                    message::SessionId sessionId);
+
+  //! Sends a reliable message on the given session. If this function fails,
+  //! the free callback will be called and it will return false.
+  //! @return whether the message was successfully sent
+  bool sendMessage(void *message, size_t messageSize, uint32_t messageType,
+                   uint16_t sessionId, uint32_t messagePermissions,
+                   chreMessageFreeFunction *freeCallback,
+                   message::EndpointId fromEndpointId);
+
+  //! Publishes a service from the given nanoapp.
+  //! This function must be called from the event loop thread.
+  //! @return true if the service was published successfully, false otherwise
+  bool publishServices(message::EndpointId fromEndpointId,
+                       const chreMsgServiceInfo *serviceInfos,
+                       size_t numServices);
+
+  //! Unregisters the given endpoint (nanoapp) from the MessageHub
+  //! This will clean up all pending resources then unregister the endpoint
+  //! from the MessageHub.
+  void unregisterEndpoint(message::EndpointId endpointId);
+
+  //! Cleans up all pending resources for the given endpoint (nanoapp).
+  //! This should only be called from the event loop thread.
+  void cleanupEndpointResources(message::EndpointId endpointId);
+
+  //! Converts a message::EndpointType to a CHRE endpoint type
+  //! @return the CHRE endpoint type
+  chreMsgEndpointType toChreEndpointType(message::EndpointType type);
+
+  //! Converts a message::Reason to a CHRE endpoint reason
+  //! @return the CHRE endpoint reason
+  chreMsgEndpointReason toChreEndpointReason(message::Reason reason);
+
  private:
   //! Data to be passed to the message callback
   struct MessageCallbackData {
-    chreMessageFromEndpointData messageToNanoapp;
+    chreMsgMessageFromEndpointData messageToNanoapp;
     pw::UniquePtr<std::byte[]> data;
     uint64_t nanoappId;
   };
 
+  //! Data to be passed to the message free callback
+  struct MessageFreeCallbackData {
+    chreMessageFreeFunction *freeCallback;
+    uint64_t nanoappId;
+  };
+
   //! Data to be passed to the session closed callback
-  struct SessionClosedCallbackData {
-    chreEndpointSessionClosedData sessionClosedData;
+  struct SessionCallbackData {
+    chreMsgSessionInfo sessionData;
+    bool isClosed;
     uint64_t nanoappId;
   };
 
+  //! Data that represents a service published by a nanoapp
+  struct NanoappServiceData {
+    uint64_t nanoappId;
+    chreMsgServiceInfo serviceInfo;
+  };
+
+  //! Data that represents a ready event configured for an endpoint or service
+  struct EndpointReadyEventData {
+    message::EndpointId fromEndpointId;
+    message::MessageHubId messageHubId;
+    message::EndpointId endpointId;
+    const char *serviceDescriptor;
+  };
+
+  //! The callback used to register the CHRE MessageHub with the MessageRouter
+  //! @see MessageRouter::MessageHubCallback
+  class ChreMessageHubCallback
+      : public message::MessageRouter::MessageHubCallback,
+        pw::Recyclable<ChreMessageHubCallback> {
+   public:
+    explicit ChreMessageHubCallback(ChreMessageHubManager &manager)
+        : mChreMessageHubManager(&manager) {}
+
+    ~ChreMessageHubCallback() {
+      clearManager();
+    }
+
+    //! Clears the manager pointer.
+    void clearManager();
+
+   private:
+    friend class pw::Recyclable<ChreMessageHubCallback>;
+
+    //! @see MessageRouter::MessageHubCallback
+    bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
+                           uint32_t messageType, uint32_t messagePermissions,
+                           const message::Session &session,
+                           bool sentBySessionInitiator) override;
+    void onSessionOpenRequest(const message::Session &session) override;
+    void onSessionOpened(const message::Session &session) override;
+    void onSessionClosed(const message::Session &session,
+                         message::Reason reason) override;
+    void forEachEndpoint(const pw::Function<bool(const message::EndpointInfo &)>
+                             &function) override;
+    std::optional<message::EndpointInfo> getEndpointInfo(
+        message::EndpointId endpointId) override;
+    std::optional<message::EndpointId> getEndpointForService(
+        const char *serviceDescriptor) override;
+    bool doesEndpointHaveService(message::EndpointId endpointId,
+                                 const char *serviceDescriptor) override;
+    void forEachService(const pw::Function<bool(const message::EndpointInfo &,
+                                                const message::ServiceInfo &)>
+                            &function) override;
+    void onHubRegistered(const message::MessageHubInfo &info) override;
+    void onHubUnregistered(message::MessageHubId id) override;
+    void onEndpointRegistered(message::MessageHubId messageHubId,
+                              message::EndpointId endpointId) override;
+    void onEndpointUnregistered(message::MessageHubId messageHubId,
+                                message::EndpointId endpointId) override;
+
+    //! @see pw::Recyclable
+    void pw_recycle() override;
+
+    //! The ChreMessageHubManager that owns this callback and its lock.
+    Mutex mManagerLock;
+    ChreMessageHubManager *mChreMessageHubManager;
+  };
+
+  friend class ChreMessageHubCallback;
+
+  constexpr static size_t kMaxFreeCallbackRecords = 25;
+
   //! Callback to process message sent to a nanoapp - used by the event loop
   static void onMessageToNanoappCallback(
-      SystemCallbackType /* type */,
+      SystemCallbackType type,
       UniquePtr<ChreMessageHubManager::MessageCallbackData> &&data);
 
-  //! Callback to process session closed event for a nanoapp - used by the event
-  //! loop
-  static void onSessionClosedCallback(
-      SystemCallbackType /* type */,
-      UniquePtr<ChreMessageHubManager::SessionClosedCallbackData> &&data);
+  //! Callback to process session closed or opened event for a nanoapp - used
+  //! by the event loop
+  static void onSessionStateChangedCallback(
+      SystemCallbackType type,
+      UniquePtr<ChreMessageHubManager::SessionCallbackData> &&data);
 
-  //! Definitions for MessageHubCallback
-  //! @see MessageRouter::MessageHubCallback
-  bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data, size_t length,
-                         uint32_t messageType, uint32_t messagePermissions,
-                         const message::Session &session,
-                         bool sentBySessionInitiator) override;
-  void onSessionClosed(const message::Session &session) override;
-  void forEachEndpoint(const pw::Function<bool(const message::EndpointInfo &)>
-                           &function) override;
-  std::optional<message::EndpointInfo> getEndpointInfo(
-      message::EndpointId endpointId) override;
+  //! Callback to process session open complete event - used by the event loop
+  static void onSessionOpenCompleteCallback(uint16_t type, void *data,
+                                            void *extraData);
+
+  //! Callback called when a message is freed
+  static void onMessageFreeCallback(std::byte *message, size_t length,
+                                    MessageFreeCallbackData &&callbackData);
+
+  //! Callback passed to deferCallback when handling a message free callback
+  static void handleMessageFreeCallback(uint16_t type, void *data,
+                                        void *extraData);
+
+  //! Called on a state change for a session - open or close. If reason is
+  //! not provided, the state change is open, else it is closed.
+  void onSessionStateChanged(const message::Session &session,
+                             std::optional<message::Reason> reason);
+
+  //! Called when a session open is requested.
+  void onSessionOpenComplete(message::SessionId sessionId);
+
+  //! Processes an endpoint ready event from MessageRouter. Can only be called
+  //! from the event loop thread.
+  void onEndpointReadyEvent(message::MessageHubId messageHubId,
+                            message::EndpointId endpointId);
+
+  //! @return The free callback record from the callback allocator.
+  std::optional<CallbackAllocator<MessageFreeCallbackData>::CallbackRecord>
+  getAndRemoveFreeCallbackRecord(void *ptr) {
+    return mAllocator.GetAndRemoveCallbackRecord(ptr);
+  }
+
+  //! @return The first MessageHub ID for the given endpoint ID
+  message::MessageHubId findDefaultMessageHubId(message::EndpointId endpointId);
+
+  //! @return true if the nanoapp has a service with the given service
+  //! descriptor in the legacy service descriptor format.
+  bool doesNanoappHaveLegacyService(uint64_t nanoappId, uint64_t serviceId);
+
+  //! @return true if the services are valid and can be published, false
+  //! otherwise. Caller must hold mNanoappPublishedServicesMutex.
+  bool validateServicesLocked(uint64_t nanoappId,
+                              const chreMsgServiceInfo *serviceInfos,
+                              size_t numServices);
+
+  //! Searches for an endpoint with the given hub ID, endpoint ID, and service
+  //! descriptor. The hubId can be MESSAGE_HUB_ID_ANY to search for the
+  //! endpoint on any hub, the endpointId can be ENDPOINT_ID_ANY to search for
+  //! the endpoint on any hub, or the service descriptor can be non-nullptr to
+  //! search for any endpoint that has the service.
+  //! @return the endpoint if found, std::nullopt otherwise.
+  std::optional<message::Endpoint> searchForEndpoint(
+      message::MessageHubId messageHubId, message::EndpointId endpointId,
+      const char *serviceDescriptor);
+
+  //! Removes the ready event request for the given endpoint or service.
+  void disableReadyEvents(message::EndpointId fromEndpointId,
+                          message::MessageHubId hubId,
+                          message::EndpointId endpointId,
+                          const char *serviceDescriptor);
+
+  //! Converts from a chreMsgEndpointServiceFormat to a message::RpcFormat.
+  //! @return the RpcFormat
+  message::RpcFormat toMessageRpcFormat(chreMsgEndpointServiceFormat format);
 
+  //! The MessageHub for the CHRE
   message::MessageRouter::MessageHub mChreMessageHub;
+
+  //! The callback for the CHRE MessageHub
+  pw::IntrusivePtr<ChreMessageHubCallback> mChreMessageHubCallback;
+
+  //! The vector of free callback records - used by the
+  //! CallbackAllocator
+  pw::Vector<CallbackAllocator<MessageFreeCallbackData>::CallbackRecord,
+             kMaxFreeCallbackRecords>
+      mFreeCallbackRecords;
+
+  //! The allocator for message free callbacks - used when sending a message
+  //! from a nanoapp with a free callback
+  CallbackAllocator<MessageFreeCallbackData> mAllocator;
+
+  //! Mutex to protect mNanoappPublishedServices
+  Mutex mNanoappPublishedServicesMutex;
+
+  //! The vector of services published by nanoapps
+  DynamicVector<NanoappServiceData> mNanoappPublishedServices;
+
+  //! The vector of ready event requests
+  //! This should only be accessed from the event loop thread
+  DynamicVector<EndpointReadyEventData> mEndpointReadyEventRequests;
 };
 
 }  // namespace chre
diff --git a/core/include/chre/core/event.h b/core/include/chre/core/event.h
index de64bc69..0136a1ba 100644
--- a/core/include/chre/core/event.h
+++ b/core/include/chre/core/event.h
@@ -17,9 +17,9 @@
 #ifndef CHRE_CORE_EVENT_H_
 #define CHRE_CORE_EVENT_H_
 
-#include "chre/core/event_loop_common.h"
 #include "chre/platform/assert.h"
 #include "chre/util/non_copyable.h"
+#include "chre/util/system/system_callback_type.h"
 #include "chre_api/chre/event.h"
 
 #include <cstdint>
@@ -39,7 +39,7 @@ constexpr uint16_t kInvalidInstanceId = kBroadcastInstanceId;
 
 //! Default target group mask that results in the event being sent to any app
 //! registered for it.
-constexpr uint16_t kDefaultTargetGroupMask = UINT16_MAX;
+constexpr uint16_t kDefaultTargetGroupMask = 0;
 
 class Event : public NonCopyable {
  public:
@@ -61,7 +61,6 @@ class Event : public NonCopyable {
         isLowPriority(isLowPriority_) {
     // Sending events to the system must only be done via the other constructor
     CHRE_ASSERT(targetInstanceId_ != kSystemInstanceId);
-    CHRE_ASSERT(targetAppGroupMask_ > 0);
   }
 
   // Alternative constructor used for system-internal events (e.g. deferred
diff --git a/core/include/chre/core/event_loop.h b/core/include/chre/core/event_loop.h
index 97e11e59..723c44f8 100644
--- a/core/include/chre/core/event_loop.h
+++ b/core/include/chre/core/event_loop.h
@@ -101,13 +101,6 @@ class EventLoop : public NonCopyable {
    */
   bool findNanoappInstanceIdByAppId(uint64_t appId, uint16_t *instanceId) const;
 
-  /*
-   * Checks if the new wakeup buckets need to be pushed to nanoapps because the
-   * wakeup bucket interval has been surpassed since we pushed and pushes to the
-   * apps.
-   */
-  void handleNanoappWakeupBuckets();
-
   /**
    * Iterates over the list of Nanoapps managed by this EventLoop, and invokes
    * the supplied callback for each one. This holds a lock if necessary, so it
@@ -382,6 +375,18 @@ class EventLoop : public NonCopyable {
   void onMatchingNanoappEndpoint(
       const pw::Function<bool(const message::EndpointInfo &)> &function);
 
+  /**
+   * Executes function for each service provided by a nanoapp in the event
+   * loop. If function returns true, the iteration will stop.
+   *
+   * This function is safe to call from any thread.
+   *
+   * @param function The function to execute for each service.
+   */
+  void onMatchingNanoappService(
+      const pw::Function<bool(const message::EndpointInfo &,
+                              const message::ServiceInfo &)> &function);
+
   /**
    * Returns the EndpointInfo for the given nanoapp.
    *
@@ -444,10 +449,6 @@ class EventLoop : public NonCopyable {
   //! distributed out to apps yet.
   BlockingSegmentedQueue<Event *, kEventPerBlock> mEvents;
 #endif
-  //! The time interval of nanoapp wakeup buckets, adjust in conjunction with
-  //! Nanoapp::kMaxSizeWakeupBuckets.
-  static constexpr Nanoseconds kIntervalWakeupBucket =
-      Nanoseconds(180 * kOneMinuteInNanoseconds);
 
   //! The last time wakeup buckets were pushed onto the nanoapps.
   Nanoseconds mTimeLastWakeupBucketCycled;
@@ -485,6 +486,9 @@ class EventLoop : public NonCopyable {
   //! The number of events dropped due to capacity limits
   uint32_t mNumDroppedLowPriEvents = 0;
 
+  //! The timer used to cycle nanoapp wakeup buckets.
+  TimerHandle mCycleWakeupBucketsHandle = CHRE_TIMER_INVALID;
+
   /**
    * Modifies the run loop state so it no longer iterates on new events. This
    * should only be invoked by the event loop when it is ready to stop
@@ -628,6 +632,17 @@ class EventLoop : public NonCopyable {
    */
   message::EndpointInfo getEndpointInfoFromNanoappLocked(
       const Nanoapp &nanoapp);
+
+  /*
+   * Pushes new wakeup buckets that need to be pushed to nanoapps.
+   */
+  void handleNanoappWakeupBuckets();
+
+  /*
+   * Set up the timer used for calling handleNanoappWakeupBuckets() to cycle
+   * wakeup buckets once the wakeup bucket interval has been surpassed.
+   */
+  void setCycleWakeupBucketsTimer();
 };
 
 }  // namespace chre
diff --git a/core/include/chre/core/event_loop_manager.h b/core/include/chre/core/event_loop_manager.h
index 255f9eee..2d5e523c 100644
--- a/core/include/chre/core/event_loop_manager.h
+++ b/core/include/chre/core/event_loop_manager.h
@@ -19,13 +19,14 @@
 
 #include "chre/core/audio_request_manager.h"
 #include "chre/core/ble_request_manager.h"
+#include "chre/core/ble_socket_manager.h"
 #include "chre/core/chre_message_hub_manager.h"
 #include "chre/core/debug_dump_manager.h"
 #include "chre/core/event_loop.h"
-#include "chre/core/event_loop_common.h"
 #include "chre/core/gnss_manager.h"
 #include "chre/core/host_comms_manager.h"
 #include "chre/core/host_endpoint_manager.h"
+#include "chre/core/host_message_hub_manager.h"
 #include "chre/core/sensor_request_manager.h"
 #include "chre/core/settings.h"
 #include "chre/core/system_health_monitor.h"
@@ -39,6 +40,7 @@
 #include "chre/util/fixed_size_vector.h"
 #include "chre/util/non_copyable.h"
 #include "chre/util/singleton.h"
+#include "chre/util/system/system_callback_type.h"
 #include "chre/util/unique_ptr.h"
 #include "chre_api/chre/event.h"
 
@@ -221,6 +223,13 @@ class EventLoopManager : public NonCopyable {
   BleRequestManager &getBleRequestManager() {
     return mBleRequestManager;
   }
+
+#ifdef CHRE_BLE_SOCKET_SUPPORT_ENABLED
+  BleSocketManager &getBleSocketManager() {
+    return mBleSocketManager;
+  }
+#endif  // CHRE_BLE_SOCKET_SUPPORT_ENABLED
+
 #endif  // CHRE_BLE_SUPPORT_ENABLED
 
   /**
@@ -326,6 +335,10 @@ class EventLoopManager : public NonCopyable {
   ChreMessageHubManager &getChreMessageHubManager() {
     return mChreMessageHubManager;
   }
+
+  HostMessageHubManager &getHostMessageHubManager() {
+    return mHostMessageHubManager;
+  }
 #endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
 
   /**
@@ -349,6 +362,13 @@ class EventLoopManager : public NonCopyable {
   //! The BLE request manager handles requests for all nanoapps and manages
   //! the state of the BLE subsystem that the runtime subscribes to.
   BleRequestManager mBleRequestManager;
+
+#ifdef CHRE_BLE_SOCKET_SUPPORT_ENABLED
+  //! The BLE socket manager tracks offloaded sockets and handles sending
+  //! packets between nanoapps and offloaded sockets.
+  BleSocketManager mBleSocketManager;
+#endif  // CHRE_BLE_SOCKET_SUPPORT_ENABLED
+
 #endif  // CHRE_BLE_SUPPORT_ENABLED
 
   //! The event loop managed by this event loop manager.
@@ -403,6 +423,9 @@ class EventLoopManager : public NonCopyable {
 #ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
   //! The ChreMessageHubManager that manages the CHRE Message Hub.
   ChreMessageHubManager mChreMessageHubManager;
+
+  //! The HostMessageHubManager handling communication with host message hubs.
+  HostMessageHubManager mHostMessageHubManager;
 #endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
 };
 
diff --git a/core/include/chre/core/gnss_manager.h b/core/include/chre/core/gnss_manager.h
index ed595d9b..5f3cb77e 100644
--- a/core/include/chre/core/gnss_manager.h
+++ b/core/include/chre/core/gnss_manager.h
@@ -21,11 +21,11 @@
 
 #include <cstdint>
 
-#include "chre/core/api_manager_common.h"
 #include "chre/core/nanoapp.h"
 #include "chre/core/settings.h"
 #include "chre/platform/platform_gnss.h"
 #include "chre/util/non_copyable.h"
+#include "chre/util/system/chre_error_util.h"
 #include "chre/util/system/debug_dump.h"
 #include "chre/util/time.h"
 
diff --git a/core/include/chre/core/host_message_hub_manager.h b/core/include/chre/core/host_message_hub_manager.h
new file mode 100644
index 00000000..b78208a6
--- /dev/null
+++ b/core/include/chre/core/host_message_hub_manager.h
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+
+#include <optional>
+
+#include "chre/platform/memory.h"
+#include "chre/platform/mutex.h"
+#include "chre/util/lock_guard.h"
+#include "chre/util/memory_pool.h"
+#include "chre/util/non_copyable.h"
+#include "chre/util/system/message_common.h"
+#include "chre/util/system/message_router.h"
+
+#include "pw_allocator/allocator.h"
+#include "pw_allocator/unique_ptr.h"
+#include "pw_containers/intrusive_list.h"
+#include "pw_containers/vector.h"
+#include "pw_function/function.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
+#include "pw_intrusive_ptr/recyclable.h"
+#include "pw_span/span.h"
+
+#if !defined(CHRE_MESSAGE_ROUTER_MAX_HOST_HUBS)
+#error "Must define maximum host message hubs for platform"
+#elif defined(CHRE_MESSAGE_ROUTER_MAX_MESSAGE_HUBS) && \
+    CHRE_MESSAGE_ROUTER_MAX_HOST_HUBS >= CHRE_MESSAGE_ROUTER_MAX_MESSAGE_HUBS
+#error "Message hub limit must be greater than host message hub limit"
+#endif  // !defined(CHRE_MESSAGE_ROUTER_MAX_HOST_HUBS)
+
+#ifndef CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS
+#error "Must define maximum host endpoints for platform"
+#endif  // CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS
+
+namespace chre {
+
+/**
+ * Manages the registration of host-side message hubs with MessageRouter and
+ * routes messages between them.
+ */
+class HostMessageHubManager : public NonCopyable {
+ public:
+  /** Interface registered for routing communication to host hubs. */
+  class HostCallback {
+   public:
+    virtual ~HostCallback() = default;
+
+    /**
+     * Notifies the HAL that the host message hub proxies have been reset.
+     *
+     * Invoked within MessageHubManager::reset().
+     */
+    virtual void onReset() = 0;
+
+    /**
+     * Notifies the HAL of a new embedded message hub.
+     */
+    virtual void onHubRegistered(const message::MessageHubInfo &hub) = 0;
+
+    /**
+     * Notifies the HAL that an embedded hub has been removed.
+     */
+    virtual void onHubUnregistered(message::MessageHubId id) = 0;
+
+    /**
+     * Notifies the HAL of a new embedded endpoint.
+     */
+    virtual void onEndpointRegistered(
+        message::MessageHubId hub, const message::EndpointInfo &endpoint) = 0;
+
+    /**
+     * Adds a service for a new embedded endpoint.
+     */
+    virtual void onEndpointService(message::MessageHubId hub,
+                                   const message::EndpointId endpoint,
+                                   const message::ServiceInfo &service) = 0;
+
+    /**
+     * Notifies the HAL that it has all information on an embedded endpoint.
+     */
+    virtual void onEndpointReady(message::MessageHubId hub,
+                                 message::EndpointId endpoint) = 0;
+
+    /**
+     * Notifies the HAL that an embedded endpoint is gone.
+     */
+    virtual void onEndpointUnregistered(message::MessageHubId hub,
+                                        message::EndpointId endpoint) = 0;
+
+    /**
+     * Sends a message within a session.
+     *
+     * Invoked within MessageHubCallback::onMessageReceived().
+     *
+     * @param hub The destination hub id
+     * @param session The session id
+     * @param data Message data
+     * @param type Message type
+     * @param permissions Message permissiosn
+     * @return true if the message was successfully sent
+     */
+    virtual bool onMessageReceived(message::MessageHubId hub,
+                                   message::SessionId session,
+                                   pw::UniquePtr<std::byte[]> &&data,
+                                   uint32_t type, uint32_t permissions) = 0;
+    /**
+     * Sends a request to open a session with a host endpoint
+     *
+     * Invoked within MessageHubCallback::onSessionOpenRequest().
+     *
+     * @param session The session details
+     */
+    virtual void onSessionOpenRequest(const message::Session &session) = 0;
+
+    /**
+     * Sends a notification that a session has been accepted
+     *
+     * Invoked within MessageHubCallback::onSessionOpened().
+     *
+     * @param hub The id of the destination host hub
+     * @param session The session id
+     */
+    virtual void onSessionOpened(message::MessageHubId hub,
+                                 message::SessionId session) = 0;
+
+    /**
+     * Sends a notification that a session has been closed
+     *
+     * Invoked within MessageHubCallback::onSessionClosed().
+     *
+     * @param hub The id of the destination host hub
+     * @param session The session id
+     * @param reason The reason the session has been closed
+     */
+    virtual void onSessionClosed(message::MessageHubId hub,
+                                 message::SessionId session,
+                                 message::Reason reason) = 0;
+  };
+
+  HostMessageHubManager() = default;
+  ~HostMessageHubManager();
+
+  /**
+   * Initializes the interface for host communication
+   *
+   * Must be called exactly once before any other HostMessageHubManager APIs.
+   *
+   * @param cb Implementation of HostCallback
+   */
+  void onHostTransportReady(HostCallback &cb);
+
+  /**
+   * Resets host message hub state.
+   *
+   * Existing message hubs are cleared (see Hub::clear() below) though they
+   * remain registered with MessageRouter. When the same hub is registered again
+   * the same slot is re-activated.
+   */
+  void reset();
+
+  /**
+   * Registers a new host message hub
+   *
+   * @param info Details of the message hub
+   */
+  void registerHub(const message::MessageHubInfo &info);
+
+  /**
+   * Unregisters a host message hub
+   *
+   * @param id Id of the message hub
+   */
+  void unregisterHub(message::MessageHubId id);
+
+  /**
+   * Registers a host endpoint
+   *
+   * @param hubId Id of the owning message hub
+   * @param info Details of the endpoint
+   * @param services Services exposed by the endpoint. NOTE: serviceDescriptor
+   * must have been allocated with CHRE platform memoryAlloc().
+   */
+  void registerEndpoint(message::MessageHubId hubId,
+                        const message::EndpointInfo &info,
+                        DynamicVector<message::ServiceInfo> &&services);
+
+  /**
+   * Unregisters a host endpoint
+   *
+   * @param hubId Id of the owning message hub
+   * @param id Id of the endpoint
+   */
+  void unregisterEndpoint(message::MessageHubId hubId, message::EndpointId id);
+
+  /**
+   * Requests the creation of a new session
+   *
+   * @param hubId Id of the host hub
+   * @param endpointId Id of the host endpoint
+   * @param destinationHubId Id of the destination hub
+   * @param destinationEndpointId Id of the destination endpoint
+   * @param sessionId Id of the new session
+   * @param serviceDescriptor The protocol for the session (maybe nullptr)
+   */
+  void openSession(message::MessageHubId hubId, message::EndpointId endpointId,
+                   message::MessageHubId destinationHubId,
+                   message::EndpointId destinationEndpointId,
+                   message::SessionId sessionId, const char *serviceDescriptor);
+
+  /**
+   * Notifies that a new session has been accepted
+   *
+   * @param hubId Id of the sending host hub
+   * @param sessionId Id of the new session
+   */
+  void ackSession(message::MessageHubId hubId, message::SessionId sessionId);
+
+  /**
+   * Notifies that a session has been closed / rejected
+   *
+   * @param hubId Id of the sending host hub
+   * @param sessionId Id of the session
+   * @param reason The reason for the closure / rejection
+   */
+  void closeSession(message::MessageHubId hubId, message::SessionId sessionId,
+                    message::Reason reason);
+
+  /**
+   * Sends a message within a session
+   *
+   * @param hubId Id of the sending host hub
+   * @param sessionId Id of the session
+   * @param data Message data
+   * @param type Message type
+   * @param permissions Message permissions
+   */
+  void sendMessage(message::MessageHubId hubId, message::SessionId sessionId,
+                   pw::span<const std::byte> data, uint32_t type,
+                   uint32_t permissions);
+
+ private:
+  /**
+   * Wrapper around EndpointInfo and ServiceInfos which can be allocated from a
+   * pw::allocator::TypedPool and tracked per-hub in a pw::IntrusiveList. The
+   * serviceDescriptors must have been allocated by memoryAlloc() from
+   * chre/platform/memory.h.
+   */
+  struct Endpoint : public pw::IntrusiveList<Endpoint>::Item {
+    message::EndpointInfo kInfo;
+    DynamicVector<message::ServiceInfo> mServices;
+    explicit Endpoint(const message::EndpointInfo &info,
+                      DynamicVector<message::ServiceInfo> &&services)
+        : kInfo(info), mServices(std::move(services)) {}
+    ~Endpoint() {
+      for (const auto &service : mServices)
+        memoryFree(const_cast<char *>(service.serviceDescriptor));
+    }
+  };
+
+  /**
+   * Represents a host message hub. Registered with MessageRouter and stores the
+   * returned MessageRouter::MessageHub. Stores the list of registered endpoints
+   * for inspection by MessageRouter.
+   *
+   * The public APIs are expected to be called as a result of some host-side
+   * operation with HostMessageHubManager::mHubsLock held.
+   */
+  class Hub : public NonCopyable,
+              public message::MessageRouter::MessageHubCallback,
+              public pw::Recyclable<Hub> {
+   public:
+    /**
+     * Creates and registers a new hub.
+     *
+     * @param manager The manager instance
+     * @param info Details of the host message hub
+     * @param endpoints The list of endpoints to initialize the hub with.
+     * Endpoints must have been allocated using mEndpointAllocator.
+     * @return true on successful registration or reactivation
+     */
+    static bool createLocked(HostMessageHubManager *manager,
+                             const message::MessageHubInfo &info,
+                             pw::IntrusiveList<Endpoint> &endpoints);
+
+    /** NOTE: Use createLocked() */
+    Hub(HostMessageHubManager *manager, const char *name,
+        pw::IntrusiveList<Endpoint> &endpoints);
+    Hub(Hub &&) = delete;
+    Hub &operator=(Hub &&) = delete;
+    virtual ~Hub();
+
+    /**
+     * Marks the hub inactive and clears all endpoints. Also unregisters the
+     * hub from MessageRouter.
+     */
+    void clear();
+
+    void addEndpoint(const message::EndpointInfo &info,
+                     DynamicVector<message::ServiceInfo> &&services);
+
+    void removeEndpoint(message::EndpointId id);
+
+    message::MessageRouter::MessageHub &getMessageHub() {
+      return mMessageHub;
+    }
+
+   private:
+    friend class pw::Recyclable<Hub>;
+
+    static constexpr size_t kNameMaxLen = 50;
+
+    // Implementation of MessageRouter::MessageHubCallback;
+    bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
+                           uint32_t messageType, uint32_t messagePermissions,
+                           const message::Session &session,
+                           bool sentBySessionInitiator) override;
+    void onSessionOpenRequest(const message::Session &session) override;
+    void onSessionOpened(const message::Session &session) override;
+    void onSessionClosed(const message::Session &session,
+                         message::Reason reason) override;
+    void forEachEndpoint(const pw::Function<bool(const message::EndpointInfo &)>
+                             &function) override;
+    std::optional<message::EndpointInfo> getEndpointInfo(
+        message::EndpointId endpointId) override;
+    std::optional<message::EndpointId> getEndpointForService(
+        const char *serviceDescriptor) override;
+    bool doesEndpointHaveService(message::EndpointId endpointId,
+                                 const char *serviceDescriptor) override;
+    void forEachService(const pw::Function<bool(const message::EndpointInfo &,
+                                                const message::ServiceInfo &)>
+                            &function) override;
+    void onHubRegistered(const message::MessageHubInfo &info) override;
+    void onHubUnregistered(message::MessageHubId id) override;
+    void onEndpointRegistered(message::MessageHubId messageHubId,
+                              message::EndpointId endpointId) override;
+    void onEndpointUnregistered(message::MessageHubId messageHubId,
+                                message::EndpointId endpointId) override;
+    void pw_recycle() override;
+
+    char kName[kNameMaxLen + 1];
+
+    message::MessageRouter::MessageHub mMessageHub;
+
+    // The manager pointer and lock.
+    Mutex mManagerLock;
+    HostMessageHubManager *mManager;
+
+    // Guards mEndpoints. Must be the innermost lock.
+    Mutex mEndpointsLock;
+    pw::IntrusiveList<Endpoint> mEndpoints;
+  };
+
+  /**
+   * Trivial allocator wrapping the CHRE memory allocation platform APIs. It
+   * spits out pw::UniquePtr<std::byte> instances which can be passed to
+   * MessageRouter APIs.
+   */
+  // TODO(b/395649065): Move this into util
+  class ChreAllocator : public pw::Allocator {
+   public:
+    void *DoAllocate(Layout layout) override;
+    void DoDeallocate(void *ptr) override;
+  };
+
+  // Consumes and deallocates all entries in the list. Caller must ensure
+  // the HostMessageHubManager has not been destroyed.
+  static void deallocateEndpoints(pw::IntrusiveList<Endpoint> &endpoints);
+
+  /**
+   * Clears all hubs registered with MessageRouter. The caller must hold
+   * mHubsLock.
+   */
+  void clearHubsLocked();
+
+  HostCallback *mCb;
+  ChreAllocator mMsgAllocator;
+
+  // Endpoint storage and allocator.
+  // NOTE: This is only accessed on host-triggered invocations which take
+  // mHubsLock, so additional synchronization is not required.
+  MemoryPool<Endpoint, CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS>
+      mEndpointAllocator;
+
+  // Guards mHubs. This lock is only safe to take when coming from an external
+  // path, i.e. on message from the host. MessageRouter accesses Hub instances
+  // directly, i.e. not through mHubs via the registered MessageHubCallback
+  // interface.
+  Mutex mHubsLock;
+  pw::Vector<pw::IntrusivePtr<Hub>, CHRE_MESSAGE_ROUTER_MAX_HOST_HUBS> mHubs;
+
+  // Serializes embedded hub and endpoint state changes being sent to the host
+  // with the operations in reset().
+  Mutex mEmbeddedHubOpLock;
+};
+
+}  // namespace chre
+
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
diff --git a/core/include/chre/core/nanoapp.h b/core/include/chre/core/nanoapp.h
index 68404d2d..707fb4ed 100644
--- a/core/include/chre/core/nanoapp.h
+++ b/core/include/chre/core/nanoapp.h
@@ -279,6 +279,11 @@ class Nanoapp : public PlatformNanoapp {
     return mRpcServices;
   }
 
+  /**
+   * @return true if the nanoapp has the provided RPC service.
+   */
+  bool hasRpcService(uint64_t serviceId) const;
+
   /**
    * Adds a block of memory to the linked list of headers.
    *
diff --git a/core/include/chre/core/sensor_request_manager.h b/core/include/chre/core/sensor_request_manager.h
index 5509d94d..d8dbe80c 100644
--- a/core/include/chre/core/sensor_request_manager.h
+++ b/core/include/chre/core/sensor_request_manager.h
@@ -241,6 +241,16 @@ class SensorRequestManager : public NonCopyable {
    */
   void handleBiasEvent(uint32_t sensorHandle, void *biasData);
 
+  /**
+   * Helper functions to log sensor manager state to debug dump.
+   *
+   * @param debugDump The debug dump wrapper where a string can be printed
+   *     into one of the buffers.
+   */
+  void logCurrentSensorStateToBuffer(DebugDumpWrapper &debugDump) const;
+  void logSensorRequestLogsToBuffer(DebugDumpWrapper &debugDump) const;
+  void logSensorSamplingStatusLogsToBuffer(DebugDumpWrapper &debugDump) const;
+
   /**
    * Prints state in a string buffer. Must only be called from the context of
    * the main CHRE thread.
@@ -334,6 +344,24 @@ class SensorRequestManager : public NonCopyable {
     SensorMode mode;
   };
 
+  //! An internal structure to store sensor sampling status update
+  struct SensorSamplingStatusUpdateLog {
+    SensorSamplingStatusUpdateLog(Nanoseconds timestampIn,
+                                  uint32_t sensorHandleIn,
+                                  chreSensorSamplingStatus *statusIn)
+        : timestamp(timestampIn),
+          sensorHandle(sensorHandleIn),
+          enabled(statusIn->enabled),
+          interval(statusIn->interval),
+          latency(statusIn->latency) {}
+
+    Nanoseconds timestamp;
+    uint32_t sensorHandle;
+    bool enabled;
+    uint64_t interval;
+    uint64_t latency;
+  };
+
   //! The list of all sensors
   DynamicVector<Sensor> mSensors;
 
@@ -341,6 +369,11 @@ class SensorRequestManager : public NonCopyable {
   static constexpr size_t kMaxSensorRequestLogs = 15;
   ArrayQueue<SensorRequestLog, kMaxSensorRequestLogs> mSensorRequestLogs;
 
+  //! The list of logged sensor sampling update
+  static constexpr size_t kMaxSensorSamplingStatusUpdateLogs = 15;
+  ArrayQueue<SensorSamplingStatusUpdateLog, kMaxSensorSamplingStatusUpdateLogs>
+      mSensorSamplingUpdateLogs;
+
   //! A queue of flush requests made by nanoapps.
   static constexpr size_t kMaxFlushRequests = 16;
   FixedSizeVector<FlushRequest, kMaxFlushRequests> mFlushRequestQueue;
diff --git a/core/include/chre/core/system_health_monitor.h b/core/include/chre/core/system_health_monitor.h
index ea4af24f..4585877d 100644
--- a/core/include/chre/core/system_health_monitor.h
+++ b/core/include/chre/core/system_health_monitor.h
@@ -19,8 +19,6 @@
 
 #include <cstdint>
 
-#include "chre/platform/assert.h"
-#include "chre/platform/log.h"
 #include "chre/util/enum.h"
 #include "chre/util/non_copyable.h"
 
@@ -38,7 +36,8 @@ enum class HealthCheckId : uint16_t {
   WifiScanResponseTimeout = 0,
   WifiConfigureScanMonitorTimeout = 1,
   WifiRequestRangingTimeout = 2,
-  UnexpectedWifiPalCallback = 3,
+  UnexpectedWifiScanResponse = 3,
+  UnexpectedWifiScanMonitorStateChange = 4,
 
   //! Must be last
   NumCheckIds
diff --git a/core/include/chre/core/timer_pool.h b/core/include/chre/core/timer_pool.h
index ea0bbec4..3ce8de9a 100644
--- a/core/include/chre/core/timer_pool.h
+++ b/core/include/chre/core/timer_pool.h
@@ -20,17 +20,17 @@
 #include <cstdint>
 #include "chre_api/chre/re.h"
 
-#include "chre/core/event_loop_common.h"
 #include "chre/core/nanoapp.h"
 #include "chre/platform/mutex.h"
 #include "chre/platform/system_timer.h"
 #include "chre/util/non_copyable.h"
 #include "chre/util/priority_queue.h"
+#include "chre/util/system/system_callback_type.h"
 
 namespace chre {
 
 // Forward declaration needed to friend TimerPool.
-class TestTimer;
+class TimerTest;
 
 /**
  * The type to use when referring to a timer instance.
@@ -120,8 +120,8 @@ class TimerPool : public NonCopyable {
   }
 
  private:
-  // Allows TestTimer to access hasNanoappTimers.
-  friend class TestTimer;
+  // Allows TimerTest to access hasNanoappTimers.
+  friend class TimerTest;
 
   /**
    * Tracks metadata associated with a request for a timed event.
diff --git a/core/include/chre/core/wifi_request_manager.h b/core/include/chre/core/wifi_request_manager.h
index 46837d65..2709011d 100644
--- a/core/include/chre/core/wifi_request_manager.h
+++ b/core/include/chre/core/wifi_request_manager.h
@@ -19,14 +19,13 @@
 
 #ifdef CHRE_WIFI_SUPPORT_ENABLED
 
-#include "chre/core/api_manager_common.h"
 #include "chre/core/nanoapp.h"
 #include "chre/core/settings.h"
 #include "chre/core/timer_pool.h"
 #include "chre/platform/platform_wifi.h"
 #include "chre/util/buffer.h"
 #include "chre/util/non_copyable.h"
-#include "chre/util/optional.h"
+#include "chre/util/system/chre_error_util.h"
 #include "chre/util/system/debug_dump.h"
 #include "chre/util/time.h"
 #include "chre_api/chre/wifi.h"
@@ -344,19 +343,64 @@ class WifiRequestManager : public NonCopyable {
           scanParams(*scanParams_) {}
   };
 
-  //! An internal struct to hold scan request data for logging
-  struct WifiScanRequestLog {
-    WifiScanRequestLog(Nanoseconds timestampIn, uint16_t instanceIdIn,
-                       chreWifiScanType scanTypeIn, Milliseconds maxScanAgeMsIn)
-        : timestamp(timestampIn),
-          instanceId(instanceIdIn),
-          scanType(scanTypeIn),
-          maxScanAgeMs(maxScanAgeMsIn) {}
+  enum class WifiScanLogType : uint8_t {
+    SCAN_REQUEST = 0,
+    SCAN_RESPONSE = 1,
+    SCAN_EVENT = 2,
+    SCAN_MONITOR_REQUEST = 3,
+    SCAN_MONITOR_RESULT = 4,
+  };
+
+  //! An internal struct to hold PAL request/callback data for logging
+  struct DebugLogEntry {
+    static DebugLogEntry forScanRequest(uint16_t nanoappInstanceId,
+                                        const chreWifiScanParams &scanParams,
+                                        bool syncResult);
+    static DebugLogEntry forScanResponse(uint16_t nanoappInstanceId,
+                                         bool pending, uint8_t errorCode);
+    static DebugLogEntry forScanEvent(const chreWifiScanEvent &scanEvent);
+    static DebugLogEntry forScanMonitorRequest(uint16_t nanoappInstanceId,
+                                               bool enable, bool syncResult);
+    static DebugLogEntry forScanMonitorResult(uint16_t nanoappInstanceId,
+                                              bool enabled, uint8_t errorCode);
 
     Nanoseconds timestamp;
-    uint16_t instanceId;
-    enum chreWifiScanType scanType;
-    Milliseconds maxScanAgeMs;
+    WifiScanLogType logType;
+    union {
+      struct {
+        uint16_t nanoappInstanceId;
+        uint16_t maxScanAgeMs;
+        uint8_t scanType : 2;
+        uint8_t radioChainPref : 2;
+        uint8_t channelSet : 1;
+        bool syncResult;
+      } scanRequest;
+
+      struct {
+        uint16_t nanoappInstanceId;
+        bool pending;
+        uint8_t errorCode;
+      } scanResponse;
+
+      struct {
+        uint8_t resultCount;
+        uint8_t resultTotal;
+        uint8_t eventIndex;
+        uint8_t scanType;
+      } scanEvent;
+
+      struct {
+        uint16_t nanoappInstanceId;
+        bool enable;
+        bool syncResult;
+      } scanMonitorRequest;
+
+      struct {
+        uint16_t nanoappInstanceId;
+        bool enabled;
+        uint8_t errorCode;
+      } scanMonitorResult;
+    };
   };
 
   struct NanoappNanSubscriptions {
@@ -421,8 +465,7 @@ class WifiRequestManager : public NonCopyable {
       mPendingNanSubscribeRequests;
 
   //! List of most recent wifi scan request logs
-  static constexpr size_t kNumWifiRequestLogs = 10;
-  ArrayQueue<WifiScanRequestLog, kNumWifiRequestLogs> mWifiScanRequestLogs;
+  ArrayQueue<DebugLogEntry, 32> mDebugLogs;
 
   //! Manages the timer when a ranging request is dispatched to the PAL.
   TimerHandle mRequestRangingTimeoutHandle;
@@ -435,14 +478,17 @@ class WifiRequestManager : public NonCopyable {
   //! to the PAL.
   TimerHandle mScanRequestTimeoutHandle = CHRE_TIMER_INVALID;
 
-  //! System time when the last WiFi scan event was received.
-  Milliseconds mLastScanEventTime;
-
   //! ErrorCode Histogram for collected errors, the index of this array
   //! corresponds to the type of the errorcode
   uint32_t mScanMonitorErrorHistogram[CHRE_ERROR_SIZE] = {0};
   uint32_t mActiveScanErrorHistogram[CHRE_ERROR_SIZE] = {0};
 
+  void addDebugLog(const DebugLogEntry &&log) {
+    mDebugLogs.kick_push(log);
+  }
+  void dumpDebugLog(const DebugLogEntry &log,
+                    DebugDumpWrapper &debugDump) const;
+
   /**
    * @return true if the scan monitor is enabled by any nanoapps.
    */
@@ -751,16 +797,6 @@ class WifiRequestManager : public NonCopyable {
    */
   void handleFreeWifiScanEvent(chreWifiScanEvent *scanEvent);
 
-  /**
-   * Adds a wifi scan request log onto list possibly kicking earliest log out
-   * if full.
-   *
-   * @param nanoappInstanceId The instance Id of the requesting nanoapp
-   * @param params The chre wifi scan params
-   */
-  void addWifiScanRequestLog(uint16_t nanoappInstanceId,
-                             const chreWifiScanParams *params);
-
   /**
    * Releases a wifi event (scan, ranging, NAN discovery) after nanoapps have
    * consumed it.
@@ -920,6 +956,11 @@ class WifiRequestManager : public NonCopyable {
    * called after scan response and all pending data have been delivered.
    */
   void cancelScanRequestTimer();
+
+  void resetScanEventResultCountAccumulator() {
+    mScanEventResultCountAccumulator = 0;
+    mScanRequestResultsArePending = false;
+  }
 };
 
 }  // namespace chre
diff --git a/core/include/chre/core/wwan_request_manager.h b/core/include/chre/core/wwan_request_manager.h
index 9b8b1ef9..d77ea505 100644
--- a/core/include/chre/core/wwan_request_manager.h
+++ b/core/include/chre/core/wwan_request_manager.h
@@ -21,11 +21,11 @@
 
 #include <cstdint>
 
-#include "chre/core/api_manager_common.h"
 #include "chre/core/nanoapp.h"
 #include "chre/platform/platform_wwan.h"
 #include "chre/util/non_copyable.h"
 #include "chre/util/optional.h"
+#include "chre/util/system/chre_error_util.h"
 #include "chre/util/system/debug_dump.h"
 
 namespace chre {
diff --git a/core/nanoapp.cc b/core/nanoapp.cc
index f16dbae2..427d8c16 100644
--- a/core/nanoapp.cc
+++ b/core/nanoapp.cc
@@ -69,7 +69,7 @@ bool Nanoapp::isRegisteredForBroadcastEvent(const Event *event) const {
     size_t foundIndex = registrationIndex(eventType);
     if (foundIndex < mRegisteredEvents.size()) {
       const EventRegistration &reg = mRegisteredEvents[foundIndex];
-      if (targetGroupIdMask & reg.groupIdMask) {
+      if ((targetGroupIdMask & reg.groupIdMask) == targetGroupIdMask) {
         registered = true;
       }
     }
@@ -417,6 +417,15 @@ bool Nanoapp::publishRpcServices(struct chreNanoappRpcService *services,
   return success;
 }
 
+bool Nanoapp::hasRpcService(uint64_t serviceId) const {
+  for (const chreNanoappRpcService &service : mRpcServices) {
+    if (service.id == serviceId) {
+      return true;
+    }
+  }
+  return false;
+}
+
 void Nanoapp::linkHeapBlock(HeapBlockHeader *header) {
   header->data.next = mFirstHeader;
   mFirstHeader = header;
diff --git a/core/sensor_request_manager.cc b/core/sensor_request_manager.cc
index 2888ae0a..566e1a8a 100644
--- a/core/sensor_request_manager.cc
+++ b/core/sensor_request_manager.cc
@@ -514,6 +514,15 @@ void SensorRequestManager::handleSamplingStatusUpdate(
       EventLoopManagerSingleton::get()->getSensorRequestManager().getSensor(
           sensorHandle);
   if (sensor == nullptr || sensor->isOneShot()) {
+    if (sensor == nullptr) {
+      LOGW(
+          "Received a sampling status update for non existing sensorHandle "
+          "%" PRIu32,
+          sensorHandle);
+    } else {
+      LOGW("Received a sampling status update for one shot sensor %s",
+           sensor->getSensorName());
+    }
     releaseSamplingStatusUpdate(status);
   } else {
     sensor->setSamplingStatus(*status);
@@ -522,6 +531,10 @@ void SensorRequestManager::handleSamplingStatusUpdate(
       uint32_t cbSensorHandle = NestedDataPtr<uint32_t>(data);
       auto *cbStatus =
           static_cast<struct chreSensorSamplingStatus *>(extraData);
+      EventLoopManagerSingleton::get()
+          ->getSensorRequestManager()
+          .mSensorSamplingUpdateLogs.kick_push(SensorSamplingStatusUpdateLog(
+              SystemTime::getMonotonicTime(), cbSensorHandle, cbStatus));
       postSamplingStatus(cbSensorHandle, *cbStatus);
       EventLoopManagerSingleton::get()
           ->getSensorRequestManager()
@@ -564,39 +577,73 @@ void SensorRequestManager::handleBiasEvent(uint32_t sensorHandle,
   }
 }
 
-void SensorRequestManager::logStateToBuffer(DebugDumpWrapper &debugDump) const {
+void SensorRequestManager::logCurrentSensorStateToBuffer(
+    DebugDumpWrapper &debugDump) const {
   debugDump.print("\nSensors:\n");
   for (uint8_t i = 0; i < mSensors.size(); i++) {
     for (const auto &request : mSensors[i].getRequests()) {
-      // TODO: Rearrange these prints to be similar to sensor request logs
-      // below
-      debugDump.print(
-          " %s: mode=%d int=%" PRIu64 " lat=%" PRIu64 " nappId=%" PRIu16 "\n",
-          mSensors[i].getSensorTypeName(), static_cast<int>(request.getMode()),
-          request.getInterval().toRawNanoseconds(),
-          request.getLatency().toRawNanoseconds(), request.getInstanceId());
+      debugDump.print(" %s: instanceId=%" PRIu16 " mode=%s intervalNs=%" PRIu64
+                      " latencyNs=%" PRIu64 "\n",
+                      mSensors[i].getSensorTypeName(), request.getInstanceId(),
+                      getSensorModeName(request.getMode()),
+                      request.getInterval().toRawNanoseconds(),
+                      request.getLatency().toRawNanoseconds());
     }
   }
-  debugDump.print("\n Last %zu Sensor Requests:\n", mSensorRequestLogs.size());
+  debugDump.print("\n");
+}
+
+void SensorRequestManager::logSensorRequestLogsToBuffer(
+    DebugDumpWrapper &debugDump) const {
+  debugDump.print(" Last %zu Sensor Requests:\n", mSensorRequestLogs.size());
   static_assert(kMaxSensorRequestLogs <= INT8_MAX,
                 "kMaxSensorRequestLogs must be <= INT8_MAX");
   for (int8_t i = static_cast<int8_t>(mSensorRequestLogs.size()) - 1; i >= 0;
        i--) {
     const auto &log = mSensorRequestLogs[static_cast<size_t>(i)];
     const Sensor &sensor = mSensors[log.sensorHandle];
-    debugDump.print("  ts=%" PRIu64 " nappId=%" PRIu16 " type=%s idx=%" PRIu8
-                    " mask=%" PRIx16 " mode=%s",
+    debugDump.print("  ts=%" PRIu64 " instanceId=%" PRIu16
+                    " type=%s idx=%" PRIu8 " mask=%" PRIx16 " mode=%s",
                     log.timestamp.toRawNanoseconds(), log.instanceId,
                     sensor.getSensorTypeName(), sensor.getSensorIndex(),
                     sensor.getTargetGroupMask(), getSensorModeName(log.mode));
 
     if (sensorModeIsContinuous(log.mode)) {
-      debugDump.print(" int=%" PRIu64 " lat=%" PRIu64,
+      debugDump.print(" intervalNs=%" PRIu64 " latencyNs=%" PRIu64,
                       log.interval.toRawNanoseconds(),
                       log.latency.toRawNanoseconds());
     }
     debugDump.print("\n");
   }
+  debugDump.print("\n");
+}
+
+void SensorRequestManager::logSensorSamplingStatusLogsToBuffer(
+    DebugDumpWrapper &debugDump) const {
+  debugDump.print(" Last %zu Sensor Sampling Status Updates:\n",
+                  mSensorSamplingUpdateLogs.size());
+  static_assert(kMaxSensorRequestLogs <= INT8_MAX,
+                "kMaxSensorRequestLogs must be <= INT8_MAX");
+  for (int8_t i = static_cast<int8_t>(mSensorSamplingUpdateLogs.size()) - 1;
+       i >= 0; i--) {
+    const auto &log = mSensorSamplingUpdateLogs[static_cast<size_t>(i)];
+    const Sensor &sensor = mSensors[log.sensorHandle];
+    debugDump.print("  ts=%" PRIu64 " type=%s idx=%" PRIu8 " mask=%" PRIx16
+                    " enable=%s intervalNs=%" PRIu64 " latencyNs=%" PRIu64,
+                    log.timestamp.toRawNanoseconds(),
+                    sensor.getSensorTypeName(), sensor.getSensorIndex(),
+                    sensor.getTargetGroupMask(), log.enabled ? "true" : "false",
+                    log.interval, log.latency);
+
+    debugDump.print("\n");
+  }
+  debugDump.print("\n");
+}
+
+void SensorRequestManager::logStateToBuffer(DebugDumpWrapper &debugDump) const {
+  logCurrentSensorStateToBuffer(debugDump);
+  logSensorRequestLogsToBuffer(debugDump);
+  logSensorSamplingStatusLogsToBuffer(debugDump);
 }
 
 uint32_t SensorRequestManager::disableAllSubscriptions(Nanoapp *nanoapp) {
diff --git a/core/system_health_monitor.cc b/core/system_health_monitor.cc
index 04825b95..af70316f 100644
--- a/core/system_health_monitor.cc
+++ b/core/system_health_monitor.cc
@@ -17,6 +17,7 @@
 #include "chre/core/system_health_monitor.h"
 
 #include "chre/core/event_loop_manager.h"
+#include "chre/platform/assert.h"
 #include "chre/platform/fatal_error.h"
 #include "chre/platform/log.h"
 #include "chre/util/macros.h"
diff --git a/core/timer_pool.cc b/core/timer_pool.cc
index bb8b0957..d848979f 100644
--- a/core/timer_pool.cc
+++ b/core/timer_pool.cc
@@ -17,13 +17,13 @@
 #include "chre/core/timer_pool.h"
 #include "chre/core/event.h"
 #include "chre/core/event_loop.h"
-#include "chre/core/event_loop_common.h"
 #include "chre/core/event_loop_manager.h"
 #include "chre/platform/fatal_error.h"
 #include "chre/platform/log.h"
 #include "chre/platform/system_time.h"
 #include "chre/util/lock_guard.h"
 #include "chre/util/nested_data_ptr.h"
+#include "chre/util/system/system_callback_type.h"
 
 #include <cstdint>
 
@@ -273,8 +273,7 @@ bool TimerPool::handleExpiredTimersAndScheduleNextLocked() {
         success = EventLoopManagerSingleton::get()->deferCallback(
             SystemCallbackType::TimerPoolTimerExpired,
             NestedDataPtr<TimerHandle>(currentTimerRequest.timerHandle),
-            TimerPool::handleTimerExpiredCallback,
-            this);
+            TimerPool::handleTimerExpiredCallback, this);
       }
       if (!success) {
         LOGW("Failed to defer timer callback");
@@ -343,15 +342,14 @@ void TimerPool::handleSystemTimerCallback(void *timerPoolPtr) {
 void TimerPool::handleTimerExpiredCallback(uint16_t /* type */, void *data,
                                            void *extraData) {
   NestedDataPtr<TimerHandle> timerHandle(data);
-  TimerPool* timerPool = static_cast<TimerPool*>(extraData);
+  TimerPool *timerPool = static_cast<TimerPool *>(extraData);
   size_t index;
   TimerRequest currentTimerRequest;
 
   {
     LockGuard<Mutex> lock(timerPool->mMutex);
-    TimerRequest* timerRequest =
-        timerPool->getTimerRequestByTimerHandleLocked(
-            timerHandle, &index);
+    TimerRequest *timerRequest =
+        timerPool->getTimerRequestByTimerHandleLocked(timerHandle, &index);
     if (timerRequest == nullptr) {
       return;
     }
diff --git a/core/wifi_request_manager.cc b/core/wifi_request_manager.cc
index b95405b0..e1277f5e 100644
--- a/core/wifi_request_manager.cc
+++ b/core/wifi_request_manager.cc
@@ -29,12 +29,11 @@
 #include "chre/platform/fatal_error.h"
 #include "chre/platform/log.h"
 #include "chre/platform/system_time.h"
+#include "chre/util/enum.h"
 #include "chre/util/nested_data_ptr.h"
 #include "chre/util/system/debug_dump.h"
 #include "chre/util/system/event_callbacks.h"
 #include "chre_api/chre/version.h"
-#include "include/chre/core/event_loop_common.h"
-#include "include/chre/core/wifi_request_manager.h"
 
 // The default timeout values can be overwritten to lower the runtime
 // for tests. Timeout values cannot be overwritten with a bigger value.
@@ -62,6 +61,75 @@ static_assert(CHRE_TEST_WIFI_SCAN_RESULT_TIMEOUT_NS <=
 
 namespace chre {
 
+WifiRequestManager::DebugLogEntry
+WifiRequestManager::DebugLogEntry::forScanRequest(
+    uint16_t nanoappInstanceId, const chreWifiScanParams &scanParams,
+    bool syncResult) {
+  DebugLogEntry entry;
+  entry.timestamp = SystemTime::getMonotonicTime();
+  entry.logType = WifiScanLogType::SCAN_REQUEST;
+  entry.scanRequest.nanoappInstanceId = nanoappInstanceId;
+  entry.scanRequest.maxScanAgeMs =
+      (scanParams.maxScanAgeMs > UINT16_MAX)
+          ? UINT16_MAX
+          : static_cast<uint16_t>(scanParams.maxScanAgeMs);
+  entry.scanRequest.scanType = scanParams.scanType;
+  entry.scanRequest.radioChainPref = scanParams.radioChainPref;
+  entry.scanRequest.channelSet = scanParams.channelSet;
+  entry.scanRequest.syncResult = syncResult;
+  return entry;
+}
+
+WifiRequestManager::DebugLogEntry
+WifiRequestManager::DebugLogEntry::forScanResponse(uint16_t nanoappInstanceId,
+                                                   bool pending,
+                                                   uint8_t errorCode) {
+  DebugLogEntry entry;
+  entry.timestamp = SystemTime::getMonotonicTime();
+  entry.logType = WifiScanLogType::SCAN_RESPONSE;
+  entry.scanResponse.nanoappInstanceId = nanoappInstanceId;
+  entry.scanResponse.pending = pending;
+  entry.scanResponse.errorCode = errorCode;
+  return entry;
+}
+
+WifiRequestManager::DebugLogEntry
+WifiRequestManager::DebugLogEntry::forScanEvent(
+    const chreWifiScanEvent &scanEvent) {
+  DebugLogEntry entry;
+  entry.timestamp = SystemTime::getMonotonicTime();
+  entry.logType = WifiScanLogType::SCAN_EVENT;
+  entry.scanEvent.resultCount = scanEvent.resultCount;
+  entry.scanEvent.resultTotal = scanEvent.resultTotal;
+  entry.scanEvent.eventIndex = scanEvent.eventIndex;
+  entry.scanEvent.scanType = scanEvent.scanType;
+  return entry;
+}
+
+WifiRequestManager::DebugLogEntry
+WifiRequestManager::DebugLogEntry::forScanMonitorRequest(
+    uint16_t nanoappInstanceId, bool enable, bool syncResult) {
+  DebugLogEntry entry;
+  entry.timestamp = SystemTime::getMonotonicTime();
+  entry.logType = WifiScanLogType::SCAN_MONITOR_REQUEST;
+  entry.scanMonitorRequest.nanoappInstanceId = nanoappInstanceId;
+  entry.scanMonitorRequest.enable = enable;
+  entry.scanMonitorRequest.syncResult = syncResult;
+  return entry;
+}
+
+WifiRequestManager::DebugLogEntry
+WifiRequestManager::DebugLogEntry::forScanMonitorResult(
+    uint16_t nanoappInstanceId, bool enabled, uint8_t errorCode) {
+  DebugLogEntry entry;
+  entry.timestamp = SystemTime::getMonotonicTime();
+  entry.logType = WifiScanLogType::SCAN_MONITOR_RESULT;
+  entry.scanMonitorResult.nanoappInstanceId = nanoappInstanceId;
+  entry.scanMonitorResult.enabled = enabled;
+  entry.scanMonitorResult.errorCode = errorCode;
+  return entry;
+}
+
 WifiRequestManager::WifiRequestManager() {
   // Reserve space for at least one scan monitoring nanoapp. This ensures that
   // the first asynchronous push_back will succeed. Future push_backs will be
@@ -93,7 +161,12 @@ void WifiRequestManager::dispatchQueuedConfigureScanMonitorRequests() {
           stateTransition.enable, CHRE_ERROR_NONE, stateTransition.cookie);
     } else if (scanMonitorStateTransitionIsRequired(stateTransition.enable,
                                                     hasScanMonitorRequest)) {
-      if (!mPlatformWifi.configureScanMonitor(stateTransition.enable)) {
+      bool syncResult =
+          mPlatformWifi.configureScanMonitor(stateTransition.enable);
+      addDebugLog(DebugLogEntry::forScanMonitorRequest(
+          stateTransition.nanoappInstanceId, stateTransition.enable,
+          syncResult));
+      if (!syncResult) {
         postScanMonitorAsyncResultEventFatal(
             stateTransition.nanoappInstanceId, false /* success */,
             stateTransition.enable, CHRE_ERROR, stateTransition.cookie);
@@ -151,6 +224,8 @@ bool WifiRequestManager::configureScanMonitor(Nanoapp *nanoapp, bool enable,
     success = addScanMonitorRequestToQueue(nanoapp, enable, cookie);
     if (success) {
       success = mPlatformWifi.configureScanMonitor(enable);
+      addDebugLog(
+          DebugLogEntry::forScanMonitorRequest(instanceId, enable, success));
       if (!success) {
         mPendingScanMonitorRequests.pop_back();
         LOGE("Failed to enable the scan monitor for nanoapp instance %" PRIu16,
@@ -315,6 +390,9 @@ void WifiRequestManager::handleScanRequestTimeout() {
   } else {
     EventLoopManagerSingleton::get()->getSystemHealthMonitor().onFailure(
         HealthCheckId::WifiScanResponseTimeout);
+    // Reset the scan accumulator logic to prevent interference with the next
+    // scan request.
+    resetScanEventResultCountAccumulator();
     mPendingScanRequests.pop();
     dispatchQueuedScanRequests(true /* postAsyncResult */);
   }
@@ -670,26 +748,76 @@ void WifiRequestManager::handleNanServiceSubscriptionCanceledEvent(
       NestedDataPtr<uint32_t>(subscriptionId));
 }
 
+void WifiRequestManager::dumpDebugLog(const DebugLogEntry &log,
+                                      DebugDumpWrapper &debugDump) const {
+  debugDump.print("  ts=%" PRIu64 " ", log.timestamp.toRawNanoseconds());
+  switch (log.logType) {
+    case WifiScanLogType::SCAN_REQUEST:
+      debugDump.print("scanReq: nappId=%" PRIu16 " scanType=%" PRIu8
+                      " maxScanAge(ms)=%" PRIu16 " radioChainPref=%" PRIu8
+                      " channelSet=%" PRIu8 " syncResult=%d\n",
+                      log.scanRequest.nanoappInstanceId,
+                      log.scanRequest.scanType,
+                      log.scanRequest.maxScanAgeMs,
+                      log.scanRequest.radioChainPref,
+                      log.scanRequest.channelSet,
+                      log.scanRequest.syncResult);
+      break;
+    case WifiScanLogType::SCAN_RESPONSE:
+      debugDump.print("scanRsp: nappId=%" PRIu16 " pending=%" PRIu8
+                      " errorCode=%" PRIu8 "\n",
+                      log.scanResponse.nanoappInstanceId,
+                      log.scanResponse.pending,
+                      log.scanResponse.errorCode);
+      break;
+    case WifiScanLogType::SCAN_EVENT:
+      debugDump.print("scanEvt: resultCount=%" PRIu8 " resultTotal=%" PRIu8
+                      " eventIndex=%" PRIu8 " scanType=%" PRIu8 "\n",
+                      log.scanEvent.resultCount,
+                      log.scanEvent.resultTotal,
+                      log.scanEvent.eventIndex,
+                      log.scanEvent.scanType);
+      break;
+    case WifiScanLogType::SCAN_MONITOR_REQUEST:
+      debugDump.print("scanMonReq: nappId=%" PRIu16 " enable=%" PRIu8
+                      " syncResult=%" PRIu8 "\n",
+                      log.scanMonitorRequest.nanoappInstanceId,
+                      log.scanMonitorRequest.enable,
+                      log.scanMonitorRequest.syncResult);
+      break;
+    case WifiScanLogType::SCAN_MONITOR_RESULT:
+      debugDump.print("scanMonRes: nappId=%" PRIu16 " enabled=%" PRIu8
+                      " errorCode=%" PRIu8 "\n",
+                      log.scanMonitorResult.nanoappInstanceId,
+                      log.scanMonitorResult.enabled,
+                      log.scanMonitorResult.errorCode);
+      break;
+    default:
+      debugDump.print("unknown log type %" PRIu8 "\n", asBaseType(log.logType));
+  }
+}
+
 void WifiRequestManager::logStateToBuffer(DebugDumpWrapper &debugDump) const {
-  debugDump.print("\nWifi scan monitor %s\n",
+  debugDump.print("\nWIFI:\n");
+  debugDump.print(" Scan monitor: %s\n",
                   scanMonitorIsEnabled() ? "enabled" : "disabled");
 
   if (scanMonitorIsEnabled()) {
-    debugDump.print(" Wifi scan monitor enabled nanoapps:\n");
+    debugDump.print(" Scan monitor nanoapps:\n");
     for (uint16_t instanceId : mScanMonitorNanoapps) {
       debugDump.print("  nappId=%" PRIu16 "\n", instanceId);
     }
   }
 
   if (!mPendingScanRequests.empty()) {
-    debugDump.print(" Wifi scan request queue:\n");
+    debugDump.print(" Pending scan requests:\n");
     for (const auto &request : mPendingScanRequests) {
-      debugDump.print(" nappId=%" PRIu16, request.nanoappInstanceId);
+      debugDump.print("  nappId=%" PRIu16 "\n", request.nanoappInstanceId);
     }
   }
 
   if (!mPendingScanMonitorRequests.empty()) {
-    debugDump.print(" Wifi transition queue:\n");
+    debugDump.print(" Pending scan monitor requests:\n");
     for (const auto &transition : mPendingScanMonitorRequests) {
       debugDump.print("  enable=%s nappId=%" PRIu16 "\n",
                       transition.enable ? "true" : "false",
@@ -697,24 +825,12 @@ void WifiRequestManager::logStateToBuffer(DebugDumpWrapper &debugDump) const {
     }
   }
 
-  debugDump.print(" Last %zu wifi scan requests:\n",
-                  mWifiScanRequestLogs.size());
-  static_assert(kNumWifiRequestLogs <= INT8_MAX,
-                "kNumWifiRequestLogs must be <= INT8_MAX");
-
-  for (int8_t i = static_cast<int8_t>(mWifiScanRequestLogs.size()) - 1; i >= 0;
-       i--) {
-    const auto &log = mWifiScanRequestLogs[static_cast<size_t>(i)];
-    debugDump.print("  ts=%" PRIu64 " nappId=%" PRIu16 " scanType=%" PRIu8
-                    " maxScanAge(ms)=%" PRIu64 "\n",
-                    log.timestamp.toRawNanoseconds(), log.instanceId,
-                    static_cast<uint8_t>(log.scanType),
-                    log.maxScanAgeMs.getMilliseconds());
+  size_t i = mDebugLogs.size();
+  debugDump.print(" Last %zu debug entries:\n", i);
+  while (i-- > 0) {
+    dumpDebugLog(mDebugLogs[i], debugDump);
   }
 
-  debugDump.print(" Last scan event @ %" PRIu64 " ms\n",
-                  mLastScanEventTime.getMilliseconds());
-
   debugDump.print(" API error distribution (error-code indexed):\n");
   debugDump.print("   Scan monitor:\n");
   debugDump.logErrorHistogram(mScanMonitorErrorHistogram,
@@ -849,7 +965,13 @@ bool WifiRequestManager::postScanMonitorAsyncResultEvent(
     const void *cookie) {
   // Allocate and post an event to the nanoapp requesting wifi.
   bool eventPosted = false;
-  if (!success || updateNanoappScanMonitoringList(enable, nanoappInstanceId)) {
+  // If we failed to enable, don't add the nanoapp to the list, but always
+  // remove it if it was trying to disable. This keeps us from getting stuck in
+  // a state where we think the scan monitor is enabled (because the list is
+  // non-empty) when we actually aren't sure (e.g. the scan monitor disablement
+  // may have been handled but delivering the result ran into an error).
+  if ((!success && enable) ||
+      updateNanoappScanMonitoringList(enable, nanoappInstanceId)) {
     chreAsyncResult *event = memoryAlloc<chreAsyncResult>();
     if (event == nullptr) {
       LOG_OOM();
@@ -927,28 +1049,26 @@ void WifiRequestManager::postScanRequestAsyncResultEventFatal(
 }
 
 void WifiRequestManager::postScanEventFatal(chreWifiScanEvent *event) {
-  mLastScanEventTime = Milliseconds(SystemTime::getMonotonicTime());
   EventLoopManagerSingleton::get()->getEventLoop().postEventOrDie(
       CHRE_EVENT_WIFI_SCAN_RESULT, event, freeWifiScanEventCallback);
 }
 
 void WifiRequestManager::handleScanMonitorStateChangeSync(bool enabled,
                                                           uint8_t errorCode) {
-  // Success is defined as having no errors ... in life   _ 
-  bool success = (errorCode == CHRE_ERROR_NONE);
-
-  // TODO(b/62904616): re-enable this assertion
-  // CHRE_ASSERT_LOG(!mScanMonitorStateTransitions.empty(),
-  //                "handleScanMonitorStateChangeSync called with no
-  //                transitions");
+  addDebugLog(DebugLogEntry::forScanMonitorResult(
+      mPendingScanMonitorRequests.empty()
+          ? kSystemInstanceId
+          : mPendingScanMonitorRequests.front().nanoappInstanceId,
+      enabled, errorCode));
   if (mPendingScanMonitorRequests.empty()) {
-    LOGE(
-        "WiFi PAL error: handleScanMonitorStateChangeSync called with no "
-        "transitions (enabled %d errorCode %" PRIu8 ")",
-        enabled, errorCode);
+    LOGE("Scan monitor change with no pending requests (enabled %d "
+         "errorCode %" PRIu8 ")", enabled, errorCode);
+    EventLoopManagerSingleton::get()->getSystemHealthMonitor().onFailure(
+        HealthCheckId::UnexpectedWifiScanMonitorStateChange);
   }
 
-  // Always check the front of the queue.
+  // Success is defined as having no errors ... in life   _ 
+  bool success = (errorCode == CHRE_ERROR_NONE);
   if (!mPendingScanMonitorRequests.empty()) {
     const auto &stateTransition = mPendingScanMonitorRequests.front();
     success &= (stateTransition.enable == enabled);
@@ -983,15 +1103,16 @@ void WifiRequestManager::postNanAsyncResultEvent(uint16_t nanoappInstanceId,
 
 void WifiRequestManager::handleScanResponseSync(bool pending,
                                                 uint8_t errorCode) {
-  // TODO(b/65206783): re-enable this assertion
-  // CHRE_ASSERT_LOG(mPendingScanRequests.empty(),
-  //                "handleScanResponseSync called with no outstanding
-  //                request");
+  addDebugLog(DebugLogEntry::forScanResponse(
+      mPendingScanRequests.empty()
+          ? kSystemInstanceId
+          : mPendingScanRequests.front().nanoappInstanceId,
+      pending, errorCode));
   if (mPendingScanRequests.empty()) {
-    LOGE("handleScanResponseSync called with no outstanding request");
+    EventLoopManagerSingleton::get()->getSystemHealthMonitor().onFailure(
+        HealthCheckId::UnexpectedWifiScanResponse);
   }
 
-  // TODO: raise this to CHRE_ASSERT_LOG
   if (!pending && errorCode == CHRE_ERROR_NONE) {
     LOGE("Invalid wifi scan response");
     errorCode = CHRE_ERROR;
@@ -1123,11 +1244,18 @@ bool WifiRequestManager::dispatchQueuedScanRequests(bool postAsyncResult) {
              ->getSettingManager()
              .getSettingEnabled(Setting::WIFI_AVAILABLE)) {
       asyncError = CHRE_ERROR_FUNCTION_DISABLED;
-    } else if (!mPlatformWifi.requestScan(&currentScanRequest.scanParams)) {
-      asyncError = CHRE_ERROR;
     } else {
-      mScanRequestTimeoutHandle = setScanRequestTimer();
-      return true;
+      bool syncResult =
+          mPlatformWifi.requestScan(&currentScanRequest.scanParams);
+      addDebugLog(DebugLogEntry::forScanRequest(
+          currentScanRequest.nanoappInstanceId, currentScanRequest.scanParams,
+          syncResult));
+      if (!syncResult) {
+        asyncError = CHRE_ERROR;
+      } else {
+        mScanRequestTimeoutHandle = setScanRequestTimer();
+        return true;
+      }
     }
 
     if (postAsyncResult) {
@@ -1169,13 +1297,13 @@ void WifiRequestManager::handleRangingEventSync(
 }
 
 void WifiRequestManager::handleFreeWifiScanEvent(chreWifiScanEvent *scanEvent) {
+  addDebugLog(DebugLogEntry::forScanEvent(*scanEvent));
   if (mScanRequestResultsArePending) {
     // Reset the event distribution logic once an entire scan event has been
     // received and processed by the nanoapp requesting the scan event.
     mScanEventResultCountAccumulator += scanEvent->resultCount;
     if (mScanEventResultCountAccumulator >= scanEvent->resultTotal) {
-      mScanEventResultCountAccumulator = 0;
-      mScanRequestResultsArePending = false;
+      resetScanEventResultCountAccumulator();
       cancelScanRequestTimer();
     }
 
@@ -1198,14 +1326,6 @@ void WifiRequestManager::handleFreeWifiScanEvent(chreWifiScanEvent *scanEvent) {
   mPlatformWifi.releaseScanEvent(scanEvent);
 }
 
-void WifiRequestManager::addWifiScanRequestLog(
-    uint16_t nanoappInstanceId, const chreWifiScanParams *params) {
-  mWifiScanRequestLogs.kick_push(
-      WifiScanRequestLog(SystemTime::getMonotonicTime(), nanoappInstanceId,
-                         static_cast<chreWifiScanType>(params->scanType),
-                         static_cast<Milliseconds>(params->maxScanAgeMs)));
-}
-
 void WifiRequestManager::freeWifiScanEventCallback(uint16_t /* eventType */,
                                                    void *eventData) {
   auto *scanEvent = static_cast<struct chreWifiScanEvent *>(eventData);
diff --git a/doc/vendor_extensions.md b/doc/vendor_extensions.md
index 68c21367..2637a7e3 100644
--- a/doc/vendor_extensions.md
+++ b/doc/vendor_extensions.md
@@ -56,6 +56,22 @@ the API be placed outside of the CHRE tree, in a separate Git project under
 `vendor/` in the Android tree, to avoid potential conflicts when upgrading to a
 new version of CHRE.
 
+## Vendor sensor types
+
+CHRE has reserved a range of types for vendors to define their own sensor types.
+The starting point is `CHRE_SENSOR_TYPE_VENDOR_START`. For example, a vendor can
+define their own type as:
+
+```
+#define CHREX_SENSOR_TYPE_NEUTRINO_DETECTOR (CHRE_SENSOR_TYPE_VENDOR_START + X)
+```
+
+In `platform/shared/sensor_pal/platform_sensor_type_helpers.cc` macro
+`CHREX_SENSOR_SUPPORT` is used to select whether vendor sensor types are
+supported or not. Such macro can be defined in the `variant.mk`, e.g.,
+`variant/tinysys/variant.mk` for tinysys, to selectively pull in source files
+from vendor specific projects during compilation.
+
 ### Build Customization
 
 As part of the CHRE framework build system, the `CHRE_VARIANT_MK_INCLUDES`
diff --git a/host/common/config_util.cc b/host/common/config_util.cc
index c4e49f72..3c9d952e 100644
--- a/host/common/config_util.cc
+++ b/host/common/config_util.cc
@@ -17,6 +17,7 @@
 #include "chre_host/config_util.h"
 #include "chre_host/log.h"
 
+#include <algorithm>
 #include <dirent.h>
 #include <json/json.h>
 #include <filesystem>
@@ -44,6 +45,7 @@ bool findAllNanoappsInFolder(const std::string &path,
     outNanoapps.push_back(nanoapp_name);
   }
   closedir(dir);
+  std::sort(outNanoapps.begin(), outNanoapps.end());
   return true;
 }
 
diff --git a/host/common/host_protocol_host.cc b/host/common/host_protocol_host.cc
index 830f1a5a..d87a31d9 100644
--- a/host/common/host_protocol_host.cc
+++ b/host/common/host_protocol_host.cc
@@ -19,6 +19,7 @@
 #include <inttypes.h>
 #include <string.h>
 
+#include "chre_host/generated/host_messages_generated.h"
 #include "chre_host/log.h"
 
 using flatbuffers::FlatBufferBuilder;
@@ -87,6 +88,12 @@ bool HostProtocolHost::decodeMessageFromChre(const void *message,
         handlers.handleSelfTestResponse(*msg.AsSelfTestResponse());
         break;
 
+      case fbs::ChreMessage::BtSocketOpenResponse:
+      case fbs::ChreMessage::BtSocketClose:
+      case fbs::ChreMessage::BtSocketCapabilitiesResponse:
+        handlers.handleBluetoothSocketMessage(message, messageLen);
+        break;
+
       default:
         success = handlers.handleContextHubV4Message(msg);
     }
diff --git a/host/common/include/chre_host/generated/host_messages_generated.h b/host/common/include/chre_host/generated/host_messages_generated.h
index 613b27f7..9ed14e25 100644
--- a/host/common/include/chre_host/generated/host_messages_generated.h
+++ b/host/common/include/chre_host/generated/host_messages_generated.h
@@ -165,6 +165,22 @@ struct BtSocketCloseResponse;
 struct BtSocketCloseResponseBuilder;
 struct BtSocketCloseResponseT;
 
+struct BtSocketCapabilitiesRequest;
+struct BtSocketCapabilitiesRequestBuilder;
+struct BtSocketCapabilitiesRequestT;
+
+struct BtSocketLeCocCapabilities;
+struct BtSocketLeCocCapabilitiesBuilder;
+struct BtSocketLeCocCapabilitiesT;
+
+struct BtSocketRfcommCapabilities;
+struct BtSocketRfcommCapabilitiesBuilder;
+struct BtSocketRfcommCapabilitiesT;
+
+struct BtSocketCapabilitiesResponse;
+struct BtSocketCapabilitiesResponseBuilder;
+struct BtSocketCapabilitiesResponseT;
+
 struct VendorHubInfo;
 struct VendorHubInfoBuilder;
 struct VendorHubInfoT;
@@ -197,6 +213,14 @@ struct RegisterEndpoint;
 struct RegisterEndpointBuilder;
 struct RegisterEndpointT;
 
+struct AddServiceToEndpoint;
+struct AddServiceToEndpointBuilder;
+struct AddServiceToEndpointT;
+
+struct EndpointReady;
+struct EndpointReadyBuilder;
+struct EndpointReadyT;
+
 struct UnregisterEndpoint;
 struct UnregisterEndpointBuilder;
 struct UnregisterEndpointT;
@@ -818,11 +842,15 @@ enum class ChreMessage : uint8_t {
   EndpointSessionClosed = 45,
   EndpointSessionMessage = 46,
   EndpointSessionMessageDeliveryStatus = 47,
+  BtSocketCapabilitiesRequest = 48,
+  BtSocketCapabilitiesResponse = 49,
+  AddServiceToEndpoint = 50,
+  EndpointReady = 51,
   MIN = NONE,
-  MAX = EndpointSessionMessageDeliveryStatus
+  MAX = EndpointReady
 };
 
-inline const ChreMessage (&EnumValuesChreMessage())[48] {
+inline const ChreMessage (&EnumValuesChreMessage())[52] {
   static const ChreMessage values[] = {
     ChreMessage::NONE,
     ChreMessage::NanoappMessage,
@@ -871,13 +899,17 @@ inline const ChreMessage (&EnumValuesChreMessage())[48] {
     ChreMessage::EndpointSessionOpened,
     ChreMessage::EndpointSessionClosed,
     ChreMessage::EndpointSessionMessage,
-    ChreMessage::EndpointSessionMessageDeliveryStatus
+    ChreMessage::EndpointSessionMessageDeliveryStatus,
+    ChreMessage::BtSocketCapabilitiesRequest,
+    ChreMessage::BtSocketCapabilitiesResponse,
+    ChreMessage::AddServiceToEndpoint,
+    ChreMessage::EndpointReady
   };
   return values;
 }
 
 inline const char * const *EnumNamesChreMessage() {
-  static const char * const names[49] = {
+  static const char * const names[53] = {
     "NONE",
     "NanoappMessage",
     "HubInfoRequest",
@@ -926,13 +958,17 @@ inline const char * const *EnumNamesChreMessage() {
     "EndpointSessionClosed",
     "EndpointSessionMessage",
     "EndpointSessionMessageDeliveryStatus",
+    "BtSocketCapabilitiesRequest",
+    "BtSocketCapabilitiesResponse",
+    "AddServiceToEndpoint",
+    "EndpointReady",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameChreMessage(ChreMessage e) {
-  if (flatbuffers::IsOutRange(e, ChreMessage::NONE, ChreMessage::EndpointSessionMessageDeliveryStatus)) return "";
+  if (flatbuffers::IsOutRange(e, ChreMessage::NONE, ChreMessage::EndpointReady)) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesChreMessage()[index];
 }
@@ -1129,6 +1165,22 @@ template<> struct ChreMessageTraits<chre::fbs::EndpointSessionMessageDeliverySta
   static const ChreMessage enum_value = ChreMessage::EndpointSessionMessageDeliveryStatus;
 };
 
+template<> struct ChreMessageTraits<chre::fbs::BtSocketCapabilitiesRequest> {
+  static const ChreMessage enum_value = ChreMessage::BtSocketCapabilitiesRequest;
+};
+
+template<> struct ChreMessageTraits<chre::fbs::BtSocketCapabilitiesResponse> {
+  static const ChreMessage enum_value = ChreMessage::BtSocketCapabilitiesResponse;
+};
+
+template<> struct ChreMessageTraits<chre::fbs::AddServiceToEndpoint> {
+  static const ChreMessage enum_value = ChreMessage::AddServiceToEndpoint;
+};
+
+template<> struct ChreMessageTraits<chre::fbs::EndpointReady> {
+  static const ChreMessage enum_value = ChreMessage::EndpointReady;
+};
+
 struct ChreMessageUnion {
   ChreMessage type;
   void *value;
@@ -1537,6 +1589,38 @@ struct ChreMessageUnion {
     return type == ChreMessage::EndpointSessionMessageDeliveryStatus ?
       reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatusT *>(value) : nullptr;
   }
+  chre::fbs::BtSocketCapabilitiesRequestT *AsBtSocketCapabilitiesRequest() {
+    return type == ChreMessage::BtSocketCapabilitiesRequest ?
+      reinterpret_cast<chre::fbs::BtSocketCapabilitiesRequestT *>(value) : nullptr;
+  }
+  const chre::fbs::BtSocketCapabilitiesRequestT *AsBtSocketCapabilitiesRequest() const {
+    return type == ChreMessage::BtSocketCapabilitiesRequest ?
+      reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequestT *>(value) : nullptr;
+  }
+  chre::fbs::BtSocketCapabilitiesResponseT *AsBtSocketCapabilitiesResponse() {
+    return type == ChreMessage::BtSocketCapabilitiesResponse ?
+      reinterpret_cast<chre::fbs::BtSocketCapabilitiesResponseT *>(value) : nullptr;
+  }
+  const chre::fbs::BtSocketCapabilitiesResponseT *AsBtSocketCapabilitiesResponse() const {
+    return type == ChreMessage::BtSocketCapabilitiesResponse ?
+      reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponseT *>(value) : nullptr;
+  }
+  chre::fbs::AddServiceToEndpointT *AsAddServiceToEndpoint() {
+    return type == ChreMessage::AddServiceToEndpoint ?
+      reinterpret_cast<chre::fbs::AddServiceToEndpointT *>(value) : nullptr;
+  }
+  const chre::fbs::AddServiceToEndpointT *AsAddServiceToEndpoint() const {
+    return type == ChreMessage::AddServiceToEndpoint ?
+      reinterpret_cast<const chre::fbs::AddServiceToEndpointT *>(value) : nullptr;
+  }
+  chre::fbs::EndpointReadyT *AsEndpointReady() {
+    return type == ChreMessage::EndpointReady ?
+      reinterpret_cast<chre::fbs::EndpointReadyT *>(value) : nullptr;
+  }
+  const chre::fbs::EndpointReadyT *AsEndpointReady() const {
+    return type == ChreMessage::EndpointReady ?
+      reinterpret_cast<const chre::fbs::EndpointReadyT *>(value) : nullptr;
+  }
 };
 
 bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type);
@@ -5151,6 +5235,270 @@ inline flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(
 
 flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCloseResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 
+struct BtSocketCapabilitiesRequestT : public flatbuffers::NativeTable {
+  typedef BtSocketCapabilitiesRequest TableType;
+  BtSocketCapabilitiesRequestT() {
+  }
+};
+
+struct BtSocketCapabilitiesRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketCapabilitiesRequestT NativeTableType;
+  typedef BtSocketCapabilitiesRequestBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  BtSocketCapabilitiesRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BtSocketCapabilitiesRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BtSocketCapabilitiesRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BtSocketCapabilitiesRequestBuilder {
+  typedef BtSocketCapabilitiesRequest Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit BtSocketCapabilitiesRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketCapabilitiesRequestBuilder &operator=(const BtSocketCapabilitiesRequestBuilder &);
+  flatbuffers::Offset<BtSocketCapabilitiesRequest> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketCapabilitiesRequest>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  BtSocketCapabilitiesRequestBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BtSocketLeCocCapabilitiesT : public flatbuffers::NativeTable {
+  typedef BtSocketLeCocCapabilities TableType;
+  int32_t numberOfSupportedSockets;
+  int32_t mtu;
+  BtSocketLeCocCapabilitiesT()
+      : numberOfSupportedSockets(0),
+        mtu(0) {
+  }
+};
+
+struct BtSocketLeCocCapabilities FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketLeCocCapabilitiesT NativeTableType;
+  typedef BtSocketLeCocCapabilitiesBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUMBEROFSUPPORTEDSOCKETS = 4,
+    VT_MTU = 6
+  };
+  int32_t numberOfSupportedSockets() const {
+    return GetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, 0);
+  }
+  bool mutate_numberOfSupportedSockets(int32_t _numberOfSupportedSockets) {
+    return SetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, _numberOfSupportedSockets, 0);
+  }
+  int32_t mtu() const {
+    return GetField<int32_t>(VT_MTU, 0);
+  }
+  bool mutate_mtu(int32_t _mtu) {
+    return SetField<int32_t>(VT_MTU, _mtu, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_NUMBEROFSUPPORTEDSOCKETS) &&
+           VerifyField<int32_t>(verifier, VT_MTU) &&
+           verifier.EndTable();
+  }
+  BtSocketLeCocCapabilitiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BtSocketLeCocCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BtSocketLeCocCapabilities> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BtSocketLeCocCapabilitiesBuilder {
+  typedef BtSocketLeCocCapabilities Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_numberOfSupportedSockets(int32_t numberOfSupportedSockets) {
+    fbb_.AddElement<int32_t>(BtSocketLeCocCapabilities::VT_NUMBEROFSUPPORTEDSOCKETS, numberOfSupportedSockets, 0);
+  }
+  void add_mtu(int32_t mtu) {
+    fbb_.AddElement<int32_t>(BtSocketLeCocCapabilities::VT_MTU, mtu, 0);
+  }
+  explicit BtSocketLeCocCapabilitiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketLeCocCapabilitiesBuilder &operator=(const BtSocketLeCocCapabilitiesBuilder &);
+  flatbuffers::Offset<BtSocketLeCocCapabilities> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketLeCocCapabilities>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t numberOfSupportedSockets = 0,
+    int32_t mtu = 0) {
+  BtSocketLeCocCapabilitiesBuilder builder_(_fbb);
+  builder_.add_mtu(mtu);
+  builder_.add_numberOfSupportedSockets(numberOfSupportedSockets);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BtSocketRfcommCapabilitiesT : public flatbuffers::NativeTable {
+  typedef BtSocketRfcommCapabilities TableType;
+  int32_t numberOfSupportedSockets;
+  int32_t maxFrameSize;
+  BtSocketRfcommCapabilitiesT()
+      : numberOfSupportedSockets(0),
+        maxFrameSize(0) {
+  }
+};
+
+struct BtSocketRfcommCapabilities FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketRfcommCapabilitiesT NativeTableType;
+  typedef BtSocketRfcommCapabilitiesBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUMBEROFSUPPORTEDSOCKETS = 4,
+    VT_MAXFRAMESIZE = 6
+  };
+  int32_t numberOfSupportedSockets() const {
+    return GetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, 0);
+  }
+  bool mutate_numberOfSupportedSockets(int32_t _numberOfSupportedSockets) {
+    return SetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, _numberOfSupportedSockets, 0);
+  }
+  int32_t maxFrameSize() const {
+    return GetField<int32_t>(VT_MAXFRAMESIZE, 0);
+  }
+  bool mutate_maxFrameSize(int32_t _maxFrameSize) {
+    return SetField<int32_t>(VT_MAXFRAMESIZE, _maxFrameSize, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_NUMBEROFSUPPORTEDSOCKETS) &&
+           VerifyField<int32_t>(verifier, VT_MAXFRAMESIZE) &&
+           verifier.EndTable();
+  }
+  BtSocketRfcommCapabilitiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BtSocketRfcommCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BtSocketRfcommCapabilities> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BtSocketRfcommCapabilitiesBuilder {
+  typedef BtSocketRfcommCapabilities Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_numberOfSupportedSockets(int32_t numberOfSupportedSockets) {
+    fbb_.AddElement<int32_t>(BtSocketRfcommCapabilities::VT_NUMBEROFSUPPORTEDSOCKETS, numberOfSupportedSockets, 0);
+  }
+  void add_maxFrameSize(int32_t maxFrameSize) {
+    fbb_.AddElement<int32_t>(BtSocketRfcommCapabilities::VT_MAXFRAMESIZE, maxFrameSize, 0);
+  }
+  explicit BtSocketRfcommCapabilitiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketRfcommCapabilitiesBuilder &operator=(const BtSocketRfcommCapabilitiesBuilder &);
+  flatbuffers::Offset<BtSocketRfcommCapabilities> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketRfcommCapabilities>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t numberOfSupportedSockets = 0,
+    int32_t maxFrameSize = 0) {
+  BtSocketRfcommCapabilitiesBuilder builder_(_fbb);
+  builder_.add_maxFrameSize(maxFrameSize);
+  builder_.add_numberOfSupportedSockets(numberOfSupportedSockets);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BtSocketCapabilitiesResponseT : public flatbuffers::NativeTable {
+  typedef BtSocketCapabilitiesResponse TableType;
+  std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT> leCocCapabilities;
+  std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT> rfcommCapabilities;
+  BtSocketCapabilitiesResponseT() {
+  }
+};
+
+struct BtSocketCapabilitiesResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketCapabilitiesResponseT NativeTableType;
+  typedef BtSocketCapabilitiesResponseBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_LECOCCAPABILITIES = 4,
+    VT_RFCOMMCAPABILITIES = 6
+  };
+  const chre::fbs::BtSocketLeCocCapabilities *leCocCapabilities() const {
+    return GetPointer<const chre::fbs::BtSocketLeCocCapabilities *>(VT_LECOCCAPABILITIES);
+  }
+  chre::fbs::BtSocketLeCocCapabilities *mutable_leCocCapabilities() {
+    return GetPointer<chre::fbs::BtSocketLeCocCapabilities *>(VT_LECOCCAPABILITIES);
+  }
+  const chre::fbs::BtSocketRfcommCapabilities *rfcommCapabilities() const {
+    return GetPointer<const chre::fbs::BtSocketRfcommCapabilities *>(VT_RFCOMMCAPABILITIES);
+  }
+  chre::fbs::BtSocketRfcommCapabilities *mutable_rfcommCapabilities() {
+    return GetPointer<chre::fbs::BtSocketRfcommCapabilities *>(VT_RFCOMMCAPABILITIES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_LECOCCAPABILITIES) &&
+           verifier.VerifyTable(leCocCapabilities()) &&
+           VerifyOffset(verifier, VT_RFCOMMCAPABILITIES) &&
+           verifier.VerifyTable(rfcommCapabilities()) &&
+           verifier.EndTable();
+  }
+  BtSocketCapabilitiesResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BtSocketCapabilitiesResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BtSocketCapabilitiesResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BtSocketCapabilitiesResponseBuilder {
+  typedef BtSocketCapabilitiesResponse Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_leCocCapabilities(flatbuffers::Offset<chre::fbs::BtSocketLeCocCapabilities> leCocCapabilities) {
+    fbb_.AddOffset(BtSocketCapabilitiesResponse::VT_LECOCCAPABILITIES, leCocCapabilities);
+  }
+  void add_rfcommCapabilities(flatbuffers::Offset<chre::fbs::BtSocketRfcommCapabilities> rfcommCapabilities) {
+    fbb_.AddOffset(BtSocketCapabilitiesResponse::VT_RFCOMMCAPABILITIES, rfcommCapabilities);
+  }
+  explicit BtSocketCapabilitiesResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketCapabilitiesResponseBuilder &operator=(const BtSocketCapabilitiesResponseBuilder &);
+  flatbuffers::Offset<BtSocketCapabilitiesResponse> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketCapabilitiesResponse>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<chre::fbs::BtSocketLeCocCapabilities> leCocCapabilities = 0,
+    flatbuffers::Offset<chre::fbs::BtSocketRfcommCapabilities> rfcommCapabilities = 0) {
+  BtSocketCapabilitiesResponseBuilder builder_(_fbb);
+  builder_.add_rfcommCapabilities(rfcommCapabilities);
+  builder_.add_leCocCapabilities(leCocCapabilities);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
 struct VendorHubInfoT : public flatbuffers::NativeTable {
   typedef VendorHubInfo TableType;
   std::vector<int8_t> name;
@@ -5897,6 +6245,144 @@ inline flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(
 
 flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const RegisterEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 
+struct AddServiceToEndpointT : public flatbuffers::NativeTable {
+  typedef AddServiceToEndpoint TableType;
+  std::unique_ptr<chre::fbs::EndpointIdT> endpoint;
+  std::unique_ptr<chre::fbs::ServiceT> service;
+  AddServiceToEndpointT() {
+  }
+};
+
+/// MessageRouter handles service inspection separately from endpoint inspection
+/// so these messages are required to send embedded endpoint information in
+/// pieces to the host. After RegisterEndpoint, the endpoint is only ready once
+/// an EndpointReady message is sent. After EndpointReady, AddServiceToEndpoint
+/// will be rejected.
+struct AddServiceToEndpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddServiceToEndpointT NativeTableType;
+  typedef AddServiceToEndpointBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ENDPOINT = 4,
+    VT_SERVICE = 6
+  };
+  const chre::fbs::EndpointId *endpoint() const {
+    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
+  }
+  chre::fbs::EndpointId *mutable_endpoint() {
+    return GetPointer<chre::fbs::EndpointId *>(VT_ENDPOINT);
+  }
+  const chre::fbs::Service *service() const {
+    return GetPointer<const chre::fbs::Service *>(VT_SERVICE);
+  }
+  chre::fbs::Service *mutable_service() {
+    return GetPointer<chre::fbs::Service *>(VT_SERVICE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_ENDPOINT) &&
+           verifier.VerifyTable(endpoint()) &&
+           VerifyOffset(verifier, VT_SERVICE) &&
+           verifier.VerifyTable(service()) &&
+           verifier.EndTable();
+  }
+  AddServiceToEndpointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AddServiceToEndpointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AddServiceToEndpoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AddServiceToEndpointBuilder {
+  typedef AddServiceToEndpoint Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
+    fbb_.AddOffset(AddServiceToEndpoint::VT_ENDPOINT, endpoint);
+  }
+  void add_service(flatbuffers::Offset<chre::fbs::Service> service) {
+    fbb_.AddOffset(AddServiceToEndpoint::VT_SERVICE, service);
+  }
+  explicit AddServiceToEndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  AddServiceToEndpointBuilder &operator=(const AddServiceToEndpointBuilder &);
+  flatbuffers::Offset<AddServiceToEndpoint> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddServiceToEndpoint>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0,
+    flatbuffers::Offset<chre::fbs::Service> service = 0) {
+  AddServiceToEndpointBuilder builder_(_fbb);
+  builder_.add_service(service);
+  builder_.add_endpoint(endpoint);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct EndpointReadyT : public flatbuffers::NativeTable {
+  typedef EndpointReady TableType;
+  std::unique_ptr<chre::fbs::EndpointIdT> endpoint;
+  EndpointReadyT() {
+  }
+};
+
+struct EndpointReady FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EndpointReadyT NativeTableType;
+  typedef EndpointReadyBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ENDPOINT = 4
+  };
+  const chre::fbs::EndpointId *endpoint() const {
+    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
+  }
+  chre::fbs::EndpointId *mutable_endpoint() {
+    return GetPointer<chre::fbs::EndpointId *>(VT_ENDPOINT);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_ENDPOINT) &&
+           verifier.VerifyTable(endpoint()) &&
+           verifier.EndTable();
+  }
+  EndpointReadyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(EndpointReadyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<EndpointReady> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct EndpointReadyBuilder {
+  typedef EndpointReady Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
+    fbb_.AddOffset(EndpointReady::VT_ENDPOINT, endpoint);
+  }
+  explicit EndpointReadyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  EndpointReadyBuilder &operator=(const EndpointReadyBuilder &);
+  flatbuffers::Offset<EndpointReady> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<EndpointReady>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<EndpointReady> CreateEndpointReady(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0) {
+  EndpointReadyBuilder builder_(_fbb);
+  builder_.add_endpoint(endpoint);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<EndpointReady> CreateEndpointReady(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
 struct UnregisterEndpointT : public flatbuffers::NativeTable {
   typedef UnregisterEndpoint TableType;
   std::unique_ptr<chre::fbs::EndpointIdT> endpoint;
@@ -6089,12 +6575,14 @@ flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> CreateGetMessageHubsAndE
 
 struct OpenEndpointSessionRequestT : public flatbuffers::NativeTable {
   typedef OpenEndpointSessionRequest TableType;
-  uint16_t id;
+  int64_t host_hub_id;
+  uint16_t session_id;
   std::unique_ptr<chre::fbs::EndpointIdT> fromEndpoint;
   std::unique_ptr<chre::fbs::EndpointIdT> toEndpoint;
   std::vector<int8_t> serviceDescriptor;
   OpenEndpointSessionRequestT()
-      : id(0) {
+      : host_hub_id(0),
+        session_id(0) {
   }
 };
 
@@ -6102,16 +6590,23 @@ struct OpenEndpointSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers:
   typedef OpenEndpointSessionRequestT NativeTableType;
   typedef OpenEndpointSessionRequestBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_ID = 4,
-    VT_FROMENDPOINT = 6,
-    VT_TOENDPOINT = 8,
-    VT_SERVICEDESCRIPTOR = 10
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_FROMENDPOINT = 8,
+    VT_TOENDPOINT = 10,
+    VT_SERVICEDESCRIPTOR = 12
   };
-  uint16_t id() const {
-    return GetField<uint16_t>(VT_ID, 0);
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  bool mutate_host_hub_id(int64_t _host_hub_id) {
+    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
+  }
+  uint16_t session_id() const {
+    return GetField<uint16_t>(VT_SESSION_ID, 0);
   }
-  bool mutate_id(uint16_t _id) {
-    return SetField<uint16_t>(VT_ID, _id, 0);
+  bool mutate_session_id(uint16_t _session_id) {
+    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
   }
   const chre::fbs::EndpointId *fromEndpoint() const {
     return GetPointer<const chre::fbs::EndpointId *>(VT_FROMENDPOINT);
@@ -6134,7 +6629,8 @@ struct OpenEndpointSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers:
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
+           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyOffset(verifier, VT_FROMENDPOINT) &&
            verifier.VerifyTable(fromEndpoint()) &&
            VerifyOffset(verifier, VT_TOENDPOINT) &&
@@ -6152,8 +6648,11 @@ struct OpenEndpointSessionRequestBuilder {
   typedef OpenEndpointSessionRequest Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_id(uint16_t id) {
-    fbb_.AddElement<uint16_t>(OpenEndpointSessionRequest::VT_ID, id, 0);
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(OpenEndpointSessionRequest::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
+  void add_session_id(uint16_t session_id) {
+    fbb_.AddElement<uint16_t>(OpenEndpointSessionRequest::VT_SESSION_ID, session_id, 0);
   }
   void add_fromEndpoint(flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint) {
     fbb_.AddOffset(OpenEndpointSessionRequest::VT_FROMENDPOINT, fromEndpoint);
@@ -6178,28 +6677,32 @@ struct OpenEndpointSessionRequestBuilder {
 
 inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequest(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0,
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint = 0,
     flatbuffers::Offset<flatbuffers::Vector<int8_t>> serviceDescriptor = 0) {
   OpenEndpointSessionRequestBuilder builder_(_fbb);
+  builder_.add_host_hub_id(host_hub_id);
   builder_.add_serviceDescriptor(serviceDescriptor);
   builder_.add_toEndpoint(toEndpoint);
   builder_.add_fromEndpoint(fromEndpoint);
-  builder_.add_id(id);
+  builder_.add_session_id(session_id);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequestDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0,
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint = 0,
     const std::vector<int8_t> *serviceDescriptor = nullptr) {
   auto serviceDescriptor__ = serviceDescriptor ? _fbb.CreateVector<int8_t>(*serviceDescriptor) : 0;
   return chre::fbs::CreateOpenEndpointSessionRequest(
       _fbb,
-      id,
+      host_hub_id,
+      session_id,
       fromEndpoint,
       toEndpoint,
       serviceDescriptor__);
@@ -6209,9 +6712,11 @@ flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequest
 
 struct EndpointSessionOpenedT : public flatbuffers::NativeTable {
   typedef EndpointSessionOpened TableType;
-  uint16_t id;
+  int64_t host_hub_id;
+  uint16_t session_id;
   EndpointSessionOpenedT()
-      : id(0) {
+      : host_hub_id(0),
+        session_id(0) {
   }
 };
 
@@ -6219,17 +6724,25 @@ struct EndpointSessionOpened FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl
   typedef EndpointSessionOpenedT NativeTableType;
   typedef EndpointSessionOpenedBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_ID = 4
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6
   };
-  uint16_t id() const {
-    return GetField<uint16_t>(VT_ID, 0);
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  bool mutate_host_hub_id(int64_t _host_hub_id) {
+    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
   }
-  bool mutate_id(uint16_t _id) {
-    return SetField<uint16_t>(VT_ID, _id, 0);
+  uint16_t session_id() const {
+    return GetField<uint16_t>(VT_SESSION_ID, 0);
+  }
+  bool mutate_session_id(uint16_t _session_id) {
+    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
+           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            verifier.EndTable();
   }
   EndpointSessionOpenedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
@@ -6241,8 +6754,11 @@ struct EndpointSessionOpenedBuilder {
   typedef EndpointSessionOpened Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_id(uint16_t id) {
-    fbb_.AddElement<uint16_t>(EndpointSessionOpened::VT_ID, id, 0);
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionOpened::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
+  void add_session_id(uint16_t session_id) {
+    fbb_.AddElement<uint16_t>(EndpointSessionOpened::VT_SESSION_ID, session_id, 0);
   }
   explicit EndpointSessionOpenedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
@@ -6258,9 +6774,11 @@ struct EndpointSessionOpenedBuilder {
 
 inline flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0) {
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0) {
   EndpointSessionOpenedBuilder builder_(_fbb);
-  builder_.add_id(id);
+  builder_.add_host_hub_id(host_hub_id);
+  builder_.add_session_id(session_id);
   return builder_.Finish();
 }
 
@@ -6268,10 +6786,12 @@ flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(flatbuffe
 
 struct EndpointSessionClosedT : public flatbuffers::NativeTable {
   typedef EndpointSessionClosed TableType;
-  uint16_t id;
+  int64_t host_hub_id;
+  uint16_t session_id;
   chre::fbs::Reason reason;
   EndpointSessionClosedT()
-      : id(0),
+      : host_hub_id(0),
+        session_id(0),
         reason(chre::fbs::Reason::UNSPECIFIED) {
   }
 };
@@ -6280,14 +6800,21 @@ struct EndpointSessionClosed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl
   typedef EndpointSessionClosedT NativeTableType;
   typedef EndpointSessionClosedBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_ID = 4,
-    VT_REASON = 6
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_REASON = 8
   };
-  uint16_t id() const {
-    return GetField<uint16_t>(VT_ID, 0);
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  bool mutate_host_hub_id(int64_t _host_hub_id) {
+    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
+  }
+  uint16_t session_id() const {
+    return GetField<uint16_t>(VT_SESSION_ID, 0);
   }
-  bool mutate_id(uint16_t _id) {
-    return SetField<uint16_t>(VT_ID, _id, 0);
+  bool mutate_session_id(uint16_t _session_id) {
+    return SetField<uint16_t>(VT_SESSION_ID, _session_id, 0);
   }
   chre::fbs::Reason reason() const {
     return static_cast<chre::fbs::Reason>(GetField<uint8_t>(VT_REASON, 0));
@@ -6297,7 +6824,8 @@ struct EndpointSessionClosed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
+           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyField<uint8_t>(verifier, VT_REASON) &&
            verifier.EndTable();
   }
@@ -6310,8 +6838,11 @@ struct EndpointSessionClosedBuilder {
   typedef EndpointSessionClosed Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_id(uint16_t id) {
-    fbb_.AddElement<uint16_t>(EndpointSessionClosed::VT_ID, id, 0);
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionClosed::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
+  void add_session_id(uint16_t session_id) {
+    fbb_.AddElement<uint16_t>(EndpointSessionClosed::VT_SESSION_ID, session_id, 0);
   }
   void add_reason(chre::fbs::Reason reason) {
     fbb_.AddElement<uint8_t>(EndpointSessionClosed::VT_REASON, static_cast<uint8_t>(reason), 0);
@@ -6330,10 +6861,12 @@ struct EndpointSessionClosedBuilder {
 
 inline flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0,
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0,
     chre::fbs::Reason reason = chre::fbs::Reason::UNSPECIFIED) {
   EndpointSessionClosedBuilder builder_(_fbb);
-  builder_.add_id(id);
+  builder_.add_host_hub_id(host_hub_id);
+  builder_.add_session_id(session_id);
   builder_.add_reason(reason);
   return builder_.Finish();
 }
@@ -6342,6 +6875,7 @@ flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(flatbuffe
 
 struct EndpointSessionMessageT : public flatbuffers::NativeTable {
   typedef EndpointSessionMessage TableType;
+  int64_t host_hub_id;
   uint16_t session_id;
   uint32_t type;
   uint32_t permissions;
@@ -6349,7 +6883,8 @@ struct EndpointSessionMessageT : public flatbuffers::NativeTable {
   uint32_t flags;
   uint32_t sequence_number;
   EndpointSessionMessageT()
-      : session_id(0),
+      : host_hub_id(0),
+        session_id(0),
         type(0),
         permissions(0),
         flags(0),
@@ -6361,13 +6896,20 @@ struct EndpointSessionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab
   typedef EndpointSessionMessageT NativeTableType;
   typedef EndpointSessionMessageBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_SESSION_ID = 4,
-    VT_TYPE = 6,
-    VT_PERMISSIONS = 8,
-    VT_DATA = 10,
-    VT_FLAGS = 12,
-    VT_SEQUENCE_NUMBER = 14
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_TYPE = 8,
+    VT_PERMISSIONS = 10,
+    VT_DATA = 12,
+    VT_FLAGS = 14,
+    VT_SEQUENCE_NUMBER = 16
   };
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  bool mutate_host_hub_id(int64_t _host_hub_id) {
+    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
+  }
   /// Id of session this message is being sent within
   uint16_t session_id() const {
     return GetField<uint16_t>(VT_SESSION_ID, 0);
@@ -6412,6 +6954,7 @@ struct EndpointSessionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
            VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyField<uint32_t>(verifier, VT_TYPE) &&
            VerifyField<uint32_t>(verifier, VT_PERMISSIONS) &&
@@ -6430,6 +6973,9 @@ struct EndpointSessionMessageBuilder {
   typedef EndpointSessionMessage Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionMessage::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
   void add_session_id(uint16_t session_id) {
     fbb_.AddElement<uint16_t>(EndpointSessionMessage::VT_SESSION_ID, session_id, 0);
   }
@@ -6462,6 +7008,7 @@ struct EndpointSessionMessageBuilder {
 
 inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
     flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t host_hub_id = 0,
     uint16_t session_id = 0,
     uint32_t type = 0,
     uint32_t permissions = 0,
@@ -6469,6 +7016,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
     uint32_t flags = 0,
     uint32_t sequence_number = 0) {
   EndpointSessionMessageBuilder builder_(_fbb);
+  builder_.add_host_hub_id(host_hub_id);
   builder_.add_sequence_number(sequence_number);
   builder_.add_flags(flags);
   builder_.add_data(data);
@@ -6480,6 +7028,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
 
 inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessageDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t host_hub_id = 0,
     uint16_t session_id = 0,
     uint32_t type = 0,
     uint32_t permissions = 0,
@@ -6489,6 +7038,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessageD
   auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
   return chre::fbs::CreateEndpointSessionMessage(
       _fbb,
+      host_hub_id,
       session_id,
       type,
       permissions,
@@ -6501,10 +7051,12 @@ flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(flatbuf
 
 struct EndpointSessionMessageDeliveryStatusT : public flatbuffers::NativeTable {
   typedef EndpointSessionMessageDeliveryStatus TableType;
+  int64_t host_hub_id;
   uint16_t session_id;
   std::unique_ptr<chre::fbs::MessageDeliveryStatusT> status;
   EndpointSessionMessageDeliveryStatusT()
-      : session_id(0) {
+      : host_hub_id(0),
+        session_id(0) {
   }
 };
 
@@ -6512,9 +7064,16 @@ struct EndpointSessionMessageDeliveryStatus FLATBUFFERS_FINAL_CLASS : private fl
   typedef EndpointSessionMessageDeliveryStatusT NativeTableType;
   typedef EndpointSessionMessageDeliveryStatusBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_SESSION_ID = 4,
-    VT_STATUS = 6
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_STATUS = 8
   };
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  bool mutate_host_hub_id(int64_t _host_hub_id) {
+    return SetField<int64_t>(VT_HOST_HUB_ID, _host_hub_id, 0);
+  }
   /// Id of session the message was sent within
   uint16_t session_id() const {
     return GetField<uint16_t>(VT_SESSION_ID, 0);
@@ -6530,6 +7089,7 @@ struct EndpointSessionMessageDeliveryStatus FLATBUFFERS_FINAL_CLASS : private fl
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
            VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyOffset(verifier, VT_STATUS) &&
            verifier.VerifyTable(status()) &&
@@ -6544,6 +7104,9 @@ struct EndpointSessionMessageDeliveryStatusBuilder {
   typedef EndpointSessionMessageDeliveryStatus Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionMessageDeliveryStatus::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
   void add_session_id(uint16_t session_id) {
     fbb_.AddElement<uint16_t>(EndpointSessionMessageDeliveryStatus::VT_SESSION_ID, session_id, 0);
   }
@@ -6564,9 +7127,11 @@ struct EndpointSessionMessageDeliveryStatusBuilder {
 
 inline flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> CreateEndpointSessionMessageDeliveryStatus(
     flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t host_hub_id = 0,
     uint16_t session_id = 0,
     flatbuffers::Offset<chre::fbs::MessageDeliveryStatus> status = 0) {
   EndpointSessionMessageDeliveryStatusBuilder builder_(_fbb);
+  builder_.add_host_hub_id(host_hub_id);
   builder_.add_status(status);
   builder_.add_session_id(session_id);
   return builder_.Finish();
@@ -6741,6 +7306,18 @@ struct MessageContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   const chre::fbs::EndpointSessionMessageDeliveryStatus *message_as_EndpointSessionMessageDeliveryStatus() const {
     return message_type() == chre::fbs::ChreMessage::EndpointSessionMessageDeliveryStatus ? static_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(message()) : nullptr;
   }
+  const chre::fbs::BtSocketCapabilitiesRequest *message_as_BtSocketCapabilitiesRequest() const {
+    return message_type() == chre::fbs::ChreMessage::BtSocketCapabilitiesRequest ? static_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(message()) : nullptr;
+  }
+  const chre::fbs::BtSocketCapabilitiesResponse *message_as_BtSocketCapabilitiesResponse() const {
+    return message_type() == chre::fbs::ChreMessage::BtSocketCapabilitiesResponse ? static_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(message()) : nullptr;
+  }
+  const chre::fbs::AddServiceToEndpoint *message_as_AddServiceToEndpoint() const {
+    return message_type() == chre::fbs::ChreMessage::AddServiceToEndpoint ? static_cast<const chre::fbs::AddServiceToEndpoint *>(message()) : nullptr;
+  }
+  const chre::fbs::EndpointReady *message_as_EndpointReady() const {
+    return message_type() == chre::fbs::ChreMessage::EndpointReady ? static_cast<const chre::fbs::EndpointReady *>(message()) : nullptr;
+  }
   void *mutable_message() {
     return GetPointer<void *>(VT_MESSAGE);
   }
@@ -6957,6 +7534,22 @@ template<> inline const chre::fbs::EndpointSessionMessageDeliveryStatus *Message
   return message_as_EndpointSessionMessageDeliveryStatus();
 }
 
+template<> inline const chre::fbs::BtSocketCapabilitiesRequest *MessageContainer::message_as<chre::fbs::BtSocketCapabilitiesRequest>() const {
+  return message_as_BtSocketCapabilitiesRequest();
+}
+
+template<> inline const chre::fbs::BtSocketCapabilitiesResponse *MessageContainer::message_as<chre::fbs::BtSocketCapabilitiesResponse>() const {
+  return message_as_BtSocketCapabilitiesResponse();
+}
+
+template<> inline const chre::fbs::AddServiceToEndpoint *MessageContainer::message_as<chre::fbs::AddServiceToEndpoint>() const {
+  return message_as_AddServiceToEndpoint();
+}
+
+template<> inline const chre::fbs::EndpointReady *MessageContainer::message_as<chre::fbs::EndpointReady>() const {
+  return message_as_EndpointReady();
+}
+
 struct MessageContainerBuilder {
   typedef MessageContainer Table;
   flatbuffers::FlatBufferBuilder &fbb_;
@@ -8189,6 +8782,116 @@ inline flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(fl
       _socketId);
 }
 
+inline BtSocketCapabilitiesRequestT *BtSocketCapabilitiesRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  std::unique_ptr<chre::fbs::BtSocketCapabilitiesRequestT> _o = std::unique_ptr<chre::fbs::BtSocketCapabilitiesRequestT>(new BtSocketCapabilitiesRequestT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BtSocketCapabilitiesRequest::UnPackTo(BtSocketCapabilitiesRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<BtSocketCapabilitiesRequest> BtSocketCapabilitiesRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBtSocketCapabilitiesRequest(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketCapabilitiesRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return chre::fbs::CreateBtSocketCapabilitiesRequest(
+      _fbb);
+}
+
+inline BtSocketLeCocCapabilitiesT *BtSocketLeCocCapabilities::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT> _o = std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT>(new BtSocketLeCocCapabilitiesT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BtSocketLeCocCapabilities::UnPackTo(BtSocketLeCocCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = numberOfSupportedSockets(); _o->numberOfSupportedSockets = _e; }
+  { auto _e = mtu(); _o->mtu = _e; }
+}
+
+inline flatbuffers::Offset<BtSocketLeCocCapabilities> BtSocketLeCocCapabilities::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBtSocketLeCocCapabilities(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketLeCocCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketLeCocCapabilitiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _numberOfSupportedSockets = _o->numberOfSupportedSockets;
+  auto _mtu = _o->mtu;
+  return chre::fbs::CreateBtSocketLeCocCapabilities(
+      _fbb,
+      _numberOfSupportedSockets,
+      _mtu);
+}
+
+inline BtSocketRfcommCapabilitiesT *BtSocketRfcommCapabilities::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT> _o = std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT>(new BtSocketRfcommCapabilitiesT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BtSocketRfcommCapabilities::UnPackTo(BtSocketRfcommCapabilitiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = numberOfSupportedSockets(); _o->numberOfSupportedSockets = _e; }
+  { auto _e = maxFrameSize(); _o->maxFrameSize = _e; }
+}
+
+inline flatbuffers::Offset<BtSocketRfcommCapabilities> BtSocketRfcommCapabilities::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBtSocketRfcommCapabilities(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketRfcommCapabilitiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketRfcommCapabilitiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _numberOfSupportedSockets = _o->numberOfSupportedSockets;
+  auto _maxFrameSize = _o->maxFrameSize;
+  return chre::fbs::CreateBtSocketRfcommCapabilities(
+      _fbb,
+      _numberOfSupportedSockets,
+      _maxFrameSize);
+}
+
+inline BtSocketCapabilitiesResponseT *BtSocketCapabilitiesResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  std::unique_ptr<chre::fbs::BtSocketCapabilitiesResponseT> _o = std::unique_ptr<chre::fbs::BtSocketCapabilitiesResponseT>(new BtSocketCapabilitiesResponseT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BtSocketCapabilitiesResponse::UnPackTo(BtSocketCapabilitiesResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = leCocCapabilities(); if (_e) _o->leCocCapabilities = std::unique_ptr<chre::fbs::BtSocketLeCocCapabilitiesT>(_e->UnPack(_resolver)); }
+  { auto _e = rfcommCapabilities(); if (_e) _o->rfcommCapabilities = std::unique_ptr<chre::fbs::BtSocketRfcommCapabilitiesT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<BtSocketCapabilitiesResponse> BtSocketCapabilitiesResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBtSocketCapabilitiesResponse(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(flatbuffers::FlatBufferBuilder &_fbb, const BtSocketCapabilitiesResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BtSocketCapabilitiesResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _leCocCapabilities = _o->leCocCapabilities ? CreateBtSocketLeCocCapabilities(_fbb, _o->leCocCapabilities.get(), _rehasher) : 0;
+  auto _rfcommCapabilities = _o->rfcommCapabilities ? CreateBtSocketRfcommCapabilities(_fbb, _o->rfcommCapabilities.get(), _rehasher) : 0;
+  return chre::fbs::CreateBtSocketCapabilitiesResponse(
+      _fbb,
+      _leCocCapabilities,
+      _rfcommCapabilities);
+}
+
 inline VendorHubInfoT *VendorHubInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
   std::unique_ptr<chre::fbs::VendorHubInfoT> _o = std::unique_ptr<chre::fbs::VendorHubInfoT>(new VendorHubInfoT());
   UnPackTo(_o.get(), _resolver);
@@ -8436,6 +9139,61 @@ inline flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(flatbuffers:
       _endpoint);
 }
 
+inline AddServiceToEndpointT *AddServiceToEndpoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  std::unique_ptr<chre::fbs::AddServiceToEndpointT> _o = std::unique_ptr<chre::fbs::AddServiceToEndpointT>(new AddServiceToEndpointT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AddServiceToEndpoint::UnPackTo(AddServiceToEndpointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = endpoint(); if (_e) _o->endpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
+  { auto _e = service(); if (_e) _o->service = std::unique_ptr<chre::fbs::ServiceT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<AddServiceToEndpoint> AddServiceToEndpoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAddServiceToEndpoint(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(flatbuffers::FlatBufferBuilder &_fbb, const AddServiceToEndpointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddServiceToEndpointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _endpoint = _o->endpoint ? CreateEndpointId(_fbb, _o->endpoint.get(), _rehasher) : 0;
+  auto _service = _o->service ? CreateService(_fbb, _o->service.get(), _rehasher) : 0;
+  return chre::fbs::CreateAddServiceToEndpoint(
+      _fbb,
+      _endpoint,
+      _service);
+}
+
+inline EndpointReadyT *EndpointReady::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  std::unique_ptr<chre::fbs::EndpointReadyT> _o = std::unique_ptr<chre::fbs::EndpointReadyT>(new EndpointReadyT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void EndpointReady::UnPackTo(EndpointReadyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = endpoint(); if (_e) _o->endpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<EndpointReady> EndpointReady::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateEndpointReady(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<EndpointReady> CreateEndpointReady(flatbuffers::FlatBufferBuilder &_fbb, const EndpointReadyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointReadyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _endpoint = _o->endpoint ? CreateEndpointId(_fbb, _o->endpoint.get(), _rehasher) : 0;
+  return chre::fbs::CreateEndpointReady(
+      _fbb,
+      _endpoint);
+}
+
 inline UnregisterEndpointT *UnregisterEndpoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
   std::unique_ptr<chre::fbs::UnregisterEndpointT> _o = std::unique_ptr<chre::fbs::UnregisterEndpointT>(new UnregisterEndpointT());
   UnPackTo(_o.get(), _resolver);
@@ -8523,7 +9281,8 @@ inline OpenEndpointSessionRequestT *OpenEndpointSessionRequest::UnPack(const fla
 inline void OpenEndpointSessionRequest::UnPackTo(OpenEndpointSessionRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = id(); _o->id = _e; }
+  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
+  { auto _e = session_id(); _o->session_id = _e; }
   { auto _e = fromEndpoint(); if (_e) _o->fromEndpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
   { auto _e = toEndpoint(); if (_e) _o->toEndpoint = std::unique_ptr<chre::fbs::EndpointIdT>(_e->UnPack(_resolver)); }
   { auto _e = serviceDescriptor(); if (_e) { _o->serviceDescriptor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->serviceDescriptor[_i] = _e->Get(_i); } } }
@@ -8537,13 +9296,15 @@ inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSession
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpenEndpointSessionRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
-  auto _id = _o->id;
+  auto _host_hub_id = _o->host_hub_id;
+  auto _session_id = _o->session_id;
   auto _fromEndpoint = _o->fromEndpoint ? CreateEndpointId(_fbb, _o->fromEndpoint.get(), _rehasher) : 0;
   auto _toEndpoint = _o->toEndpoint ? CreateEndpointId(_fbb, _o->toEndpoint.get(), _rehasher) : 0;
   auto _serviceDescriptor = _o->serviceDescriptor.size() ? _fbb.CreateVector(_o->serviceDescriptor) : 0;
   return chre::fbs::CreateOpenEndpointSessionRequest(
       _fbb,
-      _id,
+      _host_hub_id,
+      _session_id,
       _fromEndpoint,
       _toEndpoint,
       _serviceDescriptor);
@@ -8558,7 +9319,8 @@ inline EndpointSessionOpenedT *EndpointSessionOpened::UnPack(const flatbuffers::
 inline void EndpointSessionOpened::UnPackTo(EndpointSessionOpenedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = id(); _o->id = _e; }
+  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
+  { auto _e = session_id(); _o->session_id = _e; }
 }
 
 inline flatbuffers::Offset<EndpointSessionOpened> EndpointSessionOpened::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndpointSessionOpenedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -8569,10 +9331,12 @@ inline flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(fl
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionOpenedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
-  auto _id = _o->id;
+  auto _host_hub_id = _o->host_hub_id;
+  auto _session_id = _o->session_id;
   return chre::fbs::CreateEndpointSessionOpened(
       _fbb,
-      _id);
+      _host_hub_id,
+      _session_id);
 }
 
 inline EndpointSessionClosedT *EndpointSessionClosed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
@@ -8584,7 +9348,8 @@ inline EndpointSessionClosedT *EndpointSessionClosed::UnPack(const flatbuffers::
 inline void EndpointSessionClosed::UnPackTo(EndpointSessionClosedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = id(); _o->id = _e; }
+  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
+  { auto _e = session_id(); _o->session_id = _e; }
   { auto _e = reason(); _o->reason = _e; }
 }
 
@@ -8596,11 +9361,13 @@ inline flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(fl
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionClosedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
-  auto _id = _o->id;
+  auto _host_hub_id = _o->host_hub_id;
+  auto _session_id = _o->session_id;
   auto _reason = _o->reason;
   return chre::fbs::CreateEndpointSessionClosed(
       _fbb,
-      _id,
+      _host_hub_id,
+      _session_id,
       _reason);
 }
 
@@ -8613,6 +9380,7 @@ inline EndpointSessionMessageT *EndpointSessionMessage::UnPack(const flatbuffers
 inline void EndpointSessionMessage::UnPackTo(EndpointSessionMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
+  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
   { auto _e = session_id(); _o->session_id = _e; }
   { auto _e = type(); _o->type = _e; }
   { auto _e = permissions(); _o->permissions = _e; }
@@ -8629,6 +9397,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _host_hub_id = _o->host_hub_id;
   auto _session_id = _o->session_id;
   auto _type = _o->type;
   auto _permissions = _o->permissions;
@@ -8637,6 +9406,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
   auto _sequence_number = _o->sequence_number;
   return chre::fbs::CreateEndpointSessionMessage(
       _fbb,
+      _host_hub_id,
       _session_id,
       _type,
       _permissions,
@@ -8654,6 +9424,7 @@ inline EndpointSessionMessageDeliveryStatusT *EndpointSessionMessageDeliveryStat
 inline void EndpointSessionMessageDeliveryStatus::UnPackTo(EndpointSessionMessageDeliveryStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
+  { auto _e = host_hub_id(); _o->host_hub_id = _e; }
   { auto _e = session_id(); _o->session_id = _e; }
   { auto _e = status(); if (_e) _o->status = std::unique_ptr<chre::fbs::MessageDeliveryStatusT>(_e->UnPack(_resolver)); }
 }
@@ -8666,10 +9437,12 @@ inline flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> CreateEndpointS
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndpointSessionMessageDeliveryStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _host_hub_id = _o->host_hub_id;
   auto _session_id = _o->session_id;
   auto _status = _o->status ? CreateMessageDeliveryStatus(_fbb, _o->status.get(), _rehasher) : 0;
   return chre::fbs::CreateEndpointSessionMessageDeliveryStatus(
       _fbb,
+      _host_hub_id,
       _session_id,
       _status);
 }
@@ -9058,6 +9831,22 @@ inline bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj,
       auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(obj);
       return verifier.VerifyTable(ptr);
     }
+    case ChreMessage::BtSocketCapabilitiesRequest: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case ChreMessage::BtSocketCapabilitiesResponse: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case ChreMessage::AddServiceToEndpoint: {
+      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpoint *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case ChreMessage::EndpointReady: {
+      auto ptr = reinterpret_cast<const chre::fbs::EndpointReady *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
     default: return true;
   }
 }
@@ -9264,6 +10053,22 @@ inline void *ChreMessageUnion::UnPack(const void *obj, ChreMessage type, const f
       auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(obj);
       return ptr->UnPack(resolver);
     }
+    case ChreMessage::BtSocketCapabilitiesRequest: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case ChreMessage::BtSocketCapabilitiesResponse: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case ChreMessage::AddServiceToEndpoint: {
+      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpoint *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case ChreMessage::EndpointReady: {
+      auto ptr = reinterpret_cast<const chre::fbs::EndpointReady *>(obj);
+      return ptr->UnPack(resolver);
+    }
     default: return nullptr;
   }
 }
@@ -9458,6 +10263,22 @@ inline flatbuffers::Offset<void> ChreMessageUnion::Pack(flatbuffers::FlatBufferB
       auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatusT *>(value);
       return CreateEndpointSessionMessageDeliveryStatus(_fbb, ptr, _rehasher).Union();
     }
+    case ChreMessage::BtSocketCapabilitiesRequest: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequestT *>(value);
+      return CreateBtSocketCapabilitiesRequest(_fbb, ptr, _rehasher).Union();
+    }
+    case ChreMessage::BtSocketCapabilitiesResponse: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponseT *>(value);
+      return CreateBtSocketCapabilitiesResponse(_fbb, ptr, _rehasher).Union();
+    }
+    case ChreMessage::AddServiceToEndpoint: {
+      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpointT *>(value);
+      return CreateAddServiceToEndpoint(_fbb, ptr, _rehasher).Union();
+    }
+    case ChreMessage::EndpointReady: {
+      auto ptr = reinterpret_cast<const chre::fbs::EndpointReadyT *>(value);
+      return CreateEndpointReady(_fbb, ptr, _rehasher).Union();
+    }
     default: return 0;
   }
 }
@@ -9652,6 +10473,22 @@ inline ChreMessageUnion::ChreMessageUnion(const ChreMessageUnion &u) : type(u.ty
       FLATBUFFERS_ASSERT(false);  // chre::fbs::EndpointSessionMessageDeliveryStatusT not copyable.
       break;
     }
+    case ChreMessage::BtSocketCapabilitiesRequest: {
+      value = new chre::fbs::BtSocketCapabilitiesRequestT(*reinterpret_cast<chre::fbs::BtSocketCapabilitiesRequestT *>(u.value));
+      break;
+    }
+    case ChreMessage::BtSocketCapabilitiesResponse: {
+      FLATBUFFERS_ASSERT(false);  // chre::fbs::BtSocketCapabilitiesResponseT not copyable.
+      break;
+    }
+    case ChreMessage::AddServiceToEndpoint: {
+      FLATBUFFERS_ASSERT(false);  // chre::fbs::AddServiceToEndpointT not copyable.
+      break;
+    }
+    case ChreMessage::EndpointReady: {
+      FLATBUFFERS_ASSERT(false);  // chre::fbs::EndpointReadyT not copyable.
+      break;
+    }
     default:
       break;
   }
@@ -9894,6 +10731,26 @@ inline void ChreMessageUnion::Reset() {
       delete ptr;
       break;
     }
+    case ChreMessage::BtSocketCapabilitiesRequest: {
+      auto ptr = reinterpret_cast<chre::fbs::BtSocketCapabilitiesRequestT *>(value);
+      delete ptr;
+      break;
+    }
+    case ChreMessage::BtSocketCapabilitiesResponse: {
+      auto ptr = reinterpret_cast<chre::fbs::BtSocketCapabilitiesResponseT *>(value);
+      delete ptr;
+      break;
+    }
+    case ChreMessage::AddServiceToEndpoint: {
+      auto ptr = reinterpret_cast<chre::fbs::AddServiceToEndpointT *>(value);
+      delete ptr;
+      break;
+    }
+    case ChreMessage::EndpointReady: {
+      auto ptr = reinterpret_cast<chre::fbs::EndpointReadyT *>(value);
+      delete ptr;
+      break;
+    }
     default: break;
   }
   value = nullptr;
diff --git a/host/common/include/chre_host/host_protocol_host.h b/host/common/include/chre_host/host_protocol_host.h
index 80c0b04f..1ba14775 100644
--- a/host/common/include/chre_host/host_protocol_host.h
+++ b/host/common/include/chre_host/host_protocol_host.h
@@ -52,33 +52,36 @@ class IChreMessageHandlers {
   virtual ~IChreMessageHandlers() = default;
 
   virtual void handleNanoappMessage(
-      const ::chre::fbs::NanoappMessageT & /*message*/){};
+      const ::chre::fbs::NanoappMessageT & /*message*/) {}
 
   virtual void handleHubInfoResponse(
-      const ::chre::fbs::HubInfoResponseT & /*response*/){};
+      const ::chre::fbs::HubInfoResponseT & /*response*/) {}
 
   virtual void handleNanoappListResponse(
-      const ::chre::fbs::NanoappListResponseT & /*response*/){};
+      const ::chre::fbs::NanoappListResponseT & /*response*/) {}
 
   virtual void handleLoadNanoappResponse(
-      const ::chre::fbs::LoadNanoappResponseT & /*response*/){};
+      const ::chre::fbs::LoadNanoappResponseT & /*response*/) {}
 
   virtual void handleUnloadNanoappResponse(
-      const ::chre::fbs::UnloadNanoappResponseT & /*response*/){};
+      const ::chre::fbs::UnloadNanoappResponseT & /*response*/) {}
 
   virtual void handleDebugDumpData(
-      const ::chre::fbs::DebugDumpDataT & /*data*/){};
+      const ::chre::fbs::DebugDumpDataT & /*data*/) {}
 
   virtual void handleDebugDumpResponse(
-      const ::chre::fbs::DebugDumpResponseT & /*response*/){};
+      const ::chre::fbs::DebugDumpResponseT & /*response*/) {}
 
   virtual void handleSelfTestResponse(
-      const ::chre::fbs::SelfTestResponseT & /*response*/){};
+      const ::chre::fbs::SelfTestResponseT & /*response*/) {}
 
   virtual bool handleContextHubV4Message(
       const ::chre::fbs::ChreMessageUnion & /*msg*/) {
     return false;
-  };
+  }
+
+  virtual void handleBluetoothSocketMessage(const void * /*message*/,
+                                            size_t /*messageLen*/) {}
 };
 
 /**
@@ -98,7 +101,8 @@ class HostProtocolHost : public ::chre::HostProtocolCommon {
    *        function returns success, then exactly one of these functions was
    *        called.
    *
-   * @return true if the message was parsed successfully and passed to a handler
+   * @return true if the message was parsed successfully and passed to a
+   *         handler
    */
   static bool decodeMessageFromChre(const void *message, size_t messageLen,
                                     IChreMessageHandlers &handlers);
@@ -159,9 +163,9 @@ class HostProtocolHost : public ::chre::HostProtocolCommon {
    *        response to this request
    * @param appId Identifier for the app to unload
    * @param allowSystemNanoappUnload Whether this request should be allowed to
-   *        result in unloading a system nanoapp (e.g. requests from the context
-   *        hub HAL should have set this to false, as system nanoapps are not
-   *        expected to be managed through that HAL)
+   *        result in unloading a system nanoapp (e.g. requests from the
+   *        context hub HAL should have set this to false, as system nanoapps
+   *        are not expected to be managed through that HAL)
    */
   static void encodeUnloadNanoappRequest(
       flatbuffers::FlatBufferBuilder &builder, uint32_t transactionId,
@@ -190,8 +194,8 @@ class HostProtocolHost : public ::chre::HostProtocolCommon {
    *
    * @param message Buffer containing a complete FlatBuffers CHRE message
    * @param messageLen Size of the message, in bytes
-   * @param hostClientId Output parameter that will be populated with the client
-   *        ID included in the message on success
+   * @param hostClientId Output parameter that will be populated with the
+   *        client ID included in the message on success
    *
    * @return true if the host client ID was successfully decoded from the
    *         message
@@ -207,8 +211,8 @@ class HostProtocolHost : public ::chre::HostProtocolCommon {
    * @param messageLen Size of the message, in bytes
    * @param hostClientId The value to set the host client ID to
    *
-   * @return true if the message was verified successfully, and we were able to
-   *         modify the host client ID field
+   * @return true if the message was verified successfully, and we were able
+   *         to modify the host client ID field
    */
   static bool mutateHostClientId(void *message, size_t messageLen,
                                  uint16_t hostClientId);
diff --git a/host/common/test/power_test/chre_power_test_client.cc b/host/common/test/power_test/chre_power_test_client.cc
index c68130a7..2614b2ed 100644
--- a/host/common/test/power_test/chre_power_test_client.cc
+++ b/host/common/test/power_test/chre_power_test_client.cc
@@ -460,9 +460,31 @@ bool unloadAllNanoapps(SocketClient &client, sp<SocketCallbacks> callbacks) {
   if (!listNanoapps(client)) {
     return false;
   }
+  bool success = true;
   for (auto appId : callbacks->getAppIdVector()) {
     if (!unloadNanoapp(client, callbacks, appId)) {
-      LOGE("Failed in unloading nanoapps, unloading aborted");
+      // TODO(b/394340594): remove workaround when CHRE stall is fixed
+      // Don't abort if we timeout during unloading one nanoapp,
+      // just continue with the rest of the list and confirm at the end.
+      // LOGE("Failed in unloading nanoapps, unloading aborted");
+      // return false;
+      LOGE("Possible timeout unloading nanoapp %" PRIx64 ", continue", appId);
+      success = false;
+    }
+  }
+  if (!success) {
+    // Check again
+    if (listNanoapps(client)) {
+      if (callbacks->getAppIdVector().size() == 0) {
+        success = true;
+      } else {
+        for (auto appId : callbacks->getAppIdVector()) {
+          LOGE("Failed to unload nanoapp %" PRIx64, appId);
+        }
+      }
+    }
+    if (!success) {
+      LOGI("Unloaded all nanoapps failed");
       return false;
     }
   }
diff --git a/host/hal_generic/Android.bp b/host/hal_generic/Android.bp
index b9edabd3..35e265a9 100644
--- a/host/hal_generic/Android.bp
+++ b/host/hal_generic/Android.bp
@@ -41,6 +41,7 @@ filegroup {
     name: "hal_aidl_generic_srcs",
     srcs: [
         "aidl/generic_context_hub_aidl.cc",
+        "common/bluetooth_socket_fbs_hal.cc",
         "common/hal_chre_socket_connection.cc",
         "common/permissions_util.cc",
     ],
@@ -62,6 +63,9 @@ cc_defaults {
         "-DCHRE_HAL_SOCKET_METRICS_ENABLED",
         "-Wthread-safety", // Need to be explicitly set
     ],
+    shared_libs: [
+        "android.hardware.bluetooth.socket-V1-ndk",
+    ],
     static_libs: [
         "chre_config_util",
     ],
diff --git a/host/hal_generic/aidl/generic_context_hub_aidl.cc b/host/hal_generic/aidl/generic_context_hub_aidl.cc
index e72e3edd..a962ecd5 100644
--- a/host/hal_generic/aidl/generic_context_hub_aidl.cc
+++ b/host/hal_generic/aidl/generic_context_hub_aidl.cc
@@ -107,7 +107,7 @@ ScopedAStatus toServiceSpecificError(bool success) {
 ScopedAStatus ContextHub::getContextHubs(
     std::vector<ContextHubInfo> *out_contextHubInfos) {
   ::chre::fbs::HubInfoResponseT response;
-  bool success = mConnection.getContextHubs(&response);
+  bool success = mConnection->getContextHubs(&response);
   if (success) {
     ContextHubInfo hub;
     hub.name = getStringFromByteVector(response.name);
@@ -181,8 +181,8 @@ ScopedAStatus ContextHub::onSettingChanged(Setting setting, bool enabled) {
        setting == Setting::BT_MAIN || setting == Setting::BT_SCANNING);
 
   if (!isWifiOrBtSetting && getFbsSetting(setting, &fbsSetting)) {
-    mConnection.sendSettingChangedNotification(fbsSetting,
-                                               toFbsSettingState(enabled));
+    mConnection->sendSettingChangedNotification(fbsSetting,
+                                                toFbsSettingState(enabled));
   }
 
   bool isWifiMainEnabled = isSettingEnabled(Setting::WIFI_MAIN);
@@ -197,7 +197,7 @@ ScopedAStatus ContextHub::onSettingChanged(Setting setting, bool enabled) {
                              ? (isWifiMainEnabled)
                              : (isWifiMainEnabled || isWifiScanEnabled);
   if (!mIsWifiAvailable.has_value() || (isWifiAvailable != mIsWifiAvailable)) {
-    mConnection.sendSettingChangedNotification(
+    mConnection->sendSettingChangedNotification(
         fbs::Setting::WIFI_AVAILABLE, toFbsSettingState(isWifiAvailable));
     mIsWifiAvailable = isWifiAvailable;
   }
@@ -208,7 +208,7 @@ ScopedAStatus ContextHub::onSettingChanged(Setting setting, bool enabled) {
   bool isBtScanEnabled = isSettingEnabled(Setting::BT_SCANNING);
   bool isBleAvailable = isBtMainEnabled || isBtScanEnabled;
   if (!mIsBleAvailable.has_value() || (isBleAvailable != mIsBleAvailable)) {
-    mConnection.sendSettingChangedNotification(
+    mConnection->sendSettingChangedNotification(
         fbs::Setting::BLE_AVAILABLE, toFbsSettingState(isBleAvailable));
     mIsBleAvailable = isBleAvailable;
   }
@@ -221,7 +221,7 @@ ScopedAStatus ContextHub::queryNanoapps(int32_t contextHubId) {
     LOGE("Invalid ID %" PRId32, contextHubId);
     return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
   }
-  return toServiceSpecificError(mConnection.queryNanoapps());
+  return toServiceSpecificError(mConnection->queryNanoapps());
 }
 
 ::ndk::ScopedAStatus ContextHub::getPreloadedNanoappIds(
@@ -287,7 +287,7 @@ ScopedAStatus ContextHub::sendMessageToHub(int32_t contextHubId,
     return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
   }
 
-  bool success = mConnection.sendMessageToHub(
+  bool success = mConnection->sendMessageToHub(
       message.nanoappId, message.messageType, message.hostEndPoint,
       message.messageBody.data(), message.messageBody.size());
   mEventLogger.logMessageToNanoapp(message, success);
@@ -324,7 +324,7 @@ ScopedAStatus ContextHub::onHostEndpointConnected(
       return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
   }
   mConnectedHostEndpoints.insert(in_info.hostEndpointId);
-  mConnection.onHostEndpointConnected(
+  mConnection->onHostEndpointConnected(
       in_info.hostEndpointId, type, in_info.packageName.value_or(std::string()),
       in_info.attributionTag.value_or(std::string()));
   return ndk::ScopedAStatus::ok();
@@ -336,7 +336,7 @@ ScopedAStatus ContextHub::onHostEndpointDisconnected(
   if (mConnectedHostEndpoints.count(in_hostEndpointId) > 0) {
     mConnectedHostEndpoints.erase(in_hostEndpointId);
 
-    mConnection.onHostEndpointDisconnected(in_hostEndpointId);
+    mConnection->onHostEndpointDisconnected(in_hostEndpointId);
   } else {
     LOGE("Unknown host endpoint disconnected (ID: %" PRIu16 ")",
          in_hostEndpointId);
@@ -361,60 +361,11 @@ ScopedAStatus ContextHub::getEndpoints(std::vector<EndpointInfo> *endpoints) {
   return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
 }
 
-ScopedAStatus ContextHub::registerEndpoint(const EndpointInfo &endpoint) {
-  if (mV4Impl) return mV4Impl->registerEndpoint(endpoint);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::unregisterEndpoint(const EndpointInfo &endpoint) {
-  if (mV4Impl) return mV4Impl->unregisterEndpoint(endpoint);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::registerEndpointCallback(
-    const std::shared_ptr<IEndpointCallback> &callback) {
-  if (mV4Impl) return mV4Impl->registerEndpointCallback(callback);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::requestSessionIdRange(int32_t size,
-                                                std::vector<int32_t> *ids) {
-  if (mV4Impl) return mV4Impl->requestSessionIdRange(size, ids);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::openEndpointSession(
-    int32_t sessionId, const EndpointId &destination,
-    const EndpointId &initiator,
-    const std::optional<std::string> &serviceDescriptor) {
-  if (mV4Impl) {
-    return mV4Impl->openEndpointSession(sessionId, destination, initiator,
-                                        serviceDescriptor);
-  }
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::sendMessageToEndpoint(int32_t sessionId,
-                                                const Message &msg) {
-  if (mV4Impl) return mV4Impl->sendMessageToEndpoint(sessionId, msg);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::sendMessageDeliveryStatusToEndpoint(
-    int32_t sessionId, const MessageDeliveryStatus &msgStatus) {
+ScopedAStatus ContextHub::registerEndpointHub(
+    const std::shared_ptr<IEndpointCallback> &callback, const HubInfo &hubInfo,
+    std::shared_ptr<IEndpointCommunication> *hubInterface) {
   if (mV4Impl)
-    return mV4Impl->sendMessageDeliveryStatusToEndpoint(sessionId, msgStatus);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::closeEndpointSession(int32_t sessionId,
-                                               Reason reason) {
-  if (mV4Impl) return mV4Impl->closeEndpointSession(sessionId, reason);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus ContextHub::endpointSessionOpenComplete(int32_t sessionId) {
-  if (mV4Impl) return mV4Impl->endpointSessionOpenComplete(sessionId);
+    return mV4Impl->registerEndpointHub(callback, hubInfo, hubInterface);
   return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
 }
 
@@ -481,6 +432,8 @@ void ContextHub::onNanoappListResponse(
     if (!mQueryNanoappsInternalList) {
       mQueryNanoappsInternalList = appInfoList;
       mQueryNanoappsInternalCondVar.notify_all();
+      // This was an internal HAL request - do not call callback
+      return;
     }
   }
 
@@ -504,7 +457,18 @@ void ContextHub::onTransactionResult(uint32_t transactionId, bool success) {
   }
 }
 
-void ContextHub::onContextHubRestarted() {
+void ContextHub::onContextHubConnected(bool restart) {
+  // Handle any initialization on the first CHRE connection.
+  if (!restart) {
+    if (mV4Impl) mV4Impl->init();
+    return;
+  }
+
+  if (mV4Impl) {
+    mV4Impl->onChreDisconnected();
+    mV4Impl->onChreRestarted();
+  }
+
   std::lock_guard<std::mutex> lock(mCallbackMutex);
   mIsWifiAvailable.reset();
   {
@@ -582,7 +546,7 @@ ScopedAStatus ContextHub::enableTestMode() {
   std::vector<int64_t> nanoappIdsToUnload;
   if (mIsTestModeEnabled) {
     success = true;
-  } else if (mConnection.isLoadTransactionPending()) {
+  } else if (mConnection->isLoadTransactionPending()) {
     /**
      * There is already a pending load transaction. We cannot change the test
      * mode state if there is a pending load transaction. We do not consider
@@ -639,7 +603,7 @@ ScopedAStatus ContextHub::disableTestMode() {
   std::string preloadedNanoappDirectory;
   if (!mIsTestModeEnabled) {
     success = true;
-  } else if (mConnection.isLoadTransactionPending()) {
+  } else if (mConnection->isLoadTransactionPending()) {
     /**
      * There is already a pending load transaction. We cannot change the test
      * mode state if there is a pending load transaction. We do not consider
@@ -702,7 +666,7 @@ bool ContextHub::loadNanoappInternal(const NanoappBinary &appBinary,
   FragmentedLoadTransaction transaction(
       transactionId, appBinary.nanoappId, appBinary.nanoappVersion,
       appBinary.flags, targetApiVersion, appBinary.customBinary);
-  bool success = mConnection.loadNanoapp(transaction);
+  bool success = mConnection->loadNanoapp(transaction);
   mEventLogger.logNanoappLoad(appBinary.nanoappId,
                               appBinary.customBinary.size(),
                               appBinary.nanoappVersion, success);
@@ -751,7 +715,7 @@ bool ContextHub::loadNanoappsInternal(
 }
 
 bool ContextHub::unloadNanoappInternal(int64_t appId, int32_t transactionId) {
-  bool success = mConnection.unloadNanoapp(appId, transactionId);
+  bool success = mConnection->unloadNanoapp(appId, transactionId);
   mEventLogger.logNanoappUnload(appId, success);
   return success;
 }
diff --git a/host/hal_generic/aidl/generic_context_hub_aidl.h b/host/hal_generic/aidl/generic_context_hub_aidl.h
index 7dd85b00..55d31594 100644
--- a/host/hal_generic/aidl/generic_context_hub_aidl.h
+++ b/host/hal_generic/aidl/generic_context_hub_aidl.h
@@ -24,10 +24,14 @@
 #include <functional>
 #include <future>
 #include <map>
+#include <memory>
 #include <mutex>
 #include <optional>
 #include <unordered_set>
 
+#include <flatbuffers/flatbuffers.h>
+
+#include "bluetooth_socket_offload_link.h"
 #include "chre_host/napp_header.h"
 #include "context_hub_v4_impl.h"
 #include "debug_dump_helper.h"
@@ -56,13 +60,21 @@ class ContextHub : public BnContextHub,
                    public ::android::hardware::contexthub::DebugDumpHelper,
                    public ::android::hardware::contexthub::common::
                        implementation::IChreSocketCallback {
+ private:
+  using HalChreSocketConnection = ::android::hardware::contexthub::common::
+      implementation::HalChreSocketConnection;
+  using BluetoothSocketOffloadLink = ::aidl::android::hardware::bluetooth::
+      socket::impl::BluetoothSocketOffloadLink;
+
  public:
   ContextHub()
       : mDeathRecipient(
             AIBinder_DeathRecipient_new(ContextHub::onServiceDied)) {
+    mConnection = std::make_shared<HalChreSocketConnection>(this);
     if (::android::chre::flags::offload_implementation()) {
-      mV4Impl.emplace([this](uint8_t *data, size_t size) {
-        return mConnection.sendRawMessage(data, size);
+      mV4Impl.emplace([this](const flatbuffers::FlatBufferBuilder &builder) {
+        return mConnection->sendRawMessage(builder.GetBufferPointer(),
+                                           builder.GetSize());
       });
     }
   }
@@ -100,24 +112,10 @@ class ContextHub : public BnContextHub,
   ::ndk::ScopedAStatus getHubs(std::vector<HubInfo> *hubs) override;
   ::ndk::ScopedAStatus getEndpoints(
       std::vector<EndpointInfo> *endpoints) override;
-  ::ndk::ScopedAStatus registerEndpoint(const EndpointInfo &endpoint) override;
-  ::ndk::ScopedAStatus unregisterEndpoint(
-      const EndpointInfo &endpoint) override;
-  ::ndk::ScopedAStatus registerEndpointCallback(
-      const std::shared_ptr<IEndpointCallback> &callback) override;
-  ::ndk::ScopedAStatus requestSessionIdRange(
-      int32_t size, std::vector<int32_t> *ids) override;
-  ::ndk::ScopedAStatus openEndpointSession(
-      int32_t sessionId, const EndpointId &destination,
-      const EndpointId &initiator,
-      const std::optional<std::string> &serviceDescriptor) override;
-  ::ndk::ScopedAStatus sendMessageToEndpoint(int32_t sessionId,
-                                             const Message &msg) override;
-  ::ndk::ScopedAStatus sendMessageDeliveryStatusToEndpoint(
-      int32_t sessionId, const MessageDeliveryStatus &msgStatus) override;
-  ::ndk::ScopedAStatus closeEndpointSession(int32_t sessionId,
-                                            Reason reason) override;
-  ::ndk::ScopedAStatus endpointSessionOpenComplete(int32_t sessionId) override;
+  ::ndk::ScopedAStatus registerEndpointHub(
+      const std::shared_ptr<IEndpointCallback> &callback,
+      const HubInfo &hubInfo,
+      std::shared_ptr<IEndpointCommunication> *hubInterface) override;
 
   void onNanoappMessage(const ::chre::fbs::NanoappMessageT &message) override;
 
@@ -126,7 +124,7 @@ class ContextHub : public BnContextHub,
 
   void onTransactionResult(uint32_t transactionId, bool success) override;
 
-  void onContextHubRestarted() override;
+  void onContextHubConnected(bool restart) override;
 
   void onDebugDumpData(const ::chre::fbs::DebugDumpDataT &data) override;
 
@@ -142,13 +140,17 @@ class ContextHub : public BnContextHub,
   binder_status_t dump(int fd, const char **args, uint32_t numArgs) override;
 
   bool requestDebugDump() override {
-    return mConnection.requestDebugDump();
+    return mConnection->requestDebugDump();
   }
 
   void debugDumpFinish() override;
 
   void writeToDebugFile(const char *str) override;
 
+  std::shared_ptr<BluetoothSocketOffloadLink> getBluetoothSocketOffloadLink() {
+    return std::static_pointer_cast<BluetoothSocketOffloadLink>(mConnection);
+  }
+
  private:
   /**
    * Enables test mode on the context hub. This unloads all nanoapps and puts
@@ -159,8 +161,8 @@ class ContextHub : public BnContextHub,
   ::ndk::ScopedAStatus enableTestMode();
 
   /**
-   * Disables test mode. Reverses the affects of enableTestMode() by loading all
-   * preloaded nanoapps. This puts CHRE back in a normal state.
+   * Disables test mode. Reverses the affects of enableTestMode() by loading
+   * all preloaded nanoapps. This puts CHRE back in a normal state.
    *
    * @return                            the status.
    */
@@ -228,10 +230,11 @@ class ContextHub : public BnContextHub,
 
   /**
    * Get the preloaded nanoapp IDs from the config file and headers. All IDs,
-   * names and headers are in the same order (one nanoapp has the same index in
-   * each).
+   * names and headers are in the same order (one nanoapp has the same index
+   * in each).
    *
-   * @param out_preloadedNanoapps       out parameter, the nanoapp information.
+   * @param out_preloadedNanoapps       out parameter, the nanoapp
+   * information.
    * @param out_directory               out parameter, optional, the directory
    * that contains the nanoapps.
    * @return true                       the operation was successful.
@@ -261,8 +264,7 @@ class ContextHub : public BnContextHub,
                    : chre::fbs::SettingState::DISABLED;
   }
 
-  ::android::hardware::contexthub::common::implementation::
-      HalChreSocketConnection mConnection{this};
+  std::shared_ptr<HalChreSocketConnection> mConnection;
 
   // A mutex to protect concurrent modifications to the callback pointer and
   // access (invocations).
@@ -293,7 +295,7 @@ class ContextHub : public BnContextHub,
   // A mutex and condition variable to synchronize queryNanoappsInternal.
   std::mutex mQueryNanoappsInternalMutex;
   std::condition_variable mQueryNanoappsInternalCondVar;
-  std::optional<std::vector<NanoappInfo>> mQueryNanoappsInternalList;
+  std::optional<std::vector<NanoappInfo>> mQueryNanoappsInternalList{{}};
 
   // State for synchronous loads and unloads. Primarily used for test mode.
   std::mutex mSynchronousLoadUnloadMutex;
diff --git a/host/hal_generic/common/bluetooth_socket_fbs_hal.cc b/host/hal_generic/common/bluetooth_socket_fbs_hal.cc
new file mode 100644
index 00000000..e791253e
--- /dev/null
+++ b/host/hal_generic/common/bluetooth_socket_fbs_hal.cc
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bluetooth_socket_fbs_hal.h"
+
+#include <cstdint>
+#include <future>
+
+#include "chre/platform/shared/host_protocol_common.h"
+#include "chre_host/generated/host_messages_generated.h"
+#include "chre_host/host_protocol_host.h"
+#include "chre_host/log.h"
+#include "flatbuffers/flatbuffers.h"
+
+namespace aidl::android::hardware::bluetooth::socket::impl {
+
+using ::android::chre::getStringFromByteVector;
+using ndk::ScopedAStatus;
+
+ScopedAStatus BluetoothSocketFbsHal::registerCallback(
+    const std::shared_ptr<IBluetoothSocketCallback> &callback) {
+  mCallback = callback;
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothSocketFbsHal::getSocketCapabilities(
+    SocketCapabilities *result) {
+  std::future<SocketCapabilities> future = mCapabilitiesPromise.get_future();
+
+  flatbuffers::FlatBufferBuilder builder(64);
+  auto socketCapabilitiesRequest =
+      ::chre::fbs::CreateBtSocketCapabilitiesRequest(builder);
+  ::chre::HostProtocolCommon::finalize(
+      builder, ::chre::fbs::ChreMessage::BtSocketCapabilitiesRequest,
+      socketCapabilitiesRequest.Union());
+
+  if (!mOffloadLinkAvailable) {
+    LOGE("BT Socket Offload Link not available");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "BT offload link not available");
+  }
+
+  if (!mOffloadLink->sendMessageToOffloadStack(builder.GetBufferPointer(),
+                                               builder.GetSize())) {
+    LOGE("Failed to send BT socket capabilities request message");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "Failed to send BT socket message");
+  }
+
+  std::future_status status = future.wait_for(std::chrono::seconds(5));
+  if (status != std::future_status::ready) {
+    LOGE("BT Socket capabilities request timed out");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "BT socket capabilities request timed out");
+  }
+
+  *result = future.get();
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothSocketFbsHal::opened(const SocketContext &context) {
+  LOGD("Host opened BT offload socket ID=%" PRIu64, context.socketId);
+  if (!mOffloadLinkAvailable) {
+    LOGE("BT Socket Offload Link not available");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "BT offload link not available");
+  }
+  if (context.channelInfo.getTag() != ChannelInfo::Tag::leCocChannelInfo) {
+    LOGE("Got open request for unsupported socket type %" PRId32,
+         context.channelInfo.getTag());
+    sendOpenedCompleteMessage(context.socketId, Status::FAILURE,
+                              "Unsupported socket type");
+    return ScopedAStatus::ok();
+  }
+  flatbuffers::FlatBufferBuilder builder(1028);
+  auto socketName = ::chre::HostProtocolCommon::addStringAsByteVector(
+      builder, context.name.c_str());
+  const auto &socketChannelInfo =
+      context.channelInfo.get<ChannelInfo::Tag::leCocChannelInfo>();
+  auto leCocChannelInfo = ::chre::fbs::CreateLeCocChannelInfo(
+      builder, socketChannelInfo.localCid, socketChannelInfo.remoteCid,
+      socketChannelInfo.psm, socketChannelInfo.localMtu,
+      socketChannelInfo.remoteMtu, socketChannelInfo.localMps,
+      socketChannelInfo.remoteMps, socketChannelInfo.initialRxCredits,
+      socketChannelInfo.initialTxCredits);
+
+  auto socketOpen = ::chre::fbs::CreateBtSocketOpen(
+      builder, context.socketId, socketName, context.aclConnectionHandle,
+      ::chre::fbs::ChannelInfo::LeCocChannelInfo, leCocChannelInfo.Union(),
+      context.endpointId.hubId, context.endpointId.id);
+  ::chre::HostProtocolCommon::finalize(
+      builder, ::chre::fbs::ChreMessage::BtSocketOpen, socketOpen.Union());
+
+  if (!mOffloadLink->sendMessageToOffloadStack(builder.GetBufferPointer(),
+                                               builder.GetSize())) {
+    LOGE("Failed to send BT socket opened message");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "Failed to send BT socket message");
+  }
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus BluetoothSocketFbsHal::closed(int64_t socketId) {
+  LOGD("Host closed BT offload socket ID=%" PRIu64, socketId);
+  if (!mOffloadLinkAvailable) {
+    LOGE("BT Socket Offload Link not available");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "BT offload link not available");
+  }
+
+  flatbuffers::FlatBufferBuilder builder(64);
+  auto socketCloseResponse =
+      ::chre::fbs::CreateBtSocketCloseResponse(builder, socketId);
+  ::chre::HostProtocolCommon::finalize(
+      builder, ::chre::fbs::ChreMessage::BtSocketCloseResponse,
+      socketCloseResponse.Union());
+
+  if (!mOffloadLink->sendMessageToOffloadStack(builder.GetBufferPointer(),
+                                               builder.GetSize())) {
+    LOGE("Failed to send BT socket closed message");
+    return ScopedAStatus::fromServiceSpecificErrorWithMessage(
+        static_cast<int32_t>(STATUS_UNKNOWN_ERROR),
+        "Failed to send BT socket message");
+  }
+
+  return ScopedAStatus::ok();
+}
+
+void BluetoothSocketFbsHal::handleMessageFromOffloadStack(const void *message,
+                                                          size_t length) {
+  if (!chre::HostProtocolCommon::verifyMessage(message, length)) {
+    LOGE("Could not decode Bluetooth Socket message");
+  } else {
+    std::unique_ptr<chre::fbs::MessageContainerT> container =
+        chre::fbs::UnPackMessageContainer(message);
+    chre::fbs::ChreMessageUnion &msg = container->message;
+    switch (container->message.type) {
+      case chre::fbs::ChreMessage::BtSocketOpenResponse:
+        handleBtSocketOpenResponse(*msg.AsBtSocketOpenResponse());
+        break;
+
+      case chre::fbs::ChreMessage::BtSocketClose:
+        handleBtSocketClose(*msg.AsBtSocketClose());
+        break;
+
+      case chre::fbs::ChreMessage::BtSocketCapabilitiesResponse:
+        handleBtSocketCapabilitiesResponse(
+            *msg.AsBtSocketCapabilitiesResponse());
+        break;
+
+      default:
+        LOGW("Got unexpected Bluetooth Socket message type %" PRIu8,
+             static_cast<uint8_t>(msg.type));
+        break;
+    }
+  }
+}
+
+void BluetoothSocketFbsHal::handleBtSocketOpenResponse(
+    const ::chre::fbs::BtSocketOpenResponseT &response) {
+  std::string reason = std::string(getStringFromByteVector(response.reason));
+  LOGD("Got BT Socket open response, socket ID=%" PRIu64
+       ", status=%d, reason=%s",
+       response.socketId, response.status, reason.c_str());
+  sendOpenedCompleteMessage(
+      response.socketId,
+      response.status == ::chre::fbs::BtSocketOpenStatus::SUCCESS
+          ? Status::SUCCESS
+          : Status::FAILURE,
+      reason);
+}
+
+void BluetoothSocketFbsHal::handleBtSocketClose(
+    const ::chre::fbs::BtSocketCloseT &message) {
+  std::string reason = std::string(getStringFromByteVector(message.reason));
+  LOGD("Got BT Socket close, socket ID=%" PRIu64 ", reason=%s",
+       message.socketId, reason.c_str());
+  if (mCallback == nullptr) {
+    LOGE("Received socket close message with no registered callback");
+    return;
+  }
+  mCallback->close(message.socketId, reason);
+}
+
+void BluetoothSocketFbsHal::handleBtSocketCapabilitiesResponse(
+    const ::chre::fbs::BtSocketCapabilitiesResponseT &response) {
+  LOGD("Got BT Socket capabilities response");
+  SocketCapabilities capabilities = {
+      .leCocCapabilities =
+          {
+              .numberOfSupportedSockets =
+                  response.leCocCapabilities->numberOfSupportedSockets,
+              .mtu = response.leCocCapabilities->mtu,
+          },
+      .rfcommCapabilities =
+          {
+              .numberOfSupportedSockets =
+                  response.rfcommCapabilities->numberOfSupportedSockets,
+              .maxFrameSize = response.rfcommCapabilities->maxFrameSize,
+          },
+  };
+  mCapabilitiesPromise.set_value(capabilities);
+}
+
+void BluetoothSocketFbsHal::sendOpenedCompleteMessage(int64_t socketId,
+                                                      Status status,
+                                                      std::string reason) {
+  if (mCallback == nullptr) {
+    LOGE("Sending socket opened complete with no registered callback");
+    return;
+  }
+  mCallback->openedComplete(socketId, status, reason);
+}
+
+}  // namespace aidl::android::hardware::bluetooth::socket::impl
diff --git a/host/hal_generic/common/bluetooth_socket_fbs_hal.h b/host/hal_generic/common/bluetooth_socket_fbs_hal.h
new file mode 100644
index 00000000..cb1866d1
--- /dev/null
+++ b/host/hal_generic/common/bluetooth_socket_fbs_hal.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <cstdint>
+#include <future>
+
+#include "aidl/android/hardware/bluetooth/socket/BnBluetoothSocket.h"
+#include "bluetooth_socket_offload_link.h"
+#include "bluetooth_socket_offload_link_callback.h"
+#include "chre_host/generated/host_messages_generated.h"
+
+namespace aidl::android::hardware::bluetooth::socket::impl {
+
+/**
+ * Implementationof the BT Socket HAL using flatbuffer encoding and decoding for
+ * offload messages.
+ */
+class BluetoothSocketFbsHal : public BnBluetoothSocket,
+                              public BluetoothSocketOffloadLinkCallback {
+ public:
+  BluetoothSocketFbsHal(std::shared_ptr<BluetoothSocketOffloadLink> offloadLink)
+      : mOffloadLink(offloadLink) {
+    mOffloadLink->setBluetoothSocketCallback(this);
+  }
+
+  // Functions implementing IBluetoothSocket.
+  ndk::ScopedAStatus registerCallback(
+      const std::shared_ptr<IBluetoothSocketCallback> &callback) override;
+  ndk::ScopedAStatus getSocketCapabilities(SocketCapabilities *result) override;
+  ndk::ScopedAStatus opened(const SocketContext &context) override;
+  ndk::ScopedAStatus closed(int64_t socketId) override;
+
+  // Functions implementing BluetoothSocketOffloadLinkCallback.
+  void onOffloadLinkDisconnected() override {
+    mOffloadLinkAvailable = false;
+  }
+  void onOffloadLinkReconnected() override {
+    mOffloadLinkAvailable = true;
+  }
+  void handleMessageFromOffloadStack(const void *message,
+                                     size_t length) override;
+
+ private:
+  std::shared_ptr<BluetoothSocketOffloadLink> mOffloadLink;
+
+  std::shared_ptr<IBluetoothSocketCallback> mCallback{};
+
+  // A thread safe flag indicating if the offload link is ready for operations.
+  // Outside of the constructor, this boolean flag should only be written by
+  // onOffloadLinkDisconnected and onOffloadLinkReconnected, the order of which
+  // should be guaranteed by the BT Socket offload link's disconnection handler.
+  std::atomic_bool mOffloadLinkAvailable = true;
+
+  // A promise that is set when getSocketCapabilities is called and is fulfilled
+  // when a response is received from the offload stack.
+  std::promise<SocketCapabilities> mCapabilitiesPromise;
+
+  void sendOpenedCompleteMessage(int64_t socketId, Status status,
+                                 std::string reason);
+
+  void handleBtSocketOpenResponse(
+      const ::chre::fbs::BtSocketOpenResponseT &response);
+
+  void handleBtSocketClose(const ::chre::fbs::BtSocketCloseT &message);
+
+  void handleBtSocketCapabilitiesResponse(
+      const ::chre::fbs::BtSocketCapabilitiesResponseT &response);
+};
+
+}  // namespace aidl::android::hardware::bluetooth::socket::impl
diff --git a/host/hal_generic/common/bluetooth_socket_offload_link.h b/host/hal_generic/common/bluetooth_socket_offload_link.h
new file mode 100644
index 00000000..a86173c8
--- /dev/null
+++ b/host/hal_generic/common/bluetooth_socket_offload_link.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <cstddef>
+#include <cstdint>
+
+#include "bluetooth_socket_offload_link_callback.h"
+
+namespace aidl::android::hardware::bluetooth::socket::impl {
+
+/**
+ * This abstract class defines the interface between the Bluetooth Socket HAL
+ * and the offload domain.
+ */
+class BluetoothSocketOffloadLink {
+ public:
+  virtual ~BluetoothSocketOffloadLink() = default;
+  /**
+   * Initializes the link between HAL and the offload domain.
+   *
+   * @return true if success, otherwise false.
+   */
+  virtual bool initOffloadLink() = 0;
+
+  /**
+   * Sends an encoded message regarding the status of an offloaded Bluetooth
+   * Socket to the offload stack.
+   *
+   * @return true if success, otherwise false.
+   */
+  virtual bool sendMessageToOffloadStack(void *data, size_t size) = 0;
+
+  virtual void setBluetoothSocketCallback(
+      BluetoothSocketOffloadLinkCallback *btSocketCallback) = 0;
+};
+
+}  // namespace aidl::android::hardware::bluetooth::socket::impl
diff --git a/host/hal_generic/common/bluetooth_socket_offload_link_callback.h b/host/hal_generic/common/bluetooth_socket_offload_link_callback.h
new file mode 100644
index 00000000..bff8f8da
--- /dev/null
+++ b/host/hal_generic/common/bluetooth_socket_offload_link_callback.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include "chre_host/generated/host_messages_generated.h"
+
+namespace aidl::android::hardware::bluetooth::socket::impl {
+
+/**
+ * The callback interface for a BluetoothSocketOffloadLink
+ *
+ * A Bluetooth Socket HAL should implement this interface so that the
+ * BluetoothSocketOffloadLink has an API to pass messages to.
+ */
+class BluetoothSocketOffloadLinkCallback {
+ public:
+  virtual ~BluetoothSocketOffloadLinkCallback() = default;
+
+  /**
+   * This method should be called when the offload link is disconnected from
+   * the HAL.
+   */
+  virtual void onOffloadLinkDisconnected() {}
+
+  /**
+   * This method should be called when the offload link is reconnected to the
+   * HAL.
+   */
+  virtual void onOffloadLinkReconnected() {}
+
+  /**
+   * Handles an encoded message related to an offloaded Bluetooth Socket from
+   * the offload stack.
+   */
+  virtual void handleMessageFromOffloadStack(const void *message,
+                                             size_t length) = 0;
+};
+
+}  // namespace aidl::android::hardware::bluetooth::socket::impl
diff --git a/host/hal_generic/common/bluetooth_socket_stub.h b/host/hal_generic/common/bluetooth_socket_stub.h
new file mode 100644
index 00000000..8e2866f3
--- /dev/null
+++ b/host/hal_generic/common/bluetooth_socket_stub.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+#include "aidl/android/hardware/bluetooth/socket/BnBluetoothSocket.h"
+
+namespace aidl::android::hardware::bluetooth::socket::impl {
+
+/**
+ * The stub implementation of the BT Socket HAL.
+ */
+class BluetoothSocketStub : public BnBluetoothSocket {
+ public:
+  // Functions implementing IBluetoothSocket.
+  ndk::ScopedAStatus registerCallback(
+      const std::shared_ptr<IBluetoothSocketCallback> &) override {
+    return ndk::ScopedAStatus::ok();
+  }
+
+  ndk::ScopedAStatus getSocketCapabilities(
+      SocketCapabilities *result) override {
+    result->leCocCapabilities.numberOfSupportedSockets = 0;
+    result->leCocCapabilities.mtu = 1000;
+    result->rfcommCapabilities.numberOfSupportedSockets = 0;
+    result->rfcommCapabilities.maxFrameSize = 23;
+    return ndk::ScopedAStatus::ok();
+  }
+
+  ndk::ScopedAStatus opened(const SocketContext &) override {
+    return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  }
+
+  ndk::ScopedAStatus closed(int64_t) override {
+    return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  }
+};
+
+}  // namespace aidl::android::hardware::bluetooth::socket::impl
diff --git a/host/hal_generic/common/context_hub_v4_impl.cc b/host/hal_generic/common/context_hub_v4_impl.cc
index 91fdde62..16c01da7 100644
--- a/host/hal_generic/common/context_hub_v4_impl.cc
+++ b/host/hal_generic/common/context_hub_v4_impl.cc
@@ -16,7 +16,6 @@
 
 #include "context_hub_v4_impl.h"
 
-#include <assert.h>
 #include <inttypes.h>
 
 #include <functional>
@@ -25,9 +24,12 @@
 #include <vector>
 
 #include <aidl/android/hardware/contexthub/BnContextHub.h>
+#include <aidl/android/hardware/contexthub/BnEndpointCommunication.h>
 #include <chre_host/generated/host_messages_generated.h>
 #include <chre_host/log.h>
 
+#include "host_protocol_host_v4.h"
+
 namespace android::hardware::contexthub::common::implementation {
 
 using ::aidl::android::hardware::contexthub::BnContextHub;
@@ -35,8 +37,41 @@ using ::chre::fbs::ChreMessage;
 using HostHub = MessageHubManager::HostHub;
 
 void ContextHubV4Impl::init() {
-  // TODO(b/378545373): Send message to get hubs/endpoints state dump to
-  // initialize mManager.
+  std::lock_guard lock(mHostHubOpLock);  // See header documentation.
+  flatbuffers::FlatBufferBuilder builder;
+  // NOTE: This message should be renamed as on initialization/CHRE restart it
+  // is used both to initialize the CHRE-side host hub proxies and to request
+  // embedded hub state.
+  HostProtocolHostV4::encodeGetMessageHubsAndEndpointsRequest(builder);
+  if (!mSendMessageFn(builder))
+    LOGE("Failed to initialize CHRE host hub proxies");
+  mManager.forEachHostHub([this](HostHub &hub) {
+    flatbuffers::FlatBufferBuilder builder;
+    HostProtocolHostV4::encodeRegisterMessageHub(builder, hub.info());
+    if (!mSendMessageFn(builder)) {
+      LOGE("Failed to initialize proxy for host hub %" PRIu64, hub.id());
+      return;
+    }
+    for (const auto &endpoint : hub.getEndpoints()) {
+      flatbuffers::FlatBufferBuilder builder;
+      HostProtocolHostV4::encodeRegisterEndpoint(builder, endpoint);
+      if (!mSendMessageFn(builder)) {
+        LOGE("Failed to initialize proxy for host endpoint (%" PRIu64
+             ", %" PRIu64 ")",
+             endpoint.id.hubId, endpoint.id.id);
+        return;
+      }
+    }
+  });
+}
+
+void ContextHubV4Impl::onChreDisconnected() {
+  LOGI("Clearing embedded message hub state.");
+  mManager.clearEmbeddedState();
+}
+
+void ContextHubV4Impl::onChreRestarted() {
+  init();
 }
 
 namespace {
@@ -48,7 +83,7 @@ ScopedAStatus fromPwStatus(pw::Status status) {
     case PW_STATUS_NOT_FOUND:
       [[fallthrough]];
     case PW_STATUS_ALREADY_EXISTS:
-      [[fallthrough]];
+      return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_STATE);
     case PW_STATUS_OUT_OF_RANGE:
       [[fallthrough]];
     case PW_STATUS_PERMISSION_DENIED:
@@ -76,160 +111,206 @@ ScopedAStatus ContextHubV4Impl::getEndpoints(
   return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::registerEndpoint(const EndpointInfo &endpoint) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  if (auto status = hub->addEndpoint(hub, endpoint); !status.ok()) {
-    LOGE("Failed to register endpoint %" PRId64 " on hub %" PRId64
-         " with %" PRId32,
-         endpoint.id.id, hub->id(), status.code());
-    return fromPwStatus(status);
+ScopedAStatus ContextHubV4Impl::registerEndpointHub(
+    const std::shared_ptr<IEndpointCallback> &callback, const HubInfo &hubInfo,
+    std::shared_ptr<IEndpointCommunication> *hubInterface) {
+  std::lock_guard lock(mHostHubOpLock);  // See header documentation.
+  auto statusOrHub = mManager.createHostHub(
+      callback, hubInfo, AIBinder_getCallingUid(), AIBinder_getCallingPid());
+  if (!statusOrHub.ok()) {
+    LOGE("Failed to register message hub 0x%" PRIx64 " with %" PRId32,
+         hubInfo.hubId, statusOrHub.status().ok());
+    return fromPwStatus(statusOrHub.status());
   }
-  // TODO(b/378545373): Send the endpoint info to CHRE.
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeRegisterMessageHub(builder, hubInfo);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send RegisterMessageHub for hub 0x%" PRIx64, hubInfo.hubId);
+    (*statusOrHub)->unregister();
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  *hubInterface = ndk::SharedRefBase::make<HostHubInterface>(
+      std::move(*statusOrHub), mSendMessageFn, mHostHubOpLock);
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::unregisterEndpoint(
-    const EndpointInfo &endpoint) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  if (auto status = hub->removeEndpoint(endpoint.id); !status.ok()) {
-    LOGE("Failed to unregister endpoint %" PRId32 " on hub %" PRId32
+ScopedAStatus HostHubInterface::registerEndpoint(const EndpointInfo &endpoint) {
+  std::lock_guard lock(mHostHubOpLock);  // See header documentation.
+  if (auto status = mHub->addEndpoint(endpoint); !status.ok()) {
+    LOGE("Failed to register endpoint 0x%" PRIx64 " on hub 0x%" PRIx64
          " with %" PRId32,
-         endpoint.id.id, hub->id(), status.code());
+         endpoint.id.id, mHub->id(), status.code());
     return fromPwStatus(status);
   }
-  // TODO(b/378545373): Send the endpoint info to CHRE.
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeRegisterEndpoint(builder, endpoint);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send RegisterEndpoint for (0x%" PRIx64 ", 0x%" PRIx64 ")",
+         endpoint.id.hubId, endpoint.id.id);
+    mHub->removeEndpoint(endpoint.id).IgnoreError();
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::registerEndpointCallback(
-    const std::shared_ptr<IEndpointCallback> &callback) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  return fromPwStatus(hub->setCallback(callback));
+ScopedAStatus HostHubInterface::unregisterEndpoint(
+    const EndpointInfo &endpoint) {
+  std::lock_guard lock(mHostHubOpLock);  // See header documentation.
+  auto statusOrSessions = mHub->removeEndpoint(endpoint.id);
+  if (!statusOrSessions.ok()) {
+    LOGE("Failed to unregister endpoint 0x%" PRIx64 " on hub 0x%" PRIx64
+         " with %" PRId32,
+         endpoint.id.id, mHub->id(), statusOrSessions.status().code());
+    return fromPwStatus(statusOrSessions.status());
+  }
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeUnregisterEndpoint(builder, endpoint.id);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send RegisterEndpoint for (0x%" PRIx64 ", 0x%" PRIx64 ")",
+         endpoint.id.hubId, endpoint.id.id);
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::requestSessionIdRange(
-    int32_t size, std::vector<int32_t> *ids) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  auto statusOrRange = hub->reserveSessionIdRange(size);
+ScopedAStatus HostHubInterface::requestSessionIdRange(
+    int32_t size, std::array<int32_t, 2> *ids) {
+  auto statusOrRange = mHub->reserveSessionIdRange(size);
   if (!statusOrRange.ok()) {
-    LOGE("Failed to reserve %" PRId32 " session ids on hub %" PRId64
+    LOGE("Failed to reserve %" PRId32 " session ids on hub 0x%" PRIx64
          " with %" PRId32,
-         size, hub->id(), statusOrRange.status().code());
+         size, mHub->id(), statusOrRange.status().code());
     return fromPwStatus(statusOrRange.status());
   }
-  ids->resize(2);
   (*ids)[0] = statusOrRange->first;
   (*ids)[1] = statusOrRange->second;
   return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::openEndpointSession(
+ScopedAStatus HostHubInterface::openEndpointSession(
     int32_t sessionId, const EndpointId &destination,
     const EndpointId &initiator,
-    const std::optional<std::string> & /*serviceDescriptor*/) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  pw::Result<std::shared_ptr<HostHub>> statusOrPruneHub =
-      hub->openSession(hub, initiator, destination, sessionId);
-  if (!statusOrPruneHub.ok()) {
-    LOGE("Failed to open session %" PRId32 " from (%" PRId64 ", %" PRId64
-         ") to (%" PRId64 ", %" PRId64 ") with %" PRId32,
+    const std::optional<std::string> &serviceDescriptor) {
+  // Ignore the flag to send a close. This hub overriding its own session is an
+  // should just return error.
+  auto status = mHub->openSession(initiator, destination, sessionId,
+                                  serviceDescriptor, /*hostInitiated=*/true);
+  if (!status.ok()) {
+    LOGE("Failed to open session %" PRId32 " from (0x%" PRIx64 ", 0x%" PRIx64
+         ") to (0x%" PRIx64 ", 0x%" PRIx64 ") with %" PRId32,
          sessionId, initiator.hubId, initiator.id, destination.hubId,
-         destination.id, statusOrPruneHub.status().code());
-    return fromPwStatus(statusOrPruneHub.status());
-  } else if (*statusOrPruneHub) {
-    // Send a closed session notification on the hub that hosted the pruned
-    // session.
-    auto status = (*statusOrPruneHub)->closeSession(sessionId);
-    LOGD("Pruning session %" PRIu16 " with status %" PRId32, sessionId,
-         status.code());
+         destination.id, status.code());
+    return fromPwStatus(status);
   }
-  // TODO(b/378545373): Send the session open request to CHRE.
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeOpenEndpointSessionRequest(
+      builder, mHub->id(), sessionId, initiator, destination,
+      serviceDescriptor);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send OpenEndpointSessionRequest for session %" PRId32,
+         sessionId);
+    mHub->closeSession(sessionId, Reason::UNSPECIFIED).IgnoreError();
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::sendMessageToEndpoint(int32_t sessionId,
-                                                      const Message & /*msg*/) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  if (auto status = hub->checkSessionOpen(sessionId); !status.ok()) {
-    if (status.IsUnavailable()) {
-      hub->getCallback()->onCloseEndpointSession(sessionId,
-                                                 Reason::ENDPOINT_GONE);
-    } else {
-      LOGE("Failed to verify session %" PRId32 " on hub %" PRId64
-           " with %" PRId32,
-           sessionId, hub->id(), status.code());
-    }
+ScopedAStatus HostHubInterface::sendMessageToEndpoint(int32_t sessionId,
+                                                      const Message &msg) {
+  if (auto status = mHub->checkSessionOpen(sessionId); !status.ok()) {
+    LOGE("Failed to verify session %" PRId32 " on hub 0x%" PRIx64
+         " with %" PRId32,
+         sessionId, mHub->id(), status.code());
     return fromPwStatus(status);
   }
   // TODO(b/378545373): Handle reliable messages.
-  // TODO(b/378545373): Send the message to CHRE.
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeEndpointSessionMessage(builder, mHub->id(),
+                                                   sessionId, msg);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send EndpointSessionMessage over session %" PRId32,
+         sessionId);
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::sendMessageDeliveryStatusToEndpoint(
-    int32_t sessionId, const MessageDeliveryStatus & /*msgStatus*/) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  if (auto status = hub->checkSessionOpen(sessionId); !status.ok()) {
-    if (status.IsUnavailable()) {
-      hub->getCallback()->onCloseEndpointSession(sessionId,
-                                                 Reason::ENDPOINT_GONE);
-    } else {
-      LOGE("Failed to verify session %" PRId32 " on hub %" PRId64
-           " with %" PRId32,
-           sessionId, hub->id(), status.code());
-    }
+ScopedAStatus HostHubInterface::sendMessageDeliveryStatusToEndpoint(
+    int32_t sessionId, const MessageDeliveryStatus &msgStatus) {
+  if (auto status = mHub->checkSessionOpen(sessionId); !status.ok()) {
+    LOGE("Failed to verify session %" PRId32 " on hub 0x%" PRIx64
+         " with %" PRId32,
+         sessionId, mHub->id(), status.code());
     return fromPwStatus(status);
   }
-  // TODO(b/378545373): Send the message to CHRE.
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeEndpointSessionMessageDeliveryStatus(
+      builder, mHub->id(), sessionId, msgStatus);
+  if (!mSendMessageFn(builder)) {
+    LOGE(
+        "Failed to send EndpointSessionMessageDeliveryStatus over session "
+        "%" PRId32,
+        sessionId);
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::closeEndpointSession(int32_t sessionId,
-                                                     Reason /*reason*/) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  if (auto status = hub->closeSession(sessionId); !status.ok()) {
-    LOGE("Failed to close session %" PRId32 " on hub %" PRId64 " with %" PRId32,
-         sessionId, hub->id(), status.code());
+ScopedAStatus HostHubInterface::closeEndpointSession(int32_t sessionId,
+                                                     Reason reason) {
+  if (auto status = mHub->closeSession(sessionId); !status.ok()) {
+    LOGE("Failed to close session %" PRId32 " on hub 0x%" PRIx64
+         " with %" PRId32,
+         sessionId, mHub->id(), status.code());
     return fromPwStatus(status);
   }
-  hub->getCallback()->onCloseEndpointSession(
-      sessionId, Reason::CLOSE_ENDPOINT_SESSION_REQUESTED);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeEndpointSessionClosed(builder, mHub->id(),
+                                                  sessionId, reason);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send EndpointSessionClosed for session %" PRId32,
+         sessionId);
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
 }
 
-ScopedAStatus ContextHubV4Impl::endpointSessionOpenComplete(int32_t sessionId) {
-  std::shared_ptr<HostHub> hub =
-      mManager.getHostHubByPid(AIBinder_getCallingPid());
-  assert(hub != nullptr);
-  if (auto status = hub->ackSession(sessionId); !status.ok()) {
-    if (status.IsUnavailable()) {
-      hub->getCallback()->onCloseEndpointSession(sessionId,
-                                                 Reason::ENDPOINT_GONE);
-    } else {
-      LOGE("Failed to verify session %" PRId32 " on hub %" PRId64
-           " with %" PRId32,
-           sessionId, hub->id(), status.code());
-    }
+ScopedAStatus HostHubInterface::endpointSessionOpenComplete(int32_t sessionId) {
+  if (auto status = mHub->ackSession(sessionId, /*hostAcked=*/true);
+      !status.ok()) {
+    LOGE("Failed to verify session %" PRId32 " on hub 0x%" PRIx64
+         " with %" PRId32,
+         sessionId, mHub->id(), status.code());
     return fromPwStatus(status);
   }
-  // TODO(b/378545373): Send the session id to CHRE.
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeEndpointSessionOpened(builder, mHub->id(),
+                                                  sessionId);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send EndpointSessionOpened for session %" PRId32,
+         sessionId);
+    return ScopedAStatus::fromServiceSpecificError(
+        BnContextHub::EX_CONTEXT_HUB_UNSPECIFIED);
+  }
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus HostHubInterface::unregister() {
+  std::lock_guard lock(mHostHubOpLock);  // See header documentation.
+  if (auto status = mHub->unregister(); !status.ok())
+    return fromPwStatus(status);
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeUnregisterMessageHub(builder, mHub->id());
+  if (!mSendMessageFn(builder))
+    LOGE("Failed to send UnregisterMessageHub for hub 0x%" PRIx64, mHub->id());
+  return ScopedAStatus::ok();
 }
 
 bool ContextHubV4Impl::handleMessageFromChre(
@@ -248,6 +329,9 @@ bool ContextHubV4Impl::handleMessageFromChre(
     case ChreMessage::RegisterEndpoint:
       onRegisterEndpoint(*message.AsRegisterEndpoint());
       break;
+    case ChreMessage::UnregisterEndpoint:
+      onUnregisterEndpoint(*message.AsUnregisterEndpoint());
+      break;
     case ChreMessage::OpenEndpointSessionRequest:
       onOpenEndpointSessionRequest(*message.AsOpenEndpointSessionRequest());
       break;
@@ -264,6 +348,12 @@ bool ContextHubV4Impl::handleMessageFromChre(
       onEndpointSessionMessageDeliveryStatus(
           *message.AsEndpointSessionMessageDeliveryStatus());
       break;
+    case ChreMessage::AddServiceToEndpoint:
+      onAddServiceToEndpoint(*message.AsAddServiceToEndpoint());
+      break;
+    case ChreMessage::EndpointReady:
+      onEndpointReady(*message.AsEndpointReady());
+      break;
     default:
       LOGW("Got unexpected message type %" PRIu8,
            static_cast<uint8_t>(message.type));
@@ -274,171 +364,186 @@ bool ContextHubV4Impl::handleMessageFromChre(
 
 void ContextHubV4Impl::onGetMessageHubsAndEndpointsResponse(
     const ::chre::fbs::GetMessageHubsAndEndpointsResponseT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
-  std::vector<HubInfo> hubs;
-  std::vector<EndpointInfo> endpoints;
   LOGI("Initializing embedded message hub cache");
-  mManager.initEmbeddedHubsAndEndpoints(hubs, endpoints);
+  mManager.initEmbeddedState();
 }
 
 void ContextHubV4Impl::onRegisterMessageHub(
-    const ::chre::fbs::RegisterMessageHubT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
+    const ::chre::fbs::RegisterMessageHubT &msg) {
   HubInfo hub;
-  LOGI("Embedded message hub %" PRId64 " registered", hub.hubId);
+  HostProtocolHostV4::decodeRegisterMessageHub(msg, hub);
+  LOGI("Embedded message hub 0x%" PRIx64 " registered", hub.hubId);
   mManager.addEmbeddedHub(hub);
 }
 
 void ContextHubV4Impl::onUnregisterMessageHub(
-    const ::chre::fbs::UnregisterMessageHubT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
+    const ::chre::fbs::UnregisterMessageHubT &msg) {
   int64_t id = 0;
-  LOGI("Embedded message hub %" PRId64 " unregistered", id);
-  std::vector<EndpointId> endpoints = mManager.removeEmbeddedHub(id);
-  if (!endpoints.empty()) {
-    mManager.forEachHostHub([&endpoints](HostHub &hub) {
-      hub.getCallback()->onEndpointStopped(endpoints, Reason::HUB_RESET);
-    });
-  }
+  HostProtocolHostV4::decodeUnregisterMessageHub(msg, id);
+  LOGI("Embedded message hub 0x%" PRIx64 " unregistered", id);
+  mManager.removeEmbeddedHub(id);
 }
 
 void ContextHubV4Impl::onRegisterEndpoint(
-    const ::chre::fbs::RegisterEndpointT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
+    const ::chre::fbs::RegisterEndpointT &msg) {
   EndpointInfo endpoint;
-  LOGI("Adding embedded endpoint (%" PRId64 ", %" PRId64 ")", endpoint.id.hubId,
-       endpoint.id.id);
+  HostProtocolHostV4::decodeRegisterEndpoint(msg, endpoint);
+  LOGI("Adding embedded endpoint (0x%" PRIx64 ", 0x%" PRIx64 ")",
+       endpoint.id.hubId, endpoint.id.id);
   mManager.addEmbeddedEndpoint(endpoint);
-  mManager.forEachHostHub([&endpoint](HostHub &hub) {
-    hub.getCallback()->onEndpointStarted({endpoint});
-  });
 }
 
-void ContextHubV4Impl::onUnregisterEndpoint(
-    const ::chre::fbs::UnregisterEndpointT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
+void ContextHubV4Impl::onAddServiceToEndpoint(
+    const ::chre::fbs::AddServiceToEndpointT &msg) {
+  EndpointId endpoint;
+  Service service;
+  HostProtocolHostV4::decodeAddServiceToEndpoint(msg, endpoint, service);
+  mManager.addEmbeddedEndpointService(endpoint, service);
+}
+
+void ContextHubV4Impl::onEndpointReady(const ::chre::fbs::EndpointReadyT &msg) {
   EndpointId endpoint;
-  LOGI("Removing embedded endpoint (%" PRId64 ", %" PRId64 ")", endpoint.hubId,
+  HostProtocolHostV4::decodeEndpointReady(msg, endpoint);
+  LOGI("Embedded endpoint (0x%" PRIx64 ", 0x%" PRIx64 ") ready", endpoint.hubId,
        endpoint.id);
+  mManager.setEmbeddedEndpointReady(endpoint);
+}
+
+void ContextHubV4Impl::onUnregisterEndpoint(
+    const ::chre::fbs::UnregisterEndpointT &msg) {
+  EndpointId endpoint;
+  HostProtocolHostV4::decodeUnregisterEndpoint(msg, endpoint);
+  LOGI("Removing embedded endpoint (0x%" PRIx64 ", 0x%" PRIx64 ")",
+       endpoint.hubId, endpoint.id);
   mManager.removeEmbeddedEndpoint(endpoint);
-  mManager.forEachHostHub([&endpoint](HostHub &hub) {
-    hub.getCallback()->onEndpointStopped({endpoint}, Reason::ENDPOINT_GONE);
-  });
 }
 
 void ContextHubV4Impl::onOpenEndpointSessionRequest(
-    const ::chre::fbs::OpenEndpointSessionRequestT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
+    const ::chre::fbs::OpenEndpointSessionRequestT &msg) {
   std::optional<std::string> serviceDescriptor;
   EndpointId local, remote;
+  int64_t hubId = 0;
   uint16_t sessionId = 0;
-  LOGD("New session (%" PRIu16 ") request from (%" PRId64 ", %" PRId64
+  HostProtocolHostV4::decodeOpenEndpointSessionRequest(
+      msg, hubId, sessionId, local, remote, serviceDescriptor);
+  LOGD("New session (%" PRIu16 ") request from (0x%" PRIx64 ", 0x%" PRIx64
        ") to "
-       "(%" PRId64 ", %" PRId64 ")",
+       "(0x%" PRIx64 ", 0x%" PRIx64 ")",
        sessionId, remote.hubId, remote.id, local.hubId, local.id);
-
-  // Look up the host hub based on the host endpoint.
-  std::shared_ptr<HostHub> hub = mManager.getHostHubByEndpointId(local);
+  std::shared_ptr<HostHub> hub = mManager.getHostHub(hubId);
   if (!hub) {
     LOGW("Unable to find host hub");
     return;
   }
 
   // Record the open session request and pass it on to the appropriate client.
-  auto statusOrPruneHub = hub->openSession(hub, local, remote, sessionId);
-  if (!statusOrPruneHub.ok()) {
+  auto status =
+      hub->openSession(local, remote, sessionId, std::move(serviceDescriptor),
+                       /*hostInitiated=*/false);
+  if (!status.ok()) {
     LOGE("Failed to request session %" PRIu16 " with %" PRId32, sessionId,
-         statusOrPruneHub.status().code());
-    return;
-  } else if (*statusOrPruneHub) {
-    // Send a closed session notification on the hub that hosted the pruned
-    // session.
-    auto status = (*statusOrPruneHub)->closeSession(sessionId);
-    LOGD("Pruning session %" PRIu16 " with status %" PRId32, sessionId,
-         status.code());
-  }
-  hub->getCallback()->onEndpointSessionOpenRequest(
-      sessionId, local, remote, std::move(serviceDescriptor));
-}
-
-namespace {
-
-void logGetHubFailure(pw::Status status, int32_t sessionId) {
-  if (status.IsUnavailable()) {
-    LOGD("Session %" PRId32 " was pruned.", sessionId);
-  } else {
-    LOGE("Failed to operate on session %" PRId32 " with %" PRId32, sessionId,
          status.code());
+    flatbuffers::FlatBufferBuilder builder;
+    HostProtocolHostV4::encodeEndpointSessionClosed(
+        builder, hub->id(), sessionId, Reason::UNSPECIFIED);
+    mSendMessageFn(builder);
+    return;
   }
 }
 
-}  // namespace
-
 void ContextHubV4Impl::onEndpointSessionOpened(
-    const ::chre::fbs::EndpointSessionOpenedT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
-  int32_t id = 0;
-  LOGD("New session ack for id %" PRId32, id);
-  auto statusOrHub = mManager.ackSessionAndGetHostHub(id);
-  if (!statusOrHub.ok()) {
-    logGetHubFailure(statusOrHub.status(), id);
-    // TODO(b/378545373): Send a notification back to CHRE.
+    const ::chre::fbs::EndpointSessionOpenedT &msg) {
+  int64_t hubId = 0;
+  uint16_t sessionId = 0;
+  HostProtocolHostV4::decodeEndpointSessionOpened(msg, hubId, sessionId);
+  LOGD("New session ack for id %" PRIu16 " on hub 0x%" PRIx64, sessionId,
+       hubId);
+  std::shared_ptr<HostHub> hub = mManager.getHostHub(hubId);
+  if (!hub) {
+    LOGW("Unable to find host hub");
+    return;
+  }
+  if (auto status = hub->ackSession(sessionId, /*hostAcked=*/false);
+      !status.ok()) {
+    handleSessionFailure(hub, sessionId, status);
     return;
   }
-
-  // Only send a session open complete message to the host hub client if it was
-  // the initiator.
-  if (static_cast<uint16_t>(id) >= MessageHubManager::kHostSessionIdBase)
-    (*statusOrHub)->getCallback()->onEndpointSessionOpenComplete(id);
 }
 
 void ContextHubV4Impl::onEndpointSessionClosed(
-    const ::chre::fbs::EndpointSessionClosedT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
-  int32_t id = 0;
+    const ::chre::fbs::EndpointSessionClosedT &msg) {
+  int64_t hubId = 0;
+  uint16_t sessionId = 0;
   Reason reason = Reason::UNSPECIFIED;
-  LOGD("Closing session id %" PRId32 " for %" PRIu8, id, reason);
-  auto statusOrHub = mManager.checkSessionOpenAndGetHostHub(id);
-  if (!statusOrHub.ok()) {
-    logGetHubFailure(statusOrHub.status(), id);
+  HostProtocolHostV4::decodeEndpointSessionClosed(msg, hubId, sessionId,
+                                                  reason);
+  LOGD("Closing session id %" PRIu16 " for %" PRIu8, sessionId, reason);
+  std::shared_ptr<HostHub> hub = mManager.getHostHub(hubId);
+  if (!hub) {
+    LOGW("Unable to find host hub");
     return;
   }
-  (*statusOrHub)->getCallback()->onCloseEndpointSession(id, reason);
+  hub->closeSession(sessionId, reason).IgnoreError();
 }
 
 void ContextHubV4Impl::onEndpointSessionMessage(
-    const ::chre::fbs::EndpointSessionMessageT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
+    const ::chre::fbs::EndpointSessionMessageT &msg) {
   Message message;
-  int32_t sessionId = 0;
-  auto statusOrHub = mManager.checkSessionOpenAndGetHostHub(sessionId);
-  if (!statusOrHub.ok()) {
-    logGetHubFailure(statusOrHub.status(), sessionId);
-    // TODO(b/378545373): Send a notification back to CHRE.
+  int64_t hubId = 0;
+  uint16_t sessionId = 0;
+  HostProtocolHostV4::decodeEndpointSessionMessage(msg, hubId, sessionId,
+                                                   message);
+  std::shared_ptr<HostHub> hub = mManager.getHostHub(hubId);
+  if (!hub) {
+    LOGW("Unable to find host hub");
     return;
   }
-  (*statusOrHub)->getCallback()->onMessageReceived(sessionId, message);
+  auto status = hub->handleMessage(sessionId, message);
+  if (status.ok()) return;
+  handleSessionFailure(hub, sessionId, status);
 }
 
 void ContextHubV4Impl::onEndpointSessionMessageDeliveryStatus(
-    const ::chre::fbs::EndpointSessionMessageDeliveryStatusT & /*msg*/) {
-  // TODO(b/378545373): Parse flatbuffer message
-  MessageDeliveryStatus status;
-  int32_t sessionId = 0;
-  auto statusOrHub = mManager.checkSessionOpenAndGetHostHub(sessionId);
-  if (!statusOrHub.ok()) {
-    logGetHubFailure(statusOrHub.status(), sessionId);
-    // TODO(b/378545373): Send a notification back to CHRE.
+    const ::chre::fbs::EndpointSessionMessageDeliveryStatusT &msg) {
+  MessageDeliveryStatus deliveryStatus;
+  int64_t hubId = 0;
+  uint16_t sessionId = 0;
+  HostProtocolHostV4::decodeEndpointSessionMessageDeliveryStatus(
+      msg, hubId, sessionId, deliveryStatus);
+  std::shared_ptr<HostHub> hub = mManager.getHostHub(hubId);
+  if (!hub) {
+    LOGW("Unable to find host hub");
     return;
   }
-  // TODO(b/378545373): Handle reliable messages.
-  (*statusOrHub)
-      ->getCallback()
-      ->onMessageDeliveryStatusReceived(sessionId, status);
+  auto status = hub->handleMessageDeliveryStatus(sessionId, deliveryStatus);
+  if (status.ok()) return;
+  handleSessionFailure(hub, sessionId, status);
+}
+
+void ContextHubV4Impl::unlinkDeadHostHub(
+    std::function<pw::Result<int64_t>()> unlinkFn) {
+  std::lock_guard lock(mHostHubOpLock);  // See header documentation.
+  auto statusOrHubId = unlinkFn();
+  if (!statusOrHubId.ok()) return;
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeUnregisterMessageHub(builder, *statusOrHubId);
+  if (!mSendMessageFn(builder)) {
+    LOGE("Failed to send UnregisterMessageHub for hub 0x%" PRIx64,
+         *statusOrHubId);
+  }
 }
 
-void ContextHubV4Impl::onHostHubDown(int64_t /*id*/) {
-  // TODO(b/378545373): Send an UnregisterMessageHub message to CHRE with id.
+void ContextHubV4Impl::handleSessionFailure(const std::shared_ptr<HostHub> &hub,
+                                            uint16_t session,
+                                            pw::Status status) {
+  LOGE("Failed to operate on session %" PRIu16 " on hub 0x%" PRIx64
+       " with %" PRId32,
+       session, hub->id(), status.code());
+  flatbuffers::FlatBufferBuilder builder;
+  HostProtocolHostV4::encodeEndpointSessionClosed(builder, hub->id(), session,
+                                                  Reason::UNSPECIFIED);
+  mSendMessageFn(builder);
+  hub->closeSession(session, Reason::UNSPECIFIED).IgnoreError();
 }
 
 }  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/context_hub_v4_impl.h b/host/hal_generic/common/context_hub_v4_impl.h
index b07dc34d..255d6d4b 100644
--- a/host/hal_generic/common/context_hub_v4_impl.h
+++ b/host/hal_generic/common/context_hub_v4_impl.h
@@ -16,33 +16,47 @@
 
 #pragma once
 
+#include <assert.h>
+
+#include <array>
 #include <functional>
+#include <mutex>
 #include <optional>
 #include <string>
 #include <vector>
 
 #include <aidl/android/hardware/contexthub/BnContextHub.h>
+#include <aidl/android/hardware/contexthub/BnEndpointCommunication.h>
 #include <chre_host/generated/host_messages_generated.h>
+#include <flatbuffers/flatbuffers.h>
 
 #include "message_hub_manager.h"
 
 namespace android::hardware::contexthub::common::implementation {
 
+using ::aidl::android::hardware::contexthub::BnEndpointCommunication;
 using ::aidl::android::hardware::contexthub::EndpointId;
 using ::aidl::android::hardware::contexthub::EndpointInfo;
 using ::aidl::android::hardware::contexthub::HubInfo;
 using ::aidl::android::hardware::contexthub::IEndpointCallback;
+using ::aidl::android::hardware::contexthub::IEndpointCommunication;
 using ::aidl::android::hardware::contexthub::Message;
 using ::aidl::android::hardware::contexthub::MessageDeliveryStatus;
 using ::aidl::android::hardware::contexthub::Reason;
 using ::ndk::ScopedAStatus;
 
+/**
+ * Common parts of the IContextHub V4+ interface which can be shared by
+ * various HAL implementations.
+ */
 class ContextHubV4Impl {
  public:
-  using SendMessageFn = std::function<bool(uint8_t *data, size_t size)>;
+  using SendMessageFn =
+      std::function<bool(const flatbuffers::FlatBufferBuilder &builder)>;
 
   explicit ContextHubV4Impl(SendMessageFn sendMessageFn)
-      : mManager([this](int64_t id) { onHostHubDown(id); }),
+      : mManager(std::bind(&ContextHubV4Impl::unlinkDeadHostHub, this,
+                           std::placeholders::_1)),
         mSendMessageFn(std::move(sendMessageFn)) {}
   ~ContextHubV4Impl() = default;
 
@@ -50,27 +64,32 @@ class ContextHubV4Impl {
    * Initializes the implementation.
    *
    * This should be called once a connection with CHRE has been established.
-   * Requests a dump of embedded hubs and endpoints from CHRE.
+   * Requests a dump of embedded hubs and endpoints from CHRE. Initializes the
+   * CHRE-side host hub proxies.
    */
   void init();
 
-  // ContextHub V4 API implementation.
+  /**
+   * Closes all existing sessions and embedded endpoints.
+   */
+  void onChreDisconnected();
+
+  /**
+   * Sends host state to CHRE.
+   *
+   * This should be called once the connection with CHRE has been restored.
+   */
+  void onChreRestarted();
+
+  // IContextHub (V4+) API implementation.
   ScopedAStatus getHubs(std::vector<HubInfo> *hubs);
   ScopedAStatus getEndpoints(std::vector<EndpointInfo> *endpoints);
-  ScopedAStatus registerEndpoint(const EndpointInfo &endpoint);
-  ScopedAStatus unregisterEndpoint(const EndpointInfo &endpoint);
-  ScopedAStatus registerEndpointCallback(
-      const std::shared_ptr<IEndpointCallback> &callback);
-  ScopedAStatus requestSessionIdRange(int32_t size, std::vector<int32_t> *ids);
-  ScopedAStatus openEndpointSession(
-      int32_t sessionId, const EndpointId &destination,
-      const EndpointId &initiator,
-      const std::optional<std::string> &serviceDescriptor);
-  ScopedAStatus sendMessageToEndpoint(int32_t sessionId, const Message &msg);
-  ScopedAStatus sendMessageDeliveryStatusToEndpoint(
-      int32_t sessionId, const MessageDeliveryStatus &msgStatus);
-  ScopedAStatus closeEndpointSession(int32_t sessionId, Reason reason);
-  ScopedAStatus endpointSessionOpenComplete(int32_t sessionId);
+  ScopedAStatus registerEndpointHub(
+      const std::shared_ptr<IEndpointCallback> &callback,
+      const HubInfo &hubInfo,
+      std::shared_ptr<IEndpointCommunication> *hubInterface);
+
+  // TODO(b/385474431): Add dump().
 
   /**
    * Handles a CHRE message that is part of the V4 implementation.
@@ -87,6 +106,8 @@ class ContextHubV4Impl {
   void onRegisterMessageHub(const ::chre::fbs::RegisterMessageHubT &msg);
   void onUnregisterMessageHub(const ::chre::fbs::UnregisterMessageHubT &msg);
   void onRegisterEndpoint(const ::chre::fbs::RegisterEndpointT &msg);
+  void onAddServiceToEndpoint(const ::chre::fbs::AddServiceToEndpointT &msg);
+  void onEndpointReady(const ::chre::fbs::EndpointReadyT &msg);
   void onUnregisterEndpoint(const ::chre::fbs::UnregisterEndpointT &msg);
   void onOpenEndpointSessionRequest(
       const ::chre::fbs::OpenEndpointSessionRequestT &msg);
@@ -98,10 +119,65 @@ class ContextHubV4Impl {
       const ::chre::fbs::EndpointSessionMessageDeliveryStatusT &msg);
 
   // Callback invoked when a HAL client associated with a host hub goes down.
-  void onHostHubDown(int64_t id);
+  void unlinkDeadHostHub(std::function<pw::Result<int64_t>()> unlinkFn);
+
+  // Log error and close a session.
+  void handleSessionFailure(
+      const std::shared_ptr<MessageHubManager::HostHub> &hub, uint16_t session,
+      pw::Status status);
 
   MessageHubManager mManager;
   SendMessageFn mSendMessageFn;
+
+  // This lock is required to be held around any operation which modifies the
+  // sets of host hubs or endpoints known by mManager and then sends an update
+  // message to CHRE. This ensures that init()/onChreRestarted() are atomic
+  // w.r.t. registerEndpointHub(), unregister(), registerEndpoint() and
+  // unregisterEndpoint(). As init() resets CHRE-side host hub state,
+  // interleaving these operations could e.g. leave an existing host hub
+  // inaccessible from CHRE.
+  std::mutex mHostHubOpLock;
+};
+
+/**
+ * Wrapper for a MessageHubManager::HostHub instance implementing
+ * IEndpointCommunication so that a client can directly make calls on its
+ * associated HostHub.
+ */
+class HostHubInterface : public BnEndpointCommunication {
+ public:
+  explicit HostHubInterface(std::shared_ptr<MessageHubManager::HostHub> hub,
+                            ContextHubV4Impl::SendMessageFn &sendMessageFn,
+                            std::mutex &hostHubOpLock)
+      : mHub(std::move(hub)),
+        mSendMessageFn(sendMessageFn),
+        mHostHubOpLock(hostHubOpLock) {
+    assert(mHub != nullptr);
+  }
+  ~HostHubInterface() = default;
+
+  // Implementation of IEndpointCommunication.
+  ScopedAStatus registerEndpoint(const EndpointInfo &endpoint) override;
+  ScopedAStatus unregisterEndpoint(const EndpointInfo &endpoint) override;
+  ScopedAStatus requestSessionIdRange(int32_t size,
+                                      std::array<int32_t, 2> *ids);
+  ScopedAStatus openEndpointSession(
+      int32_t sessionId, const EndpointId &destination,
+      const EndpointId &initiator,
+      const std::optional<std::string> &serviceDescriptor) override;
+  ScopedAStatus sendMessageToEndpoint(int32_t sessionId,
+                                      const Message &msg) override;
+  ScopedAStatus sendMessageDeliveryStatusToEndpoint(
+      int32_t sessionId, const MessageDeliveryStatus &msgStatus) override;
+  ScopedAStatus closeEndpointSession(int32_t sessionId, Reason reason) override;
+  ScopedAStatus endpointSessionOpenComplete(int32_t sessionId) override;
+  ScopedAStatus unregister() override;
+
+ private:
+  std::shared_ptr<MessageHubManager::HostHub> mHub;
+  // see ContextHubV4Impl::mSendMessageFn.
+  ContextHubV4Impl::SendMessageFn &mSendMessageFn;
+  std::mutex &mHostHubOpLock;  // see ContextHubV4Impl::mHostHubOpLock.
 };
 
 }  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/generic_context_hub_base.h b/host/hal_generic/common/generic_context_hub_base.h
index b7513d51..38ad9efd 100644
--- a/host/hal_generic/common/generic_context_hub_base.h
+++ b/host/hal_generic/common/generic_context_hub_base.h
@@ -332,7 +332,8 @@ class GenericContextHubBase : public IContexthubT,
         [&]() { return mCallbacks->handleTxnResult(transactionId, result); });
   }
 
-  void onContextHubRestarted() override {
+  void onContextHubConnected(bool restart) override {
+    if (!restart) return;
     invokeClientCallback([&]() {
       return mCallbacks->handleHubEvent(AsyncEventType::RESTARTED);
     });
diff --git a/host/hal_generic/common/hal_chre_socket_connection.cc b/host/hal_generic/common/hal_chre_socket_connection.cc
index 1c72bde4..6030d16e 100644
--- a/host/hal_generic/common/hal_chre_socket_connection.cc
+++ b/host/hal_generic/common/hal_chre_socket_connection.cc
@@ -20,6 +20,7 @@
 #include "hal_chre_socket_connection.h"
 
 #include <log/log.h>
+#include <cstddef>
 
 #ifdef CHRE_HAL_SOCKET_METRICS_ENABLED
 #include <chre_atoms_log.h>
@@ -146,7 +147,7 @@ bool HalChreSocketConnection::requestDebugDump() {
   return mClient.sendMessage(builder.GetBufferPointer(), builder.GetSize());
 }
 
-bool HalChreSocketConnection::sendRawMessage(uint8_t *data, size_t size) {
+bool HalChreSocketConnection::sendRawMessage(void *data, size_t size) {
   return mClient.sendMessage(data, size);
 }
 
@@ -179,6 +180,11 @@ bool HalChreSocketConnection::isLoadTransactionPending() {
   return mPendingLoadTransaction.has_value();
 }
 
+void HalChreSocketConnection::setBluetoothSocketCallback(
+    BluetoothSocketOffloadLinkCallback *btSocketCallback) {
+  mSocketCallbacks->setBluetoothSocketCallback(btSocketCallback);
+}
+
 HalChreSocketConnection::SocketCallbacks::SocketCallbacks(
     HalChreSocketConnection &parent, IChreSocketCallback *callback)
     : mParent(parent), mCallback(callback) {}
@@ -191,11 +197,8 @@ void HalChreSocketConnection::SocketCallbacks::onMessageReceived(
 }
 
 void HalChreSocketConnection::SocketCallbacks::onConnected() {
-  ALOGI("Reconnected to CHRE daemon");
-  if (mHaveConnected) {
-    ALOGI("Reconnected to CHRE daemon");
-    mCallback->onContextHubRestarted();
-  }
+  ALOGI("Reconnected to CHRE daemon (restart: %d)", mHaveConnected);
+  mCallback->onContextHubConnected(mHaveConnected);
   mParent.sendDebugConfiguration();
   mHaveConnected = true;
 }
@@ -321,6 +324,16 @@ bool HalChreSocketConnection::SocketCallbacks::handleContextHubV4Message(
   return mCallback->onContextHubV4Message(message);
 }
 
+void HalChreSocketConnection::SocketCallbacks::handleBluetoothSocketMessage(
+    const void *message, size_t length) {
+  mBtSocketCallback->handleMessageFromOffloadStack(message, length);
+}
+
+void HalChreSocketConnection::SocketCallbacks::setBluetoothSocketCallback(
+    BluetoothSocketOffloadLinkCallback *btSocketCallback) {
+  mBtSocketCallback = btSocketCallback;
+}
+
 bool HalChreSocketConnection::isExpectedLoadResponseLocked(
     const ::chre::fbs::LoadNanoappResponseT &response) {
   return mPendingLoadTransaction.has_value() &&
diff --git a/host/hal_generic/common/hal_chre_socket_connection.h b/host/hal_generic/common/hal_chre_socket_connection.h
index a62ced8f..d8d4054f 100644
--- a/host/hal_generic/common/hal_chre_socket_connection.h
+++ b/host/hal_generic/common/hal_chre_socket_connection.h
@@ -17,9 +17,12 @@
 #ifndef ANDROID_HARDWARE_CONTEXTHUB_COMMON_CHRE_SOCKET_H
 #define ANDROID_HARDWARE_CONTEXTHUB_COMMON_CHRE_SOCKET_H
 
+#include <flatbuffers/flatbuffers.h>
 #include <condition_variable>
 #include <mutex>
 
+#include "bluetooth_socket_offload_link.h"
+#include "bluetooth_socket_offload_link_callback.h"
 #include "chre_host/fragmented_load_transaction.h"
 #include "chre_host/host_protocol_host.h"
 #include "chre_host/socket_client.h"
@@ -70,9 +73,11 @@ class IChreSocketCallback {
       const ::chre::fbs::NanoappListResponseT &response) = 0;
 
   /**
-   * Invoked when CHRE restarts.
+   * Invoked on connection to CHRE.
+   *
+   * @param restart true if CHRE restarted since the first connection
    */
-  virtual void onContextHubRestarted() = 0;
+  virtual void onContextHubConnected(bool restart) = 0;
 
   /**
    * Invoked when a data is available as a result of a debug dump request
@@ -103,7 +108,12 @@ class IChreSocketCallback {
 /**
  * A helper class that can be used to connect to the CHRE socket.
  */
-class HalChreSocketConnection {
+class HalChreSocketConnection : public ::aidl::android::hardware::bluetooth::
+                                    socket::impl::BluetoothSocketOffloadLink {
+ private:
+  using BluetoothSocketOffloadLinkCallback = ::aidl::android::hardware::
+      bluetooth::socket::impl::BluetoothSocketOffloadLinkCallback;
+
  public:
   HalChreSocketConnection(IChreSocketCallback *callback);
 
@@ -126,7 +136,7 @@ class HalChreSocketConnection {
   bool sendSettingChangedNotification(::chre::fbs::Setting fbsSetting,
                                       ::chre::fbs::SettingState fbsState);
 
-  bool sendRawMessage(uint8_t *data, size_t size);
+  bool sendRawMessage(void *data, size_t size);
 
   bool onHostEndpointConnected(uint16_t hostEndpointId, uint8_t type,
                                const std::string &package_name,
@@ -143,6 +153,18 @@ class HalChreSocketConnection {
    */
   bool isLoadTransactionPending();
 
+  // Implementation of the BluetoothSocketOffloadLink interface:
+  bool initOffloadLink() {
+    return true;
+  }
+
+  bool sendMessageToOffloadStack(void *data, size_t size) override {
+    return sendRawMessage(data, size);
+  }
+
+  void setBluetoothSocketCallback(
+      BluetoothSocketOffloadLinkCallback *btSocketCallback) override;
+
  private:
   class SocketCallbacks : public ::android::chre::SocketClient::ICallbacks,
                           public ::android::chre::IChreMessageHandlers {
@@ -168,10 +190,14 @@ class HalChreSocketConnection {
         const ::chre::fbs::DebugDumpResponseT &response) override;
     bool handleContextHubV4Message(
         const ::chre::fbs::ChreMessageUnion &message) override;
+    void handleBluetoothSocketMessage(const void *message, size_t messageLen);
+    void setBluetoothSocketCallback(
+        BluetoothSocketOffloadLinkCallback *btSocketCallback);
 
    private:
     HalChreSocketConnection &mParent;
     IChreSocketCallback *mCallback = nullptr;
+    BluetoothSocketOffloadLinkCallback *mBtSocketCallback = nullptr;
     bool mHaveConnected = false;
   };
 
diff --git a/host/hal_generic/common/host_protocol_host_v4.cc b/host/hal_generic/common/host_protocol_host_v4.cc
new file mode 100644
index 00000000..c3137150
--- /dev/null
+++ b/host/hal_generic/common/host_protocol_host_v4.cc
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License") {}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "host_protocol_host_v4.h"
+
+#include <chre_host/host_protocol_host.h>
+
+#include "permissions_util.h"
+
+namespace android::hardware::contexthub::common::implementation {
+
+using ::chre::fbs::ChreMessage;
+using ::chre::fbs::EndpointId;
+using ::chre::fbs::EndpointInfo;
+using ::chre::fbs::MessageDeliveryStatus;
+using ::chre::fbs::MessageHub;
+using ::chre::fbs::MessageHubDetails;
+using ::chre::fbs::Reason;
+using ::flatbuffers::FlatBufferBuilder;
+using ::flatbuffers::Offset;
+using ::flatbuffers::Vector;
+
+using AidlContextHubInfo =
+    ::aidl::android::hardware::contexthub::ContextHubInfo;
+using AidlVendorHubInfo = ::aidl::android::hardware::contexthub::VendorHubInfo;
+using AidlErrorCode = ::aidl::android::hardware::contexthub::ErrorCode;
+using AidlRpcFormat = ::aidl::android::hardware::contexthub::Service::RpcFormat;
+
+void HostProtocolHostV4::encodeGetMessageHubsAndEndpointsRequest(
+    FlatBufferBuilder &builder) {
+  auto msg = ::chre::fbs::CreateGetMessageHubsAndEndpointsRequest(builder);
+  finalize(builder, ChreMessage::GetMessageHubsAndEndpointsRequest,
+           msg.Union());
+}
+
+void HostProtocolHostV4::encodeGetMessageHubsAndEndpointsResponse(
+    FlatBufferBuilder &builder, const std::vector<AidlHubInfo> &hubs,
+    const std::vector<AidlEndpointInfo> &endpoints) {
+  std::vector<Offset<MessageHub>> fbsHubs;
+  fbsHubs.reserve(hubs.size());
+  for (const auto &hub : hubs)
+    fbsHubs.push_back(aidlToFbsMessageHub(builder, hub));
+  std::vector<Offset<EndpointInfo>> fbsEndpoints;
+  for (const auto &endpoint : endpoints)
+    fbsEndpoints.push_back(aidlToFbsEndpointInfo(builder, endpoint));
+  auto hubsVector = builder.CreateVector(fbsHubs);
+  auto endpointsVector = builder.CreateVector(fbsEndpoints);
+  auto msg = ::chre::fbs::CreateGetMessageHubsAndEndpointsResponse(
+      builder, hubsVector, endpointsVector);
+  finalize(builder, ChreMessage::GetMessageHubsAndEndpointsResponse,
+           msg.Union());
+}
+
+void HostProtocolHostV4::encodeRegisterMessageHub(FlatBufferBuilder &builder,
+                                                  const AidlHubInfo &info) {
+  auto msg = ::chre::fbs::CreateRegisterMessageHub(
+      builder, aidlToFbsMessageHub(builder, info));
+  finalize(builder, ChreMessage::RegisterMessageHub, msg.Union());
+}
+
+void HostProtocolHostV4::encodeUnregisterMessageHub(FlatBufferBuilder &builder,
+                                                    int64_t id) {
+  auto msg = ::chre::fbs::CreateUnregisterMessageHub(builder, id);
+  finalize(builder, ChreMessage::UnregisterMessageHub, msg.Union());
+}
+
+void HostProtocolHostV4::encodeRegisterEndpoint(FlatBufferBuilder &builder,
+                                                const AidlEndpointInfo &info) {
+  auto msg = ::chre::fbs::CreateRegisterEndpoint(
+      builder, aidlToFbsEndpointInfo(builder, info));
+  finalize(builder, ChreMessage::RegisterEndpoint, msg.Union());
+}
+
+void HostProtocolHostV4::encodeUnregisterEndpoint(FlatBufferBuilder &builder,
+                                                  const AidlEndpointId &id) {
+  auto msg = ::chre::fbs::CreateUnregisterEndpoint(
+      builder, aidlToFbsEndpointId(builder, id));
+  finalize(builder, ChreMessage::UnregisterEndpoint, msg.Union());
+}
+
+void HostProtocolHostV4::encodeOpenEndpointSessionRequest(
+    FlatBufferBuilder &builder, int64_t hostHubId, uint16_t sessionId,
+    const AidlEndpointId &initiator, const AidlEndpointId &destination,
+    const std::optional<std::string> &serviceDescriptor) {
+  Offset<Vector<int8_t>> descriptorVector =
+      serviceDescriptor
+          ? addStringAsByteVector(builder, serviceDescriptor->c_str())
+          : 0;
+  auto msg = ::chre::fbs::CreateOpenEndpointSessionRequest(
+      builder, hostHubId, sessionId, aidlToFbsEndpointId(builder, initiator),
+      aidlToFbsEndpointId(builder, destination), descriptorVector);
+  finalize(builder, ChreMessage::OpenEndpointSessionRequest, msg.Union());
+}
+
+void HostProtocolHostV4::encodeEndpointSessionOpened(FlatBufferBuilder &builder,
+                                                     int64_t hostHubId,
+                                                     uint16_t sessionId) {
+  auto msg =
+      ::chre::fbs::CreateEndpointSessionOpened(builder, hostHubId, sessionId);
+  finalize(builder, ChreMessage::EndpointSessionOpened, msg.Union());
+}
+
+void HostProtocolHostV4::encodeEndpointSessionClosed(FlatBufferBuilder &builder,
+                                                     int64_t hostHubId,
+                                                     uint16_t sessionId,
+                                                     AidlReason reason) {
+  auto msg = ::chre::fbs::CreateEndpointSessionClosed(
+      builder, hostHubId, sessionId, static_cast<Reason>(reason));
+  finalize(builder, ChreMessage::EndpointSessionClosed, msg.Union());
+}
+
+void HostProtocolHostV4::encodeEndpointSessionMessage(
+    FlatBufferBuilder &builder, int64_t hostHubId, uint16_t sessionId,
+    const AidlMessage &message) {
+  auto msg = ::chre::fbs::CreateEndpointSessionMessage(
+      builder, hostHubId, sessionId, message.type,
+      androidToChrePermissions(message.permissions),
+      builder.CreateVector(message.content), message.flags,
+      message.sequenceNumber);
+  finalize(builder, ChreMessage::EndpointSessionMessage, msg.Union());
+}
+
+void HostProtocolHostV4::encodeEndpointSessionMessageDeliveryStatus(
+    FlatBufferBuilder &builder, int64_t hostHubId, uint16_t sessionId,
+    const AidlMessageDeliveryStatus &status) {
+  auto fbsStatus = ::chre::fbs::CreateMessageDeliveryStatus(
+      builder, status.messageSequenceNumber,
+      static_cast<int8_t>(status.errorCode));
+  auto msg = ::chre::fbs::CreateEndpointSessionMessageDeliveryStatus(
+      builder, hostHubId, sessionId, fbsStatus);
+  finalize(builder, ChreMessage::EndpointSessionMessageDeliveryStatus,
+           msg.Union());
+}
+
+namespace {
+
+std::string stringFromBytes(const std::vector<int8_t> &bytes) {
+  auto *cStr = ::android::chre::getStringFromByteVector(bytes);
+  return cStr ? std::string(cStr) : std::string();
+}
+
+}  // namespace
+
+void HostProtocolHostV4::decodeGetMessageHubsAndEndpointsResponse(
+    const ::chre::fbs::GetMessageHubsAndEndpointsResponseT &msg,
+    std::vector<AidlHubInfo> &hubs, std::vector<AidlEndpointInfo> &endpoints) {
+  for (const auto &hub : msg.hubs) hubs.push_back(fbsMessageHubToAidl(*hub));
+  for (const auto &endpoint : msg.endpoints)
+    endpoints.push_back(fbsEndpointInfoToAidl(*endpoint));
+}
+
+void HostProtocolHostV4::decodeRegisterMessageHub(
+    const ::chre::fbs::RegisterMessageHubT &msg, AidlHubInfo &info) {
+  info = fbsMessageHubToAidl(*msg.hub);
+}
+
+void HostProtocolHostV4::decodeUnregisterMessageHub(
+    const ::chre::fbs::UnregisterMessageHubT &msg, int64_t &id) {
+  id = msg.id;
+}
+
+void HostProtocolHostV4::decodeRegisterEndpoint(
+    const ::chre::fbs::RegisterEndpointT &msg, AidlEndpointInfo &info) {
+  info = fbsEndpointInfoToAidl(*msg.endpoint);
+}
+
+void HostProtocolHostV4::decodeAddServiceToEndpoint(
+    const ::chre::fbs::AddServiceToEndpointT &msg, AidlEndpointId &id,
+    AidlService &service) {
+  id = fbsEndpointIdToAidl(*msg.endpoint);
+  service.format = static_cast<AidlRpcFormat>(msg.service->format);
+  service.serviceDescriptor = stringFromBytes(msg.service->descriptor);
+  service.majorVersion = msg.service->major_version;
+  service.minorVersion = msg.service->minor_version;
+}
+
+void HostProtocolHostV4::decodeEndpointReady(
+    const ::chre::fbs::EndpointReadyT &msg, AidlEndpointId &id) {
+  id = fbsEndpointIdToAidl(*msg.endpoint);
+}
+
+void HostProtocolHostV4::decodeUnregisterEndpoint(
+    const ::chre::fbs::UnregisterEndpointT &msg, AidlEndpointId &id) {
+  id = fbsEndpointIdToAidl(*msg.endpoint);
+}
+
+void HostProtocolHostV4::decodeOpenEndpointSessionRequest(
+    const ::chre::fbs::OpenEndpointSessionRequestT &msg, int64_t &hubId,
+    uint16_t &sessionId, AidlEndpointId &hostEndpoint,
+    AidlEndpointId &embeddedEndpoint,
+    std::optional<std::string> &serviceDescriptor) {
+  hubId = msg.host_hub_id;
+  sessionId = msg.session_id;
+  hostEndpoint = fbsEndpointIdToAidl(*msg.toEndpoint);
+  embeddedEndpoint = fbsEndpointIdToAidl(*msg.fromEndpoint);
+  auto *serviceCStr =
+      ::android::chre::getStringFromByteVector(msg.serviceDescriptor);
+  if (serviceCStr) serviceDescriptor = std::string(serviceCStr);
+}
+
+void HostProtocolHostV4::decodeEndpointSessionOpened(
+    const ::chre::fbs::EndpointSessionOpenedT &msg, int64_t &hubId,
+    uint16_t &sessionId) {
+  hubId = msg.host_hub_id;
+  sessionId = msg.session_id;
+}
+
+void HostProtocolHostV4::decodeEndpointSessionClosed(
+    const ::chre::fbs::EndpointSessionClosedT &msg, int64_t &hubId,
+    uint16_t &sessionId, AidlReason &reason) {
+  hubId = msg.host_hub_id;
+  sessionId = msg.session_id;
+  reason = static_cast<AidlReason>(msg.reason);
+}
+
+void HostProtocolHostV4::decodeEndpointSessionMessage(
+    const ::chre::fbs::EndpointSessionMessageT &msg, int64_t &hubId,
+    uint16_t &sessionId, AidlMessage &message) {
+  hubId = msg.host_hub_id;
+  sessionId = msg.session_id;
+  message = {.flags = static_cast<int32_t>(msg.flags),
+             .sequenceNumber = static_cast<int32_t>(msg.sequence_number),
+             .permissions = chreToAndroidPermissions(msg.permissions),
+             .type = static_cast<int32_t>(msg.type),
+             .content = msg.data};
+}
+
+void HostProtocolHostV4::decodeEndpointSessionMessageDeliveryStatus(
+    const ::chre::fbs::EndpointSessionMessageDeliveryStatusT &msg,
+    int64_t &hubId, uint16_t &sessionId, AidlMessageDeliveryStatus &status) {
+  hubId = msg.host_hub_id;
+  sessionId = msg.session_id;
+  status = {.messageSequenceNumber =
+                static_cast<int32_t>(msg.status->message_sequence_number),
+            .errorCode = static_cast<AidlErrorCode>(msg.status->error_code)};
+}
+
+Offset<MessageHub> HostProtocolHostV4::aidlToFbsMessageHub(
+    FlatBufferBuilder &builder, const AidlHubInfo &info) {
+  MessageHubDetails detailsEnum;
+  Offset<void> detailsUnion;
+  switch (info.hubDetails.getTag()) {
+    case AidlHubInfo::HubDetails::Tag::contextHubInfo: {
+      detailsEnum = MessageHubDetails::HubInfoResponse;
+      const auto &contextHub =
+          info.hubDetails.get<AidlHubInfo::HubDetails::Tag::contextHubInfo>();
+      uint32_t chrePlatformVersion =
+          (static_cast<uint32_t>(contextHub.chreApiMajorVersion) << 24) |
+          (static_cast<uint32_t>(contextHub.chreApiMinorVersion) << 16) |
+          static_cast<uint32_t>(contextHub.chrePatchVersion);
+      detailsUnion =
+          ::chre::fbs::CreateHubInfoResponse(
+              builder, addStringAsByteVector(builder, contextHub.name.c_str()),
+              addStringAsByteVector(builder, contextHub.vendor.c_str()),
+              addStringAsByteVector(builder, contextHub.toolchain.c_str()),
+              /*platform_version=*/0, /*toolchain_version=*/0,
+              contextHub.peakMips,
+              /*stopped_power=*/0.0f, /*sleep_power=*/0.0f, /*peak_power=*/0.0f,
+              contextHub.maxSupportedMessageLengthBytes,
+              contextHub.chrePlatformId, chrePlatformVersion,
+              contextHub.supportsReliableMessages)
+              .Union();
+    } break;
+    case AidlHubInfo::HubDetails::Tag::vendorHubInfo: {
+      detailsEnum = MessageHubDetails::VendorHubInfo;
+      const auto &vendorHub =
+          info.hubDetails.get<AidlHubInfo::HubDetails::Tag::vendorHubInfo>();
+      detailsUnion =
+          ::chre::fbs::CreateVendorHubInfo(
+              builder, addStringAsByteVector(builder, vendorHub.name.c_str()),
+              vendorHub.version, /*extended_info=*/0)
+              .Union();
+    } break;
+  }
+  return ::chre::fbs::CreateMessageHub(builder, info.hubId, detailsEnum,
+                                       detailsUnion);
+}
+
+AidlHubInfo HostProtocolHostV4::fbsMessageHubToAidl(
+    const ::chre::fbs::MessageHubT &hub) {
+  AidlHubInfo info{.hubId = hub.id};
+  if (hub.details.type == MessageHubDetails::HubInfoResponse) {
+    const auto &fbsContextHub = *hub.details.AsHubInfoResponse();
+    AidlContextHubInfo contextHub = {
+        .name = stringFromBytes(fbsContextHub.name),
+        .vendor = stringFromBytes(fbsContextHub.vendor),
+        .toolchain = stringFromBytes(fbsContextHub.toolchain),
+        .peakMips = fbsContextHub.peak_mips,
+        .maxSupportedMessageLengthBytes =
+            static_cast<int32_t>(fbsContextHub.max_msg_len),
+        .chrePlatformId = static_cast<int64_t>(fbsContextHub.platform_id),
+        .chreApiMajorVersion = static_cast<int8_t>(
+            (fbsContextHub.chre_platform_version >> 24) & 0xff),
+        .chreApiMinorVersion = static_cast<int8_t>(
+            (fbsContextHub.chre_platform_version >> 16) & 0xff),
+        .chrePatchVersion =
+            static_cast<char16_t>(fbsContextHub.chre_platform_version & 0xffff),
+        .supportsReliableMessages = fbsContextHub.supports_reliable_messages};
+    info.hubDetails = AidlHubInfo::HubDetails(std::move(contextHub));
+  } else {
+    const auto &fbsVendorHub = *hub.details.AsVendorHubInfo();
+    AidlVendorHubInfo vendorHub = {
+        .name = stringFromBytes(fbsVendorHub.name),
+        .version = static_cast<int32_t>(fbsVendorHub.version)};
+    info.hubDetails = AidlHubInfo::HubDetails(std::move(vendorHub));
+  }
+  return info;
+}
+
+Offset<EndpointInfo> HostProtocolHostV4::aidlToFbsEndpointInfo(
+    FlatBufferBuilder &builder, const AidlEndpointInfo &info) {
+  std::vector<Offset<::chre::fbs::Service>> services;
+  for (const auto &service : info.services) {
+    services.push_back(::chre::fbs::CreateService(
+        builder, static_cast<::chre::fbs::RpcFormat>(service.format),
+        addStringAsByteVector(builder, service.serviceDescriptor.c_str()),
+        service.majorVersion, service.minorVersion));
+  }
+  auto servicesVector = builder.CreateVector(services);
+  return ::chre::fbs::CreateEndpointInfo(
+      builder, aidlToFbsEndpointId(builder, info.id),
+      static_cast<::chre::fbs::EndpointType>(info.type),
+      addStringAsByteVector(builder, info.name.c_str()), info.version,
+      androidToChrePermissions(info.requiredPermissions), servicesVector);
+}
+
+AidlEndpointInfo HostProtocolHostV4::fbsEndpointInfoToAidl(
+    const ::chre::fbs::EndpointInfoT &endpoint) {
+  AidlEndpointInfo info = {
+      .id = fbsEndpointIdToAidl(*endpoint.id),
+      .type = static_cast<AidlEndpointInfo::EndpointType>(endpoint.type),
+      .name = stringFromBytes(endpoint.name),
+      .version = static_cast<int32_t>(endpoint.version),
+      .requiredPermissions =
+          chreToAndroidPermissions(endpoint.required_permissions)};
+  for (const auto &service : endpoint.services) {
+    info.services.push_back(
+        {.format = static_cast<AidlRpcFormat>(service->format),
+         .serviceDescriptor = stringFromBytes(service->descriptor),
+         .majorVersion = static_cast<int32_t>(service->major_version),
+         .minorVersion = static_cast<int32_t>(service->minor_version)});
+  }
+  return info;
+}
+
+Offset<EndpointId> HostProtocolHostV4::aidlToFbsEndpointId(
+    FlatBufferBuilder &builder, const AidlEndpointId &id) {
+  return ::chre::fbs::CreateEndpointId(builder, id.hubId, id.id);
+}
+
+AidlEndpointId HostProtocolHostV4::fbsEndpointIdToAidl(
+    const ::chre::fbs::EndpointIdT &endpoint) {
+  return AidlEndpointId{.id = endpoint.id, .hubId = endpoint.hubId};
+}
+
+}  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/host_protocol_host_v4.h b/host/hal_generic/common/host_protocol_host_v4.h
new file mode 100644
index 00000000..a7663182
--- /dev/null
+++ b/host/hal_generic/common/host_protocol_host_v4.h
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+#include <vector>
+
+#include <aidl/android/hardware/contexthub/BnContextHub.h>
+#include <aidl/android/hardware/contexthub/BnEndpointCommunication.h>
+
+#include "chre/platform/shared/host_protocol_common.h"
+#include "chre_host/generated/host_messages_generated.h"
+#include "flatbuffers/flatbuffers.h"
+
+namespace android::hardware::contexthub::common::implementation {
+
+using AidlEndpointId = ::aidl::android::hardware::contexthub::EndpointId;
+using AidlEndpointInfo = ::aidl::android::hardware::contexthub::EndpointInfo;
+using AidlHubInfo = ::aidl::android::hardware::contexthub::HubInfo;
+using AidlMessage = ::aidl::android::hardware::contexthub::Message;
+using AidlMessageDeliveryStatus =
+    ::aidl::android::hardware::contexthub::MessageDeliveryStatus;
+using AidlReason = ::aidl::android::hardware::contexthub::Reason;
+using AidlService = ::aidl::android::hardware::contexthub::Service;
+
+/** Helpers for converting ContextHub V4+ AIDL <-> CHRE flatbuffer messages */
+class HostProtocolHostV4 : public ::chre::HostProtocolCommon {
+ public:
+  /**
+   * Encodes a GetMessageHubsAndEndpointsRequest message
+   *
+   * @param builder The builder used to encode the message
+   */
+  static void encodeGetMessageHubsAndEndpointsRequest(
+      flatbuffers::FlatBufferBuilder &builder);
+
+  /**
+   * Encodes a GetMessageHubsAndEndpointsResponse message
+   *
+   * @param builder The builder used to encode the message
+   * @param hubs The list of known host message hubs
+   * @param endpoints The list of known host endpoints
+   */
+  static void encodeGetMessageHubsAndEndpointsResponse(
+      flatbuffers::FlatBufferBuilder &builder,
+      const std::vector<AidlHubInfo> &hubs,
+      const std::vector<AidlEndpointInfo> &endpoints);
+
+  /**
+   * Encodes a RegisterMessageHub message
+   *
+   * @param builder The builder used to encode the message
+   * @param hub The host message hub being registered
+   */
+  static void encodeRegisterMessageHub(flatbuffers::FlatBufferBuilder &builder,
+                                       const AidlHubInfo &info);
+
+  /**
+   * Encodes a UnregisterMessageHub message
+   *
+   * @param builder The builder used to encode the message
+   * @param id The id of the host message hub being unregistered
+   */
+  static void encodeUnregisterMessageHub(
+      flatbuffers::FlatBufferBuilder &builder, int64_t id);
+
+  /**
+   * Encodes a RegisterEndpoint message
+   *
+   * @param builder The builder used to encode the message
+   * @param info The host endpoint being registered
+   */
+  static void encodeRegisterEndpoint(flatbuffers::FlatBufferBuilder &builder,
+                                     const AidlEndpointInfo &info);
+
+  /**
+   * Encodes a UnregisterEndpoint message
+   *
+   * @param builder The builder used to encode the message
+   * @param id The id of the host endpoint being unregistered
+   */
+  static void encodeUnregisterEndpoint(flatbuffers::FlatBufferBuilder &builder,
+                                       const AidlEndpointId &id);
+
+  /**
+   * Encodes a OpenEndpointSessionRequest message
+   *
+   * @param builder The builder used to encode the message
+   * @param hostHubId The id of the host hub originating the request
+   * @param sessionId The id of the session to be created
+   * @param initiator The id of the host endpoint
+   * @param destination The id of the embedded endpoint
+   * @param serviceDescriptor The descriptor of the service for the session
+   */
+  static void encodeOpenEndpointSessionRequest(
+      flatbuffers::FlatBufferBuilder &builder, int64_t hostHubId,
+      uint16_t sessionId, const AidlEndpointId &initiator,
+      const AidlEndpointId &destination,
+      const std::optional<std::string> &serviceDescriptor);
+
+  /**
+   * Encodes a EndpointSessionOpened message
+   *
+   * @param builder The builder used to encode the message
+   * @param hostHubId The id of the host hub originating the notification
+   * @param sessionId The id of the session that was accepted
+   */
+  static void encodeEndpointSessionOpened(
+      flatbuffers::FlatBufferBuilder &builder, int64_t hostHubId,
+      uint16_t sessionId);
+
+  /**
+   * Encodes a EndpointSessionClosed message
+   *
+   * @param builder The builder used to encode the message
+   * @param hostHubId The id of the host hub originating the notification
+   * @param sessionId The id of the session that was closed
+   * @param reason The reason for the closure
+   */
+  static void encodeEndpointSessionClosed(
+      flatbuffers::FlatBufferBuilder &builder, int64_t hostHubId,
+      uint16_t sessionId, AidlReason reason);
+
+  /**
+   * Encodes a EndpointSessionMessage message
+   *
+   * @param builder The builder used to encode the message
+   * @param hostHubId The id of the host hub originating the message
+   * @param sessionId The id of the session over which the message was sent
+   * @param message The message being sent
+   */
+  static void encodeEndpointSessionMessage(
+      flatbuffers::FlatBufferBuilder &builder, int64_t hostHubId,
+      uint16_t sessionId, const AidlMessage &message);
+
+  /**
+   * Encodes a EndpointSessionMessageDeliveryStatus message
+   *
+   * @param builder The builder used to encode the message
+   * @param hostHubId The id of the host hub originating the notification
+   * @param sessionId The id of the session over which the message was sent
+   * @param status The status of the message delivery
+   */
+  static void encodeEndpointSessionMessageDeliveryStatus(
+      flatbuffers::FlatBufferBuilder &builder, int64_t hostHubId,
+      uint16_t sessionId, const AidlMessageDeliveryStatus &status);
+
+  /**
+   * Decodes a GetMessageHubsAndEndpointsResponse message
+   *
+   * @param msg The message
+   * @param hubs (out) The list of embedded message hubs
+   * @param endpoints (out) The list of embedded endpoints
+   */
+  static void decodeGetMessageHubsAndEndpointsResponse(
+      const ::chre::fbs::GetMessageHubsAndEndpointsResponseT &msg,
+      std::vector<AidlHubInfo> &hubs, std::vector<AidlEndpointInfo> &endpoints);
+
+  /**
+   * Decodes a RegisterMessageHub message
+   *
+   * @param msg The message
+   * @param info (out) The details of the new embedded message hub
+   */
+  static void decodeRegisterMessageHub(
+      const ::chre::fbs::RegisterMessageHubT &msg, AidlHubInfo &info);
+
+  /**
+   * Decodes a UnregisterMessageHub message
+   *
+   * @param msg The message
+   * @param id (out) The id of the unregistered embedded hub
+   */
+  static void decodeUnregisterMessageHub(
+      const ::chre::fbs::UnregisterMessageHubT &msg, int64_t &id);
+
+  /**
+   * Decodes a RegisterEndpoint message
+   *
+   * @param msg The message
+   * @param info (out) The details of the new embedded endpoint
+   */
+  static void decodeRegisterEndpoint(const ::chre::fbs::RegisterEndpointT &msg,
+                                     AidlEndpointInfo &info);
+
+  /**
+   * Decodes a AddServiceToEndpoint message
+   *
+   * @param msg The message
+   * @param info (out) The id of the new embedded endpoint
+   * @param service (out) The service being added
+   */
+  static void decodeAddServiceToEndpoint(
+      const ::chre::fbs::AddServiceToEndpointT &msg, AidlEndpointId &id,
+      AidlService &service);
+
+  /**
+   * Decodes a EndpointReady message
+   *
+   * @param msg The message
+   * @param info (out) The id of the newly ready embedded endpoint
+   */
+  static void decodeEndpointReady(const ::chre::fbs::EndpointReadyT &msg,
+                                  AidlEndpointId &id);
+
+  /**
+   * Decodes a UnregisterEndpoint message
+   *
+   * @param msg The message
+   * @param info (out) The id of the unregistered embedded endpoint
+   */
+  static void decodeUnregisterEndpoint(
+      const ::chre::fbs::UnregisterEndpointT &msg, AidlEndpointId &id);
+
+  /**
+   * Decodes a OpenEndpointSessionRequest message
+   *
+   * @param msg The message
+   * @param hubId (out) The destination host message hub id
+   * @param sessionId (out) The id of the session being requested
+   * @param hostEndpoint (out) The destination host endpoint id
+   * @param embeddedEndpoint (out) The initating embedded endpoint id
+   * @param serviceDescriptor (out) The service requested for the session
+   */
+  static void decodeOpenEndpointSessionRequest(
+      const ::chre::fbs::OpenEndpointSessionRequestT &msg, int64_t &hubId,
+      uint16_t &sessionId, AidlEndpointId &hostEndpoint,
+      AidlEndpointId &embeddedEndpoint,
+      std::optional<std::string> &serviceDescriptor);
+
+  /**
+   * Decodes a EndpointSessionOpened message
+   *
+   * @param msg The message
+   * @param hubId (out) The id of the destination host message hub
+   * @param sessionId (out) The id of the accepted session
+   */
+  static void decodeEndpointSessionOpened(
+      const ::chre::fbs::EndpointSessionOpenedT &msg, int64_t &hubId,
+      uint16_t &sessionId);
+
+  /**
+   * Decodes a EndpointSessionClosed message
+   *
+   * @param msg The message
+   * @param hubId (out) The id of the destination host message hub
+   * @param sessionId (out) The id of the closed session
+   */
+  static void decodeEndpointSessionClosed(
+      const ::chre::fbs::EndpointSessionClosedT &msg, int64_t &hubId,
+      uint16_t &sessionId, AidlReason &reason);
+
+  /**
+   * Decodes a EndpointSessionMessage message
+   *
+   * @param msg The wrapper message
+   * @param hubId (out) The id of the destination host message hub
+   * @param sessionId (out) The id of the session hosting the message
+   * @param message (out) The containined message
+   */
+  static void decodeEndpointSessionMessage(
+      const ::chre::fbs::EndpointSessionMessageT &msg, int64_t &hubId,
+      uint16_t &sessionId, AidlMessage &message);
+
+  /**
+   * Decodes a EndpointSessionMessageDeliveryStatus message
+   *
+   * @param msg The wrapper message
+   * @param hubId (out) The id of the destination host message hub
+   * @param sessionId (out) The id of the session hosting the message
+   * @param status (out) The result of a message sent over sessionId
+   */
+  static void decodeEndpointSessionMessageDeliveryStatus(
+      const ::chre::fbs::EndpointSessionMessageDeliveryStatusT &msg,
+      int64_t &hubId, uint16_t &sessionId, AidlMessageDeliveryStatus &status);
+
+ private:
+  static flatbuffers::Offset<::chre::fbs::MessageHub> aidlToFbsMessageHub(
+      flatbuffers::FlatBufferBuilder &builder, const AidlHubInfo &info);
+
+  static AidlHubInfo fbsMessageHubToAidl(const ::chre::fbs::MessageHubT &hub);
+
+  static flatbuffers::Offset<::chre::fbs::EndpointInfo> aidlToFbsEndpointInfo(
+      flatbuffers::FlatBufferBuilder &builder, const AidlEndpointInfo &info);
+
+  static AidlEndpointInfo fbsEndpointInfoToAidl(
+      const ::chre::fbs::EndpointInfoT &endpoint);
+
+  static flatbuffers::Offset<::chre::fbs::EndpointId> aidlToFbsEndpointId(
+      flatbuffers::FlatBufferBuilder &builder, const AidlEndpointId &id);
+
+  static AidlEndpointId fbsEndpointIdToAidl(
+      const ::chre::fbs::EndpointIdT &endpoint);
+};
+
+}  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/message_hub_manager.cc b/host/hal_generic/common/message_hub_manager.cc
index 6306eca5..6b289f83 100644
--- a/host/hal_generic/common/message_hub_manager.cc
+++ b/host/hal_generic/common/message_hub_manager.cc
@@ -16,6 +16,7 @@
 
 #include "message_hub_manager.h"
 
+#include <inttypes.h>
 #include <unistd.h>
 
 #include <cstdint>
@@ -29,6 +30,7 @@
 #include <vector>
 
 #include <aidl/android/hardware/contexthub/BnContextHub.h>
+#include <android-base/thread_annotations.h>
 
 #include "chre_host/log.h"
 #include "pw_result/result.h"
@@ -37,71 +39,58 @@
 
 namespace android::hardware::contexthub::common::implementation {
 
-using HostHub = MessageHubManager::HostHub;
+using ::aidl::android::hardware::contexthub::Reason;
 
-HostHub::~HostHub() {
-  std::lock_guard lock(mManager.mLock);
-  unlinkCallbackIfNecessaryLocked();
-}
+using HostHub = MessageHubManager::HostHub;
 
-pw::Status HostHub::setCallback(std::shared_ptr<IEndpointCallback> callback) {
-  std::lock_guard lock(mManager.mLock);
-  auto *cookie = new DeathRecipientCookie{&mManager, kPid};
-  if (AIBinder_linkToDeath(callback->asBinder().get(),
-                           mManager.mDeathRecipient.get(),
-                           cookie) != STATUS_OK) {
-    LOGE("Failed to link callback for hub %ld (pid %d) to death recipient", kId,
-         kPid);
+HostHub::HostHub(MessageHubManager &manager,
+                 std::shared_ptr<IEndpointCallback> callback,
+                 const HubInfo &info)
+    : mManager(manager), kInfo(info) {
+  auto *cookie = new DeathRecipientCookie{&mManager, kInfo.hubId};
+  if (!manager.mDeathRecipient->linkCallback(callback, cookie).ok()) {
+    LOGE("Failed to link callback for hub %" PRId64 " to death recipient",
+         kInfo.hubId);
     delete cookie;
-    return pw::Status::Internal();
+    return;
   }
-  unlinkCallbackIfNecessaryLocked();
-  mCallback = std::move(callback);
   mCookie = cookie;
-  return pw::OkStatus();
-}
-
-std::shared_ptr<IEndpointCallback> HostHub::getCallback() const {
-  std::lock_guard lock(mManager.mLock);
-  return mCallback;
+  mCallback = std::move(callback);
 }
 
-pw::Status HostHub::addEndpoint(std::weak_ptr<HostHub> self,
-                                const EndpointInfo &info) {
+pw::Status HostHub::addEndpoint(const EndpointInfo &info) {
   std::lock_guard lock(mManager.mLock);
   PW_TRY(checkValidLocked());
+  if (info.id.hubId != kInfo.hubId) {
+    LOGE("Hub %" PRId64 " registering endpoint for different hub %" PRId64,
+         kInfo.hubId, info.id.hubId);
+    return pw::Status::PermissionDenied();
+  }
   int64_t id = info.id.id;
   if (auto it = mIdToEndpoint.find(id); it != mIdToEndpoint.end()) {
-    LOGE("Endpoint %ld already exists in hub %ld (pid %d)", id, kId, kPid);
+    LOGE("Endpoint %" PRId64 " already exists in hub %" PRId64, id,
+         kInfo.hubId);
     return pw::Status::AlreadyExists();
   }
-  if (kId == kHubIdInvalid) {
-    // If this is the hub's first endpoint, store its hub id and register it
-    // with the manager.
-    if (info.id.hubId == kContextHubServiceHubId &&
-        AIBinder_getCallingUid() != kSystemServerUid) {
-      LOGW(
-          "Non-systemserver client (pid %d) trying to register as "
-          "ContextHubService",
-          kPid);
-      return pw::Status::InvalidArgument();
-    }
-    kId = info.id.hubId;
-    mManager.mIdToHostHub.insert({kId, self});
-  }
-  mIdToEndpoint.insert({id, std::make_unique<EndpointInfo>(info)});
+  mIdToEndpoint.insert({id, info});
   return pw::OkStatus();
 }
 
-pw::Status HostHub::removeEndpoint(const EndpointId &id) {
+pw::Result<std::vector<uint16_t>> HostHub::removeEndpoint(
+    const EndpointId &id) {
   std::lock_guard lock(mManager.mLock);
   PW_TRY(checkValidLocked());
   if (auto it = mIdToEndpoint.find(id.id); it != mIdToEndpoint.end()) {
+    std::vector<uint16_t> sessions;
+    for (const auto &[sessionId, session] : mIdToSession) {
+      if (session.mHostEndpoint == id) sessions.push_back(sessionId);
+    }
+    for (auto sessionId : sessions) mIdToSession.erase(sessionId);
     mIdToEndpoint.erase(it);
-    return pw::OkStatus();
+    return sessions;
   }
-  LOGE("Client (hub %ld, pid %d) tried to remove unknown endpoint %ld", kId,
-       kPid, id.id);
+  LOGE("Hub %" PRId64 " tried to remove unknown endpoint %" PRId64, kInfo.hubId,
+       id.id);
   return pw::Status::NotFound();
 }
 
@@ -110,12 +99,13 @@ pw::Result<std::pair<uint16_t, uint16_t>> HostHub::reserveSessionIdRange(
   std::lock_guard lock(mManager.mLock);
   PW_TRY(checkValidLocked());
   if (!size || size > kSessionIdMaxRange) {
-    LOGE("Client (hub %ld, pid %d) tried to allocate %hu session ids", kId,
-         kPid, size);
+    LOGE("Hub %" PRId64 " tried to allocate %" PRIu16 " session ids",
+         kInfo.hubId, size);
     return pw::Status::InvalidArgument();
   }
-  if (USHRT_MAX - mManager.mNextSessionId + 1 < size) {
-    LOGW("Could not allocate %hu session ids, ids exhausted", size);
+  if (mManager.mNextSessionId < kHostSessionIdBase ||
+      USHRT_MAX - mManager.mNextSessionId + 1 < size) {
+    LOGW("Could not allocate %" PRIu16 " session ids, ids exhausted", size);
     return pw::Status::ResourceExhausted();
   }
   mSessionIdRanges.push_back(
@@ -124,135 +114,193 @@ pw::Result<std::pair<uint16_t, uint16_t>> HostHub::reserveSessionIdRange(
   return mSessionIdRanges.back();
 }
 
-pw::Result<std::shared_ptr<HostHub>> HostHub::openSession(
-    std::weak_ptr<HostHub> self, const EndpointId &localId,
-    const EndpointId &remoteId, uint16_t sessionId) {
+pw::Status HostHub::openSession(const EndpointId &hostEndpoint,
+                                const EndpointId &embeddedEndpoint,
+                                uint16_t sessionId,
+                                std::optional<std::string> serviceDescriptor,
+                                bool hostInitiated) {
   std::lock_guard lock(mManager.mLock);
   PW_TRY(checkValidLocked());
 
   // Lookup the endpoints.
-  PW_TRY_ASSIGN(std::shared_ptr<EndpointInfo> local,
-                getEndpointLocked(localId));
-  PW_TRY_ASSIGN(std::shared_ptr<EndpointInfo> remote,
-                mManager.getEmbeddedEndpointLocked(remoteId));
+  PW_TRY(endpointExistsLocked(
+      hostEndpoint, hostInitiated ? std::nullopt : serviceDescriptor));
+  PW_TRY(mManager.embeddedEndpointExistsLocked(
+      embeddedEndpoint, hostInitiated ? serviceDescriptor : std::nullopt));
 
   // Validate the session id.
-  bool hostInitiated = AIBinder_isHandlingTransaction();
   if (hostInitiated) {
     if (!sessionIdInRangeLocked(sessionId)) {
-      LOGE("Session id %hu out of range for hub %ld", sessionId, kId);
+      LOGE("Session id %" PRIu16 " out of range for hub %" PRId64, sessionId,
+           kInfo.hubId);
       return pw::Status::OutOfRange();
     }
   } else if (sessionId >= kHostSessionIdBase) {
-    LOGE(
-        "Remote endpoint (%ld, %ld) attempting to start session with "
-        "invalid id %hu",
-        remoteId.hubId, remoteId.id, sessionId);
+    LOGE("Remote endpoint (%" PRId64 ", %" PRId64
+         ") attempting to start "
+         "session with invalid id %" PRIu16,
+         embeddedEndpoint.hubId, embeddedEndpoint.id, sessionId);
     return pw::Status::InvalidArgument();
   }
 
   // Prune a stale session with this id if present.
-  std::shared_ptr<HostHub> prunedHostHub;
-  if (auto it = mManager.mIdToSession.find(sessionId);
-      it != mManager.mIdToSession.end()) {
-    SessionStrongRef session(it->second);
-    if (session) {
-      // If the session is in a valid state, prune it if it was not host
-      // initiated and is pending a final ack from message router.
-      if (!hostInitiated && !session.pendingDestination &&
-          session.pendingMessageRouter) {
-        prunedHostHub = std::move(session.hub);
-      } else if (hostInitiated && session.local->id == localId) {
-        LOGE("Hub %ld trying to override its own session %hu", kId, sessionId);
-        return pw::Status::InvalidArgument();
-      } else {
-        LOGE("(host? %d) trying to override session id %hu, hub %ld",
-             hostInitiated, sessionId, kId);
-        return pw::Status::AlreadyExists();
-      }
+  if (auto it = mIdToSession.find(sessionId); it != mIdToSession.end()) {
+    Session &session = it->second;
+    // If the session is in a valid state, prune it if it was not host
+    // initiated and is pending a final ack from message router.
+    if (!hostInitiated && !session.mPendingDestination &&
+        session.mPendingMessageRouter) {
+      mCallback->onCloseEndpointSession(sessionId, Reason::UNSPECIFIED);
+      LOGD("Pruned session %" PRIu16, sessionId);
+    } else if (hostInitiated && session.mHostEndpoint == hostEndpoint) {
+      LOGE("Hub %" PRId64 " trying to override its own session %" PRIu16,
+           kInfo.hubId, sessionId);
+      return pw::Status::InvalidArgument();
+    } else {
+      LOGE("(host? %" PRId32 ") trying to override session id %" PRIu16
+           ", hub %" PRId64,
+           hostInitiated, sessionId, kInfo.hubId);
+      return pw::Status::AlreadyExists();
     }
-    mManager.mIdToSession.erase(it);
+    mIdToSession.erase(it);
   }
 
   // Create and map the new session.
-  mManager.mIdToSession.emplace(
+  mIdToSession.emplace(
       std::piecewise_construct, std::forward_as_tuple(sessionId),
-      std::forward_as_tuple(self, local, remote, hostInitiated));
-  return prunedHostHub;
+      std::forward_as_tuple(hostEndpoint, embeddedEndpoint, hostInitiated));
+
+  // Pass a request from a embedded endpoint to the host endpoint.
+  if (!hostInitiated) {
+    mCallback->onEndpointSessionOpenRequest(sessionId, hostEndpoint,
+                                            embeddedEndpoint,
+                                            std::move(serviceDescriptor));
+  }
+  return pw::OkStatus();
 }
 
-pw::Status HostHub::closeSession(uint16_t id) {
+pw::Status HostHub::closeSession(uint16_t id, std::optional<Reason> reason) {
   std::lock_guard lock(mManager.mLock);
   PW_TRY(checkValidLocked());
-  auto it = mManager.mIdToSession.find(id);
-  if (it == mManager.mIdToSession.end()) {
-    LOGE("Closing unopened session %hu", id);
+  auto it = mIdToSession.find(id);
+  if (it == mIdToSession.end()) {
+    LOGE("Closing unopened session %" PRIu16, id);
     return pw::Status::NotFound();
   }
-  SessionStrongRef session(it->second);
-  if (session && session.hub->kPid != kPid) {
-    LOGE("Trying to close session %hu for client %d from client %d (hub %ld)",
-         id, session.hub->kPid, kPid, kId);
-    return pw::Status::PermissionDenied();
-  }
-  mManager.mIdToSession.erase(it);
+  mIdToSession.erase(it);
+  if (reason) mCallback->onCloseEndpointSession(id, *reason);
   return pw::OkStatus();
 }
 
-pw::Status HostHub::ackSession(uint16_t id) {
-  return mManager.ackSessionAndGetHostHub(id).status();
+pw::Status HostHub::checkSessionOpen(uint16_t id) {
+  std::lock_guard lock(mManager.mLock);
+  PW_TRY(checkValidLocked());
+  return checkSessionOpenLocked(id);
 }
 
-pw::Status HostHub::checkSessionOpen(uint16_t id) {
-  return mManager.checkSessionOpenAndGetHostHub(id).status();
+pw::Status HostHub::ackSession(uint16_t id, bool hostAcked) {
+  std::lock_guard lock(mManager.mLock);
+  PW_TRY(checkValidLocked());
+  PW_TRY_ASSIGN(Session * session, getSessionLocked(id));
+  bool isHostSession = id >= kHostSessionIdBase;
+  if (session->mPendingDestination) {
+    if (isHostSession == hostAcked) {
+      LOGE("Session %" PRIu16 " must be acked by other side (host? %" PRId32
+           ")",
+           id, !hostAcked);
+      return pw::Status::PermissionDenied();
+    }
+    session->mPendingDestination = false;
+    // Notify the initiator that the session has been opened.
+    if (isHostSession) mCallback->onEndpointSessionOpenComplete(id);
+  } else if (session->mPendingMessageRouter) {
+    if (hostAcked) {
+      LOGE("Message router must ack session %" PRIu16, id);
+      return pw::Status::PermissionDenied();
+    }
+    session->mPendingMessageRouter = false;
+  } else {
+    LOGE("Received unexpected ack on session %" PRIu16 ", host: %" PRId32, id,
+         hostAcked);
+  }
+  return pw::OkStatus();
 }
 
-int64_t HostHub::id() const {
+pw::Status HostHub::handleMessage(uint16_t sessionId, const Message &message) {
   std::lock_guard lock(mManager.mLock);
-  return kId;
+  PW_TRY(checkValidLocked());
+  PW_TRY(checkSessionOpenLocked(sessionId));
+  mCallback->onMessageReceived(sessionId, message);
+  return pw::OkStatus();
 }
 
-int64_t MessageHubManager::HostHub::unlinkFromManager() {
+pw::Status HostHub::handleMessageDeliveryStatus(
+    uint16_t sessionId, const MessageDeliveryStatus &status) {
   std::lock_guard lock(mManager.mLock);
-  // TODO(b/378545373): Release the session id range.
-  if (kId != kHubIdInvalid) mManager.mIdToHostHub.erase(kId);
-  mManager.mPidToHostHub.erase(kPid);
-  mUnlinked = true;
-  return kId;
+  PW_TRY(checkValidLocked());
+  PW_TRY(checkSessionOpenLocked(sessionId));
+  mCallback->onMessageDeliveryStatusReceived(sessionId, status);
+  return pw::OkStatus();
 }
 
-void HostHub::unlinkCallbackIfNecessaryLocked() {
-  if (!mCallback) return;
-  if (AIBinder_unlinkToDeath(mCallback->asBinder().get(),
-                             mManager.mDeathRecipient.get(),
-                             mCookie) != STATUS_OK) {
-    LOGW("Failed to unlink client (pid: %d, hub id: %ld)", kPid, kId);
+pw::Status HostHub::unregister() {
+  // If unlinkFromManager() fails, onClientDeath() was already called for this
+  // and we do not need to unlink the death recipient.
+  PW_TRY(unlinkFromManager());
+  if (!mManager.mDeathRecipient->unlinkCallback(mCallback, mCookie).ok()) {
+    LOGW("Process hosting hub %" PRId64 " died simultaneously with unregister",
+         kInfo.hubId);
   }
-  mCallback.reset();
-  mCookie = nullptr;
+  return pw::OkStatus();
+}
+
+std::vector<EndpointInfo> HostHub::getEndpoints() const {
+  std::vector<EndpointInfo> endpoints;
+  std::lock_guard lock(mManager.mLock);
+  for (const auto &[id, endpoint] : mIdToEndpoint)
+    endpoints.push_back(endpoint);
+  return endpoints;
+}
+
+pw::Status HostHub::unlinkFromManager() {
+  std::lock_guard lock(mManager.mLock);
+  PW_TRY(checkValidLocked());  // returns early if already unlinked
+  // TODO(b/378545373): Release the session id range.
+  mManager.mIdToHostHub.erase(kInfo.hubId);
+  mUnlinked = true;
+  return pw::OkStatus();
 }
 
 pw::Status HostHub::checkValidLocked() {
   if (!mCallback) {
-    ALOGW("Endpoint APIs invoked by client %d before callback registered",
-          kPid);
+    ALOGE("APIs invoked on hub %" PRId64
+          " which was not successfully registered.",
+          kInfo.hubId);
     return pw::Status::FailedPrecondition();
   } else if (mUnlinked) {
-    ALOGW("Client %d went down mid-operation", kPid);
+    ALOGW("Hub %" PRId64 " went down mid-operation", kInfo.hubId);
     return pw::Status::Aborted();
   }
   return pw::OkStatus();
 }
 
-pw::Result<std::shared_ptr<EndpointInfo>> HostHub::getEndpointLocked(
-    const EndpointId &id) {
-  if (id.hubId != kId) {
-    LOGE("Rejecting lookup on unowned endpoint (%ld, %ld) from hub %ld",
-         id.hubId, id.id, kId);
+pw::Status HostHub::endpointExistsLocked(
+    const EndpointId &id, std::optional<std::string> serviceDescriptor) {
+  if (id.hubId != kInfo.hubId) {
+    LOGE("Rejecting lookup on unowned endpoint (%" PRId64 ", %" PRId64
+         ") from hub %" PRId64,
+         id.hubId, id.id, kInfo.hubId);
     return pw::Status::InvalidArgument();
   }
-  if (auto it = mIdToEndpoint.find(id.id); it != mIdToEndpoint.end())
-    return it->second;
+  if (auto it = mIdToEndpoint.find(id.id); it != mIdToEndpoint.end()) {
+    if (!serviceDescriptor) return pw::OkStatus();
+    for (const auto &service : it->second.services) {
+      if (service.serviceDescriptor == *serviceDescriptor)
+        return pw::OkStatus();
+    }
+    LOGW("Endpoint (%" PRId64 ", %" PRId64 ") doesn't have service %s",
+         id.hubId, id.id, serviceDescriptor->c_str());
+  }
   return pw::Status::NotFound();
 }
 
@@ -263,129 +311,120 @@ bool HostHub::sessionIdInRangeLocked(uint16_t id) {
   return false;
 }
 
-MessageHubManager::MessageHubManager(HostHubDownCb cb)
-    : mHostHubDownCb(std::move(cb)) {
-  mDeathRecipient = ndk::ScopedAIBinder_DeathRecipient(
-      AIBinder_DeathRecipient_new(onClientDeath));
-  AIBinder_DeathRecipient_setOnUnlinked(
-      mDeathRecipient.get(), /*onUnlinked= */ [](void *cookie) {
-        LOGI("Callback is unlinked. Releasing the death recipient cookie.");
-        delete static_cast<HostHub::DeathRecipientCookie *>(cookie);
-      });
-}
-
-std::shared_ptr<HostHub> MessageHubManager::getHostHubByPid(pid_t pid) {
-  std::lock_guard lock(mLock);
-  if (auto it = mPidToHostHub.find(pid); it != mPidToHostHub.end())
-    return it->second;
-  std::shared_ptr<HostHub> hub(new HostHub(*this, pid));
-  mPidToHostHub.insert({pid, hub});
-  return hub;
+pw::Status HostHub::checkSessionOpenLocked(uint16_t id) {
+  PW_TRY_ASSIGN(Session * session, getSessionLocked(id));
+  if (!session->mPendingDestination && !session->mPendingMessageRouter)
+    return pw::OkStatus();
+  LOGE("Session %" PRIu16 " is pending", id);
+  return pw::Status::FailedPrecondition();
 }
 
-std::shared_ptr<HostHub> MessageHubManager::getHostHubByEndpointId(
-    const EndpointId &id) {
-  std::lock_guard lock(mLock);
-  if (auto it = mIdToHostHub.find(id.hubId); it != mIdToHostHub.end())
-    return it->second.lock();
-  return {};
+pw::Result<HostHub::Session *> HostHub::getSessionLocked(uint16_t id) {
+  auto sessionIt = mIdToSession.find(id);
+  if (sessionIt == mIdToSession.end()) {
+    LOGE("Did not find expected session %" PRIu16 " in hub %" PRId64, id,
+         kInfo.hubId);
+    return pw::Status::NotFound();
+  }
+  return &sessionIt->second;
 }
 
-pw::Result<std::shared_ptr<HostHub>>
-MessageHubManager::checkSessionOpenAndGetHostHub(uint16_t id) {
-  std::lock_guard lock(mLock);
-  PW_TRY_ASSIGN(SessionStrongRef session, checkSessionLocked(id));
-  if (AIBinder_getCallingPid() != session.hub->kPid) {
-    LOGE("Trying to check unowned session %hu", id);
+pw::Result<std::shared_ptr<HostHub>> MessageHubManager::createHostHub(
+    std::shared_ptr<IEndpointCallback> callback, const HubInfo &info, uid_t uid,
+    pid_t pid) {
+  if (info.hubId == kContextHubServiceHubId && uid != kSystemServerUid) {
+    LOGE("(pid %" PRId32 ", uid %" PRId32
+         ") attempting to impersonate ContextHubService",
+         pid, uid);
     return pw::Status::PermissionDenied();
   }
-  if (!session.pendingDestination && !session.pendingMessageRouter)
-    return std::move(session.hub);
-  LOGE("Session %hu is pending", id);
-  return pw::Status::FailedPrecondition();
+  std::lock_guard lock(mLock);
+  if (mIdToHostHub.count(info.hubId)) return pw::Status::AlreadyExists();
+  std::shared_ptr<HostHub> hub(new HostHub(*this, std::move(callback), info));
+  if (!hub->mCallback) return pw::Status::Internal();
+  mIdToHostHub.insert({info.hubId, hub});
+  LOGI("Registered host hub %" PRId64, info.hubId);
+  return hub;
 }
 
-pw::Result<std::shared_ptr<HostHub>> MessageHubManager::ackSessionAndGetHostHub(
-    uint16_t id) {
+std::shared_ptr<HostHub> MessageHubManager::getHostHub(int64_t id) {
   std::lock_guard lock(mLock);
-  PW_TRY_ASSIGN(SessionStrongRef session, checkSessionLocked(id));
-  bool isBinderCall = AIBinder_isHandlingTransaction();
-  bool isHostSession = id >= kHostSessionIdBase;
-  if (isBinderCall && AIBinder_getCallingPid() != session.hub->kPid) {
-    LOGE("Trying to ack unowned session %hu", id);
-    return pw::Status::PermissionDenied();
-  } else if (session.pendingDestination) {
-    if (isHostSession == isBinderCall) {
-      LOGE("Session %hu must be acked by other side (host? %d)", id,
-           !isBinderCall);
-      return pw::Status::PermissionDenied();
-    }
-    session.pendingDestination = false;
-  } else if (session.pendingMessageRouter) {
-    if (isBinderCall) {
-      LOGE("Message router must ack session %hu", id);
-      return pw::Status::PermissionDenied();
-    }
-    session.pendingMessageRouter = false;
-  } else {
-    LOGE("Received unexpected ack on session %hu, host: %d", id, isBinderCall);
-  }
-  return std::move(session.hub);
+  if (auto it = mIdToHostHub.find(id); it != mIdToHostHub.end())
+    return it->second;
+  return {};
 }
 
 void MessageHubManager::forEachHostHub(std::function<void(HostHub &hub)> fn) {
   std::list<std::shared_ptr<HostHub>> hubs;
   {
     std::lock_guard lock(mLock);
-    for (auto &[pid, hub] : mPidToHostHub) hubs.push_back(hub);
+    for (auto &[id, hub] : mIdToHostHub) hubs.push_back(hub);
   }
   for (auto &hub : hubs) fn(*hub);
 }
 
-pw::Result<MessageHubManager::SessionStrongRef>
-MessageHubManager::checkSessionLocked(uint16_t id) {
-  auto sessionIt = mIdToSession.find(id);
-  if (sessionIt == mIdToSession.end()) {
-    LOGE("Did not find expected session %hu", id);
-    return pw::Status::NotFound();
-  }
-  SessionStrongRef session(sessionIt->second);
-  if (!session) {
-    LOGD(
-        "Pruning session %hu due to one or more of host hub, host endpoint, "
-        "or embedded endpoint going down.",
-        id);
-    mIdToSession.erase(sessionIt);
-    return pw::Status::Unavailable();
-  }
-  return std::move(session);
+void MessageHubManager::initEmbeddedState() {
+  std::lock_guard lock(mLock);
+  mIdToEmbeddedHub.clear();
+  mIdToEmbeddedHubReady = true;
 }
 
-void MessageHubManager::initEmbeddedHubsAndEndpoints(
-    const std::vector<HubInfo> &hubs,
-    const std::vector<EndpointInfo> &endpoints) {
+void MessageHubManager::clearEmbeddedState() {
   std::lock_guard lock(mLock);
+  mIdToEmbeddedHubReady = false;
+
+  // Clear embedded hub state, caching the list of now removed endpoints.
+  std::vector<EndpointId> endpoints;
+  for (const auto &[hubId, hub] : mIdToEmbeddedHub) {
+    for (const auto &[endpointId, endpoint] : hub.idToEndpoint)
+      if (endpoint.second) endpoints.push_back(endpoint.first.id);
+  }
   mIdToEmbeddedHub.clear();
-  for (const auto &hub : hubs) mIdToEmbeddedHub[hub.hubId].info = hub;
-  for (const auto &endpoint : endpoints) addEmbeddedEndpointLocked(endpoint);
+
+  // For each host hub, close all sessions and send all removed endpoints.
+  for (const auto &[hubId, hub] : mIdToHostHub) {
+    ::android::base::ScopedLockAssertion lockAssertion(hub->mManager.mLock);
+    for (const auto &[sessionId, session] : hub->mIdToSession)
+      hub->mCallback->onCloseEndpointSession(sessionId, Reason::HUB_RESET);
+    hub->mCallback->onEndpointStopped(endpoints, Reason::HUB_RESET);
+  }
 }
 
 void MessageHubManager::addEmbeddedHub(const HubInfo &hub) {
   std::lock_guard lock(mLock);
+  if (!mIdToEmbeddedHubReady) {
+    LOGW("Skipping embedded hub registration before initEmbeddedState()");
+    return;
+  }
   if (mIdToEmbeddedHub.count(hub.hubId)) return;
   mIdToEmbeddedHub[hub.hubId].info = hub;
 }
 
-std::vector<EndpointId> MessageHubManager::removeEmbeddedHub(int64_t id) {
+void MessageHubManager::removeEmbeddedHub(int64_t id) {
   std::lock_guard lock(mLock);
+
+  // Get the list of endpoints being removed and remove the hub.
   std::vector<EndpointId> endpoints;
   auto it = mIdToEmbeddedHub.find(id);
-  if (it != mIdToEmbeddedHub.end()) {
-    for (const auto &[endpointId, info] : it->second.idToEndpoint)
-      endpoints.push_back({.id = endpointId, .hubId = id});
-    mIdToEmbeddedHub.erase(it);
+  if (it == mIdToEmbeddedHub.end()) return;
+  for (const auto &[endpointId, info] : it->second.idToEndpoint)
+    if (info.second) endpoints.push_back(info.first.id);
+  mIdToEmbeddedHub.erase(it);
+
+  // For each host hub, determine which sessions if any are now closed and send
+  // notifications as appropriate. Also send the list of removed endpoints.
+  for (auto &[hostHubId, hub] : mIdToHostHub) {
+    ::android::base::ScopedLockAssertion lockAssertion(hub->mManager.mLock);
+    std::vector<uint16_t> closedSessions;
+    for (const auto &[sessionId, session] : hub->mIdToSession) {
+      if (session.mEmbeddedEndpoint.hubId == id) {
+        hub->mCallback->onCloseEndpointSession(sessionId, Reason::HUB_RESET);
+        closedSessions.push_back(sessionId);
+      }
+    }
+    for (auto session : closedSessions) hub->mIdToSession.erase(session);
+    hub->mCallback->onEndpointStopped(endpoints, Reason::HUB_RESET);
   }
-  return endpoints;
 }
 
 std::vector<HubInfo> MessageHubManager::getEmbeddedHubs() const {
@@ -397,47 +436,157 @@ std::vector<HubInfo> MessageHubManager::getEmbeddedHubs() const {
 
 void MessageHubManager::addEmbeddedEndpoint(const EndpointInfo &endpoint) {
   std::lock_guard lock(mLock);
+  if (!mIdToEmbeddedHubReady) {
+    LOGW("Skipping embedded endpoint registration before initEmbeddedState()");
+    return;
+  }
   addEmbeddedEndpointLocked(endpoint);
 }
 
+void MessageHubManager::addEmbeddedEndpointService(const EndpointId &endpoint,
+                                                   const Service &service) {
+  std::lock_guard lock(mLock);
+  if (!mIdToEmbeddedHubReady) {
+    LOGW("Skipping embedded endpoint registration before initEmbeddedState()");
+    return;
+  }
+  auto statusOrEndpoint = lookupEmbeddedEndpointLocked(endpoint);
+  if (!statusOrEndpoint.ok()) return;
+  if ((*statusOrEndpoint)->second) {
+    LOGE("Adding service to embedded endpoint after ready");
+    return;
+  }
+  (*statusOrEndpoint)->first.services.push_back(service);
+}
+
+void MessageHubManager::setEmbeddedEndpointReady(const EndpointId &id) {
+  std::lock_guard lock(mLock);
+  if (!mIdToEmbeddedHubReady) {
+    LOGW("Skipping embedded endpoint registration before initEmbeddedState()");
+    return;
+  }
+  auto statusOrEndpoint = lookupEmbeddedEndpointLocked(id);
+  if (!statusOrEndpoint.ok() || (*statusOrEndpoint)->second) return;
+  (*statusOrEndpoint)->second = true;
+  for (auto &[hostHubId, hub] : mIdToHostHub) {
+    ::android::base::ScopedLockAssertion lockAssertion(hub->mManager.mLock);
+    hub->mCallback->onEndpointStarted({(*statusOrEndpoint)->first});
+  }
+}
+
 std::vector<EndpointInfo> MessageHubManager::getEmbeddedEndpoints() const {
   std::lock_guard lock(mLock);
   std::vector<EndpointInfo> endpoints;
   for (const auto &[id, hub] : mIdToEmbeddedHub) {
     for (const auto &[endptId, endptInfo] : hub.idToEndpoint)
-      endpoints.push_back(*endptInfo);
+      if (endptInfo.second) endpoints.push_back(endptInfo.first);
   }
   return endpoints;
 }
 
+void MessageHubManager::removeEmbeddedEndpoint(const EndpointId &id) {
+  std::lock_guard lock(mLock);
+  auto hubIt = mIdToEmbeddedHub.find(id.hubId);
+  if (hubIt == mIdToEmbeddedHub.end()) return;
+  if (!hubIt->second.idToEndpoint.erase(id.id)) return;
+
+  // For each host hub, determine which sessions if any are now closed and send
+  // notifications as appropriate. Also send the removed endpoint notification.
+  for (auto &[hostHubId, hub] : mIdToHostHub) {
+    ::android::base::ScopedLockAssertion lockAssertion(hub->mManager.mLock);
+    std::vector<uint16_t> closedSessions;
+    for (const auto &[sessionId, session] : hub->mIdToSession) {
+      if (session.mEmbeddedEndpoint == id) {
+        hub->mCallback->onCloseEndpointSession(sessionId,
+                                               Reason::ENDPOINT_GONE);
+        closedSessions.push_back(sessionId);
+      }
+    }
+    for (auto session : closedSessions) hub->mIdToSession.erase(session);
+    hub->mCallback->onEndpointStopped({id}, Reason::ENDPOINT_GONE);
+  }
+}
+
+MessageHubManager::RealDeathRecipient::RealDeathRecipient() {
+  mDeathRecipient = ndk::ScopedAIBinder_DeathRecipient(
+      AIBinder_DeathRecipient_new(&MessageHubManager::onClientDeath));
+  AIBinder_DeathRecipient_setOnUnlinked(
+      mDeathRecipient.get(), /*onUnlinked= */ [](void *cookie) {
+        LOGD("Callback is unlinked. Releasing the death recipient cookie.");
+        delete static_cast<HostHub::DeathRecipientCookie *>(cookie);
+      });
+}
+
+pw::Status MessageHubManager::RealDeathRecipient::linkCallback(
+    const std::shared_ptr<IEndpointCallback> &callback,
+    HostHub::DeathRecipientCookie *cookie) {
+  return AIBinder_linkToDeath(callback->asBinder().get(), mDeathRecipient.get(),
+                              cookie) == STATUS_OK
+             ? pw::OkStatus()
+             : pw::Status::Internal();
+}
+
+pw::Status MessageHubManager::RealDeathRecipient::unlinkCallback(
+    const std::shared_ptr<IEndpointCallback> &callback,
+    HostHub::DeathRecipientCookie *cookie) {
+  return AIBinder_unlinkToDeath(callback->asBinder().get(),
+                                mDeathRecipient.get(), cookie) == STATUS_OK
+             ? pw::OkStatus()
+             : pw::Status::NotFound();
+}
+
 void MessageHubManager::onClientDeath(void *cookie) {
   auto *cookieData = reinterpret_cast<HostHub::DeathRecipientCookie *>(cookie);
+  LOGW("Process hosting hub %" PRId64 " died", cookieData->hubId);
   MessageHubManager *manager = cookieData->manager;
-  std::shared_ptr<HostHub> hub = manager->getHostHubByPid(cookieData->pid);
-  LOGW("Hub %ld (pid %d) died", hub->id(), cookieData->pid);
-  manager->mHostHubDownCb(hub->unlinkFromManager());
+  std::shared_ptr<HostHub> hub = manager->getHostHub(cookieData->hubId);
+  // NOTE: if IEndpointCommunication.unregister() was called simultaneously, hub
+  // may be null or unlinkFromManager() may fail.
+  if (hub) {
+    manager->mHostHubDownCb([hubPtr = hub.get()]() -> pw::Result<int64_t> {
+      PW_TRY(hubPtr->unlinkFromManager());
+      return hubPtr->id();
+    });
+  }
 }
 
 void MessageHubManager::addEmbeddedEndpointLocked(
     const EndpointInfo &endpoint) {
   auto it = mIdToEmbeddedHub.find(endpoint.id.hubId);
   if (it == mIdToEmbeddedHub.end()) {
-    LOGW("Could not find hub %ld for endpoint %ld", endpoint.id.hubId,
-         endpoint.id.id);
+    LOGW("Could not find hub %" PRId64 " for endpoint %" PRId64,
+         endpoint.id.hubId, endpoint.id.id);
     return;
   }
-  it->second.idToEndpoint.insert(
-      {endpoint.id.id, std::make_shared<EndpointInfo>(endpoint)});
+  it->second.idToEndpoint.insert({endpoint.id.id, {endpoint, false}});
+}
+
+pw::Status MessageHubManager::embeddedEndpointExistsLocked(
+    const EndpointId &id, std::optional<std::string> serviceDescriptor) {
+  PW_TRY_ASSIGN(const auto *endpoint, lookupEmbeddedEndpointLocked(id));
+  if (!endpoint->second) {
+    LOGW("Accessing remote endpoint (%" PRId64 ", %" PRId64 ") before ready",
+         id.hubId, id.id);
+    return pw::Status::NotFound();
+  }
+  if (!serviceDescriptor) return pw::OkStatus();
+  for (const auto &service : endpoint->first.services) {
+    if (service.serviceDescriptor == *serviceDescriptor) return pw::OkStatus();
+  }
+  LOGW("Endpoint (%" PRId64 ", %" PRId64 ") doesn't have service %s", id.hubId,
+       id.id, serviceDescriptor->c_str());
+  return pw::Status::NotFound();
 }
 
-pw::Result<std::shared_ptr<EndpointInfo>>
-MessageHubManager::getEmbeddedEndpointLocked(const EndpointId &id) {
+pw::Result<std::pair<EndpointInfo, bool> *>
+MessageHubManager::lookupEmbeddedEndpointLocked(const EndpointId &id) {
   auto hubIt = mIdToEmbeddedHub.find(id.hubId);
   if (hubIt != mIdToEmbeddedHub.end()) {
     auto it = hubIt->second.idToEndpoint.find(id.id);
-    if (it != hubIt->second.idToEndpoint.end()) return it->second;
+    if (it != hubIt->second.idToEndpoint.end()) return &(it->second);
   }
-  LOGW("Could not find remote endpoint (%ld, %ld)", id.hubId, id.id);
+  LOGW("Could not find remote endpoint (%" PRId64 ", %" PRId64 ")", id.hubId,
+       id.id);
   return pw::Status::NotFound();
 }
 
diff --git a/host/hal_generic/common/message_hub_manager.h b/host/hal_generic/common/message_hub_manager.h
index 53533754..9e11b0e5 100644
--- a/host/hal_generic/common/message_hub_manager.h
+++ b/host/hal_generic/common/message_hub_manager.h
@@ -28,7 +28,7 @@
 #include <utility>
 #include <vector>
 
-#include <aidl/android/hardware/contexthub/BnContextHub.h>
+#include <aidl/android/hardware/contexthub/IContextHub.h>
 #include <android-base/thread_annotations.h>
 
 #include "pw_result/result.h"
@@ -40,6 +40,10 @@ using ::aidl::android::hardware::contexthub::EndpointId;
 using ::aidl::android::hardware::contexthub::EndpointInfo;
 using ::aidl::android::hardware::contexthub::HubInfo;
 using ::aidl::android::hardware::contexthub::IEndpointCallback;
+using ::aidl::android::hardware::contexthub::Message;
+using ::aidl::android::hardware::contexthub::MessageDeliveryStatus;
+using ::aidl::android::hardware::contexthub::Reason;
+using ::aidl::android::hardware::contexthub::Service;
 
 /**
  * Stores host and embedded MessageHub objects and maintains global mappings.
@@ -52,42 +56,24 @@ class MessageHubManager {
    */
   class HostHub {
    public:
-    ~HostHub();
-
-    /**
-     * Sets the callback for sending endpoint events back to the HAL client
-     *
-     * @param callback The callback provided by the client
-     * @return pw::OkStatus() on success.
-     */
-    pw::Status setCallback(std::shared_ptr<IEndpointCallback> callback)
-        EXCLUDES(mManager.mLock);
-
-    /**
-     * Returns the callback registered in setCallback()
-     *
-     * @return The previously registered callback
-     */
-    std::shared_ptr<IEndpointCallback> getCallback() const
-        EXCLUDES(mManager.mLock);
+    ~HostHub() = default;
 
     /**
      * Adds an endpoint to this message hub
      *
-     * @param self Self-reference for mapping from hub id
      * @param info Description of the endpoint
      * @return pw::OkStatus() on success
      */
-    pw::Status addEndpoint(std::weak_ptr<HostHub> self,
-                           const EndpointInfo &info) EXCLUDES(mManager.mLock);
+    pw::Status addEndpoint(const EndpointInfo &info) EXCLUDES(mManager.mLock);
 
     /**
      * Removes an endpoint from this message hub
      *
      * @param info Id of endpoint to remove
-     * @return pw::OkStatus() on success
+     * @return List of sessions to prune on success
      */
-    pw::Status removeEndpoint(const EndpointId &info) EXCLUDES(mManager.mLock);
+    pw::Result<std::vector<uint16_t>> removeEndpoint(const EndpointId &info)
+        EXCLUDES(mManager.mLock);
 
     /**
      * Reserves a session id range to be used by this message hub
@@ -103,35 +89,34 @@ class MessageHubManager {
      *
      * The session is pending until updated by the destination endpoint.
      *
-     * @param self Self-reference to be stored in session state
-     * @param localId The id of an endpoint hosted by this hub
-     * @param remoteId The id of the remote endpoint
+     * @param hostEndpoint The id of an endpoint hosted by this hub
+     * @param embeddedEndpoint The id of the embedded endpoint
      * @param sessionId The id to be used for this session. Must be in the range
      * allocated to this hub
-     * @return On success, returns a possibly null reference to the HostHub
-     * which hosted an endpoint on a pruned session with the same id. If not
-     * null, the HostHub should be notified that the session has been closed.
+     * @param serviceDescriptor Optional service for the session
+     * @param hostInitiated true if the request came from a host endpoint
+     * @return pw::OkStatus() on success.
      */
-    pw::Result<std::shared_ptr<HostHub>> openSession(
-        std::weak_ptr<HostHub> self, const EndpointId &localId,
-        const EndpointId &remoteId, uint16_t sessionId)
-        EXCLUDES(mManager.mLock);
+    pw::Status openSession(const EndpointId &hostEndpoint,
+                           const EndpointId &embeddedEndpoint,
+                           uint16_t sessionId,
+                           std::optional<std::string> serviceDescriptor,
+                           bool hostInitiated) EXCLUDES(mManager.mLock);
 
     /**
      * Acks a pending session.
      *
      * @param id Session id
-     * @return pw::OkStatus() on success, pw::Status::Unavailable() if the
-     * session is gone due to an endpoint going down.
+     * @param hostAcked true if a host endpoint is acking the session
+     * @return pw::OkStatus() on success
      */
-    pw::Status ackSession(uint16_t id) EXCLUDES(mManager.mLock);
+    pw::Status ackSession(uint16_t id, bool hostAcked) EXCLUDES(mManager.mLock);
 
     /**
      * Checks that a session is open.
      *
      * @param id Session id
-     * @return pw::OkStatus() on success, pw::Status::Unavailable() if the
-     * session is gone due to an endpoint going down.
+     * @return pw::OkStatus() on success
      */
     pw::Status checkSessionOpen(uint16_t id) EXCLUDES(mManager.mLock);
 
@@ -139,64 +124,136 @@ class MessageHubManager {
      * Removes the given session and any local and global mappings
      *
      * @param id The session id
+     * @param reason If present, reason for closing to be passed to the host
+     * endpoint
      * @return pw::OkStatus() on success
      */
-    pw::Status closeSession(uint16_t id) EXCLUDES(mManager.mLock);
+    pw::Status closeSession(uint16_t id, std::optional<Reason> reason = {})
+        EXCLUDES(mManager.mLock);
 
     /**
-     * Returns the registered id of this message hub.
+     * Forwards a message to an endpoint on this hub.
      *
-     * @return kId
+     * @param id The session in which the message was sent
+     * @param message The message
+     * @return pw::OkStatus() on success
      */
-    int64_t id() const;
+    pw::Status handleMessage(uint16_t sessionId, const Message &message)
+        EXCLUDES(mManager.mLock);
+
+    /**
+     * Forwards a message delivery status to an endpoint on this hub.
+     *
+     * @param id The session in which the message was sent
+     * @param status The message delivery status
+     * @return pw::OkStatus() on success
+     */
+    pw::Status handleMessageDeliveryStatus(uint16_t sessionId,
+                                           const MessageDeliveryStatus &status)
+        EXCLUDES(mManager.mLock);
+
+    /**
+     * Unregisters this HostHub.
+     *
+     * @return pw::OkStatus() if the host hub was successfully initialized and
+     * not yet unregistered.
+     */
+    pw::Status unregister() EXCLUDES(mManager.mLock);
+
+    /**
+     * Returns the list of endpoints registered on this hub.
+     */
+    std::vector<EndpointInfo> getEndpoints() const;
+
+    /**
+     * Returns the Message Hub info
+     */
+    const HubInfo &info() const {
+      return kInfo;
+    }
+
+    /**
+     * Returns the registered id of this message hub.
+     */
+    int64_t id() const {
+      return kInfo.hubId;
+    }
 
    private:
     friend class MessageHubManager;
+    friend class MessageHubManagerTest;
+
+    // Reresents a session between a host and embedded endpoint.
+    //
+    // A Session is created on an openSession() request (triggered either by a
+    // local or remote endpoint) with mPendingDestination unset via a call to
+    // ackSession*() from the destination endpoint. For Sessions started by
+    // embedded endpoints, an additional ackSession*() must be received from the
+    // CHRE MessageRouter after passing it the ack from the destination host
+    // endpoint. This unsets mPendingMessageRouter. A session is only open for
+    // messages once both mPendingDestination and mPendingMessageRouter are
+    // unset.
+    struct Session {
+      EndpointId mHostEndpoint;
+      EndpointId mEmbeddedEndpoint;
+      bool mPendingDestination = true;
+      bool mPendingMessageRouter;
+
+      Session(const EndpointId &hostEndpoint,
+              const EndpointId &embeddedEndpoint, bool hostInitiated)
+          : mHostEndpoint(hostEndpoint),
+            mEmbeddedEndpoint(embeddedEndpoint),
+            mPendingMessageRouter(!hostInitiated) {}
+    };
 
     // Cookie associated with each registered client callback.
     struct DeathRecipientCookie {
       MessageHubManager *manager;
-      pid_t pid;
+      int64_t hubId;
     };
 
     static constexpr uint16_t kSessionIdMaxRange = 1024;
 
     static constexpr int64_t kHubIdInvalid = 0;
 
-    HostHub(MessageHubManager &manager, pid_t pid)
-        : mManager(manager), kPid(pid) {}
+    HostHub(MessageHubManager &manager,
+            std::shared_ptr<IEndpointCallback> callback, const HubInfo &info);
 
     // Unlinks this hub from the manager, destroying internal references.
-    // Returns the id so that it can be propagated to CHRE.
-    int64_t unlinkFromManager() EXCLUDES(mManager.mLock);
-
-    // Unlink the current callback from the manager's death recipient.
-    void unlinkCallbackIfNecessaryLocked() REQUIRES(mManager.mLock);
+    // Propagates the unlinking to CHRE. If already unlinked, returns early with
+    // error.
+    pw::Status unlinkFromManager() EXCLUDES(mManager.mLock);
 
     // Returns pw::OkStatus() if the hub is in a valid state.
     pw::Status checkValidLocked() REQUIRES(mManager.mLock);
 
-    // Returns a shared_ptr to the given endpoint.
-    pw::Result<std::shared_ptr<EndpointInfo>> getEndpointLocked(
-        const EndpointId &id) REQUIRES(mManager.mLock);
+    // Returns pw::OkStatus() if the given endpoint (with service if given)
+    // exists on this hub.
+    pw::Status endpointExistsLocked(
+        const EndpointId &id, std::optional<std::string> serviceDescriptor)
+        REQUIRES(mManager.mLock);
 
     // Returns pw::OkStatus() if the session id is in range for this hub.
     bool sessionIdInRangeLocked(uint16_t id) REQUIRES(mManager.mLock);
 
-    MessageHubManager &mManager;
-    const pid_t kPid;
+    // Returns pw::OkStatus() if the session is open.
+    pw::Status checkSessionOpenLocked(uint16_t id) REQUIRES(mManager.mLock);
 
-    // Hub id, set when the first endpoint is registered.
-    int64_t kId GUARDED_BY(mManager.mLock) = kHubIdInvalid;
+    // Returns a pointer to the session with given id.
+    pw::Result<Session *> getSessionLocked(uint16_t id)
+        REQUIRES(mManager.mLock);
 
-    // Callback to HAL client.
-    std::shared_ptr<IEndpointCallback> mCallback GUARDED_BY(mManager.mLock);
+    MessageHubManager &mManager;
+    std::shared_ptr<IEndpointCallback> mCallback;  // Callback to client.
+    DeathRecipientCookie *mCookie;  // Death cookie associated with mCallback.
+    const HubInfo kInfo;            // Details of this hub.
 
-    // Cookie associated with mCallback.
-    DeathRecipientCookie *mCookie GUARDED_BY(mManager.mLock);
+    // Used to lookup a host endpoint.
+    std::unordered_map<int64_t, EndpointInfo> mIdToEndpoint
+        GUARDED_BY(mManager.mLock);
 
-    // Used to lookup a host endpoint. Owns the associated EndpointInfo.
-    std::unordered_map<int64_t, std::shared_ptr<EndpointInfo>> mIdToEndpoint
+    // Used to lookup state for sessions including an endpoint on this hub.
+    std::unordered_map<uint16_t, Session> mIdToSession
         GUARDED_BY(mManager.mLock);
 
     // Session id ranges allocated to this HostHub. The ranges are stored as a
@@ -209,78 +266,60 @@ class MessageHubManager {
   };
 
   // Callback registered to pass up the id of a host hub which disconnected.
-  using HostHubDownCb = std::function<void(int64_t hubId)>;
+  using HostHubDownCb =
+      std::function<void(std::function<pw::Result<int64_t>()> unlinkFn)>;
 
   // The base session id for sessions initiated from host endpoints.
   static constexpr uint16_t kHostSessionIdBase = 0x8000;
 
-  explicit MessageHubManager(HostHubDownCb cb);
+  explicit MessageHubManager(HostHubDownCb cb)
+      : mHostHubDownCb(std::move(cb)),
+        mDeathRecipient(std::make_unique<RealDeathRecipient>()) {}
   ~MessageHubManager() = default;
 
   /**
-   * Retrieves the HostHub instance for the calling process
-   *
-   * This API should be used for any HostHub lookup coming from the
-   * IContextHub interface. The first call to this API by any client process
-   * will trigger the creation of a HostHub for that client.
-   *
-   * @param pid The caller's system process id
-   * @return shared_ptr to the HostHub instance
-   */
-  std::shared_ptr<HostHub> getHostHubByPid(pid_t pid) EXCLUDES(mLock);
-
-  /**
-   * Retrieves the HostHub instance for the given EndpointId
+   * Registers a new client, creating a HostHub instance for it
    *
-   * @param id The endpoint id hosted by the returned hub
-   * @return shared_ptr to the HostHub instance
+   * @param callback Interface for communicating with the client
+   * @param info Details of the hub being registered
+   * @param uid The UID of the client
+   * @param pid The PID of the client
+   * @return On success, shared_ptr to the HostHub instance
    */
-  std::shared_ptr<HostHub> getHostHubByEndpointId(const EndpointId &id)
-      EXCLUDES(mLock);
+  pw::Result<std::shared_ptr<HostHub>> createHostHub(
+      std::shared_ptr<IEndpointCallback> callback, const HubInfo &info,
+      uid_t uid, pid_t pid) EXCLUDES(mLock);
 
   /**
-   * Checks that a given session is open and returns its HostHub.
+   * Retrieves a HostHub instance given its id
    *
-   * @param id Session id
-   * @return A strong reference to the HostHub. pw::Status::Unavailable()
-   * indicates that the session has been pruned.
+   * @param id The HostHub id
+   * @return shared_ptr to the HostHub instance, nullptr if not found
    */
-  pw::Result<std::shared_ptr<HostHub>> checkSessionOpenAndGetHostHub(
-      uint16_t id) EXCLUDES(mLock);
-
-  /**
-   * Acks a session open request.
-   *
-   * This is called both when the destination endpoint approves and also when
-   * MessageRouter gives a final ack on a session initiated from an embedded
-   * endpoint. See the documentation on the Session class.
-   *
-   * @param id Session id
-   * @return A strong reference to the HostHub. pw::Status::Unavailable()
-   * indicates that the session has been pruned.
-   */
-  pw::Result<std::shared_ptr<HostHub>> ackSessionAndGetHostHub(uint16_t id)
-      EXCLUDES(mLock);
+  std::shared_ptr<HostHub> getHostHub(int64_t id) EXCLUDES(mLock);
 
   /**
    * Apply the given function to each host hub.
    *
    * @param fn The function to apply.
    */
-  void forEachHostHub(std::function<void(HostHub &hub)> fn);
+  void forEachHostHub(std::function<void(HostHub &hub)> fn) EXCLUDES(mLock);
 
   /**
-   * Wipes and initializes the cache of embedded hubs and endpoints
+   * Wipes and marks the embedded state cache ready.
    *
    * This should only be called once during startup as it invalidates session
    * state (i.e. existing sessions will be pruned).
+   */
+  void initEmbeddedState() EXCLUDES(mLock);
+
+  /**
+   * Clears cache of embedded state and closes all sessions.
    *
-   * @param hubs The list of message hubs
-   * @param endpoints The list of endpoints
+   * Called on CHRE disconnection. Invalidates the cache. initEmbeddedState()
+   * must be called again before sessions can be established.
    */
-  void initEmbeddedHubsAndEndpoints(const std::vector<HubInfo> &hubs,
-                                    const std::vector<EndpointInfo> &endpoints)
-      EXCLUDES(mLock);
+  void clearEmbeddedState() EXCLUDES(mLock);
 
   /**
    * Adds the given hub to the cache
@@ -295,9 +334,8 @@ class MessageHubManager {
    * Removes the hub with given id from the cache
    *
    * @param id The id of the hub to remove
-   * @return The ids of all endpoints on the embedded hub
    */
-  std::vector<EndpointId> removeEmbeddedHub(int64_t id) EXCLUDES(mLock);
+  void removeEmbeddedHub(int64_t id) EXCLUDES(mLock);
 
   /**
    * Returns the cached list of embedded message hubs
@@ -315,6 +353,24 @@ class MessageHubManager {
    */
   void addEmbeddedEndpoint(const EndpointInfo &endpoint);
 
+  /**
+   * Adds a service to an embedded endpoint in the cache
+   *
+   * Ignored if the endpoint is already marked ready
+   *
+   * @param endpoint the new endpoint being updated
+   * @param service the service being added
+   */
+  void addEmbeddedEndpointService(const EndpointId &endpoint,
+                                  const Service &service);
+
+  /**
+   * Sets the ready flag on an embedded endpoint
+   *
+   * @param id The id of the endpoint to remove
+   */
+  void setEmbeddedEndpointReady(const EndpointId &endpoint);
+
   /**
    * Removes an embedded endpoint from the cache
    *
@@ -330,69 +386,54 @@ class MessageHubManager {
   std::vector<EndpointInfo> getEmbeddedEndpoints() const EXCLUDES(mLock);
 
  private:
+  friend class MessageHubManagerTest;
+
   // Callback invoked when a client goes down.
   using UnlinkToDeathFn = std::function<bool(
       const std::shared_ptr<IEndpointCallback> &callback, void *cookie)>;
 
-  // Represents an embedded MessageHub. Stores the hub details as well as a map
-  // of all endpoints hosted by the hub.
-  struct EmbeddedHub {
-    std::unordered_map<int64_t, std::shared_ptr<EndpointInfo>> idToEndpoint;
-    HubInfo info;
+  // Base class for a Binder DeathRecipient wrapper so that this functionality
+  // can be mocked in unit tests.
+  class DeathRecipient {
+   public:
+    virtual ~DeathRecipient() = default;
+
+    virtual pw::Status linkCallback(
+        const std::shared_ptr<IEndpointCallback> &callback,
+        HostHub::DeathRecipientCookie *cookie) = 0;
+
+    virtual pw::Status unlinkCallback(
+        const std::shared_ptr<IEndpointCallback> &callback,
+        HostHub::DeathRecipientCookie *cookie) = 0;
+
+   protected:
+    DeathRecipient() = default;
   };
 
-  // Represents a session between a host and embedded endpoint. Only stores weak
-  // references to the endpoints and HostHub owning the host endpoint. Must be
-  // converted to a SessionStrongRef to temporarily access state. The weak
-  // references expire when the associated entity is unregistered. A
-  // SessionStrongRef cannot be created if any reference has expired.
-  //
-  // A Session is created on an openSession() request (triggered either by a
-  // local or remote endpoint) with mPendingDestination unset via a call to
-  // ackSession*() from the destination endpoint. For Sessions started by
-  // embedded endpoints, an additional ackSession*() must be received from the
-  // CHRE MessageRouter after passing it the ack from the destination host
-  // endpoint. This unsets mPendingMessageRouter. A session is only open for
-  // messages once both mPendingDestination and mPendingMessageRouter are unset.
-  struct SessionStrongRef;
-  class Session {
+  // Real implementation of DeathRecipient.
+  class RealDeathRecipient : public DeathRecipient {
    public:
-    Session(std::weak_ptr<HostHub> hub, std::weak_ptr<EndpointInfo> local,
-            std::weak_ptr<EndpointInfo> remote, bool hostInitiated)
-        : mHub(hub),
-          mLocal(local),
-          mRemote(remote),
-          mPendingMessageRouter(!hostInitiated) {}
+    RealDeathRecipient();
+    RealDeathRecipient(RealDeathRecipient &&) = default;
+    RealDeathRecipient &operator=(RealDeathRecipient &&) = default;
+    virtual ~RealDeathRecipient() = default;
 
-   private:
-    friend struct SessionStrongRef;
+    pw::Status linkCallback(const std::shared_ptr<IEndpointCallback> &callback,
+                            HostHub::DeathRecipientCookie *cookie) override;
+
+    pw::Status unlinkCallback(
+        const std::shared_ptr<IEndpointCallback> &callback,
+        HostHub::DeathRecipientCookie *cookie) override;
 
-    std::weak_ptr<HostHub> mHub;
-    std::weak_ptr<EndpointInfo> mLocal;
-    std::weak_ptr<EndpointInfo> mRemote;
-    bool mPendingDestination = true;
-    bool mPendingMessageRouter;
+   private:
+    ndk::ScopedAIBinder_DeathRecipient mDeathRecipient;
   };
 
-  // A strong reference to a Session's underlying endpoints and HostHub as well
-  // as Session metadata. A SessionStrongRef should be created and destroyed
-  // within a single critical section.
-  struct SessionStrongRef {
-    std::shared_ptr<HostHub> hub;
-    std::shared_ptr<EndpointInfo> local;
-    std::shared_ptr<EndpointInfo> remote;
-    bool &pendingDestination;
-    bool &pendingMessageRouter;
-
-    SessionStrongRef(Session &session)
-        : hub(session.mHub.lock()),
-          local(session.mLocal.lock()),
-          remote(session.mRemote.lock()),
-          pendingDestination(session.mPendingDestination),
-          pendingMessageRouter(session.mPendingMessageRouter) {}
-    operator bool() const {
-      return hub && local && remote;
-    }
+  // Represents an embedded MessageHub. Stores the hub details as well as a map
+  // of all endpoints hosted by the hub.
+  struct EmbeddedHub {
+    std::unordered_map<int64_t, std::pair<EndpointInfo, bool>> idToEndpoint;
+    HubInfo info;
   };
 
   // The hub id reserved for the ContextHub service.
@@ -404,21 +445,30 @@ class MessageHubManager {
   // Invoked on client death. Cleans up references to the client.
   static void onClientDeath(void *cookie);
 
-  // Retrieves a strong reference to the session with given id.
-  pw::Result<SessionStrongRef> checkSessionLocked(uint16_t id) REQUIRES(mLock);
+  // Constructor used by tests to inject a mock DeathRecipient.
+  MessageHubManager(std::unique_ptr<DeathRecipient> deathRecipient,
+                    HostHubDownCb cb)
+      : mHostHubDownCb(std::move(cb)),
+        mDeathRecipient(std::move(deathRecipient)) {}
 
   // Adds an embedded endpoint to the cache.
   void addEmbeddedEndpointLocked(const EndpointInfo &endpoint) REQUIRES(mLock);
 
-  // Returns true if the embedded endpoint with given id is in the cache.
-  pw::Result<std::shared_ptr<EndpointInfo>> getEmbeddedEndpointLocked(
+  // Returns pw::OkStatus() if the given embedded endpoint (with service, if
+  // given), is in the cache.
+  pw::Status embeddedEndpointExistsLocked(
+      const EndpointId &id, std::optional<std::string> serviceDescriptor)
+      REQUIRES(mLock);
+
+  // Returns a pointer to an embedded endpoint entry if it exists.
+  pw::Result<std::pair<EndpointInfo, bool> *> lookupEmbeddedEndpointLocked(
       const EndpointId &id) REQUIRES(mLock);
 
   // Callback to pass up the id of a host hub for a client that disconnected.
   HostHubDownCb mHostHubDownCb;
 
   // Death recipient handling clients' disconnections.
-  ndk::ScopedAIBinder_DeathRecipient mDeathRecipient;
+  std::unique_ptr<DeathRecipient> mDeathRecipient;
 
   // Guards hub, endpoint, and session state.
   mutable std::mutex mLock;
@@ -426,22 +476,15 @@ class MessageHubManager {
   // Map of EmbeddedHubs.
   std::unordered_map<int64_t, EmbeddedHub> mIdToEmbeddedHub GUARDED_BY(mLock);
 
-  // Used to look up the HostHub associated with the client on IContextHub
-  // calls.
-  std::unordered_map<pid_t, std::shared_ptr<HostHub>> mPidToHostHub
-      GUARDED_BY(mLock);
-
-  // Used when an embedded endpoint wants to start a session with an endpoint
-  // hosted by a specific HostHub.
-  std::unordered_map<int64_t, std::weak_ptr<HostHub>> mIdToHostHub
+  // Map of HostHubs for registered IContextHub V4+ clients.
+  std::unordered_map<int64_t, std::shared_ptr<HostHub>> mIdToHostHub
       GUARDED_BY(mLock);
 
-  // Used to lookup the host endpoint to receive a message on an endpoint
-  // session.
-  std::unordered_map<uint16_t, Session> mIdToSession GUARDED_BY(mLock);
-
   // Next session id from which to allocate ranges.
   uint16_t mNextSessionId GUARDED_BY(mLock) = kHostSessionIdBase;
+
+  // True if the embedded hub cache is initialized.
+  bool mIdToEmbeddedHubReady GUARDED_BY(mLock) = false;
 };
 
 }  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/multi_client_context_hub_base.cc b/host/hal_generic/common/multi_client_context_hub_base.cc
index 356de2a8..1255195e 100644
--- a/host/hal_generic/common/multi_client_context_hub_base.cc
+++ b/host/hal_generic/common/multi_client_context_hub_base.cc
@@ -25,6 +25,7 @@
 #include "chre_host/fragmented_load_transaction.h"
 #include "chre_host/hal_error.h"
 #include "chre_host/host_protocol_host.h"
+#include "hal_client_id.h"
 #include "permissions_util.h"
 
 #include <android_chre_flags.h>
@@ -364,19 +365,8 @@ ScopedAStatus MultiClientContextHubBase::onSettingChanged(Setting setting,
 }
 
 ScopedAStatus MultiClientContextHubBase::queryNanoapps(int32_t contextHubId) {
-  if (!mIsChreReady) {
-    LOGE("%s() can't be processed as CHRE is not ready", __func__);
-    return fromServiceError(HalError::CHRE_NOT_READY);
-  }
-  if (!isValidContextHubId(contextHubId)) {
-    return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
-  }
-  flatbuffers::FlatBufferBuilder builder(64);
-  HostProtocolHost::encodeNanoappListRequest(builder);
-  HostProtocolHost::mutateHostClientId(
-      builder.GetBufferPointer(), builder.GetSize(),
-      mHalClientManager->getClientId(AIBinder_getCallingPid()));
-  return fromResult(mConnection->sendMessage(builder));
+  return queryNanoappsWithClientId(
+      contextHubId, mHalClientManager->getClientId(AIBinder_getCallingPid()));
 }
 
 ScopedAStatus MultiClientContextHubBase::getPreloadedNanoappIds(
@@ -591,77 +581,21 @@ ScopedAStatus MultiClientContextHubBase::getEndpoints(
   return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
 }
 
-ScopedAStatus MultiClientContextHubBase::registerEndpoint(
-    const EndpointInfo &endpoint) {
-  if (mV4Impl) return mV4Impl->registerEndpoint(endpoint);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::unregisterEndpoint(
-    const EndpointInfo &endpoint) {
-  if (mV4Impl) return mV4Impl->unregisterEndpoint(endpoint);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::registerEndpointCallback(
-    const std::shared_ptr<IEndpointCallback> &callback) {
-  if (mV4Impl) return mV4Impl->registerEndpointCallback(callback);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::requestSessionIdRange(
-    int32_t size, std::vector<int32_t> *ids) {
-  if (mV4Impl) return mV4Impl->requestSessionIdRange(size, ids);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::openEndpointSession(
-    int32_t sessionId, const EndpointId &destination,
-    const EndpointId &initiator,
-    const std::optional<std::string> &serviceDescriptor) {
-  if (mV4Impl) {
-    return mV4Impl->openEndpointSession(sessionId, destination, initiator,
-                                        serviceDescriptor);
-  }
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::sendMessageToEndpoint(
-    int32_t sessionId, const Message &msg) {
-  if (mV4Impl) return mV4Impl->sendMessageToEndpoint(sessionId, msg);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::sendMessageDeliveryStatusToEndpoint(
-    int32_t sessionId, const MessageDeliveryStatus &msgStatus) {
+ScopedAStatus MultiClientContextHubBase::registerEndpointHub(
+    const std::shared_ptr<IEndpointCallback> &callback, const HubInfo &hubInfo,
+    std::shared_ptr<IEndpointCommunication> *hubInterface) {
   if (mV4Impl)
-    return mV4Impl->sendMessageDeliveryStatusToEndpoint(sessionId, msgStatus);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::closeEndpointSession(int32_t sessionId,
-                                                              Reason reason) {
-  if (mV4Impl) return mV4Impl->closeEndpointSession(sessionId, reason);
-  return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
-}
-
-ScopedAStatus MultiClientContextHubBase::endpointSessionOpenComplete(
-    int32_t sessionId) {
-  if (mV4Impl) return mV4Impl->endpointSessionOpenComplete(sessionId);
+    return mV4Impl->registerEndpointHub(callback, hubInfo, hubInterface);
   return ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
 }
 
-bool MultiClientContextHubBase::enableTestMode() {
-  std::unique_lock<std::mutex> lock(mTestModeMutex);
-  if (mIsTestModeEnabled) {
-    return true;
-  }
-
+bool MultiClientContextHubBase::enableTestModeLocked(
+    std::unique_lock<std::mutex> &lock) {
   // Pulling out a list of loaded nanoapps.
   mTestModeNanoapps.reset();
-  if (!queryNanoapps(kDefaultHubId).isOk()) {
+  mTestModeSystemNanoapps.reset();
+  if (!queryNanoappsWithClientId(kDefaultHubId, kHalId).isOk()) {
     LOGE("Failed to get a list of loaded nanoapps to enable test mode");
-    mTestModeNanoapps.emplace();
     return false;
   }
   if (!mEnableTestModeCv.wait_for(lock, ktestModeTimeOut, [&]() {
@@ -671,7 +605,6 @@ bool MultiClientContextHubBase::enableTestMode() {
     LOGE("Failed to get a list of loaded nanoapps within %" PRIu64
          " seconds to enable test mode",
          ktestModeTimeOut.count());
-    mTestModeNanoapps.emplace();
     return false;
   }
 
@@ -711,21 +644,68 @@ bool MultiClientContextHubBase::enableTestMode() {
 
   LOGD("%" PRIu64 " nanoapps are unloaded to enable test mode",
        mTestModeNanoapps->size());
-  mIsTestModeEnabled = true;
-  mTestModeNanoapps.emplace();
   return true;
 }
 
+bool MultiClientContextHubBase::enableTestMode() {
+  std::unique_lock<std::mutex> lock(mTestModeMutex);
+  if (mIsTestModeEnabled) {
+    return true;
+  }
+  // Needed to ensure multiple calls to enableTestMode to not race as we unlock
+  // the lock to query the nanoapps.
+  mIsTestModeEnabled = true;
+
+  mIsTestModeEnabled = enableTestModeLocked(lock);
+  return mIsTestModeEnabled;
+}
+
 void MultiClientContextHubBase::disableTestMode() {
   std::unique_lock<std::mutex> lock(mTestModeMutex);
   if (!mIsTestModeEnabled) {
     return;
   }
+
+  mIsTestModeEnabled = false;
   int numOfNanoappsLoaded =
       mPreloadedNanoappLoader->loadPreloadedNanoapps(mTestModeSystemNanoapps);
   LOGD("%d nanoapps are reloaded to recover from test mode",
        numOfNanoappsLoaded);
-  mIsTestModeEnabled = false;
+}
+
+ScopedAStatus MultiClientContextHubBase::queryNanoappsWithClientId(
+    int32_t contextHubId, HalClientId clientId) {
+  if (!mIsChreReady) {
+    LOGE("%s() can't be processed as CHRE is not ready", __func__);
+    return fromServiceError(HalError::CHRE_NOT_READY);
+  }
+  if (!isValidContextHubId(contextHubId)) {
+    return ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
+  }
+  flatbuffers::FlatBufferBuilder builder(64);
+  HostProtocolHost::encodeNanoappListRequest(builder);
+  HostProtocolHost::mutateHostClientId(builder.GetBufferPointer(),
+                                       builder.GetSize(), clientId);
+  return fromResult(mConnection->sendMessage(builder));
+}
+
+void MultiClientContextHubBase::handleTestModeNanoappQueryResponse(
+    const ::chre::fbs::NanoappListResponseT &response) {
+  {
+    std::unique_lock<std::mutex> lock(mTestModeMutex);
+    mTestModeNanoapps.emplace();
+    mTestModeSystemNanoapps.emplace();
+
+    for (const auto &nanoapp : response.nanoapps) {
+      if (nanoapp->is_system) {
+        mTestModeSystemNanoapps->push_back(nanoapp->app_id);
+      } else {
+        mTestModeNanoapps->push_back(nanoapp->app_id);
+      }
+    }
+  }
+
+  mEnableTestModeCv.notify_all();
 }
 
 void MultiClientContextHubBase::handleMessageFromChre(
@@ -851,20 +831,11 @@ void MultiClientContextHubBase::onDebugDumpComplete(
 void MultiClientContextHubBase::onNanoappListResponse(
     const fbs::NanoappListResponseT &response, HalClientId clientId) {
   LOGD("Received a nanoapp list response for client %" PRIu16, clientId);
-  {
-    std::unique_lock<std::mutex> lock(mTestModeMutex);
-    if (!mTestModeNanoapps.has_value()) {
-      mTestModeNanoapps.emplace();
-      mTestModeSystemNanoapps.emplace();
-      for (const auto &nanoapp : response.nanoapps) {
-        if (nanoapp->is_system) {
-          mTestModeSystemNanoapps->push_back(nanoapp->app_id);
-        } else {
-          mTestModeNanoapps->push_back(nanoapp->app_id);
-        }
-      }
-      mEnableTestModeCv.notify_all();
-    }
+
+  if (clientId == kHalId) {
+    LOGD("Received a nanoapp list response to enable test mode");
+    handleTestModeNanoappQueryResponse(response);
+    return;  // this query was for test mode -> do not call callback
   }
 
   std::shared_ptr<IContextHubCallback> callback =
@@ -1105,14 +1076,22 @@ void MultiClientContextHubBase::handleClientDeath(pid_t clientPid) {
   mHalClientManager->handleClientDeath(clientPid);
 }
 
+void MultiClientContextHubBase::onChreDisconnected() {
+  mIsChreReady = false;
+  LOGW("HAL APIs will be failed because CHRE is disconnected");
+  if (mV4Impl) mV4Impl->onChreDisconnected();
+}
+
 void MultiClientContextHubBase::onChreRestarted() {
   mIsWifiAvailable.reset();
   mEventLogger.logContextHubRestart();
   mHalClientManager->handleChreRestart();
+  if (mV4Impl) mV4Impl->onChreRestarted();
 
   // Unblock APIs BEFORE informing the clients that CHRE has restarted so that
   // any API call triggered by handleContextHubAsyncEvent() can come through.
   mIsChreReady = true;
+  LOGI("HAL APIs are re-enabled");
   std::vector<std::shared_ptr<IContextHubCallback>> callbacks =
       mHalClientManager->getCallbacks();
   for (auto callback : callbacks) {
diff --git a/host/hal_generic/common/multi_client_context_hub_base.h b/host/hal_generic/common/multi_client_context_hub_base.h
index ea7b6f35..919ef513 100644
--- a/host/hal_generic/common/multi_client_context_hub_base.h
+++ b/host/hal_generic/common/multi_client_context_hub_base.h
@@ -32,6 +32,7 @@
 #include "hal_client_id.h"
 #include "hal_client_manager.h"
 
+#include <array>
 #include <chrono>
 #include <deque>
 #include <memory>
@@ -94,30 +95,16 @@ class MultiClientContextHubBase
       const MessageDeliveryStatus &messageDeliveryStatus) override;
   ScopedAStatus getHubs(std::vector<HubInfo> *hubs) override;
   ScopedAStatus getEndpoints(std::vector<EndpointInfo> *endpoints) override;
-  ScopedAStatus registerEndpoint(const EndpointInfo &endpoint) override;
-  ScopedAStatus unregisterEndpoint(const EndpointInfo &endpoint) override;
-  ScopedAStatus registerEndpointCallback(
-      const std::shared_ptr<IEndpointCallback> &callback) override;
-  ScopedAStatus requestSessionIdRange(int32_t size,
-                                      std::vector<int32_t> *ids) override;
-  ScopedAStatus openEndpointSession(
-      int32_t sessionId, const EndpointId &destination,
-      const EndpointId &initiator,
-      const std::optional<std::string> &serviceDescriptor) override;
-  ScopedAStatus sendMessageToEndpoint(int32_t sessionId,
-                                      const Message &msg) override;
-  ScopedAStatus sendMessageDeliveryStatusToEndpoint(
-      int32_t sessionId, const MessageDeliveryStatus &msgStatus) override;
-  ScopedAStatus closeEndpointSession(int32_t sessionId, Reason reason) override;
-  ScopedAStatus endpointSessionOpenComplete(int32_t sessionId) override;
+  ScopedAStatus registerEndpointHub(
+      const std::shared_ptr<IEndpointCallback> &callback,
+      const HubInfo &hubInfo,
+      std::shared_ptr<IEndpointCommunication> *hubInterface) override;
 
   // Functions implementing ChreConnectionCallback.
   void handleMessageFromChre(const unsigned char *messageBuffer,
                              size_t messageLen) override;
   void onChreRestarted() override;
-  void onChreDisconnected() override {
-    mIsChreReady = false;
-  }
+  void onChreDisconnected() override;
 
   // Functions for dumping debug information.
   binder_status_t dump(int fd, const char **args, uint32_t numArgs) override;
@@ -184,6 +171,15 @@ class MultiClientContextHubBase
   void handleClientDeath(pid_t pid);
   void handleLogMessageV2(const ::chre::fbs::LogMessageV2T &logMessage);
 
+  /**
+   * Enables test mode by unloading all the nanoapps except the system nanoapps.
+   * Requires the caller to hold the mTestModeMutex. This function does not
+   * set mIsTestModeEnabled.
+   *
+   * @return true as long as we have a list of nanoapps to unload.
+   */
+  bool enableTestModeLocked(std::unique_lock<std::mutex> &lock);
+
   /**
    * Enables test mode by unloading all the nanoapps except the system nanoapps.
    *
@@ -201,6 +197,25 @@ class MultiClientContextHubBase
    */
   void disableTestMode();
 
+  /**
+   * Queries nanoapps from the context hub with the given client ID.
+   *
+   * @param contextHubId The context hub ID.
+   * @param clientId The client ID.
+   * @return A ScopedAStatus indicating the success or failure of the query.
+   */
+  ScopedAStatus queryNanoappsWithClientId(int32_t contextHubId,
+                                          HalClientId clientId);
+
+  /**
+   * Handles a nanoapp list response from the context hub for test mode
+   * enablement.
+   *
+   * @param response The nanoapp list response from the context hub.
+   */
+  void handleTestModeNanoappQueryResponse(
+      const ::chre::fbs::NanoappListResponseT &response);
+
   inline bool isSettingEnabled(Setting setting) {
     return mSettingEnabled.find(setting) != mSettingEnabled.end() &&
            mSettingEnabled[setting];
@@ -214,8 +229,7 @@ class MultiClientContextHubBase
 
   HalClientManager::DeadClientUnlinker mDeadClientUnlinker;
 
-  // HAL is the unique owner of the communication channel to CHRE.
-  std::unique_ptr<ChreConnection> mConnection{};
+  std::shared_ptr<ChreConnection> mConnection{};
 
   // HalClientManager maintains states of hal clients. Each HAL should only have
   // one instance of a HalClientManager.
@@ -250,10 +264,10 @@ class MultiClientContextHubBase
   std::condition_variable mEnableTestModeCv;
   bool mIsTestModeEnabled = false;
   std::optional<bool> mTestModeSyncUnloadResult = std::nullopt;
+
   // mTestModeNanoapps records the nanoapps that will be unloaded in
-  // enableTestMode(). it is initialized to an empty vector to prevent it from
-  // unintended population in onNanoappListResponse().
-  std::optional<std::vector<uint64_t>> mTestModeNanoapps{{}};
+  // enableTestMode().
+  std::optional<std::vector<uint64_t>> mTestModeNanoapps;
   // mTestModeSystemNanoapps records system nanoapps that won't be reloaded in
   // disableTestMode().
   std::optional<std::vector<uint64_t>> mTestModeSystemNanoapps;
@@ -276,7 +290,8 @@ class MultiClientContextHubBase
   // guaranteed by the CHRE's disconnection handler.
   std::atomic_bool mIsChreReady = true;
 
-  // TODO(b/333567700): Remove when cleaning up the bug_fix_hal_reliable_message_record flag
+  // TODO(b/333567700): Remove when cleaning up the
+  // bug_fix_hal_reliable_message_record flag
   std::unordered_map<int32_t, HostEndpointId> mReliableMessageMap;
 };
 }  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/permissions_util.cc b/host/hal_generic/common/permissions_util.cc
index a414a25c..fb736219 100644
--- a/host/hal_generic/common/permissions_util.cc
+++ b/host/hal_generic/common/permissions_util.cc
@@ -16,14 +16,12 @@
 
 #include "permissions_util.h"
 
+#include <chre_host/log.h>
+
 #include "chre/util/macros.h"
 #include "chre/util/system/napp_permissions.h"
 
-namespace android {
-namespace hardware {
-namespace contexthub {
-namespace common {
-namespace implementation {
+namespace android::hardware::contexthub::common::implementation {
 
 std::vector<std::string> chreToAndroidPermissions(uint32_t chrePermissions) {
   std::vector<std::string> androidPermissions;
@@ -50,8 +48,24 @@ std::vector<std::string> chreToAndroidPermissions(uint32_t chrePermissions) {
   return androidPermissions;
 }
 
-}  // namespace implementation
-}  // namespace common
-}  // namespace contexthub
-}  // namespace hardware
-}  // namespace android
+uint32_t androidToChrePermissions(
+    const std::vector<std::string> &androidPermissions) {
+  uint32_t chrePermissions = 0;
+  for (const auto &permission : androidPermissions) {
+    if (permission == kRecordAudioPerm) {
+      chrePermissions |= ::chre::NanoappPermissions::CHRE_PERMS_AUDIO;
+    } else if (permission == kFineLocationPerm ||
+               permission == kBackgroundLocationPerm) {
+      chrePermissions |= ::chre::NanoappPermissions::CHRE_PERMS_GNSS |
+                         ::chre::NanoappPermissions::CHRE_PERMS_WIFI |
+                         ::chre::NanoappPermissions::CHRE_PERMS_WWAN;
+    } else if (permission == kBluetoothScanPerm) {
+      chrePermissions |= ::chre::NanoappPermissions::CHRE_PERMS_BLE;
+    } else {
+      LOGW("Unknown Android permission %s", permission.c_str());
+    }
+  }
+  return chrePermissions;
+}
+
+}  // namespace android::hardware::contexthub::common::implementation
diff --git a/host/hal_generic/common/permissions_util.h b/host/hal_generic/common/permissions_util.h
index ec5ebafa..1761fad2 100644
--- a/host/hal_generic/common/permissions_util.h
+++ b/host/hal_generic/common/permissions_util.h
@@ -20,11 +20,7 @@
 #include <string>
 #include <vector>
 
-namespace android {
-namespace hardware {
-namespace contexthub {
-namespace common {
-namespace implementation {
+namespace android::hardware::contexthub::common::implementation {
 
 // List of permissions supported by this HAL.
 const std::string kBackgroundLocationPerm =
@@ -39,10 +35,10 @@ const std::vector<std::string> kSupportedPermissions = {
 //! Converts the CHRE permissions bitmask to a list of CHRE permissions.
 std::vector<std::string> chreToAndroidPermissions(uint32_t chrePermissions);
 
-}  // namespace implementation
-}  // namespace common
-}  // namespace contexthub
-}  // namespace hardware
-}  // namespace android
+//! Converts list of Android permissions to CHRE permissions.
+uint32_t androidToChrePermissions(
+    const std::vector<std::string> &androidPermissions);
+
+}  // namespace android::hardware::contexthub::common::implementation
 
 #endif  // ANDROID_HARDWARE_CONTEXTHUB_COMMON_PERMISSIONS_UTIL_H
diff --git a/host/test/hal_generic/common/message_hub_manager_test.cc b/host/test/hal_generic/common/message_hub_manager_test.cc
new file mode 100644
index 00000000..15e29390
--- /dev/null
+++ b/host/test/hal_generic/common/message_hub_manager_test.cc
@@ -0,0 +1,707 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "message_hub_manager.h"
+
+#include <cstddef>
+#include <memory>
+#include <random>
+#include <unordered_map>
+
+#include <aidl/android/hardware/contexthub/IContextHub.h>
+
+#include "chre/platform/log.h"
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+namespace android::hardware::contexthub::common::implementation {
+namespace {
+
+using ::aidl::android::hardware::contexthub::EndpointId;
+using ::aidl::android::hardware::contexthub::EndpointInfo;
+using ::aidl::android::hardware::contexthub::ErrorCode;
+using ::aidl::android::hardware::contexthub::HubInfo;
+using ::aidl::android::hardware::contexthub::IEndpointCallback;
+using ::aidl::android::hardware::contexthub::Message;
+using ::aidl::android::hardware::contexthub::MessageDeliveryStatus;
+using ::aidl::android::hardware::contexthub::Reason;
+using ::ndk::ScopedAStatus;
+using ::ndk::SharedRefBase;
+using ::ndk::SpAIBinder;
+using ::testing::_;
+using ::testing::AllOf;
+using ::testing::AnyNumber;
+using ::testing::Ge;
+using ::testing::IsEmpty;
+using ::testing::IsNull;
+using ::testing::Le;
+using ::testing::NiceMock;
+using ::testing::Return;
+using ::testing::UnorderedElementsAreArray;
+
+class MockEndpointCallback : public IEndpointCallback {
+ public:
+  MOCK_METHOD(ScopedAStatus, onEndpointStarted,
+              (const std::vector<EndpointInfo> &), (override));
+  MOCK_METHOD(ScopedAStatus, onEndpointStopped,
+              (const std::vector<EndpointId> &, Reason), (override));
+  MOCK_METHOD(ScopedAStatus, onMessageReceived, (int32_t, const Message &),
+              (override));
+  MOCK_METHOD(ScopedAStatus, onMessageDeliveryStatusReceived,
+              (int32_t, const MessageDeliveryStatus &), (override));
+  MOCK_METHOD(ScopedAStatus, onEndpointSessionOpenRequest,
+              (int32_t, const EndpointId &, const EndpointId &,
+               const std::optional<std::string> &),
+              (override));
+  MOCK_METHOD(ScopedAStatus, onCloseEndpointSession, (int32_t, Reason),
+              (override));
+  MOCK_METHOD(ScopedAStatus, onEndpointSessionOpenComplete, (int32_t),
+              (override));
+  MOCK_METHOD(SpAIBinder, asBinder, (), (override));
+  MOCK_METHOD(bool, isRemote, (), (override));
+  MOCK_METHOD(ScopedAStatus, getInterfaceVersion, (int32_t *), (override));
+  MOCK_METHOD(ScopedAStatus, getInterfaceHash, (std::string *), (override));
+
+  MockEndpointCallback() {
+    ON_CALL(*this, onEndpointStarted)
+        .WillByDefault([](const std::vector<EndpointInfo> &) {
+          return ScopedAStatus::ok();
+        });
+    ON_CALL(*this, onEndpointStopped)
+        .WillByDefault([](const std::vector<EndpointId> &, Reason) {
+          return ScopedAStatus::ok();
+        });
+    ON_CALL(*this, onMessageReceived)
+        .WillByDefault(
+            [](int32_t, const Message &) { return ScopedAStatus::ok(); });
+    ON_CALL(*this, onMessageDeliveryStatusReceived)
+        .WillByDefault([](int32_t, const MessageDeliveryStatus &) {
+          return ScopedAStatus::ok();
+        });
+    ON_CALL(*this, onEndpointSessionOpenRequest)
+        .WillByDefault([](int32_t, const EndpointId &, const EndpointId &,
+                          const std::optional<std::string> &) {
+          return ScopedAStatus::ok();
+        });
+    ON_CALL(*this, onCloseEndpointSession).WillByDefault([](int32_t, Reason) {
+      return ScopedAStatus::ok();
+    });
+    ON_CALL(*this, onEndpointSessionOpenComplete).WillByDefault([](int32_t) {
+      return ScopedAStatus::ok();
+    });
+  }
+};
+
+constexpr int64_t kHub1Id = 0x1, kHub2Id = 0x2;
+constexpr int64_t kEndpoint1Id = 0x1, kEndpoint2Id = 0x2;
+const std::string kTestServiceDescriptor = "test_service";
+const HubInfo kHub1Info{.hubId = kHub1Id};
+const HubInfo kHub2Info{.hubId = kHub2Id};
+const Service kTestService{.serviceDescriptor = kTestServiceDescriptor};
+const EndpointInfo kEndpoint1_1Info{
+    .id = {.id = kEndpoint1Id, .hubId = kHub1Id}};
+const EndpointInfo kEndpoint1_2Info{
+    .id = {.id = kEndpoint2Id, .hubId = kHub1Id}, .services = {kTestService}};
+const EndpointInfo kEndpoint2_1Info{
+    .id = {.id = kEndpoint1Id, .hubId = kHub2Id}};
+const EndpointInfo kEndpoint2_2Info{
+    .id = {.id = kEndpoint2Id, .hubId = kHub2Id}, .services = {kTestService}};
+
+}  // namespace
+
+class MessageHubManagerTest : public ::testing::Test {
+ public:
+  using HostHub = MessageHubManager::HostHub;
+  using DeathRecipientCookie = HostHub::DeathRecipientCookie;
+  using HostHubDownCb = MessageHubManager::HostHubDownCb;
+
+  static constexpr auto kSessionIdMaxRange = HostHub::kSessionIdMaxRange;
+  static constexpr auto kHostSessionIdBase =
+      MessageHubManager::kHostSessionIdBase;
+
+  void SetUp() override {
+    reinit([](std::function<pw::Result<int64_t>()>) { FAIL(); });
+  }
+
+  void TearDown() override {
+    mManager->forEachHostHub([](HostHub &hub) { delete hub.mCookie; });
+  }
+
+  void reinit(HostHubDownCb cb) {
+    auto deathRecipient = std::make_unique<NiceMock<MockDeathRecipient>>();
+    mDeathRecipient = deathRecipient.get();
+    ON_CALL(*deathRecipient, linkCallback(_, _))
+        .WillByDefault(Return(pw::OkStatus()));
+    ON_CALL(*deathRecipient, unlinkCallback(_, _))
+        .WillByDefault(Return(pw::OkStatus()));
+    mManager.reset(
+        new MessageHubManager(std::move(deathRecipient), std::move(cb)));
+  }
+
+  void onClientDeath(const std::shared_ptr<HostHub> &hub) {
+    MessageHubManager::onClientDeath(hub->mCookie);
+  }
+
+  void setupDefaultHubs() {
+    mManager->initEmbeddedState();
+    mManager->addEmbeddedHub(kHub2Info);
+    mManager->addEmbeddedEndpoint(kEndpoint2_1Info);
+    mManager->setEmbeddedEndpointReady(kEndpoint2_1Info.id);
+    mManager->addEmbeddedEndpoint(kEndpoint2_2Info);
+    mManager->setEmbeddedEndpointReady(kEndpoint2_2Info.id);
+    mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+    mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+    EXPECT_TRUE(mHostHub->addEndpoint(kEndpoint1_1Info).ok());
+    EXPECT_TRUE(mHostHub->addEndpoint(kEndpoint1_2Info).ok());
+  }
+
+  uint16_t setupDefaultHubsAndSession() {
+    setupDefaultHubs();
+    auto range = *mHostHub->reserveSessionIdRange(1);
+    EXPECT_TRUE(mHostHub
+                    ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                  range.first, {}, /*hostInitiated=*/true)
+                    .ok());
+    EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenComplete(range.first));
+    EXPECT_TRUE(mManager->getHostHub(kHub1Id)
+                    ->ackSession(range.first,
+                                 /*hostAcked=*/false)
+                    .ok());
+    return range.first;
+  }
+
+ protected:
+  class MockDeathRecipient : public MessageHubManager::DeathRecipient {
+   public:
+    MOCK_METHOD(pw::Status, linkCallback,
+                (const std::shared_ptr<IEndpointCallback> &,
+                 DeathRecipientCookie *),
+                (override));
+    MOCK_METHOD(pw::Status, unlinkCallback,
+                (const std::shared_ptr<IEndpointCallback> &,
+                 DeathRecipientCookie *),
+                (override));
+  };
+
+  std::unique_ptr<MessageHubManager> mManager;
+  NiceMock<MockDeathRecipient> *mDeathRecipient;
+
+  std::shared_ptr<HostHub> mHostHub;
+  std::shared_ptr<MockEndpointCallback> mHostHubCb;
+};
+
+namespace {
+
+MATCHER_P(MatchSp, sp, "Matches an IEndpointCallback") {
+  return arg.get() == sp.get();
+}
+
+TEST_F(MessageHubManagerTest, CreateAndUnregisterHostHub) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  DeathRecipientCookie *cookie;
+  EXPECT_CALL(*mDeathRecipient, linkCallback(MatchSp(mHostHubCb), _))
+      .WillOnce([&cookie](const std::shared_ptr<IEndpointCallback> &,
+                          DeathRecipientCookie *c) {
+        cookie = c;
+        return pw::OkStatus();
+      });
+  auto statusOrHub = mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  ASSERT_TRUE(statusOrHub.ok());
+
+  mHostHub = *statusOrHub;
+  EXPECT_EQ(mHostHub->id(), kHub1Id);
+  EXPECT_EQ(mHostHub, mManager->getHostHub(kHub1Id));
+
+  EXPECT_CALL(*mDeathRecipient, unlinkCallback(MatchSp(mHostHubCb), cookie))
+      .WillOnce(Return(pw::OkStatus()));
+  mHostHub->unregister();
+  EXPECT_EQ(mHostHub->unregister(), pw::Status::Aborted());
+  EXPECT_THAT(mManager->getHostHub(kHub1Id), IsNull());
+}
+
+TEST_F(MessageHubManagerTest, CreateHostHubFails) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  EXPECT_CALL(*mDeathRecipient, linkCallback(MatchSp(mHostHubCb), _))
+      .WillOnce(Return(pw::Status::Internal()));
+  EXPECT_FALSE(mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0).ok());
+}
+
+TEST_F(MessageHubManagerTest, OnClientDeath) {
+  bool unlinked = false;
+  reinit([&unlinked](std::function<pw::Result<int64_t>()> fn) {
+    auto statusOrHubId = fn();
+    ASSERT_TRUE(statusOrHubId.ok());
+    EXPECT_EQ(*statusOrHubId, kHub1Id);
+    unlinked = true;
+  });
+
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  EXPECT_CALL(*mDeathRecipient, linkCallback(MatchSp(mHostHubCb), _))
+      .WillOnce(Return(pw::OkStatus()));
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  EXPECT_EQ(mHostHub->id(), kHub1Id);
+  EXPECT_EQ(mHostHub, mManager->getHostHub(kHub1Id));
+
+  EXPECT_CALL(*mDeathRecipient, unlinkCallback(_, _)).Times(0);
+  onClientDeath(mHostHub);
+  EXPECT_THAT(mManager->getHostHub(kHub1Id), IsNull());
+}
+
+TEST_F(MessageHubManagerTest, OnClientDeathAfterUnregister) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  mHostHub->unregister();
+  onClientDeath(mHostHub);
+}
+
+TEST_F(MessageHubManagerTest, InitAndClearEmbeddedState) {
+  mManager->addEmbeddedHub(kHub1Info);
+  EXPECT_THAT(mManager->getEmbeddedHubs(), IsEmpty());
+
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedHub(kHub1Info);
+  EXPECT_THAT(mManager->getEmbeddedHubs(),
+              UnorderedElementsAreArray({kHub1Info}));
+
+  mManager->clearEmbeddedState();
+  EXPECT_THAT(mManager->getEmbeddedHubs(), IsEmpty());
+}
+
+TEST_F(MessageHubManagerTest, AddAndRemoveEmbeddedHub) {
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedHub(kHub1Info);
+  EXPECT_THAT(mManager->getEmbeddedHubs(),
+              UnorderedElementsAreArray({kHub1Info}));
+
+  mManager->removeEmbeddedHub(kHub1Id);
+  EXPECT_THAT(mManager->getEmbeddedHubs(), IsEmpty());
+}
+
+MATCHER_P(MatchEndpointInfo, info, "Matches an EndpointInfo") {
+  if (arg.id.id != info.id.id || arg.id.hubId != info.id.hubId ||
+      arg.services.size() != info.services.size()) {
+    return false;
+  }
+  for (size_t i = 0; i < arg.services.size(); ++i) {
+    if (arg.services[i].serviceDescriptor !=
+        info.services[i].serviceDescriptor) {
+      return false;
+    }
+  }
+  return true;
+}
+
+TEST_F(MessageHubManagerTest, AddAndRemoveEmbeddedEndpoint) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  auto hostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedHub(kHub2Info);
+
+  mManager->addEmbeddedEndpoint({.id = kEndpoint2_2Info.id});
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(), IsEmpty());
+
+  mManager->addEmbeddedEndpointService(kEndpoint2_2Info.id,
+                                       kEndpoint2_2Info.services[0]);
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(), IsEmpty());
+
+  EXPECT_CALL(*mHostHubCb, onEndpointStarted(UnorderedElementsAreArray(
+                               {MatchEndpointInfo(kEndpoint2_2Info)})));
+  mManager->setEmbeddedEndpointReady(kEndpoint2_2Info.id);
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(),
+              UnorderedElementsAreArray({MatchEndpointInfo(kEndpoint2_2Info)}));
+
+  EXPECT_CALL(*mHostHubCb, onEndpointStopped(
+                               UnorderedElementsAreArray({kEndpoint2_2Info.id}),
+                               Reason::ENDPOINT_GONE));
+  mManager->removeEmbeddedEndpoint(kEndpoint2_2Info.id);
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(), IsEmpty());
+}
+
+TEST_F(MessageHubManagerTest, RemovingEmbeddedHubRemovesEndpoints) {
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedHub(kHub2Info);
+  mManager->addEmbeddedEndpoint(kEndpoint2_1Info);
+  mManager->setEmbeddedEndpointReady(kEndpoint2_1Info.id);
+  mManager->addEmbeddedEndpoint(kEndpoint2_2Info);
+  mManager->setEmbeddedEndpointReady(kEndpoint2_2Info.id);
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(),
+              UnorderedElementsAreArray({MatchEndpointInfo(kEndpoint2_1Info),
+                                         MatchEndpointInfo(kEndpoint2_2Info)}));
+
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  auto hostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  EXPECT_CALL(*mHostHubCb,
+              onEndpointStopped(UnorderedElementsAreArray(
+                                    {kEndpoint2_1Info.id, kEndpoint2_2Info.id}),
+                                Reason::HUB_RESET));
+  mManager->removeEmbeddedHub(kHub2Id);
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(), IsEmpty());
+}
+
+TEST_F(MessageHubManagerTest, AddEmbeddedEndpointForUnknownHub) {
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedEndpoint(kEndpoint1_1Info);
+  mManager->setEmbeddedEndpointReady(kEndpoint1_1Info.id);
+  EXPECT_THAT(mManager->getEmbeddedEndpoints(), IsEmpty());
+}
+
+TEST_F(MessageHubManagerTest, AddAndRemoveHostEndpoint) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+
+  EXPECT_TRUE(mHostHub->addEndpoint(kEndpoint1_1Info).ok());
+  EXPECT_THAT(mHostHub->getEndpoints(),
+              UnorderedElementsAreArray({kEndpoint1_1Info}));
+
+  EXPECT_TRUE(mHostHub->removeEndpoint(kEndpoint1_1Info.id).ok());
+  EXPECT_THAT(mHostHub->getEndpoints(), IsEmpty());
+}
+
+TEST_F(MessageHubManagerTest, AddDuplicateEndpoint) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  ASSERT_TRUE(mHostHub->addEndpoint(kEndpoint1_1Info).ok());
+  EXPECT_EQ(mHostHub->addEndpoint(kEndpoint1_1Info),
+            pw::Status::AlreadyExists());
+}
+
+TEST_F(MessageHubManagerTest, RemoveNonexistentEndpoint) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  EXPECT_EQ(mHostHub->removeEndpoint(kEndpoint1_1Info.id).status(),
+            pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, ReserveSessionIdRange) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  std::random_device rand;
+  auto range = *mHostHub->reserveSessionIdRange(
+      std::uniform_int_distribution<size_t>(1, kSessionIdMaxRange)(rand));
+  EXPECT_THAT(range.second - range.first + 1,
+              AllOf(Ge(1), Le(kSessionIdMaxRange)));
+}
+
+TEST_F(MessageHubManagerTest, ReserveBadSessionIdRange) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  EXPECT_EQ(mHostHub->reserveSessionIdRange(0).status(),
+            pw::Status::InvalidArgument());
+  EXPECT_EQ(mHostHub->reserveSessionIdRange(kSessionIdMaxRange + 1).status(),
+            pw::Status::InvalidArgument());
+}
+
+TEST_F(MessageHubManagerTest, ReserveSessionIdRangeFull) {
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  int iterations = (USHRT_MAX - kHostSessionIdBase + 1) / kSessionIdMaxRange;
+  for (int i = 0; i < iterations; ++i)
+    ASSERT_TRUE(mHostHub->reserveSessionIdRange(kSessionIdMaxRange).ok());
+  EXPECT_EQ(mHostHub->reserveSessionIdRange(kSessionIdMaxRange).status(),
+            pw::Status::ResourceExhausted());
+}
+
+TEST_F(MessageHubManagerTest, OpenHostSessionRequest) {
+  setupDefaultHubs();
+
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                range.first, {}, /*hostInitiated=*/true)
+                  .ok());
+  EXPECT_FALSE(mHostHub->checkSessionOpen(range.first).ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenHostSessionRequestBadSessionId) {
+  setupDefaultHubs();
+
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  EXPECT_EQ(mHostHub->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                  range.first + 1, {}, /*hostInitiated=*/true),
+            pw::Status::OutOfRange());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionRequest) {
+  setupDefaultHubs();
+
+  static constexpr uint16_t kSessionId = 1;
+  std::optional<std::string> serviceDescriptor;
+  EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenRequest(
+                               kSessionId, kEndpoint1_1Info.id,
+                               kEndpoint2_1Info.id, serviceDescriptor));
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                kSessionId, {}, /*hostInitiated=*/false)
+                  .ok());
+  EXPECT_FALSE(mHostHub->checkSessionOpen(kSessionId).ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionRequestBadSessionId) {
+  setupDefaultHubs();
+
+  EXPECT_FALSE(mHostHub
+                   ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                 kHostSessionIdBase, {},
+                                 /*hostInitiated=*/false)
+                   .ok());
+  EXPECT_EQ(mHostHub->checkSessionOpen(kHostSessionIdBase),
+            pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, OpenSessionRequestUnknownHostEndpoint) {
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedHub(kHub2Info);
+  mManager->addEmbeddedEndpoint(kEndpoint2_1Info);
+  mManager->setEmbeddedEndpointReady(kEndpoint2_1Info.id);
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  EXPECT_EQ(mHostHub->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                  range.first, {}, /*hostInitiated=*/true),
+            pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, OpenSessionRequestUnknownEmbeddedEndpoint) {
+  mManager->initEmbeddedState();
+  mManager->addEmbeddedHub(kHub2Info);
+  mHostHubCb = SharedRefBase::make<MockEndpointCallback>();
+  mHostHub = *mManager->createHostHub(mHostHubCb, kHub1Info, 0, 0);
+  ASSERT_TRUE(mHostHub->addEndpoint(kEndpoint1_1Info).ok());
+
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  EXPECT_EQ(mHostHub->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                  range.first, {}, /*hostInitiated=*/true),
+            pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, OpenHostSessionRequestWithService) {
+  setupDefaultHubs();
+
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  uint16_t sessionId = range.first;
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_2Info.id, kEndpoint2_2Info.id,
+                                sessionId, kTestServiceDescriptor,
+                                /*hostInitiated=*/true)
+                  .ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionRequestWithService) {
+  setupDefaultHubs();
+
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  uint16_t sessionId = range.first;
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_2Info.id, kEndpoint2_2Info.id,
+                                sessionId, kTestServiceDescriptor,
+                                /*hostInitiated=*/true)
+                  .ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenSessionWithServiceHostSideDoesNotSupport) {
+  setupDefaultHubs();
+
+  EXPECT_FALSE(mHostHub
+                   ->openSession(kEndpoint1_1Info.id, kEndpoint2_2Info.id,
+                                 kHostSessionIdBase, kTestServiceDescriptor,
+                                 /*hostInitiated=*/true)
+                   .ok());
+}
+
+TEST_F(MessageHubManagerTest,
+       OpenSessionWithServiceEmbeddedSideDoesNotSupport) {
+  setupDefaultHubs();
+
+  EXPECT_FALSE(mHostHub
+                   ->openSession(kEndpoint1_2Info.id, kEndpoint2_1Info.id,
+                                 kHostSessionIdBase, kTestServiceDescriptor,
+                                 /*hostInitiated=*/true)
+                   .ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenSessionRequestServiceSupportedButNotUsed) {
+  setupDefaultHubs();
+
+  std::optional<std::string> serviceDescriptor;
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  uint16_t sessionId = range.first;
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_2Info.id, kEndpoint2_2Info.id,
+                                sessionId, serviceDescriptor,
+                                /*hostInitiated=*/true)
+                  .ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenHostSessionEmbeddedEndpointAccepts) {
+  auto sessionId = setupDefaultHubsAndSession();
+  EXPECT_TRUE(mHostHub->checkSessionOpen(sessionId).ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenHostSessionEmbeddedEndpointRejects) {
+  setupDefaultHubs();
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  ASSERT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                range.first, {}, /*hostInitiated=*/true)
+                  .ok());
+
+  EXPECT_CALL(*mHostHubCb,
+              onCloseEndpointSession(
+                  range.first, Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED));
+  EXPECT_TRUE(mManager->getHostHub(kHub1Id)
+                  ->closeSession(range.first,
+                                 Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED)
+                  .ok());
+  EXPECT_EQ(mHostHub->checkSessionOpen(range.first), pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, OpenHostSessionHostTriesToAck) {
+  setupDefaultHubs();
+  auto range = *mHostHub->reserveSessionIdRange(1);
+  ASSERT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                range.first, {}, /*hostInitiated=*/true)
+                  .ok());
+
+  EXPECT_FALSE(mHostHub->ackSession(range.first, /*hostAcked=*/true).ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionHostEndpointAccepts) {
+  setupDefaultHubs();
+  static constexpr uint16_t kSessionId = 1;
+  EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenRequest(kSessionId, _, _, _));
+  ASSERT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                kSessionId, {}, /*hostInitiated=*/false)
+                  .ok());
+
+  EXPECT_TRUE(mHostHub->ackSession(kSessionId, /*hostAcked=*/true).ok());
+  EXPECT_FALSE(mHostHub->checkSessionOpen(kSessionId).ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionMessageRouterTriesToAck) {
+  setupDefaultHubs();
+  static constexpr uint16_t kSessionId = 1;
+  EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenRequest(kSessionId, _, _, _));
+  ASSERT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                kSessionId, {}, /*hostInitiated=*/false)
+                  .ok());
+
+  EXPECT_FALSE(mHostHub->ackSession(kSessionId, /*hostAcked=*/false).ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionPrunePendingSession) {
+  setupDefaultHubs();
+  static constexpr uint16_t kSessionId = 1;
+  EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenRequest(kSessionId, _, _, _));
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                kSessionId, {}, /*hostInitiated=*/false)
+                  .ok());
+  EXPECT_TRUE(mHostHub->ackSession(kSessionId, /*hostAcked=*/true).ok());
+
+  EXPECT_CALL(*mHostHubCb, onCloseEndpointSession(kSessionId, _));
+  EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenRequest(kSessionId, _, _, _));
+  EXPECT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                kSessionId, {}, /*hostInitiated=*/false)
+                  .ok());
+}
+
+TEST_F(MessageHubManagerTest, OpenEmbeddedSessionMessageRouterAcks) {
+  setupDefaultHubs();
+  static constexpr uint16_t kSessionId = 1;
+  EXPECT_CALL(*mHostHubCb, onEndpointSessionOpenRequest(kSessionId, _, _, _));
+  ASSERT_TRUE(mHostHub
+                  ->openSession(kEndpoint1_1Info.id, kEndpoint2_1Info.id,
+                                kSessionId, {}, /*hostInitiated=*/false)
+                  .ok());
+  ASSERT_TRUE(mHostHub->ackSession(kSessionId, /*hostAcked=*/true).ok());
+
+  EXPECT_TRUE(mHostHub->ackSession(kSessionId, /*hostAcked=*/false).ok());
+  EXPECT_TRUE(mHostHub->checkSessionOpen(kSessionId).ok());
+}
+
+TEST_F(MessageHubManagerTest, ActiveSessionEmbeddedHubGone) {
+  auto sessionId = setupDefaultHubsAndSession();
+
+  EXPECT_CALL(*mHostHubCb,
+              onCloseEndpointSession(sessionId, Reason::HUB_RESET));
+  EXPECT_CALL(*mHostHubCb,
+              onEndpointStopped(UnorderedElementsAreArray(
+                                    {kEndpoint2_1Info.id, kEndpoint2_2Info.id}),
+                                Reason::HUB_RESET));
+  mManager->removeEmbeddedHub(kHub2Id);
+  EXPECT_EQ(mHostHub->checkSessionOpen(sessionId), pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, ActiveSessionEmbeddedEndpointGone) {
+  auto sessionId = setupDefaultHubsAndSession();
+
+  EXPECT_CALL(*mHostHubCb,
+              onCloseEndpointSession(sessionId, Reason::ENDPOINT_GONE));
+  EXPECT_CALL(*mHostHubCb, onEndpointStopped(
+                               UnorderedElementsAreArray({kEndpoint2_1Info.id}),
+                               Reason::ENDPOINT_GONE));
+  mManager->removeEmbeddedEndpoint(kEndpoint2_1Info.id);
+  EXPECT_EQ(mHostHub->checkSessionOpen(sessionId), pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, ActiveSessionHostEndpointGone) {
+  auto sessionId = setupDefaultHubsAndSession();
+
+  EXPECT_THAT(*mHostHub->removeEndpoint(kEndpoint1_1Info.id),
+              UnorderedElementsAreArray({sessionId}));
+  EXPECT_EQ(mHostHub->checkSessionOpen(sessionId), pw::Status::NotFound());
+}
+
+TEST_F(MessageHubManagerTest, HandleMessage) {
+  auto sessionId = setupDefaultHubsAndSession();
+
+  Message message{.content = {0xde, 0xad, 0xbe, 0xef}};
+  EXPECT_CALL(*mHostHubCb, onMessageReceived(sessionId, message));
+  EXPECT_TRUE(mHostHub->handleMessage(sessionId, message).ok());
+}
+
+TEST_F(MessageHubManagerTest, HandleMessageForUnknownSession) {
+  setupDefaultHubs();
+
+  Message message{.content = {0xde, 0xad, 0xbe, 0xef}};
+  EXPECT_CALL(*mHostHubCb, onMessageReceived(_, _)).Times(0);
+  EXPECT_FALSE(mHostHub->handleMessage(1, message).ok());
+}
+
+TEST_F(MessageHubManagerTest, HandleMessageDeliveryStatus) {
+  auto sessionId = setupDefaultHubsAndSession();
+
+  MessageDeliveryStatus status{.errorCode = ErrorCode::TRANSIENT_ERROR};
+  EXPECT_CALL(*mHostHubCb, onMessageDeliveryStatusReceived(sessionId, status));
+  EXPECT_TRUE(mHostHub->handleMessageDeliveryStatus(sessionId, status).ok());
+}
+
+TEST_F(MessageHubManagerTest, HandleMessageDeliveryStatusForUnknownSession) {
+  setupDefaultHubs();
+
+  MessageDeliveryStatus status{.errorCode = ErrorCode::TRANSIENT_ERROR};
+  EXPECT_CALL(*mHostHubCb, onMessageDeliveryStatusReceived(_, _)).Times(0);
+  EXPECT_FALSE(mHostHub->handleMessageDeliveryStatus(1, status).ok());
+}
+
+}  // namespace
+}  // namespace android::hardware::contexthub::common::implementation
diff --git a/java/test/ble_concurrency/src/com/google/android/chre/test/bleconcurrency/ContextHubBleConcurrencyTestExecutor.java b/java/test/ble_concurrency/src/com/google/android/chre/test/bleconcurrency/ContextHubBleConcurrencyTestExecutor.java
index 10187ba3..c071aef9 100644
--- a/java/test/ble_concurrency/src/com/google/android/chre/test/bleconcurrency/ContextHubBleConcurrencyTestExecutor.java
+++ b/java/test/ble_concurrency/src/com/google/android/chre/test/bleconcurrency/ContextHubBleConcurrencyTestExecutor.java
@@ -34,7 +34,7 @@ public class ContextHubBleConcurrencyTestExecutor extends ContextHubBleTestExecu
      * Runs the test.
      */
     public void run() throws Exception {
-        if (doesNecessaryBleCapabilitiesExist()) {
+        if (doNecessaryBleCapabilitiesExist()) {
             testHostScanFirst();
             Thread.sleep(1000);
             testChreScanFirst();
diff --git a/java/test/chqts/src/com/google/android/chre/test/chqts/ContextHubBleTestExecutor.java b/java/test/chqts/src/com/google/android/chre/test/chqts/ContextHubBleTestExecutor.java
index e8d30777..afaa0bd8 100644
--- a/java/test/chqts/src/com/google/android/chre/test/chqts/ContextHubBleTestExecutor.java
+++ b/java/test/chqts/src/com/google/android/chre/test/chqts/ContextHubBleTestExecutor.java
@@ -346,10 +346,10 @@ public class ContextHubBleTestExecutor extends ContextHubChreApiTestExecutor {
     }
 
     /**
-     * Returns true if the required BLE capabilities and filter capabilities exist,
-     * otherwise returns false.
+     * Returns true if the required BLE capabilities and filter capabilities exist, otherwise
+     * returns false.
      */
-    public boolean doesNecessaryBleCapabilitiesExist() throws Exception {
+    public boolean doNecessaryBleCapabilitiesExist() throws Exception {
         if (mBluetoothLeScanner == null) {
             return false;
         }
@@ -369,10 +369,10 @@ public class ContextHubBleTestExecutor extends ContextHubChreApiTestExecutor {
     }
 
     /**
-     * Returns true if the required BLE capabilities and filter capabilities exist
-     * on the AP, otherwise returns false.
+     * Returns true if the required BLE capabilities and filter capabilities exist on the AP,
+     * otherwise returns false.
      */
-    public boolean doesNecessaryBleCapabilitiesExistOnTheAP() throws Exception {
+    public boolean doNecessaryBleCapabilitiesExistOnTheAP() throws Exception {
         return mBluetoothLeAdvertiser != null;
     }
 
@@ -406,8 +406,8 @@ public class ContextHubBleTestExecutor extends ContextHubChreApiTestExecutor {
         AdvertisingSetParameters parameters = new AdvertisingSetParameters.Builder()
                 .setLegacyMode(true)
                 .setConnectable(false)
-                .setInterval(AdvertisingSetParameters.INTERVAL_HIGH)
-                .setTxPowerLevel(AdvertisingSetParameters.TX_POWER_HIGH)
+                .setInterval(AdvertisingSetParameters.INTERVAL_LOW)
+                .setTxPowerLevel(AdvertisingSetParameters.TX_POWER_MEDIUM)
                 .build();
 
         AdvertiseData data = new AdvertiseData.Builder()
@@ -434,8 +434,8 @@ public class ContextHubBleTestExecutor extends ContextHubChreApiTestExecutor {
         AdvertisingSetParameters parameters = new AdvertisingSetParameters.Builder()
                 .setLegacyMode(true)
                 .setConnectable(false)
-                .setInterval(AdvertisingSetParameters.INTERVAL_HIGH)
-                .setTxPowerLevel(AdvertisingSetParameters.TX_POWER_HIGH)
+                .setInterval(AdvertisingSetParameters.INTERVAL_LOW)
+                .setTxPowerLevel(AdvertisingSetParameters.TX_POWER_MEDIUM)
                 .build();
 
         AdvertiseData data = new AdvertiseData.Builder()
diff --git a/java/test/chqts/src/com/google/android/chre/test/chqts/multidevice/ContextHubMultiDeviceBleBeaconTestExecutor.java b/java/test/chqts/src/com/google/android/chre/test/chqts/multidevice/ContextHubMultiDeviceBleBeaconTestExecutor.java
index c1ada3d2..2826a550 100644
--- a/java/test/chqts/src/com/google/android/chre/test/chqts/multidevice/ContextHubMultiDeviceBleBeaconTestExecutor.java
+++ b/java/test/chqts/src/com/google/android/chre/test/chqts/multidevice/ContextHubMultiDeviceBleBeaconTestExecutor.java
@@ -28,12 +28,14 @@ import java.util.concurrent.Future;
 import dev.chre.rpc.proto.ChreApiTest;
 
 public class ContextHubMultiDeviceBleBeaconTestExecutor extends ContextHubBleTestExecutor {
-    private static final int NUM_EVENTS_TO_GATHER = 10;
+    private static final int NUM_EVENTS_TO_GATHER_PER_CYCLE = 1000;
 
-    private static final long TIMEOUT_IN_S = 30;
+    private static final long TIMEOUT_IN_S = 1;
 
     private static final long TIMEOUT_IN_NS = TIMEOUT_IN_S * 1000000000L;
 
+    private static final int NUM_EVENT_CYCLES_TO_GATHER = 5;
+
     /**
      * The minimum offset in bytes of a BLE advertisement report which includes the length
      * and type of the report.
@@ -45,33 +47,37 @@ public class ContextHubMultiDeviceBleBeaconTestExecutor extends ContextHubBleTes
     }
 
     /**
-     * Gathers BLE advertisement events from the nanoapp for TIMEOUT_IN_NS or up to
-     * NUM_EVENTS_TO_GATHER events. This function returns true if all
+     * Gathers BLE advertisement events from the nanoapp for NUM_EVENT_CYCLES_TO_GATHER
+     * cycles, and for each cycle gathers for TIMEOUT_IN_NS or up to
+     * NUM_EVENTS_TO_GATHER_PER_CYCLE events. This function returns true if all
      * chreBleAdvertisingReport's contain advertisments for Google Eddystone and
      * there is at least one advertisement, otherwise it returns false.
      */
     public boolean gatherAndVerifyChreBleAdvertisementsForGoogleEddystone() throws Exception {
-        List<ChreApiTest.GeneralEventsMessage> events = gatherChreBleEvents();
-        if (events == null) {
-            return false;
-        }
-
-        for (ChreApiTest.GeneralEventsMessage event: events) {
-            if (!event.hasChreBleAdvertisementEvent()) {
+        for (int i = 0; i < NUM_EVENT_CYCLES_TO_GATHER; i++) {
+            List<ChreApiTest.GeneralEventsMessage> events = gatherChreBleEvents();
+            if (events == null) {
                 continue;
             }
 
-            ChreApiTest.ChreBleAdvertisementEvent bleAdvertisementEvent =
-                    event.getChreBleAdvertisementEvent();
-            for (int i = 0; i < bleAdvertisementEvent.getReportsCount(); ++i) {
-                ChreApiTest.ChreBleAdvertisingReport report = bleAdvertisementEvent.getReports(i);
-                byte[] data = report.getData().toByteArray();
-                if (data == null || data.length < BLE_ADVERTISEMENT_DATA_HEADER_OFFSET) {
+            for (ChreApiTest.GeneralEventsMessage event: events) {
+                if (!event.hasChreBleAdvertisementEvent()) {
                     continue;
                 }
 
-                if (searchForGoogleEddystoneAdvertisement(data)) {
-                    return true;
+                ChreApiTest.ChreBleAdvertisementEvent bleAdvertisementEvent =
+                        event.getChreBleAdvertisementEvent();
+                for (int j = 0; j < bleAdvertisementEvent.getReportsCount(); ++j) {
+                    ChreApiTest.ChreBleAdvertisingReport report =
+                            bleAdvertisementEvent.getReports(j);
+                    byte[] data = report.getData().toByteArray();
+                    if (data == null || data.length < BLE_ADVERTISEMENT_DATA_HEADER_OFFSET) {
+                        continue;
+                    }
+
+                    if (searchForGoogleEddystoneAdvertisement(data)) {
+                        return true;
+                    }
                 }
             }
         }
@@ -79,33 +85,37 @@ public class ContextHubMultiDeviceBleBeaconTestExecutor extends ContextHubBleTes
     }
 
     /**
-     * Gathers BLE advertisement events from the nanoapp for TIMEOUT_IN_NS or up to
-     * NUM_EVENTS_TO_GATHER events. This function returns true if all
+     * Gathers BLE advertisement events from the nanoapp for NUM_EVENT_CYCLES_TO_GATHER
+     * cycles, and for each cycle gathers for TIMEOUT_IN_NS or up to
+     * NUM_EVENTS_TO_GATHER_PER_CYCLE events. This function returns true if all
      * chreBleAdvertisingReport's contain advertisments with CHRE test manufacturer ID and
      * there is at least one advertisement, otherwise it returns false.
      */
     public boolean gatherAndVerifyChreBleAdvertisementsWithManufacturerData() throws Exception {
-        List<ChreApiTest.GeneralEventsMessage> events = gatherChreBleEvents();
-        if (events == null) {
-            return false;
-        }
-
-        for (ChreApiTest.GeneralEventsMessage event: events) {
-            if (!event.hasChreBleAdvertisementEvent()) {
+        for (int i = 0; i < NUM_EVENT_CYCLES_TO_GATHER; i++) {
+            List<ChreApiTest.GeneralEventsMessage> events = gatherChreBleEvents();
+            if (events == null) {
                 continue;
             }
 
-            ChreApiTest.ChreBleAdvertisementEvent bleAdvertisementEvent =
-                    event.getChreBleAdvertisementEvent();
-            for (int i = 0; i < bleAdvertisementEvent.getReportsCount(); ++i) {
-                ChreApiTest.ChreBleAdvertisingReport report = bleAdvertisementEvent.getReports(i);
-                byte[] data = report.getData().toByteArray();
-                if (data == null || data.length < BLE_ADVERTISEMENT_DATA_HEADER_OFFSET) {
+            for (ChreApiTest.GeneralEventsMessage event: events) {
+                if (!event.hasChreBleAdvertisementEvent()) {
                     continue;
                 }
 
-                if (searchForManufacturerAdvertisement(data)) {
-                    return true;
+                ChreApiTest.ChreBleAdvertisementEvent bleAdvertisementEvent =
+                        event.getChreBleAdvertisementEvent();
+                for (int j = 0; j < bleAdvertisementEvent.getReportsCount(); ++j) {
+                    ChreApiTest.ChreBleAdvertisingReport report =
+                            bleAdvertisementEvent.getReports(j);
+                    byte[] data = report.getData().toByteArray();
+                    if (data == null || data.length < BLE_ADVERTISEMENT_DATA_HEADER_OFFSET) {
+                        continue;
+                    }
+
+                    if (searchForManufacturerAdvertisement(data)) {
+                        return true;
+                    }
                 }
             }
         }
@@ -120,7 +130,7 @@ public class ContextHubMultiDeviceBleBeaconTestExecutor extends ContextHubBleTes
                 new ChreApiTestUtil().gatherEvents(
                         mRpcClients.get(0),
                         Arrays.asList(CHRE_EVENT_BLE_ADVERTISEMENT),
-                        NUM_EVENTS_TO_GATHER,
+                        NUM_EVENTS_TO_GATHER_PER_CYCLE,
                         TIMEOUT_IN_NS);
         List<ChreApiTest.GeneralEventsMessage> events = eventsFuture.get();
         return events;
diff --git a/java/test/cross_validation/Android.bp b/java/test/cross_validation/Android.bp
index de9ffa24..31f68ef4 100644
--- a/java/test/cross_validation/Android.bp
+++ b/java/test/cross_validation/Android.bp
@@ -33,6 +33,7 @@ java_library {
         "chre_test_common_java_proto",
         "chrecrossvalidation_sensor_java_proto",
         "chrecrossvalidation_wifi_java_proto",
+        "chrecrossvalidation_wwan_java_proto",
         "guava",
     ],
 
diff --git a/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorSensor.java b/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorSensor.java
index cc62d5d7..e1b2a47f 100644
--- a/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorSensor.java
+++ b/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorSensor.java
@@ -93,6 +93,15 @@ public class ChreCrossValidatorSensor
     // test start-up.
     private List<Sensor> mSensorList = new ArrayList<Sensor>();
 
+    // The name of the sensor that CHRE are intended to collect data from.
+    // Note that although we can try to configure which sensor to use on CHRE by setting
+    // SensorInfoCommand.sensorName, CHRE might not support multiple sensor so it's always going
+    // to use default sensor, which is why we need to double check which sensor to use on the host
+    // side.
+    private String mChreUsedSensorName = null;
+
+    private int mCurrentTestingSensorType;
+
     // The current sensor that is being cross-validated. These variables should be re-generated for
     // each sensor that is tested.
     private Sensor mSensor;
@@ -148,6 +157,8 @@ public class ChreCrossValidatorSensor
             String.format("Sensor could not be instantiated for sensor type %d, " +
                               "skipping this test", apSensorType),
             mSensorList.size() > 0);
+
+        mCurrentTestingSensorType = apSensorType;
     }
 
     @Override
@@ -167,6 +178,7 @@ public class ChreCrossValidatorSensor
                             TimeUnit.MICROSECONDS.toMillis(mSensor.getMaxDelay()));
 
             verifyChreSensorIsPresent();
+            updateTestingSensor();
             if (!mChreSensorIndex.isPresent()) {
                 // All CHRE sensors are optional so skip this test if the sensor isn't found.
                 Log.d(TAG, "Sensor was not present in CHRE - skip");
@@ -239,6 +251,41 @@ public class ChreCrossValidatorSensor
         }
     }
 
+    // Update the host side testing sensor if CHRE reports that it's going to test
+    // another sensor.
+    private void updateTestingSensor() {
+        if (mChreUsedSensorName == null) {
+            Log.w(TAG, "mChreUsedSensorName == null");
+            return;
+        }
+        if (mSensor.getName() != null && mSensor.getName().equals(mChreUsedSensorName)) {
+            Log.d(TAG, "Host/CHRE sensor matches, no need to update test sensor");
+            return;
+        }
+        int matchedCount = 0;
+        for (Sensor sensor : mSensorList) {
+            if (sensor.getName() == null) {
+                Log.w(TAG, "sensor.getName() == null");
+                continue;
+            }
+            // We know that sometimes host side sensor name will have additional postfixes.
+            if (sensor.getName().contains(mChreUsedSensorName)
+                    && sensor.getType() == mCurrentTestingSensorType) {
+                Log.d(TAG, "Updating test sensor to [CHRE: " + mChreUsedSensorName
+                         + "],[Android: " + sensor.getName() + "]");
+                mSensor = sensor;
+                matchedCount += 1;
+            }
+        }
+        if (matchedCount == 0) {
+            Log.e(TAG, "Cannot find the same sensor on host that has name ["
+                    + mChreUsedSensorName + "]");
+        } else if (matchedCount > 1) {
+            Log.w(TAG, "Found more than one sensor that matches ["
+                    + mChreUsedSensorName + "]");
+        }
+    }
+
     private void parseInfoResponseFromNanoappMessage(NanoAppMessage message) {
         ChreCrossValidationSensor.SensorInfoResponse infoProto;
         try {
@@ -263,6 +310,12 @@ public class ChreCrossValidatorSensor
         if (infoProto.getIsAvailable()) {
             mChreSensorIndex = Optional.of(infoProto.getSensorIndex());
         }
+
+        if (infoProto.hasSensorName()) {
+            mChreUsedSensorName = infoProto.getSensorName().toStringUtf8();
+        } else {
+            Log.w(TAG, "No sensor name coming from nanoapp");
+        }
         mAwaitDataLatch.countDown();
     }
 
@@ -357,13 +410,13 @@ public class ChreCrossValidatorSensor
     @Override
     public void init() throws AssertionError {
         super.init();
-        restrictSensors();
+        ChreTestUtil.restrictSensors("ChreCrossValidatorSensor");
     }
 
     @Override
     public void deinit() throws AssertionError {
         super.deinit();
-        unrestrictSensors();
+        ChreTestUtil.unrestrictSensors();
     }
 
     /*
@@ -502,22 +555,6 @@ public class ChreCrossValidatorSensor
         mChreDatapointsArray = newChreSensorDatapoints.toArray(new ChreSensorDatapoint[0]);
     }
 
-    /**
-     * Restrict other applications from accessing sensors. Should be called before validating data.
-     */
-    private void restrictSensors() {
-        ChreTestUtil.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
-                "dumpsys sensorservice restrict ChreCrossValidatorSensor");
-    }
-
-    /**
-     * Unrestrict other applications from accessing sensors. Should be called after validating data.
-     */
-    private void unrestrictSensors() {
-        ChreTestUtil.executeShellCommand(
-                InstrumentationRegistry.getInstrumentation(), "dumpsys sensorservice enable");
-    }
-
     @Override
     protected void unregisterApDataListener() {
         mSensorManager.unregisterListener(this);
diff --git a/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWifi.java b/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWifi.java
index e9f9f92c..0dbd2d57 100644
--- a/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWifi.java
+++ b/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWifi.java
@@ -49,7 +49,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
 public class ChreCrossValidatorWifi extends ChreCrossValidatorBase {
-    private static final long AWAIT_STEP_RESULT_MESSAGE_TIMEOUT_SEC = 7;
+    private static final long AWAIT_STEP_RESULT_MESSAGE_TIMEOUT_SEC = 15;
     private static final long AWAIT_WIFI_SCAN_RESULT_TIMEOUT_SEC = 30;
 
     private static final long NANO_APP_ID = 0x476f6f6754000005L;
diff --git a/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWwan.java b/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWwan.java
new file mode 100644
index 00000000..4b9472bf
--- /dev/null
+++ b/java/test/cross_validation/src/com/google/android/chre/test/crossvalidator/ChreCrossValidatorWwan.java
@@ -0,0 +1,744 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.chre.test.crossvalidator;
+
+import android.content.Context;
+import android.hardware.location.ContextHubInfo;
+import android.hardware.location.ContextHubManager;
+import android.hardware.location.ContextHubTransaction;
+import android.hardware.location.NanoAppBinary;
+import android.hardware.location.NanoAppMessage;
+import android.telephony.CellIdentityGsm;
+import android.telephony.CellIdentityLte;
+import android.telephony.CellIdentityNr;
+import android.telephony.CellIdentityWcdma;
+import android.telephony.CellInfo;
+import android.telephony.CellInfoGsm;
+import android.telephony.CellInfoLte;
+import android.telephony.CellInfoNr;
+import android.telephony.CellInfoWcdma;
+import android.telephony.CellSignalStrengthGsm;
+import android.telephony.CellSignalStrengthLte;
+import android.telephony.CellSignalStrengthNr;
+import android.telephony.CellSignalStrengthWcdma;
+import android.telephony.TelephonyManager;
+import android.telephony.TelephonyManager.CellInfoCallback;
+import android.util.Log;
+
+import com.google.android.chre.nanoapp.proto.ChreCrossValidationWwan;
+import com.google.android.chre.nanoapp.proto.ChreTestCommon;
+import com.google.android.utils.chre.SettingsUtil;
+import com.google.protobuf.InvalidProtocolBufferException;
+
+import org.junit.Assert;
+import org.junit.Assume;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+public class ChreCrossValidatorWwan extends ChreCrossValidatorBase implements Executor {
+    private static final long AWAIT_CELL_INFO_FOR_AP_TIMEOUT_SEC = 7;
+    private static final long AWAIT_RESULT_MESSAGE_TIMEOUT_SEC = 7;
+
+    private static final long NANOAPP_ID = 0x476f6f6754000011L;
+
+    // Maximum difference between signal strength values in dBm. A small
+    // difference is allowed for data updates between AP and CHRE readings.
+    private static final int SIGNAL_STRENGTH_TOLERANCE_DBM = 4;
+
+    // Maximum difference between signal strength values in ASU.
+    // ASU is calculated based on 3GPP RSSI. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
+    private static final int SIGNAL_STRENGTH_TOLERANCE_ASU = 4;
+
+    /** Wwan capabilities flags listed in //system/chre/chre_api/include/chre_api/chre/wwan.h */
+    private static final int WWAN_CAPABILITIES_GET_CELL_INFO = 1;
+
+    private static final int WWAN_CAPABILITIES_GET_CELL_NEIGHBOR_INFO = 2;
+
+    List<CellInfo> mApCellInfo;
+
+    AtomicBoolean mReceivedCapabilites = new AtomicBoolean(false);
+    AtomicBoolean mReceivedCellInfoResults = new AtomicBoolean(false);
+
+    BlockingQueue<CellInfoOrError> mApCellInfoQueue = new ArrayBlockingQueue<>(1);
+
+    private TelephonyManager mTelephonyManager;
+
+    private AtomicReference<ChreCrossValidationWwan.WwanCapabilities> mWwanCapabilities =
+            new AtomicReference<ChreCrossValidationWwan.WwanCapabilities>(null);
+
+    private AtomicReference<ChreCrossValidationWwan.WwanCellInfoResult> mChreCellInfoResult =
+            new AtomicReference<ChreCrossValidationWwan.WwanCellInfoResult>(null);
+
+    private boolean mInitialAirplaneMode;
+    private final SettingsUtil mSettingsUtil;
+
+    public ChreCrossValidatorWwan(
+            ContextHubManager contextHubManager,
+            ContextHubInfo contextHubInfo,
+            NanoAppBinary nanoAppBinary) {
+        super(contextHubManager, contextHubInfo, nanoAppBinary);
+        Assert.assertTrue(
+                "Nanoapp given to cross validator is not the designated chre cross"
+                        + " validation nanoapp.",
+                nanoAppBinary.getNanoAppId() == NANOAPP_ID);
+
+        Context context =
+                androidx.test.platform.app.InstrumentationRegistry.getInstrumentation()
+                        .getTargetContext();
+        mSettingsUtil = new SettingsUtil(context);
+        mTelephonyManager = context.getSystemService(TelephonyManager.class);
+    }
+
+    @Override
+    public void init() throws AssertionError {
+        super.init();
+        mInitialAirplaneMode = mSettingsUtil.isAirplaneModeOn();
+        try {
+            mSettingsUtil.setAirplaneMode(false);
+        } catch (InterruptedException e) {
+            throw new AssertionError("Could not set airplane mode to false.", e);
+        }
+    }
+
+    @Override
+    public void validate() throws AssertionError, InterruptedException {
+        mCollectingData.set(true);
+        requestCapabilities();
+        waitForCapabilitesFromNanoapp();
+        mCollectingData.set(false);
+        verifyCapabilities();
+
+        requestCellInfoRefresh();
+        waitForCellInfoForAp();
+
+        mCollectingData.set(true);
+        requestChreCellInfo();
+        waitForCellInfoResultFromNanoapp();
+        mCollectingData.set(false);
+
+        verifyResult();
+    }
+
+    @Override
+    public void deinit() throws AssertionError {
+        super.deinit();
+        try {
+            mSettingsUtil.setAirplaneMode(mInitialAirplaneMode);
+        } catch (InterruptedException e) {
+            throw new AssertionError("Failed to restore initial airplane mode state.", e);
+        }
+    }
+
+    private void requestCapabilities() {
+        createAndSendMessage(ChreCrossValidationWwan.MessageType.WWAN_CAPABILITIES_REQUEST_VALUE);
+    }
+
+    private void requestChreCellInfo() {
+        createAndSendMessage(ChreCrossValidationWwan.MessageType.WWAN_CELL_INFO_REQUEST_VALUE);
+    }
+
+    private void createAndSendMessage(int type) {
+        NanoAppMessage message =
+                NanoAppMessage.createMessageToNanoApp(
+                        mNappBinary.getNanoAppId(), type, new byte[0]);
+        int result = mContextHubClient.sendMessageToNanoApp(message);
+        if (result != ContextHubTransaction.RESULT_SUCCESS) {
+            Assert.fail("Failed to create and send WWAN message");
+        }
+    }
+
+    private void waitForCapabilitesFromNanoapp() throws InterruptedException {
+        boolean success = mAwaitDataLatch.await(AWAIT_RESULT_MESSAGE_TIMEOUT_SEC, TimeUnit.SECONDS);
+        Assert.assertTrue("Timeout waiting for signal: capabilites message from nanoapp", success);
+        mAwaitDataLatch = new CountDownLatch(1);
+        Assert.assertTrue(
+                "Timed out for capabilites message from nanoapp", mReceivedCapabilites.get());
+        if (mErrorStr.get() != null) {
+            Assert.fail(mErrorStr.get());
+        }
+    }
+
+    private void waitForCellInfoResultFromNanoapp() throws InterruptedException {
+        boolean success = mAwaitDataLatch.await(AWAIT_RESULT_MESSAGE_TIMEOUT_SEC, TimeUnit.SECONDS);
+        Assert.assertTrue("Timeout waiting for signal: cell info message from nanoapp", success);
+        mAwaitDataLatch = new CountDownLatch(1);
+        Assert.assertTrue(
+                "Timed out for cell info message from nanoapp", mReceivedCellInfoResults.get());
+        if (mErrorStr.get() != null) {
+            Assert.fail(mErrorStr.get());
+        }
+    }
+
+    private void waitForCellInfoForAp() throws InterruptedException {
+        CellInfoOrError result =
+                mApCellInfoQueue.poll(AWAIT_CELL_INFO_FOR_AP_TIMEOUT_SEC, TimeUnit.SECONDS);
+        Assert.assertNotNull("Timed out for cell info for AP", result);
+
+        if (result.getErrorCode() != 0 || result.getErrorDetail() != null) {
+            Log.e(TAG, "AP requestCellInfoUpdate failed with detail="
+                    + result.getErrorDetail().getMessage());
+            Assert.fail("AP requestCellInfoUpdate failed with errorCode=" + result.getErrorCode());
+        }
+
+        mApCellInfo = result.getCellInfo();
+    }
+
+    private boolean chreWwanHasBasicCapabilities() {
+        return ((mWwanCapabilities.get().getWwanCapabilities() & WWAN_CAPABILITIES_GET_CELL_INFO)
+                != 0);
+    }
+
+    private boolean chreWwanHasNeighborCapabilities() {
+        return ((mWwanCapabilities.get().getWwanCapabilities()
+                        & WWAN_CAPABILITIES_GET_CELL_NEIGHBOR_INFO)
+                != 0);
+    }
+
+    private void verifyCapabilities() {
+        Assume.assumeTrue(
+                "CHRE WWAN capabilites are insufficient. Skipping test.",
+                chreWwanHasBasicCapabilities());
+
+        Log.i(
+                TAG,
+                "CHRE WWAN provides neighbor info ="
+                        + String.valueOf(chreWwanHasNeighborCapabilities()));
+    }
+
+    private void verifyResult() {
+        verifyCellInfoCount();
+        verifyCellInfoContents();
+    }
+
+    void verifyCellInfoCount() {
+        ChreCrossValidationWwan.WwanCellInfoResult chreCellInfoResult = mChreCellInfoResult.get();
+        List<CellInfo> apCellInfoList = mApCellInfo;
+
+        Log.i(TAG, "AP cell_info result count= " + apCellInfoList.size());
+
+        int chreResultCount = chreCellInfoResult.getCellInfoCount();
+        Log.i(TAG, "CHRE result count=" + chreResultCount);
+
+        if (chreCellInfoResult.getErrorCode() != 0) {
+            Assert.fail("CHRE WWAN results had error=" + chreCellInfoResult.getErrorCode());
+        }
+
+        int expectedResults = apCellInfoList.size();
+        if (!chreWwanHasNeighborCapabilities()) {
+            Log.i(TAG, "CHRE WWAN does not support neighbor info. Limiting count.");
+            // Compare simple count if neighbors are not supported
+            expectedResults = Math.min(expectedResults, 1);
+        }
+
+        Assert.assertEquals(
+                "Unexpected result count from CHRE cell info. Expected="
+                        + expectedResults
+                        + " Actual="
+                        + chreResultCount,
+                expectedResults,
+                chreResultCount);
+    }
+
+    void verifyCellInfoContents() {
+        List<CellInfo> apCellInfoList = mApCellInfo;
+        // Match all CHRE cell infos to AP cell infos
+        // AP cell info entries are removed from the list as they are matched.
+        for (ChreCrossValidationWwan.WwanCellInfo cCi :
+                mChreCellInfoResult.get().getCellInfoList()) {
+            switch (cCi.getCellInfoType()) {
+                case ChreCrossValidationWwan.WwanCellInfoType.WWAN_CELL_INFO_TYPE_NR:
+                    Assert.assertTrue(
+                            "Could not find matching Nr CellInfo",
+                            matchAndRemoveCellInfoNr(cCi, apCellInfoList));
+                    break;
+                case ChreCrossValidationWwan.WwanCellInfoType.WWAN_CELL_INFO_TYPE_LTE:
+                    Assert.assertTrue(
+                            "Could not find matching Lte CellInfo",
+                            matchAndRemoveCellInfoLte(cCi, apCellInfoList));
+                    break;
+                case ChreCrossValidationWwan.WwanCellInfoType.WWAN_CELL_INFO_TYPE_GSM:
+                    Assert.assertTrue(
+                            "Could not find matching Gsm CellInfo",
+                            matchAndRemoveCellInfoGsm(cCi, apCellInfoList));
+                    break;
+                case ChreCrossValidationWwan.WwanCellInfoType.WWAN_CELL_INFO_TYPE_WCDMA:
+                    Assert.assertTrue(
+                            "Could not find matching Wcdma CellInfo",
+                            matchAndRemoveCellInfoWcdma(cCi, apCellInfoList));
+                    break;
+                default:
+                    Assert.fail(
+                            "Can't match CHRE cell info of unknown type: "
+                                    + cCi.getCellInfoType().name());
+            }
+        }
+    }
+
+    @Override
+    protected void parseDataFromNanoAppMessage(NanoAppMessage message) {
+        switch (message.getMessageType()) {
+            case ChreCrossValidationWwan.MessageType.WWAN_NANOAPP_ERROR_VALUE:
+                parseNanoappError(message);
+                break;
+            case ChreCrossValidationWwan.MessageType.WWAN_CAPABILITIES_VALUE:
+                parseCapabilities(message);
+                break;
+            case ChreCrossValidationWwan.MessageType.WWAN_CELL_INFO_RESULTS_VALUE:
+                parseCellInfoResults(message);
+                break;
+            default:
+                setErrorStr("Received message with unexpected type: " + message.getMessageType());
+        }
+        // Each message should countdown the latch no matter success or fail
+        mAwaitDataLatch.countDown();
+    }
+
+    private void parseNanoappError(NanoAppMessage message) {
+        ChreTestCommon.TestResult testResult = null;
+        try {
+            testResult = ChreTestCommon.TestResult.parseFrom(message.getMessageBody());
+        } catch (InvalidProtocolBufferException e) {
+            setErrorStr("Error parsing protobuff: " + e);
+            return;
+        }
+        boolean success = getSuccessFromTestResult(testResult);
+        if (!success) {
+            setErrorStr("Nanoapp error: " + testResult.getErrorMessage().toStringUtf8());
+        }
+    }
+
+    private void parseCapabilities(NanoAppMessage message) {
+        ChreCrossValidationWwan.WwanCapabilities capabilities = null;
+        try {
+            capabilities =
+                    ChreCrossValidationWwan.WwanCapabilities.parseFrom(message.getMessageBody());
+        } catch (InvalidProtocolBufferException e) {
+            setErrorStr("Error parsing protobuff: " + e);
+            return;
+        }
+        mWwanCapabilities.set(capabilities);
+        mReceivedCapabilites.set(true);
+    }
+
+    private void parseCellInfoResults(NanoAppMessage message) {
+        ChreCrossValidationWwan.WwanCellInfoResult result = null;
+        try {
+            result = ChreCrossValidationWwan.WwanCellInfoResult.parseFrom(message.getMessageBody());
+        } catch (InvalidProtocolBufferException e) {
+            setErrorStr("Error parsing protobuff: " + e);
+            return;
+        }
+        mChreCellInfoResult.set(result);
+        mReceivedCellInfoResults.set(true);
+    }
+
+    /**
+     * @return The boolean indicating test result success or failure from TestResult proto message.
+     */
+    private boolean getSuccessFromTestResult(ChreTestCommon.TestResult testResult) {
+        return testResult.getCode() == ChreTestCommon.TestResult.Code.PASSED;
+    }
+
+    String chreCellInfoHeaderToString(ChreCrossValidationWwan.WwanCellInfo cellInfo) {
+        String value = "CellInfoType=" + cellInfo.getCellInfoType().name();
+        value += ", TimestampNs=" + cellInfo.getTimestampNs();
+        value += ", TimestampType=" + cellInfo.getTimestampType().name();
+        value += ", IsRegistered=" + cellInfo.getIsRegistered();
+        value += ", ";
+        return value;
+    }
+
+    String chreCellInfoNrToString(ChreCrossValidationWwan.WwanCellInfo cellInfo) {
+        ChreCrossValidationWwan.CellInfoNr cellInfoNr = cellInfo.getNr();
+        ChreCrossValidationWwan.CellIdentityNr cellIdentityNr = cellInfoNr.getCellIdentity();
+        ChreCrossValidationWwan.SignalStrengthNr signalStrengthNr = cellInfoNr.getSignalStrength();
+        String value = chreCellInfoHeaderToString(cellInfo);
+        value += "Mcc=" + cellIdentityNr.getMcc();
+        value += ", Mnc=" + cellIdentityNr.getMnc();
+        value += ", Nci=" + cellIdentityNr.getNci();
+        value += ", Pci=" + cellIdentityNr.getPci();
+        value += ", Tac=" + cellIdentityNr.getTac();
+        value += ", NrArfcn=" + cellIdentityNr.getNrarfcn();
+        value += ", SsRsrp=" + signalStrengthNr.getSsRsrp();
+        value += ", SsRsrq=" + signalStrengthNr.getSsRsrq();
+        value += ", SsSinr=" + signalStrengthNr.getSsSinr();
+        value += ", CsiRsrp=" + signalStrengthNr.getCsiRsrp();
+        value += ", CsiRsrq=" + signalStrengthNr.getCsiRsrq();
+        value += ", CsiSinr=" + signalStrengthNr.getCsiSinr();
+        return value;
+    }
+
+    String chreCellInfoLteToString(ChreCrossValidationWwan.WwanCellInfo cellInfo) {
+        ChreCrossValidationWwan.CellInfoLte cellInfoLte = cellInfo.getLte();
+        ChreCrossValidationWwan.CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
+        ChreCrossValidationWwan.SignalStrengthLte signalStrengthLte =
+                cellInfoLte.getSignalStrength();
+        String value = chreCellInfoHeaderToString(cellInfo);
+        value += "Mcc=" + cellIdentityLte.getMcc();
+        value += ", Mnc=" + cellIdentityLte.getMnc();
+        value += ", Ci=" + cellIdentityLte.getCi();
+        value += ", Pci=" + cellIdentityLte.getPci();
+        value += ", Tac=" + cellIdentityLte.getTac();
+        value += ", Earfcn=" + cellIdentityLte.getEarfcn();
+        value += ", Signal_strength=" + signalStrengthLte.getSignalStrength();
+        value += ", Rsrp=" + signalStrengthLte.getRsrp();
+        value += ", Rsrq=" + signalStrengthLte.getRsrq();
+        value += ", Rssnr=" + signalStrengthLte.getRssnr();
+        value += ", Cqi=" + signalStrengthLte.getCqi();
+        value += ", TimingAdvance=" + signalStrengthLte.getTimingAdvance();
+        return value;
+    }
+
+    String chreCellInfoGsmToString(ChreCrossValidationWwan.WwanCellInfo cellInfo) {
+        ChreCrossValidationWwan.CellInfoGsm cellInfoGsm = cellInfo.getGsm();
+        ChreCrossValidationWwan.CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
+        ChreCrossValidationWwan.SignalStrengthGsm signalStrengthGsm =
+                cellInfoGsm.getSignalStrength();
+        String value = chreCellInfoHeaderToString(cellInfo);
+        value += "Mcc=" + cellIdentityGsm.getMcc();
+        value += ", Mnc=" + cellIdentityGsm.getMnc();
+        value += ", Lac=" + cellIdentityGsm.getLac();
+        value += ", Cid=" + cellIdentityGsm.getCid();
+        value += ", Arfcn=" + cellIdentityGsm.getArfcn();
+        value += ", Bsic=" + cellIdentityGsm.getBsic();
+        value += ", Signal_strength=" + signalStrengthGsm.getSignalStrength();
+        value += ", Bit_error_rate=" + signalStrengthGsm.getBitErrorRate();
+        value += ", Timing_advance=" + signalStrengthGsm.getTimingAdvance();
+        return value;
+    }
+
+    String chreCellInfoWcdmaToString(ChreCrossValidationWwan.WwanCellInfo cellInfo) {
+        ChreCrossValidationWwan.CellInfoWcdma cellInfoWcdma = cellInfo.getWcdma();
+        ChreCrossValidationWwan.CellIdentityWcdma cellIdentityWcdma =
+                cellInfoWcdma.getCellIdentity();
+        ChreCrossValidationWwan.SignalStrengthWcdma signalStrengthWcdma =
+                cellInfoWcdma.getSignalStrength();
+        String value = chreCellInfoHeaderToString(cellInfo);
+        value += "Mcc=" + cellIdentityWcdma.getMcc();
+        value += ", Mnc=" + cellIdentityWcdma.getMnc();
+        value += ", Lac=" + cellIdentityWcdma.getLac();
+        value += ", Cid=" + cellIdentityWcdma.getCid();
+        value += ", Psc=" + cellIdentityWcdma.getPsc();
+        value += ", Uarfcn=" + cellIdentityWcdma.getUarfcn();
+        value += ", Signal_strength=" + signalStrengthWcdma.getSignalStrength();
+        value += ", Bit_error_rate=" + signalStrengthWcdma.getBitErrorRate();
+        return value;
+    }
+
+    boolean matchAndRemoveCellInfoNr(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfo, List<CellInfo> apCellInfoList) {
+        Log.i(TAG, "CHRE cell info: " + chreCellInfoNrToString(chreCellInfo));
+        Iterator<CellInfo> apCellInfoIterator = apCellInfoList.iterator();
+        while (apCellInfoIterator.hasNext()) {
+            CellInfo apCi = apCellInfoIterator.next();
+            if (apCi instanceof CellInfoNr) {
+                CellInfoNr apCellInfoNr = (CellInfoNr) apCi;
+                if (compareCellIdentityNr(chreCellInfo, apCellInfoNr)
+                        && compareSignalStrengthNr(
+                                chreCellInfo.getNr().getSignalStrength(),
+                                (CellSignalStrengthNr) apCellInfoNr.getCellSignalStrength())) {
+                    apCellInfoIterator.remove();
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    boolean matchAndRemoveCellInfoLte(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfo, List<CellInfo> apCellInfoList) {
+        Log.i(TAG, "CHRE cell info: " + chreCellInfoLteToString(chreCellInfo));
+        Iterator<CellInfo> apCellInfoIterator = apCellInfoList.iterator();
+        while (apCellInfoIterator.hasNext()) {
+            CellInfo apCi = apCellInfoIterator.next();
+            if (apCi instanceof CellInfoLte) {
+                CellInfoLte apCellInfoLte = (CellInfoLte) apCi;
+                if (compareCellIdentityLte(chreCellInfo, apCellInfoLte)
+                        && compareSignalStrengthLte(
+                                chreCellInfo.getLte().getSignalStrength(),
+                                (CellSignalStrengthLte) apCellInfoLte.getCellSignalStrength())) {
+                    apCellInfoIterator.remove();
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    boolean matchAndRemoveCellInfoGsm(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfo, List<CellInfo> apCellInfoList) {
+        Log.i(TAG, "CHRE cell info: " + chreCellInfoGsmToString(chreCellInfo));
+        Iterator<CellInfo> apCellInfoIterator = apCellInfoList.iterator();
+        while (apCellInfoIterator.hasNext()) {
+            CellInfo apCi = apCellInfoIterator.next();
+            if (apCi instanceof CellInfoGsm) {
+                CellInfoGsm apCellInfoGsm = (CellInfoGsm) apCi;
+                if (compareCellIdentityGsm(chreCellInfo, apCellInfoGsm)
+                        && compareSignalStrengthGsm(
+                                chreCellInfo.getGsm().getSignalStrength(),
+                                (CellSignalStrengthGsm) apCellInfoGsm.getCellSignalStrength())) {
+                    apCellInfoIterator.remove();
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    boolean matchAndRemoveCellInfoWcdma(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfo, List<CellInfo> apCellInfoList) {
+        Log.i(TAG, "CHRE cell info: " + chreCellInfoWcdmaToString(chreCellInfo));
+        Iterator<CellInfo> apCellInfoIterator = apCellInfoList.iterator();
+        while (apCellInfoIterator.hasNext()) {
+            CellInfo apCi = apCellInfoIterator.next();
+            if (apCi instanceof CellInfoWcdma) {
+                CellInfoWcdma apCellInfoWcdma = (CellInfoWcdma) apCi;
+                if (compareCellIdentityWcdma(chreCellInfo, apCellInfoWcdma)
+                        && compareSignalStrengthWcdma(
+                                chreCellInfo.getWcdma().getSignalStrength(),
+                                (CellSignalStrengthWcdma)
+                                        apCellInfoWcdma.getCellSignalStrength())) {
+                    apCellInfoIterator.remove();
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    boolean compareCellIdentityNr(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfoNr, CellInfoNr apCellInfoNr) {
+
+        CellIdentityNr apCellIdentityNr = (CellIdentityNr) apCellInfoNr.getCellIdentity();
+        ChreCrossValidationWwan.CellIdentityNr chreCellIdentityNr =
+                chreCellInfoNr.getNr().getCellIdentity();
+
+        // pci, nrarfcn, and is_registered must always be valid
+        if (chreCellIdentityNr.getPci() != apCellIdentityNr.getPci()
+                || chreCellIdentityNr.getNrarfcn() != apCellIdentityNr.getNrarfcn()
+                || chreCellInfoNr.getIsRegistered() != apCellInfoNr.isRegistered()) {
+            return false;
+        }
+
+        // mcc, mnc, nci must be valid for registered cells
+        if (apCellInfoNr.isRegistered()) {
+            if (chreCellIdentityNr.getMcc() != Integer.parseInt(apCellIdentityNr.getMccString())
+                    || chreCellIdentityNr.getMnc()
+                            != Integer.parseInt(apCellIdentityNr.getMncString())
+                    || chreCellIdentityNr.getNci() != apCellIdentityNr.getNci()) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    boolean compareCellIdentityLte(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfoLte, CellInfoLte apCellInfoLte) {
+        CellIdentityLte apCellIdentityLte = (CellIdentityLte) apCellInfoLte.getCellIdentity();
+        ChreCrossValidationWwan.CellIdentityLte chreCellIdentityLte =
+                chreCellInfoLte.getLte().getCellIdentity();
+
+        if (chreCellInfoLte.getIsRegistered() != apCellInfoLte.isRegistered()
+                || chreCellIdentityLte.getMcc()
+                        != parseCellIdentityString(apCellIdentityLte.getMccString())
+                || chreCellIdentityLte.getMnc()
+                        != parseCellIdentityString(apCellIdentityLte.getMncString())
+                || chreCellIdentityLte.getCi() != apCellIdentityLte.getCi()
+                || chreCellIdentityLte.getPci() != apCellIdentityLte.getPci()
+                || chreCellIdentityLte.getTac() != apCellIdentityLte.getTac()
+                || chreCellIdentityLte.getEarfcn() != apCellIdentityLte.getEarfcn()) {
+            return false;
+        }
+
+        return true;
+    }
+
+    boolean compareCellIdentityGsm(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfoGsm, CellInfoGsm apCellInfoGsm) {
+        CellIdentityGsm apCellIdentityGsm = (CellIdentityGsm) apCellInfoGsm.getCellIdentity();
+        ChreCrossValidationWwan.CellIdentityGsm chreCellIdentityGsm =
+                chreCellInfoGsm.getGsm().getCellIdentity();
+        if (chreCellInfoGsm.getIsRegistered() != apCellInfoGsm.isRegistered()
+                || chreCellIdentityGsm.getMcc()
+                        != parseCellIdentityString(apCellIdentityGsm.getMccString())
+                || chreCellIdentityGsm.getMnc()
+                        != parseCellIdentityString(apCellIdentityGsm.getMncString())
+                || chreCellIdentityGsm.getLac() != apCellIdentityGsm.getLac()
+                || chreCellIdentityGsm.getCid() != apCellIdentityGsm.getCid()
+                || chreCellIdentityGsm.getArfcn() != apCellIdentityGsm.getArfcn()
+                || chreCellIdentityGsm.getBsic() != apCellIdentityGsm.getBsic()) {
+            return false;
+        }
+
+        return true;
+    }
+
+    boolean compareCellIdentityWcdma(
+            ChreCrossValidationWwan.WwanCellInfo chreCellInfoWcdma, CellInfoWcdma apCellInfoWcdma) {
+        CellIdentityWcdma apCellIdentityWcdma =
+                (CellIdentityWcdma) apCellInfoWcdma.getCellIdentity();
+        ChreCrossValidationWwan.CellIdentityWcdma chreCellIdentityWcdma =
+                chreCellInfoWcdma.getWcdma().getCellIdentity();
+        if (chreCellInfoWcdma.getIsRegistered() != apCellInfoWcdma.isRegistered()
+                || chreCellIdentityWcdma.getMcc()
+                        != parseCellIdentityString(apCellIdentityWcdma.getMccString())
+                || chreCellIdentityWcdma.getMnc()
+                        != parseCellIdentityString(apCellIdentityWcdma.getMncString())
+                || chreCellIdentityWcdma.getLac() != apCellIdentityWcdma.getLac()
+                || chreCellIdentityWcdma.getCid() != apCellIdentityWcdma.getCid()
+                || chreCellIdentityWcdma.getPsc() != apCellIdentityWcdma.getPsc()
+                || chreCellIdentityWcdma.getUarfcn() != apCellIdentityWcdma.getUarfcn()) {
+            return false;
+        }
+
+        return true;
+    }
+
+    boolean compareSignalStrengthCommon(int chreStrength, int apStrength, int tolerance) {
+        // Check that the difference is within the expected range.
+        int signalDifference = chreStrength - apStrength;
+
+        if (Math.abs(signalDifference) > tolerance) {
+            Log.e(
+                    TAG,
+                    "Mismatch in signal strength. AP="
+                            + apStrength
+                            + " CHRE="
+                            + chreStrength
+                            + " Difference="
+                            + signalDifference
+                            + " Tolerance="
+                            + tolerance);
+            return false;
+        }
+
+        return true;
+    }
+
+    boolean compareSignalStrengthNr(
+            ChreCrossValidationWwan.SignalStrengthNr chreSignalStrengthNr,
+            CellSignalStrengthNr apSignalStrengthNr) {
+        // Note that the CHRE value is inverted by default
+        int chreSsRsrp = (-1 * chreSignalStrengthNr.getSsRsrp());
+        int apSsRsrp = apSignalStrengthNr.getSsRsrp();
+        return compareSignalStrengthCommon(chreSsRsrp, apSsRsrp, SIGNAL_STRENGTH_TOLERANCE_DBM);
+    }
+
+    boolean compareSignalStrengthLte(
+            ChreCrossValidationWwan.SignalStrengthLte chreSignalStrengthLte,
+            CellSignalStrengthLte apSignalStrengthLte) {
+        // Note that the CHRE value is inverted by default
+        int chreRsrp = (-1 * chreSignalStrengthLte.getRsrp());
+        int apRsrp = apSignalStrengthLte.getRsrp();
+        return compareSignalStrengthCommon(chreRsrp, apRsrp, SIGNAL_STRENGTH_TOLERANCE_DBM);
+    }
+
+    boolean compareSignalStrengthGsm(
+            ChreCrossValidationWwan.SignalStrengthGsm chreSignalStrengthGsm,
+            CellSignalStrengthGsm apSignalStrengthGsm) {
+        // CHRE signal_strength and AP rssi are not directly comparable
+        int chreAsu = chreSignalStrengthGsm.getSignalStrength();
+        int apAsu = apSignalStrengthGsm.getAsuLevel();
+        return compareSignalStrengthCommon(chreAsu, apAsu, SIGNAL_STRENGTH_TOLERANCE_ASU);
+    }
+
+    boolean compareSignalStrengthWcdma(
+            ChreCrossValidationWwan.SignalStrengthWcdma chreSignalStrengthWcdma,
+            CellSignalStrengthWcdma apSignalStrengthWcdma) {
+        // CHRE signal_strength and AP rssi are not directly comparable
+        int chreAsu = chreSignalStrengthWcdma.getSignalStrength();
+        int apAsu = apSignalStrengthWcdma.getAsuLevel();
+        return compareSignalStrengthCommon(chreAsu, apAsu, SIGNAL_STRENGTH_TOLERANCE_ASU);
+    }
+
+    class CellInfoOrError {
+        private List<CellInfo> mCellInfo;
+        private int mErrorCode;
+        private Throwable mDetail;
+
+        CellInfoOrError(List<CellInfo> cellInfo) {
+            this.mCellInfo = cellInfo;
+            this.mErrorCode = 0;
+            this.mDetail = null;
+        }
+
+        CellInfoOrError(int errorCode, Throwable detail) {
+            this.mCellInfo = null;
+            this.mErrorCode = errorCode;
+            this.mDetail = detail;
+        }
+
+        public List<CellInfo> getCellInfo() {
+            return mCellInfo;
+        }
+
+        public int getErrorCode() {
+            return mErrorCode;
+        }
+
+        public Throwable getErrorDetail() {
+            return mDetail;
+        }
+    };
+
+    void requestCellInfoRefresh() {
+        CellInfoCallback callback =
+                new CellInfoCallback() {
+                    @Override
+                    public synchronized void onCellInfo(List<CellInfo> cellInfo) {
+                        Log.i(TAG, "Received cell info for AP. onCellInfo invoked");
+                        for (CellInfo apCi : cellInfo) {
+                            Log.i(TAG, "AP cell info: " + apCi.toString());
+                        }
+                        mApCellInfoQueue.add(new CellInfoOrError(cellInfo));
+                    }
+
+                    @Override
+                    public synchronized void onError(int errorCode, Throwable detail) {
+                        mApCellInfoQueue.add(new CellInfoOrError(errorCode, detail));
+                    }
+                };
+
+        mTelephonyManager.requestCellInfoUpdate(this, callback);
+    }
+
+    /** Run the given runnable. Required to support requestCellInfoUpdate */
+    public void execute(Runnable r) {
+        r.run();
+    }
+
+    // Unused. Required to extend ChreCrossValidatorBase.
+    @Override
+    protected void unregisterApDataListener() {}
+
+    /**
+     * @param value A cell identify string value. Can be null.
+     * @return the corresponding integer value, or Integer.MAX_VALUE if value is null.
+     */
+    private int parseCellIdentityString(String value) {
+        return value == null ? Integer.MAX_VALUE : Integer.parseInt(value);
+    }
+}
diff --git a/java/test/endpoint/Android.bp b/java/test/endpoint/Android.bp
new file mode 100644
index 00000000..b35f55e1
--- /dev/null
+++ b/java/test/endpoint/Android.bp
@@ -0,0 +1,36 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_context_hub",
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "system_chre_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["system_chre_license"],
+}
+
+java_library {
+    name: "context-hub-endpoint-test",
+
+    srcs: ["src/**/*.java"],
+
+    static_libs: [
+        "androidx.test.rules",
+        "chre-test-utils",
+    ],
+
+    sdk_version: "test_current",
+}
diff --git a/java/test/endpoint/src/com/google/android/chre/test/endpoint/ContextHubEchoEndpointExecutor.java b/java/test/endpoint/src/com/google/android/chre/test/endpoint/ContextHubEchoEndpointExecutor.java
new file mode 100644
index 00000000..102d1107
--- /dev/null
+++ b/java/test/endpoint/src/com/google/android/chre/test/endpoint/ContextHubEchoEndpointExecutor.java
@@ -0,0 +1,645 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.chre.test.endpoint;
+
+import android.content.Context;
+import android.hardware.contexthub.HubDiscoveryInfo;
+import android.hardware.contexthub.HubEndpoint;
+import android.hardware.contexthub.HubEndpointDiscoveryCallback;
+import android.hardware.contexthub.HubEndpointInfo;
+import android.hardware.contexthub.HubEndpointLifecycleCallback;
+import android.hardware.contexthub.HubEndpointMessageCallback;
+import android.hardware.contexthub.HubEndpointSession;
+import android.hardware.contexthub.HubEndpointSessionResult;
+import android.hardware.contexthub.HubMessage;
+import android.hardware.contexthub.HubServiceInfo;
+import android.hardware.location.ContextHubInfo;
+import android.hardware.location.ContextHubManager;
+import android.hardware.location.ContextHubTransaction;
+import android.hardware.location.NanoAppBinary;
+import android.hardware.location.NanoAppState;
+import android.util.Log;
+import android.util.Pair;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.InstrumentationRegistry;
+
+import com.google.android.utils.chre.ChreTestUtil;
+
+import org.junit.Assert;
+import org.junit.Assume;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+
+/**
+ * A test to validate endpoint connection and messaging with an service on the device. The device
+ * tested in this class is expected to register a test echo service, which must behave as a loopback
+ * service which echoes back a message sent to it with identical payload.
+ */
+public class ContextHubEchoEndpointExecutor {
+    private static final String TAG = "ContextHubEchoEndpointExecutor";
+
+    /** The service descriptor for an echo service. */
+    private static final String ECHO_SERVICE_DESCRIPTOR =
+            "android.hardware.contexthub.test.EchoService";
+
+    private static final int ECHO_SERVICE_MAJOR_VERSION = 1;
+    private static final int ECHO_SERVICE_MINOR_VERSION = 0;
+
+    private static final int TIMEOUT_MESSAGE_SECONDS = 5;
+
+    private static final int TIMEOUT_SESSION_OPEN_SECONDS = 5;
+    private static final int TIMEOUT_DISCOVERY_SECONDS = 5;
+
+    @NonNull private final ContextHubManager mContextHubManager;
+    @Nullable private final ContextHubInfo mContextHubInfo;
+
+    /** The nanoapp binary which publishes a test echo service */
+    @Nullable private final NanoAppBinary mEchoServiceNanoappBinary;
+
+    /** The ID of the above nanoapp */
+    private static final long ECHO_SERVICE_NANOAPP_ID = 0x476f6f6754fffffbL;
+
+    /** The nanoapp binary which connects to a host-side test echo service */
+    @Nullable private final NanoAppBinary mEchoClientNanoappBinary;
+
+    /** The ID of the above nanoapp */
+    private static final long ECHO_CLIENT_NANOAPP_ID = 0x476f6f6754000012L;
+
+    /** A local hub endpoint currently registered with the service. */
+    private HubEndpoint mRegisteredEndpoint = null;
+
+    static class TestLifecycleCallback implements HubEndpointLifecycleCallback {
+        TestLifecycleCallback() {
+            this(/* acceptSession= */ false);
+        }
+
+        TestLifecycleCallback(boolean acceptSession) {
+            mAcceptSession = acceptSession;
+        }
+
+        @Override
+        public HubEndpointSessionResult onSessionOpenRequest(
+                HubEndpointInfo requester, String serviceDescriptor) {
+            Log.d(TAG, "onSessionOpenRequest");
+            HubEndpointSessionResult result =
+                    mAcceptSession
+                            ? HubEndpointSessionResult.accept()
+                            : HubEndpointSessionResult.reject("Unexpected request");
+            mSessionRequestQueue.add(result);
+            return result;
+        }
+
+        @Override
+        public void onSessionOpened(HubEndpointSession session) {
+            Log.d(TAG, "onSessionOpened: session=" + session);
+            mSessionQueue.add(session);
+        }
+
+        @Override
+        public void onSessionClosed(HubEndpointSession session, int reason) {
+            Log.d(TAG, "onSessionClosed: session=" + session);
+            mSessionCloseQueue.add(Pair.create(session, reason));
+        }
+
+        public HubEndpointSession waitForEndpointSession() throws InterruptedException {
+            return mSessionQueue.poll(TIMEOUT_SESSION_OPEN_SECONDS, TimeUnit.SECONDS);
+        }
+
+        public HubEndpointSessionResult waitForOpenSessionRequest() throws InterruptedException {
+            return mSessionRequestQueue.poll(TIMEOUT_SESSION_OPEN_SECONDS, TimeUnit.SECONDS);
+        }
+
+        public Pair<HubEndpointSession, Integer> waitForCloseSession() throws InterruptedException {
+            return mSessionCloseQueue.poll(TIMEOUT_SESSION_OPEN_SECONDS, TimeUnit.SECONDS);
+        }
+
+        /** If true, accepts incoming sessions */
+        private final boolean mAcceptSession;
+
+        private final BlockingQueue<HubEndpointSession> mSessionQueue = new ArrayBlockingQueue<>(1);
+        private final BlockingQueue<HubEndpointSessionResult> mSessionRequestQueue =
+                new ArrayBlockingQueue<>(1);
+        private final BlockingQueue<Pair<HubEndpointSession, Integer>> mSessionCloseQueue =
+                new ArrayBlockingQueue<>(1);
+    }
+
+    static class TestMessageCallback implements HubEndpointMessageCallback {
+        @Override
+        public void onMessageReceived(HubEndpointSession session, HubMessage message) {
+            Log.d(TAG, "onMessageReceived: session=" + session + ", message=" + message);
+            mMessageQueue.add(message);
+        }
+
+        public HubMessage waitForMessage() throws InterruptedException {
+            return mMessageQueue.poll(TIMEOUT_MESSAGE_SECONDS, TimeUnit.SECONDS);
+        }
+
+        private BlockingQueue<HubMessage> mMessageQueue = new ArrayBlockingQueue<>(1);
+    }
+
+    static class TestDiscoveryCallback implements HubEndpointDiscoveryCallback {
+        @Override
+        public void onEndpointsStarted(@NonNull List<HubDiscoveryInfo> discoveryInfoList) {
+            Log.d(TAG, "onEndpointsStarted: discovery size=" + discoveryInfoList.size());
+            mEndpointStartedQueue.add(discoveryInfoList);
+        }
+
+        @Override
+        public void onEndpointsStopped(
+                @NonNull List<HubDiscoveryInfo> discoveryInfoList, int reason) {
+            Log.d(
+                    TAG,
+                    "onEndpointsStarted: discovery size="
+                            + discoveryInfoList.size()
+                            + ", reason="
+                            + reason);
+            mEndpointStoppedQueue.add(Pair.create(discoveryInfoList, reason));
+        }
+
+        public List<HubDiscoveryInfo> waitForStarted() throws InterruptedException {
+            return mEndpointStartedQueue.poll(TIMEOUT_DISCOVERY_SECONDS, TimeUnit.SECONDS);
+        }
+
+        public Pair<List<HubDiscoveryInfo>, Integer> waitForStopped() throws InterruptedException {
+            return mEndpointStoppedQueue.poll(TIMEOUT_DISCOVERY_SECONDS, TimeUnit.SECONDS);
+        }
+
+        private BlockingQueue<List<HubDiscoveryInfo>> mEndpointStartedQueue =
+                new ArrayBlockingQueue<>(1);
+        private BlockingQueue<Pair<List<HubDiscoveryInfo>, Integer>> mEndpointStoppedQueue =
+                new ArrayBlockingQueue<>(1);
+    }
+
+    public ContextHubEchoEndpointExecutor(ContextHubManager manager) {
+        this(
+                manager,
+                /* info= */ null,
+                /* echoServiceNanoappBinary= */ null,
+                /* echoClientNanoappBinary= */ null);
+    }
+
+    public ContextHubEchoEndpointExecutor(
+            ContextHubManager manager,
+            ContextHubInfo info,
+            NanoAppBinary echoServiceNanoappBinary,
+            NanoAppBinary echoClientNanoappBinary) {
+        if (echoServiceNanoappBinary != null) {
+            Assert.assertEquals(echoServiceNanoappBinary.getNanoAppId(), ECHO_SERVICE_NANOAPP_ID);
+        }
+        if (echoClientNanoappBinary != null) {
+            Assert.assertEquals(echoServiceNanoappBinary.getNanoAppId(), ECHO_CLIENT_NANOAPP_ID);
+        }
+        mContextHubManager = manager;
+        mContextHubInfo = info;
+        mEchoServiceNanoappBinary = echoServiceNanoappBinary;
+        mEchoClientNanoappBinary = echoClientNanoappBinary;
+    }
+
+    /** Deinitialization code that should be called in e.g. @After. */
+    public void deinit() {
+        if (mRegisteredEndpoint != null) {
+            unregisterRegisteredEndpointNoThrow();
+        }
+        if (mContextHubInfo != null && mEchoServiceNanoappBinary != null) {
+            List<NanoAppState> stateList =
+                    ChreTestUtil.queryNanoAppsAssertSuccess(mContextHubManager, mContextHubInfo);
+            for (NanoAppState state : stateList) {
+                if (state.getNanoAppId() == ECHO_SERVICE_NANOAPP_ID) {
+                    ChreTestUtil.unloadNanoAppAssertSuccess(
+                            mContextHubManager, mContextHubInfo, state.getNanoAppId());
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks to see if an echo service exists on the device, and validates the endpoint discovery
+     * info contents.
+     *
+     * @return The list of hub discovery info which contains the echo service.
+     */
+    public List<HubDiscoveryInfo> getEchoServiceList() {
+        List<HubDiscoveryInfo> infoList = new ArrayList<>();
+        checkApiSupport(
+                (manager) -> infoList.addAll(manager.findEndpoints(ECHO_SERVICE_DESCRIPTOR)));
+        for (HubDiscoveryInfo info : infoList) {
+            printHubDiscoveryInfo(info);
+            HubEndpointInfo endpointInfo = info.getHubEndpointInfo();
+            Assert.assertNotNull(endpointInfo);
+            // The first valid endpoint info type is 1
+            Assert.assertNotEquals(endpointInfo.getType(), 0);
+            HubEndpointInfo.HubEndpointIdentifier identifier = endpointInfo.getIdentifier();
+            Assert.assertNotNull(identifier);
+
+            HubServiceInfo serviceInfo = info.getHubServiceInfo();
+            Assert.assertNotNull(serviceInfo);
+            Assert.assertEquals(ECHO_SERVICE_DESCRIPTOR, serviceInfo.getServiceDescriptor());
+
+            List<HubDiscoveryInfo> identifierDiscoveryList = new ArrayList<>();
+            checkApiSupport(
+                    (manager) ->
+                            identifierDiscoveryList.addAll(
+                                    manager.findEndpoints(ECHO_SERVICE_DESCRIPTOR)));
+            Assert.assertNotEquals(identifierDiscoveryList.size(), 0);
+        }
+        return infoList;
+    }
+
+    /** Validates that a local endpoint can be registered/unregistered. */
+    public void testDefaultEndpointRegistration() throws Exception {
+        mRegisteredEndpoint = registerDefaultEndpoint();
+        unregisterRegisteredEndpoint();
+    }
+
+    /**
+     * Creates a local endpoint and validates that a session can be opened with the echo service
+     * endpoint.
+     */
+    public void testOpenEndpointSession() throws Exception {
+        List<HubDiscoveryInfo> infoList = getEchoServiceList();
+        for (HubDiscoveryInfo info : infoList) {
+            HubEndpointInfo targetEndpointInfo = info.getHubEndpointInfo();
+            Assert.assertNotNull(targetEndpointInfo);
+            mRegisteredEndpoint = registerDefaultEndpoint();
+            openSessionOrFailNoDescriptor(mRegisteredEndpoint, targetEndpointInfo);
+            unregisterRegisteredEndpoint();
+        }
+    }
+
+    /**
+     * Creates a local endpoint and validates that a session can be opened with the echo service
+     * endpoint, receives an onSessionOpened callback, and the session can be closed.
+     */
+    public void testOpenCloseEndpointSession() throws Exception {
+        List<HubDiscoveryInfo> infoList = getEchoServiceList();
+        for (HubDiscoveryInfo info : infoList) {
+            HubEndpointInfo targetEndpointInfo = info.getHubEndpointInfo();
+
+            TestLifecycleCallback callback = new TestLifecycleCallback();
+            mRegisteredEndpoint = registerDefaultEndpoint(callback, null);
+            openSessionOrFail(mRegisteredEndpoint, targetEndpointInfo);
+            HubEndpointSession session = callback.waitForEndpointSession();
+            Assert.assertEquals(session.getServiceDescriptor(), ECHO_SERVICE_DESCRIPTOR);
+            Assert.assertNotNull(session);
+            session.close();
+
+            unregisterRegisteredEndpoint();
+        }
+    }
+
+    public void testEndpointMessaging() throws Exception {
+        doTestEndpointMessaging(/* executor= */ null);
+    }
+
+    public void testEndpointThreadedMessaging() throws Exception {
+        ScheduledThreadPoolExecutor executor =
+                new ScheduledThreadPoolExecutor(/* corePoolSize= */ 1);
+        doTestEndpointMessaging(executor);
+    }
+
+    /**
+     * Creates a local endpoint and validates that a session can be opened with the echo service
+     * endpoint, receives an onSessionOpened callback, and confirms that a message can be echoed
+     * through the service.
+     *
+     * @param executor An optional executor to invoke callbacks on.
+     */
+    private void doTestEndpointMessaging(@Nullable Executor executor) throws Exception {
+        List<HubDiscoveryInfo> infoList = getEchoServiceList();
+        for (HubDiscoveryInfo info : infoList) {
+            HubEndpointInfo targetEndpointInfo = info.getHubEndpointInfo();
+
+            TestLifecycleCallback callback = new TestLifecycleCallback();
+            TestMessageCallback messageCallback = new TestMessageCallback();
+            mRegisteredEndpoint =
+                    (executor == null)
+                            ? registerDefaultEndpoint(callback, messageCallback)
+                            : registerDefaultEndpoint(callback, messageCallback, executor);
+            openSessionOrFail(mRegisteredEndpoint, targetEndpointInfo);
+            HubEndpointSession session = callback.waitForEndpointSession();
+            Assert.assertNotNull(session);
+            Assert.assertEquals(session.getServiceDescriptor(), ECHO_SERVICE_DESCRIPTOR);
+
+            final int messageType = 1234;
+            HubMessage message =
+                    new HubMessage.Builder(
+                            messageType,
+                            new byte[] {1, 2, 3, 4, 5}).setResponseRequired(true).build();
+            ContextHubTransaction<Void> txn = session.sendMessage(message);
+            Assert.assertNotNull(txn);
+            ContextHubTransaction.Response<Void> txnResponse =
+                    txn.waitForResponse(TIMEOUT_MESSAGE_SECONDS, TimeUnit.SECONDS);
+            Assert.assertNotNull(txnResponse);
+            Assert.assertEquals(txnResponse.getResult(), ContextHubTransaction.RESULT_SUCCESS);
+            HubMessage response = messageCallback.waitForMessage();
+            Assert.assertNotNull(response);
+            Assert.assertEquals(message.getMessageType(), response.getMessageType());
+            Assert.assertTrue(
+                    "Echo message unidentical. Expected: "
+                            + Arrays.toString(message.getMessageBody())
+                            + ", actual: "
+                            + Arrays.toString(response.getMessageBody()),
+                    Arrays.equals(message.getMessageBody(), response.getMessageBody()));
+            session.close();
+
+            unregisterRegisteredEndpoint();
+        }
+    }
+
+    public void testEndpointDiscovery() throws Exception {
+        doTestEndpointDiscovery(/* executor= */ null);
+    }
+
+    public void testThreadedEndpointDiscovery() throws Exception {
+        ScheduledThreadPoolExecutor executor =
+                new ScheduledThreadPoolExecutor(/* corePoolSize= */ 1);
+        doTestEndpointDiscovery(executor);
+    }
+
+    /**
+     * Registers an endpoint discovery callback for endpoints with the echo service descriptor.
+     *
+     * @param executor An optional executor to invoke callbacks on.
+     */
+    private void doTestEndpointDiscovery(@Nullable Executor executor) throws Exception {
+        TestDiscoveryCallback callback = new TestDiscoveryCallback();
+        if (executor != null) {
+            checkApiSupport(
+                    (manager) ->
+                            manager.registerEndpointDiscoveryCallback(
+                                    executor, callback, ECHO_SERVICE_DESCRIPTOR));
+        } else {
+            checkApiSupport(
+                    (manager) ->
+                            manager.registerEndpointDiscoveryCallback(
+                                    callback, ECHO_SERVICE_DESCRIPTOR));
+        }
+
+        checkDynamicEndpointDiscovery(callback);
+        checkApiSupport((manager) -> manager.unregisterEndpointDiscoveryCallback(callback));
+    }
+
+    public void testEndpointIdDiscovery() throws Exception {
+        doTestEndpointIdDiscovery(/* executor= */ null);
+    }
+
+    public void testThreadedEndpointIdDiscovery() throws Exception {
+        ScheduledThreadPoolExecutor executor =
+                new ScheduledThreadPoolExecutor(/* corePoolSize= */ 1);
+        doTestEndpointIdDiscovery(executor);
+    }
+
+    /**
+     * Registers an endpoint discovery callback for endpoints with the echo message nanoapp ID.
+     *
+     * @param executor An optional executor to invoke callbacks on.
+     */
+    private void doTestEndpointIdDiscovery(@Nullable Executor executor) throws Exception {
+        TestDiscoveryCallback callback = new TestDiscoveryCallback();
+        if (executor != null) {
+            checkApiSupport(
+                    (manager) ->
+                            manager.registerEndpointDiscoveryCallback(
+                                    executor, callback, ECHO_SERVICE_NANOAPP_ID));
+        } else {
+            checkApiSupport(
+                    (manager) ->
+                            manager.registerEndpointDiscoveryCallback(
+                                    callback, ECHO_SERVICE_NANOAPP_ID));
+        }
+
+        checkDynamicEndpointDiscovery(callback);
+        checkApiSupport((manager) -> manager.unregisterEndpointDiscoveryCallback(callback));
+    }
+
+    /**
+     * A test to see if a echo test service can be registered by the application.
+     *
+     * <p>For CHRE-capable devices, we will also confirm that a connection can be started from the
+     * embedded client and echo works as intended. The echo client nanoapp is expected to open a
+     * session with the host-side service when the nanoapp is loaded, and sends a message to echo
+     * back to the nanoapp once the session is opened.
+     */
+    public void testApplicationEchoService() throws Exception {
+        Collection<HubServiceInfo> serviceList = new ArrayList<>();
+        HubServiceInfo.Builder builder =
+                new HubServiceInfo.Builder(
+                        ECHO_SERVICE_DESCRIPTOR,
+                        HubServiceInfo.FORMAT_CUSTOM,
+                        ECHO_SERVICE_MAJOR_VERSION,
+                        ECHO_SERVICE_MINOR_VERSION);
+        HubServiceInfo info = builder.build();
+        Assert.assertNotNull(info);
+        serviceList.add(info);
+
+        TestLifecycleCallback callback = new TestLifecycleCallback(/* acceptSession= */ true);
+        TestMessageCallback messageCallback = new TestMessageCallback();
+        mRegisteredEndpoint =
+                registerDefaultEndpoint(
+                        callback, messageCallback, /* executor= */ null, serviceList);
+
+        // TODO(b/385765805): Enable when ready
+        boolean isDynamicLoadingSupported = false;
+        if (isDynamicLoadingSupported
+                && mContextHubInfo != null
+                && mEchoClientNanoappBinary != null) {
+            ChreTestUtil.loadNanoAppAssertSuccess(
+                    mContextHubManager, mContextHubInfo, mEchoClientNanoappBinary);
+            HubEndpointSessionResult result = callback.waitForOpenSessionRequest();
+            Assert.assertNotNull(result);
+            Assert.assertTrue(result.isAccepted());
+            HubEndpointSession session = callback.waitForEndpointSession();
+            Assert.assertNotNull(session);
+            Log.d(TAG, "Session open: " + session);
+
+            HubMessage message = messageCallback.waitForMessage();
+            Assert.assertNotNull(message);
+            HubMessage outMessage =
+                    new HubMessage.Builder(message.getMessageType(), message.getMessageBody())
+                            .setResponseRequired(true)
+                            .build();
+            ContextHubTransaction<Void> txn = session.sendMessage(outMessage);
+            Assert.assertNotNull(txn);
+            ContextHubTransaction.Response<Void> txnResponse =
+                    txn.waitForResponse(TIMEOUT_MESSAGE_SECONDS, TimeUnit.SECONDS);
+            Assert.assertNotNull(txnResponse);
+            Assert.assertEquals(txnResponse.getResult(), ContextHubTransaction.RESULT_SUCCESS);
+
+            ChreTestUtil.unloadNanoAppAssertSuccess(
+                    mContextHubManager, mContextHubInfo, mEchoClientNanoappBinary.getNanoAppId());
+            Pair<HubEndpointSession, Integer> closeResult = callback.waitForCloseSession();
+            Assert.assertNotNull(closeResult);
+            Assert.assertNotNull(closeResult.first);
+            Log.d(TAG, "Session closed: " + closeResult.first);
+            Assert.assertEquals(session, closeResult.first);
+            Assert.assertNotNull(closeResult.second);
+            Assert.assertEquals(closeResult.second.intValue(), HubEndpoint.REASON_ENDPOINT_STOPPED);
+        }
+
+        unregisterRegisteredEndpoint();
+    }
+
+    private void printHubDiscoveryInfo(HubDiscoveryInfo info) {
+        Log.d(TAG, "Found hub: ");
+        Log.d(TAG, " - Endpoint info: " + info.getHubEndpointInfo());
+        Log.d(TAG, " - Service info: " + info.getHubServiceInfo());
+    }
+
+    private HubEndpoint registerDefaultEndpoint() {
+        return registerDefaultEndpoint(
+                /* callback= */ null,
+                /* messageCallback= */ null,
+                /* executor= */ null,
+                Collections.emptyList());
+    }
+
+    private HubEndpoint registerDefaultEndpoint(
+            HubEndpointLifecycleCallback callback, HubEndpointMessageCallback messageCallback) {
+        return registerDefaultEndpoint(
+                callback, messageCallback, /* executor= */ null, Collections.emptyList());
+    }
+
+    private HubEndpoint registerDefaultEndpoint(
+            HubEndpointLifecycleCallback callback,
+            HubEndpointMessageCallback messageCallback,
+            Executor executor) {
+        return registerDefaultEndpoint(
+                callback, messageCallback, executor, Collections.emptyList());
+    }
+
+    private HubEndpoint registerDefaultEndpoint(
+            HubEndpointLifecycleCallback callback,
+            HubEndpointMessageCallback messageCallback,
+            Executor executor,
+            Collection<HubServiceInfo> serviceList) {
+        Assert.assertNotNull(serviceList);
+        Context context = InstrumentationRegistry.getTargetContext();
+        HubEndpoint.Builder builder = new HubEndpoint.Builder(context);
+        builder.setTag(TAG);
+        if (callback != null) {
+            if (executor != null) {
+                builder.setLifecycleCallback(executor, callback);
+            } else {
+                builder.setLifecycleCallback(callback);
+            }
+        }
+        if (messageCallback != null) {
+            if (executor != null) {
+                builder.setMessageCallback(executor, messageCallback);
+            } else {
+                builder.setMessageCallback(messageCallback);
+            }
+        }
+        builder.setServiceInfoCollection(serviceList);
+        HubEndpoint endpoint = builder.build();
+        Assert.assertNotNull(endpoint);
+        Assert.assertEquals(endpoint.getTag(), TAG);
+        Assert.assertEquals(endpoint.getLifecycleCallback(), callback);
+        Assert.assertEquals(endpoint.getMessageCallback(), messageCallback);
+        Assert.assertEquals(endpoint.getServiceInfoCollection().size(), serviceList.size());
+
+        checkApiSupport((manager) -> manager.registerEndpoint(endpoint));
+        return endpoint;
+    }
+
+    private void openSessionOrFail(HubEndpoint endpoint, HubEndpointInfo target) {
+        checkApiSupport(
+                (manager) -> manager.openSession(endpoint, target, ECHO_SERVICE_DESCRIPTOR));
+    }
+
+    /**
+     * Same as openSessionOrFail but with no service descriptor.
+     */
+    private void openSessionOrFailNoDescriptor(HubEndpoint endpoint, HubEndpointInfo target) {
+        checkApiSupport((manager) -> manager.openSession(endpoint, target));
+    }
+
+    private void unregisterRegisteredEndpointNoThrow() {
+        try {
+            unregisterRegisteredEndpoint();
+        } catch (Exception e) {
+            Log.e(TAG, "Exception when unregistering endpoint", e);
+        }
+    }
+
+    private void unregisterRegisteredEndpoint() throws AssertionError {
+        checkApiSupport((manager) -> manager.unregisterEndpoint(mRegisteredEndpoint));
+        mRegisteredEndpoint = null;
+    }
+
+    private void checkApiSupport(Consumer<ContextHubManager> consumer) {
+        try {
+            consumer.accept(mContextHubManager);
+        } catch (UnsupportedOperationException e) {
+            // Forced assumption
+            Assume.assumeTrue("Skipping endpoint test on unsupported device", false);
+        }
+    }
+
+    private void checkDynamicEndpointDiscovery(TestDiscoveryCallback callback) throws Exception {
+        // TODO(b/385765805): Enable when ready
+        boolean isDynamicLoadingSupported = false;
+        if (isDynamicLoadingSupported
+                && mContextHubInfo != null
+                && mEchoServiceNanoappBinary != null) {
+            ChreTestUtil.loadNanoAppAssertSuccess(
+                    mContextHubManager, mContextHubInfo, mEchoServiceNanoappBinary);
+            List<HubDiscoveryInfo> discoveryList = callback.waitForStarted();
+            Assert.assertNotNull(discoveryList);
+            Assert.assertNotEquals(discoveryList.size(), 0);
+            Assert.assertTrue(checkNanoappInDiscoveryList(discoveryList));
+
+            ChreTestUtil.unloadNanoAppAssertSuccess(
+                    mContextHubManager, mContextHubInfo, mEchoServiceNanoappBinary.getNanoAppId());
+            Pair<List<HubDiscoveryInfo>, Integer> discoveryListAndReason =
+                    callback.waitForStopped();
+            Assert.assertNotNull(discoveryListAndReason);
+            discoveryList = discoveryListAndReason.first;
+            Assert.assertNotNull(discoveryList);
+            Assert.assertNotEquals(discoveryList.size(), 0);
+            Assert.assertTrue(checkNanoappInDiscoveryList(discoveryList));
+            Integer reason = discoveryListAndReason.second;
+            Assert.assertNotNull(reason);
+            Assert.assertEquals(reason.intValue(), HubEndpoint.REASON_ENDPOINT_STOPPED);
+        }
+    }
+
+    private boolean checkNanoappInDiscoveryList(List<HubDiscoveryInfo> discoveryList) {
+        for (HubDiscoveryInfo info : discoveryList) {
+            Assert.assertNotNull(info);
+            HubEndpointInfo endpointInfo = info.getHubEndpointInfo();
+            Assert.assertNotNull(endpointInfo);
+            HubEndpointInfo.HubEndpointIdentifier id = endpointInfo.getIdentifier();
+            Assert.assertNotNull(id);
+            if (id.getEndpoint() == ECHO_SERVICE_NANOAPP_ID) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/java/test/settings/src/com/google/android/chre/test/setting/ContextHubWwanSettingsTestExecutor.java b/java/test/settings/src/com/google/android/chre/test/setting/ContextHubWwanSettingsTestExecutor.java
index c7f726fc..d07393dc 100644
--- a/java/test/settings/src/com/google/android/chre/test/setting/ContextHubWwanSettingsTestExecutor.java
+++ b/java/test/settings/src/com/google/android/chre/test/setting/ContextHubWwanSettingsTestExecutor.java
@@ -71,6 +71,8 @@ public class ContextHubWwanSettingsTestExecutor {
     private void runTest(boolean enableFeature) throws InterruptedException {
         boolean airplaneModeExpected = !enableFeature;
         mSettingsUtil.setAirplaneMode(airplaneModeExpected);
+        // Wait for setting to propagate to modem.
+        Thread.sleep(1000 /*millis*/);
 
         ChreSettingsTest.TestCommand.State state = enableFeature
                 ? ChreSettingsTest.TestCommand.State.ENABLED
diff --git a/java/test/utils/src/com/google/android/utils/chre/ChreTestUtil.java b/java/test/utils/src/com/google/android/utils/chre/ChreTestUtil.java
index f1214a56..d05dc5b6 100644
--- a/java/test/utils/src/com/google/android/utils/chre/ChreTestUtil.java
+++ b/java/test/utils/src/com/google/android/utils/chre/ChreTestUtil.java
@@ -47,7 +47,7 @@ import java.util.concurrent.TimeoutException;
  */
 public class ChreTestUtil {
     // Various timeouts for Context Hub operations.
-    private static final long TIMEOUT_LOAD_NANOAPP_SECONDS = 5;
+    private static final long TIMEOUT_LOAD_NANOAPP_SECONDS = 30;
     private static final long TIMEOUT_UNLOAD_NANOAPP_SECONDS = 5;
     private static final long QUERY_NANOAPPS_TIMEOUT_SECONDS = 5;
 
@@ -313,4 +313,22 @@ public class ChreTestUtil {
                 .that(isCountedDown)
                 .isTrue();
     }
+
+    /**
+     * Restrict other applications from accessing sensors.
+     * Should be called before validating data.
+     */
+    public static void restrictSensors(String packageName) {
+        executeShellCommand(InstrumentationRegistry.getInstrumentation(),
+                "dumpsys sensorservice restrict " + packageName);
+    }
+
+    /**
+     * Unrestrict other applications from accessing sensors.
+     * Should be called after validating data.
+     */
+    public static void unrestrictSensors() {
+        executeShellCommand(
+                InstrumentationRegistry.getInstrumentation(), "dumpsys sensorservice enable");
+    }
 }
diff --git a/platform/CMakeLists.txt b/platform/CMakeLists.txt
index 7f2d2a99..0d0a7b1c 100644
--- a/platform/CMakeLists.txt
+++ b/platform/CMakeLists.txt
@@ -308,6 +308,18 @@ pw_add_facade(chre.platform.system_timer INTERFACE
     chre.variant.config
 )
 
+pw_add_facade(chre.platform.tagged_log INTERFACE
+  BACKEND
+    chre.platform.tagged_log_BACKEND
+  HEADERS
+    include/chre/platform/tagged_log.h
+  PUBLIC_INCLUDES
+    include
+  PUBLIC_DEPS
+    chre.util
+    chre.variant.config
+)
+
 pw_add_facade(chre.platform.thread_handle INTERFACE
   BACKEND
     chre.platform.thread_handle_BACKEND
diff --git a/platform/backend.cmake b/platform/backend.cmake
index 91d0712c..c1702e31 100644
--- a/platform/backend.cmake
+++ b/platform/backend.cmake
@@ -77,6 +77,9 @@ pw_add_backend_variable(chre.platform.system_time_BACKEND)
 # Backend for chre.platform.system_timer.
 pw_add_backend_variable(chre.platform.system_timer_BACKEND)
 
+# Backend for chre.platform.tagged_log.
+pw_add_backend_variable(chre.platform.tagged_log_BACKEND)
+
 # Backend for chre.platform.thread_handle.
 pw_add_backend_variable(chre.platform.thread_handle_BACKEND)
 
diff --git a/platform/exynos/host_link.cc b/platform/exynos/host_link.cc
index 5dfa7ce3..ffde4757 100644
--- a/platform/exynos/host_link.cc
+++ b/platform/exynos/host_link.cc
@@ -222,12 +222,12 @@ void HostMessageHandlers::handleNanConfigurationUpdate(bool /* enabled */) {
 }
 
 void HostMessageHandlers::handleBtSocketOpen(
-    uint16_t /* hostClientId */, uint64_t /* socketId */,
-    const char * /* name */, uint64_t /* endpointId */, uint64_t /* hubId */,
-    uint32_t /* aclConnectionHandle */, uint32_t /* localCid */,
-    uint32_t /* remoteCid */, uint32_t /* psm */, uint32_t /* localMtu */,
-    uint32_t /* remoteMtu */, uint32_t /* localMps */, uint32_t /* remoteMps */,
-    uint32_t /* initialRxCredits */, uint32_t /* initialTxCredits */) {
+    uint64_t /* hubId */, const BleL2capCocSocketData & /* socketData */,
+    const char * /* name */, uint32_t /* psm */) {
+  LOGE("BT Socket offload not supported");
+}
+
+void HostMessageHandlers::handleBtSocketCapabilitiesRequest() {
   LOGE("BT Socket offload not supported");
 }
 
diff --git a/platform/include/chre/platform/assert.h b/platform/include/chre/platform/assert.h
index be83a360..1e0917c3 100644
--- a/platform/include/chre/platform/assert.h
+++ b/platform/include/chre/platform/assert.h
@@ -36,7 +36,7 @@
 
 #elif defined(CHRE_ASSERTIONS_ENABLED)
 
-#include "chre/target_platform/assert.h"
+#include "chre/target_platform/assert.h"  // IWYU pragma: export
 
 #ifndef CHRE_ASSERT
 #error "CHRE_ASSERT must be defined by the target platform's assert.h"
diff --git a/platform/include/chre/platform/log.h b/platform/include/chre/platform/log.h
index f236e586..054e51b5 100644
--- a/platform/include/chre/platform/log.h
+++ b/platform/include/chre/platform/log.h
@@ -35,8 +35,8 @@
  * the log levels Error, Warning, Informational, and Debug, respectively.
  */
 
-#include "chre/target_platform/log.h"
-#include "chre/util/log_common.h"
+#include "chre/target_platform/log.h"  // IWYU pragma: export
+#include "chre/util/log_common.h"      // IWYU pragma: export
 
 #ifndef LOGE
 #error "LOGE must be defined by chre/target_platform/log.h"
diff --git a/platform/include/chre/platform/tagged_log.h b/platform/include/chre/platform/tagged_log.h
new file mode 100644
index 00000000..f4021e4a
--- /dev/null
+++ b/platform/include/chre/platform/tagged_log.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHRE_PLATFORM_TAGGED_LOG_H_
+#define CHRE_PLATFORM_TAGGED_LOG_H_
+
+/**
+ * @file
+ * Includes the appropriate platform-specific header file that supplies logging
+ * capabilities. The platform header file must supply these symbols, either as
+ * macros or free functions:
+ *
+ *   TLOGE(format, ...)
+ *   TLOGW(format, ...)
+ *   TLOGI(format, ...)
+ *   TLOGD(format, ...)
+ *
+ * The platform header is recommend to also supply TLOGV for verbose logs,
+ * however it is not required.
+ *
+ * Where "format" is a printf-style format string, and E, W, I, D correspond to
+ * the log levels Error, Warning, Informational, and Debug, respectively.
+ */
+
+#include "chre/target_platform/tagged_log.h"
+#include "chre/util/log_common.h"
+
+#ifndef TLOGE
+#error "TLOGE must be defined by chre/target_platform/tagged_log.h"
+#endif  // TLOGE
+
+#ifndef TLOGW
+#error "TLOGW must be defined by chre/target_platform/tagged_log.h"
+#endif  // TLOGW
+
+#ifndef TLOGI
+#error "TLOGI must be defined by chre/target_platform/tagged_log.h"
+#endif  // TLOGI
+
+#ifndef TLOGD
+#error "TLOGD must be defined by chre/target_platform/tagged_log.h"
+#endif  // TLOGD
+
+#ifndef TLOGV
+// Map TLOGV to TLOGD if the platform doesn't supply it - in that case TLOGV won't
+// be distinguished at runtime from TLOGD, but we'll still retain the ability to
+// compile out TLOGV based on CHRE_MINIMUM_LOG_LEVEL
+#define TLOGV TLOGD
+#endif
+
+/*
+ * Supply a stub implementation of the LOGx macros when the build is
+ * configured with a minimum logging level that is above the requested level.
+ */
+
+#ifndef CHRE_MINIMUM_LOG_LEVEL
+#error "CHRE_MINIMUM_LOG_LEVEL must be defined"
+#endif  // CHRE_MINIMUM_LOG_LEVEL
+
+#if CHRE_MINIMUM_LOG_LEVEL < CHRE_LOG_LEVEL_ERROR
+#undef TLOGE
+#define TLOGE(format, ...) CHRE_LOG_NULL(format, ##__VA_ARGS__)
+#endif
+
+#if CHRE_MINIMUM_LOG_LEVEL < CHRE_LOG_LEVEL_WARN
+#undef TLOGW
+#define TLOGW(format, ...) CHRE_LOG_NULL(format, ##__VA_ARGS__)
+#endif
+
+#if CHRE_MINIMUM_LOG_LEVEL < CHRE_LOG_LEVEL_INFO
+#undef TLOGI
+#define TLOGI(format, ...) CHRE_LOG_NULL(format, ##__VA_ARGS__)
+#endif
+
+#if CHRE_MINIMUM_LOG_LEVEL < CHRE_LOG_LEVEL_DEBUG
+#undef TLOGD
+#define TLOGD(format, ...) CHRE_LOG_NULL(format, ##__VA_ARGS__)
+#endif
+
+#if CHRE_MINIMUM_LOG_LEVEL < CHRE_LOG_LEVEL_VERBOSE
+#undef TLOGV
+#define TLOGV(format, ...) CHRE_LOG_NULL(format, ##__VA_ARGS__)
+#endif
+
+#endif  // CHRE_PLATFORM_TAGGED_LOG_H_
diff --git a/platform/linux/memory.cc b/platform/linux/memory.cc
index ad92c85c..4db8c2d1 100644
--- a/platform/linux/memory.cc
+++ b/platform/linux/memory.cc
@@ -36,4 +36,6 @@ void palSystemApiMemoryFree(void *pointer) {
   free(pointer);
 }
 
+void forceDramAccess() {}
+
 }  // namespace chre
diff --git a/platform/platform.mk b/platform/platform.mk
index 8dd0d610..e66e3bba 100644
--- a/platform/platform.mk
+++ b/platform/platform.mk
@@ -29,6 +29,7 @@ SLPI_CFLAGS += -I$(SLPI_PREFIX)/platform/rtld/inc
 
 SLPI_CFLAGS += -Iplatform/shared/aligned_alloc_unsupported/include
 SLPI_CFLAGS += -Iplatform/shared/include
+SLPI_CFLAGS += -Iplatform/shared/fbs/include
 SLPI_CFLAGS += -Iplatform/slpi/include
 
 # We use FlatBuffers in the SLPI platform layer
@@ -49,6 +50,7 @@ SLPI_SEE_CFLAGS += -I$(SLPI_PREFIX)/ssc/goog/api
 SLPI_SEE_CFLAGS += -I$(SLPI_PREFIX)/ssc/inc
 SLPI_SEE_CFLAGS += -I$(SLPI_PREFIX)/ssc/inc/internal
 SLPI_SEE_CFLAGS += -I$(SLPI_PREFIX)/ssc/inc/utils/nanopb
+SLPI_SEE_CFLAGS += -Iplatform/shared/fbs/include
 
 SLPI_SEE_CFLAGS += -Iplatform/slpi/see/include
 
@@ -96,6 +98,7 @@ SLPI_SRCS += platform/shared/assert.cc
 SLPI_SRCS += platform/shared/chre_api_audio.cc
 SLPI_SRCS += platform/shared/chre_api_core.cc
 SLPI_SRCS += platform/shared/chre_api_gnss.cc
+SLPI_SRCS += platform/shared/chre_api_msg.cc
 SLPI_SRCS += platform/shared/chre_api_re.cc
 SLPI_SRCS += platform/shared/chre_api_user_settings.cc
 SLPI_SRCS += platform/shared/chre_api_version.cc
@@ -221,6 +224,7 @@ SIM_SRCS += platform/shared/chre_api_audio.cc
 SIM_SRCS += platform/shared/chre_api_ble.cc
 SIM_SRCS += platform/shared/chre_api_core.cc
 SIM_SRCS += platform/shared/chre_api_gnss.cc
+SIM_SRCS += platform/shared/chre_api_msg.cc
 SIM_SRCS += platform/shared/chre_api_re.cc
 SIM_SRCS += platform/shared/chre_api_sensor.cc
 SIM_SRCS += platform/shared/chre_api_user_settings.cc
@@ -313,6 +317,7 @@ GOOGLE_ARM64_ANDROID_CFLAGS += -Ihost/common/include
 
 # Also add the linux sources to fall back to the default Linux implementation.
 GOOGLE_ARM64_ANDROID_CFLAGS += -Iplatform/linux/include
+GOOGLE_ARM64_ANDROID_CFLAGS += -Iplatform/shared/fbs/include
 
 # We use FlatBuffers in the Android simulator
 GOOGLE_ARM64_ANDROID_CFLAGS += -I$(FLATBUFFERS_PATH)/include
@@ -393,6 +398,7 @@ EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_audio.cc
 EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_ble.cc
 EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_core.cc
 EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_gnss.cc
+EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_msg.cc
 EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_re.cc
 EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_user_settings.cc
 EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_version.cc
@@ -414,6 +420,7 @@ EMBOS_SRCS += $(CHRE_PREFIX)/platform/shared/nanoapp_loader.cc
 
 # Exynos specific compiler flags
 EXYNOS_CFLAGS += -I$(CHRE_PREFIX)/platform/exynos/include
+EXYNOS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/fbs/include
 EXYNOS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/audio_pal/include
 
 EXYNOS_SRCS += $(CHRE_PREFIX)/platform/exynos/chre_api_re.cc
@@ -480,6 +487,7 @@ TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_audio.cc
 TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_ble.cc
 TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_core.cc
 TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_gnss.cc
+TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_msg.cc
 TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_re.cc
 TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_user_settings.cc
 TINYSYS_SRCS += $(CHRE_PREFIX)/platform/shared/chre_api_version.cc
@@ -540,6 +548,7 @@ TINYSYS_PLATFORM = mt6989
 TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/freertos/include
 TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/aligned_alloc_unsupported/include
 TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/include
+TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/fbs/include
 TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/nanoapp/include
 TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/public_platform_ble_pal
 TINYSYS_CFLAGS += -I$(CHRE_PREFIX)/platform/shared/public_platform_debug_dump_manager
diff --git a/platform/shared/CMakeLists.txt b/platform/shared/CMakeLists.txt
index f6beab87..eb85ebcd 100644
--- a/platform/shared/CMakeLists.txt
+++ b/platform/shared/CMakeLists.txt
@@ -1,4 +1,5 @@
 include($ENV{PW_ROOT}/pw_build/pigweed.cmake)
+include($ENV{PW_ROOT}/pw_flatbuffers/flatbuffers.cmake)
 include(backend.cmake)
 
 pw_add_facade(chre.platform.shared.authentication INTERFACE
@@ -128,6 +129,43 @@ pw_add_library(chre.platform.shared.chre_api_gnss STATIC
     chre.util.system
 )
 
+# Implements chre_api/chre/msg.h's:
+# - bool chreMsgGetEndpointInfo(uint64_t hubId, uint64_t endpointId,
+#                               struct chreMsgEndpointInfo *info)
+# - size_t chreMsgGetEndpointServiceCount(uint64_t hubId, uint64_t endpointId)
+# - bool chreMsgGetEndpointServices(uint64_t hubId, uint64_t endpointId,
+#                                   struct chreMsgEndpointServiceInfo *services,
+#                                   size_t *numServices)
+# - bool chreMsgConfigureEndpointNotifications(uint64_t hubId,
+#                                              uint64_t endpointId,
+#                                              bool enable)
+# - bool chreMsgGetSessionInfo(uint16_t sessionId,
+#                              struct chreMsgEndpointSessionInfo *info)
+# - bool chreMsgPublishRpcServices(struct chreMsgEndpointServiceInfo *services,
+#                                  size_t numServices)
+# - uint16_t chreMsgOpenEndpointSessionAsync(uint64_t hubId,
+#                                            uint64_t endpointId)
+# - uint16_t chreMsgOpenEndpointSessionWithServiceAsync(
+#       uint64_t hubId, uint64_t endpointId, const char *serviceDescriptor)
+# - uint16_t chreMsgOpenDefaultEndpointSessionAsync(uint64_t endpointId)
+# - uint16_t chreMsgOpenDefaultEndpointSessionWithServiceAsync(
+#       uint64_t endpointId, const char *serviceDescriptor)
+# - uint16_t chreMsgOpenServiceEndpointSessionAsync(const char *serviceDescriptor)
+# - bool chreMsgCloseEndpointSessionAsync(uint16_t sessionId)
+# - bool chreMsgSendReliableEndpointMessageAsync(
+#       void *message, size_t messageSize, uint32_t messageType,
+#       uint16_t sessionId, uint32_t messagePermissions,
+#       chreMessageFreeFunction *freeCallback, const void *cookie)
+pw_add_library(chre.platform.shared.chre_api_msg STATIC
+  SOURCES
+    chre_api_msg.cc
+  PRIVATE_DEPS
+    chre.chre_api.facade
+    chre.core
+    chre.util
+    chre.util.system
+)
+
 # Implements chre_api/chre/re.h's:
 # - uint32_t chreGetCapabilities()
 # - uint32_t chreGetMessageToHostMaxSize()
@@ -265,13 +303,18 @@ pw_add_library(chre.platform.shared.dlfcn STATIC
     chre.util
 )
 
-pw_add_library(chre.platform.shared.generated.host_messages_generated INTERFACE
-  HEADERS
-    include/chre/platform/shared/generated/host_messages_generated.h
-  PUBLIC_INCLUDES
-    include
-  PUBLIC_DEPS
+pw_flatbuffer_library(chre.platform.shared.idl.host_messages_generated
+  SOURCES
+    idl/host_messages.fbs
+  FLATC_FLAGS
+    --scoped-enums
+    --cpp-ptr-type chre::UniquePtr
+  DEPS
     chre_third_party.flatbuffers
+  PREFIX
+    chre/platform/shared/fbs
+  STRIP_PREFIX
+    idl
 )
 
 pw_add_library(chre.platform.shared.host_protocol_chre STATIC
@@ -281,10 +324,11 @@ pw_add_library(chre.platform.shared.host_protocol_chre STATIC
     include
   PUBLIC_DEPS
     chre.core
-    chre.platform.shared.generated.host_messages_generated
+    chre.platform.shared.idl.host_messages_generated.cpp
     chre.platform.shared.host_protocol_common
     chre.util
     chre.util.flatbuffers
+    chre.util.system
     chre.chre_api
     chre_third_party.flatbuffers
   SOURCES
@@ -293,7 +337,6 @@ pw_add_library(chre.platform.shared.host_protocol_chre STATIC
   PRIVATE_DEPS
     chre.core
     chre.platform.log
-    chre.platform.shared.host_protocol_chre
     chre.platform.shared.nanoapp_load_manager
 )
 
@@ -308,7 +351,7 @@ pw_add_library(chre.platform.shared.host_protocol_common STATIC
   SOURCES
     host_protocol_common.cc
   PRIVATE_DEPS
-    chre.platform.shared.generated.host_messages_generated
+    chre.platform.shared.idl.host_messages_generated.cpp
 )
 
 pw_add_library(chre.platform.shared.loader_util INTERFACE
@@ -329,7 +372,7 @@ pw_add_library(chre.platform.shared.log_buffer STATIC
     chre.core
     chre.platform.mutex
     chre.platform.shared.bt_snoop_log
-    chre.platform.shared.generated.host_messages_generated
+    chre.platform.shared.idl.host_messages_generated.cpp
   SOURCES
     log_buffer.cc
   PRIVATE_DEPS
@@ -352,7 +395,7 @@ pw_add_facade(chre.platform.shared.log_buffer_manager STATIC
     chre.platform.condition_variable
     chre.platform.mutex
     chre.platform.shared.bt_snoop_log.facade
-    chre.platform.shared.generated.host_messages_generated
+    chre.platform.shared.idl.host_messages_generated.cpp
     chre.platform.shared.log_buffer
     chre.util
   SOURCES
@@ -424,6 +467,7 @@ pw_add_facade(chre.platform.shared.nanoapp_loader STATIC
     chre.platform.assert
     chre.platform.fatal_error
     chre.platform.shared.chre_api_re
+    chre.platform.shared.chre_api_msg
     chre.platform.shared.dlfcn
     chre.platform.shared.memory
     chre.platform.shared.nanoapp_tokenized_log
diff --git a/platform/shared/chre_api_ble.cc b/platform/shared/chre_api_ble.cc
index 5b65ac17..67c15612 100644
--- a/platform/shared/chre_api_ble.cc
+++ b/platform/shared/chre_api_ble.cc
@@ -130,4 +130,38 @@ DLL_EXPORT bool chreBleGetScanStatus(struct chreBleScanStatus *status) {
   UNUSED_VAR(status);
   return false;
 #endif  // CHRE_BLE_SUPPORT_ENABLED
-}
\ No newline at end of file
+}
+
+DLL_EXPORT bool chreBleSocketAccept(uint64_t socketId) {
+#ifdef CHRE_BLE_SOCKET_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return nanoapp->permitPermissionUse(NanoappPermissions::CHRE_PERMS_BLE) &&
+         EventLoopManagerSingleton::get()
+             ->getBleSocketManager()
+             .acceptBleSocket(socketId);
+#else
+  UNUSED_VAR(socketId);
+  return false;
+#endif  // CHRE_BLE_SOCKET_SUPPORT_ENABLED
+}
+
+DLL_EXPORT int32_t
+chreBleSocketSend(uint64_t socketId, const void *data, uint16_t length,
+                  chreBleSocketPacketFreeFunction *freeCallback) {
+#ifdef CHRE_BLE_SOCKET_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  if (!nanoapp->permitPermissionUse(NanoappPermissions::CHRE_PERMS_BLE)) {
+    return chreError::CHRE_ERROR_PERMISSION_DENIED;
+  }
+  return EventLoopManagerSingleton::get()
+      ->getBleSocketManager()
+      .sendBleSocketPacket(socketId, data, length, freeCallback);
+#else
+  UNUSED_VAR(socketId);
+  UNUSED_VAR(data);
+  UNUSED_VAR(length);
+  UNUSED_VAR(freeCallback);
+
+  return chreError::CHRE_ERROR_NOT_SUPPORTED;
+#endif  // CHRE_BLE_SOCKET_SUPPORT_ENABLED
+}
diff --git a/platform/shared/chre_api_msg.cc b/platform/shared/chre_api_msg.cc
new file mode 100644
index 00000000..77771082
--- /dev/null
+++ b/platform/shared/chre_api_msg.cc
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "chre/core/event_loop_manager.h"
+#include "chre/util/macros.h"
+#include "chre_api/chre/common.h"
+#include "chre_api/chre/event.h"
+#include "chre_api/chre/msg.h"
+
+#include <cstdarg>
+#include <cstdio>
+#include <cstring>
+
+using ::chre::EventLoopManager;
+using ::chre::EventLoopManagerSingleton;
+using ::chre::Nanoapp;
+
+DLL_EXPORT bool chreMsgGetEndpointInfo(uint64_t hubId, uint64_t endpointId,
+                                       struct chreMsgEndpointInfo *info) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  return info != nullptr && EventLoopManagerSingleton::get()
+                                ->getChreMessageHubManager()
+                                .getEndpointInfo(hubId, endpointId, *info);
+#else
+  UNUSED_VAR(hubId);
+  UNUSED_VAR(endpointId);
+  UNUSED_VAR(info);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgConfigureEndpointReadyEvents(uint64_t hubId,
+                                                    uint64_t endpointId,
+                                                    bool enable) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .configureReadyEvents(nanoapp->getInstanceId(), nanoapp->getAppId(),
+                            hubId, endpointId,
+                            /* serviceDescriptor= */ nullptr, enable);
+#else
+  UNUSED_VAR(hubId);
+  UNUSED_VAR(endpointId);
+  UNUSED_VAR(enable);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgConfigureServiceReadyEvents(
+    uint64_t hubId, const char *serviceDescriptor, bool enable) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .configureReadyEvents(nanoapp->getInstanceId(), nanoapp->getAppId(),
+                            hubId,
+                            /* endpointId= */ CHRE_MSG_ENDPOINT_ID_INVALID,
+                            serviceDescriptor, enable);
+#else
+  UNUSED_VAR(hubId);
+  UNUSED_VAR(serviceDescriptor);
+  UNUSED_VAR(enable);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgSessionGetInfo(uint16_t sessionId,
+                                      struct chreMsgSessionInfo *info) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return info != nullptr &&
+         EventLoopManagerSingleton::get()
+             ->getChreMessageHubManager()
+             .getSessionInfo(nanoapp->getAppId(), sessionId, *info);
+#else
+  UNUSED_VAR(sessionId);
+  UNUSED_VAR(info);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgPublishServices(
+    const struct chreMsgServiceInfo *services, size_t numServices) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .publishServices(nanoapp->getAppId(), services, numServices);
+#else
+  UNUSED_VAR(services);
+  UNUSED_VAR(numServices);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgSessionOpenAsync(uint64_t hubId, uint64_t endpointId,
+                                        const char *serviceDescriptor) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .openDefaultSessionAsync(nanoapp->getAppId(), hubId, endpointId,
+                               serviceDescriptor);
+#else
+  UNUSED_VAR(hubId);
+  UNUSED_VAR(endpointId);
+  UNUSED_VAR(serviceDescriptor);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgSessionCloseAsync(uint16_t sessionId) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .closeSession(nanoapp->getAppId(), sessionId);
+#else
+  UNUSED_VAR(sessionId);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
+
+DLL_EXPORT bool chreMsgSend(
+    void *message, size_t messageSize, uint32_t messageType, uint16_t sessionId,
+    uint32_t messagePermissions, chreMessageFreeFunction *freeCallback) {
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  Nanoapp *nanoapp = EventLoopManager::validateChreApiCall(__func__);
+  return EventLoopManagerSingleton::get()
+      ->getChreMessageHubManager()
+      .sendMessage(message, messageSize, messageType, sessionId,
+                   messagePermissions, freeCallback, nanoapp->getAppId());
+#else
+  UNUSED_VAR(message);
+  UNUSED_VAR(messageSize);
+  UNUSED_VAR(messageType);
+  UNUSED_VAR(sessionId);
+  UNUSED_VAR(messagePermissions);
+  UNUSED_VAR(freeCallback);
+  return false;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+}
diff --git a/platform/shared/chre_api_re.cc b/platform/shared/chre_api_re.cc
index 3d7c8fd7..d074cbcf 100644
--- a/platform/shared/chre_api_re.cc
+++ b/platform/shared/chre_api_re.cc
@@ -35,6 +35,10 @@ DLL_EXPORT uint32_t chreGetCapabilities() {
   capabilities |= CHRE_CAPABILITIES_RELIABLE_MESSAGES;
 #endif  // CHRE_RELIABLE_MESSAGE_SUPPORT_ENABLED
 
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+  capabilities |= CHRE_CAPABILITIES_GENERIC_ENDPOINT_MESSAGES;
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+
   return capabilities;
 }
 
diff --git a/platform/shared/include/chre/platform/shared/generated/host_messages_generated.h b/platform/shared/fbs/include/chre/platform/shared/fbs/host_messages_generated.h
similarity index 91%
rename from platform/shared/include/chre/platform/shared/generated/host_messages_generated.h
rename to platform/shared/fbs/include/chre/platform/shared/fbs/host_messages_generated.h
index 41014398..bbc19b1a 100644
--- a/platform/shared/include/chre/platform/shared/generated/host_messages_generated.h
+++ b/platform/shared/fbs/include/chre/platform/shared/fbs/host_messages_generated.h
@@ -126,6 +126,18 @@ struct BtSocketCloseBuilder;
 struct BtSocketCloseResponse;
 struct BtSocketCloseResponseBuilder;
 
+struct BtSocketCapabilitiesRequest;
+struct BtSocketCapabilitiesRequestBuilder;
+
+struct BtSocketLeCocCapabilities;
+struct BtSocketLeCocCapabilitiesBuilder;
+
+struct BtSocketRfcommCapabilities;
+struct BtSocketRfcommCapabilitiesBuilder;
+
+struct BtSocketCapabilitiesResponse;
+struct BtSocketCapabilitiesResponseBuilder;
+
 struct VendorHubInfo;
 struct VendorHubInfoBuilder;
 
@@ -150,6 +162,12 @@ struct EndpointInfoBuilder;
 struct RegisterEndpoint;
 struct RegisterEndpointBuilder;
 
+struct AddServiceToEndpoint;
+struct AddServiceToEndpointBuilder;
+
+struct EndpointReady;
+struct EndpointReadyBuilder;
+
 struct UnregisterEndpoint;
 struct UnregisterEndpointBuilder;
 
@@ -670,11 +688,15 @@ enum class ChreMessage : uint8_t {
   EndpointSessionClosed = 45,
   EndpointSessionMessage = 46,
   EndpointSessionMessageDeliveryStatus = 47,
+  BtSocketCapabilitiesRequest = 48,
+  BtSocketCapabilitiesResponse = 49,
+  AddServiceToEndpoint = 50,
+  EndpointReady = 51,
   MIN = NONE,
-  MAX = EndpointSessionMessageDeliveryStatus
+  MAX = EndpointReady
 };
 
-inline const ChreMessage (&EnumValuesChreMessage())[48] {
+inline const ChreMessage (&EnumValuesChreMessage())[52] {
   static const ChreMessage values[] = {
     ChreMessage::NONE,
     ChreMessage::NanoappMessage,
@@ -723,13 +745,17 @@ inline const ChreMessage (&EnumValuesChreMessage())[48] {
     ChreMessage::EndpointSessionOpened,
     ChreMessage::EndpointSessionClosed,
     ChreMessage::EndpointSessionMessage,
-    ChreMessage::EndpointSessionMessageDeliveryStatus
+    ChreMessage::EndpointSessionMessageDeliveryStatus,
+    ChreMessage::BtSocketCapabilitiesRequest,
+    ChreMessage::BtSocketCapabilitiesResponse,
+    ChreMessage::AddServiceToEndpoint,
+    ChreMessage::EndpointReady
   };
   return values;
 }
 
 inline const char * const *EnumNamesChreMessage() {
-  static const char * const names[49] = {
+  static const char * const names[53] = {
     "NONE",
     "NanoappMessage",
     "HubInfoRequest",
@@ -778,13 +804,17 @@ inline const char * const *EnumNamesChreMessage() {
     "EndpointSessionClosed",
     "EndpointSessionMessage",
     "EndpointSessionMessageDeliveryStatus",
+    "BtSocketCapabilitiesRequest",
+    "BtSocketCapabilitiesResponse",
+    "AddServiceToEndpoint",
+    "EndpointReady",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameChreMessage(ChreMessage e) {
-  if (flatbuffers::IsOutRange(e, ChreMessage::NONE, ChreMessage::EndpointSessionMessageDeliveryStatus)) return "";
+  if (flatbuffers::IsOutRange(e, ChreMessage::NONE, ChreMessage::EndpointReady)) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesChreMessage()[index];
 }
@@ -981,6 +1011,22 @@ template<> struct ChreMessageTraits<chre::fbs::EndpointSessionMessageDeliverySta
   static const ChreMessage enum_value = ChreMessage::EndpointSessionMessageDeliveryStatus;
 };
 
+template<> struct ChreMessageTraits<chre::fbs::BtSocketCapabilitiesRequest> {
+  static const ChreMessage enum_value = ChreMessage::BtSocketCapabilitiesRequest;
+};
+
+template<> struct ChreMessageTraits<chre::fbs::BtSocketCapabilitiesResponse> {
+  static const ChreMessage enum_value = ChreMessage::BtSocketCapabilitiesResponse;
+};
+
+template<> struct ChreMessageTraits<chre::fbs::AddServiceToEndpoint> {
+  static const ChreMessage enum_value = ChreMessage::AddServiceToEndpoint;
+};
+
+template<> struct ChreMessageTraits<chre::fbs::EndpointReady> {
+  static const ChreMessage enum_value = ChreMessage::EndpointReady;
+};
+
 bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj, ChreMessage type);
 bool VerifyChreMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
 
@@ -3656,6 +3702,194 @@ inline flatbuffers::Offset<BtSocketCloseResponse> CreateBtSocketCloseResponse(
   return builder_.Finish();
 }
 
+struct BtSocketCapabilitiesRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketCapabilitiesRequestBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct BtSocketCapabilitiesRequestBuilder {
+  typedef BtSocketCapabilitiesRequest Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit BtSocketCapabilitiesRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketCapabilitiesRequestBuilder &operator=(const BtSocketCapabilitiesRequestBuilder &);
+  flatbuffers::Offset<BtSocketCapabilitiesRequest> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketCapabilitiesRequest>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketCapabilitiesRequest> CreateBtSocketCapabilitiesRequest(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  BtSocketCapabilitiesRequestBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct BtSocketLeCocCapabilities FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketLeCocCapabilitiesBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUMBEROFSUPPORTEDSOCKETS = 4,
+    VT_MTU = 6
+  };
+  int32_t numberOfSupportedSockets() const {
+    return GetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, 0);
+  }
+  int32_t mtu() const {
+    return GetField<int32_t>(VT_MTU, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_NUMBEROFSUPPORTEDSOCKETS) &&
+           VerifyField<int32_t>(verifier, VT_MTU) &&
+           verifier.EndTable();
+  }
+};
+
+struct BtSocketLeCocCapabilitiesBuilder {
+  typedef BtSocketLeCocCapabilities Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_numberOfSupportedSockets(int32_t numberOfSupportedSockets) {
+    fbb_.AddElement<int32_t>(BtSocketLeCocCapabilities::VT_NUMBEROFSUPPORTEDSOCKETS, numberOfSupportedSockets, 0);
+  }
+  void add_mtu(int32_t mtu) {
+    fbb_.AddElement<int32_t>(BtSocketLeCocCapabilities::VT_MTU, mtu, 0);
+  }
+  explicit BtSocketLeCocCapabilitiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketLeCocCapabilitiesBuilder &operator=(const BtSocketLeCocCapabilitiesBuilder &);
+  flatbuffers::Offset<BtSocketLeCocCapabilities> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketLeCocCapabilities>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketLeCocCapabilities> CreateBtSocketLeCocCapabilities(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t numberOfSupportedSockets = 0,
+    int32_t mtu = 0) {
+  BtSocketLeCocCapabilitiesBuilder builder_(_fbb);
+  builder_.add_mtu(mtu);
+  builder_.add_numberOfSupportedSockets(numberOfSupportedSockets);
+  return builder_.Finish();
+}
+
+struct BtSocketRfcommCapabilities FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketRfcommCapabilitiesBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUMBEROFSUPPORTEDSOCKETS = 4,
+    VT_MAXFRAMESIZE = 6
+  };
+  int32_t numberOfSupportedSockets() const {
+    return GetField<int32_t>(VT_NUMBEROFSUPPORTEDSOCKETS, 0);
+  }
+  int32_t maxFrameSize() const {
+    return GetField<int32_t>(VT_MAXFRAMESIZE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_NUMBEROFSUPPORTEDSOCKETS) &&
+           VerifyField<int32_t>(verifier, VT_MAXFRAMESIZE) &&
+           verifier.EndTable();
+  }
+};
+
+struct BtSocketRfcommCapabilitiesBuilder {
+  typedef BtSocketRfcommCapabilities Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_numberOfSupportedSockets(int32_t numberOfSupportedSockets) {
+    fbb_.AddElement<int32_t>(BtSocketRfcommCapabilities::VT_NUMBEROFSUPPORTEDSOCKETS, numberOfSupportedSockets, 0);
+  }
+  void add_maxFrameSize(int32_t maxFrameSize) {
+    fbb_.AddElement<int32_t>(BtSocketRfcommCapabilities::VT_MAXFRAMESIZE, maxFrameSize, 0);
+  }
+  explicit BtSocketRfcommCapabilitiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketRfcommCapabilitiesBuilder &operator=(const BtSocketRfcommCapabilitiesBuilder &);
+  flatbuffers::Offset<BtSocketRfcommCapabilities> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketRfcommCapabilities>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketRfcommCapabilities> CreateBtSocketRfcommCapabilities(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t numberOfSupportedSockets = 0,
+    int32_t maxFrameSize = 0) {
+  BtSocketRfcommCapabilitiesBuilder builder_(_fbb);
+  builder_.add_maxFrameSize(maxFrameSize);
+  builder_.add_numberOfSupportedSockets(numberOfSupportedSockets);
+  return builder_.Finish();
+}
+
+struct BtSocketCapabilitiesResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BtSocketCapabilitiesResponseBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_LECOCCAPABILITIES = 4,
+    VT_RFCOMMCAPABILITIES = 6
+  };
+  const chre::fbs::BtSocketLeCocCapabilities *leCocCapabilities() const {
+    return GetPointer<const chre::fbs::BtSocketLeCocCapabilities *>(VT_LECOCCAPABILITIES);
+  }
+  const chre::fbs::BtSocketRfcommCapabilities *rfcommCapabilities() const {
+    return GetPointer<const chre::fbs::BtSocketRfcommCapabilities *>(VT_RFCOMMCAPABILITIES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_LECOCCAPABILITIES) &&
+           verifier.VerifyTable(leCocCapabilities()) &&
+           VerifyOffset(verifier, VT_RFCOMMCAPABILITIES) &&
+           verifier.VerifyTable(rfcommCapabilities()) &&
+           verifier.EndTable();
+  }
+};
+
+struct BtSocketCapabilitiesResponseBuilder {
+  typedef BtSocketCapabilitiesResponse Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_leCocCapabilities(flatbuffers::Offset<chre::fbs::BtSocketLeCocCapabilities> leCocCapabilities) {
+    fbb_.AddOffset(BtSocketCapabilitiesResponse::VT_LECOCCAPABILITIES, leCocCapabilities);
+  }
+  void add_rfcommCapabilities(flatbuffers::Offset<chre::fbs::BtSocketRfcommCapabilities> rfcommCapabilities) {
+    fbb_.AddOffset(BtSocketCapabilitiesResponse::VT_RFCOMMCAPABILITIES, rfcommCapabilities);
+  }
+  explicit BtSocketCapabilitiesResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  BtSocketCapabilitiesResponseBuilder &operator=(const BtSocketCapabilitiesResponseBuilder &);
+  flatbuffers::Offset<BtSocketCapabilitiesResponse> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BtSocketCapabilitiesResponse>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BtSocketCapabilitiesResponse> CreateBtSocketCapabilitiesResponse(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<chre::fbs::BtSocketLeCocCapabilities> leCocCapabilities = 0,
+    flatbuffers::Offset<chre::fbs::BtSocketRfcommCapabilities> rfcommCapabilities = 0) {
+  BtSocketCapabilitiesResponseBuilder builder_(_fbb);
+  builder_.add_rfcommCapabilities(rfcommCapabilities);
+  builder_.add_leCocCapabilities(leCocCapabilities);
+  return builder_.Finish();
+}
+
 struct VendorHubInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef VendorHubInfoBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
@@ -4215,6 +4449,108 @@ inline flatbuffers::Offset<RegisterEndpoint> CreateRegisterEndpoint(
   return builder_.Finish();
 }
 
+/// MessageRouter handles service inspection separately from endpoint inspection
+/// so these messages are required to send embedded endpoint information in
+/// pieces to the host. After RegisterEndpoint, the endpoint is only ready once
+/// an EndpointReady message is sent. After EndpointReady, AddServiceToEndpoint
+/// will be rejected.
+struct AddServiceToEndpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddServiceToEndpointBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ENDPOINT = 4,
+    VT_SERVICE = 6
+  };
+  const chre::fbs::EndpointId *endpoint() const {
+    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
+  }
+  const chre::fbs::Service *service() const {
+    return GetPointer<const chre::fbs::Service *>(VT_SERVICE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_ENDPOINT) &&
+           verifier.VerifyTable(endpoint()) &&
+           VerifyOffset(verifier, VT_SERVICE) &&
+           verifier.VerifyTable(service()) &&
+           verifier.EndTable();
+  }
+};
+
+struct AddServiceToEndpointBuilder {
+  typedef AddServiceToEndpoint Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
+    fbb_.AddOffset(AddServiceToEndpoint::VT_ENDPOINT, endpoint);
+  }
+  void add_service(flatbuffers::Offset<chre::fbs::Service> service) {
+    fbb_.AddOffset(AddServiceToEndpoint::VT_SERVICE, service);
+  }
+  explicit AddServiceToEndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  AddServiceToEndpointBuilder &operator=(const AddServiceToEndpointBuilder &);
+  flatbuffers::Offset<AddServiceToEndpoint> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddServiceToEndpoint>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddServiceToEndpoint> CreateAddServiceToEndpoint(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0,
+    flatbuffers::Offset<chre::fbs::Service> service = 0) {
+  AddServiceToEndpointBuilder builder_(_fbb);
+  builder_.add_service(service);
+  builder_.add_endpoint(endpoint);
+  return builder_.Finish();
+}
+
+struct EndpointReady FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EndpointReadyBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ENDPOINT = 4
+  };
+  const chre::fbs::EndpointId *endpoint() const {
+    return GetPointer<const chre::fbs::EndpointId *>(VT_ENDPOINT);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_ENDPOINT) &&
+           verifier.VerifyTable(endpoint()) &&
+           verifier.EndTable();
+  }
+};
+
+struct EndpointReadyBuilder {
+  typedef EndpointReady Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_endpoint(flatbuffers::Offset<chre::fbs::EndpointId> endpoint) {
+    fbb_.AddOffset(EndpointReady::VT_ENDPOINT, endpoint);
+  }
+  explicit EndpointReadyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  EndpointReadyBuilder &operator=(const EndpointReadyBuilder &);
+  flatbuffers::Offset<EndpointReady> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<EndpointReady>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<EndpointReady> CreateEndpointReady(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<chre::fbs::EndpointId> endpoint = 0) {
+  EndpointReadyBuilder builder_(_fbb);
+  builder_.add_endpoint(endpoint);
+  return builder_.Finish();
+}
+
 struct UnregisterEndpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef UnregisterEndpointBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
@@ -4360,13 +4696,17 @@ inline flatbuffers::Offset<GetMessageHubsAndEndpointsResponse> CreateGetMessageH
 struct OpenEndpointSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef OpenEndpointSessionRequestBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_ID = 4,
-    VT_FROMENDPOINT = 6,
-    VT_TOENDPOINT = 8,
-    VT_SERVICEDESCRIPTOR = 10
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_FROMENDPOINT = 8,
+    VT_TOENDPOINT = 10,
+    VT_SERVICEDESCRIPTOR = 12
   };
-  uint16_t id() const {
-    return GetField<uint16_t>(VT_ID, 0);
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  uint16_t session_id() const {
+    return GetField<uint16_t>(VT_SESSION_ID, 0);
   }
   const chre::fbs::EndpointId *fromEndpoint() const {
     return GetPointer<const chre::fbs::EndpointId *>(VT_FROMENDPOINT);
@@ -4380,7 +4720,8 @@ struct OpenEndpointSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers:
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
+           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyOffset(verifier, VT_FROMENDPOINT) &&
            verifier.VerifyTable(fromEndpoint()) &&
            VerifyOffset(verifier, VT_TOENDPOINT) &&
@@ -4395,8 +4736,11 @@ struct OpenEndpointSessionRequestBuilder {
   typedef OpenEndpointSessionRequest Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_id(uint16_t id) {
-    fbb_.AddElement<uint16_t>(OpenEndpointSessionRequest::VT_ID, id, 0);
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(OpenEndpointSessionRequest::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
+  void add_session_id(uint16_t session_id) {
+    fbb_.AddElement<uint16_t>(OpenEndpointSessionRequest::VT_SESSION_ID, session_id, 0);
   }
   void add_fromEndpoint(flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint) {
     fbb_.AddOffset(OpenEndpointSessionRequest::VT_FROMENDPOINT, fromEndpoint);
@@ -4421,28 +4765,32 @@ struct OpenEndpointSessionRequestBuilder {
 
 inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequest(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0,
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint = 0,
     flatbuffers::Offset<flatbuffers::Vector<int8_t>> serviceDescriptor = 0) {
   OpenEndpointSessionRequestBuilder builder_(_fbb);
+  builder_.add_host_hub_id(host_hub_id);
   builder_.add_serviceDescriptor(serviceDescriptor);
   builder_.add_toEndpoint(toEndpoint);
   builder_.add_fromEndpoint(fromEndpoint);
-  builder_.add_id(id);
+  builder_.add_session_id(session_id);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSessionRequestDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0,
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> fromEndpoint = 0,
     flatbuffers::Offset<chre::fbs::EndpointId> toEndpoint = 0,
     const std::vector<int8_t> *serviceDescriptor = nullptr) {
   auto serviceDescriptor__ = serviceDescriptor ? _fbb.CreateVector<int8_t>(*serviceDescriptor) : 0;
   return chre::fbs::CreateOpenEndpointSessionRequest(
       _fbb,
-      id,
+      host_hub_id,
+      session_id,
       fromEndpoint,
       toEndpoint,
       serviceDescriptor__);
@@ -4451,14 +4799,19 @@ inline flatbuffers::Offset<OpenEndpointSessionRequest> CreateOpenEndpointSession
 struct EndpointSessionOpened FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef EndpointSessionOpenedBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_ID = 4
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6
   };
-  uint16_t id() const {
-    return GetField<uint16_t>(VT_ID, 0);
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  uint16_t session_id() const {
+    return GetField<uint16_t>(VT_SESSION_ID, 0);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
+           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            verifier.EndTable();
   }
 };
@@ -4467,8 +4820,11 @@ struct EndpointSessionOpenedBuilder {
   typedef EndpointSessionOpened Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_id(uint16_t id) {
-    fbb_.AddElement<uint16_t>(EndpointSessionOpened::VT_ID, id, 0);
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionOpened::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
+  void add_session_id(uint16_t session_id) {
+    fbb_.AddElement<uint16_t>(EndpointSessionOpened::VT_SESSION_ID, session_id, 0);
   }
   explicit EndpointSessionOpenedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
@@ -4484,27 +4840,34 @@ struct EndpointSessionOpenedBuilder {
 
 inline flatbuffers::Offset<EndpointSessionOpened> CreateEndpointSessionOpened(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0) {
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0) {
   EndpointSessionOpenedBuilder builder_(_fbb);
-  builder_.add_id(id);
+  builder_.add_host_hub_id(host_hub_id);
+  builder_.add_session_id(session_id);
   return builder_.Finish();
 }
 
 struct EndpointSessionClosed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef EndpointSessionClosedBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_ID = 4,
-    VT_REASON = 6
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_REASON = 8
   };
-  uint16_t id() const {
-    return GetField<uint16_t>(VT_ID, 0);
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
+  uint16_t session_id() const {
+    return GetField<uint16_t>(VT_SESSION_ID, 0);
   }
   chre::fbs::Reason reason() const {
     return static_cast<chre::fbs::Reason>(GetField<uint8_t>(VT_REASON, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
+           VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyField<uint8_t>(verifier, VT_REASON) &&
            verifier.EndTable();
   }
@@ -4514,8 +4877,11 @@ struct EndpointSessionClosedBuilder {
   typedef EndpointSessionClosed Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_id(uint16_t id) {
-    fbb_.AddElement<uint16_t>(EndpointSessionClosed::VT_ID, id, 0);
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionClosed::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
+  void add_session_id(uint16_t session_id) {
+    fbb_.AddElement<uint16_t>(EndpointSessionClosed::VT_SESSION_ID, session_id, 0);
   }
   void add_reason(chre::fbs::Reason reason) {
     fbb_.AddElement<uint8_t>(EndpointSessionClosed::VT_REASON, static_cast<uint8_t>(reason), 0);
@@ -4534,10 +4900,12 @@ struct EndpointSessionClosedBuilder {
 
 inline flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(
     flatbuffers::FlatBufferBuilder &_fbb,
-    uint16_t id = 0,
+    int64_t host_hub_id = 0,
+    uint16_t session_id = 0,
     chre::fbs::Reason reason = chre::fbs::Reason::UNSPECIFIED) {
   EndpointSessionClosedBuilder builder_(_fbb);
-  builder_.add_id(id);
+  builder_.add_host_hub_id(host_hub_id);
+  builder_.add_session_id(session_id);
   builder_.add_reason(reason);
   return builder_.Finish();
 }
@@ -4545,13 +4913,17 @@ inline flatbuffers::Offset<EndpointSessionClosed> CreateEndpointSessionClosed(
 struct EndpointSessionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef EndpointSessionMessageBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_SESSION_ID = 4,
-    VT_TYPE = 6,
-    VT_PERMISSIONS = 8,
-    VT_DATA = 10,
-    VT_FLAGS = 12,
-    VT_SEQUENCE_NUMBER = 14
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_TYPE = 8,
+    VT_PERMISSIONS = 10,
+    VT_DATA = 12,
+    VT_FLAGS = 14,
+    VT_SEQUENCE_NUMBER = 16
   };
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
   /// Id of session this message is being sent within
   uint16_t session_id() const {
     return GetField<uint16_t>(VT_SESSION_ID, 0);
@@ -4578,6 +4950,7 @@ struct EndpointSessionMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
            VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyField<uint32_t>(verifier, VT_TYPE) &&
            VerifyField<uint32_t>(verifier, VT_PERMISSIONS) &&
@@ -4593,6 +4966,9 @@ struct EndpointSessionMessageBuilder {
   typedef EndpointSessionMessage Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionMessage::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
   void add_session_id(uint16_t session_id) {
     fbb_.AddElement<uint16_t>(EndpointSessionMessage::VT_SESSION_ID, session_id, 0);
   }
@@ -4625,6 +5001,7 @@ struct EndpointSessionMessageBuilder {
 
 inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
     flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t host_hub_id = 0,
     uint16_t session_id = 0,
     uint32_t type = 0,
     uint32_t permissions = 0,
@@ -4632,6 +5009,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
     uint32_t flags = 0,
     uint32_t sequence_number = 0) {
   EndpointSessionMessageBuilder builder_(_fbb);
+  builder_.add_host_hub_id(host_hub_id);
   builder_.add_sequence_number(sequence_number);
   builder_.add_flags(flags);
   builder_.add_data(data);
@@ -4643,6 +5021,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessage(
 
 inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessageDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t host_hub_id = 0,
     uint16_t session_id = 0,
     uint32_t type = 0,
     uint32_t permissions = 0,
@@ -4652,6 +5031,7 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessageD
   auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
   return chre::fbs::CreateEndpointSessionMessage(
       _fbb,
+      host_hub_id,
       session_id,
       type,
       permissions,
@@ -4663,9 +5043,13 @@ inline flatbuffers::Offset<EndpointSessionMessage> CreateEndpointSessionMessageD
 struct EndpointSessionMessageDeliveryStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef EndpointSessionMessageDeliveryStatusBuilder Builder;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
-    VT_SESSION_ID = 4,
-    VT_STATUS = 6
+    VT_HOST_HUB_ID = 4,
+    VT_SESSION_ID = 6,
+    VT_STATUS = 8
   };
+  int64_t host_hub_id() const {
+    return GetField<int64_t>(VT_HOST_HUB_ID, 0);
+  }
   /// Id of session the message was sent within
   uint16_t session_id() const {
     return GetField<uint16_t>(VT_SESSION_ID, 0);
@@ -4675,6 +5059,7 @@ struct EndpointSessionMessageDeliveryStatus FLATBUFFERS_FINAL_CLASS : private fl
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_HOST_HUB_ID) &&
            VerifyField<uint16_t>(verifier, VT_SESSION_ID) &&
            VerifyOffset(verifier, VT_STATUS) &&
            verifier.VerifyTable(status()) &&
@@ -4686,6 +5071,9 @@ struct EndpointSessionMessageDeliveryStatusBuilder {
   typedef EndpointSessionMessageDeliveryStatus Table;
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
+  void add_host_hub_id(int64_t host_hub_id) {
+    fbb_.AddElement<int64_t>(EndpointSessionMessageDeliveryStatus::VT_HOST_HUB_ID, host_hub_id, 0);
+  }
   void add_session_id(uint16_t session_id) {
     fbb_.AddElement<uint16_t>(EndpointSessionMessageDeliveryStatus::VT_SESSION_ID, session_id, 0);
   }
@@ -4706,9 +5094,11 @@ struct EndpointSessionMessageDeliveryStatusBuilder {
 
 inline flatbuffers::Offset<EndpointSessionMessageDeliveryStatus> CreateEndpointSessionMessageDeliveryStatus(
     flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t host_hub_id = 0,
     uint16_t session_id = 0,
     flatbuffers::Offset<chre::fbs::MessageDeliveryStatus> status = 0) {
   EndpointSessionMessageDeliveryStatusBuilder builder_(_fbb);
+  builder_.add_host_hub_id(host_hub_id);
   builder_.add_status(status);
   builder_.add_session_id(session_id);
   return builder_.Finish();
@@ -4872,6 +5262,18 @@ struct MessageContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   const chre::fbs::EndpointSessionMessageDeliveryStatus *message_as_EndpointSessionMessageDeliveryStatus() const {
     return message_type() == chre::fbs::ChreMessage::EndpointSessionMessageDeliveryStatus ? static_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(message()) : nullptr;
   }
+  const chre::fbs::BtSocketCapabilitiesRequest *message_as_BtSocketCapabilitiesRequest() const {
+    return message_type() == chre::fbs::ChreMessage::BtSocketCapabilitiesRequest ? static_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(message()) : nullptr;
+  }
+  const chre::fbs::BtSocketCapabilitiesResponse *message_as_BtSocketCapabilitiesResponse() const {
+    return message_type() == chre::fbs::ChreMessage::BtSocketCapabilitiesResponse ? static_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(message()) : nullptr;
+  }
+  const chre::fbs::AddServiceToEndpoint *message_as_AddServiceToEndpoint() const {
+    return message_type() == chre::fbs::ChreMessage::AddServiceToEndpoint ? static_cast<const chre::fbs::AddServiceToEndpoint *>(message()) : nullptr;
+  }
+  const chre::fbs::EndpointReady *message_as_EndpointReady() const {
+    return message_type() == chre::fbs::ChreMessage::EndpointReady ? static_cast<const chre::fbs::EndpointReady *>(message()) : nullptr;
+  }
   /// The originating or destination client ID on the host side, used to direct
   /// responses only to the client that sent the request. Although initially
   /// populated by the requesting client, this is enforced to be the correct
@@ -5079,6 +5481,22 @@ template<> inline const chre::fbs::EndpointSessionMessageDeliveryStatus *Message
   return message_as_EndpointSessionMessageDeliveryStatus();
 }
 
+template<> inline const chre::fbs::BtSocketCapabilitiesRequest *MessageContainer::message_as<chre::fbs::BtSocketCapabilitiesRequest>() const {
+  return message_as_BtSocketCapabilitiesRequest();
+}
+
+template<> inline const chre::fbs::BtSocketCapabilitiesResponse *MessageContainer::message_as<chre::fbs::BtSocketCapabilitiesResponse>() const {
+  return message_as_BtSocketCapabilitiesResponse();
+}
+
+template<> inline const chre::fbs::AddServiceToEndpoint *MessageContainer::message_as<chre::fbs::AddServiceToEndpoint>() const {
+  return message_as_AddServiceToEndpoint();
+}
+
+template<> inline const chre::fbs::EndpointReady *MessageContainer::message_as<chre::fbs::EndpointReady>() const {
+  return message_as_EndpointReady();
+}
+
 struct MessageContainerBuilder {
   typedef MessageContainer Table;
   flatbuffers::FlatBufferBuilder &fbb_;
@@ -5365,6 +5783,22 @@ inline bool VerifyChreMessage(flatbuffers::Verifier &verifier, const void *obj,
       auto ptr = reinterpret_cast<const chre::fbs::EndpointSessionMessageDeliveryStatus *>(obj);
       return verifier.VerifyTable(ptr);
     }
+    case ChreMessage::BtSocketCapabilitiesRequest: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesRequest *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case ChreMessage::BtSocketCapabilitiesResponse: {
+      auto ptr = reinterpret_cast<const chre::fbs::BtSocketCapabilitiesResponse *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case ChreMessage::AddServiceToEndpoint: {
+      auto ptr = reinterpret_cast<const chre::fbs::AddServiceToEndpoint *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case ChreMessage::EndpointReady: {
+      auto ptr = reinterpret_cast<const chre::fbs::EndpointReady *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
     default: return true;
   }
 }
diff --git a/platform/shared/host_protocol_chre.cc b/platform/shared/host_protocol_chre.cc
index 62241358..c0831b77 100644
--- a/platform/shared/host_protocol_chre.cc
+++ b/platform/shared/host_protocol_chre.cc
@@ -22,15 +22,29 @@
 
 #include "chre/core/event_loop_manager.h"
 #include "chre/core/host_endpoint_manager.h"
+#include "chre/core/host_message_hub_manager.h"
 #include "chre/platform/log.h"
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
+#include "chre/util/dynamic_vector.h"
 #include "chre/util/macros.h"
+#include "chre/util/system/message_common.h"
 
 using flatbuffers::Offset;
 using flatbuffers::Vector;
 
 namespace chre {
 
+using message::EndpointId;
+using message::EndpointInfo;
+using message::EndpointType;
+using message::MessageHubId;
+using message::MessageHubInfo;
+using message::Reason;
+using message::RpcFormat;
+using message::ServiceInfo;
+using message::Session;
+using message::SessionId;
+
 // This is similar to getStringFromByteVector in host_protocol_host.h. Ensure
 // that method's implementation is kept in sync with this.
 const char *getStringFromByteVector(const flatbuffers::Vector<int8_t> *vec) {
@@ -46,6 +60,14 @@ const char *getStringFromByteVector(const flatbuffers::Vector<int8_t> *vec) {
   return str;
 }
 
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+namespace {
+HostMessageHubManager &getHostHubManager() {
+  return EventLoopManagerSingleton::get()->getHostMessageHubManager();
+}
+}  // namespace
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+
 bool HostProtocolChre::decodeMessageFromHost(const void *message,
                                              size_t messageLen) {
   bool success = verifyMessage(message, messageLen);
@@ -214,24 +236,45 @@ bool HostProtocolChre::decodeMessageFromHost(const void *message,
                   btSocketOpen->channelInfo());
           const char *name = getStringFromByteVector(btSocketOpen->name());
           HostMessageHandlers::handleBtSocketOpen(
-              hostClientId, static_cast<uint64_t>(btSocketOpen->socketId()),
-              name, static_cast<uint64_t>(btSocketOpen->endpointId()),
               static_cast<uint64_t>(btSocketOpen->hubId()),
-              static_cast<uint32_t>(btSocketOpen->aclConnectionHandle()),
-              static_cast<uint32_t>(leCocChannelInfo->localCid()),
-              static_cast<uint32_t>(leCocChannelInfo->remoteCid()),
-              static_cast<uint32_t>(leCocChannelInfo->psm()),
-              static_cast<uint32_t>(leCocChannelInfo->localMtu()),
-              static_cast<uint32_t>(leCocChannelInfo->remoteMtu()),
-              static_cast<uint32_t>(leCocChannelInfo->localMps()),
-              static_cast<uint32_t>(leCocChannelInfo->remoteMps()),
-              static_cast<uint32_t>(leCocChannelInfo->initialRxCredits()),
-              static_cast<uint32_t>(leCocChannelInfo->initialTxCredits()));
+              BleL2capCocSocketData{
+                  .socketId = static_cast<uint64_t>(btSocketOpen->socketId()),
+                  .endpointId =
+                      static_cast<uint64_t>(btSocketOpen->endpointId()),
+                  .connectionHandle = static_cast<uint16_t>(
+                      btSocketOpen->aclConnectionHandle()),
+                  .hostClientId = hostClientId,
+                  .rxConfig =
+                      L2capCocConfig{.cid = static_cast<uint16_t>(
+                                         leCocChannelInfo->localCid()),
+                                     .mtu = static_cast<uint16_t>(
+                                         leCocChannelInfo->localMtu()),
+                                     .mps = static_cast<uint16_t>(
+                                         leCocChannelInfo->localMps()),
+                                     .credits = static_cast<uint16_t>(
+                                         leCocChannelInfo->initialRxCredits())},
+                  .txConfig =
+                      L2capCocConfig{.cid = static_cast<uint16_t>(
+                                         leCocChannelInfo->remoteCid()),
+                                     .mtu = static_cast<uint16_t>(
+                                         leCocChannelInfo->remoteMtu()),
+                                     .mps = static_cast<uint16_t>(
+                                         leCocChannelInfo->remoteMps()),
+                                     .credits = static_cast<uint16_t>(
+                                         leCocChannelInfo->initialTxCredits())},
+              },
+              name, static_cast<uint32_t>(leCocChannelInfo->psm()));
           success = true;
         }
         break;
       }
 
+      case fbs::ChreMessage::BtSocketCapabilitiesRequest: {
+        HostMessageHandlers::handleBtSocketCapabilitiesRequest();
+        success = true;
+        break;
+      }
+
       case fbs::ChreMessage::BtSocketCloseResponse: {
         const auto *btSocketCloseResponse =
             static_cast<const fbs::BtSocketCloseResponse *>(
@@ -242,6 +285,118 @@ bool HostProtocolChre::decodeMessageFromHost(const void *message,
         break;
       }
 
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+      case fbs::ChreMessage::GetMessageHubsAndEndpointsRequest:
+        getHostHubManager().reset();
+        break;
+
+      case fbs::ChreMessage::RegisterMessageHub: {
+        const auto *msg =
+            static_cast<const fbs::RegisterMessageHub *>(container->message());
+        MessageHubInfo hub{.id = static_cast<MessageHubId>(msg->hub()->id())};
+        if (msg->hub()->details_type() ==
+            fbs::MessageHubDetails::VendorHubInfo) {
+          hub.name = getStringFromByteVector(
+              msg->hub()->details_as_VendorHubInfo()->name());
+        } else {
+          hub.name = getStringFromByteVector(
+              msg->hub()->details_as_HubInfoResponse()->name());
+        }
+        getHostHubManager().registerHub(hub);
+        break;
+      }
+
+      case fbs::ChreMessage::UnregisterMessageHub: {
+        const auto *msg = static_cast<const fbs::UnregisterMessageHub *>(
+            container->message());
+        getHostHubManager().unregisterHub(msg->id());
+        break;
+      }
+
+      case fbs::ChreMessage::RegisterEndpoint: {
+        const auto *fbsEndpoint =
+            static_cast<const fbs::RegisterEndpoint *>(container->message())
+                ->endpoint();
+        auto *maybeName = getStringFromByteVector(fbsEndpoint->name());
+        EndpointInfo endpoint(fbsEndpoint->id()->id(),
+                              maybeName ? maybeName : "",
+                              fbsEndpoint->version(),
+                              static_cast<EndpointType>(fbsEndpoint->type()),
+                              fbsEndpoint->required_permissions());
+        DynamicVector<ServiceInfo> services;
+        if (fbsEndpoint->services() && fbsEndpoint->services()->size()) {
+          if (!services.reserve(fbsEndpoint->services()->size())) {
+            LOG_OOM();
+          } else {
+            for (const auto &service : *fbsEndpoint->services()) {
+              auto *serviceDescriptor =
+                  getStringFromByteVector(service->descriptor());
+              if (!serviceDescriptor) continue;
+              auto size = strlen(serviceDescriptor) + 1;
+              auto *buf = static_cast<char *>(memoryAlloc(size));
+              if (!buf) {
+                LOG_OOM();
+                break;
+              }
+              memcpy(buf, serviceDescriptor, size);
+              services.emplace_back(buf, service->major_version(),
+                                    service->minor_version(),
+                                    static_cast<RpcFormat>(service->format()));
+            }
+          }
+        }
+        getHostHubManager().registerEndpoint(fbsEndpoint->id()->hubId(),
+                                             endpoint, std::move(services));
+        break;
+      }
+
+      case fbs::ChreMessage::UnregisterEndpoint: {
+        const auto *msg =
+            static_cast<const fbs::UnregisterEndpoint *>(container->message());
+        getHostHubManager().unregisterEndpoint(msg->endpoint()->hubId(),
+                                               msg->endpoint()->id());
+        break;
+      }
+
+      case fbs::ChreMessage::OpenEndpointSessionRequest: {
+        const auto *msg = static_cast<const fbs::OpenEndpointSessionRequest *>(
+            container->message());
+        getHostHubManager().openSession(
+            msg->fromEndpoint()->hubId(), msg->fromEndpoint()->id(),
+            msg->toEndpoint()->hubId(), msg->toEndpoint()->id(),
+            msg->session_id(),
+            getStringFromByteVector(msg->serviceDescriptor()));
+        break;
+      }
+
+      case fbs::ChreMessage::EndpointSessionOpened: {
+        const auto *msg = static_cast<const fbs::EndpointSessionOpened *>(
+            container->message());
+        getHostHubManager().ackSession(msg->host_hub_id(), msg->session_id());
+        break;
+      }
+
+      case fbs::ChreMessage::EndpointSessionClosed: {
+        const auto *msg = static_cast<const fbs::EndpointSessionClosed *>(
+            container->message());
+        getHostHubManager().closeSession(msg->host_hub_id(), msg->session_id(),
+                                         static_cast<Reason>(msg->reason()));
+        break;
+      }
+
+      case fbs::ChreMessage::EndpointSessionMessage: {
+        const auto *msg = static_cast<const fbs::EndpointSessionMessage *>(
+            container->message());
+        pw::span<const std::byte> data = {
+            reinterpret_cast<const std::byte *>(msg->data()->data()),
+            msg->data()->size()};
+        getHostHubManager().sendMessage(msg->host_hub_id(), msg->session_id(),
+                                        data, msg->type(), msg->permissions());
+        break;
+      }
+
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+
       default:
         LOGW("Got invalid/unexpected message type %" PRIu8,
              static_cast<uint8_t>(container->message_type()));
@@ -447,6 +602,20 @@ void HostProtocolChre::encodeBtSocketClose(ChreFlatBufferBuilder &builder,
            hostClientId);
 }
 
+void HostProtocolChre::encodeBtSocketGetCapabilitiesResponse(
+    ChreFlatBufferBuilder &builder, uint32_t leCocNumberOfSupportedSockets,
+    uint32_t leCocMtu, uint32_t rfcommNumberOfSupportedSockets,
+    uint32_t rfcommMaxFrameSize) {
+  auto leCocCapabilities = fbs::CreateBtSocketLeCocCapabilities(
+      builder, leCocNumberOfSupportedSockets, leCocMtu);
+  auto rfcommCapabilities = fbs::CreateBtSocketRfcommCapabilities(
+      builder, rfcommNumberOfSupportedSockets, rfcommMaxFrameSize);
+  auto socketCapabilitiesResponse = fbs::CreateBtSocketCapabilitiesResponse(
+      builder, leCocCapabilities, rfcommCapabilities);
+  finalize(builder, fbs::ChreMessage::BtSocketCapabilitiesResponse,
+           socketCapabilitiesResponse.Union());
+}
+
 bool HostProtocolChre::getSettingFromFbs(fbs::Setting setting,
                                          Setting *chreSetting) {
   bool success = true;
@@ -492,4 +661,105 @@ bool HostProtocolChre::getSettingEnabledFromFbs(fbs::SettingState state,
   return success;
 }
 
+void HostProtocolChre::encodeGetMessageHubsAndEndpointsResponse(
+    ChreFlatBufferBuilder &builder) {
+  auto msg = fbs::CreateGetMessageHubsAndEndpointsResponse(builder);
+  finalize(builder, fbs::ChreMessage::GetMessageHubsAndEndpointsResponse,
+           msg.Union());
+}
+
+void HostProtocolChre::encodeRegisterMessageHub(ChreFlatBufferBuilder &builder,
+                                                const MessageHubInfo &hub) {
+  auto vendorHub = fbs::CreateVendorHubInfo(
+      builder, addStringAsByteVector(builder, hub.name));
+  auto fbsHub = fbs::CreateMessageHub(builder, hub.id,
+                                      fbs::MessageHubDetails::VendorHubInfo,
+                                      vendorHub.Union());
+  auto msg = fbs::CreateRegisterMessageHub(builder, fbsHub);
+  finalize(builder, fbs::ChreMessage::RegisterMessageHub, msg.Union());
+}
+
+void HostProtocolChre::encodeUnregisterMessageHub(
+    ChreFlatBufferBuilder &builder, MessageHubId id) {
+  auto msg = fbs::CreateUnregisterMessageHub(builder, id);
+  finalize(builder, fbs::ChreMessage::UnregisterMessageHub, msg.Union());
+}
+
+void HostProtocolChre::encodeRegisterEndpoint(ChreFlatBufferBuilder &builder,
+                                              MessageHubId hub,
+                                              const EndpointInfo &endpoint) {
+  auto id = fbs::CreateEndpointId(builder, hub, endpoint.id);
+  auto info = fbs::CreateEndpointInfo(
+      builder, id, static_cast<fbs::EndpointType>(endpoint.type),
+      addStringAsByteVector(builder, endpoint.name), endpoint.version,
+      endpoint.requiredPermissions);
+  auto msg = fbs::CreateRegisterEndpoint(builder, info);
+  finalize(builder, fbs::ChreMessage::RegisterEndpoint, msg.Union());
+}
+
+void HostProtocolChre::encodeAddServiceToEndpoint(
+    ChreFlatBufferBuilder &builder, MessageHubId hub, EndpointId endpoint,
+    const ServiceInfo &service) {
+  auto id = fbs::CreateEndpointId(builder, hub, endpoint);
+  auto serviceDescriptor =
+      addStringAsByteVector(builder, service.serviceDescriptor);
+  auto fbsService = fbs::CreateService(
+      builder, static_cast<fbs::RpcFormat>(service.format), serviceDescriptor,
+      service.majorVersion, service.minorVersion);
+  auto msg = fbs::CreateAddServiceToEndpoint(builder, id, fbsService);
+  finalize(builder, fbs::ChreMessage::AddServiceToEndpoint, msg.Union());
+}
+
+void HostProtocolChre::encodeEndpointReady(ChreFlatBufferBuilder &builder,
+                                           MessageHubId hub,
+                                           EndpointId endpoint) {
+  auto id = fbs::CreateEndpointId(builder, hub, endpoint);
+  auto msg = fbs::CreateEndpointReady(builder, id);
+  finalize(builder, fbs::ChreMessage::EndpointReady, msg.Union());
+}
+
+void HostProtocolChre::encodeUnregisterEndpoint(ChreFlatBufferBuilder &builder,
+                                                MessageHubId hub,
+                                                EndpointId endpoint) {
+  auto id = fbs::CreateEndpointId(builder, hub, endpoint);
+  auto msg = fbs::CreateUnregisterEndpoint(builder, id);
+  finalize(builder, fbs::ChreMessage::UnregisterEndpoint, msg.Union());
+}
+
+void HostProtocolChre::encodeOpenEndpointSessionRequest(
+    ChreFlatBufferBuilder &builder, const Session &session) {
+  auto fromEndpoint = fbs::CreateEndpointId(
+      builder, session.initiator.messageHubId, session.initiator.endpointId);
+  auto toEndpoint = fbs::CreateEndpointId(builder, session.peer.messageHubId,
+                                          session.peer.endpointId);
+  auto msg = fbs::CreateOpenEndpointSessionRequest(
+      builder, session.peer.messageHubId, session.sessionId, fromEndpoint,
+      toEndpoint, addStringAsByteVector(builder, session.serviceDescriptor));
+  finalize(builder, fbs::ChreMessage::OpenEndpointSessionRequest, msg.Union());
+}
+
+void HostProtocolChre::encodeEndpointSessionOpened(
+    ChreFlatBufferBuilder &builder, MessageHubId hub, SessionId session) {
+  auto msg = fbs::CreateEndpointSessionOpened(builder, hub, session);
+  finalize(builder, fbs::ChreMessage::EndpointSessionOpened, msg.Union());
+}
+
+void HostProtocolChre::encodeEndpointSessionClosed(
+    ChreFlatBufferBuilder &builder, MessageHubId hub, SessionId session,
+    Reason reason) {
+  auto msg = fbs::CreateEndpointSessionClosed(builder, hub, session,
+                                              static_cast<fbs::Reason>(reason));
+  finalize(builder, fbs::ChreMessage::EndpointSessionClosed, msg.Union());
+}
+
+void HostProtocolChre::encodeEndpointSessionMessage(
+    ChreFlatBufferBuilder &builder, MessageHubId hub, SessionId session,
+    pw::UniquePtr<std::byte[]> &&data, uint32_t type, uint32_t permissions) {
+  auto dataVec = builder.CreateVector(reinterpret_cast<uint8_t *>(data.get()),
+                                      data.size());
+  auto msg = fbs::CreateEndpointSessionMessage(builder, hub, session, type,
+                                               permissions, dataVec);
+  finalize(builder, fbs::ChreMessage::EndpointSessionMessage, msg.Union());
+}
+
 }  // namespace chre
diff --git a/platform/shared/host_protocol_common.cc b/platform/shared/host_protocol_common.cc
index b23c6a26..f795f1de 100644
--- a/platform/shared/host_protocol_common.cc
+++ b/platform/shared/host_protocol_common.cc
@@ -19,7 +19,7 @@
 #include <string.h>
 #include <cstdint>
 
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
 
 using flatbuffers::FlatBufferBuilder;
 using flatbuffers::Offset;
diff --git a/platform/shared/idl/host_messages.fbs b/platform/shared/idl/host_messages.fbs
index 2b86db5a..c965cc26 100644
--- a/platform/shared/idl/host_messages.fbs
+++ b/platform/shared/idl/host_messages.fbs
@@ -584,6 +584,42 @@ table BtSocketCloseResponse {
   socketId:long;
 }
 
+// Request from the host to the offload domain to get the capabilities of the
+// offload stack for BT sockets.
+table BtSocketCapabilitiesRequest {}
+
+//Capabilities for LE L2CAP COC that the offload stack supports.
+table BtSocketLeCocCapabilities {
+  // Maximum number of LE COC sockets supported. If not supported, the value
+  // must be zero.
+  numberOfSupportedSockets :int;
+
+  // Local Maximum Transmission Unit size in octets. The MTU size must be in
+  // range 23 to 65535.
+  mtu:int;
+}
+
+// Capabilities for RFCOMM that the offload stack supports.
+table BtSocketRfcommCapabilities {
+  // Maximum number of RFCOMM sockets supported. If not supported, the value
+  // must be zero.
+  numberOfSupportedSockets :int;
+
+  // Maximum frame size in octets negotiated during DLCI establishment. The
+  // frame size must be in range 23 to 32767.
+  maxFrameSize :int;
+}
+
+// Response from the offload domain to the host with the capabilities of the
+// offload stack for BT sockets.
+table BtSocketCapabilitiesResponse {
+  // Capabilities for LE COC sockets.
+  leCocCapabilities:BtSocketLeCocCapabilities;
+
+  // Capabilities for RFCOMM sockets.
+  rfcommCapabilities:BtSocketRfcommCapabilities;
+}
+
 table VendorHubInfo {
   /// The name of the hub. Nominally a UTF-8 string, but note that we're not
   /// using the built-in "string" data type from FlatBuffers here, because the
@@ -684,6 +720,19 @@ table RegisterEndpoint {
   endpoint:EndpointInfo;
 }
 
+/// MessageRouter handles service inspection separately from endpoint inspection
+/// so these messages are required to send embedded endpoint information in
+/// pieces to the host. After RegisterEndpoint, the endpoint is only ready once
+/// an EndpointReady message is sent. After EndpointReady, AddServiceToEndpoint
+/// will be rejected.
+table AddServiceToEndpoint {
+  endpoint:EndpointId;
+  service:Service;
+}
+table EndpointReady {
+  endpoint:EndpointId;
+}
+
 table UnregisterEndpoint {
   endpoint:EndpointId;
 }
@@ -696,7 +745,8 @@ table GetMessageHubsAndEndpointsResponse {
 }
 
 table OpenEndpointSessionRequest {
-  id:ushort;
+  host_hub_id:long;
+  session_id:ushort;
   fromEndpoint:EndpointId;
   toEndpoint:EndpointId;
 
@@ -705,7 +755,8 @@ table OpenEndpointSessionRequest {
 }
 
 table EndpointSessionOpened {
-  id:ushort;
+  host_hub_id:long;
+  session_id:ushort;
 }
 
 /// "Reason"s for stopping an endpoint or session over an endpoint.
@@ -731,11 +782,14 @@ enum Reason : ubyte {
 }
 
 table EndpointSessionClosed {
-  id:ushort;
+  host_hub_id:long;
+  session_id:ushort;
   reason:Reason;
 }
 
 table EndpointSessionMessage {
+  host_hub_id:long;
+
   /// Id of session this message is being sent within
   session_id:ushort;
 
@@ -754,6 +808,8 @@ table EndpointSessionMessage {
 }
 
 table EndpointSessionMessageDeliveryStatus {
+  host_hub_id:long;
+
   /// Id of session the message was sent within
   session_id:ushort;
   status:MessageDeliveryStatus;
@@ -834,6 +890,12 @@ union ChreMessage {
 
   EndpointSessionMessage,
   EndpointSessionMessageDeliveryStatus,
+
+  BtSocketCapabilitiesRequest,
+  BtSocketCapabilitiesResponse,
+
+  AddServiceToEndpoint,
+  EndpointReady,
 }
 
 struct HostAddress {
diff --git a/platform/shared/idl/update.sh b/platform/shared/idl/update.sh
index 26f6882e..1639bd21 100755
--- a/platform/shared/idl/update.sh
+++ b/platform/shared/idl/update.sh
@@ -7,7 +7,8 @@ exit
 fi
 
 # Generate the CHRE-side header file
-flatc --cpp -o ../include/chre/platform/shared/generated/ --scoped-enums \
+
+flatc --cpp -o ../fbs/include/chre/platform/shared/fbs/ --scoped-enums \
   --cpp-ptr-type chre::UniquePtr host_messages.fbs
 
 # Generate the AP-side header file with some extra goodies
diff --git a/platform/shared/include/chre/platform/shared/host_protocol_chre.h b/platform/shared/include/chre/platform/shared/host_protocol_chre.h
index 8857fad1..14130f01 100644
--- a/platform/shared/include/chre/platform/shared/host_protocol_chre.h
+++ b/platform/shared/include/chre/platform/shared/host_protocol_chre.h
@@ -20,16 +20,20 @@
 #include <stdint.h>
 #include <cstdint>
 
-#include "chre/core/event_loop_common.h"
+#include "chre/core/ble_l2cap_coc_socket_data.h"
 #include "chre/core/nanoapp.h"
 #include "chre/core/settings.h"
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
 #include "chre/platform/shared/host_protocol_common.h"
 #include "chre/util/dynamic_vector.h"
 #include "chre/util/flatbuffers/helpers.h"
+#include "chre/util/system/message_common.h"
+#include "chre/util/system/system_callback_type.h"
 #include "chre_api/chre/event.h"
 #include "flatbuffers/flatbuffers.h"
 
+#include "pw_allocator/unique_ptr.h"
+
 namespace chre {
 
 typedef flatbuffers::Offset<fbs::NanoappListEntry> NanoappListEntryOffset;
@@ -101,14 +105,11 @@ class HostMessageHandlers {
 
   static void handleNanConfigurationUpdate(bool enabled);
 
-  static void handleBtSocketOpen(uint16_t hostClientId, uint64_t socketId,
-                                 const char *name, uint64_t endpointId,
-                                 uint64_t hubId, uint32_t aclConnectionHandle,
-                                 uint32_t localCid, uint32_t remoteCid,
-                                 uint32_t psm, uint32_t localMtu,
-                                 uint32_t remoteMtu, uint32_t localMps,
-                                 uint32_t remoteMps, uint32_t initialRxCredits,
-                                 uint32_t initialTxCredits);
+  static void handleBtSocketOpen(uint64_t hubId,
+                                 const BleL2capCocSocketData &socketData,
+                                 const char *name, uint32_t psm);
+
+  static void handleBtSocketCapabilitiesRequest();
 
  private:
   static void sendFragmentResponse(uint16_t hostClientId,
@@ -361,6 +362,141 @@ class HostProtocolChre : public HostProtocolCommon {
   static void encodeBtSocketClose(ChreFlatBufferBuilder &builder,
                                   uint16_t hostClientId, uint64_t socketId,
                                   const char *reason);
+
+  /**
+   * Encodes a BT socket capabilities response.
+   *
+   * @param builder An instance of the CHRE Flatbuffer builder.
+   * @param leCocNumberOfSupportedSockets Number of LE CoC sockets supported.
+   * @param leCocMtu Max local MTU of LE CoC sockets.
+   * @param rfcommNumberOfSupportedSockets Number of RFCOMM sockets supported.
+   * @param rfcommMaxFrameSize Max frame size of RFCOMM sockets.
+   */
+  static void encodeBtSocketGetCapabilitiesResponse(
+      ChreFlatBufferBuilder &builder, uint32_t leCocNumberOfSupportedSockets,
+      uint32_t leCocMtu, uint32_t rfcommNumberOfSupportedSockets,
+      uint32_t rfcommMaxFrameSize);
+
+  /**
+   * Encodes the response acking a GetMessageHubsAndEndpointsRequest.
+   *
+   * @param builder Builder which assembles and stores the message.
+   */
+  static void encodeGetMessageHubsAndEndpointsResponse(
+      ChreFlatBufferBuilder &builder);
+
+  /**
+   * Encodes a new embedded hub notification.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Details of the new hub.
+   */
+  static void encodeRegisterMessageHub(ChreFlatBufferBuilder &builder,
+                                       const message::MessageHubInfo &hub);
+
+  /**
+   * Encodes an embedded hub removal notification.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param id Id of the unregistered hub.
+   */
+  static void encodeUnregisterMessageHub(ChreFlatBufferBuilder &builder,
+                                         message::MessageHubId id);
+
+  /**
+   * Encodes a new embedded endpoint notification.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the hub hosting the new endpoint.
+   * @param endpoint Details of the new endpoint.
+   */
+  static void encodeRegisterEndpoint(ChreFlatBufferBuilder &builder,
+                                     message::MessageHubId hub,
+                                     const message::EndpointInfo &endpoint);
+
+  /**
+   * Encodes a notification to add a service hosted by a new embedded endpoint.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the hub hosting the new endpoint.
+   * @param endpoint Id of the new endpoint.
+   * @param service The service being added.
+   */
+  static void encodeAddServiceToEndpoint(ChreFlatBufferBuilder &builder,
+                                         message::MessageHubId hub,
+                                         message::EndpointId endpoint,
+                                         const message::ServiceInfo &service);
+
+  /**
+   * Encodes an embedded endpoint ready notification.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the hub hosting the new endpoint.
+   * @param endpoint Id of the new endpoint.
+   */
+  static void encodeEndpointReady(ChreFlatBufferBuilder &builder,
+                                  message::MessageHubId hub,
+                                  message::EndpointId endpoint);
+
+  /**
+   * Encodes an embedded endpoint removal notification.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the hub hosting the removed endpoint.
+   * @param endpoint Id of the removed endpoint.
+   */
+  static void encodeUnregisterEndpoint(ChreFlatBufferBuilder &builder,
+                                       message::MessageHubId hub,
+                                       message::EndpointId endpoint);
+
+  /**
+   * Encodes a request to open a new session with host endpoint.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param session Details of the new session.
+   */
+  static void encodeOpenEndpointSessionRequest(ChreFlatBufferBuilder &builder,
+                                               const message::Session &session);
+
+  /**
+   * Encodes a notification that a session has been opened.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the destination host hub.
+   * @param session Id of the session that was opened.
+   */
+  static void encodeEndpointSessionOpened(ChreFlatBufferBuilder &builder,
+                                          message::MessageHubId hub,
+                                          message::SessionId session);
+
+  /**
+   * Encodes a notification that a session has been closed.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the destination host hub.
+   * @param session Id of the session that was closed.
+   * @param reason Reason the session was closed (or rejected).
+   */
+  static void encodeEndpointSessionClosed(ChreFlatBufferBuilder &builder,
+                                          message::MessageHubId hub,
+                                          message::SessionId session,
+                                          message::Reason reason);
+
+  /**
+   * Encodes a message sent within an endpoint session.
+   *
+   * @param builder Builder which assembles and stores the message.
+   * @param hub Id of the destination host hub.
+   * @param session Id of the session.
+   * @param data The message data.
+   * @param type The type of the message.
+   * @param permissions The permissions required to receive the message.
+   */
+  static void encodeEndpointSessionMessage(ChreFlatBufferBuilder &builder,
+                                           message::MessageHubId hub,
+                                           message::SessionId session,
+                                           pw::UniquePtr<std::byte[]> &&data,
+                                           uint32_t type, uint32_t permissions);
 };
 
 }  // namespace chre
diff --git a/platform/shared/include/chre/platform/shared/log_buffer.h b/platform/shared/include/chre/platform/shared/log_buffer.h
index 813c773c..1e5747d0 100644
--- a/platform/shared/include/chre/platform/shared/log_buffer.h
+++ b/platform/shared/include/chre/platform/shared/log_buffer.h
@@ -24,7 +24,7 @@
 #include "chre/core/event.h"
 #include "chre/platform/mutex.h"
 #include "chre/platform/shared/bt_snoop_log.h"
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
 
 namespace chre {
 
diff --git a/platform/shared/include/chre/platform/shared/log_buffer_manager.h b/platform/shared/include/chre/platform/shared/log_buffer_manager.h
index 4a5e96f4..887cf3a4 100644
--- a/platform/shared/include/chre/platform/shared/log_buffer_manager.h
+++ b/platform/shared/include/chre/platform/shared/log_buffer_manager.h
@@ -21,7 +21,7 @@
 #include "chre/platform/condition_variable.h"
 #include "chre/platform/mutex.h"
 #include "chre/platform/shared/bt_snoop_log.h"
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
 #include "chre/platform/shared/log_buffer.h"
 #include "chre/util/singleton.h"
 #include "chre_api/chre/re.h"
diff --git a/platform/shared/log_buffer.cc b/platform/shared/log_buffer.cc
index ee03476f..5b4a5a85 100644
--- a/platform/shared/log_buffer.cc
+++ b/platform/shared/log_buffer.cc
@@ -16,7 +16,7 @@
 
 #include "chre/platform/shared/log_buffer.h"
 #include "chre/platform/assert.h"
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
 #include "chre/util/lock_guard.h"
 
 #include <cstdarg>
diff --git a/platform/shared/log_buffer_manager.cc b/platform/shared/log_buffer_manager.cc
index d090068a..0a0bf902 100644
--- a/platform/shared/log_buffer_manager.cc
+++ b/platform/shared/log_buffer_manager.cc
@@ -19,7 +19,7 @@
 #include "chre/core/event_loop_manager.h"
 #include "chre/platform/assert.h"
 #include "chre/platform/shared/bt_snoop_log.h"
-#include "chre/platform/shared/generated/host_messages_generated.h"
+#include "chre/platform/shared/fbs/host_messages_generated.h"
 #include "chre/util/lock_guard.h"
 
 #ifdef CHRE_TOKENIZED_LOGGING_ENABLED
diff --git a/platform/shared/nanoapp/nanoapp_support_lib_dso.cc b/platform/shared/nanoapp/nanoapp_support_lib_dso.cc
index f0d938ae..574bea5b 100644
--- a/platform/shared/nanoapp/nanoapp_support_lib_dso.cc
+++ b/platform/shared/nanoapp/nanoapp_support_lib_dso.cc
@@ -388,6 +388,22 @@ bool chreBleGetScanStatus(struct chreBleScanStatus *status) {
 }
 #endif /* CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_8 */
 
+#if CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_11
+WEAK_SYMBOL
+bool chreBleSocketAccept(uint64_t socketId) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreBleSocketAccept);
+  return (fptr != nullptr) ? fptr(socketId) : false;
+}
+
+WEAK_SYMBOL
+int32_t chreBleSocketSend(uint64_t socketId, const void *data, uint16_t length,
+                          chreBleSocketPacketFreeFunction *freeCallback) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreBleSocketSend);
+  return (fptr != nullptr) ? fptr(socketId, data, length, freeCallback)
+                           : CHRE_ERROR_NOT_SUPPORTED;
+}
+#endif /* CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_11 */
+
 #endif /* CHRE_NANOAPP_USES_BLE */
 
 #if CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_2
@@ -418,6 +434,40 @@ bool chreGnssConfigurePassiveLocationListener(bool enable) {
 }
 #endif /* CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_2 */
 
+#if CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_11
+WEAK_SYMBOL
+bool chreGnssLocationSessionStartAsyncV1_11(uint32_t minIntervalMs,
+                                            uint32_t minTimeToNextFixMs,
+                                            const void *cookie,
+                                            enum chreGnssSource source) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreGnssLocationSessionStartAsyncV1_11);
+  if (fptr != nullptr) {
+    return fptr(minIntervalMs, minTimeToNextFixMs, cookie, source);
+  }
+  if (source == CHRE_GNSS_SOURCE_UNSPECIFIED ||
+      source == CHRE_GNSS_SOURCE_LOCAL) {
+    return chreGnssLocationSessionStartAsync(minIntervalMs, minTimeToNextFixMs,
+                                             cookie);
+  }
+  return false;
+}
+
+WEAK_SYMBOL
+bool chreGnssMeasurementSessionStartAsyncV1_11(uint32_t minIntervalMs,
+                                               const void *cookie,
+                                               enum chreGnssSource source) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreGnssMeasurementSessionStartAsyncV1_11);
+  if (fptr != nullptr) {
+    return fptr(minIntervalMs, cookie, source);
+  }
+  if (source == CHRE_GNSS_SOURCE_UNSPECIFIED ||
+      source == CHRE_GNSS_SOURCE_LOCAL) {
+    return chreGnssMeasurementSessionStartAsync(minIntervalMs, cookie);
+  }
+  return false;
+}
+#endif /* CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_11 */
+
 #endif /* CHRE_NANOAPP_USES_GNSS */
 
 #ifdef CHRE_NANOAPP_USES_WIFI
@@ -576,6 +626,71 @@ bool chreSendReliableMessageAsync(void *message, size_t messageSize,
 }
 #endif /* CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_10 */
 
+// Begin endpoint messaging APIs
+
+#if CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_11
+WEAK_SYMBOL
+bool chreMsgGetEndpointInfo(uint64_t hubId, uint64_t endpointId,
+                            struct chreMsgEndpointInfo *info) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgGetEndpointInfo);
+  return fptr != nullptr ? fptr(hubId, endpointId, info) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgConfigureEndpointReadyEvents(uint64_t hubId, uint64_t endpointId,
+                                         bool enable) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgConfigureEndpointReadyEvents);
+  return fptr != nullptr ? fptr(hubId, endpointId, enable) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgConfigureServiceReadyEvents(uint64_t hubId,
+                                        const char *serviceDescriptor,
+                                        bool enable) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgConfigureServiceReadyEvents);
+  return fptr != nullptr ? fptr(hubId, serviceDescriptor, enable) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgSessionGetInfo(uint16_t sessionId,
+                           struct chreMsgSessionInfo *info) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgSessionGetInfo);
+  return fptr != nullptr ? fptr(sessionId, info) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgPublishServices(const struct chreMsgServiceInfo *services,
+                            size_t numServices) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgPublishServices);
+  return fptr != nullptr ? fptr(services, numServices) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgSessionOpenAsync(uint64_t hubId, uint64_t endpointId,
+                             const char *serviceDescriptor) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgSessionOpenAsync);
+  return fptr != nullptr ? fptr(hubId, endpointId, serviceDescriptor) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgSessionCloseAsync(uint16_t sessionId) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgSessionCloseAsync);
+  return fptr != nullptr ? fptr(sessionId) : false;
+}
+
+WEAK_SYMBOL
+bool chreMsgSend(void *message, size_t messageSize, uint32_t messageType,
+                 uint16_t sessionId, uint32_t messagePermissions,
+                 chreMessageFreeFunction *freeCallback) {
+  auto *fptr = CHRE_NSL_LAZY_LOOKUP(chreMsgSend);
+  return fptr != nullptr ? fptr(message, messageSize, messageType, sessionId,
+                                messagePermissions, freeCallback)
+                         : false;
+}
+#endif /* CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_11 */
+
+// End endpoint messaging APIs
+
 #if CHRE_FIRST_SUPPORTED_API_VERSION < CHRE_API_VERSION_1_5
 WEAK_SYMBOL
 int8_t chreUserSettingGetState(uint8_t setting) {
diff --git a/platform/shared/nanoapp_loader.cc b/platform/shared/nanoapp_loader.cc
index 5eea1560..a827e4fb 100644
--- a/platform/shared/nanoapp_loader.cc
+++ b/platform/shared/nanoapp_loader.cc
@@ -56,12 +56,12 @@ NanoappLoader *gCurrentlyLoadingNanoapp = nullptr;
 //! Indicates whether a failure occurred during static initialization.
 bool gStaticInitFailure = false;
 
-void deleteOpOverride(void* /* ptr */, unsigned int size) {
+void deleteOpOverride(void * /* ptr */, unsigned int size) {
   FATAL_ERROR("Nanoapp: delete(void *, unsigned int) override : sz = %u", size);
 }
 
 #ifdef __clang__
-void deleteOp2Override(void*) {
+void deleteOp2Override(void *) {
   FATAL_ERROR("Nanoapp: delete(void *)");
 }
 #endif
@@ -218,12 +218,14 @@ const ExportedData kExportedData[] = {
     ADD_EXPORTED_C_SYMBOL(chreBleGetCapabilities),
     ADD_EXPORTED_C_SYMBOL(chreBleGetFilterCapabilities),
     ADD_EXPORTED_C_SYMBOL(chreBleFlushAsync),
+    ADD_EXPORTED_C_SYMBOL(chreBleGetScanStatus),
+    ADD_EXPORTED_C_SYMBOL(chreBleReadRssiAsync),
+    ADD_EXPORTED_C_SYMBOL(chreBleSocketAccept),
+    ADD_EXPORTED_C_SYMBOL(chreBleSocketSend),
     ADD_EXPORTED_C_SYMBOL(chreBleStartScanAsync),
     ADD_EXPORTED_C_SYMBOL(chreBleStartScanAsyncV1_9),
     ADD_EXPORTED_C_SYMBOL(chreBleStopScanAsync),
     ADD_EXPORTED_C_SYMBOL(chreBleStopScanAsyncV1_9),
-    ADD_EXPORTED_C_SYMBOL(chreBleReadRssiAsync),
-    ADD_EXPORTED_C_SYMBOL(chreBleGetScanStatus),
     ADD_EXPORTED_C_SYMBOL(chreConfigureDebugDumpEvent),
     ADD_EXPORTED_C_SYMBOL(chreConfigureHostSleepStateEvents),
     ADD_EXPORTED_C_SYMBOL(chreConfigureNanoappInfoEvents),
@@ -251,6 +253,16 @@ const ExportedData kExportedData[] = {
     ADD_EXPORTED_C_SYMBOL(chreHeapFree),
     ADD_EXPORTED_C_SYMBOL(chreIsHostAwake),
     ADD_EXPORTED_C_SYMBOL(chreLog),
+#ifdef CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
+    ADD_EXPORTED_C_SYMBOL(chreMsgConfigureEndpointReadyEvents),
+    ADD_EXPORTED_C_SYMBOL(chreMsgConfigureServiceReadyEvents),
+    ADD_EXPORTED_C_SYMBOL(chreMsgGetEndpointInfo),
+    ADD_EXPORTED_C_SYMBOL(chreMsgPublishServices),
+    ADD_EXPORTED_C_SYMBOL(chreMsgSend),
+    ADD_EXPORTED_C_SYMBOL(chreMsgSessionCloseAsync),
+    ADD_EXPORTED_C_SYMBOL(chreMsgSessionGetInfo),
+    ADD_EXPORTED_C_SYMBOL(chreMsgSessionOpenAsync),
+#endif  // CHRE_MESSAGE_ROUTER_SUPPORT_ENABLED
     ADD_EXPORTED_C_SYMBOL(chreSendEvent),
     ADD_EXPORTED_C_SYMBOL(chreSendMessageToHost),
     ADD_EXPORTED_C_SYMBOL(chreSendMessageToHostEndpoint),
diff --git a/platform/slpi/host_link.cc b/platform/slpi/host_link.cc
index a32f9e62..d4bcf8ff 100644
--- a/platform/slpi/host_link.cc
+++ b/platform/slpi/host_link.cc
@@ -929,12 +929,12 @@ void HostMessageHandlers::handleNanConfigurationUpdate(bool enabled) {
 }
 
 void HostMessageHandlers::handleBtSocketOpen(
-    uint16_t /* hostClientId */, uint64_t /* socketId */,
-    const char * /* name */, uint64_t /* endpointId */, uint64_t /* hubId */,
-    uint32_t /* aclConnectionHandle */, uint32_t /* localCid */,
-    uint32_t /* remoteCid */, uint32_t /* psm */, uint32_t /* localMtu */,
-    uint32_t /* remoteMtu */, uint32_t /* localMps */, uint32_t /* remoteMps */,
-    uint32_t /* initialRxCredits */, uint32_t /* initialTxCredits */) {
+    uint64_t /* hubId */, const BleL2capCocSocketData & /* socketData */,
+    const char * /* name */, uint32_t /* psm */) {
+  LOGE("BT Socket offload not supported");
+}
+
+void HostMessageHandlers::handleBtSocketCapabilitiesRequest() {
   LOGE("BT Socket offload not supported");
 }
 
diff --git a/platform/tinysys/host_link.cc b/platform/tinysys/host_link.cc
index f6f47127..68b80cc1 100644
--- a/platform/tinysys/host_link.cc
+++ b/platform/tinysys/host_link.cc
@@ -936,12 +936,8 @@ DRAM_REGION_FUNCTION void HostMessageHandlers::handleNanConfigurationUpdate(
 }
 
 DRAM_REGION_FUNCTION void HostMessageHandlers::handleBtSocketOpen(
-    uint16_t /* hostClientId */, uint64_t /* socketId */,
-    const char * /* name */, uint64_t /* endpointId */, uint64_t /* hubId */,
-    uint32_t /* aclConnectionHandle */, uint32_t /* localCid */,
-    uint32_t /* remoteCid */, uint32_t /* psm */, uint32_t /* localMtu */,
-    uint32_t /* remoteMtu */, uint32_t /* localMps */, uint32_t /* remoteMps */,
-    uint32_t /* initialRxCredits */, uint32_t /* initialTxCredits */) {
+    uint64_t /* hubId */, const BleL2capCocSocketData & /* socketData */,
+    const char * /* name */, uint32_t /* psm */) {
   LOGE("BT Socket offload not supported");
 }
 
@@ -963,4 +959,8 @@ DRAM_REGION_FUNCTION void sendAudioRelease() {
                          kInitialSize, msgBuilder, /* cookie= */ nullptr);
 }
 
+void HostMessageHandlers::handleBtSocketCapabilitiesRequest() {
+  LOGE("BT Socket offload not supported");
+}
+
 }  // namespace chre
diff --git a/platform/tinysys/memory.cc b/platform/tinysys/memory.cc
index b67c8363..0c117536 100644
--- a/platform/tinysys/memory.cc
+++ b/platform/tinysys/memory.cc
@@ -45,7 +45,11 @@ void DramVoteClient::issueDramVote(bool /*enabled*/) {}
 void forceDramAccess() {}
 
 void nanoappBinaryFree(void *pointer) {
+#ifdef NANOAPP_ALWAYS_IN_DRAM
+  aligned_dram_free(pointer);
+#else
   aligned_free(pointer);
+#endif
 }
 
 void nanoappBinaryDramFree(void *pointer) {
@@ -69,6 +73,9 @@ void palSystemApiMemoryFree(void *pointer) {
 }
 
 void *nanoappBinaryAlloc(size_t size, size_t alignment) {
+#ifdef NANOAPP_ALWAYS_IN_DRAM
+  return aligned_dram_malloc(size, alignment);
+#endif
   return aligned_malloc(size, alignment);
 }
 
diff --git a/platform/zephyr/CMakeLists.txt b/platform/zephyr/CMakeLists.txt
index b011f15c..f2a9338d 100644
--- a/platform/zephyr/CMakeLists.txt
+++ b/platform/zephyr/CMakeLists.txt
@@ -25,6 +25,7 @@ if(CONFIG_CHRE)
       "${CHRE_DIR}/pal/include"
       "${CHRE_DIR}/platform/include"
       "${CHRE_DIR}/platform/shared/include"
+      "${CHRE_DIR}/platform/shared/fbs/include"
       "${CHRE_DIR}/util/include"
       "${CMAKE_CURRENT_SOURCE_DIR}/include")
   zephyr_include_directories("${CHRE_INCLUDE_DIRS}")
diff --git a/test/simulation/audio_test.cc b/test/simulation/audio_test.cc
index 85ddc6d3..f6ed7111 100644
--- a/test/simulation/audio_test.cc
+++ b/test/simulation/audio_test.cc
@@ -36,6 +36,8 @@
 namespace chre {
 namespace {
 
+class AudioTest : public TestBase {};
+
 class AudioNanoapp : public TestNanoapp {
  public:
   AudioNanoapp()
@@ -49,7 +51,7 @@ class AudioNanoapp : public TestNanoapp {
   }
 };
 
-TEST_F(TestBase, AudioCanSubscribeAndUnsubscribeToDataEvents) {
+TEST_F(AudioTest, AudioCanSubscribeAndUnsubscribeToDataEvents) {
   CREATE_CHRE_TEST_EVENT(CONFIGURE, 0);
 
   class App : public AudioNanoapp {
@@ -119,7 +121,7 @@ TEST_F(TestBase, AudioCanSubscribeAndUnsubscribeToDataEvents) {
   EXPECT_FALSE(chrePalAudioIsHandle0Enabled());
 }
 
-TEST_F(TestBase, AudioUnsubscribeToDataEventsOnUnload) {
+TEST_F(AudioTest, AudioUnsubscribeToDataEventsOnUnload) {
   CREATE_CHRE_TEST_EVENT(CONFIGURE, 0);
 
   class App : public AudioNanoapp {
diff --git a/test/simulation/ble_test.cc b/test/simulation/ble_test.cc
index a2912e96..d948b08a 100644
--- a/test/simulation/ble_test.cc
+++ b/test/simulation/ble_test.cc
@@ -34,12 +34,14 @@ namespace chre {
 
 namespace {
 
+class BleTest : public TestBase {};
+
 /**
  * This test verifies that a nanoapp can query for BLE capabilities and filter
  * capabilities. Note that a nanoapp does not require BLE permissions to use
  * these APIs.
  */
-TEST_F(TestBase, BleCapabilitiesTest) {
+TEST_F(BleTest, BleCapabilitiesTest) {
   CREATE_CHRE_TEST_EVENT(GET_CAPABILITIES, 0);
   CREATE_CHRE_TEST_EVENT(GET_FILTER_CAPABILITIES, 1);
 
@@ -109,7 +111,7 @@ class BleTestNanoapp : public TestNanoapp {
  * This test validates the case in which a nanoapp starts a scan, receives
  * at least one advertisement event, and stops a scan.
  */
-TEST_F(TestBase, BleSimpleScanTest) {
+TEST_F(BleTest, BleSimpleScanTest) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(STOP_SCAN, 2);
@@ -177,7 +179,7 @@ TEST_F(TestBase, BleSimpleScanTest) {
   ASSERT_FALSE(chrePalIsBleEnabled());
 }
 
-TEST_F(TestBase, BleStopScanOnUnload) {
+TEST_F(BleTest, BleStopScanOnUnload) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
 
@@ -228,7 +230,7 @@ TEST_F(TestBase, BleStopScanOnUnload) {
  * This test validates that a nanoapp can start a scan twice and the platform
  * will be enabled.
  */
-TEST_F(TestBase, BleStartTwiceScanTest) {
+TEST_F(BleTest, BleStartTwiceScanTest) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(STOP_SCAN, 2);
@@ -302,7 +304,7 @@ TEST_F(TestBase, BleStartTwiceScanTest) {
  * any ongoing scan existing. It asserts that the nanoapp did not receive any
  * advertisment events because a scan was never started.
  */
-TEST_F(TestBase, BleStopTwiceScanTest) {
+TEST_F(BleTest, BleStopTwiceScanTest) {
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(STOP_SCAN, 2);
   CREATE_CHRE_TEST_EVENT(SCAN_STOPPED, 3);
@@ -366,7 +368,7 @@ TEST_F(TestBase, BleStopTwiceScanTest) {
  * 3) Toggle BLE setting -> enabled.
  * 4) Verify things resume.
  */
-TEST_F(TestBase, BleSettingChangeTest) {
+TEST_F(BleTest, BleSettingChangeTest) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(SCAN_STOPPED, 3);
@@ -455,7 +457,7 @@ TEST_F(TestBase, BleSettingChangeTest) {
  * Test that a nanoapp receives a function disabled error if it attempts to
  * start a scan when the BLE setting is disabled.
  */
-TEST_F(TestBase, BleSettingDisabledStartScanTest) {
+TEST_F(BleTest, BleSettingDisabledStartScanTest) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
 
   class App : public BleTestNanoapp {
@@ -517,7 +519,7 @@ TEST_F(TestBase, BleSettingDisabledStartScanTest) {
  * Test that a nanoapp receives a success response when it attempts to stop a
  * BLE scan while the BLE setting is disabled.
  */
-TEST_F(TestBase, BleSettingDisabledStopScanTest) {
+TEST_F(BleTest, BleSettingDisabledStopScanTest) {
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(STOP_SCAN, 2);
   CREATE_CHRE_TEST_EVENT(SCAN_STOPPED, 3);
@@ -582,7 +584,7 @@ TEST_F(TestBase, BleSettingDisabledStopScanTest) {
 /**
  * Test that a nanoapp can read RSSI successfully.
  */
-TEST_F(TestBase, BleReadRssi) {
+TEST_F(BleTest, BleReadRssi) {
   constexpr uint16_t kConnectionHandle = 6;
   constexpr uint32_t kCookie = 123;
 
@@ -645,7 +647,7 @@ TEST_F(TestBase, BleReadRssi) {
  * receiving an async response. It should invalidate its original request by
  * calling start scan a second time.
  */
-TEST_F(TestBase, BleStartScanTwiceBeforeAsyncResponseTest) {
+TEST_F(BleTest, BleStartScanTwiceBeforeAsyncResponseTest) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(STOP_SCAN, 2);
@@ -733,7 +735,7 @@ TEST_F(TestBase, BleStartScanTwiceBeforeAsyncResponseTest) {
  * is enabled for the nanoapp. This test validates that batching will hold the
  * data and flush will send the batched data and then a flush complete event.
  */
-TEST_F(TestBase, BleFlush) {
+TEST_F(BleTest, BleFlush) {
   CREATE_CHRE_TEST_EVENT(START_SCAN, 0);
   CREATE_CHRE_TEST_EVENT(SCAN_STARTED, 1);
   CREATE_CHRE_TEST_EVENT(STOP_SCAN, 2);
diff --git a/test/simulation/chre_message_hub_test.cc b/test/simulation/chre_message_hub_test.cc
index 7b3a0d33..97c8ac6c 100644
--- a/test/simulation/chre_message_hub_test.cc
+++ b/test/simulation/chre_message_hub_test.cc
@@ -14,30 +14,54 @@
  * limitations under the License.
  */
 
-#include <cstdint>
-#include <cstring>
-#include <optional>
-
 #include "chre/core/event_loop_manager.h"
 #include "chre/util/dynamic_vector.h"
 #include "chre/util/system/message_common.h"
 #include "chre/util/system/message_router.h"
 #include "chre/util/system/napp_permissions.h"
+#include "chre_api/chre.h"
 #include "chre_api/chre/event.h"
 
 #include "pw_allocator/allocator.h"
 #include "pw_allocator/libc_allocator.h"
 #include "pw_allocator/unique_ptr.h"
 #include "pw_function/function.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
 
 #include "gtest/gtest.h"
 #include "inc/test_util.h"
 #include "test_base.h"
+#include "test_event.h"
 #include "test_util.h"
 
+#include <condition_variable>
+#include <cstdint>
+#include <cstring>
+#include <mutex>
+#include <optional>
+
 namespace chre::message {
 namespace {
 
+CREATE_CHRE_TEST_EVENT(TEST_GET_EVENT_INFO, 0);
+CREATE_CHRE_TEST_EVENT(TEST_OPEN_SESSION, 1);
+CREATE_CHRE_TEST_EVENT(TEST_OPEN_DEFAULT_SESSION, 2);
+CREATE_CHRE_TEST_EVENT(TEST_OPEN_SESSION_NANOAPP_TO_NANOAPP, 3);
+CREATE_CHRE_TEST_EVENT(TEST_CLOSE_SESSION, 4);
+CREATE_CHRE_TEST_EVENT(TEST_CLOSE_SESSION_NON_PARTY, 5);
+CREATE_CHRE_TEST_EVENT(TEST_GET_SESSION_INFO_INVALID_SESSION, 6);
+CREATE_CHRE_TEST_EVENT(TEST_SEND_MESSAGE, 7);
+CREATE_CHRE_TEST_EVENT(TEST_SEND_MESSAGE_NO_FREE_CALLBACK, 8);
+CREATE_CHRE_TEST_EVENT(TEST_SEND_MESSAGE_NANOAPP_TO_NANOAPP, 9);
+CREATE_CHRE_TEST_EVENT(TEST_PUBLISH_SERVICE, 10);
+CREATE_CHRE_TEST_EVENT(TEST_BAD_LEGACY_SERVICE_NAME, 11);
+CREATE_CHRE_TEST_EVENT(TEST_OPEN_SESSION_WITH_SERVICE, 12);
+CREATE_CHRE_TEST_EVENT(TEST_SUBSCRIBE_TO_READY_EVENT, 13);
+CREATE_CHRE_TEST_EVENT(TEST_SUBSCRIBE_TO_READY_EVENT_ALREADY_EXISTS, 14);
+CREATE_CHRE_TEST_EVENT(TEST_UNSUBSCRIBE_FROM_READY_EVENT, 15);
+CREATE_CHRE_TEST_EVENT(TEST_SUBSCRIBE_TO_SERVICE_READY_EVENT, 16);
+CREATE_CHRE_TEST_EVENT(TEST_UNSUBSCRIBE_FROM_SERVICE_READY_EVENT, 17);
+
 constexpr size_t kNumEndpoints = 3;
 constexpr size_t kMessageSize = 5;
 constexpr MessageHubId kOtherMessageHubId = 0xDEADBEEFBEEFDEAD;
@@ -49,6 +73,20 @@ EndpointInfo kEndpointInfos[kNumEndpoints] = {
                  EndpointType::HOST_NATIVE, CHRE_MESSAGE_PERMISSION_BLE),
     EndpointInfo(/* id= */ 3, /* name= */ "endpoint3", /* version= */ 100,
                  EndpointType::GENERIC, CHRE_MESSAGE_PERMISSION_AUDIO)};
+EndpointInfo kDynamicEndpointInfo = EndpointInfo(
+    /* id= */ 4, /* name= */ "DynamicallyRegisteredEndpoint",
+    /* version= */ 1, EndpointType::NANOAPP, CHRE_MESSAGE_PERMISSION_NONE);
+
+const char kServiceDescriptorForEndpoint2[] = "TEST_SERVICE.TEST";
+const char kServiceDescriptorForDynamicEndpoint[] = "TEST_DYNAMIC_SERVICE";
+const char kServiceDescriptorForNanoapp[] = "TEST_NANOAPP.TEST_SERVICE";
+const uint64_t kLegacyServiceId = 0xDEADBEEFDEADBEEF;
+const uint32_t kLegacyServiceVersion = 1;
+const uint64_t kLegacyServiceNanoappId = 0xCAFECAFECAFECAFE;
+const char kLegacyServiceName[] =
+    "chre.nanoapp_0xCAFECAFECAFECAFE.service_0xDEADBEEFDEADBEEF";
+const char kBadLegacyServiceName[] =
+    "chre.nanoapp_0xCAFECAFECAFECAFE.service_0x0123456789ABCDEF";
 
 //! Base class for MessageHubCallbacks used in tests
 class MessageHubCallbackBase : public MessageRouter::MessageHubCallback {
@@ -70,6 +108,103 @@ class MessageHubCallbackBase : public MessageRouter::MessageHubCallback {
     }
     return std::nullopt;
   }
+
+  void onSessionOpened(const Session &session) override {
+    bool shouldNotify = false;
+    {
+      std::unique_lock<std::mutex> lock(mSessionOpenedMutex);
+      if (mSessionId == SESSION_ID_INVALID) {
+        return;
+      }
+      if (mSessionId == session.sessionId) {
+        shouldNotify = true;
+        mSessionId = SESSION_ID_INVALID;
+      }
+    }
+    if (shouldNotify) {
+      mSessionOpenedCondVar.notify_one();
+    }
+  }
+
+  std::optional<EndpointId> getEndpointForService(
+      const char *serviceDescriptor) override {
+    if (serviceDescriptor != nullptr &&
+        std::strcmp(serviceDescriptor, kServiceDescriptorForEndpoint2) == 0) {
+      return kEndpointInfos[1].id;
+    }
+    return std::nullopt;
+  }
+
+  bool doesEndpointHaveService(EndpointId endpointId,
+                               const char *serviceDescriptor) override {
+    if (serviceDescriptor == nullptr) {
+      return false;
+    }
+    if (endpointId == kEndpointInfos[1].id) {
+      return std::strcmp(serviceDescriptor, kServiceDescriptorForEndpoint2) ==
+             0;
+    }
+    if (endpointId == kDynamicEndpointInfo.id) {
+      return std::strcmp(serviceDescriptor,
+                         kServiceDescriptorForDynamicEndpoint) == 0;
+    }
+    return false;
+  }
+
+  void forEachService(
+      const pw::Function<bool(const EndpointInfo &, const ServiceInfo &)>
+          &function) override {
+    if (function(
+            kEndpointInfos[1],
+            ServiceInfo(kServiceDescriptorForEndpoint2, /* majorVersion= */ 1,
+                        /* minorVersion= */ 0, RpcFormat::CUSTOM))) {
+      return;
+    }
+
+    function(kDynamicEndpointInfo,
+             ServiceInfo(kServiceDescriptorForDynamicEndpoint,
+                         /* majorVersion= */ 1,
+                         /* minorVersion= */ 0, RpcFormat::CUSTOM));
+  }
+
+  void onHubRegistered(const MessageHubInfo & /*info*/) override {}
+
+  void onHubUnregistered(MessageHubId /*id*/) override {}
+
+  void onEndpointRegistered(MessageHubId messageHubId,
+                            EndpointId endpointId) override {
+    mRegisteredEndpoints.insert(std::make_pair(messageHubId, endpointId));
+  }
+
+  void onEndpointUnregistered(MessageHubId messageHubId,
+                              EndpointId endpointId) override {
+    mRegisteredEndpoints.erase(std::make_pair(messageHubId, endpointId));
+  }
+
+  bool hasEndpointBeenRegistered(MessageHubId messageHubId,
+                                 EndpointId endpointId) {
+    return mRegisteredEndpoints.find(std::make_pair(
+               messageHubId, endpointId)) != mRegisteredEndpoints.end();
+  }
+
+  void pw_recycle() override {
+    delete this;
+  }
+
+  void openSessionAndWaitForOpen(
+      const std::function<SessionId()> &openSession) {
+    std::unique_lock<std::mutex> lock(mSessionOpenedMutex);
+    mSessionId = openSession();
+    mSessionOpenedCondVar.wait(
+        lock, [this]() { return mSessionId == SESSION_ID_INVALID; });
+  }
+
+ private:
+  std::set<std::pair<MessageHubId, EndpointId>> mRegisteredEndpoints;
+
+  std::mutex mSessionOpenedMutex;
+  std::condition_variable mSessionOpenedCondVar;
+  SessionId mSessionId = SESSION_ID_INVALID;
 };
 
 //! MessageHubCallback that stores the data passed to onMessageReceived and
@@ -77,9 +212,9 @@ class MessageHubCallbackBase : public MessageRouter::MessageHubCallback {
 class MessageHubCallbackStoreData : public MessageHubCallbackBase {
  public:
   MessageHubCallbackStoreData(Message *message, Session *session)
-      : mMessage(message), mSession(session) {}
+      : mMessage(message), mSession(session), mMessageHub(nullptr) {}
 
-  bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data, size_t length,
+  bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
                          uint32_t messageType, uint32_t messagePermissions,
                          const Session &session,
                          bool sentBySessionInitiator) override {
@@ -90,27 +225,49 @@ class MessageHubCallbackStoreData : public MessageHubCallbackBase {
           sentBySessionInitiator ? session.peer : session.initiator;
       mMessage->sessionId = session.sessionId;
       mMessage->data = std::move(data);
-      mMessage->length = length;
       mMessage->messageType = messageType;
       mMessage->messagePermissions = messagePermissions;
     }
     return true;
   }
 
-  void onSessionClosed(const Session &session) override {
+  void onSessionClosed(const Session &session, Reason /* reason */) override {
     if (mSession != nullptr) {
       *mSession = session;
     }
   }
 
+  void onSessionOpenRequest(const Session &session) override {
+    if (mMessageHub != nullptr) {
+      mMessageHub->onSessionOpenComplete(session.sessionId);
+    }
+  }
+
+  void setMessageHub(MessageRouter::MessageHub *messageHub) {
+    mMessageHub = messageHub;
+  }
+
  private:
   Message *mMessage;
   Session *mSession;
+  MessageRouter::MessageHub *mMessageHub;
 };
 
+// Creates a message with data from 1 to messageSize
+pw::UniquePtr<std::byte[]> createMessageData(
+    pw::allocator::Allocator &allocator, size_t messageSize) {
+  pw::UniquePtr<std::byte[]> messageData =
+      allocator.MakeUniqueArray<std::byte>(messageSize);
+  EXPECT_NE(messageData.get(), nullptr);
+  for (size_t i = 0; i < messageSize; ++i) {
+    messageData[i] = static_cast<std::byte>(i + 1);
+  }
+  return messageData;
+}
+
 class ChreMessageHubTest : public TestBase {};
 
-TEST_F(ChreMessageHubTest, MessageRouterNanoappsAreEndpointsToChreMessageHub) {
+TEST_F(ChreMessageHubTest, NanoappsAreEndpointsToChreMessageHub) {
   class App : public TestNanoapp {
    public:
     App() : TestNanoapp(TestNanoappInfo{.name = "TEST1", .id = 0x1234}) {}
@@ -137,8 +294,70 @@ TEST_F(ChreMessageHubTest, MessageRouterNanoappsAreEndpointsToChreMessageHub) {
             nanoapp->getAppPermissions());
 }
 
-TEST_F(ChreMessageHubTest,
-       MessageRouterMultipleNanoappsAreEndpointsToChreMessageHub) {
+//! Nanoapp used to test getting endpoint info
+class EndpointInfoTestApp : public TestNanoapp {
+ public:
+  EndpointInfoTestApp(const TestNanoappInfo &info) : TestNanoapp(info) {}
+
+  void handleEvent(uint32_t, uint16_t eventType,
+                   const void *eventData) override {
+    switch (eventType) {
+      case CHRE_EVENT_TEST_EVENT: {
+        auto event = static_cast<const TestEvent *>(eventData);
+        switch (event->type) {
+          case TEST_GET_EVENT_INFO: {
+            for (size_t i = 0; i < kNumEndpoints; ++i) {
+              chreMsgEndpointInfo info = {};
+              EXPECT_TRUE(chreMsgGetEndpointInfo(kOtherMessageHubId,
+                                                 kEndpointInfos[i].id, &info));
+
+              EXPECT_EQ(info.hubId, kOtherMessageHubId);
+              EXPECT_EQ(info.endpointId, kEndpointInfos[i].id);
+              EXPECT_EQ(info.version, kEndpointInfos[i].version);
+              EXPECT_EQ(info.type,
+                        EventLoopManagerSingleton::get()
+                            ->getChreMessageHubManager()
+                            .toChreEndpointType(kEndpointInfos[i].type));
+              EXPECT_EQ(info.requiredPermissions,
+                        kEndpointInfos[i].requiredPermissions);
+              EXPECT_STREQ(info.name, kEndpointInfos[i].name);
+            }
+            triggerWait(TEST_GET_EVENT_INFO);
+            break;
+          }
+        }
+        break;
+      }
+      default: {
+        break;
+      }
+    }
+  }
+};
+
+TEST_F(ChreMessageHubTest, NanoappGetsEndpointInfo) {
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<EndpointInfoTestApp>(
+
+      TestNanoappInfo{.name = "TEST_GET_ENDPOINT_INFO", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test getting endpoint info
+  sendEventToNanoappAndWait(appId, TEST_GET_EVENT_INFO, TEST_GET_EVENT_INFO);
+}
+
+TEST_F(ChreMessageHubTest, MultipleNanoappsAreEndpointsToChreMessageHub) {
   class App : public TestNanoapp {
    public:
     App() : TestNanoapp(TestNanoappInfo{.name = "TEST1", .id = 0x1234}) {}
@@ -160,8 +379,8 @@ TEST_F(ChreMessageHubTest,
   DynamicVector<EndpointInfo> endpointInfos;
   EXPECT_TRUE(MessageRouterSingleton::get()->forEachEndpointOfHub(
       EventLoopManagerSingleton::get()
-           ->getChreMessageHubManager()
-           .kChreMessageHubId,
+          ->getChreMessageHubManager()
+          .kChreMessageHubId,
       [&endpointInfos](const EndpointInfo &endpointInfo) {
         endpointInfos.push_back(endpointInfo);
         return false;
@@ -182,48 +401,38 @@ TEST_F(ChreMessageHubTest,
 //! Nanoapp used to test sending messages from a generic endpoint to a nanoapp
 class MessageTestApp : public TestNanoapp {
  public:
-  MessageTestApp(std::mutex &mutex, std::condition_variable &condVar,
-                 bool &messageReceivedAndValidated, bool &sessionClosed,
+  MessageTestApp(bool &messageReceivedAndValidated, bool &sessionClosed,
                  const TestNanoappInfo &info)
       : TestNanoapp(info),
-        mMutex(mutex),
-        mCondVar(condVar),
         mMessageReceivedAndValidated(messageReceivedAndValidated),
         mSessionClosed(sessionClosed) {}
 
   void handleEvent(uint32_t, uint16_t eventType,
                    const void *eventData) override {
     switch (eventType) {
-      case CHRE_EVENT_MESSAGE_FROM_ENDPOINT: {
-        {
-          std::unique_lock<std::mutex> lock(mMutex);
-          auto *message =
-              static_cast<const struct chreMessageFromEndpointData *>(
-                  eventData);
-          EXPECT_EQ(message->messageType, 1);
-          EXPECT_EQ(message->messagePermissions, 0);
-          EXPECT_EQ(message->messageSize, kMessageSize);
-
-          auto *messageData = static_cast<const std::byte *>(message->message);
-          for (size_t i = 0; i < kMessageSize; ++i) {
-            EXPECT_EQ(messageData[i], static_cast<std::byte>(i + 1));
-          }
-          mMessageReceivedAndValidated = true;
+      case CHRE_EVENT_MSG_FROM_ENDPOINT: {
+        auto *message =
+            static_cast<const struct chreMsgMessageFromEndpointData *>(
+                eventData);
+        EXPECT_EQ(message->messageType, 1);
+        EXPECT_EQ(message->messagePermissions, 0);
+        EXPECT_EQ(message->messageSize, kMessageSize);
+
+        auto *messageData = static_cast<const std::byte *>(message->message);
+        for (size_t i = 0; i < kMessageSize; ++i) {
+          EXPECT_EQ(messageData[i], static_cast<std::byte>(i + 1));
         }
-        mCondVar.notify_one();
+        mMessageReceivedAndValidated = true;
+        triggerWait(CHRE_EVENT_MSG_FROM_ENDPOINT);
         break;
       }
-      case CHRE_EVENT_ENDPOINT_SESSION_CLOSED: {
-        {
-          std::unique_lock<std::mutex> lock(mMutex);
-          auto *session =
-              static_cast<const struct chreEndpointSessionClosedData *>(
-                  eventData);
-          EXPECT_EQ(session->hubId, kOtherMessageHubId);
-          EXPECT_EQ(session->endpointId, kEndpointInfos[0].id);
-          mSessionClosed = true;
-        }
-        mCondVar.notify_one();
+      case CHRE_EVENT_MSG_SESSION_CLOSED: {
+        auto *session =
+            static_cast<const struct chreMsgSessionInfo *>(eventData);
+        EXPECT_EQ(session->hubId, kOtherMessageHubId);
+        EXPECT_EQ(session->endpointId, kEndpointInfos[0].id);
+        mSessionClosed = true;
+        triggerWait(CHRE_EVENT_MSG_SESSION_CLOSED);
         break;
       }
       default: {
@@ -232,77 +441,75 @@ class MessageTestApp : public TestNanoapp {
     }
   }
 
-  std::mutex &mMutex;
-  std::condition_variable &mCondVar;
   bool &mMessageReceivedAndValidated;
   bool &mSessionClosed;
 };
 
-TEST_F(ChreMessageHubTest, MessageRouterSendMessageToNanoapp) {
+TEST_F(ChreMessageHubTest, SendMessageToNanoapp) {
   constexpr uint64_t kNanoappId = 0x1234;
-  std::mutex mutex;
-  std::condition_variable condVar;
+
   bool messageReceivedAndValidated = false;
   bool sessionClosed = false;
 
+  // Create the message
   pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
   pw::UniquePtr<std::byte[]> messageData =
-      allocator.MakeUniqueArray<std::byte>(kMessageSize);
-  for (size_t i = 0; i < kMessageSize; ++i) {
-    messageData[i] = static_cast<std::byte>(i + 1);
-  }
+      createMessageData(allocator, kMessageSize);
 
   // Load the nanoapp
   uint64_t appId = loadNanoapp(MakeUnique<MessageTestApp>(
-      mutex, condVar, messageReceivedAndValidated, sessionClosed,
+      messageReceivedAndValidated, sessionClosed,
       TestNanoappInfo{.name = "TEST1", .id = kNanoappId}));
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
 
   // Create the other hub
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub =
       MessageRouterSingleton::get()->registerMessageHub(
           "OTHER_TEST_HUB", kOtherMessageHubId, callback);
   ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
 
   // Open the session from the other hub:1 to the nanoapp
-  SessionId sessionId =
-      messageHub->openSession(kEndpointInfos[0].id,
-                              EventLoopManagerSingleton::get()
-                                   ->getChreMessageHubManager()
-                                   .kChreMessageHubId,
-                              kNanoappId);
-  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  SessionId sessionId = SESSION_ID_INVALID;
+  callback->openSessionAndWaitForOpen([&sessionId, &messageHub]() {
+    sessionId = messageHub->openSession(kEndpointInfos[0].id,
+                                        EventLoopManagerSingleton::get()
+                                            ->getChreMessageHubManager()
+                                            .kChreMessageHubId,
+                                        kNanoappId);
+    EXPECT_NE(sessionId, SESSION_ID_INVALID);
+    return sessionId;
+  });
 
   // Send the message to the nanoapp
-  std::unique_lock<std::mutex> lock(mutex);
-  ASSERT_TRUE(messageHub->sendMessage(std::move(messageData), kMessageSize,
+  ASSERT_TRUE(messageHub->sendMessage(std::move(messageData),
                                       /* messageType= */ 1,
                                       /* messagePermissions= */ 0, sessionId));
-  condVar.wait(lock);
+  testNanoapp->wait(CHRE_EVENT_MSG_FROM_ENDPOINT);
   EXPECT_TRUE(messageReceivedAndValidated);
 
   // Close the session
   EXPECT_TRUE(messageHub->closeSession(sessionId));
-  condVar.wait(lock);
+  testNanoapp->wait(CHRE_EVENT_MSG_SESSION_CLOSED);
   EXPECT_TRUE(sessionClosed);
 }
 
+//! Nanoapp used to test sending messages from a generic endpoint to a nanoapp
+//! with a different permissions set
 class MessagePermissionTestApp : public MessageTestApp {
  public:
-  MessagePermissionTestApp(std::mutex &mutex, std::condition_variable &condVar,
-                           bool &messageReceivedAndValidated,
+  MessagePermissionTestApp(bool &messageReceivedAndValidated,
                            bool &sessionClosed, const TestNanoappInfo &info)
-      : MessageTestApp(mutex, condVar, messageReceivedAndValidated,
-                       sessionClosed, info) {}
+      : MessageTestApp(messageReceivedAndValidated, sessionClosed, info) {}
 };
 
-TEST_F(ChreMessageHubTest, MessageRouterSendMessageToNanoappPermissionFailure) {
-  CREATE_CHRE_TEST_EVENT(TRIGGER_COND_VAR, 0);
-
+TEST_F(ChreMessageHubTest, SendMessageToNanoappPermissionFailure) {
   constexpr uint64_t kNanoappId = 0x1234;
-  std::mutex mutex;
-  std::condition_variable condVar;
+
   bool messageReceivedAndValidated = false;
   bool sessionClosed = false;
 
@@ -315,45 +522,1202 @@ TEST_F(ChreMessageHubTest, MessageRouterSendMessageToNanoappPermissionFailure) {
 
   // Load the nanoapp
   uint64_t appId = loadNanoapp(MakeUnique<MessagePermissionTestApp>(
-      mutex, condVar, messageReceivedAndValidated, sessionClosed,
+      messageReceivedAndValidated, sessionClosed,
       TestNanoappInfo{
           .name = "TEST1", .id = kNanoappId, .perms = CHRE_PERMS_BLE}));
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
 
   // Create the other hub
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub =
       MessageRouterSingleton::get()->registerMessageHub(
           "OTHER_TEST_HUB", kOtherMessageHubId, callback);
   ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
 
   // Open the session from the other hub:1 to the nanoapp
-  SessionId sessionId =
-      messageHub->openSession(kEndpointInfos[0].id,
-                              EventLoopManagerSingleton::get()
-                                   ->getChreMessageHubManager()
-                                   .kChreMessageHubId,
-                              kNanoappId);
-  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  SessionId sessionId = SESSION_ID_INVALID;
+  callback->openSessionAndWaitForOpen([&sessionId, &messageHub]() {
+    sessionId = messageHub->openSession(kEndpointInfos[0].id,
+                                        EventLoopManagerSingleton::get()
+                                            ->getChreMessageHubManager()
+                                            .kChreMessageHubId,
+                                        kNanoappId);
+    EXPECT_NE(sessionId, SESSION_ID_INVALID);
+    return sessionId;
+  });
 
   // Send the message to the nanoapp
-  std::unique_lock<std::mutex> lock(mutex);
   ASSERT_TRUE(messageHub->sendMessage(
-      std::move(messageData), kMessageSize,
+      std::move(messageData),
       /* messageType= */ 1,
       /* messagePermissions= */ CHRE_PERMS_AUDIO | CHRE_PERMS_GNSS, sessionId));
 
-  // Send the trigger cond var event, which will be handled after the
-  // CHRE message from endpoint event (if it is sent erroneously). If the
-  // message event is not sent, this event will unlock the condition variable.
-  // If the message event is sent, the condition variable will be unlocked
-  // after the message event is processed, setting the
-  // messageReceivedAndValidated variable to true, which will fail the test.
-  sendEventToNanoapp(appId, TRIGGER_COND_VAR);
-  condVar.wait(lock);
+  // Wait for the session to close due to the permission failure
+  testNanoapp->wait(CHRE_EVENT_MSG_SESSION_CLOSED);
   EXPECT_FALSE(messageReceivedAndValidated);
   EXPECT_TRUE(sessionClosed);
 }
 
+//! Nanoapp used to test opening sessions and sending messages from a nanoapp
+//! to a generic endpoint
+class SessionAndMessageTestApp : public TestNanoapp {
+ public:
+  SessionAndMessageTestApp(SessionId &sessionId, const TestNanoappInfo &info)
+      : TestNanoapp(info), mSessionId(sessionId) {}
+
+  void handleEvent(uint32_t, uint16_t eventType,
+                   const void *eventData) override {
+    switch (eventType) {
+      case CHRE_EVENT_MSG_SESSION_OPENED: {
+        // Verify the session info from the event is correct
+        auto sessionInfo = static_cast<const chreMsgSessionInfo *>(eventData);
+        EXPECT_EQ(sessionInfo->hubId, mToMessageHubId);
+        EXPECT_EQ(sessionInfo->endpointId, mToEndpointId);
+        EXPECT_STREQ(sessionInfo->serviceDescriptor, "");
+        EXPECT_NE(sessionInfo->sessionId, UINT16_MAX);
+        EXPECT_EQ(sessionInfo->reason,
+                  chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED);
+        mSessionId = sessionInfo->sessionId;
+
+        // Get the session info and verify it is correct
+        struct chreMsgSessionInfo sessionInfo2;
+        EXPECT_TRUE(chreMsgSessionGetInfo(mSessionId, &sessionInfo2));
+        EXPECT_EQ(sessionInfo2.hubId, mToMessageHubId);
+        EXPECT_EQ(sessionInfo2.endpointId, mToEndpointId);
+        EXPECT_STREQ(sessionInfo2.serviceDescriptor, "");
+        EXPECT_EQ(sessionInfo2.sessionId, mSessionId);
+        EXPECT_EQ(sessionInfo2.reason,
+                  chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED);
+        triggerWait(CHRE_EVENT_MSG_SESSION_OPENED);
+        break;
+      }
+      case CHRE_EVENT_MSG_SESSION_CLOSED: {
+        // Verify the session info from the event is correct
+        auto sessionInfo = static_cast<const chreMsgSessionInfo *>(eventData);
+        EXPECT_EQ(sessionInfo->hubId, mToMessageHubId);
+        EXPECT_EQ(sessionInfo->endpointId, mToEndpointId);
+        EXPECT_STREQ(sessionInfo->serviceDescriptor, "");
+        EXPECT_EQ(sessionInfo->sessionId, mSessionId);
+        triggerWait(CHRE_EVENT_MSG_SESSION_CLOSED);
+        break;
+      }
+      case CHRE_EVENT_MSG_FROM_ENDPOINT: {
+        auto messageData =
+            static_cast<const chreMsgMessageFromEndpointData *>(eventData);
+        EXPECT_EQ(messageData->messageType, 1);
+        EXPECT_EQ(messageData->messagePermissions,
+                  CHRE_MESSAGE_PERMISSION_NONE);
+        EXPECT_EQ(messageData->messageSize, kMessageSize);
+
+        auto message = reinterpret_cast<const uint8_t *>(messageData->message);
+        for (size_t i = 0; i < kMessageSize; ++i) {
+          EXPECT_EQ(message[i], i + 1);
+        }
+        EXPECT_EQ(messageData->sessionId, mSessionId);
+        triggerWait(CHRE_EVENT_MSG_FROM_ENDPOINT);
+        break;
+      }
+      case CHRE_EVENT_TEST_EVENT: {
+        auto event = static_cast<const TestEvent *>(eventData);
+        switch (event->type) {
+          case TEST_OPEN_SESSION: {
+            // Open the session from the nanoapp to the other hub:0
+            mToMessageHubId = kOtherMessageHubId;
+            mToEndpointId = kEndpointInfos[0].id;
+            EXPECT_TRUE(
+                chreMsgSessionOpenAsync(mToMessageHubId, mToEndpointId,
+                                        /* serviceDescriptor= */ nullptr));
+            mSessionId = UINT16_MAX;
+            break;
+          }
+          case TEST_OPEN_DEFAULT_SESSION: {
+            // Open the default session from the nanoapp to the other hub:1
+            mToMessageHubId = kOtherMessageHubId;
+            mToEndpointId = kEndpointInfos[1].id;
+            EXPECT_TRUE(
+                chreMsgSessionOpenAsync(CHRE_MSG_HUB_ID_ANY, mToEndpointId,
+                                        /* serviceDescriptor= */ nullptr));
+            mSessionId = UINT16_MAX;
+            break;
+          }
+          case TEST_OPEN_SESSION_NANOAPP_TO_NANOAPP: {
+            // Open a session from the nanoapp to itself
+            mToMessageHubId = CHRE_PLATFORM_ID;
+            mToEndpointId = id();
+            EXPECT_TRUE(
+                chreMsgSessionOpenAsync(mToMessageHubId, mToEndpointId,
+                                        /* serviceDescriptor= */ nullptr));
+            mSessionId = UINT16_MAX;
+            break;
+          }
+          case TEST_CLOSE_SESSION: {
+            // Close the session
+            EXPECT_TRUE(chreMsgSessionCloseAsync(mSessionId));
+            break;
+          }
+          case TEST_CLOSE_SESSION_NON_PARTY: {
+            ASSERT_NE(event->data, nullptr);
+            SessionId sessionId = *static_cast<SessionId *>(event->data);
+
+            // Close the session that was opened by the other nanoapp
+            EXPECT_FALSE(chreMsgSessionCloseAsync(sessionId));
+            triggerWait(TEST_CLOSE_SESSION_NON_PARTY);
+            break;
+          }
+          case TEST_GET_SESSION_INFO_INVALID_SESSION: {
+            struct chreMsgSessionInfo sessionInfo;
+            EXPECT_NE(mSessionId, SESSION_ID_INVALID);
+            EXPECT_FALSE(chreMsgSessionGetInfo(mSessionId, &sessionInfo));
+            triggerWait(TEST_GET_SESSION_INFO_INVALID_SESSION);
+            break;
+          }
+          case TEST_SEND_MESSAGE: {
+            EXPECT_TRUE(chreMsgSend(
+                reinterpret_cast<void *>(kMessage), kMessageSize,
+                /* messageType= */ 1, mSessionId, CHRE_MESSAGE_PERMISSION_NONE,
+                [](void *message, size_t length) {
+                  EXPECT_EQ(message, kMessage);
+                  EXPECT_EQ(length, kMessageSize);
+                }));
+            triggerWait(TEST_SEND_MESSAGE);
+            break;
+          }
+          case TEST_SEND_MESSAGE_NO_FREE_CALLBACK: {
+            EXPECT_TRUE(chreMsgSend(
+                reinterpret_cast<void *>(kMessage), kMessageSize,
+                /* messageType= */ 1, mSessionId, CHRE_MESSAGE_PERMISSION_NONE,
+                /* freeCallback= */ [](void * /*message*/, size_t /*length*/) {
+                }));
+            triggerWait(TEST_SEND_MESSAGE_NO_FREE_CALLBACK);
+            break;
+          }
+          case TEST_SEND_MESSAGE_NANOAPP_TO_NANOAPP: {
+            EXPECT_TRUE(chreMsgSend(
+                reinterpret_cast<void *>(kMessage), kMessageSize,
+                /* messageType= */ 1, mSessionId, CHRE_MESSAGE_PERMISSION_NONE,
+                /* freeCallback= */ [](void * /*message*/, size_t /*length*/) {
+                }));
+            break;
+          }
+        }
+        break;
+      }
+      default: {
+        break;
+      }
+    }
+  }
+
+  static uint8_t kMessage[kMessageSize];
+
+  SessionId &mSessionId;
+  MessageHubId mToMessageHubId = MESSAGE_HUB_ID_INVALID;
+  EndpointId mToEndpointId = ENDPOINT_ID_INVALID;
+};
+uint8_t SessionAndMessageTestApp::kMessage[kMessageSize] = {1, 2, 3, 4, 5};
+
+TEST_F(ChreMessageHubTest, NanoappOpensSessionWithGenericEndpoint) {
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Verify the other hub received the correct session information
+  std::optional<Session> session = messageHub->getSessionWithId(sessionId);
+  ASSERT_TRUE(session.has_value());
+  EXPECT_EQ(session->sessionId, sessionId);
+  EXPECT_EQ(session->initiator.messageHubId, EventLoopManagerSingleton::get()
+                                                 ->getChreMessageHubManager()
+                                                 .kChreMessageHubId);
+  EXPECT_EQ(session->initiator.endpointId, nanoapp->getAppId());
+  EXPECT_EQ(session->peer.messageHubId, kOtherMessageHubId);
+  EXPECT_EQ(session->peer.endpointId, kEndpointInfos[0].id);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &session]() {
+        messageHub->closeSession(session->sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, NanoappTriesToCloseNonPartySession) {
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Load the nanoapp
+  uint64_t appId2 = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId,
+      TestNanoappInfo{.name = "TEST_OPEN_SESSION_NON_PARTY", .id = 0x1235}));
+  Nanoapp *nanoapp2 = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp2, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Now close the session and expect failure
+  sendEventToNanoappAndWait(appId, TEST_CLOSE_SESSION_NON_PARTY, &sessionId,
+                            TEST_CLOSE_SESSION_NON_PARTY);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, NanoappOpensDefaultSessionWithGenericEndpoint) {
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId,
+      TestNanoappInfo{.name = "TEST_OPEN_DEFAULT_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening the default session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_DEFAULT_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Verify the other hub received the correct session information
+  std::optional<Session> session = messageHub->getSessionWithId(sessionId);
+  ASSERT_TRUE(session.has_value());
+
+  EXPECT_EQ(session->sessionId, sessionId);
+  EXPECT_EQ(session->initiator.messageHubId, EventLoopManagerSingleton::get()
+                                                 ->getChreMessageHubManager()
+                                                 .kChreMessageHubId);
+  EXPECT_EQ(session->initiator.endpointId, nanoapp->getAppId());
+  EXPECT_EQ(session->peer.messageHubId, kOtherMessageHubId);
+  EXPECT_EQ(session->peer.endpointId, kEndpointInfos[1].id);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, NanoappClosesSessionWithGenericEndpoint) {
+  Session session;
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &session);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Now close the session
+  sendEventToNanoappAndWait(appId, TEST_CLOSE_SESSION,
+                            CHRE_EVENT_MSG_SESSION_CLOSED);
+
+  // Verify the other hub received the correct session information
+  EXPECT_EQ(session.sessionId, sessionId);
+  EXPECT_EQ(session.initiator.messageHubId, EventLoopManagerSingleton::get()
+                                                ->getChreMessageHubManager()
+                                                .kChreMessageHubId);
+  EXPECT_EQ(session.initiator.endpointId, nanoapp->getAppId());
+  EXPECT_EQ(session.peer.messageHubId, kOtherMessageHubId);
+  EXPECT_EQ(session.peer.endpointId, kEndpointInfos[0].id);
+}
+
+TEST_F(ChreMessageHubTest, OtherHubClosesNanoappSessionWithGenericEndpoint) {
+  Session session;
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &session);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Now close the session and wait for the event to be processed
+  EXPECT_TRUE(messageHub->closeSession(sessionId));
+  testNanoapp->wait(CHRE_EVENT_MSG_SESSION_CLOSED);
+
+  // Verify the other hub received the correct session information
+  EXPECT_EQ(session.sessionId, sessionId);
+  EXPECT_EQ(session.initiator.messageHubId, EventLoopManagerSingleton::get()
+                                                ->getChreMessageHubManager()
+                                                .kChreMessageHubId);
+  EXPECT_EQ(session.initiator.endpointId, nanoapp->getAppId());
+  EXPECT_EQ(session.peer.messageHubId, kOtherMessageHubId);
+  EXPECT_EQ(session.peer.endpointId, kEndpointInfos[0].id);
+}
+
+TEST_F(ChreMessageHubTest, NanoappGetSessionInfoForNonPartySession) {
+  Session session;
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hubs
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &session);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &session);
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB2", kOtherMessageHubId + 1, callback2);
+  ASSERT_TRUE(messageHub2.has_value());
+  callback2->setMessageHub(&(*messageHub2));
+
+  // Open a session not involving the nanoapps
+  sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, kOtherMessageHubId + 1, kEndpointInfos[1].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+
+  // Tell the nanoapp to get the session info for our session
+  sendEventToNanoappAndWait(appId, TEST_GET_SESSION_INFO_INVALID_SESSION,
+                            TEST_GET_SESSION_INFO_INVALID_SESSION);
+}
+
+TEST_F(ChreMessageHubTest, NanoappSendsMessageToGenericEndpoint) {
+  SessionId sessionId = SESSION_ID_INVALID;
+  Message message;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&message,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Send the message to the other hub and verify it was received
+  sendEventToNanoappAndWait(appId, TEST_SEND_MESSAGE,
+                            TEST_SEND_MESSAGE);
+
+  EXPECT_EQ(message.data.size(), kMessageSize);
+  for (size_t i = 0; i < kMessageSize; ++i) {
+    EXPECT_EQ(message.data[i],
+              static_cast<std::byte>(SessionAndMessageTestApp::kMessage[i]));
+  }
+  EXPECT_EQ(message.messageType, 1);
+  EXPECT_EQ(message.messagePermissions, CHRE_MESSAGE_PERMISSION_NONE);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest,
+       NanoappSendsMessageWithNoFreeCallbackToGenericEndpoint) {
+  SessionId sessionId = SESSION_ID_INVALID;
+  Message message;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&message,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Send the message to the other hub and verify it was received
+  sendEventToNanoappAndWait(appId, TEST_SEND_MESSAGE_NO_FREE_CALLBACK,
+                            TEST_SEND_MESSAGE_NO_FREE_CALLBACK);
+
+  EXPECT_EQ(message.data.size(), kMessageSize);
+  for (size_t i = 0; i < kMessageSize; ++i) {
+    EXPECT_EQ(message.data[i],
+              static_cast<std::byte>(SessionAndMessageTestApp::kMessage[i]));
+  }
+  EXPECT_EQ(message.messageType, 1);
+  EXPECT_EQ(message.messagePermissions, CHRE_MESSAGE_PERMISSION_NONE);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, NanoappGetsMessageFromGenericEndpoint) {
+  SessionId sessionId = SESSION_ID_INVALID;
+  Message message;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_OPEN_SESSION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&message,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test opening session
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Send the message to the nanoapp and verify it was received
+  pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
+  pw::UniquePtr<std::byte[]> messageData =
+      createMessageData(allocator, kMessageSize);
+  EXPECT_TRUE(messageHub->sendMessage(std::move(messageData),
+                                      /* messageType= */ 1,
+                                      CHRE_MESSAGE_PERMISSION_NONE, sessionId));
+
+  testNanoapp->wait(CHRE_EVENT_MSG_FROM_ENDPOINT);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, NanoappSendsMessageToNanoapp) {
+  Session session;
+  SessionId sessionId = SESSION_ID_INVALID;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<SessionAndMessageTestApp>(
+      sessionId, TestNanoappInfo{.name = "TEST_SEND_MESSAGE_NANOAPP_TO_NANOAPP",
+                                 .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Test opening the session to itself
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION_NANOAPP_TO_NANOAPP,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Send the message to itself
+  sendEventToNanoappAndWait(appId, TEST_SEND_MESSAGE_NANOAPP_TO_NANOAPP,
+                            CHRE_EVENT_MSG_FROM_ENDPOINT);
+
+  // Wait for the session to be closed
+  sendEventToNanoappAndWait(appId, TEST_CLOSE_SESSION,
+                            CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+//! Nanoapp used to test opening sessions with services
+class ServiceSessionTestApp : public TestNanoapp {
+ public:
+  ServiceSessionTestApp(const TestNanoappInfo &info) : TestNanoapp(info) {}
+
+  bool start() override {
+    chreNanoappRpcService serviceInfo;
+    serviceInfo.id = kLegacyServiceId;
+    serviceInfo.version = kLegacyServiceVersion;
+    EXPECT_TRUE(chrePublishRpcServices(&serviceInfo,
+                                       /* numServices= */ 1));
+    return true;
+  }
+
+  void handleEvent(uint32_t, uint16_t eventType,
+                   const void *eventData) override {
+    switch (eventType) {
+      case CHRE_EVENT_MSG_SESSION_OPENED: {
+        // Verify the session info from the event is correct
+        auto sessionInfo = static_cast<const chreMsgSessionInfo *>(eventData);
+        EXPECT_EQ(sessionInfo->hubId, kOtherMessageHubId);
+        EXPECT_EQ(sessionInfo->reason,
+                  chreMsgEndpointReason::CHRE_MSG_ENDPOINT_REASON_UNSPECIFIED);
+
+        if (std::strcmp(sessionInfo->serviceDescriptor,
+                        kServiceDescriptorForEndpoint2) == 0) {
+          EXPECT_EQ(sessionInfo->endpointId, kEndpointInfos[1].id);
+          EXPECT_NE(sessionInfo->sessionId, UINT16_MAX);
+        }
+        triggerWait(CHRE_EVENT_MSG_SESSION_OPENED);
+        break;
+      }
+      case CHRE_EVENT_MSG_SESSION_CLOSED: {
+        triggerWait(CHRE_EVENT_MSG_SESSION_CLOSED);
+        break;
+      }
+      case CHRE_EVENT_TEST_EVENT: {
+        auto event = static_cast<const TestEvent *>(eventData);
+        switch (event->type) {
+          case TEST_PUBLISH_SERVICE: {
+            chreMsgServiceInfo serviceInfo;
+            serviceInfo.majorVersion = 1;
+            serviceInfo.minorVersion = 0;
+            serviceInfo.serviceDescriptor = kServiceDescriptorForNanoapp;
+            serviceInfo.serviceFormat = CHRE_MSG_ENDPOINT_SERVICE_FORMAT_CUSTOM;
+            EXPECT_TRUE(
+                chreMsgPublishServices(&serviceInfo, /* numServices= */ 1));
+            triggerWait(TEST_PUBLISH_SERVICE);
+            break;
+          }
+          case TEST_BAD_LEGACY_SERVICE_NAME: {
+            chreMsgServiceInfo serviceInfo;
+            serviceInfo.majorVersion = 1;
+            serviceInfo.minorVersion = 0;
+            serviceInfo.serviceDescriptor = kBadLegacyServiceName;
+            serviceInfo.serviceFormat = CHRE_MSG_ENDPOINT_SERVICE_FORMAT_CUSTOM;
+            EXPECT_FALSE(
+                chreMsgPublishServices(&serviceInfo, /* numServices= */ 1));
+            triggerWait(TEST_BAD_LEGACY_SERVICE_NAME);
+            break;
+          }
+          case TEST_OPEN_SESSION_WITH_SERVICE: {
+            EXPECT_TRUE(chreMsgSessionOpenAsync(
+                kOtherMessageHubId, kEndpointInfos[1].id,
+                kServiceDescriptorForEndpoint2));
+            break;
+          }
+        }
+        break;
+      }
+      default: {
+        break;
+      }
+    }
+  }
+};
+
+TEST_F(ChreMessageHubTest, OpenSessionWithNanoappService) {
+  constexpr uint64_t kNanoappId = 0x1234;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_OPEN_SESSION_WITH_SERVICE",
+                      .id = kNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Nanoapp publishes the service
+  sendEventToNanoappAndWait(appId, TEST_PUBLISH_SERVICE, TEST_PUBLISH_SERVICE);
+
+  // Open the session from the other hub:1 to the nanoapp with the service
+  SessionId sessionId = SESSION_ID_INVALID;
+  callback->openSessionAndWaitForOpen([&sessionId, &messageHub]() {
+    sessionId =
+        messageHub->openSession(kEndpointInfos[0].id,
+                                EventLoopManagerSingleton::get()
+                                    ->getChreMessageHubManager()
+                                    .kChreMessageHubId,
+                                kNanoappId, kServiceDescriptorForNanoapp);
+    EXPECT_NE(sessionId, SESSION_ID_INVALID);
+    return sessionId;
+  });
+
+  // Wait for the nanoapp to receive the session open event
+  testNanoapp->wait(CHRE_EVENT_MSG_SESSION_OPENED);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, OpenTwoSessionsWithNanoappServiceAndNoService) {
+  constexpr uint64_t kNanoappId = 0x1234;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_OPEN_SESSION_WITH_SERVICE",
+                      .id = kNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Nanoapp publishes the service
+  sendEventToNanoappAndWait(appId, TEST_PUBLISH_SERVICE, TEST_PUBLISH_SERVICE);
+
+  // Open the session from the other hub:1 to the nanoapp with the service
+  SessionId sessionId = SESSION_ID_INVALID;
+  callback->openSessionAndWaitForOpen([&sessionId, &messageHub]() {
+    sessionId =
+        messageHub->openSession(kEndpointInfos[0].id,
+                                EventLoopManagerSingleton::get()
+                                    ->getChreMessageHubManager()
+                                    .kChreMessageHubId,
+                                kNanoappId, kServiceDescriptorForNanoapp);
+    EXPECT_NE(sessionId, SESSION_ID_INVALID);
+    return sessionId;
+  });
+
+  // Wait for the nanoapp to receive the session open event
+  testNanoapp->wait(CHRE_EVENT_MSG_SESSION_OPENED);
+
+  // Open the other session from the other hub:1 to the nanoapp
+  SessionId sessionId2 = SESSION_ID_INVALID;
+  callback->openSessionAndWaitForOpen([&sessionId, &sessionId2, &messageHub]() {
+    sessionId2 = messageHub->openSession(kEndpointInfos[0].id,
+                                         EventLoopManagerSingleton::get()
+                                             ->getChreMessageHubManager()
+                                             .kChreMessageHubId,
+                                         kNanoappId);
+    EXPECT_NE(sessionId2, SESSION_ID_INVALID);
+    EXPECT_NE(sessionId, sessionId2);
+    return sessionId2;
+  });
+
+  // Wait for the nanoapp to receive the session open event
+  testNanoapp->wait(CHRE_EVENT_MSG_SESSION_OPENED);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId2]() {
+        messageHub->closeSession(sessionId2);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, OpenSessionWithNanoappLegacyService) {
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_OPEN_SESSION_WITH_LEGACY_SERVICE",
+                      .id = kLegacyServiceNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Open the session from the other hub:1 to the nanoapp with the service
+  SessionId sessionId = SESSION_ID_INVALID;
+  callback->openSessionAndWaitForOpen([&sessionId, &messageHub]() {
+    sessionId =
+        messageHub->openSession(kEndpointInfos[0].id,
+                                EventLoopManagerSingleton::get()
+                                    ->getChreMessageHubManager()
+                                    .kChreMessageHubId,
+                                kLegacyServiceNanoappId, kLegacyServiceName);
+    EXPECT_NE(sessionId, SESSION_ID_INVALID);
+    return sessionId;
+  });
+
+  testNanoapp->doActionAndWait(
+      [&messageHub, &sessionId]() {
+        messageHub->closeSession(sessionId);
+        return true;
+      },
+      CHRE_EVENT_MSG_SESSION_CLOSED);
+}
+
+TEST_F(ChreMessageHubTest, ForEachServiceNanoappLegacyService) {
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_FOR_EACH_SERVICE_LEGACY_SERVICE",
+                      .id = kLegacyServiceNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Find the service
+  MessageRouterSingleton::get()->forEachService(
+      [&](const MessageHubInfo &hub, const EndpointInfo &endpoint,
+          const ServiceInfo &service) {
+        if (hub.id == EventLoopManagerSingleton::get()
+                          ->getChreMessageHubManager()
+                          .kChreMessageHubId) {
+          EXPECT_EQ(endpoint.id, kLegacyServiceNanoappId);
+          EXPECT_STREQ(service.serviceDescriptor, kLegacyServiceName);
+          EXPECT_EQ(service.majorVersion, 1);
+          EXPECT_EQ(service.minorVersion, 0);
+          EXPECT_EQ(service.format, RpcFormat::PW_RPC_PROTOBUF);
+          return true;
+        }
+        return false;
+      });
+}
+
+TEST_F(ChreMessageHubTest, NanoappFailsToPublishLegacyServiceInNewWay) {
+  constexpr uint64_t kNanoappId = 0x1234;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_BAD_LEGACY_SERVICE_NAME",
+                      .id = kNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Nanoapp publishes the service
+  sendEventToNanoappAndWait(appId, TEST_BAD_LEGACY_SERVICE_NAME,
+                            TEST_BAD_LEGACY_SERVICE_NAME);
+}
+
+TEST_F(ChreMessageHubTest, NanoappOpensSessionWithService) {
+  constexpr uint64_t kNanoappId = 0x1234;
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_OPEN_SESSION_WITH_SERVICE",
+                      .id = kNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Nanoapp opens the session with the service
+  sendEventToNanoappAndWait(appId, TEST_OPEN_SESSION_WITH_SERVICE,
+                            CHRE_EVENT_MSG_SESSION_OPENED);
+}
+
+TEST_F(ChreMessageHubTest, NanoappUnloadUnregistersProvidedServices) {
+  constexpr uint64_t kNanoappId = 0x1234;
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<ServiceSessionTestApp>(
+
+      TestNanoappInfo{.name = "TEST_UNLOAD_UNREGISTERS_PROVIDED_SERVICES",
+                      .id = kNanoappId}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  callback->setMessageHub(&(*messageHub));
+
+  // Nanoapp publishes the service
+  sendEventToNanoappAndWait(appId, TEST_PUBLISH_SERVICE, TEST_PUBLISH_SERVICE);
+
+  // Get the endpoint ID for the service
+  std::optional<Endpoint> endpoint =
+      MessageRouterSingleton::get()->getEndpointForService(
+          EventLoopManagerSingleton::get()
+              ->getChreMessageHubManager()
+              .kChreMessageHubId,
+          kServiceDescriptorForNanoapp);
+  EXPECT_TRUE(endpoint.has_value());
+  EXPECT_EQ(endpoint->messageHubId, EventLoopManagerSingleton::get()
+                                        ->getChreMessageHubManager()
+                                        .kChreMessageHubId);
+  EXPECT_EQ(endpoint->endpointId, kNanoappId);
+
+  // Unload the nanoapp
+  unloadNanoapp(appId);
+
+  // Load another nanoapp. This forces this thread to wait for the finish
+  // load nanoapp event to process, which is after the cleanup event.
+  loadNanoapp(MakeUnique<TestNanoapp>());
+
+  // The service should be gone
+  endpoint = MessageRouterSingleton::get()->getEndpointForService(
+      EventLoopManagerSingleton::get()
+          ->getChreMessageHubManager()
+          .kChreMessageHubId,
+      kServiceDescriptorForNanoapp);
+  EXPECT_FALSE(endpoint.has_value());
+}
+
+//! Nanoapp used to test endpoint registration and ready events
+class EndpointRegistrationTestApp : public TestNanoapp {
+ public:
+  EndpointRegistrationTestApp(const TestNanoappInfo &info)
+      : TestNanoapp(info) {}
+
+  void handleEvent(uint32_t, uint16_t eventType,
+                   const void *eventData) override {
+    switch (eventType) {
+      case CHRE_EVENT_MSG_ENDPOINT_READY: {
+        auto event = static_cast<const chreMsgEndpointReadyEvent *>(eventData);
+        EXPECT_EQ(event->hubId, kOtherMessageHubId);
+        EXPECT_EQ(event->endpointId, mEndpointId);
+        triggerWait(CHRE_EVENT_MSG_ENDPOINT_READY);
+        break;
+      }
+      case CHRE_EVENT_MSG_SERVICE_READY: {
+        auto event = static_cast<const chreMsgServiceReadyEvent *>(eventData);
+        EXPECT_EQ(event->hubId, kOtherMessageHubId);
+        EXPECT_EQ(event->endpointId, kDynamicEndpointInfo.id);
+        EXPECT_STREQ(event->serviceDescriptor,
+                     kServiceDescriptorForDynamicEndpoint);
+        triggerWait(CHRE_EVENT_MSG_SERVICE_READY);
+        break;
+      }
+      case CHRE_EVENT_TEST_EVENT: {
+        auto event = static_cast<const TestEvent *>(eventData);
+        switch (event->type) {
+          case TEST_SUBSCRIBE_TO_READY_EVENT: {
+            mEndpointId = kDynamicEndpointInfo.id;
+            EXPECT_TRUE(chreMsgConfigureEndpointReadyEvents(
+                kOtherMessageHubId, mEndpointId,
+                /* enable= */ true));
+            triggerWait(TEST_SUBSCRIBE_TO_READY_EVENT);
+            break;
+          }
+          case TEST_SUBSCRIBE_TO_READY_EVENT_ALREADY_EXISTS: {
+            mEndpointId = kEndpointInfos[1].id;
+            EXPECT_TRUE(chreMsgConfigureEndpointReadyEvents(
+                kOtherMessageHubId, mEndpointId,
+                /* enable= */ true));
+            break;
+          }
+          case TEST_UNSUBSCRIBE_FROM_READY_EVENT: {
+            EXPECT_TRUE(chreMsgConfigureEndpointReadyEvents(
+                kOtherMessageHubId, mEndpointId,
+                /* enable= */ false));
+            triggerWait(TEST_UNSUBSCRIBE_FROM_READY_EVENT);
+            break;
+          }
+          case TEST_SUBSCRIBE_TO_SERVICE_READY_EVENT: {
+            EXPECT_TRUE(chreMsgConfigureServiceReadyEvents(
+                kOtherMessageHubId, kServiceDescriptorForDynamicEndpoint,
+                /* enable= */ true));
+            triggerWait(TEST_SUBSCRIBE_TO_SERVICE_READY_EVENT);
+            break;
+          }
+          case TEST_UNSUBSCRIBE_FROM_SERVICE_READY_EVENT: {
+            EXPECT_TRUE(chreMsgConfigureServiceReadyEvents(
+                kOtherMessageHubId, kServiceDescriptorForDynamicEndpoint,
+                /* enable= */ false));
+            triggerWait(TEST_UNSUBSCRIBE_FROM_SERVICE_READY_EVENT);
+            break;
+          }
+        }
+        break;
+      }
+      default: {
+        break;
+      }
+    }
+  }
+
+  EndpointId mEndpointId = ENDPOINT_ID_INVALID;
+};
+
+TEST_F(ChreMessageHubTest, NanoappSubscribesToEndpointReadyEvent) {
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<EndpointRegistrationTestApp>(
+
+      TestNanoappInfo{.name = "TEST_ENDPOINT_READY_EVENT", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test subscribing to the ready event
+  sendEventToNanoappAndWait(appId, TEST_SUBSCRIBE_TO_READY_EVENT,
+                            TEST_SUBSCRIBE_TO_READY_EVENT);
+
+  // Register the endpoint and wait for the ready event
+  EXPECT_TRUE(messageHub->registerEndpoint(kDynamicEndpointInfo.id));
+  testNanoapp->wait(CHRE_EVENT_MSG_ENDPOINT_READY);
+
+  // Unsubscribe from the ready event
+  sendEventToNanoappAndWait(appId, TEST_UNSUBSCRIBE_FROM_READY_EVENT,
+                            TEST_UNSUBSCRIBE_FROM_READY_EVENT);
+}
+
+TEST_F(ChreMessageHubTest, NanoappSubscribesToEndpointReadyEventAlreadyExists) {
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<EndpointRegistrationTestApp>(
+
+      TestNanoappInfo{.name = "TEST_ENDPOINT_READY_EVENT", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test subscribing to the ready event - endpoint should already exist
+  sendEventToNanoappAndWait(appId, TEST_SUBSCRIBE_TO_READY_EVENT_ALREADY_EXISTS,
+                            CHRE_EVENT_MSG_ENDPOINT_READY);
+
+  // Unsubscribe from the ready event
+  sendEventToNanoappAndWait(appId, TEST_UNSUBSCRIBE_FROM_READY_EVENT,
+                            TEST_UNSUBSCRIBE_FROM_READY_EVENT);
+}
+
+TEST_F(ChreMessageHubTest, NanoappSubscribesToServiceReadyEvent) {
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<EndpointRegistrationTestApp>(
+      TestNanoappInfo{.name = "TEST_SERVICE_READY_EVENT", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+  TestNanoapp *testNanoapp = queryNanoapp(appId);
+  ASSERT_NE(testNanoapp, nullptr);
+
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Test subscribing to the service ready event
+  sendEventToNanoappAndWait(appId, TEST_SUBSCRIBE_TO_SERVICE_READY_EVENT,
+                            TEST_SUBSCRIBE_TO_SERVICE_READY_EVENT);
+
+  // Register the endpoint and wait for the service ready event
+  EXPECT_TRUE(messageHub->registerEndpoint(kDynamicEndpointInfo.id));
+  testNanoapp->wait(CHRE_EVENT_MSG_SERVICE_READY);
+
+  // Unsubscribe from the service ready event
+  sendEventToNanoappAndWait(appId, TEST_UNSUBSCRIBE_FROM_SERVICE_READY_EVENT,
+                            TEST_UNSUBSCRIBE_FROM_SERVICE_READY_EVENT);
+}
+
+TEST_F(ChreMessageHubTest, NanoappLoadAndUnloadAreRegisteredAndUnregistered) {
+  // Create the other hub
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      MessageRouterSingleton::get()->registerMessageHub(
+          "OTHER_TEST_HUB", kOtherMessageHubId, callback);
+  ASSERT_TRUE(messageHub.has_value());
+  callback->setMessageHub(&(*messageHub));
+
+  // Load the nanoapp
+  uint64_t appId = loadNanoapp(MakeUnique<EndpointRegistrationTestApp>(
+      TestNanoappInfo{.name = "TEST_NANOAPP_REGISTRATION", .id = 0x1234}));
+  Nanoapp *nanoapp = getNanoappByAppId(appId);
+  ASSERT_NE(nanoapp, nullptr);
+
+  // The nanoapp should be registered as an endpoint
+  EXPECT_TRUE(
+      callback->hasEndpointBeenRegistered(EventLoopManagerSingleton::get()
+                                              ->getChreMessageHubManager()
+                                              .kChreMessageHubId,
+                                          appId));
+
+  // Unload the nanoapp
+  unloadNanoapp(appId);
+
+  // The nanoapp should be unregistered as an endpoint
+  EXPECT_FALSE(
+      callback->hasEndpointBeenRegistered(EventLoopManagerSingleton::get()
+                                              ->getChreMessageHubManager()
+                                              .kChreMessageHubId,
+                                          appId));
+}
+
 }  // namespace
 }  // namespace chre::message
diff --git a/test/simulation/delay_event_test.cc b/test/simulation/delay_event_test.cc
index 196f8f9d..9f4ea4aa 100644
--- a/test/simulation/delay_event_test.cc
+++ b/test/simulation/delay_event_test.cc
@@ -32,6 +32,8 @@ using ::chre::platform_linux::SystemTimeOverride;
 namespace chre {
 namespace {
 
+class DelayEventTest : public TestBase {};
+
 CREATE_CHRE_TEST_EVENT(DELAY_EVENT, 0);
 
 constexpr Seconds kDelayEventInterval(2);
@@ -69,7 +71,7 @@ class DelayEventNanoapp : public TestNanoapp {
   bool hasSeenDelayEvent = false;
 };
 
-TEST_F(TestBase, DelayedEventIsFlagged) {
+TEST_F(DelayEventTest, DelayedEventIsFlagged) {
   constexpr uint32_t kDelayEventCount = 3;
   SystemTimeOverride override(0);
   uint64_t appId = loadNanoapp(MakeUnique<DelayEventNanoapp>());
diff --git a/test/simulation/gnss_test.cc b/test/simulation/gnss_test.cc
index f9e388bd..605eca3d 100644
--- a/test/simulation/gnss_test.cc
+++ b/test/simulation/gnss_test.cc
@@ -35,6 +35,8 @@
 namespace chre {
 namespace {
 
+class GnssTest : public TestBase {};
+
 /**
  * Wait for the predicate to become true with a timeout.
  *
@@ -53,7 +55,7 @@ bool waitForCondition(const std::function<bool()> &predicate,
 }
 
 // ref b/228669574
-TEST_F(TestBase, GnssSubscriptionWithSettingChange) {
+TEST_F(GnssTest, GnssSubscriptionWithSettingChange) {
   CREATE_CHRE_TEST_EVENT(LOCATION_REQUEST, 0);
 
   struct LocationRequest {
@@ -169,7 +171,7 @@ TEST_F(TestBase, GnssSubscriptionWithSettingChange) {
   chrePalGnssDelaySendingLocationEvents(false);
 }
 
-TEST_F(TestBase, GnssCanSubscribeAndUnsubscribeToLocation) {
+TEST_F(GnssTest, GnssCanSubscribeAndUnsubscribeToLocation) {
   CREATE_CHRE_TEST_EVENT(LOCATION_REQUEST, 0);
 
   struct LocationRequest {
@@ -246,7 +248,7 @@ TEST_F(TestBase, GnssCanSubscribeAndUnsubscribeToLocation) {
   EXPECT_FALSE(chrePalGnssIsLocationEnabled());
 }
 
-TEST_F(TestBase, GnssUnsubscribeToLocationOnUnload) {
+TEST_F(GnssTest, GnssUnsubscribeToLocationOnUnload) {
   CREATE_CHRE_TEST_EVENT(LOCATION_REQUEST, 0);
 
   struct LocationRequest {
@@ -315,7 +317,7 @@ TEST_F(TestBase, GnssUnsubscribeToLocationOnUnload) {
   EXPECT_FALSE(chrePalGnssIsLocationEnabled());
 }
 
-TEST_F(TestBase, GnssCanSubscribeAndUnsubscribeToMeasurement) {
+TEST_F(GnssTest, GnssCanSubscribeAndUnsubscribeToMeasurement) {
   CREATE_CHRE_TEST_EVENT(MEASUREMENT_REQUEST, 0);
 
   struct MeasurementRequest {
@@ -394,7 +396,7 @@ TEST_F(TestBase, GnssCanSubscribeAndUnsubscribeToMeasurement) {
   EXPECT_FALSE(chrePalGnssIsMeasurementEnabled());
 }
 
-TEST_F(TestBase, GnssUnsubscribeToMeasurementOnUnload) {
+TEST_F(GnssTest, GnssUnsubscribeToMeasurementOnUnload) {
   CREATE_CHRE_TEST_EVENT(MEASUREMENT_REQUEST, 0);
 
   struct MeasurementRequest {
@@ -463,7 +465,7 @@ TEST_F(TestBase, GnssUnsubscribeToMeasurementOnUnload) {
   EXPECT_FALSE(chrePalGnssIsMeasurementEnabled());
 }
 
-TEST_F(TestBase, GnssCanSubscribeAndUnsubscribeToPassiveListener) {
+TEST_F(GnssTest, GnssCanSubscribeAndUnsubscribeToPassiveListener) {
   CREATE_CHRE_TEST_EVENT(LISTENER_REQUEST, 0);
 
   class App : public TestNanoapp {
@@ -508,7 +510,7 @@ TEST_F(TestBase, GnssCanSubscribeAndUnsubscribeToPassiveListener) {
   EXPECT_FALSE(chrePalGnssIsPassiveLocationListenerEnabled());
 }
 
-TEST_F(TestBase, GnssUnsubscribeToPassiveListenerOnUnload) {
+TEST_F(GnssTest, GnssUnsubscribeToPassiveListenerOnUnload) {
   CREATE_CHRE_TEST_EVENT(LISTENER_REQUEST, 0);
 
   class App : public TestNanoapp {
diff --git a/test/simulation/host_endpoint_notification_test.cc b/test/simulation/host_endpoint_notification_test.cc
index 75e3a7eb..8a5ea92e 100644
--- a/test/simulation/host_endpoint_notification_test.cc
+++ b/test/simulation/host_endpoint_notification_test.cc
@@ -33,6 +33,8 @@ namespace chre {
 
 namespace {
 
+class HostEndpointNotificationTest : public TestBase {};
+
 //! The host endpoint ID to use for this test.
 constexpr uint16_t kHostEndpointId = 123;
 
@@ -44,7 +46,7 @@ HostEndpointManager &getHostEndpointManager() {
 /**
  * Verifies basic functionality of chreConfigureHostEndpointNotifications.
  */
-TEST_F(TestBase, HostEndpointDisconnectedTest) {
+TEST_F(HostEndpointNotificationTest, HostEndpointDisconnectedTest) {
   CREATE_CHRE_TEST_EVENT(SETUP_NOTIFICATION, 0);
 
   struct Config {
@@ -121,13 +123,13 @@ TEST_F(TestBase, HostEndpointDisconnectedTest) {
                    .getHostEndpointInfo(kHostEndpointId, &retrievedInfo));
 }
 
-TEST_F(TestBase, HostEndpointNotRegisteredTest) {
+TEST_F(HostEndpointNotificationTest, HostEndpointNotRegisteredTest) {
   struct chreHostEndpointInfo retrievedInfo;
   ASSERT_FALSE(getHostEndpointManager().getHostEndpointInfo(kHostEndpointId,
                                                             &retrievedInfo));
 }
 
-TEST_F(TestBase, HostEndpointDisconnectedTwiceTest) {
+TEST_F(HostEndpointNotificationTest, HostEndpointDisconnectedTwiceTest) {
   struct chreHostEndpointInfo info;
   info.hostEndpointId = kHostEndpointId;
   info.hostEndpointType = CHRE_HOST_ENDPOINT_TYPE_FRAMEWORK;
diff --git a/test/simulation/host_message_hub_test.cc b/test/simulation/host_message_hub_test.cc
new file mode 100644
index 00000000..079f6c79
--- /dev/null
+++ b/test/simulation/host_message_hub_test.cc
@@ -0,0 +1,625 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cstring>
+#include <optional>
+#include <unordered_set>
+#include <vector>
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+#include "test_base.h"
+
+#include "chre/core/event_loop_manager.h"
+#include "chre/core/host_message_hub_manager.h"
+#include "chre/platform/memory.h"
+#include "chre/util/system/message_common.h"
+#include "chre/util/system/message_router.h"
+#include "chre/util/system/message_router_mocks.h"
+#include "chre_api/chre/event.h"
+
+#include "pw_allocator/libc_allocator.h"
+#include "pw_allocator/unique_ptr.h"
+#include "pw_function/function.h"
+
+namespace chre {
+namespace {
+
+using ::chre::message::EndpointId;
+using ::chre::message::EndpointInfo;
+using ::chre::message::EndpointType;
+using ::chre::message::Message;
+using ::chre::message::MessageHubId;
+using ::chre::message::MessageHubInfo;
+using ::chre::message::MessageRouter;
+using ::chre::message::MessageRouterSingleton;
+using ::chre::message::MockMessageHubCallback;
+using ::chre::message::Reason;
+using ::chre::message::RpcFormat;
+using ::chre::message::ServiceInfo;
+using ::chre::message::Session;
+using ::chre::message::SessionId;
+using ::testing::_;
+using ::testing::AnyNumber;
+using ::testing::Expectation;
+using ::testing::NiceMock;
+using ::testing::UnorderedElementsAreArray;
+
+class MockHostCallback : public HostMessageHubManager::HostCallback {
+ public:
+  MOCK_METHOD(void, onReset, (), (override));
+  MOCK_METHOD(void, onHubRegistered, (const MessageHubInfo &), (override));
+  MOCK_METHOD(void, onHubUnregistered, (MessageHubId), (override));
+  MOCK_METHOD(void, onEndpointRegistered, (MessageHubId, const EndpointInfo &),
+              (override));
+  MOCK_METHOD(void, onEndpointService,
+              (MessageHubId, EndpointId, const ServiceInfo &), (override));
+  MOCK_METHOD(void, onEndpointReady, (MessageHubId, EndpointId), (override));
+  MOCK_METHOD(void, onEndpointUnregistered, (MessageHubId, EndpointId),
+              (override));
+  MOCK_METHOD(bool, onMessageReceived,
+              (MessageHubId, SessionId, pw::UniquePtr<std::byte[]> &&, uint32_t,
+               uint32_t),
+              (override));
+  MOCK_METHOD(void, onSessionOpenRequest, (const Session &), (override));
+  MOCK_METHOD(void, onSessionOpened, (MessageHubId, SessionId), (override));
+  MOCK_METHOD(void, onSessionClosed, (MessageHubId, SessionId, Reason),
+              (override));
+};
+
+HostMessageHubManager &getManager() {
+  return EventLoopManagerSingleton::get()->getHostMessageHubManager();
+}
+
+MessageRouter &getRouter() {
+  return *MessageRouterSingleton::get();
+}
+
+const char *kServiceName = "test_service";
+const ServiceInfo kService(kServiceName, 0, 0, RpcFormat::CUSTOM);
+const EndpointInfo kEndpoints[] = {
+    EndpointInfo(0x1, nullptr, 0, EndpointType::GENERIC, 0),
+    EndpointInfo(0x2, nullptr, 0, EndpointType::GENERIC, 0)};
+const EndpointInfo kExtraEndpoint(0x3, nullptr, 0, EndpointType::GENERIC, 0);
+const EndpointId kEndpointIds[] = {0x1, 0x2};
+const char *kEmbeddedHubName = "embedded hub";
+const MessageHubInfo kEmbeddedHub{.id = CHRE_PLATFORM_ID + 1,
+                                  .name = kEmbeddedHubName};
+const char *kHostHubName = "host hub";
+const MessageHubInfo kHostHub{.id = kEmbeddedHub.id + 1, .name = kHostHubName};
+
+class HostMessageHubTest : public TestBase {
+ public:
+  HostMessageHubTest() : TestBase() {
+    for (const auto &endpoint : kEndpoints) {
+      std::vector<ServiceInfo> services;
+      if (endpoint.id > 0x1) services.push_back(kService);
+      mEmbeddedEndpoints.push_back({endpoint, std::move(services)});
+    }
+  }
+
+  void SetUp() override {
+    TestBase::SetUp();
+
+    mEmbeddedHubCb = pw::MakeRefCounted<NiceMock<MockMessageHubCallback>>();
+    ASSERT_NE(mEmbeddedHubCb.get(), nullptr);
+
+    // Specify uninteresting behaviors for the mock embedded hub callback.
+    ON_CALL(*mEmbeddedHubCb, forEachEndpoint(_))
+        .WillByDefault(
+            [this](const pw::Function<bool(const EndpointInfo &)> &fn) {
+              for (const auto &endpoint : mEmbeddedEndpoints)
+                if (fn(endpoint.first)) return;
+            });
+    ON_CALL(*mEmbeddedHubCb, getEndpointInfo(_))
+        .WillByDefault([this](EndpointId id) -> std::optional<EndpointInfo> {
+          for (const auto &endpoint : mEmbeddedEndpoints)
+            if (endpoint.first.id == id) return endpoint.first;
+          return {};
+        });
+    ON_CALL(*mEmbeddedHubCb, getEndpointForService(_))
+        .WillByDefault(
+            [this](const char *service) -> std::optional<EndpointId> {
+              for (const auto &endpoint : mEmbeddedEndpoints) {
+                for (const auto &serviceInfo : endpoint.second) {
+                  if (!std::strcmp(serviceInfo.serviceDescriptor, service))
+                    return endpoint.first.id;
+                }
+              }
+              return {};
+            });
+    ON_CALL(*mEmbeddedHubCb, doesEndpointHaveService(_, _))
+        .WillByDefault([this](EndpointId id, const char *service) {
+          for (const auto &endpoint : mEmbeddedEndpoints) {
+            if (endpoint.first.id != id) continue;
+            for (const auto &serviceInfo : endpoint.second) {
+              if (!std::strcmp(serviceInfo.serviceDescriptor, service))
+                return true;
+            }
+          }
+          return false;
+        });
+    ON_CALL(*mEmbeddedHubCb, forEachService(_))
+        .WillByDefault(
+            [this](const pw::Function<bool(const EndpointInfo &,
+                                           const message::ServiceInfo &)> &fn) {
+              for (const auto &endpoint : mEmbeddedEndpoints) {
+                for (const auto &serviceInfo : endpoint.second) {
+                  if (fn(endpoint.first, serviceInfo)) return;
+                }
+              }
+            });
+
+    // We mostly don't care about this. Individual tests may override this
+    // behavior.
+    EXPECT_CALL(*mEmbeddedHubCb, onHubRegistered(_)).Times(AnyNumber());
+    EXPECT_CALL(*mEmbeddedHubCb, onHubUnregistered(_)).Times(AnyNumber());
+    EXPECT_CALL(mHostCallback, onHubRegistered(_)).Times(AnyNumber());
+    EXPECT_CALL(mHostCallback, onHubUnregistered(_)).Times(AnyNumber());
+
+    // Register the embedded message hub with MessageRouter.
+    auto maybeEmbeddedHub = getRouter().registerMessageHub(
+        kEmbeddedHubName, kEmbeddedHub.id, mEmbeddedHubCb);
+    if (maybeEmbeddedHub) {
+      mEmbeddedHubIntf = std::move(*maybeEmbeddedHub);
+    } else {
+      FAIL() << "Failed to register test embedded message hub";
+    }
+
+    // Initialize the manager with a mock HostCallback.
+    getManager().onHostTransportReady(mHostCallback);
+  }
+
+  void TearDown() override {
+    EXPECT_CALL(mHostCallback, onReset());
+    EXPECT_CALL(mHostCallback, onHubRegistered(_)).Times(AnyNumber());
+    EXPECT_CALL(mHostCallback, onEndpointRegistered(_, _)).Times(AnyNumber());
+    EXPECT_CALL(mHostCallback, onEndpointService(_, _, _)).Times(AnyNumber());
+    EXPECT_CALL(mHostCallback, onEndpointReady(_, _)).Times(AnyNumber());
+    getManager().reset();
+    mEmbeddedHubIntf.unregister();
+
+    TestBase::TearDown();
+  }
+
+  DynamicVector<ServiceInfo> getHostEndpointServices() {
+    auto serviceName =
+        static_cast<char *>(memoryAlloc(std::strlen(kServiceName) + 1));
+    std::memcpy(serviceName, kServiceName, std::strlen(kServiceName) + 1);
+    DynamicVector<ServiceInfo> services;
+    services.emplace_back(serviceName, kService.majorVersion,
+                          kService.minorVersion, kService.format);
+    return services;
+  }
+
+  void expectOnEmbeddedEndpoint(
+      const std::pair<EndpointInfo, std::vector<ServiceInfo>> &endpoint,
+      Expectation *sequence) {
+    Expectation previous;
+    if (sequence) {
+      previous =
+          EXPECT_CALL(mHostCallback,
+                      onEndpointRegistered(kEmbeddedHub.id, endpoint.first))
+              .After(*sequence)
+              .RetiresOnSaturation();
+    } else {
+      previous =
+          EXPECT_CALL(mHostCallback,
+                      onEndpointRegistered(kEmbeddedHub.id, endpoint.first))
+              .RetiresOnSaturation();
+    }
+    for (const auto &service : endpoint.second) {
+      previous = EXPECT_CALL(mHostCallback,
+                             onEndpointService(kEmbeddedHub.id,
+                                               endpoint.first.id, service))
+                     .After(previous)
+                     .RetiresOnSaturation();
+    }
+    EXPECT_CALL(mHostCallback,
+                onEndpointReady(kEmbeddedHub.id, endpoint.first.id))
+        .After(previous)
+        .RetiresOnSaturation();
+  }
+
+ protected:
+  pw::IntrusivePtr<NiceMock<MockMessageHubCallback>> mEmbeddedHubCb;
+  MessageRouter::MessageHub mEmbeddedHubIntf;
+  MockHostCallback mHostCallback;
+
+  std::vector<std::pair<EndpointInfo, std::vector<ServiceInfo>>>
+      mEmbeddedEndpoints;
+};
+
+MATCHER_P(HubIdMatcher, id, "Matches a MessageHubInfo by id") {
+  return arg.id == id;
+}
+
+TEST_F(HostMessageHubTest, Reset) {
+  // On each reset(), expect onReset() followed by onHubRegistered() and
+  // onEndpointRegistered() for each endpoint.
+  auto resetExpectations = [this] {
+    Expectation reset =
+        EXPECT_CALL(mHostCallback, onReset()).RetiresOnSaturation();
+    Expectation defaultHub =
+        EXPECT_CALL(mHostCallback,
+                    onHubRegistered(HubIdMatcher(CHRE_PLATFORM_ID)))
+            .After(reset)
+            .RetiresOnSaturation();
+    Expectation testHub =
+        EXPECT_CALL(mHostCallback, onHubRegistered(kEmbeddedHub))
+            .After(reset)
+            .RetiresOnSaturation();
+    for (const auto &endpoint : mEmbeddedEndpoints)
+      expectOnEmbeddedEndpoint(endpoint, &testHub);
+  };
+
+  // reset() with no host endpoints.
+  resetExpectations();
+  getManager().reset();
+  getRouter().forEachEndpoint(
+      [](const MessageHubInfo &hub, const EndpointInfo &) {
+        EXPECT_EQ(hub.id, kEmbeddedHub.id);
+      });
+
+  // Add a host hub and endpoint. MessageRouter should see none of them after a
+  // second reset().
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+  resetExpectations();
+  getManager().reset();
+  getRouter().forEachEndpoint(
+      [](const MessageHubInfo &hub, const EndpointInfo &) {
+        EXPECT_EQ(hub.id, kEmbeddedHub.id);
+      });
+}
+
+TEST_F(HostMessageHubTest, RegisterAndUnregisterHub) {
+  EXPECT_FALSE(getRouter().forEachEndpointOfHub(
+      kHostHub.id, [](const EndpointInfo &) { return true; }));
+
+  EXPECT_CALL(*mEmbeddedHubCb, onHubRegistered(kHostHub));
+  getManager().registerHub(kHostHub);
+  EXPECT_TRUE(getRouter().forEachEndpointOfHub(
+      kHostHub.id, [](const EndpointInfo &) { return true; }));
+
+  EXPECT_CALL(*mEmbeddedHubCb, onHubUnregistered(kHostHub.id));
+  getManager().unregisterHub(kHostHub.id);
+  // NOTE: The hub stays registered with MessageRouter to avoid races with
+  // unregistering message hubs, however its endpoints are no longer accessible.
+  getRouter().forEachEndpointOfHub(kHostHub.id, [](const EndpointInfo &) {
+    ADD_FAILURE();
+    return true;
+  });
+}
+
+// Hubs are expected to be static over the runtime, i.e. regardless of when a
+// hub is registered, the total set of hubs is fixed. A different hub cannot
+// take the slot of an unregistered hub.
+TEST_F(HostMessageHubTest, RegisterHubStaticHubLimit) {
+  // Register a hub to occupy a slot.
+  getManager().registerHub(kHostHub);
+
+  // Attempt to register a hub for each slot. The final registration should fail
+  // due to the occupied slot.
+  std::vector<std::string> hubNames;
+  for (uint64_t i = 1; i <= CHRE_MESSAGE_ROUTER_MAX_HOST_HUBS; ++i) {
+    MessageHubId id = kHostHub.id + i;
+    hubNames.push_back(std::string(kHostHubName) + '0');
+    hubNames.back().back() = i + '0';
+    getManager().registerHub({.id = id, .name = hubNames[i - 1].c_str()});
+    if (i < CHRE_MESSAGE_ROUTER_MAX_HOST_HUBS) {
+      EXPECT_TRUE(getRouter().forEachEndpointOfHub(
+          id, [](const EndpointInfo &) { return true; }));
+    } else {
+      EXPECT_FALSE(getRouter().forEachEndpointOfHub(
+          id, [](const EndpointInfo &) { return true; }));
+    }
+  }
+}
+
+MATCHER_P(HubMatcher, id, "matches the hub id in MessageHubInfo") {
+  return arg.id == id;
+}
+
+TEST_F(HostMessageHubTest, OnHubRegisteredAndUnregistered) {
+  getManager().registerHub(kHostHub);
+
+  const MessageHubId kHubId = kHostHub.id + 1;
+  EXPECT_CALL(mHostCallback, onHubRegistered(HubMatcher(kHubId)));
+  pw::IntrusivePtr<MockMessageHubCallback> newHubCb =
+      pw::MakeRefCounted<MockMessageHubCallback>();
+  const char *name = "test embedded hub";
+  auto newHub = getRouter().registerMessageHub(name, kHubId, newHubCb);
+  EXPECT_TRUE(newHub);
+
+  EXPECT_CALL(mHostCallback, onHubUnregistered(kHubId));
+  newHub.reset();
+}
+
+TEST_F(HostMessageHubTest, RegisterAndUnregisterEndpoint) {
+  getManager().registerHub(kHostHub);
+
+  EXPECT_CALL(*mEmbeddedHubCb,
+              onEndpointRegistered(kHostHub.id, kEndpoints[0].id));
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+  getRouter().forEachEndpointOfHub(kHostHub.id, [](const EndpointInfo &info) {
+    EXPECT_EQ(info.id, kEndpoints[0].id);
+    return true;
+  });
+
+  EXPECT_CALL(*mEmbeddedHubCb,
+              onEndpointUnregistered(kHostHub.id, kEndpoints[0].id));
+  getManager().unregisterEndpoint(kHostHub.id, kEndpoints[0].id);
+  bool found = false;
+  getRouter().forEachEndpointOfHub(kHostHub.id, [&found](const EndpointInfo &) {
+    found = true;
+    return true;
+  });
+  EXPECT_FALSE(found);
+}
+
+TEST_F(HostMessageHubTest, RegisterAndUnregisterEndpointWithService) {
+  getManager().registerHub(kHostHub);
+
+  EXPECT_CALL(*mEmbeddedHubCb,
+              onEndpointRegistered(kHostHub.id, kEndpoints[0].id));
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0],
+                                getHostEndpointServices());
+  bool found = false;
+  getRouter().forEachService([&found](const MessageHubInfo &hub,
+                                      const EndpointInfo &endpoint,
+                                      const ServiceInfo &service) {
+    if (hub.id != kHostHub.id || endpoint.id != kEndpoints[0].id ||
+        std::strcmp(service.serviceDescriptor, kServiceName)) {
+      return false;
+    }
+    found = true;
+    return true;
+  });
+  EXPECT_TRUE(found);
+
+  EXPECT_CALL(*mEmbeddedHubCb,
+              onEndpointUnregistered(kHostHub.id, kEndpoints[0].id));
+  getManager().unregisterEndpoint(kHostHub.id, kEndpoints[0].id);
+  found = false;
+  getRouter().forEachEndpointOfHub(kHostHub.id, [&found](const EndpointInfo &) {
+    found = true;
+    return true;
+  });
+  EXPECT_FALSE(found);
+}
+
+TEST_F(HostMessageHubTest, OnEndpointRegisteredAndUnregistered) {
+  getManager().registerHub(kHostHub);
+
+  mEmbeddedEndpoints.push_back({kExtraEndpoint, {}});
+  expectOnEmbeddedEndpoint(mEmbeddedEndpoints.back(), nullptr);
+  mEmbeddedHubIntf.registerEndpoint(kExtraEndpoint.id);
+
+  EXPECT_CALL(mHostCallback,
+              onEndpointUnregistered(kEmbeddedHub.id, kExtraEndpoint.id));
+  mEmbeddedHubIntf.unregisterEndpoint(kExtraEndpoint.id);
+}
+
+TEST_F(HostMessageHubTest, OnEndpointWithServiceRegisteredAndUnregistered) {
+  getManager().registerHub(kHostHub);
+
+  mEmbeddedEndpoints.push_back({kExtraEndpoint, {kService}});
+  expectOnEmbeddedEndpoint(mEmbeddedEndpoints.back(), nullptr);
+  mEmbeddedHubIntf.registerEndpoint(kExtraEndpoint.id);
+
+  EXPECT_CALL(mHostCallback,
+              onEndpointUnregistered(kEmbeddedHub.id, kExtraEndpoint.id));
+  mEmbeddedHubIntf.unregisterEndpoint(kExtraEndpoint.id);
+}
+
+TEST_F(HostMessageHubTest, RegisterMaximumEndpoints) {
+  getManager().registerHub(kHostHub);
+
+  // Try to register one more than the maximum endpoints.
+  for (int i = 0; i <= CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS; ++i) {
+    EndpointInfo endpoint(0x1 + i, nullptr, 0, EndpointType::GENERIC, 0);
+    getManager().registerEndpoint(kHostHub.id, endpoint, {});
+  }
+
+  int count = 0;
+  getRouter().forEachEndpointOfHub(kHostHub.id, [&count](const EndpointInfo &) {
+    count++;
+    return false;
+  });
+  EXPECT_EQ(count, CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS);
+
+  // Unregister one endpoint and register another one.
+  getManager().unregisterEndpoint(kHostHub.id, 0x1);
+  EndpointInfo endpoint(0x1 + CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS, nullptr,
+                        0, EndpointType::GENERIC, 0);
+  getManager().registerEndpoint(kHostHub.id, endpoint, {});
+  bool found = false;
+  getRouter().forEachEndpointOfHub(
+      kHostHub.id, [&found](const EndpointInfo &info) {
+        if (info.id == 0x1 + CHRE_MESSAGE_ROUTER_MAX_HOST_ENDPOINTS) {
+          found = true;
+          return true;
+        }
+        return false;
+      });
+  EXPECT_TRUE(found);
+}
+
+TEST_F(HostMessageHubTest, OpenAndCloseSession) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+
+  constexpr auto sessionId = MessageRouter::kDefaultReservedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpened(kHostHub.id, sessionId)).Times(1);
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpenRequest(_))
+      .WillOnce([this](const Session &session) {
+        mEmbeddedHubIntf.onSessionOpenComplete(session.sessionId);
+      });
+  getManager().openSession(kHostHub.id, kEndpoints[0].id, kEmbeddedHub.id,
+                           kEndpoints[1].id, sessionId,
+                           /*serviceDescriptor=*/nullptr);
+
+  EXPECT_CALL(*mEmbeddedHubCb,
+              onSessionClosed(_, Reason::CLOSE_ENDPOINT_SESSION_REQUESTED))
+      .Times(1);
+  getManager().closeSession(kHostHub.id, sessionId,
+                            Reason::CLOSE_ENDPOINT_SESSION_REQUESTED);
+}
+
+TEST_F(HostMessageHubTest, OpenSessionAndHandleClose) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+
+  constexpr auto sessionId = MessageRouter::kDefaultReservedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpened(kHostHub.id, sessionId)).Times(1);
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpenRequest(_))
+      .WillOnce([this](const Session &session) {
+        mEmbeddedHubIntf.onSessionOpenComplete(session.sessionId);
+      });
+  getManager().openSession(kHostHub.id, kEndpoints[0].id, kEmbeddedHub.id,
+                           kEndpoints[1].id, sessionId,
+                           /*serviceDescriptor=*/nullptr);
+
+  EXPECT_CALL(mHostCallback,
+              onSessionClosed(kHostHub.id, sessionId,
+                              Reason::CLOSE_ENDPOINT_SESSION_REQUESTED))
+      .Times(1);
+  mEmbeddedHubIntf.closeSession(sessionId,
+                                Reason::CLOSE_ENDPOINT_SESSION_REQUESTED);
+}
+
+TEST_F(HostMessageHubTest, OpenSessionRejected) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+
+  constexpr auto sessionId = MessageRouter::kDefaultReservedSessionId;
+  EXPECT_CALL(mHostCallback,
+              onSessionClosed(kHostHub.id, sessionId,
+                              Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED))
+      .Times(1);
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpenRequest(_))
+      .WillOnce([this](const Session &session) {
+        mEmbeddedHubIntf.closeSession(
+            session.sessionId, Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED);
+      });
+  getManager().openSession(kHostHub.id, kEndpoints[0].id, kEmbeddedHub.id,
+                           kEndpoints[1].id, sessionId,
+                           /*serviceDescriptor=*/nullptr);
+}
+
+TEST_F(HostMessageHubTest, OpenSessionWithService) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0],
+                                getHostEndpointServices());
+
+  constexpr auto sessionId = MessageRouter::kDefaultReservedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpened(kHostHub.id, sessionId)).Times(1);
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpenRequest(_))
+      .WillOnce([this](const Session &session) {
+        mEmbeddedHubIntf.onSessionOpenComplete(session.sessionId);
+      });
+  getManager().openSession(kHostHub.id, kEndpoints[0].id, kEmbeddedHub.id,
+                           kEndpoints[1].id, sessionId, kServiceName);
+}
+
+TEST_F(HostMessageHubTest, OnOpenSessionWithService) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0],
+                                getHostEndpointServices());
+
+  SessionId receivedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpenRequest(_))
+      .WillOnce([&receivedSessionId](const Session &session) {
+        receivedSessionId = session.sessionId;
+      });
+  auto sessionId = mEmbeddedHubIntf.openSession(kEndpoints[1].id, kHostHub.id,
+                                                kEndpoints[0].id, kServiceName);
+  EXPECT_EQ(sessionId, receivedSessionId);
+}
+
+TEST_F(HostMessageHubTest, AckSession) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+
+  SessionId receivedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpenRequest(_))
+      .WillOnce([&receivedSessionId](const Session &session) {
+        receivedSessionId = session.sessionId;
+      });
+  auto sessionId = mEmbeddedHubIntf.openSession(kEndpoints[1].id, kHostHub.id,
+                                                kEndpoints[0].id);
+  EXPECT_EQ(sessionId, receivedSessionId);
+
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpened(_)).Times(1);
+  getManager().ackSession(kHostHub.id, sessionId);
+}
+
+MATCHER_P(DataMatcher, data, "matches data in pw::UniquePtr<std::byte[]>") {
+  return arg != nullptr && !std::memcmp(arg.get(), data, arg.size());
+}
+
+MATCHER_P(SessionIdMatcher, session, "matches the session id in Session") {
+  return arg.sessionId == session;
+}
+
+TEST_F(HostMessageHubTest, SendMessage) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+  constexpr auto sessionId = MessageRouter::kDefaultReservedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpened(kHostHub.id, sessionId)).Times(1);
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpenRequest(_))
+      .WillOnce([this](const Session &session) {
+        mEmbeddedHubIntf.onSessionOpenComplete(session.sessionId);
+      });
+  getManager().openSession(kHostHub.id, kEndpoints[0].id, kEmbeddedHub.id,
+                           kEndpoints[1].id, sessionId,
+                           /*serviceDescriptor=*/nullptr);
+
+  std::byte data[] = {std::byte{0xde}, std::byte{0xad}, std::byte{0xbe},
+                      std::byte{0xef}};
+  EXPECT_CALL(*mEmbeddedHubCb,
+              onMessageReceived(DataMatcher(data), 1, 2,
+                                SessionIdMatcher(sessionId), _))
+      .Times(1);
+  getManager().sendMessage(kHostHub.id, sessionId, {data, sizeof(data)}, 1, 2);
+}
+
+TEST_F(HostMessageHubTest, ReceiveMessage) {
+  getManager().registerHub(kHostHub);
+  getManager().registerEndpoint(kHostHub.id, kEndpoints[0], {});
+  constexpr auto sessionId = MessageRouter::kDefaultReservedSessionId;
+  EXPECT_CALL(mHostCallback, onSessionOpened(kHostHub.id, sessionId)).Times(1);
+  EXPECT_CALL(*mEmbeddedHubCb, onSessionOpenRequest(_))
+      .WillOnce([this](const Session &session) {
+        mEmbeddedHubIntf.onSessionOpenComplete(session.sessionId);
+      });
+  getManager().openSession(kHostHub.id, kEndpoints[0].id, kEmbeddedHub.id,
+                           kEndpoints[1].id, sessionId,
+                           /*serviceDescriptor=*/nullptr);
+
+  std::byte bytes[] = {std::byte{0xde}, std::byte{0xad}, std::byte{0xbe},
+                       std::byte{0xef}};
+  auto data = pw::allocator::GetLibCAllocator().MakeUniqueArray<std::byte>(4);
+  std::memcpy(data.get(), bytes, sizeof(bytes));
+  EXPECT_CALL(mHostCallback, onMessageReceived(kHostHub.id, sessionId,
+                                               DataMatcher(bytes), 1, 2))
+      .Times(1);
+  mEmbeddedHubIntf.sendMessage(std::move(data), 1, 2, sessionId);
+}
+
+}  // namespace
+}  // namespace chre
diff --git a/test/simulation/inc/test_util.h b/test/simulation/inc/test_util.h
index 9e796018..500a326b 100644
--- a/test/simulation/inc/test_util.h
+++ b/test/simulation/inc/test_util.h
@@ -17,17 +17,28 @@
 #ifndef CHRE_SIMULATION_TEST_UTIL_H_
 #define CHRE_SIMULATION_TEST_UTIL_H_
 
-#include <chre/nanoapp.h>
+#include <algorithm>
+#include <chrono>
+#include <condition_variable>
 #include <cstdint>
+#include <mutex>
+#include <vector>
+
+#include "android-base/thread_annotations.h"
 
 #include "chre/core/event_loop_manager.h"
 #include "chre/core/nanoapp.h"
+#include "chre/nanoapp.h"
 #include "chre/util/unique_ptr.h"
 #include "test_event.h"
 #include "test_event_queue.h"
 
 namespace chre {
 
+//! Gets/Sets the timeout for wait/triggerWait() calls.
+std::chrono::nanoseconds getWaitTimeout();
+void setWaitTimeout(uint64_t timeout);
+
 constexpr uint64_t kDefaultTestNanoappId = 0x0123456789abcdef;
 
 /**
@@ -51,13 +62,13 @@ struct TestNanoappInfo {
 /**
  * Test nanoapp.
  *
- * Tests typically inherit this class and override the entry points to test the
- * nanoapp behavior.
+ * Tests typically inherit this class and override the entry points to test
+ * the nanoapp behavior.
  *
  * The bulk of the code should be in the handleEvent method to respond to
  * events sent to the nanoapp by the platform and by the sendEventToNanoapp
- * function. start and end can be use to setup and cleanup the test environment
- * around each test.
+ * function. start and end can be use to setup and cleanup the test
+ * environment around each test.
  *
  * Note: end is only executed when the nanoapp is explicitly unloaded.
  */
@@ -96,10 +107,53 @@ class TestNanoapp {
     return mTestNanoappInfo.perms;
   }
 
+  //! Call this function to trigger the wait condition and release the
+  //! waiting thread. This should only be called by the nanoapp in handleEvent.
+  void triggerWait(uint16_t eventType) {
+    mWaitingEventTypes.insert(eventType);
+    mCondVar.notify_one();
+  }
+
+  //! Completes action and expects it to return true, then waits for
+  //! triggerWait() to be called by the nanoapp with the given eventType.
+  void doActionAndWait(const std::function<bool()> &action,
+                       uint16_t eventType) {
+    std::unique_lock<std::mutex> lock(mMutex);
+    EXPECT_TRUE(action());
+    mCondVar.wait_for(lock, getWaitTimeout(), [this, eventType]() {
+      return mWaitingEventTypes.find(eventType) != mWaitingEventTypes.end();
+    });
+    auto iter = mWaitingEventTypes.find(eventType);
+    ASSERT_NE(iter, mWaitingEventTypes.end());
+    mWaitingEventTypes.erase(iter);
+  }
+
+  //! Waits for triggerWait() to be called by the nanoapp with the given
+  //! eventType.
+  void wait(uint16_t eventType) {
+    doActionAndWait([]() { return true; }, eventType);
+  }
+
+  std::mutex &mutex() {
+    return mMutex;
+  }
+
  private:
   const TestNanoappInfo mTestNanoappInfo;
+
+  //! Mutex and condition variable used to wait for triggerWait() to be
+  //! called.
+  std::mutex mMutex;
+  std::condition_variable mCondVar;
+  std::set<uint16_t> mWaitingEventTypes GUARDED_BY(mMutex);
 };
 
+/**
+ * @return a pointer to a registered nanoapp or nullptr if the appId is not
+ *         registered.
+ */
+TestNanoapp *queryNanoapp(uint64_t appId);
+
 /**
  * @return the statically loaded nanoapp based on the arguments.
  *
@@ -169,8 +223,8 @@ uint64_t loadNanoapp(UniquePtr<TestNanoapp> app);
 void unloadNanoapp(uint64_t appId);
 
 /**
- * A convenience deferred callback function that can be used to start an already
- * loaded nanoapp.
+ * A convenience deferred callback function that can be used to start an
+ * already loaded nanoapp.
  *
  * @param type The callback type.
  * @param nanoapp A pointer to the nanoapp that is already loaded.
@@ -204,6 +258,21 @@ void freeTestEventDataCallback(uint16_t /*eventType*/, void *eventData);
  */
 void sendEventToNanoapp(uint64_t appId, uint16_t eventType);
 
+/**
+ * Sends a message to a nanoapp and waits for the nanoapp code to call
+ * triggerWait(). The nanoapp code must call triggerWait() to release the
+ * waiting thread or this function will never return.
+ *
+ * This function is typically used to execute code in the context of the
+ * nanoapp in its handleEvent method.
+ *
+ * @param appId ID of the nanoapp.
+ * @param eventType The event to send.
+ * @param waitEventType The event to wait for.
+ */
+void sendEventToNanoappAndWait(uint64_t appId, uint16_t eventType,
+                               uint16_t waitEventType);
+
 /**
  * Sends a message to a nanoapp with data.
  *
@@ -218,7 +287,7 @@ void sendEventToNanoapp(uint64_t appId, uint16_t eventType);
  * @param eventType The event to send.
  * @param eventData The data to send.
  */
-template <class T>
+template <typename T>
 void sendEventToNanoapp(uint64_t appId, uint16_t eventType,
                         const T &eventData) {
   static_assert(std::is_trivial<T>::value);
@@ -241,6 +310,36 @@ void sendEventToNanoapp(uint64_t appId, uint16_t eventType,
   }
 }
 
+/**
+ * Sends a message to a nanoapp with data and waits for the nanoapp code to call
+ * triggerWait(). The nanoapp code must call triggerWait() to release the
+ * waiting thread or this function will never return.
+ *
+ * This function is typically used to execute code in the context of the
+ * nanoapp in its handleEvent method.
+ *
+ * The nanoapp handleEvent function will receive a a TestEvent instance
+ * populated with the eventType and a pointer to as copy of the evenData as
+ * a CHRE_EVENT_TEST_EVENT event.
+ *
+ * @param appId ID of the nanoapp.
+ * @param eventType The event to send.
+ * @param eventData The data to send.
+ * @param waitEventType The event to wait for.
+ */
+template <typename T>
+void sendEventToNanoappAndWait(uint64_t appId, uint16_t eventType,
+                               const T &eventData, uint16_t waitEventType) {
+  TestNanoapp *app = queryNanoapp(appId);
+  ASSERT_NE(app, nullptr);
+  app->doActionAndWait(
+      [appId, eventType, &eventData]() {
+        sendEventToNanoapp(appId, eventType, eventData);
+        return true;
+      },
+      waitEventType);
+}
+
 }  // namespace chre
 
 #endif  // CHRE_SIMULATION_TEST_UTIL_H_
diff --git a/test/simulation/info_struct_version_test.cc b/test/simulation/info_struct_version_test.cc
index c2d6a0f4..603aa742 100644
--- a/test/simulation/info_struct_version_test.cc
+++ b/test/simulation/info_struct_version_test.cc
@@ -28,7 +28,9 @@
 
 namespace chre {
 
-TEST_F(TestBase, InfoStructOldVersionCheckForAppPermission) {
+class InfoStructVersionTest : public TestBase {};
+
+TEST_F(InfoStructVersionTest, InfoStructOldVersionCheckForAppPermission) {
   constexpr uint8_t kInfoStructVersionOld = 2;
 
   constexpr uint64_t kAppId = 0x01234;
@@ -42,7 +44,7 @@ TEST_F(TestBase, InfoStructOldVersionCheckForAppPermission) {
   EXPECT_FALSE(oldnanoapp->supportsAppPermissions());
 }
 
-TEST_F(TestBase, InfoStructCurrentVersionCheckForAppPermission) {
+TEST_F(InfoStructVersionTest, InfoStructCurrentVersionCheckForAppPermission) {
   constexpr uint8_t kInfoStructVersionCurrent = 3;
 
   constexpr uint64_t kAppId = 0x56789;
@@ -56,7 +58,7 @@ TEST_F(TestBase, InfoStructCurrentVersionCheckForAppPermission) {
   EXPECT_TRUE(currentnanoapp->supportsAppPermissions());
 }
 
-TEST_F(TestBase, InfoStructFutureVersionCheckForAppPermission) {
+TEST_F(InfoStructVersionTest, InfoStructFutureVersionCheckForAppPermission) {
   constexpr uint8_t kInfoStructVersionFuture = 4;
 
   constexpr uint64_t kAppId = 0xabcde;
diff --git a/test/simulation/memory_test.cc b/test/simulation/memory_test.cc
index a3047346..ad46cad6 100644
--- a/test/simulation/memory_test.cc
+++ b/test/simulation/memory_test.cc
@@ -33,7 +33,9 @@
 namespace chre {
 namespace {
 
-TEST_F(TestBase, MemoryAllocateAndFree) {
+class MemoryTest : public TestBase {};
+
+TEST_F(MemoryTest, MemoryAllocateAndFree) {
   CREATE_CHRE_TEST_EVENT(ALLOCATE, 0);
   CREATE_CHRE_TEST_EVENT(FREE, 1);
 
@@ -103,7 +105,7 @@ TEST_F(TestBase, MemoryAllocateAndFree) {
   EXPECT_EQ(memManager.getAllocationCount(), 0);
 }
 
-TEST_F(TestBase, MemoryFreeOnNanoappUnload) {
+TEST_F(MemoryTest, MemoryFreeOnNanoappUnload) {
   CREATE_CHRE_TEST_EVENT(ALLOCATE, 0);
 
   class App : public TestNanoapp {
@@ -158,7 +160,7 @@ TEST_F(TestBase, MemoryFreeOnNanoappUnload) {
   EXPECT_EQ(memManager.getAllocationCount(), 0);
 }
 
-TEST_F(TestBase, MemoryStressTestShouldNotTriggerErrors) {
+TEST_F(MemoryTest, MemoryStressTestShouldNotTriggerErrors) {
   CREATE_CHRE_TEST_EVENT(ALLOCATE, 0);
   CREATE_CHRE_TEST_EVENT(FREE, 1);
 
diff --git a/test/simulation/rpc_test.cc b/test/simulation/rpc_test.cc
index a023f640..ccad4b91 100644
--- a/test/simulation/rpc_test.cc
+++ b/test/simulation/rpc_test.cc
@@ -45,7 +45,9 @@ pw::Status RpcTestService::Increment(const chre_rpc_NumberMessage &request,
 
 namespace {
 
-TEST_F(TestBase, PwRpcCanPublishServicesInNanoappStart) {
+class RpcTest : public TestBase {};
+
+TEST_F(RpcTest, PwRpcCanPublishServicesInNanoappStart) {
   class App : public TestNanoapp {
    public:
     bool start() override {
@@ -75,7 +77,7 @@ TEST_F(TestBase, PwRpcCanPublishServicesInNanoappStart) {
   EXPECT_EQ(napp->getRpcServices()[3].id, 4);
 }
 
-TEST_F(TestBase, PwRpcCanNotPublishDuplicateServices) {
+TEST_F(RpcTest, PwRpcCanNotPublishDuplicateServices) {
   class App : public TestNanoapp {
     bool start() override {
       struct chreNanoappRpcService servicesA[] = {
@@ -107,7 +109,7 @@ TEST_F(TestBase, PwRpcCanNotPublishDuplicateServices) {
   EXPECT_EQ(napp->getRpcServices()[1].id, 2);
 }
 
-TEST_F(TestBase, PwRpcDifferentAppCanPublishSameServices) {
+TEST_F(RpcTest, PwRpcDifferentAppCanPublishSameServices) {
   class App : public TestNanoapp {
    public:
     explicit App(uint64_t id) : TestNanoapp(TestNanoappInfo{.id = id}) {}
@@ -139,7 +141,7 @@ TEST_F(TestBase, PwRpcDifferentAppCanPublishSameServices) {
   EXPECT_EQ(napp2->getRpcServices()[1].id, 2);
 }
 
-TEST_F(TestBase, PwRpcCanNotPublishServicesOutsideOfNanoappStart) {
+TEST_F(RpcTest, PwRpcCanNotPublishServicesOutsideOfNanoappStart) {
   CREATE_CHRE_TEST_EVENT(PUBLISH_SERVICES, 0);
 
   class App : public TestNanoapp {
@@ -181,7 +183,7 @@ TEST_F(TestBase, PwRpcCanNotPublishServicesOutsideOfNanoappStart) {
   EXPECT_EQ(napp->getRpcServices().size(), 0);
 }
 
-TEST_F(TestBase, PwRpcRegisterServicesShouldGracefullyFailOnDuplicatedService) {
+TEST_F(RpcTest, PwRpcRegisterServicesShouldGracefullyFailOnDuplicatedService) {
   class App : public TestNanoapp {
    public:
     bool start() override {
@@ -213,7 +215,7 @@ TEST_F(TestBase, PwRpcRegisterServicesShouldGracefullyFailOnDuplicatedService) {
   EnvSingleton::deinit();
 }
 
-TEST_F(TestBase, PwRpcGetNanoappInfoByAppIdReturnsServices) {
+TEST_F(RpcTest, PwRpcGetNanoappInfoByAppIdReturnsServices) {
   CREATE_CHRE_TEST_EVENT(QUERY_INFO, 0);
 
   class App : public TestNanoapp {
@@ -265,7 +267,7 @@ TEST_F(TestBase, PwRpcGetNanoappInfoByAppIdReturnsServices) {
   EXPECT_EQ(pInfo->reserved[2], 0);
 }
 
-TEST_F(TestBase, PwRpcClientNanoappCanRequestServerNanoapp) {
+TEST_F(RpcTest, PwRpcClientNanoappCanRequestServerNanoapp) {
   CREATE_CHRE_TEST_EVENT(INCREMENT_REQUEST, 0);
 
   class ClientApp : public TestNanoapp {
@@ -353,7 +355,7 @@ TEST_F(TestBase, PwRpcClientNanoappCanRequestServerNanoapp) {
   EnvSingleton::deinit();
 }
 
-TEST_F(TestBase, PwRpcRpcClientHasServiceCheckForAMatchingService) {
+TEST_F(RpcTest, PwRpcRpcClientHasServiceCheckForAMatchingService) {
   CREATE_CHRE_TEST_EVENT(QUERY_HAS_SERVICE, 0);
 
   struct ServiceInfo {
diff --git a/test/simulation/sensor_test.cc b/test/simulation/sensor_test.cc
index 779c8c6f..aba0976a 100644
--- a/test/simulation/sensor_test.cc
+++ b/test/simulation/sensor_test.cc
@@ -36,7 +36,9 @@
 namespace chre {
 namespace {
 
-TEST_F(TestBase, SensorCanSubscribeAndUnsubscribeToDataEvents) {
+class SensorTest : public TestBase {};
+
+TEST_F(SensorTest, SensorCanSubscribeAndUnsubscribeToDataEvents) {
   CREATE_CHRE_TEST_EVENT(CONFIGURE, 0);
 
   struct Configuration {
@@ -103,7 +105,7 @@ TEST_F(TestBase, SensorCanSubscribeAndUnsubscribeToDataEvents) {
   EXPECT_FALSE(chrePalSensorIsSensor0Enabled());
 }
 
-TEST_F(TestBase, SensorUnsubscribeToDataEventsOnUnload) {
+TEST_F(SensorTest, SensorUnsubscribeToDataEventsOnUnload) {
   CREATE_CHRE_TEST_EVENT(CONFIGURE, 0);
 
   struct Configuration {
diff --git a/test/simulation/settings_test.cc b/test/simulation/settings_test.cc
index 8dd5314a..16b6eb94 100644
--- a/test/simulation/settings_test.cc
+++ b/test/simulation/settings_test.cc
@@ -35,6 +35,8 @@ namespace chre {
 
 namespace {
 
+class SettingsTest : public TestBase {};
+
 int8_t gExpectedLocationSettingState;
 int8_t gExpectedWifiSettingState;
 
@@ -139,7 +141,7 @@ void startTestNanoapp() {
  * 3) Toggle location setting -> enabled.
  * 4) Verify things resume.
  */
-TEST_F(TestBase, LocationSettingsTest) {
+TEST_F(SettingsTest, LocationSettingsTest) {
   startTestNanoapp();
 
   waitForEvent(CHRE_EVENT_SIMULATION_TEST_NANOAPP_LOADED);
@@ -172,7 +174,7 @@ TEST_F(TestBase, LocationSettingsTest) {
   ASSERT_TRUE(chrePalGnssIsLocationEnabled());
 }
 
-TEST_F(TestBase, DefaultSettingsAreSet) {
+TEST_F(SettingsTest, DefaultSettingsAreSet) {
   for (uint8_t setting = CHRE_USER_SETTING_LOCATION;
        setting <= CHRE_USER_SETTING_BLE_AVAILABLE; ++setting) {
     int8_t expectedSettingState = (setting == CHRE_USER_SETTING_AIRPLANE_MODE)
@@ -182,7 +184,7 @@ TEST_F(TestBase, DefaultSettingsAreSet) {
   }
 }
 
-TEST_F(TestBase, WifiSettingsTest) {
+TEST_F(SettingsTest, WifiSettingsTest) {
   startTestNanoapp();
 
   waitForEvent(CHRE_EVENT_WIFI_NAN_IDENTIFIER_RESULT);
diff --git a/test/simulation/test_base.cc b/test/simulation/test_base.cc
index 985295f4..baf89b32 100644
--- a/test/simulation/test_base.cc
+++ b/test/simulation/test_base.cc
@@ -37,7 +37,7 @@ namespace chre {
 
 namespace {
 
-constexpr size_t kMaxMessageHubs = 2;
+constexpr size_t kMaxMessageHubs = 5;
 constexpr size_t kMaxSessions = 25;
 pw::Vector<MessageRouter::MessageHubRecord, kMaxMessageHubs> gMessageHubs;
 pw::Vector<Session, kMaxSessions> gSessions;
@@ -59,6 +59,8 @@ pw::Vector<Session, kMaxSessions> gSessions;
  * this test.
  */
 void TestBase::SetUp() {
+  setWaitTimeout(getTimeoutNs() / 2);
+
   MessageRouterSingleton::init(gMessageHubs, gSessions);
   chre::PlatformLogSingleton::init();
   TaskManagerSingleton::init();
diff --git a/test/simulation/test_util.cc b/test/simulation/test_util.cc
index 44398ab7..4c915b93 100644
--- a/test/simulation/test_util.cc
+++ b/test/simulation/test_util.cc
@@ -17,10 +17,12 @@
 #include "test_util.h"
 
 #include <gtest/gtest.h>
+#include <cstdint>
 #include <unordered_map>
 
 #include "chre/core/event_loop_manager.h"
 #include "chre/core/nanoapp.h"
+#include "chre/platform/system_time.h"
 #include "chre/util/dynamic_vector.h"
 #include "chre/util/macros.h"
 #include "chre/util/memory.h"
@@ -41,13 +43,8 @@ DynamicVector<UniquePtr<chreNslNanoappInfo>> gNanoappInfos;
 /** Registry of nanoapp by ID. */
 std::unordered_map<uint64_t, UniquePtr<TestNanoapp>> nanoapps;
 
-/**
- * @return a pointer to a registered nanoapp or nullptr if the appId is not
- *         registered.
- */
-TestNanoapp *queryNanoapp(uint64_t appId) {
-  return nanoapps.count(appId) == 0 ? nullptr : nanoapps[appId].get();
-}
+//! The timeout for wait/triggerWait() calls.
+uint64_t gWaitTimeout = 3 * kOneSecondInNanoseconds;
 
 /**
  * Nanoapp start.
@@ -76,6 +73,7 @@ void handleEvent(uint32_t senderInstanceId, uint16_t eventType,
   if (app == nullptr) {
     LOGE("[handleEvent] unregistered nanoapp 0x%016" PRIx64, id);
   } else {
+    std::lock_guard<std::mutex> lock(app->mutex());
     app->handleEvent(senderInstanceId, eventType, eventData);
   }
 }
@@ -122,6 +120,18 @@ void unregisterNanoapp(uint64_t appId) {
 
 }  // namespace
 
+std::chrono::nanoseconds getWaitTimeout() {
+  return std::chrono::nanoseconds(gWaitTimeout);
+}
+
+void setWaitTimeout(uint64_t timeout) {
+  gWaitTimeout = timeout;
+}
+
+TestNanoapp *queryNanoapp(uint64_t appId) {
+  return nanoapps.count(appId) == 0 ? nullptr : nanoapps[appId].get();
+}
+
 void unregisterAllTestNanoapps() {
   nanoapps.clear();
 }
@@ -220,6 +230,18 @@ void sendEventToNanoapp(uint64_t appId, uint16_t eventType) {
   }
 }
 
+void sendEventToNanoappAndWait(uint64_t appId, uint16_t eventType,
+                               uint16_t waitEventType) {
+  TestNanoapp *app = queryNanoapp(appId);
+  ASSERT_NE(app, nullptr);
+  app->doActionAndWait(
+      [appId, eventType]() {
+        sendEventToNanoapp(appId, eventType);
+        return true;
+      },
+      waitEventType);
+}
+
 void unloadNanoapp(uint64_t appId) {
   uint64_t *ptr = memoryAlloc<uint64_t>();
   ASSERT_NE(ptr, nullptr);
diff --git a/test/simulation/timer_test.cc b/test/simulation/timer_test.cc
index ff76ddbe..c7e38ce1 100644
--- a/test/simulation/timer_test.cc
+++ b/test/simulation/timer_test.cc
@@ -33,8 +33,8 @@
 
 namespace chre {
 
-// TestTimer is required to access private members of the TimerPool.
-class TestTimer : public TestBase {
+// TimerTest is required to access private members of the TimerPool.
+class TimerTest : public TestBase {
  protected:
   bool hasNanoappTimers(TimerPool &pool, uint16_t instanceId) {
     return pool.hasNanoappTimers(instanceId);
@@ -42,7 +42,8 @@ class TestTimer : public TestBase {
 };
 
 namespace {
-TEST_F(TestTimer, SetupAndCancelPeriodicTimer) {
+
+TEST_F(TimerTest, SetupAndCancelPeriodicTimer) {
   CREATE_CHRE_TEST_EVENT(START_TIMER, 0);
   CREATE_CHRE_TEST_EVENT(STOP_TIMER, 1);
 
@@ -119,7 +120,7 @@ TEST_F(TestTimer, SetupAndCancelPeriodicTimer) {
   EXPECT_FALSE(success);
 }
 
-TEST_F(TestTimer, CancelPeriodicTimerOnUnload) {
+TEST_F(TimerTest, CancelPeriodicTimerOnUnload) {
   CREATE_CHRE_TEST_EVENT(START_TIMER, 0);
 
   class App : public TestNanoapp {
diff --git a/test/simulation/wifi_nan_test.cc b/test/simulation/wifi_nan_test.cc
index bab012ee..f7099e68 100644
--- a/test/simulation/wifi_nan_test.cc
+++ b/test/simulation/wifi_nan_test.cc
@@ -47,6 +47,8 @@
 namespace chre {
 namespace {
 
+class WifiNanTest : public TestBase {};
+
 /**
  * Common settings for test nanoapps.
  *
@@ -71,7 +73,7 @@ class NanTestNanoapp : public TestNanoapp {
  * Test that an async error is received if NAN operations are attempted when
  * the WiFi setting is disabled.
  */
-TEST_F(TestBase, WifiNanDisabledViaSettings) {
+TEST_F(WifiNanTest, WifiNanDisabledViaSettings) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
 
   class App : public NanTestNanoapp {
@@ -123,7 +125,7 @@ TEST_F(TestBase, WifiNanDisabledViaSettings) {
  * received with a matching cookie. Also test that a discovery event is later
  * received, marking the completion of the subscription process.
  */
-TEST_F(TestBase, WifiNanSuccessfulSubscribe) {
+TEST_F(WifiNanTest, WifiNanSuccessfulSubscribe) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
 
   class App : public NanTestNanoapp {
@@ -189,7 +191,7 @@ TEST_F(TestBase, WifiNanSuccessfulSubscribe) {
   EXPECT_EQ(id, subscribeId);
 }
 
-TEST_F(TestBase, WifiNanUnsSubscribeOnNanoappUnload) {
+TEST_F(WifiNanTest, WifiNanUnsSubscribeOnNanoappUnload) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
 
   class App : public NanTestNanoapp {
@@ -250,7 +252,7 @@ TEST_F(TestBase, WifiNanUnsSubscribeOnNanoappUnload) {
  * fake PAL engine always returns the generic CHRE_ERROR as the error code,
  * but this may vary in unsimulated scenarios).
  */
-TEST_F(TestBase, WifiNanUnuccessfulSubscribeTest) {
+TEST_F(WifiNanTest, WifiNanUnuccessfulSubscribeTest) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
 
   class App : public NanTestNanoapp {
@@ -306,7 +308,7 @@ TEST_F(TestBase, WifiNanUnuccessfulSubscribeTest) {
  * Test that a terminated event is received upon the Pal NAN engine
  * terminating a discovered service.
  */
-TEST_F(TestBase, WifiNanServiceTerminatedTest) {
+TEST_F(WifiNanTest, WifiNanServiceTerminatedTest) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
 
   class App : public NanTestNanoapp {
@@ -387,7 +389,7 @@ TEST_F(TestBase, WifiNanServiceTerminatedTest) {
  * Test that a service lost event is received upon the Pal NAN engine 'losing'
  * a discovered service.
  */
-TEST_F(TestBase, WifiNanServiceLostTest) {
+TEST_F(WifiNanTest, WifiNanServiceLostTest) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
 
   struct Ids {
@@ -475,7 +477,7 @@ TEST_F(TestBase, WifiNanServiceLostTest) {
  * Test that a ranging event is received upon requesting NAN range
  * measurements.
  */
-TEST_F(TestBase, WifiNanRangingTest) {
+TEST_F(WifiNanTest, WifiNanRangingTest) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
   CREATE_CHRE_TEST_EVENT(REQUEST_RANGING, 1);
 
@@ -550,7 +552,7 @@ TEST_F(TestBase, WifiNanRangingTest) {
   waitForEvent(CHRE_EVENT_WIFI_RANGING_RESULT);
 }
 
-TEST_F(TestBase, WifiNanSubscribeCancelTest) {
+TEST_F(WifiNanTest, WifiNanSubscribeCancelTest) {
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE, 0);
   CREATE_CHRE_TEST_EVENT(NAN_SUBSCRIBE_DONE, 1);
   CREATE_CHRE_TEST_EVENT(NAN_UNSUBSCRIBE, 2);
diff --git a/test/simulation/wifi_scan_test.cc b/test/simulation/wifi_scan_test.cc
index 1940e075..bf4aecf1 100644
--- a/test/simulation/wifi_scan_test.cc
+++ b/test/simulation/wifi_scan_test.cc
@@ -32,6 +32,9 @@
 
 namespace chre {
 namespace {
+
+class WifiScanTest : public TestBase {};
+
 using namespace std::chrono_literals;
 
 CREATE_CHRE_TEST_EVENT(SCAN_REQUEST, 20);
@@ -114,7 +117,7 @@ class WifiScanTestNanoapp : public TestNanoapp {
   uint8_t mNextFreeCookieIndex = 0;
 };
 
-TEST_F(TestBase, WifiScanBasicSettingTest) {
+TEST_F(WifiScanTest, WifiScanBasicSettingTest) {
   uint64_t appId = loadNanoapp(MakeUnique<WifiScanTestNanoapp>());
 
   EventLoopManagerSingleton::get()->getSettingManager().postSettingChange(
diff --git a/test/simulation/wifi_test.cc b/test/simulation/wifi_test.cc
index deca31c8..6d70d2d4 100644
--- a/test/simulation/wifi_test.cc
+++ b/test/simulation/wifi_test.cc
@@ -33,7 +33,9 @@
 namespace chre {
 namespace {
 
-TEST_F(TestBase, WifiCanSubscribeAndUnsubscribeToScanMonitoring) {
+class WifiTest : public TestBase {};
+
+TEST_F(WifiTest, WifiCanSubscribeAndUnsubscribeToScanMonitoring) {
   CREATE_CHRE_TEST_EVENT(MONITORING_REQUEST, 0);
 
   struct MonitoringRequest {
@@ -101,7 +103,7 @@ TEST_F(TestBase, WifiCanSubscribeAndUnsubscribeToScanMonitoring) {
   EXPECT_FALSE(chrePalWifiIsScanMonitoringActive());
 }
 
-TEST_F(TestBase, WifiScanMonitoringDisabledOnUnload) {
+TEST_F(WifiTest, WifiScanMonitoringDisabledOnUnload) {
   CREATE_CHRE_TEST_EVENT(MONITORING_REQUEST, 1);
 
   struct MonitoringRequest {
@@ -166,7 +168,7 @@ TEST_F(TestBase, WifiScanMonitoringDisabledOnUnload) {
   EXPECT_FALSE(chrePalWifiIsScanMonitoringActive());
 }
 
-TEST_F(TestBase, WifiScanMonitoringDisabledOnUnloadAndCanBeReEnabled) {
+TEST_F(WifiTest, WifiScanMonitoringDisabledOnUnloadAndCanBeReEnabled) {
   CREATE_CHRE_TEST_EVENT(MONITORING_REQUEST, 1);
 
   struct MonitoringRequest {
diff --git a/test/simulation/wifi_timeout_test.cc b/test/simulation/wifi_timeout_test.cc
index 7c310fd7..1e9d4766 100644
--- a/test/simulation/wifi_timeout_test.cc
+++ b/test/simulation/wifi_timeout_test.cc
@@ -33,12 +33,13 @@
 
 namespace chre {
 namespace {
-// WifiTimeoutTestBase needs to set timeout more than the max waitForEvent()
+
+// WifiTimeoutTest needs to set timeout more than the max waitForEvent()
 // should process (Currently it is
 // WifiCanDispatchSecondScanRequestInQueueAfterFirstTimeout). If not,
 // waitForEvent will timeout before actual timeout happens in CHRE, making us
 // unable to observe how system handles timeout.
-class WifiTimeoutTestBase : public TestBase {
+class WifiTimeoutTest : public TestBase {
  protected:
   uint64_t getTimeoutNs() const override {
     return 3 * CHRE_TEST_WIFI_SCAN_RESULT_TIMEOUT_NS;
@@ -48,7 +49,7 @@ class WifiTimeoutTestBase : public TestBase {
 CREATE_CHRE_TEST_EVENT(SCAN_REQUEST, 20);
 CREATE_CHRE_TEST_EVENT(REQUEST_TIMED_OUT, 21);
 
-TEST_F(WifiTimeoutTestBase, WifiScanRequestTimeoutTest) {
+TEST_F(WifiTimeoutTest, WifiScanRequestTimeoutTest) {
   class ScanTestNanoapp : public TestNanoapp {
    public:
     explicit ScanTestNanoapp()
@@ -139,7 +140,7 @@ TEST_F(WifiTimeoutTestBase, WifiScanRequestTimeoutTest) {
   unloadNanoapp(appId);
 }
 
-TEST_F(WifiTimeoutTestBase, WifiCanDispatchQueuedRequestAfterOneTimeout) {
+TEST_F(WifiTimeoutTest, WifiCanDispatchQueuedRequestAfterOneTimeout) {
   constexpr uint8_t kNanoappNum = 2;
   // receivedTimeout is shared across apps and must be static.
   // But we want it initialized each time the test is executed.
@@ -255,7 +256,7 @@ TEST_F(WifiTimeoutTestBase, WifiCanDispatchQueuedRequestAfterOneTimeout) {
   unloadNanoapp(secondAppId);
 }
 
-TEST_F(WifiTimeoutTestBase, WifiScanMonitorTimeoutTest) {
+TEST_F(WifiTimeoutTest, WifiScanMonitorTimeoutTest) {
   CREATE_CHRE_TEST_EVENT(SCAN_MONITOR_REQUEST, 1);
 
   struct MonitoringRequest {
@@ -360,7 +361,7 @@ TEST_F(WifiTimeoutTestBase, WifiScanMonitorTimeoutTest) {
   unloadNanoapp(appId);
 }
 
-TEST_F(WifiTimeoutTestBase, WifiRequestRangingTimeoutTest) {
+TEST_F(WifiTimeoutTest, WifiRequestRangingTimeoutTest) {
   CREATE_CHRE_TEST_EVENT(RANGING_REQUEST, 0);
 
   class App : public TestNanoapp {
diff --git a/util/CMakeLists.txt b/util/CMakeLists.txt
index 3d4554f9..07d24943 100644
--- a/util/CMakeLists.txt
+++ b/util/CMakeLists.txt
@@ -115,6 +115,7 @@ pw_add_library(chre.util.nanoapp STATIC
     chre.chre_api
     chre.platform.assert
     chre.platform.log
+    chre.platform.tagged_log
     chre.util
     chre.variant.config
     pw_tokenizer
@@ -159,7 +160,9 @@ pw_add_library(chre.util.system STATIC
   HEADERS
     include/chre/util/system/atomic_spsc_queue.h
     include/chre/util/system/ble_util.h
+    include/chre/util/system/chre_error_util.h
     include/chre/util/system/debug_dump.h
+    include/chre/util/system/error_util.h
     include/chre/util/system/event_callbacks.h
     include/chre/util/system/fixed_size_blocking_queue.h
     include/chre/util/system/fixed_size_blocking_queue_impl.h
@@ -168,6 +171,7 @@ pw_add_library(chre.util.system STATIC
     include/chre/util/system/napp_header_utils.h
     include/chre/util/system/napp_permissions.h
     include/chre/util/system/ref_base.h
+    include/chre/util/system/service_helpers.h
     include/chre/util/system/shared_ptr.h
     include/chre/util/system/shared_ptr_impl.h
     include/chre/util/system/synchronized_expandable_memory_pool.h
@@ -175,6 +179,7 @@ pw_add_library(chre.util.system STATIC
     include/chre/util/system/synchronized_memory_pool.h
     include/chre/util/system/synchronized_memory_pool_impl.h
     include/chre/util/system/stats_container.h
+    include/chre/util/system/system_callback_type.h
     include/chre/util/system/transaction_manager.h
     include/chre/util/system/transaction_manager_impl.h
     include/chre/util/system/wifi_util.h
@@ -191,11 +196,15 @@ pw_add_library(chre.util.system STATIC
     chre.util
     chre.variant.config
     pw_allocator.deallocator
+    pw_containers.vector
+    pw_intrusive_ptr
   SOURCES
     system/ble_util.cc
+    system/error_util.cc
     system/event_callbacks.cc
     system/debug_dump.cc
     system/message_router.cc
+    system/service_helpers.cc
   PRIVATE_DEPS
     chre.platform.log
 )
diff --git a/util/include/chre/util/array_queue.h b/util/include/chre/util/array_queue.h
index 2be174e9..351bc56d 100644
--- a/util/include/chre/util/array_queue.h
+++ b/util/include/chre/util/array_queue.h
@@ -321,7 +321,7 @@ class ArrayQueueExternalStorage : public NonCopyable {
     return mData;
   }
 
-  size_t capacity() const {
+  constexpr size_t capacity() const {
     return kCapacity;
   }
 
diff --git a/util/include/chre/util/enum.h b/util/include/chre/util/enum.h
index 52baa319..2dad53d8 100644
--- a/util/include/chre/util/enum.h
+++ b/util/include/chre/util/enum.h
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#pragma once
 
 #include <type_traits>
 
diff --git a/util/include/chre/util/fixed_size_vector.h b/util/include/chre/util/fixed_size_vector.h
index 91658e13..71bd2b94 100644
--- a/util/include/chre/util/fixed_size_vector.h
+++ b/util/include/chre/util/fixed_size_vector.h
@@ -75,7 +75,9 @@ class FixedSizeVector : public NonCopyable {
    * @return The maximum capacity of the vector as defined by the template
    * argument.
    */
-  size_t capacity() const;
+  constexpr size_t capacity() const {
+    return kCapacity;
+  }
 
   /**
    * Determines whether the vector is empty or not.
diff --git a/util/include/chre/util/fixed_size_vector_impl.h b/util/include/chre/util/fixed_size_vector_impl.h
index d6d4112b..32032812 100644
--- a/util/include/chre/util/fixed_size_vector_impl.h
+++ b/util/include/chre/util/fixed_size_vector_impl.h
@@ -71,11 +71,6 @@ size_t FixedSizeVector<ElementType, kCapacity>::size() const {
   return mSize;
 }
 
-template <typename ElementType, size_t kCapacity>
-size_t FixedSizeVector<ElementType, kCapacity>::capacity() const {
-  return kCapacity;
-}
-
 template <typename ElementType, size_t kCapacity>
 bool FixedSizeVector<ElementType, kCapacity>::empty() const {
   return (mSize == 0);
diff --git a/util/include/chre/util/nanoapp/tagged_log.h b/util/include/chre/util/nanoapp/tagged_log.h
index 3efe3a31..577560ad 100644
--- a/util/include/chre/util/nanoapp/tagged_log.h
+++ b/util/include/chre/util/nanoapp/tagged_log.h
@@ -37,11 +37,15 @@
 
 #else  // CHRE_IS_NANOAPP_BUILD
 // Static nanoapps
+#ifdef CHRE_PLATFORM_TAGGED_LOGGING_ENABLED
+#include "chre/platform/tagged_log.h"
+#else
 #define TLOGV(format, ...) LOGV("%s " format, LOG_TAG, ##__VA_ARGS__)
 #define TLOGD(format, ...) LOGD("%s " format, LOG_TAG, ##__VA_ARGS__)
 #define TLOGI(format, ...) LOGI("%s " format, LOG_TAG, ##__VA_ARGS__)
 #define TLOGW(format, ...) LOGW("%s " format, LOG_TAG, ##__VA_ARGS__)
 #define TLOGE(format, ...) LOGE("%s " format, LOG_TAG, ##__VA_ARGS__)
+#endif
 
 #endif  // CHRE_IS_NANOAPP_BUILD
 
diff --git a/util/include/chre/util/pigweed/rpc_helper.h b/util/include/chre/util/pigweed/rpc_helper.h
index 08bd2bf6..b105897a 100644
--- a/util/include/chre/util/pigweed/rpc_helper.h
+++ b/util/include/chre/util/pigweed/rpc_helper.h
@@ -34,19 +34,6 @@ namespace chre {
  * @return whether the nanoapp IDs match (lower 16b).
  */
 bool rpcEndpointsMatch(uint32_t expectedId, uint32_t actualId);
-
-/**
- * @param id Channel ID.
- * @return whether the channel ID is a host client.
- */
-bool isRpcChannelIdHostClient(uint32_t id);
-
-/**
- * @param id Channel ID.
- * @return whether the channel ID is a nanoapp client.
- */
-bool isRpcChannelIdNanoappClient(uint32_t id);
-
 /**
  * Validates that the host client sending the message matches the expected
  * channel ID.
diff --git a/util/include/chre/util/raw_storage.h b/util/include/chre/util/raw_storage.h
index 902770c4..d2fb3f33 100644
--- a/util/include/chre/util/raw_storage.h
+++ b/util/include/chre/util/raw_storage.h
@@ -37,7 +37,7 @@ namespace chre {
 template <typename ElementType, size_t kCapacity>
 class RawStorage : public NonCopyable {
  public:
-  size_t capacity() const {
+  constexpr size_t capacity() const {
     return kCapacity;
   }
 
diff --git a/util/include/chre/util/segmented_queue.h b/util/include/chre/util/segmented_queue.h
index 127e3a6f..38f660f5 100644
--- a/util/include/chre/util/segmented_queue.h
+++ b/util/include/chre/util/segmented_queue.h
@@ -60,14 +60,14 @@ class SegmentedQueue : public NonCopyable {
   /**
    * @return size_t: Number of elements that this segmented queue holds.
    */
-  size_t size() {
+  size_t size() const {
     return mSize;
   }
 
   /**
    * @return size_t: How many blocks does this segmented queue contains.
    */
-  size_t block_count() {
+  size_t block_count() const {
     return mRawStoragePtrs.size();
   }
 
@@ -75,14 +75,14 @@ class SegmentedQueue : public NonCopyable {
    * @return size_t: Number of items that this queue can store without pushing
    * new blocks.
    */
-  size_t capacity() {
+  size_t capacity() const {
     return mRawStoragePtrs.size() * kBlockSize;
   }
 
   /**
    * @return true: Return true if the segmented queue cannot accept new element.
    */
-  bool full() {
+  bool full() const {
     return mSize == kMaxBlockCount * kBlockSize;
   }
 
diff --git a/util/include/chre/util/system/atomic_spsc_queue.h b/util/include/chre/util/system/atomic_spsc_queue.h
index d4c42bdd..18517eca 100644
--- a/util/include/chre/util/system/atomic_spsc_queue.h
+++ b/util/include/chre/util/system/atomic_spsc_queue.h
@@ -78,7 +78,7 @@ class AtomicSpscQueue : public NonCopyable {
     }
   }
 
-  size_t capacity() const {
+  constexpr size_t capacity() const {
     return kCapacity;
   }
 
@@ -123,7 +123,7 @@ class AtomicSpscQueue : public NonCopyable {
    */
   class Producer {
    public:
-    size_t capacity() const {
+    constexpr size_t capacity() const {
       return kCapacity;
     }
     bool full() const {
@@ -208,7 +208,7 @@ class AtomicSpscQueue : public NonCopyable {
    */
   class Consumer {
    public:
-    size_t capacity() const {
+    constexpr size_t capacity() const {
       return kCapacity;
     }
     bool empty() const {
diff --git a/util/include/chre/util/system/callback_allocator.h b/util/include/chre/util/system/callback_allocator.h
new file mode 100644
index 00000000..159a8f80
--- /dev/null
+++ b/util/include/chre/util/system/callback_allocator.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHRE_UTIL_SYSTEM_CALLBACK_ALLOCATOR_H_
+#define CHRE_UTIL_SYSTEM_CALLBACK_ALLOCATOR_H_
+
+#include <cstddef>
+#include <optional>
+
+#include "chre/platform/mutex.h"
+
+#include "pw_allocator/allocator.h"
+#include "pw_allocator/capability.h"
+#include "pw_allocator/unique_ptr.h"
+#include "pw_containers/vector.h"
+#include "pw_function/function.h"
+
+namespace chre {
+
+//! An allocator that keeps track of callbacks.
+//! The allocator will call the callback when the underlying type is
+//! deallocated.
+//! @param Metadata The metadata type for the callback function
+template <typename Metadata>
+class CallbackAllocator : public pw::Allocator {
+ public:
+  static constexpr Capabilities kCapabilities = 0;
+
+  //! The callback called when the underlying type is deallocated
+  using Callback = pw::Function<void(std::byte *message, size_t length,
+                                     Metadata &&metadata)>;
+
+  //! A record of a message and its callback
+  struct CallbackRecord {
+    std::byte *message;
+    Metadata metadata;
+    size_t messageSize;
+  };
+
+  CallbackAllocator(Callback &&callback,
+                    pw::Vector<CallbackRecord> &CallbackRecords,
+                    bool doEraseRecord = true);
+
+  //! @see pw::Allocator::DoAllocate
+  virtual void *DoAllocate(Layout /* layout */) override;
+
+  //! @see pw::Allocator::DoDeallocate
+  virtual void DoDeallocate(void *ptr) override;
+
+  //! Creates a pw::UniquePtr with a callback.
+  //! The callback will be called when the underlying type is deallocated.
+  //! @return A pw::UniquePtr containing data at ptr.
+  [[nodiscard]] pw::UniquePtr<std::byte[]> MakeUniqueArrayWithCallback(
+      std::byte *ptr, size_t size, Metadata &&metadata);
+
+  //! Gets the callback record for a message. Also removes the record from
+  //! the vector.
+  //! @param ptr The message pointer
+  //! @return The callback record for the message, or std::nullopt if not
+  //! found
+  std::optional<CallbackRecord> GetAndRemoveCallbackRecord(void *ptr);
+
+ private:
+  //! The callback called on deallocation
+  Callback mCallback;
+
+  //! The mutex to protect mCallbackRecords
+  Mutex mMutex;
+
+  //! The list of callback records
+  pw::Vector<CallbackRecord> &mCallbackRecords;
+
+  //! Whether to erase the record from the vector after the data is freed
+  const bool mDoEraseRecord;
+};
+
+}  // namespace chre
+
+#include "chre/util/system/callback_allocator_impl.h"
+
+#endif  // CHRE_UTIL_SYSTEM_CALLBACK_ALLOCATOR_H_
diff --git a/util/include/chre/util/system/callback_allocator_impl.h b/util/include/chre/util/system/callback_allocator_impl.h
new file mode 100644
index 00000000..f2ffda00
--- /dev/null
+++ b/util/include/chre/util/system/callback_allocator_impl.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHRE_UTIL_SYSTEM_CALLBACK_ALLOCATOR_IMPL_H_
+#define CHRE_UTIL_SYSTEM_CALLBACK_ALLOCATOR_IMPL_H_
+
+#include <cstddef>
+#include <optional>
+
+#include "chre/util/lock_guard.h"
+#include "chre/util/system/callback_allocator.h"
+
+#include "pw_allocator/allocator.h"
+#include "pw_allocator/capability.h"
+#include "pw_allocator/unique_ptr.h"
+#include "pw_containers/vector.h"
+#include "pw_function/function.h"
+
+namespace chre {
+
+template <typename Metadata>
+CallbackAllocator<Metadata>::CallbackAllocator(
+    Callback &&callback, pw::Vector<CallbackRecord> &callbackRecords,
+    bool doEraseRecord)
+    : pw::Allocator(kCapabilities),
+      mCallback(std::move(callback)),
+      mCallbackRecords(callbackRecords),
+      mDoEraseRecord(doEraseRecord) {}
+
+template <typename Metadata>
+void *CallbackAllocator<Metadata>::DoAllocate(Layout /* layout */) {
+  // Do not allow usage of this allocator without providing a callback
+  // function. This allocator does not manage the memory, only guarantees
+  // that the callback will be called. Use MakeUniqueArrayWithCallback.
+  return nullptr;
+}
+
+template <typename Metadata>
+void CallbackAllocator<Metadata>::DoDeallocate(void *ptr) {
+  std::optional<CallbackRecord> callbackRecord;
+  {
+    LockGuard<Mutex> lock(mMutex);
+    for (CallbackRecord &record : mCallbackRecords) {
+      if (record.message == ptr) {
+        if (mDoEraseRecord) {
+          callbackRecord = std::move(record);
+          mCallbackRecords.erase(&record);
+        } else {
+          callbackRecord = record;
+        }
+        break;
+      }
+    }
+  }
+
+  if (callbackRecord.has_value()) {
+    mCallback(callbackRecord->message, callbackRecord->messageSize,
+              std::move(callbackRecord->metadata));
+  }
+}
+
+template <typename Metadata>
+pw::UniquePtr<std::byte[]>
+CallbackAllocator<Metadata>::MakeUniqueArrayWithCallback(std::byte *ptr,
+                                                         size_t size,
+                                                         Metadata &&metadata) {
+  {
+    LockGuard<Mutex> lock(mMutex);
+    if (mCallbackRecords.full()) {
+      return pw::UniquePtr<std::byte[]>();
+    }
+
+    mCallbackRecords.push_back(
+        {.message = ptr, .metadata = std::move(metadata), .messageSize = size});
+  }
+
+  return WrapUnique<std::byte[]>(ptr, size);
+}
+
+template <typename Metadata>
+std::optional<typename CallbackAllocator<Metadata>::CallbackRecord>
+CallbackAllocator<Metadata>::GetAndRemoveCallbackRecord(void *ptr) {
+  LockGuard<Mutex> lock(mMutex);
+  std::optional<CallbackRecord> foundRecord;
+  for (CallbackRecord &record : mCallbackRecords) {
+    if (record.message == ptr) {
+      foundRecord = std::move(record);
+      mCallbackRecords.erase(&record);
+      break;
+    }
+  }
+  return foundRecord;
+}
+
+}  // namespace chre
+
+#endif  // CHRE_UTIL_SYSTEM_CALLBACK_ALLOCATOR_IMPL_H_
diff --git a/core/include/chre/core/api_manager_common.h b/util/include/chre/util/system/chre_error_util.h
similarity index 87%
rename from core/include/chre/core/api_manager_common.h
rename to util/include/chre/util/system/chre_error_util.h
index ecf7d68a..46c745b0 100644
--- a/core/include/chre/core/api_manager_common.h
+++ b/util/include/chre/util/system/chre_error_util.h
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef CHRE_CORE_API_MANAGER_COMMON_H_
-#define CHRE_CORE_API_MANAGER_COMMON_H_
+#ifndef CHRE_UTIL_SYSTEM_CHRE_ERROR_UTIL_H_
+#define CHRE_UTIL_SYSTEM_CHRE_ERROR_UTIL_H_
 
 #include <cstddef>
 
@@ -31,4 +31,4 @@ static constexpr size_t CHRE_ERROR_SIZE =
 
 }  // namespace chre
 
-#endif  // CHRE_CORE_API_MANAGER_COMMON_H_
+#endif  // CHRE_UTIL_SYSTEM_CHRE_ERROR_UTIL_H_
diff --git a/util/include/chre/util/system/error_util.h b/util/include/chre/util/system/error_util.h
new file mode 100644
index 00000000..6a0a9f8b
--- /dev/null
+++ b/util/include/chre/util/system/error_util.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "chre_api/chre.h"
+
+namespace chre {
+
+/**
+ * Get the CHRE error message string for a given chreError
+ *
+ * @param error CHRE error
+ * @return const char* CHRE error message string
+ */
+const char *getChreErrorMessage(chreError error);
+
+}  // namespace chre
diff --git a/util/include/chre/util/system/intrusive_ref_base.h b/util/include/chre/util/system/intrusive_ref_base.h
new file mode 100644
index 00000000..0107257f
--- /dev/null
+++ b/util/include/chre/util/system/intrusive_ref_base.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHRE_UTIL_SYSTEM_INTRUSIVE_REF_BASE_H_
+#define CHRE_UTIL_SYSTEM_INTRUSIVE_REF_BASE_H_
+
+#include "chre/platform/atomic.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
+
+namespace chre {
+
+//! Base class for any type used with pw::IntrusivePtr that needs to support
+//! reference counting.
+class IntrusiveRefBase {
+ public:
+  //! Increments reference counter.
+  void AddRef() const { mRefCount.fetch_increment(); }
+
+  //! Decrements reference count and returns true if the object should be
+  //! deleted.
+  [[nodiscard]] bool ReleaseRef() const {
+    return mRefCount.fetch_decrement() == 1;
+  }
+
+  //! Reference count
+  [[nodiscard]] int32_t ref_count() const {
+    return static_cast<int32_t>(mRefCount.load());
+  }
+
+ protected:
+  constexpr IntrusiveRefBase() = default;
+  IntrusiveRefBase(const IntrusiveRefBase &) = delete;
+  IntrusiveRefBase &operator=(const IntrusiveRefBase &) = delete;
+  IntrusiveRefBase(IntrusiveRefBase &&) = delete;
+  IntrusiveRefBase &operator=(IntrusiveRefBase &&) = delete;
+  virtual ~IntrusiveRefBase() = default;
+
+ private:
+  template <typename T>
+  friend class pw::IntrusivePtr;
+
+  //! Reference count
+  mutable AtomicUint32 mRefCount{0};
+};
+
+}  // namespace chre
+
+#endif  // CHRE_UTIL_SYSTEM_INTRUSIVE_REF_BASE_H_
diff --git a/util/include/chre/util/system/message_common.h b/util/include/chre/util/system/message_common.h
index f314f32d..a5d1ae97 100644
--- a/util/include/chre/util/system/message_common.h
+++ b/util/include/chre/util/system/message_common.h
@@ -17,8 +17,8 @@
 #ifndef CHRE_UTIL_SYSTEM_MESSAGE_COMMON_H_
 #define CHRE_UTIL_SYSTEM_MESSAGE_COMMON_H_
 
-#include <pw_allocator/unique_ptr.h>
-#include <pw_function/function.h>
+#include "pw_allocator/unique_ptr.h"
+
 #include <cstddef>
 #include <cstdint>
 #include <cstring>
@@ -37,9 +37,15 @@ using SessionId = uint16_t;
 //! An invalid MessageHub ID
 constexpr MessageHubId MESSAGE_HUB_ID_INVALID = 0;
 
+//! A MessageHub ID that matches any MessageHub
+constexpr MessageHubId MESSAGE_HUB_ID_ANY = MESSAGE_HUB_ID_INVALID;
+
 //! An invalid endpoint ID
 constexpr EndpointId ENDPOINT_ID_INVALID = 0;
 
+//! An endpoint ID that matches any endpoint
+constexpr EndpointId ENDPOINT_ID_ANY = ENDPOINT_ID_INVALID;
+
 //! An invalid session ID
 constexpr SessionId SESSION_ID_INVALID = UINT16_MAX;
 
@@ -53,9 +59,7 @@ enum class EndpointType : uint8_t {
 };
 
 //! Endpoint permissions
-//! This should match CHRE permissions.
-// TODO(b/373417024): Update permissions to this typed name in all MessageRouter
-// code
+//! This should match the CHRE_MESSAGE_PERMISSION_* constants.
 enum class EndpointPermission : uint32_t {
   NONE = 0,
   AUDIO = 1,
@@ -65,11 +69,39 @@ enum class EndpointPermission : uint32_t {
   BLE = 1 << 4,
 };
 
+//! The reason for closing a session
+enum class Reason : uint8_t {
+  UNSPECIFIED = 0,
+  OUT_OF_MEMORY,
+  TIMEOUT,
+  OPEN_ENDPOINT_SESSION_REQUEST_REJECTED,
+  CLOSE_ENDPOINT_SESSION_REQUESTED,
+  ENDPOINT_INVALID,
+  ENDPOINT_GONE,
+  ENDPOINT_CRASHED,
+  HUB_RESET,
+  PERMISSION_DENIED,
+};
+
+//! The format of an RPC message sent using a service
+enum class RpcFormat : uint8_t {
+  CUSTOM = 0,
+  AIDL,
+  PW_RPC_PROTOBUF,
+};
+
 //! Represents a single endpoint connected to a MessageHub
 struct Endpoint {
   MessageHubId messageHubId;
   EndpointId endpointId;
 
+  Endpoint()
+      : messageHubId(MESSAGE_HUB_ID_INVALID), endpointId(ENDPOINT_ID_INVALID) {}
+
+  Endpoint(MessageHubId messageHubId, EndpointId endpointId)
+      : messageHubId(messageHubId),
+        endpointId(endpointId) {}
+
   bool operator==(const Endpoint &other) const {
     return messageHubId == other.messageHubId && endpointId == other.endpointId;
   }
@@ -81,22 +113,61 @@ struct Endpoint {
 
 //! Represents a session between two endpoints
 struct Session {
+  static constexpr size_t kMaxServiceDescriptorLength = 127;
+
+  Session()
+      : sessionId(SESSION_ID_INVALID),
+        isActive(false),
+        hasServiceDescriptor(false) {
+    serviceDescriptor[0] = '\0';
+  }
+
+  Session(SessionId sessionId, Endpoint initiator, Endpoint peer,
+          const char *serviceDescriptor)
+      : sessionId(sessionId),
+        isActive(false),
+        hasServiceDescriptor(serviceDescriptor != nullptr),
+        initiator(initiator),
+        peer(peer) {
+    if (serviceDescriptor != nullptr) {
+      std::strncpy(this->serviceDescriptor, serviceDescriptor,
+                   kMaxServiceDescriptorLength);
+    } else {
+      this->serviceDescriptor[0] = '\0';
+    }
+    this->serviceDescriptor[kMaxServiceDescriptorLength] = '\0';
+  }
+
   SessionId sessionId;
+  bool isActive;
+  bool hasServiceDescriptor;
   Endpoint initiator;
   Endpoint peer;
+  char serviceDescriptor[kMaxServiceDescriptorLength + 1];
 
   bool operator==(const Session &other) const {
     return sessionId == other.sessionId && initiator == other.initiator &&
-           peer == other.peer;
+           peer == other.peer && isActive == other.isActive &&
+           hasServiceDescriptor == other.hasServiceDescriptor &&
+           (!hasServiceDescriptor ||
+            std::strncmp(serviceDescriptor, other.serviceDescriptor,
+                         kMaxServiceDescriptorLength) == 0);
   }
 
   bool operator!=(const Session &other) const {
     return !(*this == other);
   }
 
+  //! @return true if the two sessions are equivalent, i.e. they have the same
+  //! endpoints and service descriptor (if present), false otherwise
   bool isEquivalent(const Session &other) const {
-    return (initiator == other.initiator && peer == other.peer) ||
-           (initiator == other.peer && peer == other.initiator);
+    bool sameEndpoints = (initiator == other.initiator && peer == other.peer) ||
+                         (initiator == other.peer && peer == other.initiator);
+    return hasServiceDescriptor == other.hasServiceDescriptor &&
+           sameEndpoints &&
+           (!hasServiceDescriptor ||
+            std::strncmp(serviceDescriptor, other.serviceDescriptor,
+                         kMaxServiceDescriptorLength) == 0);
   }
 };
 
@@ -106,44 +177,41 @@ struct Message {
   Endpoint recipient;
   SessionId sessionId;
   pw::UniquePtr<std::byte[]> data;
-  size_t length;
   uint32_t messageType;
   uint32_t messagePermissions;
 
   Message()
       : sessionId(SESSION_ID_INVALID),
         data(nullptr),
-        length(0),
         messageType(0),
         messagePermissions(0) {}
-  Message(pw::UniquePtr<std::byte[]> &&data, size_t length,
+
+  Message(pw::UniquePtr<std::byte[]> &&data,
           uint32_t messageType, uint32_t messagePermissions, Session session,
           bool sentBySessionInitiator)
       : sender(sentBySessionInitiator ? session.initiator : session.peer),
         recipient(sentBySessionInitiator ? session.peer : session.initiator),
         sessionId(session.sessionId),
         data(std::move(data)),
-        length(length),
         messageType(messageType),
         messagePermissions(messagePermissions) {}
+
+  Message(const Message &) = delete;
+  Message &operator=(const Message &) = delete;
+
   Message(Message &&other)
       : sender(other.sender),
         recipient(other.recipient),
         sessionId(other.sessionId),
         data(std::move(other.data)),
-        length(other.length),
         messageType(other.messageType),
         messagePermissions(other.messagePermissions) {}
 
-  Message(const Message &) = delete;
-  Message &operator=(const Message &) = delete;
-
   Message &operator=(Message &&other) {
     sender = other.sender;
     recipient = other.recipient;
     sessionId = other.sessionId;
     data = std::move(other.data);
-    length = other.length;
     messageType = other.messageType;
     messagePermissions = other.messagePermissions;
     return *this;
@@ -151,7 +219,6 @@ struct Message {
 };
 
 //! Represents information about an endpoint
-//! Service information is stored in ServiceManager
 struct EndpointInfo {
   static constexpr size_t kMaxNameLength = 50;
 
@@ -178,7 +245,7 @@ struct EndpointInfo {
   bool operator==(const EndpointInfo &other) const {
     return id == other.id && version == other.version && type == other.type &&
            requiredPermissions == other.requiredPermissions &&
-           std::strcmp(name, other.name) == 0;
+           std::strncmp(name, other.name, kMaxNameLength) == 0;
   }
 
   bool operator!=(const EndpointInfo &other) const {
@@ -186,13 +253,65 @@ struct EndpointInfo {
   }
 };
 
+//! Represents information about a service provided by an endpoint.
+struct ServiceInfo {
+  ServiceInfo(const char *serviceDescriptor, uint32_t majorVersion,
+              uint32_t minorVersion, RpcFormat format)
+      : serviceDescriptor(serviceDescriptor),
+        majorVersion(majorVersion),
+        minorVersion(minorVersion),
+        format(format) {}
+
+  bool operator==(const ServiceInfo &other) const {
+    if (majorVersion != other.majorVersion ||
+        minorVersion != other.minorVersion || format != other.format) {
+      return false;
+    }
+
+    if ((serviceDescriptor == nullptr) !=
+        (other.serviceDescriptor == nullptr)) {
+      return false;
+    }
+    if (serviceDescriptor != nullptr &&
+        std::strcmp(serviceDescriptor, other.serviceDescriptor) != 0) {
+      return false;
+    }
+    return true;
+  }
+
+  bool operator!=(const ServiceInfo &other) const {
+    return !(*this == other);
+  }
+
+  //! The service descriptor, a null-terminated ASCII string. This must be valid
+  //! only for the lifetime of the service iteration methods in MessageRouter.
+  const char *serviceDescriptor;
+
+  //! Version of the service.
+  uint32_t majorVersion;
+  uint32_t minorVersion;
+
+  //! The format of the RPC messages sent using this service.
+  RpcFormat format;
+};
+
 //! Represents information about a MessageHub
 struct MessageHubInfo {
   MessageHubId id;
   const char *name;
 
   bool operator==(const MessageHubInfo &other) const {
-    return id == other.id && std::strcmp(name, other.name) == 0;
+    if (id != other.id) {
+      return false;
+    }
+
+    if ((name == nullptr) != (other.name == nullptr)) {
+      return false;
+    }
+    if (name != nullptr && std::strcmp(name, other.name) != 0) {
+      return false;
+    }
+    return true;
   }
 
   bool operator!=(const MessageHubInfo &other) const {
diff --git a/util/include/chre/util/system/message_router.h b/util/include/chre/util/system/message_router.h
index 089f149d..09e1d1f4 100644
--- a/util/include/chre/util/system/message_router.h
+++ b/util/include/chre/util/system/message_router.h
@@ -17,17 +17,23 @@
 #ifndef CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_H_
 #define CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_H_
 
-#include <pw_allocator/unique_ptr.h>
-#include <pw_containers/vector.h>
-#include <pw_function/function.h>
-#include <cstddef>
-#include <cstdint>
-#include <optional>
-
 #include "chre/platform/mutex.h"
+#include "chre/util/dynamic_vector.h"
+#include "chre/util/memory.h"
 #include "chre/util/singleton.h"
+#include "chre/util/system/intrusive_ref_base.h"
 #include "chre/util/system/message_common.h"
 
+#include "pw_allocator/unique_ptr.h"
+#include "pw_containers/vector.h"
+#include "pw_function/function.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
+#include "pw_intrusive_ptr/recyclable.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <optional>
+
 namespace chre::message {
 
 //! MessageRouter routes messages between endpoints connected to MessageHubs. It
@@ -49,7 +55,8 @@ namespace chre::message {
 class MessageRouter {
  public:
   //! The callback used to register a MessageHub with the MessageRouter
-  class MessageHubCallback {
+  class MessageHubCallback : public IntrusiveRefBase,
+                             public pw::Recyclable<MessageHubCallback> {
    public:
     virtual ~MessageHubCallback() = default;
 
@@ -63,26 +70,77 @@ class MessageRouter {
     //! initiator of the session
     //! @return true if the message was accepted for processing
     virtual bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
-                                   size_t length, uint32_t messageType,
+                                   uint32_t messageType,
                                    uint32_t messagePermissions,
                                    const Session &session,
                                    bool sentBySessionInitiator) = 0;
 
+    //! Callback called when a session has been requested to be opened. The
+    //! message hub should call onSessionOpenComplete or closeSession to
+    //! accept or reject the session, respectively.
+    //! This function is called before returning from openSession in the
+    //! requestor hub.
+    virtual void onSessionOpenRequest(const Session &session) = 0;
+
+    //! Callback called when the peer message hub has accepted the session
+    //! and the session is now open for messages
+    virtual void onSessionOpened(const Session &session) = 0;
+
     //! Callback called when the session is closed
-    virtual void onSessionClosed(const Session &session) = 0;
+    virtual void onSessionClosed(const Session &session, Reason reason) = 0;
 
     //! Callback called to iterate over all endpoints connected to the
     //! MessageHub. Underlying endpoint storage must not change during this
     //! callback. If function returns true, the MessageHub can stop iterating
-    //! over future endpoints. This function should not call any MessageRouter
-    //! or MessageHub functions.
+    //! over future endpoints.
     virtual void forEachEndpoint(
         const pw::Function<bool(const EndpointInfo &)> &function) = 0;
 
-    //! @return The EndpointInfo for the given endpoint ID. This function should
-    //! not call any MessageRouter or MessageHub functions.
+    //! @return The EndpointInfo for the given endpoint ID.
     virtual std::optional<EndpointInfo> getEndpointInfo(
         EndpointId endpointId) = 0;
+
+    //! @return The first endpoint that has the given service descriptor, a
+    //! null-terminated ASCII string. If no endpoint has the service descriptor,
+    //! std::nullopt is returned.
+    virtual std::optional<EndpointId> getEndpointForService(
+        const char *serviceDescriptor) = 0;
+
+    //! @return true if the endpoint has the given service descriptor, a
+    //! null-terminated ASCII string, false otherwise.
+    virtual bool doesEndpointHaveService(EndpointId endpointId,
+                                         const char *serviceDescriptor) = 0;
+
+    //! Callback called to iterate over all services provided by endpoints
+    //! connected to the MessageHub. Underlying endpoint and service storage
+    //! must not change during this callback. If function returns true, the
+    //! MessageHub can stop iterating over future endpoints. The service
+    //! descriptor must be valid for the duration of the callback.
+    virtual void forEachService(
+        const pw::Function<bool(const EndpointInfo &, const ServiceInfo &)>
+            &function) = 0;
+
+    //! Callback called when a message hub except this one is registered.
+    virtual void onHubRegistered(const MessageHubInfo &info) = 0;
+
+    //! Callback called when a message hub except this one is unregistered.
+    virtual void onHubUnregistered(MessageHubId id) = 0;
+
+    //! Callback called when an endpoint is registered to any MessageHub,
+    //! except for this MessageHub.
+    virtual void onEndpointRegistered(MessageHubId messageHubId,
+                                      EndpointId endpointId) = 0;
+
+    //! Callback called when an endpoint is unregistered from any MessageHub,
+    //! except for this MessageHub.
+    virtual void onEndpointUnregistered(MessageHubId messageHubId,
+                                        EndpointId endpointId) = 0;
+
+    //! Recycle function called by pw::IntrusivePtr when the MessageHubCallback
+    //! is no longer in use. The default behavior in Pigweed is to `delete
+    //! this`. The callbacks derived from this class should also inherit from
+    //! pw::Recyclable and override this function.
+    virtual void pw_recycle() = 0;
   };
 
   //! The API returned when registering a MessageHub with the MessageRouter.
@@ -93,11 +151,6 @@ class MessageRouter {
     //! undefined behavior.
     MessageHub();
 
-    ~MessageHub() {
-      if (mRouter != nullptr) {
-        mRouter->unregisterMessageHub(mHubId);
-      }
-    }
     // There can only be one live MessageHub instance for a given hub ID, so
     // only move operations are supported.
     MessageHub(const MessageHub &) = delete;
@@ -105,17 +158,36 @@ class MessageRouter {
     MessageHub(MessageHub &&other);
     MessageHub &operator=(MessageHub &&other);
 
+    //! Destructor. Unregisters the MessageHub from the MessageRouter.
+    ~MessageHub();
+
+    //! Accepts the session open request from the peer message hub.
+    //! onSessionOpened will be called on both hubs.
+    void onSessionOpenComplete(SessionId sessionId);
+
     //! Opens a session from an endpoint connected to the current MessageHub
-    //! to the listed MessageHub ID and endpoint ID
+    //! to the listed MessageHub ID and endpoint ID, with the given service
+    //! descriptor, a null-terminated ASCII string.
+    //! onSessionOpenRequest will be called to request the session to be
+    //! opened. Once the peer message hub calls onSessionOpenComplete or
+    //! closeSession, onSessionOpened or onSessionClosed will be called,
+    //! depending on the result. If the session ID is provided (not
+    //! SESSION_ID_INVALID), it must be unique and from the reserved session ID
+    //! range. MessageRouter does not guarantee anything about the session ID if
+    //! it is provided in this API. If the session ID is not provided,
+    //! MessageRouter will assign a session ID normally.
     //! @return The session ID or SESSION_ID_INVALID if the session could
     //! not be opened
     SessionId openSession(EndpointId fromEndpointId,
-                          MessageHubId toMessageHubId, EndpointId toEndpointId);
+                          MessageHubId toMessageHubId, EndpointId toEndpointId,
+                          const char *serviceDescriptor = nullptr,
+                          SessionId sessionId = SESSION_ID_INVALID);
 
-    //! Closes the session with sessionId
+    //! Closes the session with sessionId and reason
     //! @return true if the session was closed, false if the session was not
     //! found
-    bool closeSession(SessionId sessionId);
+    bool closeSession(SessionId sessionId,
+                      Reason reason = Reason::CLOSE_ENDPOINT_SESSION_REQUESTED);
 
     //! Returns a session if it exists
     //! @return The session or std::nullopt if the session was not found
@@ -127,20 +199,38 @@ class MessageRouter {
     //! is closed and subsequent calls to this function with the same sessionId
     //! will return false.
     //! @param data The data to send
-    //! @param length The length of the data to send
     //! @param messageType The type of the message, a bit flagged value
     //! @param messagePermissions The permissions of the message, a bit flagged
     //! value
     //! @param sessionId The session to send the message on
+    //! @param fromEndpointId The endpoint ID of the sender or ENDPOINT_ID_ANY
+    //! to allow MessageRouter to infer the sender endpoint ID. If the
+    //! sender endpoint ID cannot be inferred, (i.e. the session is between
+    //! endpoints on the same message hub), this function will return false.
     //! @return true if the message was sent, false if the message could not be
     //! sent
-    bool sendMessage(pw::UniquePtr<std::byte[]> &&data, size_t length,
-                     uint32_t messageType, uint32_t messagePermissions,
-                     SessionId sessionId);
+    bool sendMessage(pw::UniquePtr<std::byte[]> &&data, uint32_t messageType,
+                     uint32_t messagePermissions, SessionId sessionId,
+                     EndpointId fromEndpointId = ENDPOINT_ID_ANY);
+
+    //! Registers an endpoint with the MessageHub.
+    //! @return true if the endpoint was registered, otherwise false.
+    bool registerEndpoint(EndpointId endpointId);
+
+    //! Unregisters an endpoint from the MessageHub.
+    //! @return true if the endpoint was unregistered, otherwise false.
+    bool unregisterEndpoint(EndpointId endpointId);
 
     //! @return The MessageHub ID of the currently connected MessageHub
     MessageHubId getId();
 
+    //! @return If the MessageHub is active and registered with the
+    //! MessageRouter.
+    bool isRegistered();
+
+    //! Unregisters this MessageHub from the MessageRouter.
+    void unregister();
+
    private:
     friend class MessageRouter;
 
@@ -156,13 +246,25 @@ class MessageRouter {
   //! Represents a MessageHub and its connected endpoints
   struct MessageHubRecord {
     MessageHubInfo info;
-    MessageHubCallback *callback;
+    pw::IntrusivePtr<MessageHubCallback> callback;
   };
 
+  //! The default reserved session ID value
+  static constexpr SessionId kDefaultReservedSessionId = 0x8000;
+
   MessageRouter() = delete;
+
+  //! Constructor for the MessageRouter.
+  //! @param messageHubs The list of MessageHubs connected to the MessageRouter
+  //! @param sessions The list of sessions connected to the MessageRouter
+  //! @param reservedSessionId The first reserved session ID - MessageRouter
+  //! will not assign session IDs greater than or equal to this value
   MessageRouter(pw::Vector<MessageHubRecord> &messageHubs,
-                pw::Vector<Session> &sessions)
-      : mMessageHubs(messageHubs), mSessions(sessions) {}
+                pw::Vector<Session> &sessions,
+                SessionId reservedSessionId = kDefaultReservedSessionId)
+      : kReservedSessionId(reservedSessionId),
+        mMessageHubs(messageHubs),
+        mSessions(sessions) {}
 
   //! Registers a MessageHub with the MessageRouter.
   //! The provided name must be unique and not registered before and be a valid
@@ -175,9 +277,9 @@ class MessageRouter {
   //! @param callback The callback to handle messages sent to the MessageHub
   //! @return The MessageHub API or std::nullopt if the MessageHub could not be
   //! registered
-  std::optional<MessageHub> registerMessageHub(const char *name,
-                                               MessageHubId id,
-                                               MessageHubCallback &callback);
+  std::optional<MessageHub> registerMessageHub(
+      const char *name, MessageHubId id,
+      pw::IntrusivePtr<MessageHubCallback> callback);
 
   //! Executes the function for each endpoint connected to this MessageHub.
   //! If function returns true, the iteration will stop.
@@ -187,8 +289,8 @@ class MessageRouter {
       const pw::Function<bool(const EndpointInfo &)> &function);
 
   //! Executes the function for each endpoint connected to all Message Hubs.
-  //! The lock is held when calling the callback.
-  void forEachEndpoint(
+  //! @return true if successful, false otherwise
+  bool forEachEndpoint(
       const pw::Function<void(const MessageHubInfo &, const EndpointInfo &)>
           &function);
 
@@ -196,10 +298,29 @@ class MessageRouter {
   std::optional<EndpointInfo> getEndpointInfo(MessageHubId messageHubId,
                                               EndpointId endpointId);
 
-  //! Executes the function for each MessageHub connected to the MessageRouter.
-  //! If function returns true, the iteration will stop.
-  //! The lock is held when calling the callback.
-  void forEachMessageHub(
+  //! @return The Endpoint for the given service descriptor. If multiple
+  //! endpoints have the same service descriptor, the first one is returned.
+  //! If the message hub ID is MESSAGE_HUB_ID_ANY, all message hubs are
+  //! searched.
+  std::optional<Endpoint> getEndpointForService(MessageHubId messageHubId,
+                                                const char *serviceDescriptor);
+
+  //! @return true if the endpoint has the given service descriptor, a
+  //! null-terminated ASCII string, false otherwise.
+  bool doesEndpointHaveService(MessageHubId messageHubId, EndpointId endpointId,
+                               const char *serviceDescriptor);
+
+  //! Executes the function for each service provided by an endpoint connected
+  //! to this MessageHub. If function returns true, the iteration will stop.
+  //! @return true if successful, false otherwise
+  bool forEachService(
+      const pw::Function<bool(const MessageHubInfo &, const EndpointInfo &,
+                              const ServiceInfo &)> &function);
+
+  //! Executes the function for each MessageHub connected to the
+  //! MessageRouter. If function returns true, the iteration will stop.
+  //! @return true if successful, false if failed
+  bool forEachMessageHub(
       const pw::Function<bool(const MessageHubInfo &)> &function);
 
  private:
@@ -212,18 +333,43 @@ class MessageRouter {
   //! was not found.
   bool unregisterMessageHub(MessageHubId fromMessageHubId);
 
+  //! Accepts the session open request from the peer message hub.
+  //! onSessionOpened will be called on both hubs.
+  void onSessionOpenComplete(MessageHubId fromMessageHubId,
+                             SessionId sessionId);
+
   //! Opens a session from an endpoint connected to the current MessageHub
-  //! to the listed MessageHub ID and endpoint ID
+  //! to the listed MessageHub ID and endpoint ID, with the given service
+  //! descriptor, a null-terminated ASCII string.
+  //! onSessionOpenRequest will be called to request the session to be
+  //! opened. Once the peer message hub calls onSessionOpenComplete or
+  //! closeSession, onSessionOpened or onSessionClosed will be called,
+  //! depending on the result. If the session ID is provided (not
+  //! SESSION_ID_INVALID), it must be unique and from the reserved session ID
+  //! range. MessageRouter does not guarantee anything about the session ID if
+  //! it is provided in this API. If the session ID is not provided,
+  //! MessageRouter will assign a session ID normally.
   //! @return The session ID or SESSION_ID_INVALID if the session could not be
   //! opened
   SessionId openSession(MessageHubId fromMessageHubId,
                         EndpointId fromEndpointId, MessageHubId toMessageHubId,
-                        EndpointId toEndpointId);
+                        EndpointId toEndpointId,
+                        const char *serviceDescriptor = nullptr,
+                        SessionId sessionId = SESSION_ID_INVALID);
 
-  //! Closes the session with sessionId
+  //! Closes the session with sessionId and reason
   //! @return true if the session was closed, false if the session was not
   //! found
-  bool closeSession(MessageHubId fromMessageHubId, SessionId sessionId);
+  bool closeSession(MessageHubId fromMessageHubId, SessionId sessionId,
+                    Reason reason = Reason::CLOSE_ENDPOINT_SESSION_REQUESTED);
+
+  //! Finalizes the session with sessionId and reason. If reason is provided,
+  //! the session will be closed, else the session will be fully opened.
+  //! @return true if the session was finalized, false if the session was not
+  //! found or one of the message hubs were not found or not linked to the
+  //! session.
+  bool finalizeSession(MessageHubId fromMessageHubId, SessionId sessionId,
+                       std::optional<Reason> reason);
 
   //! Returns a session if it exists
   //! @return The session or std::nullopt if the session was not found
@@ -238,9 +384,31 @@ class MessageRouter {
   //! @see MessageHub::sendMessage
   //! @return true if the message was sent, false if the message could not be
   //! sent
-  bool sendMessage(pw::UniquePtr<std::byte[]> &&data, size_t length,
-                   uint32_t messageType, uint32_t messagePermissions,
-                   SessionId sessionId, MessageHubId fromMessageHubId);
+  bool sendMessage(pw::UniquePtr<std::byte[]> &&data, uint32_t messageType,
+                   uint32_t messagePermissions, SessionId sessionId,
+                   EndpointId fromEndpointId, MessageHubId fromMessageHubId);
+
+  //! Registers an endpoint with the MessageHub.
+  //! @return true if the endpoint was registered, otherwise false.
+  bool registerEndpoint(MessageHubId messageHubId, EndpointId endpointId);
+
+  //! Unregisters an endpoint from the MessageHub.
+  //! @return true if the endpoint was unregistered, otherwise false.
+  bool unregisterEndpoint(MessageHubId messageHubId, EndpointId endpointId);
+
+  //! Helper function for registering or unregistering an endpoint with a
+  //! MessageHub.
+  //! @return true if the endpoint was registered or unregistered, otherwise
+  //! false.
+  bool onEndpointRegistrationStateChanged(MessageHubId messageHubId,
+                                          EndpointId endpointId,
+                                          bool isRegistered);
+
+  //! @return The a copy of the list of MessageHubRecords
+  std::optional<DynamicVector<MessageHubRecord>> getMessageHubRecords();
+
+  //! @return A copy of the list of MessageHubRecords while holding mMutex.
+  std::optional<DynamicVector<MessageHubRecord>> getMessageHubRecordsLocked();
 
   //! @return The MessageHubRecord for the given MessageHub ID
   const MessageHubRecord *getMessageHubRecordLocked(MessageHubId messageHubId);
@@ -252,15 +420,23 @@ class MessageRouter {
 
   //! @return The callback for the given MessageHub ID or nullptr if not found
   //! Requires the caller to hold the mutex
-  MessageHubCallback *getCallbackFromMessageHubId(MessageHubId messageHubId);
+  pw::IntrusivePtr<MessageHubCallback> getCallbackFromMessageHubId(
+      MessageHubId messageHubId);
 
   //! @return The callback for the given MessageHub ID or nullptr if not found
-  MessageHubCallback *getCallbackFromMessageHubIdLocked(
+  pw::IntrusivePtr<MessageHubCallback> getCallbackFromMessageHubIdLocked(
       MessageHubId messageHubId);
 
   //! @return true if the endpoint exists in the MessageHub with the given
   //! callback
-  bool checkIfEndpointExists(MessageHubCallback *callback, EndpointId endpointId);
+  bool checkIfEndpointExists(
+      const pw::IntrusivePtr<MessageHubCallback> &callback,
+      EndpointId endpointId);
+
+  //! @return The next available Session ID. Will wrap around if needed and
+  //! ensures the returned ID is not in the reserved range nor is it already in
+  //! use. Requires the caller to hold the mutex.
+  SessionId getNextSessionIdLocked();
 
   //! The mutex to protect MessageRouter state
   Mutex mMutex;
@@ -268,6 +444,9 @@ class MessageRouter {
   //! The next available Session ID
   SessionId mNextSessionId = 0;
 
+  //! The start of the reserved session ID range
+  const SessionId kReservedSessionId;
+
   //! The list of MessageHubs connected to the MessageRouter
   pw::Vector<MessageHubRecord> &mMessageHubs;
 
@@ -282,8 +461,9 @@ typedef Singleton<MessageRouter> MessageRouterSingleton;
 template <size_t kMaxMessageHubs, size_t kMaxSessions>
 class MessageRouterWithStorage : public MessageRouter {
  public:
-  MessageRouterWithStorage():
-      MessageRouter(mMessageHubs, mSessions) {}
+  MessageRouterWithStorage(
+      SessionId reservedSessionId = MessageRouter::kDefaultReservedSessionId)
+      : MessageRouter(mMessageHubs, mSessions, reservedSessionId) {}
 
  private:
   //! The list of MessageHubs connected to the MessageRouter
diff --git a/util/include/chre/util/system/message_router_callback_allocator.h b/util/include/chre/util/system/message_router_callback_allocator.h
deleted file mode 100644
index e3aabd84..00000000
--- a/util/include/chre/util/system/message_router_callback_allocator.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_CALLBACK_ALLOCATOR_H_
-#define CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_CALLBACK_ALLOCATOR_H_
-
-#include <pw_allocator/allocator.h>
-#include <pw_allocator/capability.h>
-#include <pw_allocator/unique_ptr.h>
-#include <pw_containers/vector.h>
-#include <pw_function/function.h>
-#include <cstddef>
-#include <optional>
-
-#include "chre/platform/mutex.h"
-
-namespace chre::message {
-
-//! An allocator for message free callbacks
-//! This allocator is used to store message free callbacks in a vector
-//! The allocator will call the free callback when the message is deallocated
-//! This is used to create pw::UniquePtrs for messages that have a free
-//! callback.
-//! @param Metadata The metadata type for the callback function
-template <typename Metadata>
-class MessageRouterCallbackAllocator : public pw::Allocator {
- public:
-  static constexpr Capabilities kCapabilities = 0;
-
-  //! The callback used to free a message
-  using MessageFreeCallback = pw::Function<void(
-      std::byte *message, size_t length, const Metadata &metadata)>;
-
-  //! A record of a message and its free callback
-  struct FreeCallbackRecord {
-    std::byte *message;
-    Metadata metadata;
-    size_t messageSize;
-  };
-
-  MessageRouterCallbackAllocator(
-      MessageFreeCallback &&callback,
-      pw::Vector<FreeCallbackRecord> &freeCallbackRecords);
-
-  //! @see pw::Allocator::DoAllocate
-  virtual void *DoAllocate(Layout /* layout */) override;
-
-  //! @see pw::Allocator::DoDeallocate
-  virtual void DoDeallocate(void *ptr) override;
-
-  //! Creates a pw::UniquePtr for a message with a free callback.
-  //! The free callback will be called when the message is deallocated.
-  //! @return A pw::UniquePtr containing the message
-  [[nodiscard]] pw::UniquePtr<std::byte[]> MakeUniqueArrayWithCallback(
-      std::byte *ptr, size_t size, Metadata &&metadata);
-
- private:
-  //! The callback used to free a message
-  MessageFreeCallback mCallback;
-
-  //! The mutex to protect mFreeCallbackRecords
-  Mutex mMutex;
-
-  //! The map of message pointers to free callbacks
-  pw::Vector<FreeCallbackRecord> &mFreeCallbackRecords;
-};
-
-}  // namespace chre::message
-
-#include "chre/util/system/message_router_callback_allocator_impl.h"
-
-#endif  // CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_CALLBACK_ALLOCATOR_H_
diff --git a/util/include/chre/util/system/message_router_callback_allocator_impl.h b/util/include/chre/util/system/message_router_callback_allocator_impl.h
deleted file mode 100644
index fc27e905..00000000
--- a/util/include/chre/util/system/message_router_callback_allocator_impl.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_CALLBACK_ALLOCATOR_IMPL_H_
-#define CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_CALLBACK_ALLOCATOR_IMPL_H_
-
-#include <pw_allocator/allocator.h>
-#include <pw_allocator/capability.h>
-#include <pw_allocator/unique_ptr.h>
-#include <pw_containers/vector.h>
-#include <pw_function/function.h>
-#include <cstddef>
-#include <optional>
-
-#include "chre/util/lock_guard.h"
-#include "chre/util/system/message_common.h"
-#include "chre/util/system/message_router_callback_allocator.h"
-
-namespace chre::message {
-
-template <typename Metadata>
-MessageRouterCallbackAllocator<Metadata>::MessageRouterCallbackAllocator(
-    MessageFreeCallback &&callback,
-    pw::Vector<FreeCallbackRecord> &freeCallbackRecords)
-        : pw::Allocator(kCapabilities),
-          mCallback(std::move(callback)),
-          mFreeCallbackRecords(freeCallbackRecords) {}
-
-template <typename Metadata>
-void *MessageRouterCallbackAllocator<Metadata>::DoAllocate(
-    Layout /* layout */) {
-  return nullptr;
-}
-
-template <typename Metadata>
-void MessageRouterCallbackAllocator<Metadata>::DoDeallocate(void *ptr) {
-  std::optional<FreeCallbackRecord> freeCallbackRecord;
-  {
-    LockGuard<Mutex> lock(mMutex);
-    for (FreeCallbackRecord &record : mFreeCallbackRecords) {
-      if (record.message == ptr) {
-        freeCallbackRecord = std::move(record);
-        mFreeCallbackRecords.erase(&record);
-        break;
-      }
-    }
-  }
-
-  if (freeCallbackRecord.has_value()) {
-    mCallback(freeCallbackRecord->message, freeCallbackRecord->messageSize,
-              freeCallbackRecord->metadata);
-  }
-}
-
-template <typename Metadata>
-pw::UniquePtr<std::byte[]>
-MessageRouterCallbackAllocator<Metadata>::MakeUniqueArrayWithCallback(
-    std::byte *ptr, size_t size, Metadata &&metadata) {
-  {
-    LockGuard<Mutex> lock(mMutex);
-    if (mFreeCallbackRecords.full()) {
-      return pw::UniquePtr<std::byte[]>();
-    }
-
-    mFreeCallbackRecords.push_back(
-        {.message = ptr, .metadata = std::move(metadata), .messageSize = size});
-  }
-
-  return WrapUniqueArray(ptr, size);
-}
-
-}  // namespace chre::message
-
-#endif  // CHRE_UTIL_SYSTEM_MESSAGE_ROUTER_CALLBACK_ALLOCATOR_IMPL_H_
diff --git a/util/include/chre/util/system/message_router_mocks.h b/util/include/chre/util/system/message_router_mocks.h
new file mode 100644
index 00000000..247efd73
--- /dev/null
+++ b/util/include/chre/util/system/message_router_mocks.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "gmock/gmock.h"
+
+#include "chre/util/system/message_common.h"
+#include "chre/util/system/message_router.h"
+
+#include "pw_allocator/unique_ptr.h"
+#include "pw_function/function.h"
+
+namespace chre::message {
+
+class MockMessageHubCallback : public MessageRouter::MessageHubCallback {
+ public:
+  MOCK_METHOD(bool, onMessageReceived,
+              (pw::UniquePtr<std::byte[]> && data, uint32_t messageType,
+               uint32_t messagePermissions, const Session &session,
+               bool sentBySessionInitiator),
+              (override));
+  MOCK_METHOD(void, onSessionOpenRequest, (const Session &session), (override));
+  MOCK_METHOD(void, onSessionOpened, (const Session &session), (override));
+  MOCK_METHOD(void, onSessionClosed, (const Session &session, Reason reason),
+              (override));
+  MOCK_METHOD(void, forEachEndpoint,
+              (const pw::Function<bool(const EndpointInfo &)> &function),
+              (override));
+  MOCK_METHOD(std::optional<EndpointInfo>, getEndpointInfo,
+              (EndpointId endpointId), (override));
+  MOCK_METHOD(std::optional<EndpointId>, getEndpointForService,
+              (const char *serviceDescriptor), (override));
+  MOCK_METHOD(bool, doesEndpointHaveService,
+              (EndpointId endpointId, const char *serviceDescriptor),
+              (override));
+  MOCK_METHOD(
+      void, forEachService,
+      (const pw::Function<bool(const EndpointInfo &,
+                               const message::ServiceInfo &)> &function),
+      (override));
+  MOCK_METHOD(void, onHubRegistered, (const MessageHubInfo &), (override));
+  MOCK_METHOD(void, onHubUnregistered, (MessageHubId), (override));
+  MOCK_METHOD(void, onEndpointRegistered,
+              (MessageHubId messageHubId, EndpointId endpointId), (override));
+  MOCK_METHOD(void, onEndpointUnregistered,
+              (MessageHubId messageHubId, EndpointId endpointId), (override));
+
+  void pw_recycle() override {
+    delete this;
+  }
+};
+
+}  // namespace chre::message
diff --git a/util/include/chre/util/system/service_helpers.h b/util/include/chre/util/system/service_helpers.h
new file mode 100644
index 00000000..f818fd58
--- /dev/null
+++ b/util/include/chre/util/system/service_helpers.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CHRE_UTIL_SYSTEM_SERVICE_HELPERS_H_
+#define CHRE_UTIL_SYSTEM_SERVICE_HELPERS_H_
+
+#include <cstdint>
+
+namespace chre::message {
+
+//! Finds the nanoapp ID and service ID for the given service descriptor if
+//! the service descriptor is in the legacy service descriptor format.
+//! @see chrePublishRpcServices for the legacy service format
+//! @return true if the nanoapp ID and service ID were found and populated,
+//! false otherwise
+bool extractNanoappIdAndServiceId(const char *serviceDescriptor,
+                                  uint64_t &nanoappId, uint64_t &serviceId);
+
+}  // namespace chre::message
+
+#endif  // CHRE_UTIL_SYSTEM_SERVICE_HELPERS_H_
diff --git a/core/include/chre/core/event_loop_common.h b/util/include/chre/util/system/system_callback_type.h
similarity index 87%
rename from core/include/chre/core/event_loop_common.h
rename to util/include/chre/util/system/system_callback_type.h
index ea2203d0..a7fb9e51 100644
--- a/core/include/chre/core/event_loop_common.h
+++ b/util/include/chre/util/system/system_callback_type.h
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef CHRE_CORE_EVENT_LOOP_COMMON_H_
-#define CHRE_CORE_EVENT_LOOP_COMMON_H_
+#ifndef CHRE_UTIL_SYSTEM_SYSTEM_CALLBACK_TYPE_H_
+#define CHRE_UTIL_SYSTEM_SYSTEM_CALLBACK_TYPE_H_
 
 #include "chre_api/chre/event.h"
 
@@ -77,7 +77,13 @@ enum class SystemCallbackType : uint16_t {
   TimerPoolTimerExpired,
   TransactionManagerTimeout,
   EndpointMessageToNanoappEvent,
-  EndpointSessionClosedEvent,
+  EndpointSessionStateChangedEvent,
+  EndpointMessageFreeEvent,
+  EndpointRegisteredEvent,
+  BleSocketConnected,
+  EndpointCleanupNanoappEvent,
+  EndpointSessionRequestedEvent,
+  CycleNanoappWakeupBucket,
 };
 
 //! Deferred/delayed callbacks use the event subsystem but are invariably sent
@@ -89,4 +95,4 @@ using SystemEventCallbackFunction = void(uint16_t type, void *data,
 
 }  // namespace chre
 
-#endif  // CHRE_CORE_EVENT_LOOP_COMMON_H_
+#endif  // CHRE_UTIL_SYSTEM_SYSTEM_CALLBACK_TYPE_H_
diff --git a/util/include/chre/util/system/transaction_manager_impl.h b/util/include/chre/util/system/transaction_manager_impl.h
index 4d689b31..9dca43d9 100644
--- a/util/include/chre/util/system/transaction_manager_impl.h
+++ b/util/include/chre/util/system/transaction_manager_impl.h
@@ -20,9 +20,9 @@
 // IWYU pragma: private
 #include "chre/util/system/transaction_manager.h"
 
-#include "chre/core/event_loop_common.h"
 #include "chre/platform/system_time.h"
 #include "chre/util/hash.h"
+#include "chre/util/system/system_callback_type.h"
 
 namespace chre {
 
diff --git a/util/pigweed/rpc_helper.cc b/util/pigweed/rpc_helper.cc
index d833cf8f..9b3bb4ef 100644
--- a/util/pigweed/rpc_helper.cc
+++ b/util/pigweed/rpc_helper.cc
@@ -26,9 +26,19 @@
 
 namespace chre {
 
+namespace {
+bool inline isRpcChannelIdHost(uint32_t id) {
+  return id >> 16 == 1;
+}
+
+bool inline isRpcChannelIdNanoapp(uint32_t id) {
+  return id >> 16 == 0;
+}
+}  // namespace
+
 bool rpcEndpointsMatch(uint32_t expectedId, uint32_t actualId) {
   if ((expectedId & kRpcClientIdMask) != (actualId & kRpcClientIdMask)) {
-    LOGE("Invalid endpoint 0x%04" PRIx32 " expected 0x%04" PRIx32, actualId,
+    LOGE("Invalid endpoint 0x%04" PRIx32 ", expected 0x%04" PRIx32, actualId,
          expectedId);
     return false;
   }
@@ -36,21 +46,14 @@ bool rpcEndpointsMatch(uint32_t expectedId, uint32_t actualId) {
   return true;
 }
 
-bool isRpcChannelIdHost(uint32_t id) {
-  return id >> 16 == 1;
-}
-
-bool isRpcChannelIdNanoapp(uint32_t id) {
-  return id >> 16 == 0;
-}
-
 bool validateHostChannelId(const chreMessageFromHostData *msg,
                            uint32_t channelId) {
-  struct chreHostEndpointInfo info;
+  struct chreHostEndpointInfo info {};
 
   if (!isRpcChannelIdHost(channelId) ||
       !chreGetHostEndpointInfo(msg->hostEndpoint, &info)) {
-    LOGE("Invalid channelId for a host client 0x%08" PRIx32, channelId);
+    LOGE("Invalid channelId 0x%" PRIx32 "for host endpoint %" PRIu16, channelId,
+         msg->hostEndpoint);
     return false;
   }
 
diff --git a/util/system/error_util.cc b/util/system/error_util.cc
new file mode 100644
index 00000000..fa8a89c1
--- /dev/null
+++ b/util/system/error_util.cc
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "chre/util/system/error_util.h"
+
+#include "chre/util/system/chre_error_util.h"
+
+namespace chre {
+
+const char *getChreErrorMessage(chreError error) {
+  switch (error) {
+    case CHRE_ERROR_NONE:
+      return "CHRE_ERROR_NONE";
+    case CHRE_ERROR:
+      return "CHRE_ERROR";
+    case CHRE_ERROR_INVALID_ARGUMENT:
+      return "CHRE_ERROR_INVALID_ARGUMENT";
+    case CHRE_ERROR_BUSY:
+      return "CHRE_ERROR_BUSY";
+    case CHRE_ERROR_NO_MEMORY:
+      return "CHRE_ERROR_NO_MEMORY";
+    case CHRE_ERROR_NOT_SUPPORTED:
+      return "CHRE_ERROR_NOT_SUPPORTED";
+    case CHRE_ERROR_TIMEOUT:
+      return "CHRE_ERROR_TIMEOUT";
+    case CHRE_ERROR_FUNCTION_DISABLED:
+      return "CHRE_ERROR_FUNCTION_DISABLED";
+    case CHRE_ERROR_REJECTED_RATE_LIMIT:
+      return "CHRE_ERROR_REJECTED_RATE_LIMIT";
+    case CHRE_ERROR_FUNCTION_RESTRICTED_TO_OTHER_CLIENT:
+      return "CHRE_ERROR_FUNCTION_RESTRICTED";
+    case CHRE_ERROR_OBSOLETE_REQUEST:
+      return "CHRE_ERROR_OBSOLETE_REQUEST";
+    case CHRE_ERROR_TRANSIENT:
+      return "CHRE_ERROR_TRANSIENT";
+    case CHRE_ERROR_PERMISSION_DENIED:
+      return "CHRE_ERROR_PERMISSION_DENIED";
+    case CHRE_ERROR_DESTINATION_NOT_FOUND:
+      return "CHRE_ERROR_DESTINATION_NOT_FOUND";
+      // If this assertion is hit, it is because a new CHRE error code was added
+      // and is not yet supported in this function. Add the new error code to
+      // this function and update this assertion to use the latest error code.
+      static_assert(CHRE_ERROR_SIZE == CHRE_ERROR_DESTINATION_NOT_FOUND + 1);
+    default:
+      return "CHRE_ERROR_UNKNOWN";
+  }
+}
+
+}  // namespace chre
diff --git a/util/system/message_router.cc b/util/system/message_router.cc
index 35828897..f26f2b39 100644
--- a/util/system/message_router.cc
+++ b/util/system/message_router.cc
@@ -14,17 +14,16 @@
  * limitations under the License.
  */
 
+#include "chre/util/system/message_router.h"
+#include "chre/util/dynamic_vector.h"
+#include "chre/util/lock_guard.h"
+#include "chre/util/system/message_common.h"
+
 #include <inttypes.h>
 #include <cstring>
 #include <optional>
 #include <utility>
 
-#include "chre/platform/log.h"
-#include "chre/util/dynamic_vector.h"
-#include "chre/util/lock_guard.h"
-#include "chre/util/system/message_common.h"
-#include "chre/util/system/message_router.h"
-
 namespace chre::message {
 
 MessageRouter::MessageHub::MessageHub()
@@ -41,6 +40,7 @@ MessageRouter::MessageHub::MessageHub(MessageHub &&other)
 
 MessageRouter::MessageHub &MessageRouter::MessageHub::operator=(
     MessageHub &&other) {
+  unregister();
   mRouter = other.mRouter;
   mHubId = other.mHubId;
   other.mRouter = nullptr;
@@ -48,17 +48,30 @@ MessageRouter::MessageHub &MessageRouter::MessageHub::operator=(
   return *this;
 }
 
+MessageRouter::MessageHub::~MessageHub() {
+  unregister();
+}
+
+void MessageRouter::MessageHub::onSessionOpenComplete(SessionId sessionId) {
+  if (mRouter != nullptr) {
+    mRouter->onSessionOpenComplete(mHubId, sessionId);
+  }
+}
+
 SessionId MessageRouter::MessageHub::openSession(EndpointId fromEndpointId,
                                                  MessageHubId toMessageHubId,
-                                                 EndpointId toEndpointId) {
+                                                 EndpointId toEndpointId,
+                                                 const char *serviceDescriptor,
+                                                 SessionId sessionId) {
   return mRouter == nullptr
              ? SESSION_ID_INVALID
              : mRouter->openSession(mHubId, fromEndpointId, toMessageHubId,
-                                    toEndpointId);
+                                    toEndpointId, serviceDescriptor, sessionId);
 }
 
-bool MessageRouter::MessageHub::closeSession(SessionId sessionId) {
-  return mRouter == nullptr ? false : mRouter->closeSession(mHubId, sessionId);
+bool MessageRouter::MessageHub::closeSession(SessionId sessionId,
+                                             Reason reason) {
+  return mRouter != nullptr && mRouter->closeSession(mHubId, sessionId, reason);
 }
 
 std::optional<Session> MessageRouter::MessageHub::getSessionWithId(
@@ -68,58 +81,95 @@ std::optional<Session> MessageRouter::MessageHub::getSessionWithId(
 }
 
 bool MessageRouter::MessageHub::sendMessage(pw::UniquePtr<std::byte[]> &&data,
-                                            size_t length, uint32_t messageType,
+                                            uint32_t messageType,
                                             uint32_t messagePermissions,
-                                            SessionId sessionId) {
-  return mRouter == nullptr
-             ? false
-             : mRouter->sendMessage(std::move(data), length, messageType,
-                                    messagePermissions, sessionId, mHubId);
+                                            SessionId sessionId,
+                                            EndpointId fromEndpointId) {
+  return mRouter != nullptr &&
+         mRouter->sendMessage(std::move(data), messageType, messagePermissions,
+                              sessionId, fromEndpointId, mHubId);
+}
+
+bool MessageRouter::MessageHub::registerEndpoint(EndpointId endpointId) {
+  return mRouter != nullptr && mRouter->registerEndpoint(mHubId, endpointId);
+}
+
+bool MessageRouter::MessageHub::unregisterEndpoint(EndpointId endpointId) {
+  return mRouter != nullptr && mRouter->unregisterEndpoint(mHubId, endpointId);
 }
 
 MessageHubId MessageRouter::MessageHub::getId() {
   return mHubId;
 }
 
+bool MessageRouter::MessageHub::isRegistered() {
+  return mRouter != nullptr;
+}
+
+void MessageRouter::MessageHub::unregister() {
+  if (mRouter != nullptr) {
+    mRouter->unregisterMessageHub(mHubId);
+  }
+  mRouter = nullptr;
+}
+
 std::optional<typename MessageRouter::MessageHub>
 MessageRouter::registerMessageHub(
     const char *name, MessageHubId id,
-    MessageRouter::MessageRouter::MessageHubCallback &callback) {
-  LockGuard<Mutex> lock(mMutex);
-  if (mMessageHubs.full()) {
-    LOGE(
-        "Message hub '%s' not registered: maximum number of message hubs "
-        "reached",
-        name);
-    return std::nullopt;
-  }
-
-  for (MessageHubRecord &messageHub : mMessageHubs) {
-    if (std::strcmp(messageHub.info.name, name) == 0 ||
-        messageHub.info.id == id) {
+    pw::IntrusivePtr<MessageRouter::MessageHubCallback> callback) {
+  DynamicVector<MessageHubRecord> hubsToNotify;
+  std::optional<MessageHub> newHub;
+  MessageHubInfo newHubInfo;
+  {
+    LockGuard<Mutex> lock(mMutex);
+    if (mMessageHubs.full()) {
       LOGE(
-          "Message hub '%s' not registered: hub with same name or ID already "
-          "exists",
+          "Message hub '%s' not registered: maximum number of message hubs "
+          "reached",
           name);
       return std::nullopt;
     }
+
+    for (MessageHubRecord &messageHub : mMessageHubs) {
+      if (std::strcmp(messageHub.info.name, name) == 0 ||
+          messageHub.info.id == id) {
+        LOGE(
+            "Message hub '%s' not registered: hub with same name or ID already "
+            "exists",
+            name);
+        return std::nullopt;
+      }
+    }
+
+    if (auto hubRecords = getMessageHubRecordsLocked(); hubRecords) {
+      hubsToNotify = std::move(*hubRecords);
+    } else {
+      return std::nullopt;
+    }
+
+    MessageHubRecord messageHubRecord = {
+        .info = {.id = id, .name = name},
+        .callback = std::move(callback),
+    };
+    newHubInfo = messageHubRecord.info;
+    mMessageHubs.push_back(std::move(messageHubRecord));
+    newHub = MessageHub(*this, id);
   }
 
-  MessageHubRecord messageHubRecord = {
-      .info = {.id = id, .name = name},
-      .callback = &callback,
-  };
-  mMessageHubs.push_back(std::move(messageHubRecord));
-  return MessageHub(*this, id);
+  // NOTE: newHubInfo is guaranteed to be valid while we have newHub.
+  for (const auto &hubRecord : hubsToNotify) {
+    hubRecord.callback->onHubRegistered(newHubInfo);
+  }
+  return newHub;
 }
 
 bool MessageRouter::forEachEndpointOfHub(
     MessageHubId messageHubId,
     const pw::Function<bool(const EndpointInfo &)> &function) {
-  MessageRouter::MessageHubCallback *callback =
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> callback =
       getCallbackFromMessageHubId(messageHubId);
   if (callback == nullptr) {
-    LOGE("Failed to find message hub with ID %" PRIu64, messageHubId);
+    LOGE("Failed to find message hub with ID 0x%" PRIx64, messageHubId);
     return false;
   }
 
@@ -127,16 +177,20 @@ bool MessageRouter::forEachEndpointOfHub(
   return true;
 }
 
-void MessageRouter::forEachEndpoint(
+bool MessageRouter::forEachEndpoint(
     const pw::Function<void(const MessageHubInfo &, const EndpointInfo &)>
         &function) {
-  LockGuard<Mutex> lock(mMutex);
+  std::optional<DynamicVector<MessageHubRecord>> messageHubRecords =
+      getMessageHubRecords();
+  if (!messageHubRecords.has_value()) {
+    return false;
+  }
 
   struct Context {
     decltype(function) function;
-    MessageHubInfo &messageHubInfo;
+    const MessageHubInfo &messageHubInfo;
   };
-  for (MessageHubRecord &messageHubRecord : mMessageHubs) {
+  for (const MessageHubRecord &messageHubRecord : *messageHubRecords) {
     Context context = {
         .function = function,
         .messageHubInfo = messageHubRecord.info,
@@ -148,15 +202,16 @@ void MessageRouter::forEachEndpoint(
           return false;
         });
   }
+  return true;
 }
 
 std::optional<EndpointInfo> MessageRouter::getEndpointInfo(
     MessageHubId messageHubId, EndpointId endpointId) {
-  MessageRouter::MessageHubCallback *callback =
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> callback =
       getCallbackFromMessageHubId(messageHubId);
   if (callback == nullptr) {
-    LOGE("Failed to get endpoint info for message hub with ID %" PRIu64
-         " and endpoint ID %" PRIu64 ": hub not found",
+    LOGE("Failed to get endpoint info for message hub with ID 0x%" PRIx64
+         " and endpoint ID 0x%" PRIx64 ": hub not found",
          messageHubId, endpointId);
     return std::nullopt;
   }
@@ -164,26 +219,122 @@ std::optional<EndpointInfo> MessageRouter::getEndpointInfo(
   return callback->getEndpointInfo(endpointId);
 }
 
-void MessageRouter::forEachMessageHub(
+std::optional<Endpoint> MessageRouter::getEndpointForService(
+    MessageHubId messageHubId, const char *serviceDescriptor) {
+  if (serviceDescriptor == nullptr) {
+    LOGE("Failed to get endpoint for service: service descriptor is null");
+    return std::nullopt;
+  }
+
+  std::optional<DynamicVector<MessageHubRecord>> messageHubRecords =
+      getMessageHubRecords();
+  if (!messageHubRecords.has_value()) {
+    return std::nullopt;
+  }
+
+  for (const MessageHubRecord &messageHubRecord : *messageHubRecords) {
+    if ((messageHubId == MESSAGE_HUB_ID_ANY ||
+         messageHubId == messageHubRecord.info.id) &&
+        messageHubRecord.callback != nullptr) {
+      std::optional<EndpointId> endpointId =
+          messageHubRecord.callback->getEndpointForService(serviceDescriptor);
+      if (endpointId.has_value()) {
+        return Endpoint(messageHubRecord.info.id, *endpointId);
+      }
+
+      // Only searching this message hub, so return early if not found
+      if (messageHubId != MESSAGE_HUB_ID_ANY) {
+        return std::nullopt;
+      }
+    }
+  }
+  return std::nullopt;
+}
+
+bool MessageRouter::doesEndpointHaveService(MessageHubId messageHubId,
+                                            EndpointId endpointId,
+                                            const char *serviceDescriptor) {
+  if (serviceDescriptor == nullptr) {
+    LOGE("Failed to check if endpoint has service: service descriptor is null");
+    return false;
+  }
+
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> callback =
+      getCallbackFromMessageHubId(messageHubId);
+  if (callback == nullptr) {
+    LOGE(
+        "Failed to check if endpoint has service for message hub with ID "
+        "0x%" PRIx64 " and endpoint ID 0x%" PRIx64 ": hub not found",
+        messageHubId, endpointId);
+    return false;
+  }
+  return callback->doesEndpointHaveService(endpointId, serviceDescriptor);
+}
+
+bool MessageRouter::forEachService(
+    const pw::Function<bool(const MessageHubInfo &, const EndpointInfo &,
+                            const ServiceInfo &)> &function) {
+  std::optional<DynamicVector<MessageHubRecord>> messageHubRecords =
+      getMessageHubRecords();
+  if (!messageHubRecords.has_value()) {
+    return false;
+  }
+
+  struct Context {
+    decltype(function) &function;
+    const MessageHubInfo *messageHubInfo;
+  };
+  Context context = {
+      .function = function,
+      .messageHubInfo = nullptr,
+  };
+  for (const MessageHubRecord &messageHubRecord : *messageHubRecords) {
+    context.messageHubInfo = &messageHubRecord.info;
+    messageHubRecord.callback->forEachService(
+        [&context](const EndpointInfo &endpointInfo,
+                   const ServiceInfo &serviceInfo) {
+          return context.function(*context.messageHubInfo, endpointInfo,
+                                  serviceInfo);
+        });
+  }
+  return true;
+}
+
+bool MessageRouter::forEachMessageHub(
     const pw::Function<bool(const MessageHubInfo &)> &function) {
-  LockGuard<Mutex> lock(mMutex);
-  for (MessageHubRecord &messageHubRecord : mMessageHubs) {
+  std::optional<DynamicVector<MessageHubRecord>> messageHubRecords =
+      getMessageHubRecords();
+  if (!messageHubRecords.has_value()) {
+    return false;
+  }
+
+  for (const MessageHubRecord &messageHubRecord : *messageHubRecords) {
     function(messageHubRecord.info);
   }
+  return true;
 }
 
 bool MessageRouter::unregisterMessageHub(MessageHubId fromMessageHubId) {
-  DynamicVector<std::pair<MessageHubCallback *, Session>> sessionsToDestroy;
+  DynamicVector<std::pair<pw::IntrusivePtr<MessageHubCallback>, Session>>
+      sessionsToDestroy;
+  DynamicVector<pw::IntrusivePtr<MessageHubCallback>> hubsToNotify;
 
   {
     LockGuard<Mutex> lock(mMutex);
 
+    if (!mMessageHubs.empty() &&
+        !hubsToNotify.reserve(mMessageHubs.size() - 1)) {
+      LOG_OOM();
+      return false;
+    }
+
     bool success = false;
     for (MessageHubRecord &messageHubRecord : mMessageHubs) {
       if (messageHubRecord.info.id == fromMessageHubId) {
         mMessageHubs.erase(&messageHubRecord);
         success = true;
-        break;
+      } else {
+        hubsToNotify.push_back(messageHubRecord.callback);
       }
     }
     if (!success) {
@@ -197,9 +348,10 @@ bool MessageRouter::unregisterMessageHub(MessageHubId fromMessageHubId) {
       bool peerIsFromHub = session.peer.messageHubId == fromMessageHubId;
 
       if (initiatorIsFromHub || peerIsFromHub) {
-        MessageHubCallback *callback = getCallbackFromMessageHubIdLocked(
-            initiatorIsFromHub ? session.peer.messageHubId
-                               : session.initiator.messageHubId);
+        pw::IntrusivePtr<MessageRouter::MessageHubCallback> callback =
+            getCallbackFromMessageHubIdLocked(
+                initiatorIsFromHub ? session.peer.messageHubId
+                                   : session.initiator.messageHubId);
         sessionsToDestroy.push_back(std::make_pair(callback, session));
         mSessions.erase(&mSessions[i]);
       } else {
@@ -210,46 +362,70 @@ bool MessageRouter::unregisterMessageHub(MessageHubId fromMessageHubId) {
 
   for (auto [callback, session] : sessionsToDestroy) {
     if (callback != nullptr) {
-      callback->onSessionClosed(session);
+      callback->onSessionClosed(session, Reason::HUB_RESET);
+    }
+  }
+  for (auto callback : hubsToNotify) {
+    if (callback != nullptr) {
+      callback->onHubUnregistered(fromMessageHubId);
     }
   }
   return true;
 }
 
+void MessageRouter::onSessionOpenComplete(MessageHubId fromMessageHubId,
+                                          SessionId sessionId) {
+  finalizeSession(fromMessageHubId, sessionId, /* reason = */ std::nullopt);
+}
+
 SessionId MessageRouter::openSession(MessageHubId fromMessageHubId,
                                      EndpointId fromEndpointId,
                                      MessageHubId toMessageHubId,
-                                     EndpointId toEndpointId) {
-  if (fromMessageHubId == toMessageHubId) {
-    LOGE(
-        "Failed to open session: initiator and peer message hubs are the "
-        "same");
+                                     EndpointId toEndpointId,
+                                     const char *serviceDescriptor,
+                                     SessionId sessionId) {
+  if (sessionId != SESSION_ID_INVALID && sessionId < kReservedSessionId) {
+    LOGE("Failed to open session: session ID %" PRIu16
+         " is not in the reserved range",
+         sessionId);
     return SESSION_ID_INVALID;
   }
 
-  MessageRouter::MessageHubCallback *initiatorCallback =
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> initiatorCallback =
       getCallbackFromMessageHubId(fromMessageHubId);
-  MessageRouter::MessageHubCallback *peerCallback =
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> peerCallback =
       getCallbackFromMessageHubId(toMessageHubId);
   if (initiatorCallback == nullptr || peerCallback == nullptr) {
-    LOGE("Failed to open session: initiator or peer message hub not found");
+    LOGE("Failed to open session: %s message hub not found",
+         initiatorCallback == nullptr ? "initiator" : "peer");
     return SESSION_ID_INVALID;
   }
 
   if (!checkIfEndpointExists(initiatorCallback, fromEndpointId)) {
-    LOGE("Failed to open session: endpoint with ID %" PRIu64
-         " not found in message hub with ID %" PRIu64,
+    LOGE("Failed to open session: endpoint with ID 0x%" PRIx64
+         " not found in message hub with ID 0x%" PRIx64,
          fromEndpointId, fromMessageHubId);
     return SESSION_ID_INVALID;
   }
 
   if (!checkIfEndpointExists(peerCallback, toEndpointId)) {
-    LOGE("Failed to open session: endpoint with ID %" PRIu64
-         " not found in message hub with ID %" PRIu64,
+    LOGE("Failed to open session: endpoint with ID 0x%" PRIx64
+         " not found in message hub with ID 0x%" PRIx64,
          toEndpointId, toMessageHubId);
     return SESSION_ID_INVALID;
   }
 
+  if (serviceDescriptor != nullptr &&
+      !peerCallback->doesEndpointHaveService(toEndpointId, serviceDescriptor)) {
+    LOGE("Failed to open session: endpoint with ID 0x%" PRIx64
+         " does not have service descriptor '%s'",
+         toEndpointId, serviceDescriptor);
+    return SESSION_ID_INVALID;
+  }
+
+  Session session(SESSION_ID_INVALID,
+                  Endpoint(fromMessageHubId, fromEndpointId),
+                  Endpoint(toMessageHubId, toEndpointId), serviceDescriptor);
   {
     LockGuard<Mutex> lock(mMutex);
     if (mSessions.full()) {
@@ -257,53 +433,93 @@ SessionId MessageRouter::openSession(MessageHubId fromMessageHubId,
       return SESSION_ID_INVALID;
     }
 
-    Session insertSession = {
-        .sessionId = mNextSessionId,
-        .initiator = {.messageHubId = fromMessageHubId,
-                      .endpointId = fromEndpointId},
-        .peer = {.messageHubId = toMessageHubId, .endpointId = toEndpointId},
-    };
-
-    for (Session &session : mSessions) {
-      if (session.isEquivalent(insertSession)) {
-        LOGD("Session with ID %" PRIu16 " already exists", session.sessionId);
-        return session.sessionId;
+    bool foundSession = false;
+    for (Session &existingSession : mSessions) {
+      if (existingSession.isEquivalent(session)) {
+        LOGD("Session with ID %" PRIu16 " already exists",
+             existingSession.sessionId);
+        session = existingSession;
+        foundSession = true;
+        break;
       }
     }
 
-    mSessions.push_back(std::move(insertSession));
-    return mNextSessionId++;
+    if (!foundSession) {
+      if (sessionId == SESSION_ID_INVALID) {
+        sessionId = getNextSessionIdLocked();
+        if (sessionId == SESSION_ID_INVALID) {
+          LOGE("Failed to open session: no available session ID");
+          return SESSION_ID_INVALID;
+        }
+      }
+
+      session.sessionId = sessionId;
+      mSessions.push_back(session);
+    }
   }
+
+  peerCallback->onSessionOpenRequest(session);
+  return session.sessionId;
 }
 
 bool MessageRouter::closeSession(MessageHubId fromMessageHubId,
-                                 SessionId sessionId) {
+                                 SessionId sessionId, Reason reason) {
+  return finalizeSession(fromMessageHubId, sessionId, reason);
+}
+
+bool MessageRouter::finalizeSession(MessageHubId fromMessageHubId,
+                                    SessionId sessionId,
+                                    std::optional<Reason> reason) {
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> peerCallback = nullptr;
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> initiatorCallback =
+      nullptr;
   Session session;
-  MessageRouter::MessageHubCallback *initiatorCallback = nullptr;
-  MessageRouter::MessageHubCallback *peerCallback = nullptr;
   {
     LockGuard<Mutex> lock(mMutex);
-
     std::optional<size_t> index =
         findSessionIndexLocked(fromMessageHubId, sessionId);
     if (!index.has_value()) {
-      LOGE("Failed to close session with ID %" PRIu16 ": session not found",
-           sessionId);
+      LOGE("Failed to %s session with ID %" PRIu16 " not found",
+           reason.has_value() ? "close" : "open", sessionId);
       return false;
     }
 
     session = mSessions[*index];
+    if (reason.has_value()) {
+      mSessions.erase(&mSessions[*index]);
+    } else {
+      mSessions[*index].isActive = true;
+      session.isActive = true;
+    }
+
     initiatorCallback =
         getCallbackFromMessageHubIdLocked(session.initiator.messageHubId);
     peerCallback = getCallbackFromMessageHubIdLocked(session.peer.messageHubId);
-    mSessions.erase(&mSessions[*index]);
-  }
 
-  if (initiatorCallback != nullptr) {
-    initiatorCallback->onSessionClosed(session);
+    if (initiatorCallback == nullptr || peerCallback == nullptr) {
+      LOGE("Failed to finalize session: %s message hub with ID 0x%" PRIx64
+           " not found",
+           initiatorCallback == nullptr ? "initiator" : "peer",
+           initiatorCallback == nullptr ? session.initiator.messageHubId
+                                        : session.peer.messageHubId);
+      if (!reason.has_value()) {
+        // Only erase if it was not erased above
+        mSessions.erase(&mSessions[*index]);
+      }
+      return false;
+    }
   }
-  if (peerCallback != nullptr) {
-    peerCallback->onSessionClosed(session);
+
+  if (reason.has_value()) {
+    initiatorCallback->onSessionClosed(session, reason.value());
+    if (initiatorCallback != peerCallback) {
+      peerCallback->onSessionClosed(session, reason.value());
+    }
+  } else {
+    initiatorCallback->onSessionOpened(session);
+    if (initiatorCallback != peerCallback) {
+      peerCallback->onSessionOpened(session);
+    }
   }
   return true;
 }
@@ -319,12 +535,14 @@ std::optional<Session> MessageRouter::getSessionWithId(
 }
 
 bool MessageRouter::sendMessage(pw::UniquePtr<std::byte[]> &&data,
-                                size_t length, uint32_t messageType,
+                                uint32_t messageType,
                                 uint32_t messagePermissions,
-                                SessionId sessionId,
+                                SessionId sessionId, EndpointId fromEndpointId,
                                 MessageHubId fromMessageHubId) {
-  MessageRouter::MessageHubCallback *receiverCallback = nullptr;
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> receiverCallback =
+      nullptr;
   Session session;
+  bool sentBySessionInitiator;
   {
     LockGuard<Mutex> lock(mMutex);
 
@@ -337,25 +555,117 @@ bool MessageRouter::sendMessage(pw::UniquePtr<std::byte[]> &&data,
     }
 
     session = mSessions[*index];
+    if (!session.isActive) {
+      LOGE("Failed to send message: session with ID %" PRIu16 " is inactive",
+           sessionId);
+      return false;
+    }
+
+    Endpoint sender(fromMessageHubId, fromEndpointId);
+    if (fromEndpointId == ENDPOINT_ID_ANY) {
+      if (session.initiator.messageHubId == session.peer.messageHubId) {
+        LOGE("Unable to infer sender endpoint ID: session with ID %" PRIu16
+             " is between endpoints on the same message hub with ID 0x%" PRIx64,
+             sessionId, fromMessageHubId);
+        return false;
+      }
+      sender.endpointId = session.initiator.messageHubId == fromMessageHubId
+                              ? session.initiator.endpointId
+                              : session.peer.endpointId;
+    }
+
+    if (sender != session.initiator && sender != session.peer) {
+      LOGE("Failed to send message: session with ID %" PRIu16
+           " does not contain endpoint with hub ID 0x%" PRIx64
+           " and endpoint ID 0x%" PRIx64,
+           sessionId, fromMessageHubId, fromEndpointId);
+      return false;
+    }
+    sentBySessionInitiator = sender == session.initiator;
     receiverCallback = getCallbackFromMessageHubIdLocked(
-        session.initiator.messageHubId == fromMessageHubId
-            ? session.peer.messageHubId
-            : session.initiator.messageHubId);
+        sentBySessionInitiator ? session.peer.messageHubId
+                               : session.initiator.messageHubId);
   }
 
   bool success = false;
   if (receiverCallback != nullptr) {
-    success = receiverCallback->onMessageReceived(
-        std::move(data), length, messageType, messagePermissions, session,
-        session.initiator.messageHubId == fromMessageHubId);
+    success = receiverCallback->onMessageReceived(std::move(data), messageType,
+                                                  messagePermissions, session,
+                                                  sentBySessionInitiator);
   }
 
   if (!success) {
-    closeSession(fromMessageHubId, sessionId);
+    closeSession(fromMessageHubId, sessionId, Reason::UNSPECIFIED);
   }
   return success;
 }
 
+bool MessageRouter::registerEndpoint(MessageHubId messageHubId,
+                                     EndpointId endpointId) {
+  return onEndpointRegistrationStateChanged(messageHubId, endpointId,
+                                            /* isRegistered = */ true);
+}
+
+bool MessageRouter::unregisterEndpoint(MessageHubId messageHubId,
+                                       EndpointId endpointId) {
+  return onEndpointRegistrationStateChanged(messageHubId, endpointId,
+                                            /* isRegistered = */ false);
+}
+
+bool MessageRouter::onEndpointRegistrationStateChanged(
+    MessageHubId messageHubId, EndpointId endpointId, bool isRegistered) {
+  pw::IntrusivePtr<MessageRouter::MessageHubCallback> callback =
+      getCallbackFromMessageHubId(messageHubId);
+  if (callback == nullptr) {
+    LOGE("Failed to register endpoint with ID 0x%" PRIx64
+         " to message hub with ID 0x%" PRIx64 ": hub not found",
+         endpointId, messageHubId);
+    return false;
+  }
+
+  std::optional<DynamicVector<MessageHubRecord>> messageHubRecords =
+      getMessageHubRecords();
+  if (!messageHubRecords.has_value()) {
+    return false;
+  }
+
+  for (const MessageHubRecord &messageHubRecord : *messageHubRecords) {
+    if (messageHubRecord.info.id == messageHubId) {
+      continue;
+    }
+
+    if (isRegistered) {
+      messageHubRecord.callback->onEndpointRegistered(messageHubId, endpointId);
+    } else {
+      messageHubRecord.callback->onEndpointUnregistered(messageHubId,
+                                                        endpointId);
+    }
+  }
+
+  return true;
+}
+
+std::optional<DynamicVector<MessageRouter::MessageHubRecord>>
+MessageRouter::getMessageHubRecords() {
+  LockGuard<Mutex> lock(mMutex);
+  return getMessageHubRecordsLocked();
+}
+
+std::optional<DynamicVector<MessageRouter::MessageHubRecord>>
+MessageRouter::getMessageHubRecordsLocked() {
+  DynamicVector<MessageHubRecord> messageHubRecords;
+  if (!messageHubRecords.reserve(mMessageHubs.size())) {
+    LOG_OOM();
+    return std::nullopt;
+  }
+
+  for (const MessageHubRecord &messageHubRecord : mMessageHubs) {
+    // Will not fail because we reserved space above
+    messageHubRecords.push_back(messageHubRecord);
+  }
+  return messageHubRecords;
+}
+
 const MessageRouter::MessageHubRecord *MessageRouter::getMessageHubRecordLocked(
     MessageHubId messageHubId) {
   for (MessageHubRecord &messageHubRecord : mMessageHubs) {
@@ -376,8 +686,8 @@ std::optional<size_t> MessageRouter::findSessionIndexLocked(
       }
 
       LOGE("Hub mismatch for session with ID %" PRIu16
-           ": requesting hub ID %" PRIu64
-           " but session is between hubs %" PRIu64 " and %" PRIu64,
+           ": requesting hub ID 0x%" PRIx64
+           " but session is between hubs 0x%" PRIx64 " and 0x%" PRIx64,
            sessionId, fromMessageHubId, mSessions[i].initiator.messageHubId,
            mSessions[i].peer.messageHubId);
       break;
@@ -386,13 +696,13 @@ std::optional<size_t> MessageRouter::findSessionIndexLocked(
   return std::nullopt;
 }
 
-MessageRouter::MessageHubCallback *MessageRouter::getCallbackFromMessageHubId(
-    MessageHubId messageHubId) {
+pw::IntrusivePtr<MessageRouter::MessageHubCallback>
+MessageRouter::getCallbackFromMessageHubId(MessageHubId messageHubId) {
   LockGuard<Mutex> lock(mMutex);
   return getCallbackFromMessageHubIdLocked(messageHubId);
 }
 
-MessageRouter::MessageHubCallback *
+pw::IntrusivePtr<MessageRouter::MessageHubCallback>
 MessageRouter::getCallbackFromMessageHubIdLocked(MessageHubId messageHubId) {
   const MessageHubRecord *messageHubRecord =
       getMessageHubRecordLocked(messageHubId);
@@ -400,7 +710,8 @@ MessageRouter::getCallbackFromMessageHubIdLocked(MessageHubId messageHubId) {
 }
 
 bool MessageRouter::checkIfEndpointExists(
-    MessageRouter::MessageHubCallback *callback, EndpointId endpointId) {
+    const pw::IntrusivePtr<MessageRouter::MessageHubCallback> &callback,
+    EndpointId endpointId) {
   struct EndpointContext {
     EndpointId endpointId;
     bool foundEndpoint = false;
@@ -419,4 +730,31 @@ bool MessageRouter::checkIfEndpointExists(
   return context.foundEndpoint;
 }
 
+SessionId MessageRouter::getNextSessionIdLocked() {
+  constexpr size_t kMaxIterations = 10;
+
+  if (mNextSessionId >= kReservedSessionId) {
+    mNextSessionId = 0;
+  }
+
+  bool foundSessionIdConflict;
+  size_t iterations = 0;
+  do {
+    foundSessionIdConflict = false;
+    for (const Session &session : mSessions) {
+      if (session.sessionId == mNextSessionId) {
+        ++mNextSessionId;
+        if (mNextSessionId >= kReservedSessionId) {
+          mNextSessionId = 0;
+        }
+        foundSessionIdConflict = true;
+        break;
+      }
+    }
+    ++iterations;
+  } while (foundSessionIdConflict && iterations < kMaxIterations);
+
+  return foundSessionIdConflict ? SESSION_ID_INVALID : mNextSessionId++;
+}
+
 }  // namespace chre::message
diff --git a/util/system/service_helpers.cc b/util/system/service_helpers.cc
new file mode 100644
index 00000000..0215e4da
--- /dev/null
+++ b/util/system/service_helpers.cc
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <cstring>
+
+#include "chre/util/system/service_helpers.h"
+
+namespace chre::message {
+
+namespace {
+
+//! Legacy format is: chre.nanoapp_0x<nanoappId>.service_0x<serviceId>
+//! All IDs are in hexadecimal
+constexpr char kPrefix[] = "chre.nanoapp_0x";
+constexpr size_t kPrefixLength = sizeof(kPrefix) - 1;
+constexpr char kSeparator[] = ".service_0x";
+constexpr size_t kSeparatorLength = sizeof(kSeparator) - 1;
+constexpr size_t kEncodingLength = 16;
+constexpr size_t kBase = 16;
+constexpr size_t kServiceDescriptorLength =
+    kPrefixLength + kEncodingLength + kSeparatorLength + kEncodingLength;
+
+//! Converts a string containing a 16-character hexadecimal encoding to a
+//! uint64_t. We are using this instead of directly using strtoull because
+//! some of our platforms do not support this function.
+//! @return the converted uint64_t
+uint64_t convertEncodedIdToUint64(const char *str) {
+  constexpr size_t kHalfEncodingLength = kEncodingLength / 2;
+  char buffer[kHalfEncodingLength + 1];
+  buffer[kHalfEncodingLength] = '\0';
+
+  // Convert the first half (upper 32 bits) of the encoding to a uint64_t
+  memcpy(buffer, str, kHalfEncodingLength);
+  uint64_t resultFirst = strtoul(buffer, nullptr, kBase);
+
+  // Convert the second half (lower 32 bits) of the encoding to a uint64_t
+  memcpy(buffer, str + kHalfEncodingLength, kHalfEncodingLength);
+  uint64_t resultSecond = strtoul(buffer, nullptr, kBase);
+
+  // Combine the two halves into a single uint64_t
+  return (resultFirst << 32) | resultSecond;
+}
+
+}  // anonymous namespace
+
+bool extractNanoappIdAndServiceId(const char *serviceDescriptor,
+                                  uint64_t &nanoappId, uint64_t &serviceId) {
+  // Reject null service descriptors
+  if (serviceDescriptor == nullptr) {
+    return false;
+  }
+
+  // Check the service descriptor length
+  if (strlen(serviceDescriptor) != kServiceDescriptorLength) {
+    return false;
+  }
+
+  // Check if the service descriptor starts with the legacy prefix
+  if (strstr(serviceDescriptor, kPrefix) != serviceDescriptor) {
+    return false;
+  }
+
+  // Check if the service descriptor contains the separator in the correct
+  // location
+  const char *separatorIndex =
+      strstr(serviceDescriptor + kPrefixLength, kSeparator);
+  if (separatorIndex == nullptr ||
+      (reinterpret_cast<uintptr_t>(separatorIndex) -
+       reinterpret_cast<uintptr_t>(serviceDescriptor)) *
+              sizeof(char) !=
+          kPrefixLength + kEncodingLength) {
+    return false;
+  }
+
+  // Convert the encoded strings for the IDs to uint64_t
+  nanoappId = convertEncodedIdToUint64(serviceDescriptor + kPrefixLength);
+  serviceId = convertEncodedIdToUint64(separatorIndex + kSeparatorLength);
+  return true;
+}
+
+}  // namespace chre::message
diff --git a/util/tests/intrusive_ref_base_test.cc b/util/tests/intrusive_ref_base_test.cc
new file mode 100644
index 00000000..6a86f432
--- /dev/null
+++ b/util/tests/intrusive_ref_base_test.cc
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <memory>
+
+#include "gtest/gtest.h"
+
+#include "chre/util/memory.h"
+#include "chre/util/system/intrusive_ref_base.h"
+
+#include "pw_intrusive_ptr/intrusive_ptr.h"
+#include "pw_intrusive_ptr/recyclable.h"
+
+namespace {
+
+class TestBase : public chre::IntrusiveRefBase,
+                 public pw::Recyclable<TestBase> {
+ public:
+  ~TestBase() {
+    destructorCount++;
+  }
+
+  void pw_recycle() {
+    chre::memoryFreeAndDestroy(this);
+  }
+
+  static int destructorCount;
+};
+int TestBase::destructorCount = 0;
+
+class IntrusiveRefBaseTest : public testing::Test {
+ public:
+  void SetUp() override {
+    TestBase::destructorCount = 0;
+  }
+};
+
+}  // namespace
+
+TEST_F(IntrusiveRefBaseTest, ObjectIsDestroyed) {
+  TestBase *object =
+      static_cast<TestBase *>(chre::memoryAlloc(sizeof(TestBase)));
+  ASSERT_NE(object, nullptr);
+  std::construct_at(object);
+
+  {
+    pw::IntrusivePtr<TestBase> objectPtr(object);
+    EXPECT_EQ(0, TestBase::destructorCount);
+
+    {
+      pw::IntrusivePtr<TestBase> objectPtr2(object);
+      EXPECT_EQ(0, TestBase::destructorCount);
+    }
+    EXPECT_EQ(0, TestBase::destructorCount);
+  }
+  EXPECT_EQ(1, TestBase::destructorCount);
+}
diff --git a/util/tests/message_router_test.cc b/util/tests/message_router_test.cc
index 8c6f8759..520fec29 100644
--- a/util/tests/message_router_test.cc
+++ b/util/tests/message_router_test.cc
@@ -14,21 +14,28 @@
  * limitations under the License.
  */
 
-#include <pw_allocator/allocator.h>
-#include <pw_allocator/capability.h>
-#include <pw_allocator/unique_ptr.h>
-#include <cstddef>
-#include <cstdint>
-#include <optional>
-#include <utility>
+#include "chre/util/system/message_router.h"
 
 #include "chre/util/dynamic_vector.h"
+#include "chre/util/system/callback_allocator.h"
 #include "chre/util/system/message_common.h"
-#include "chre/util/system/message_router.h"
-#include "chre/util/system/message_router_callback_allocator.h"
+#include "chre/util/system/message_router_mocks.h"
 #include "chre_api/chre.h"
+
+#include "pw_allocator/libc_allocator.h"
+#include "pw_allocator/unique_ptr.h"
+#include "pw_intrusive_ptr/intrusive_ptr.h"
+
+#include "gmock/gmock.h"
 #include "gtest/gtest.h"
 
+#include <cstddef>
+#include <cstdint>
+#include <optional>
+#include <utility>
+
+using ::testing::_;
+
 namespace chre::message {
 namespace {
 
@@ -44,46 +51,25 @@ const EndpointInfo kEndpointInfos[kNumEndpoints] = {
                  EndpointType::HOST_NATIVE, CHRE_MESSAGE_PERMISSION_BLE),
     EndpointInfo(/* id= */ 3, /* name= */ "endpoint3", /* version= */ 100,
                  EndpointType::GENERIC, CHRE_MESSAGE_PERMISSION_AUDIO)};
+const char kServiceDescriptorForEndpoint2[] = "TEST_SERVICE.TEST";
 
-class TestAllocator : public pw::Allocator {
- public:
-  static constexpr Capabilities kCapabilities = 0;
-
-  TestAllocator() : pw::Allocator(kCapabilities) {}
-
-  virtual void *DoAllocate(Layout layout) override {
-    if (layout.alignment() > alignof(std::max_align_t)) {
-      void *ptr;
-      return posix_memalign(&ptr, layout.alignment(), layout.size()) == 0
-                 ? ptr
-                 : nullptr;
-    } else {
-      return malloc(layout.size());
-    }
-  }
+class MessageRouterTest : public ::testing::Test {};
 
-  virtual void DoDeallocate(void *ptr) override {
-    free(ptr);
+//! Iterates over the endpoints
+void forEachEndpoint(const pw::Function<bool(const EndpointInfo &)> &function) {
+  for (const EndpointInfo &endpointInfo : kEndpointInfos) {
+    if (function(endpointInfo)) {
+      return;
+    }
   }
-};
-
-class MessageRouterTest : public ::testing::Test {
- protected:
-  void SetUp() override {}
-
-  TestAllocator mAllocator;
-};
+}
 
 //! Base class for MessageHubCallbacks used in tests
 class MessageHubCallbackBase : public MessageRouter::MessageHubCallback {
  public:
   void forEachEndpoint(
       const pw::Function<bool(const EndpointInfo &)> &function) override {
-    for (const EndpointInfo &endpointInfo : kEndpointInfos) {
-      if (function(endpointInfo)) {
-        return;
-      }
-    }
+    ::chre::message::forEachEndpoint(function);
   }
 
   std::optional<EndpointInfo> getEndpointInfo(EndpointId endpointId) override {
@@ -94,16 +80,60 @@ class MessageHubCallbackBase : public MessageRouter::MessageHubCallback {
     }
     return std::nullopt;
   }
+
+  void onSessionOpenRequest(const Session & /* session */) override {}
+
+  std::optional<EndpointId> getEndpointForService(
+      const char *serviceDescriptor) override {
+    if (serviceDescriptor != nullptr &&
+        std::strcmp(serviceDescriptor, kServiceDescriptorForEndpoint2) == 0) {
+      return kEndpointInfos[1].id;
+    }
+    return std::nullopt;
+  }
+
+  bool doesEndpointHaveService(EndpointId endpointId,
+                               const char *serviceDescriptor) override {
+    return serviceDescriptor != nullptr && endpointId == kEndpointInfos[1].id &&
+           std::strcmp(serviceDescriptor, kServiceDescriptorForEndpoint2) == 0;
+  }
+
+  void forEachService(
+      const pw::Function<bool(const EndpointInfo &, const ServiceInfo &)>
+          &function) override {
+    function(kEndpointInfos[1],
+             ServiceInfo(kServiceDescriptorForEndpoint2, /* majorVersion= */ 1,
+                         /* minorVersion= */ 0, RpcFormat::CUSTOM));
+  }
+
+  void onHubRegistered(const MessageHubInfo & /* info */) override {}
+
+  void onHubUnregistered(MessageHubId /* id */) override {}
+
+  void onEndpointRegistered(MessageHubId /* messageHubId */,
+                            EndpointId /* endpointId */) override {}
+
+  void onEndpointUnregistered(MessageHubId /* messageHubId */,
+                              EndpointId /* endpointId */) override {}
+
+  void pw_recycle() override {
+    delete this;
+  }
 };
 
 //! MessageHubCallback that stores the data passed to onMessageReceived and
 //! onSessionClosed
 class MessageHubCallbackStoreData : public MessageHubCallbackBase {
  public:
-  MessageHubCallbackStoreData(Message *message, Session *session)
-      : mMessage(message), mSession(session) {}
-
-  bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data, size_t length,
+  MessageHubCallbackStoreData(Message *message, Session *session,
+                              Reason *reason = nullptr,
+                              Session *openedSession = nullptr)
+      : mMessage(message),
+        mSession(session),
+        mReason(reason),
+        mOpenedSession(openedSession) {}
+
+  bool onMessageReceived(pw::UniquePtr<std::byte[]> &&data,
                          uint32_t messageType, uint32_t messagePermissions,
                          const Session &session,
                          bool sentBySessionInitiator) override {
@@ -114,22 +144,49 @@ class MessageHubCallbackStoreData : public MessageHubCallbackBase {
           sentBySessionInitiator ? session.peer : session.initiator;
       mMessage->sessionId = session.sessionId;
       mMessage->data = std::move(data);
-      mMessage->length = length;
       mMessage->messageType = messageType;
       mMessage->messagePermissions = messagePermissions;
     }
     return true;
   }
 
-  void onSessionClosed(const Session &session) override {
+  void onSessionClosed(const Session &session, Reason reason) override {
     if (mSession != nullptr) {
       *mSession = session;
     }
+    if (mReason != nullptr) {
+      *mReason = reason;
+    }
+  }
+
+  void onSessionOpened(const Session &session) override {
+    if (mOpenedSession != nullptr) {
+      *mOpenedSession = session;
+    }
+  }
+
+  void onEndpointRegistered(MessageHubId messageHubId,
+                            EndpointId endpointId) override {
+    mRegisteredEndpoints.insert(std::make_pair(messageHubId, endpointId));
+  }
+
+  void onEndpointUnregistered(MessageHubId messageHubId,
+                              EndpointId endpointId) override {
+    mRegisteredEndpoints.erase(std::make_pair(messageHubId, endpointId));
+  }
+
+  bool hasEndpointBeenRegistered(MessageHubId messageHubId,
+                                 EndpointId endpointId) {
+    return mRegisteredEndpoints.find(std::make_pair(
+               messageHubId, endpointId)) != mRegisteredEndpoints.end();
   }
 
  private:
   Message *mMessage;
   Session *mSession;
+  Reason *mReason;
+  Session *mOpenedSession;
+  std::set<std::pair<MessageHubId, EndpointId>> mRegisteredEndpoints;
 };
 
 //! MessageHubCallback that always fails to process messages
@@ -141,7 +198,7 @@ class MessageHubCallbackAlwaysFails : public MessageHubCallbackBase {
         mWasSessionClosedCalled(wasSessionClosedCalled) {}
 
   bool onMessageReceived(pw::UniquePtr<std::byte[]> && /* data */,
-                         size_t /* length */, uint32_t /* messageType */,
+                         uint32_t /* messageType */,
                          uint32_t /* messagePermissions */,
                          const Session & /* session */,
                          bool /* sentBySessionInitiator */) override {
@@ -151,23 +208,55 @@ class MessageHubCallbackAlwaysFails : public MessageHubCallbackBase {
     return false;
   }
 
-  void onSessionClosed(const Session & /* session */) override {
+  void onSessionClosed(const Session & /* session */,
+                       Reason /* reason */) override {
     if (mWasSessionClosedCalled != nullptr) {
       *mWasSessionClosedCalled = true;
     }
   }
 
+  void onSessionOpened(const Session & /* session */) override {}
+
  private:
   bool *mWasMessageReceivedCalled;
   bool *mWasSessionClosedCalled;
 };
 
+//! MessageHubCallback that tracks open session requests calls
+class MessageHubCallbackOpenSessionRequest : public MessageHubCallbackBase {
+ public:
+  MessageHubCallbackOpenSessionRequest(bool *wasSessionOpenRequestCalled)
+      : mWasSessionOpenRequestCalled(wasSessionOpenRequestCalled) {}
+
+  void onSessionOpenRequest(const Session & /* session */) override {
+    if (mWasSessionOpenRequestCalled != nullptr) {
+      *mWasSessionOpenRequestCalled = true;
+    }
+  }
+
+  bool onMessageReceived(pw::UniquePtr<std::byte[]> && /* data */,
+                         uint32_t /* messageType */,
+                         uint32_t /* messagePermissions */,
+                         const Session & /* session */,
+                         bool /* sentBySessionInitiator */) override {
+    return true;
+  }
+
+  void onSessionClosed(const Session & /* session */,
+                       Reason /* reason */) override {}
+
+  void onSessionOpened(const Session & /* session */) override {}
+
+ private:
+  bool *mWasSessionOpenRequestCalled;
+};
+
 //! MessageHubCallback that calls MessageHub APIs during callbacks
 class MessageHubCallbackCallsMessageHubApisDuringCallback
     : public MessageHubCallbackBase {
  public:
   bool onMessageReceived(pw::UniquePtr<std::byte[]> && /* data */,
-                         size_t /* length */, uint32_t /* messageType */,
+                         uint32_t /* messageType */,
                          uint32_t /* messagePermissions */,
                          const Session & /* session */,
                          bool /* sentBySessionInitiator */) override {
@@ -179,7 +268,16 @@ class MessageHubCallbackCallsMessageHubApisDuringCallback
     return true;
   }
 
-  void onSessionClosed(const Session & /* session */) override {
+  void onSessionClosed(const Session & /* session */,
+                       Reason /* reason */) override {
+    if (mMessageHub != nullptr) {
+      // Call a function that locks the MessageRouter mutex
+      mMessageHub->openSession(kEndpointInfos[0].id, mMessageHub->getId(),
+                               kEndpointInfos[1].id);
+    }
+  }
+
+  void onSessionOpened(const Session & /* session */) override {
     if (mMessageHub != nullptr) {
       // Call a function that locks the MessageRouter mutex
       mMessageHub->openSession(kEndpointInfos[0].id, mMessageHub->getId(),
@@ -198,8 +296,9 @@ class MessageHubCallbackCallsMessageHubApisDuringCallback
 TEST_F(MessageRouterTest, RegisterMessageHubNameIsUnique) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
 
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub1 =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub1.has_value());
@@ -215,8 +314,9 @@ TEST_F(MessageRouterTest, RegisterMessageHubNameIsUnique) {
 TEST_F(MessageRouterTest, RegisterMessageHubIdIsUnique) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
 
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub1 =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub1.has_value());
@@ -232,8 +332,9 @@ TEST_F(MessageRouterTest, RegisterMessageHubIdIsUnique) {
 TEST_F(MessageRouterTest, RegisterMessageHubGetListOfHubs) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
 
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub1 =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub1.has_value());
@@ -265,8 +366,9 @@ TEST_F(MessageRouterTest, RegisterMessageHubGetListOfHubs) {
 TEST_F(MessageRouterTest, RegisterMessageHubGetListOfHubsWithUnregister) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
 
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub1 =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub1.has_value());
@@ -317,8 +419,9 @@ TEST_F(MessageRouterTest, RegisterMessageHubTooManyFails) {
   static_assert(kMaxMessageHubs == 3);
   constexpr const char *kNames[3] = {"hub1", "hub2", "hub3"};
 
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   MessageRouter::MessageHub messageHubs[kMaxMessageHubs];
   for (size_t i = 0; i < kMaxMessageHubs; ++i) {
     std::optional<MessageRouter::MessageHub> messageHub =
@@ -336,8 +439,9 @@ TEST_F(MessageRouterTest, RegisterMessageHubTooManyFails) {
 TEST_F(MessageRouterTest, GetEndpointInfo) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
 
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub1 =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub1.has_value());
@@ -361,14 +465,91 @@ TEST_F(MessageRouterTest, GetEndpointInfo) {
   }
 }
 
+TEST_F(MessageRouterTest, GetEndpointForService) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub1 =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub1.has_value());
+
+  std::optional<Endpoint> endpoint = router.getEndpointForService(
+      MESSAGE_HUB_ID_INVALID, kServiceDescriptorForEndpoint2);
+  EXPECT_TRUE(endpoint.has_value());
+
+  EXPECT_EQ(endpoint->messageHubId, messageHub1->getId());
+  EXPECT_EQ(endpoint->endpointId, kEndpointInfos[1].id);
+}
+
+TEST_F(MessageRouterTest, DoesEndpointHaveService) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub1 =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub1.has_value());
+
+  EXPECT_TRUE(router.doesEndpointHaveService(messageHub1->getId(),
+                                             kEndpointInfos[1].id,
+                                             kServiceDescriptorForEndpoint2));
+}
+
+TEST_F(MessageRouterTest, ForEachService) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub1 =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub1.has_value());
+
+  router.forEachService([](const MessageHubInfo &hub,
+                           const EndpointInfo &endpoint,
+                           const ServiceInfo &service) {
+    EXPECT_EQ(hub.id, 1);
+    EXPECT_EQ(endpoint.id, kEndpointInfos[1].id);
+    EXPECT_STREQ(service.serviceDescriptor, kServiceDescriptorForEndpoint2);
+    EXPECT_EQ(service.majorVersion, 1);
+    EXPECT_EQ(service.minorVersion, 0);
+    EXPECT_EQ(service.format, RpcFormat::CUSTOM);
+    return true;
+  });
+}
+
+TEST_F(MessageRouterTest, GetEndpointForServiceBadServiceDescriptor) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub1 =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub1.has_value());
+
+  std::optional<Endpoint> endpoint = router.getEndpointForService(
+      MESSAGE_HUB_ID_INVALID, "SERVICE_THAT_DOES_NOT_EXIST");
+  EXPECT_FALSE(endpoint.has_value());
+
+  std::optional<Endpoint> endpoint2 = router.getEndpointForService(
+      MESSAGE_HUB_ID_INVALID, /* serviceDescriptor= */ nullptr);
+  EXPECT_FALSE(endpoint2.has_value());
+}
+
 TEST_F(MessageRouterTest, RegisterSessionTwoDifferentMessageHubs) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   Session sessionFromCallback1;
   Session sessionFromCallback2;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -381,6 +562,7 @@ TEST_F(MessageRouterTest, RegisterSessionTwoDifferentMessageHubs) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Get session from messageHub and compare it with messageHub2
   std::optional<Session> sessionAfterRegistering =
@@ -408,14 +590,318 @@ TEST_F(MessageRouterTest, RegisterSessionTwoDifferentMessageHubs) {
   EXPECT_FALSE(messageHub2->getSessionWithId(sessionId).has_value());
 }
 
+TEST_F(MessageRouterTest, RegisterSessionVerifyAllCallbacksAreCalled) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  Session sessionClosedFromCallback1;
+  Session sessionClosedFromCallback2;
+  Session sessionOpenedFromCallback1;
+  Session sessionOpenedFromCallback2;
+  Reason sessionCloseReason1;
+  Reason sessionCloseReason2;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(
+          /* message= */ nullptr, &sessionClosedFromCallback1,
+          &sessionCloseReason1, &sessionOpenedFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(
+          /* message= */ nullptr, &sessionClosedFromCallback2,
+          &sessionCloseReason2, &sessionOpenedFromCallback2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
+
+  // Verify that onSessionOpened is called on both message hubs
+  EXPECT_EQ(sessionOpenedFromCallback1.sessionId, sessionId);
+  EXPECT_EQ(sessionOpenedFromCallback1.initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionOpenedFromCallback1.initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionOpenedFromCallback1.peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionOpenedFromCallback1.peer.endpointId, kEndpointInfos[1].id);
+
+  EXPECT_EQ(sessionOpenedFromCallback2.sessionId, sessionId);
+  EXPECT_EQ(sessionOpenedFromCallback2.initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionOpenedFromCallback2.initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionOpenedFromCallback2.peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionOpenedFromCallback2.peer.endpointId, kEndpointInfos[1].id);
+
+  // Close the session with a reason
+  Reason reason = Reason::TIMEOUT;
+  EXPECT_TRUE(messageHub->closeSession(sessionId, reason));
+
+  // Verify that onSessionClosed is called on both message hubs
+  EXPECT_EQ(sessionClosedFromCallback1.sessionId, sessionId);
+  EXPECT_EQ(sessionClosedFromCallback1.initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionClosedFromCallback1.initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionClosedFromCallback1.peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionClosedFromCallback1.peer.endpointId, kEndpointInfos[1].id);
+  EXPECT_EQ(sessionCloseReason1, reason);
+
+  EXPECT_EQ(sessionClosedFromCallback2.sessionId, sessionId);
+  EXPECT_EQ(sessionClosedFromCallback2.initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionClosedFromCallback2.initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionClosedFromCallback2.peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionClosedFromCallback2.peer.endpointId, kEndpointInfos[1].id);
+  EXPECT_EQ(sessionCloseReason2, reason);
+}
+
+TEST_F(MessageRouterTest, RegisterSessionGetsRejectedAndClosed) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  Session sessionFromCallback1;
+  Session sessionFromCallback2;
+  Reason sessionCloseReason;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(
+          /* message= */ nullptr, &sessionFromCallback1, &sessionCloseReason);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  Reason reason = Reason::OPEN_ENDPOINT_SESSION_REQUEST_REJECTED;
+  messageHub2->closeSession(sessionId, reason);
+
+  // Get session from messageHub and ensure it is deleted
+  std::optional<Session> sessionAfterRegistering =
+      messageHub->getSessionWithId(sessionId);
+  EXPECT_FALSE(sessionAfterRegistering.has_value());
+  std::optional<Session> sessionAfterRegistering2 =
+      messageHub2->getSessionWithId(sessionId);
+  EXPECT_FALSE(sessionAfterRegistering2.has_value());
+
+  // Close the session and verify it is closed on both message hubs
+  EXPECT_EQ(sessionFromCallback1.sessionId, sessionId);
+  EXPECT_EQ(sessionFromCallback1.initiator.messageHubId, messageHub->getId());
+  EXPECT_EQ(sessionFromCallback1.initiator.endpointId, kEndpointInfos[0].id);
+  EXPECT_EQ(sessionFromCallback1.peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionFromCallback1.peer.endpointId, kEndpointInfos[1].id);
+  EXPECT_EQ(sessionCloseReason, reason);
+}
+
+TEST_F(MessageRouterTest, RegisterSessionSecondHubDoesNotRespond) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  bool wasOpenSessionRequestCalled = false;
+  bool wasOpenSessionRequestCalled2 = false;
+  pw::IntrusivePtr<MessageHubCallbackOpenSessionRequest> callback =
+      pw::MakeRefCounted<MessageHubCallbackOpenSessionRequest>(
+          &wasOpenSessionRequestCalled);
+  pw::IntrusivePtr<MessageHubCallbackOpenSessionRequest> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackOpenSessionRequest>(
+          &wasOpenSessionRequestCalled2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+
+  // Message Hub 2 does not respond - verify the callback was called once
+  EXPECT_FALSE(wasOpenSessionRequestCalled);
+  EXPECT_TRUE(wasOpenSessionRequestCalled2);
+
+  // Open session from messageHub:1 to messageHub2:2 - try again
+  wasOpenSessionRequestCalled = false;
+  SessionId sessionId2 = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  EXPECT_EQ(sessionId, sessionId2);
+  EXPECT_FALSE(wasOpenSessionRequestCalled);
+  EXPECT_TRUE(wasOpenSessionRequestCalled2);
+
+  // Respond then close the session
+  messageHub2->onSessionOpenComplete(sessionId2);
+  EXPECT_TRUE(messageHub->closeSession(sessionId));
+}
+
+TEST_F(MessageRouterTest, RegisterSessionWithServiceDescriptor) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  Session sessionFromCallback1;
+  Session sessionFromCallback2;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id,
+      kServiceDescriptorForEndpoint2);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+
+  // Get session from messageHub and compare it with messageHub2
+  std::optional<Session> sessionAfterRegistering =
+      messageHub->getSessionWithId(sessionId);
+  EXPECT_TRUE(sessionAfterRegistering.has_value());
+  EXPECT_EQ(sessionAfterRegistering->sessionId, sessionId);
+  EXPECT_EQ(sessionAfterRegistering->initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionAfterRegistering->initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionAfterRegistering->peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionAfterRegistering->peer.endpointId, kEndpointInfos[1].id);
+  EXPECT_TRUE(sessionAfterRegistering->hasServiceDescriptor);
+  EXPECT_STREQ(sessionAfterRegistering->serviceDescriptor,
+               kServiceDescriptorForEndpoint2);
+  std::optional<Session> sessionAfterRegistering2 =
+      messageHub2->getSessionWithId(sessionId);
+  EXPECT_TRUE(sessionAfterRegistering2.has_value());
+  EXPECT_EQ(*sessionAfterRegistering, *sessionAfterRegistering2);
+
+  // Close the session and verify it is closed on both message hubs
+  EXPECT_NE(*sessionAfterRegistering, sessionFromCallback1);
+  EXPECT_NE(*sessionAfterRegistering, sessionFromCallback2);
+  EXPECT_TRUE(messageHub->closeSession(sessionId));
+  EXPECT_EQ(*sessionAfterRegistering, sessionFromCallback1);
+  EXPECT_EQ(*sessionAfterRegistering, sessionFromCallback2);
+  EXPECT_FALSE(messageHub->getSessionWithId(sessionId).has_value());
+  EXPECT_FALSE(messageHub2->getSessionWithId(sessionId).has_value());
+}
+
+TEST_F(MessageRouterTest,
+       RegisterSessionWithAndWithoutServiceDescriptorSameEndpoints) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  Session sessionFromCallback1;
+  Session sessionFromCallback2;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2 with service descriptor
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id,
+      kServiceDescriptorForEndpoint2);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+
+  // Open session from messageHub:1 to messageHub2:2 without service descriptor
+  SessionId sessionId2 = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+  EXPECT_NE(sessionId2, SESSION_ID_INVALID);
+  EXPECT_NE(sessionId2, sessionId);
+
+  // Get the first session from messageHub and compare it with messageHub2
+  std::optional<Session> sessionAfterRegistering =
+      messageHub->getSessionWithId(sessionId);
+  EXPECT_TRUE(sessionAfterRegistering.has_value());
+  EXPECT_EQ(sessionAfterRegistering->sessionId, sessionId);
+  EXPECT_EQ(sessionAfterRegistering->initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionAfterRegistering->initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionAfterRegistering->peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionAfterRegistering->peer.endpointId, kEndpointInfos[1].id);
+  EXPECT_TRUE(sessionAfterRegistering->hasServiceDescriptor);
+  EXPECT_STREQ(sessionAfterRegistering->serviceDescriptor,
+               kServiceDescriptorForEndpoint2);
+  std::optional<Session> sessionAfterRegistering2 =
+      messageHub2->getSessionWithId(sessionId);
+  EXPECT_TRUE(sessionAfterRegistering2.has_value());
+  EXPECT_EQ(*sessionAfterRegistering, *sessionAfterRegistering2);
+
+  // Get the second session from messageHub and compare it with messageHub2
+  std::optional<Session> sessionAfterRegistering3 =
+      messageHub->getSessionWithId(sessionId2);
+  EXPECT_TRUE(sessionAfterRegistering3.has_value());
+  EXPECT_EQ(sessionAfterRegistering3->sessionId, sessionId2);
+  EXPECT_EQ(sessionAfterRegistering3->initiator.messageHubId,
+            messageHub->getId());
+  EXPECT_EQ(sessionAfterRegistering3->initiator.endpointId,
+            kEndpointInfos[0].id);
+  EXPECT_EQ(sessionAfterRegistering3->peer.messageHubId, messageHub2->getId());
+  EXPECT_EQ(sessionAfterRegistering3->peer.endpointId, kEndpointInfos[1].id);
+  EXPECT_FALSE(sessionAfterRegistering3->hasServiceDescriptor);
+  EXPECT_STREQ(sessionAfterRegistering3->serviceDescriptor, "");
+  std::optional<Session> sessionAfterRegistering4 =
+      messageHub2->getSessionWithId(sessionId2);
+  EXPECT_TRUE(sessionAfterRegistering4.has_value());
+  EXPECT_EQ(*sessionAfterRegistering3, *sessionAfterRegistering4);
+}
+
+TEST_F(MessageRouterTest, RegisterSessionWithBadServiceDescriptor) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  Session sessionFromCallback1;
+  Session sessionFromCallback2;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[2].id,
+      kServiceDescriptorForEndpoint2);
+  EXPECT_EQ(sessionId, SESSION_ID_INVALID);
+}
+
 TEST_F(MessageRouterTest, UnregisterMessageHubCausesSessionClosed) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   Session sessionFromCallback1;
   Session sessionFromCallback2;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -428,6 +914,7 @@ TEST_F(MessageRouterTest, UnregisterMessageHubCausesSessionClosed) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Get session from messageHub and compare it with messageHub2
   std::optional<Session> sessionAfterRegistering =
@@ -452,14 +939,16 @@ TEST_F(MessageRouterTest, UnregisterMessageHubCausesSessionClosed) {
   EXPECT_FALSE(messageHub->getSessionWithId(sessionId).has_value());
 }
 
-TEST_F(MessageRouterTest, RegisterSessionSameMessageHubInvalid) {
+TEST_F(MessageRouterTest, RegisterSessionSameMessageHubIsValid) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   Session sessionFromCallback1;
   Session sessionFromCallback2;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -471,22 +960,107 @@ TEST_F(MessageRouterTest, RegisterSessionSameMessageHubInvalid) {
   // Open session from messageHub:2 to messageHub:2
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[1].id, messageHub->getId(), kEndpointInfos[1].id);
-  EXPECT_EQ(sessionId, SESSION_ID_INVALID);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
 
   // Open session from messageHub:1 to messageHub:3
   sessionId = messageHub->openSession(kEndpointInfos[0].id, messageHub->getId(),
                                       kEndpointInfos[2].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+}
+
+TEST_F(MessageRouterTest, RegisterSessionReservedSessionIdAreRespected) {
+  constexpr SessionId kReservedSessionId = 25;
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router(
+      kReservedSessionId);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub:2 more than the max number of
+  // sessions - should wrap around
+  for (size_t i = 0; i < kReservedSessionId * 2; ++i) {
+    SessionId sessionId = messageHub->openSession(
+        kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+    EXPECT_NE(sessionId, SESSION_ID_INVALID);
+    messageHub2->onSessionOpenComplete(sessionId);
+    EXPECT_TRUE(messageHub->closeSession(sessionId));
+  }
+}
+
+TEST_F(MessageRouterTest, RegisterSessionOpenSessionNotReservedRegionRejected) {
+  constexpr SessionId kReservedSessionId = 25;
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router(
+      kReservedSessionId);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub:2 and provide an invalid
+  // session ID (not in the reserved range)
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id,
+      /* serviceDescriptor= */ nullptr, kReservedSessionId / 2);
   EXPECT_EQ(sessionId, SESSION_ID_INVALID);
 }
 
+TEST_F(MessageRouterTest, RegisterSessionOpenSessionWithReservedSessionId) {
+  constexpr SessionId kReservedSessionId = 25;
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router(
+      kReservedSessionId);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub:2 and provide a reserved
+  // session ID
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id,
+      /* serviceDescriptor= */ nullptr, kReservedSessionId);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
+  EXPECT_TRUE(messageHub->closeSession(sessionId));
+}
+
 TEST_F(MessageRouterTest, RegisterSessionDifferentMessageHubsSameEndpoints) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   Session sessionFromCallback1;
   Session sessionFromCallback2;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -499,15 +1073,18 @@ TEST_F(MessageRouterTest, RegisterSessionDifferentMessageHubsSameEndpoints) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 }
 
 TEST_F(MessageRouterTest,
        RegisterSessionTwoDifferentMessageHubsInvalidEndpoint) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -528,12 +1105,15 @@ TEST_F(MessageRouterTest, ThirdMessageHubTriesToFindOthersSession) {
   Session sessionFromCallback1;
   Session sessionFromCallback2;
   Session sessionFromCallback3;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        &sessionFromCallback2);
-  MessageHubCallbackStoreData callback3(/* message= */ nullptr,
-                                        &sessionFromCallback3);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback3 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      &sessionFromCallback3);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -598,12 +1178,15 @@ TEST_F(MessageRouterTest, ThirdMessageHubTriesToFindOthersSession) {
 
 TEST_F(MessageRouterTest, ThreeMessageHubsAndThreeSessions) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
-  MessageHubCallbackStoreData callback2(/* message= */ nullptr,
-                                        /* session= */ nullptr);
-  MessageHubCallbackStoreData callback3(/* message= */ nullptr,
-                                        /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback3 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -619,16 +1202,19 @@ TEST_F(MessageRouterTest, ThreeMessageHubsAndThreeSessions) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Open session from messageHub2:2 to messageHub3:3
   SessionId sessionId2 = messageHub2->openSession(
       kEndpointInfos[1].id, messageHub3->getId(), kEndpointInfos[2].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub3->onSessionOpenComplete(sessionId2);
 
   // Open session from messageHub3:3 to messageHub1:1
   SessionId sessionId3 = messageHub3->openSession(
       kEndpointInfos[2].id, messageHub->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub->onSessionOpenComplete(sessionId3);
 
   // Get sessions and compare
   // Find session: MessageHub1:1 -> MessageHub2:2
@@ -671,8 +1257,9 @@ TEST_F(MessageRouterTest, ThreeMessageHubsAndThreeSessions) {
 TEST_F(MessageRouterTest, SendMessageToSession) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   constexpr size_t kMessageSize = 5;
+  pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
   pw::UniquePtr<std::byte[]> messageData =
-      mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+      allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
@@ -683,12 +1270,15 @@ TEST_F(MessageRouterTest, SendMessageToSession) {
   Session sessionFromCallback1;
   Session sessionFromCallback2;
   Session sessionFromCallback3;
-  MessageHubCallbackStoreData callback(&messageFromCallback1,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(&messageFromCallback2,
-                                        &sessionFromCallback2);
-  MessageHubCallbackStoreData callback3(&messageFromCallback3,
-                                        &sessionFromCallback3);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback1,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback2,
+                                                      &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback3 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback3,
+                                                      &sessionFromCallback3);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -704,19 +1294,106 @@ TEST_F(MessageRouterTest, SendMessageToSession) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Open session from messageHub2:2 to messageHub3:3
   SessionId sessionId2 = messageHub2->openSession(
       kEndpointInfos[1].id, messageHub3->getId(), kEndpointInfos[2].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub3->onSessionOpenComplete(sessionId2);
 
   // Open session from messageHub3:3 to messageHub1:1
   SessionId sessionId3 = messageHub3->openSession(
       kEndpointInfos[2].id, messageHub->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub->onSessionOpenComplete(sessionId3);
+
+  // Send message from messageHub:1 to messageHub2:2
+  ASSERT_TRUE(messageHub->sendMessage(std::move(messageData),
+                                      /* messageType= */ 1,
+                                      /* messagePermissions= */ 0, sessionId));
+  EXPECT_EQ(messageFromCallback2.sessionId, sessionId);
+  EXPECT_EQ(messageFromCallback2.sender.messageHubId, messageHub->getId());
+  EXPECT_EQ(messageFromCallback2.sender.endpointId, kEndpointInfos[0].id);
+  EXPECT_EQ(messageFromCallback2.recipient.messageHubId, messageHub2->getId());
+  EXPECT_EQ(messageFromCallback2.recipient.endpointId, kEndpointInfos[1].id);
+  EXPECT_EQ(messageFromCallback2.messageType, 1);
+  EXPECT_EQ(messageFromCallback2.messagePermissions, 0);
+  EXPECT_EQ(messageFromCallback2.data.size(), kMessageSize);
+  for (size_t i = 0; i < kMessageSize; ++i) {
+    EXPECT_EQ(messageFromCallback2.data[i], static_cast<std::byte>(i + 1));
+  }
+
+  messageData = allocator.MakeUniqueArray<std::byte>(kMessageSize);
+  for (size_t i = 0; i < 5; ++i) {
+    messageData[i] = static_cast<std::byte>(i + 1);
+  }
+
+  // Send message from messageHub2:2 to messageHub:1
+  ASSERT_TRUE(messageHub2->sendMessage(std::move(messageData),
+                                       /* messageType= */ 2,
+                                       /* messagePermissions= */ 3, sessionId));
+  EXPECT_EQ(messageFromCallback1.sessionId, sessionId);
+  EXPECT_EQ(messageFromCallback1.sender.messageHubId, messageHub2->getId());
+  EXPECT_EQ(messageFromCallback1.sender.endpointId, kEndpointInfos[1].id);
+  EXPECT_EQ(messageFromCallback1.recipient.messageHubId, messageHub->getId());
+  EXPECT_EQ(messageFromCallback1.recipient.endpointId, kEndpointInfos[0].id);
+  EXPECT_EQ(messageFromCallback1.messageType, 2);
+  EXPECT_EQ(messageFromCallback1.messagePermissions, 3);
+  EXPECT_EQ(messageFromCallback1.data.size(), kMessageSize);
+  for (size_t i = 0; i < kMessageSize; ++i) {
+    EXPECT_EQ(messageFromCallback1.data[i], static_cast<std::byte>(i + 1));
+  }
+}
+
+TEST_F(MessageRouterTest, SendMessageOnHalfOpenSessionIsRejected) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  constexpr size_t kMessageSize = 5;
+  pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
+  pw::UniquePtr<std::byte[]> messageData =
+      allocator.MakeUniqueArray<std::byte>(kMessageSize);
+  for (size_t i = 0; i < 5; ++i) {
+    messageData[i] = static_cast<std::byte>(i + 1);
+  }
+
+  Message messageFromCallback1;
+  Message messageFromCallback2;
+  Session sessionFromCallback1;
+  Session sessionFromCallback2;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback1,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback2,
+                                                      &sessionFromCallback2);
+
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub2.has_value());
+
+  // Open session from messageHub:1 to messageHub2:2 but do not complete it
+  SessionId sessionId = messageHub->openSession(
+      kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
+  EXPECT_NE(sessionId, SESSION_ID_INVALID);
+
+  // Try to send a message from messageHub:1 to messageHub2:2 - should fail
+  EXPECT_FALSE(messageHub->sendMessage(std::move(messageData),
+                                       /* messageType= */ 1,
+                                       /* messagePermissions= */ 0, sessionId));
+
+  // Now complete the session
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Send message from messageHub:1 to messageHub2:2
-  ASSERT_TRUE(messageHub->sendMessage(std::move(messageData), kMessageSize,
+  messageData = allocator.MakeUniqueArray<std::byte>(kMessageSize);
+  for (size_t i = 0; i < 5; ++i) {
+    messageData[i] = static_cast<std::byte>(i + 1);
+  }
+
+  ASSERT_TRUE(messageHub->sendMessage(std::move(messageData),
                                       /* messageType= */ 1,
                                       /* messagePermissions= */ 0, sessionId));
   EXPECT_EQ(messageFromCallback2.sessionId, sessionId);
@@ -726,18 +1403,18 @@ TEST_F(MessageRouterTest, SendMessageToSession) {
   EXPECT_EQ(messageFromCallback2.recipient.endpointId, kEndpointInfos[1].id);
   EXPECT_EQ(messageFromCallback2.messageType, 1);
   EXPECT_EQ(messageFromCallback2.messagePermissions, 0);
-  EXPECT_EQ(messageFromCallback2.length, kMessageSize);
+  EXPECT_EQ(messageFromCallback2.data.size(), kMessageSize);
   for (size_t i = 0; i < kMessageSize; ++i) {
     EXPECT_EQ(messageFromCallback2.data[i], static_cast<std::byte>(i + 1));
   }
 
-  messageData = mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+  messageData = allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
 
   // Send message from messageHub2:2 to messageHub:1
-  ASSERT_TRUE(messageHub2->sendMessage(std::move(messageData), kMessageSize,
+  ASSERT_TRUE(messageHub2->sendMessage(std::move(messageData),
                                        /* messageType= */ 2,
                                        /* messagePermissions= */ 3, sessionId));
   EXPECT_EQ(messageFromCallback1.sessionId, sessionId);
@@ -747,7 +1424,7 @@ TEST_F(MessageRouterTest, SendMessageToSession) {
   EXPECT_EQ(messageFromCallback1.recipient.endpointId, kEndpointInfos[0].id);
   EXPECT_EQ(messageFromCallback1.messageType, 2);
   EXPECT_EQ(messageFromCallback1.messagePermissions, 3);
-  EXPECT_EQ(messageFromCallback1.length, kMessageSize);
+  EXPECT_EQ(messageFromCallback1.data.size(), kMessageSize);
   for (size_t i = 0; i < kMessageSize; ++i) {
     EXPECT_EQ(messageFromCallback1.data[i], static_cast<std::byte>(i + 1));
   }
@@ -760,13 +1437,10 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
     size_t length;
   };
 
-  pw::Vector<
-      MessageRouterCallbackAllocator<FreeCallbackContext>::FreeCallbackRecord,
-      10>
+  pw::Vector<CallbackAllocator<FreeCallbackContext>::CallbackRecord, 10>
       freeCallbackRecords;
-  MessageRouterCallbackAllocator<FreeCallbackContext> allocator(
-      [](std::byte *message, size_t length,
-         const FreeCallbackContext &context) {
+  CallbackAllocator<FreeCallbackContext> allocator(
+      [](std::byte *message, size_t length, FreeCallbackContext &&context) {
         *context.freeCallbackCalled =
             message == context.message && length == context.length;
       },
@@ -785,12 +1459,15 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
   Session sessionFromCallback1;
   Session sessionFromCallback2;
   Session sessionFromCallback3;
-  MessageHubCallbackStoreData callback(&messageFromCallback1,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(&messageFromCallback2,
-                                        &sessionFromCallback2);
-  MessageHubCallbackStoreData callback3(&messageFromCallback3,
-                                        &sessionFromCallback3);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback1,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback2,
+                                                      &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback3 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback3,
+                                                      &sessionFromCallback3);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -806,16 +1483,19 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Open session from messageHub2:2 to messageHub3:3
   SessionId sessionId2 = messageHub2->openSession(
       kEndpointInfos[1].id, messageHub3->getId(), kEndpointInfos[2].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub3->onSessionOpenComplete(sessionId2);
 
   // Open session from messageHub3:3 to messageHub1:1
   SessionId sessionId3 = messageHub3->openSession(
       kEndpointInfos[2].id, messageHub->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub->onSessionOpenComplete(sessionId3);
 
   // Send message from messageHub:1 to messageHub2:2
   bool freeCallbackCalled = false;
@@ -828,7 +1508,7 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
       messageData, kMessageSize, std::move(freeCallbackContext));
   ASSERT_NE(data.get(), nullptr);
 
-  ASSERT_TRUE(messageHub->sendMessage(std::move(data), kMessageSize,
+  ASSERT_TRUE(messageHub->sendMessage(std::move(data),
                                       /* messageType= */ 1,
                                       /* messagePermissions= */ 0, sessionId));
   EXPECT_EQ(messageFromCallback2.sessionId, sessionId);
@@ -838,7 +1518,7 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
   EXPECT_EQ(messageFromCallback2.recipient.endpointId, kEndpointInfos[1].id);
   EXPECT_EQ(messageFromCallback2.messageType, 1);
   EXPECT_EQ(messageFromCallback2.messagePermissions, 0);
-  EXPECT_EQ(messageFromCallback2.length, kMessageSize);
+  EXPECT_EQ(messageFromCallback2.data.size(), kMessageSize);
   for (size_t i = 0; i < kMessageSize; ++i) {
     EXPECT_EQ(messageFromCallback2.data[i], static_cast<std::byte>(i + 1));
   }
@@ -860,7 +1540,7 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
                                                std::move(freeCallbackContext2));
   ASSERT_NE(data.get(), nullptr);
 
-  ASSERT_TRUE(messageHub2->sendMessage(std::move(data), kMessageSize,
+  ASSERT_TRUE(messageHub2->sendMessage(std::move(data),
                                        /* messageType= */ 2,
                                        /* messagePermissions= */ 3, sessionId));
   EXPECT_EQ(messageFromCallback1.sessionId, sessionId);
@@ -870,7 +1550,7 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
   EXPECT_EQ(messageFromCallback1.recipient.endpointId, kEndpointInfos[0].id);
   EXPECT_EQ(messageFromCallback1.messageType, 2);
   EXPECT_EQ(messageFromCallback1.messagePermissions, 3);
-  EXPECT_EQ(messageFromCallback1.length, kMessageSize);
+  EXPECT_EQ(messageFromCallback1.data.size(), kMessageSize);
   for (size_t i = 0; i < kMessageSize; ++i) {
     EXPECT_EQ(messageFromCallback1.data[i], static_cast<std::byte>(i + 1));
   }
@@ -885,8 +1565,9 @@ TEST_F(MessageRouterTest, SendMessageToSessionUsingPointerAndFreeCallback) {
 TEST_F(MessageRouterTest, SendMessageToSessionInvalidHubAndSession) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   constexpr size_t kMessageSize = 5;
+  pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
   pw::UniquePtr<std::byte[]> messageData =
-      mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+      allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
@@ -897,12 +1578,15 @@ TEST_F(MessageRouterTest, SendMessageToSessionInvalidHubAndSession) {
   Session sessionFromCallback1;
   Session sessionFromCallback2;
   Session sessionFromCallback3;
-  MessageHubCallbackStoreData callback(&messageFromCallback1,
-                                       &sessionFromCallback1);
-  MessageHubCallbackStoreData callback2(&messageFromCallback2,
-                                        &sessionFromCallback2);
-  MessageHubCallbackStoreData callback3(&messageFromCallback3,
-                                        &sessionFromCallback3);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback1,
+                                                      &sessionFromCallback1);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback2,
+                                                      &sessionFromCallback2);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback3 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(&messageFromCallback3,
+                                                      &sessionFromCallback3);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
@@ -918,27 +1602,30 @@ TEST_F(MessageRouterTest, SendMessageToSessionInvalidHubAndSession) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Open session from messageHub2:2 to messageHub3:3
   SessionId sessionId2 = messageHub2->openSession(
       kEndpointInfos[1].id, messageHub3->getId(), kEndpointInfos[2].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub3->onSessionOpenComplete(sessionId2);
 
   // Open session from messageHub3:3 to messageHub1:1
   SessionId sessionId3 = messageHub3->openSession(
       kEndpointInfos[2].id, messageHub->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub->onSessionOpenComplete(sessionId3);
 
   // Send message from messageHub:1 to messageHub2:2
-  EXPECT_FALSE(messageHub->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_FALSE(messageHub->sendMessage(std::move(messageData),
                                        /* messageType= */ 1,
                                        /* messagePermissions= */ 0,
                                        sessionId2));
-  EXPECT_FALSE(messageHub2->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_FALSE(messageHub2->sendMessage(std::move(messageData),
                                         /* messageType= */ 2,
                                         /* messagePermissions= */ 3,
                                         sessionId3));
-  EXPECT_FALSE(messageHub3->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_FALSE(messageHub3->sendMessage(std::move(messageData),
                                         /* messageType= */ 2,
                                         /* messagePermissions= */ 3,
                                         sessionId));
@@ -947,8 +1634,9 @@ TEST_F(MessageRouterTest, SendMessageToSessionInvalidHubAndSession) {
 TEST_F(MessageRouterTest, SendMessageToSessionCallbackFailureClosesSession) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   constexpr size_t kMessageSize = 5;
+  pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
   pw::UniquePtr<std::byte[]> messageData =
-      mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+      allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
@@ -956,15 +1644,18 @@ TEST_F(MessageRouterTest, SendMessageToSessionCallbackFailureClosesSession) {
   bool wasMessageReceivedCalled1 = false;
   bool wasMessageReceivedCalled2 = false;
   bool wasMessageReceivedCalled3 = false;
-  MessageHubCallbackAlwaysFails callback1(
-      &wasMessageReceivedCalled1,
-      /* wasSessionClosedCalled= */ nullptr);
-  MessageHubCallbackAlwaysFails callback2(
-      &wasMessageReceivedCalled2,
-      /* wasSessionClosedCalled= */ nullptr);
-  MessageHubCallbackAlwaysFails callback3(
-      &wasMessageReceivedCalled3,
-      /* wasSessionClosedCalled= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackAlwaysFails> callback1 =
+      pw::MakeRefCounted<MessageHubCallbackAlwaysFails>(
+          &wasMessageReceivedCalled1,
+          /* wasSessionClosedCalled= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackAlwaysFails> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackAlwaysFails>(
+          &wasMessageReceivedCalled2,
+          /* wasSessionClosedCalled= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackAlwaysFails> callback3 =
+      pw::MakeRefCounted<MessageHubCallbackAlwaysFails>(
+          &wasMessageReceivedCalled3,
+          /* wasSessionClosedCalled= */ nullptr);
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback1);
@@ -980,16 +1671,19 @@ TEST_F(MessageRouterTest, SendMessageToSessionCallbackFailureClosesSession) {
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Open session from messageHub2:2 to messageHub3:3
   SessionId sessionId2 = messageHub2->openSession(
       kEndpointInfos[1].id, messageHub3->getId(), kEndpointInfos[2].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub3->onSessionOpenComplete(sessionId2);
 
   // Open session from messageHub3:3 to messageHub1:1
   SessionId sessionId3 = messageHub3->openSession(
       kEndpointInfos[2].id, messageHub->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub->onSessionOpenComplete(sessionId3);
 
   // Send message from messageHub2:2 to messageHub3:3
   EXPECT_FALSE(wasMessageReceivedCalled1);
@@ -999,7 +1693,7 @@ TEST_F(MessageRouterTest, SendMessageToSessionCallbackFailureClosesSession) {
   EXPECT_TRUE(messageHub2->getSessionWithId(sessionId2).has_value());
   EXPECT_TRUE(messageHub3->getSessionWithId(sessionId2).has_value());
 
-  EXPECT_FALSE(messageHub2->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_FALSE(messageHub2->sendMessage(std::move(messageData),
                                         /* messageType= */ 1,
                                         /* messagePermissions= */ 0,
                                         sessionId2));
@@ -1014,19 +1708,19 @@ TEST_F(MessageRouterTest, SendMessageToSessionCallbackFailureClosesSession) {
   wasMessageReceivedCalled1 = false;
   wasMessageReceivedCalled2 = false;
   wasMessageReceivedCalled3 = false;
-  messageData = mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+  messageData = allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
-  EXPECT_FALSE(messageHub2->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_FALSE(messageHub2->sendMessage(std::move(messageData),
                                         /* messageType= */ 1,
                                         /* messagePermissions= */ 0,
                                         sessionId2));
-  messageData = mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+  messageData = allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
-  EXPECT_FALSE(messageHub3->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_FALSE(messageHub3->sendMessage(std::move(messageData),
                                         /* messageType= */ 1,
                                         /* messagePermissions= */ 0,
                                         sessionId2));
@@ -1038,55 +1732,65 @@ TEST_F(MessageRouterTest, SendMessageToSessionCallbackFailureClosesSession) {
 TEST_F(MessageRouterTest, MessageHubCallbackCanCallOtherMessageHubAPIs) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
   constexpr size_t kMessageSize = 5;
+  pw::allocator::LibCAllocator allocator = pw::allocator::GetLibCAllocator();
   pw::UniquePtr<std::byte[]> messageData =
-      mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+      allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
 
-  MessageHubCallbackCallsMessageHubApisDuringCallback callback;
-  MessageHubCallbackCallsMessageHubApisDuringCallback callback2;
-  MessageHubCallbackCallsMessageHubApisDuringCallback callback3;
+  pw::IntrusivePtr<MessageHubCallbackCallsMessageHubApisDuringCallback>
+      callback = pw::MakeRefCounted<
+          MessageHubCallbackCallsMessageHubApisDuringCallback>();
+  pw::IntrusivePtr<MessageHubCallbackCallsMessageHubApisDuringCallback>
+      callback2 = pw::MakeRefCounted<
+          MessageHubCallbackCallsMessageHubApisDuringCallback>();
+  pw::IntrusivePtr<MessageHubCallbackCallsMessageHubApisDuringCallback>
+      callback3 = pw::MakeRefCounted<
+          MessageHubCallbackCallsMessageHubApisDuringCallback>();
 
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub.has_value());
-  callback.setMessageHub(&messageHub.value());
+  callback->setMessageHub(&messageHub.value());
   std::optional<MessageRouter::MessageHub> messageHub2 =
       router.registerMessageHub("hub2", /* id= */ 2, callback2);
   EXPECT_TRUE(messageHub2.has_value());
-  callback2.setMessageHub(&messageHub2.value());
+  callback2->setMessageHub(&messageHub2.value());
   std::optional<MessageRouter::MessageHub> messageHub3 =
       router.registerMessageHub("hub3", /* id= */ 3, callback3);
   EXPECT_TRUE(messageHub3.has_value());
-  callback3.setMessageHub(&messageHub3.value());
+  callback3->setMessageHub(&messageHub3.value());
 
   // Open session from messageHub:1 to messageHub2:2
   SessionId sessionId = messageHub->openSession(
       kEndpointInfos[0].id, messageHub2->getId(), kEndpointInfos[1].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub2->onSessionOpenComplete(sessionId);
 
   // Open session from messageHub2:2 to messageHub3:3
   SessionId sessionId2 = messageHub2->openSession(
       kEndpointInfos[1].id, messageHub3->getId(), kEndpointInfos[2].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub3->onSessionOpenComplete(sessionId2);
 
   // Open session from messageHub3:3 to messageHub1:1
   SessionId sessionId3 = messageHub3->openSession(
       kEndpointInfos[2].id, messageHub->getId(), kEndpointInfos[0].id);
   EXPECT_NE(sessionId, SESSION_ID_INVALID);
+  messageHub->onSessionOpenComplete(sessionId3);
 
   // Send message from messageHub:1 to messageHub2:2
-  EXPECT_TRUE(messageHub->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_TRUE(messageHub->sendMessage(std::move(messageData),
                                       /* messageType= */ 1,
                                       /* messagePermissions= */ 0, sessionId));
 
   // Send message from messageHub2:2 to messageHub:1
-  messageData = mAllocator.MakeUniqueArray<std::byte>(kMessageSize);
+  messageData = allocator.MakeUniqueArray<std::byte>(kMessageSize);
   for (size_t i = 0; i < 5; ++i) {
     messageData[i] = static_cast<std::byte>(i + 1);
   }
-  EXPECT_TRUE(messageHub2->sendMessage(std::move(messageData), kMessageSize,
+  EXPECT_TRUE(messageHub2->sendMessage(std::move(messageData),
                                        /* messageType= */ 2,
                                        /* messagePermissions= */ 3, sessionId));
 
@@ -1101,8 +1805,9 @@ TEST_F(MessageRouterTest, MessageHubCallbackCanCallOtherMessageHubAPIs) {
 
 TEST_F(MessageRouterTest, ForEachEndpointOfHub) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub.has_value());
@@ -1129,8 +1834,9 @@ TEST_F(MessageRouterTest, ForEachEndpoint) {
   constexpr MessageHubId kHubId = 1;
 
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub(kHubName, kHubId, callback);
   EXPECT_TRUE(messageHub.has_value());
@@ -1156,8 +1862,9 @@ TEST_F(MessageRouterTest, ForEachEndpoint) {
 
 TEST_F(MessageRouterTest, ForEachEndpointOfHubInvalidHub) {
   MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
-  MessageHubCallbackStoreData callback(/* message= */ nullptr,
-                                       /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
   std::optional<MessageRouter::MessageHub> messageHub =
       router.registerMessageHub("hub1", /* id= */ 1, callback);
   EXPECT_TRUE(messageHub.has_value());
@@ -1171,5 +1878,122 @@ TEST_F(MessageRouterTest, ForEachEndpointOfHubInvalidHub) {
   EXPECT_EQ(endpoints.size(), 0);
 }
 
+TEST_F(MessageRouterTest, RegisterEndpointCallbacksAreCalled) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub.has_value());
+
+  // Register the endpoint and verify that the callbacks were called
+  EXPECT_TRUE(messageHub->registerEndpoint(kEndpointInfos[0].id));
+  EXPECT_TRUE(callback2->hasEndpointBeenRegistered(messageHub->getId(),
+                                                   kEndpointInfos[0].id));
+}
+
+TEST_F(MessageRouterTest, UnregisterEndpointCallbacksAreCalled) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  pw::IntrusivePtr<MessageHubCallbackStoreData> callback2 =
+      pw::MakeRefCounted<MessageHubCallbackStoreData>(/* message= */ nullptr,
+                                                      /* session= */ nullptr);
+  std::optional<MessageRouter::MessageHub> messageHub =
+      router.registerMessageHub("hub1", /* id= */ 1, callback);
+  EXPECT_TRUE(messageHub.has_value());
+  std::optional<MessageRouter::MessageHub> messageHub2 =
+      router.registerMessageHub("hub2", /* id= */ 2, callback2);
+  EXPECT_TRUE(messageHub.has_value());
+
+  // Register the endpoint and verify that the callbacks were called
+  // only on the other hub
+  EXPECT_TRUE(messageHub->registerEndpoint(kEndpointInfos[0].id));
+  EXPECT_FALSE(callback->hasEndpointBeenRegistered(messageHub->getId(),
+                                                   kEndpointInfos[0].id));
+  EXPECT_TRUE(callback2->hasEndpointBeenRegistered(messageHub->getId(),
+                                                   kEndpointInfos[0].id));
+
+  // Unregister the endpoint and verify that the callbacks were called
+  // only on the other hub
+  EXPECT_TRUE(messageHub->unregisterEndpoint(kEndpointInfos[0].id));
+  EXPECT_FALSE(callback->hasEndpointBeenRegistered(messageHub->getId(),
+                                                   kEndpointInfos[0].id));
+  EXPECT_FALSE(callback2->hasEndpointBeenRegistered(messageHub->getId(),
+                                                    kEndpointInfos[0].id));
+}
+
+MATCHER_P(HubMatcher, id, "Matches id in MessageHubInfo") {
+  return arg.id == id;
+}
+
+TEST_F(MessageRouterTest, OnRegisterAndUnregisterHub) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  pw::IntrusivePtr<MockMessageHubCallback> hub1Callback =
+      pw::MakeRefCounted<MockMessageHubCallback>();
+  pw::IntrusivePtr<MockMessageHubCallback> hub2Callback =
+      pw::MakeRefCounted<MockMessageHubCallback>();
+  MessageHubId hub1Id = 1, hub2Id = 2;
+  std::optional<MessageRouter::MessageHub> hub1 =
+      router.registerMessageHub("hub1", hub1Id, hub1Callback);
+  ASSERT_TRUE(hub1.has_value());
+
+  EXPECT_CALL(*hub1Callback, onHubRegistered(HubMatcher(hub2Id)));
+  std::optional<MessageRouter::MessageHub> hub2 =
+      router.registerMessageHub("hub2", hub2Id, hub2Callback);
+  ASSERT_TRUE(hub2.has_value());
+
+  EXPECT_CALL(*hub1Callback, onHubUnregistered(hub2Id));
+  hub2.reset();
+}
+
+MATCHER_P(SessionIdMatcher, id, "Matches id in Session") {
+  return arg.sessionId == id;
+}
+
+TEST_F(MessageRouterTest, SessionCallbacksAreCalledOnceSameHub) {
+  MessageRouterWithStorage<kMaxMessageHubs, kMaxSessions> router;
+  pw::IntrusivePtr<MockMessageHubCallback> hub1Callback =
+      pw::MakeRefCounted<MockMessageHubCallback>();
+  MessageHubId hub1Id = 1;
+  std::optional<MessageRouter::MessageHub> hub1 =
+      router.registerMessageHub("hub1", hub1Id, hub1Callback);
+  ASSERT_TRUE(hub1.has_value());
+
+  ON_CALL(*hub1Callback, forEachEndpoint).WillByDefault(forEachEndpoint);
+
+  // Try with different endpoints
+  SessionId sessionId = hub1->openSession(kEndpointInfos[0].id, hub1->getId(),
+                                          kEndpointInfos[1].id);
+  ASSERT_NE(sessionId, SESSION_ID_INVALID);
+
+  EXPECT_CALL(*hub1Callback, onSessionOpened(_)).Times(1);
+  hub1->onSessionOpenComplete(sessionId);
+
+  EXPECT_CALL(*hub1Callback, onSessionClosed(SessionIdMatcher(sessionId), _))
+      .Times(1);
+  hub1->closeSession(sessionId);
+
+  // Try with the same endpoint
+  SessionId sessionId2 = hub1->openSession(kEndpointInfos[1].id, hub1->getId(),
+                                           kEndpointInfos[1].id);
+  ASSERT_NE(sessionId2, SESSION_ID_INVALID);
+
+  EXPECT_CALL(*hub1Callback, onSessionOpened(_)).Times(1);
+  hub1->onSessionOpenComplete(sessionId2);
+
+  EXPECT_CALL(*hub1Callback, onSessionClosed(SessionIdMatcher(sessionId2), _))
+      .Times(1);
+  hub1->closeSession(sessionId2);
+}
+
 }  // namespace
 }  // namespace chre::message
diff --git a/util/tests/service_helpers_test.cc b/util/tests/service_helpers_test.cc
new file mode 100644
index 00000000..0824509d
--- /dev/null
+++ b/util/tests/service_helpers_test.cc
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "chre/util/system/service_helpers.h"
+#include "gtest/gtest.h"
+
+namespace chre::message {
+namespace {
+
+TEST(ServiceHelpersTest, ExtractNanoappIdAndServiceId_NullServiceDescriptor) {
+  uint64_t nanoappId;
+  uint64_t serviceId;
+  EXPECT_FALSE(extractNanoappIdAndServiceId(nullptr, nanoappId, serviceId));
+}
+
+TEST(ServiceHelpersTest, ExtractNanoappIdAndServiceId_InvalidPrefix) {
+  uint64_t nanoappId;
+  uint64_t serviceId;
+  EXPECT_FALSE(
+      extractNanoappIdAndServiceId("invalid_prefix", nanoappId, serviceId));
+}
+
+TEST(ServiceHelpersTest, ExtractNanoappIdAndServiceId_MissingSeparator) {
+  uint64_t nanoappId;
+  uint64_t serviceId;
+  EXPECT_FALSE(extractNanoappIdAndServiceId("chre.nanoapp_0x1234567890ABCDEF",
+                                            nanoappId, serviceId));
+}
+
+TEST(ServiceHelpersTest, ExtractNanoappIdAndServiceId_InvalidEncodingLength) {
+  uint64_t nanoappId;
+  uint64_t serviceId;
+  EXPECT_FALSE(extractNanoappIdAndServiceId(
+      "chre.nanoapp_0x1234567890ABCDEF.service_0x1234567890ABCDE", nanoappId,
+      serviceId));
+
+  EXPECT_FALSE(extractNanoappIdAndServiceId(
+      "chre.nanoapp_0x1234567890ABCDE.service_0x1234567890ABCDEF", nanoappId,
+      serviceId));
+
+  EXPECT_FALSE(extractNanoappIdAndServiceId("chre.nanoapp_0x0.service_0x1",
+                                            nanoappId, serviceId));
+
+  EXPECT_FALSE(extractNanoappIdAndServiceId("chre.nanoapp_0x.service_0x",
+                                            nanoappId, serviceId));
+
+  EXPECT_FALSE(extractNanoappIdAndServiceId(
+      "chre.nanoapp_0x1234567890ABCDEF.service_0x", nanoappId, serviceId));
+
+  EXPECT_FALSE(extractNanoappIdAndServiceId(
+      "chre.nanoapp_0x.service_0x1234567890ABCDEF", nanoappId, serviceId));
+}
+
+TEST(ServiceHelpersTest, ExtractNanoappIdAndServiceId_Success) {
+  uint64_t nanoappId;
+  uint64_t serviceId;
+  EXPECT_TRUE(extractNanoappIdAndServiceId(
+      "chre.nanoapp_0x1234567890ABCDEF.service_0x1234567890ABCDEF", nanoappId,
+      serviceId));
+  EXPECT_EQ(nanoappId, 0x1234567890ABCDEF);
+  EXPECT_EQ(serviceId, 0x1234567890ABCDEF);
+
+  EXPECT_TRUE(extractNanoappIdAndServiceId(
+      "chre.nanoapp_0xDEADBEEFCAFECAFE.service_0xCAFECAFECAFECAFE", nanoappId,
+      serviceId));
+  EXPECT_EQ(nanoappId, 0xDEADBEEFCAFECAFE);
+  EXPECT_EQ(serviceId, 0xCAFECAFECAFECAFE);
+}
+
+}  // namespace
+}  // namespace chre::message
diff --git a/util/tests/transaction_manager_test.cc b/util/tests/transaction_manager_test.cc
index 7df617b2..4a6f93f7 100644
--- a/util/tests/transaction_manager_test.cc
+++ b/util/tests/transaction_manager_test.cc
@@ -19,9 +19,9 @@
 #include <algorithm>
 #include <map>
 
-#include "chre/core/event_loop_common.h"
 #include "chre/core/timer_pool.h"
 #include "chre/platform/linux/system_time.h"
+#include "chre/util/system/system_callback_type.h"
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
diff --git a/util/util.mk b/util/util.mk
index 4e5cd1e0..74d95157 100644
--- a/util/util.mk
+++ b/util/util.mk
@@ -10,6 +10,7 @@ PIGWEED_CHRE_DIR = $(ANDROID_BUILD_TOP)/system/chre/external/pigweed
 # Common Compiler Flags ########################################################
 
 # Include paths.
+COMMON_CFLAGS += -I$(CHRE_PREFIX)/core/include
 COMMON_CFLAGS += -I$(CHRE_PREFIX)/util/include
 
 # Pigweed ######################################################################
@@ -18,18 +19,24 @@ COMMON_CFLAGS += -I$(PIGWEED_CHRE_DIR)/pw_log_nanoapp/public_overrides
 COMMON_CFLAGS += -I$(PIGWEED_CHRE_DIR)/pw_assert_nanoapp/public_overrides
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_allocator/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_assert/public
+COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_bytes/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_containers/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_function/public
+COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_intrusive_ptr/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_log/public
+COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_numeric/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_polyfill/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_preprocessor/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_result/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_span/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_status/public
+COMMON_CFLAGS += -I$(PIGWEED_DIR)/pw_toolchain/public
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/third_party/fuchsia/repo/sdk/lib/fit/include
 COMMON_CFLAGS += -I$(PIGWEED_DIR)/third_party/fuchsia/repo/sdk/lib/stdcompat/include
 
-COMMON_SRCS += $(PIGWEED_DIR)/pw_allocator/unique_ptr.cc
+COMMON_SRCS += $(PIGWEED_DIR)/pw_allocator/allocator.cc
+COMMON_SRCS += $(PIGWEED_DIR)/pw_allocator/managed_ptr.cc
+COMMON_SRCS += $(PIGWEED_DIR)/pw_containers/intrusive_item.cc
 
 # Common Source Files ##########################################################
 
@@ -45,9 +52,11 @@ COMMON_SRCS += $(CHRE_PREFIX)/util/nanoapp/debug.cc
 COMMON_SRCS += $(CHRE_PREFIX)/util/nanoapp/string.cc
 COMMON_SRCS += $(CHRE_PREFIX)/util/nanoapp/wifi.cc
 COMMON_SRCS += $(CHRE_PREFIX)/util/system/ble_util.cc
+COMMON_SRCS += $(CHRE_PREFIX)/util/system/error_util.cc
 COMMON_SRCS += $(CHRE_PREFIX)/util/system/event_callbacks.cc
 COMMON_SRCS += $(CHRE_PREFIX)/util/system/debug_dump.cc
 COMMON_SRCS += $(CHRE_PREFIX)/util/system/message_router.cc
+COMMON_SRCS += $(CHRE_PREFIX)/util/system/service_helpers.cc
 
 # GoogleTest Source Files ######################################################
 
```

