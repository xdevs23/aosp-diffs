```diff
diff --git a/METADATA b/METADATA
deleted file mode 100644
index d97975ca..00000000
--- a/METADATA
+++ /dev/null
@@ -1,3 +0,0 @@
-third_party {
-  license_type: NOTICE
-}
diff --git a/ext4_utils/Android.bp b/ext4_utils/Android.bp
index 4db055bd..7195a855 100644
--- a/ext4_utils/Android.bp
+++ b/ext4_utils/Android.bp
@@ -72,13 +72,6 @@ python_binary_host {
         "mke2fs.conf",
     ],
 
-    version: {
-        py3: {
-            enabled: true,
-            embedded_launcher: true,
-        },
-    },
-
     required: [
         "mke2fs",
         "e2fsdroid",
diff --git a/libatrace_rust/Android.bp b/libatrace_rust/Android.bp
index e08ca1e0..5481a644 100644
--- a/libatrace_rust/Android.bp
+++ b/libatrace_rust/Android.bp
@@ -10,7 +10,7 @@ rust_defaults {
         "libtracing",
         "libtracing_subscriber",
     ],
-    min_sdk_version: "35",
+    min_sdk_version: "34",
 }
 
 rust_library {
@@ -44,7 +44,7 @@ rust_defaults {
         "libstatic_assertions",
         "libbitflags",
     ],
-    min_sdk_version: "35",
+    min_sdk_version: "34",
 }
 
 rust_library {
@@ -81,7 +81,7 @@ rust_bindgen {
         "--allowlist-var=atrace_.*",
     ],
     shared_libs: ["libcutils"],
-    static_libs: ["libcutils_trace_bindgen_wrap"],
+    whole_static_libs: ["libcutils_trace_bindgen_wrap"],
     // Host support is for unit tests.
     host_supported: true,
     product_available: true,
@@ -90,7 +90,7 @@ rust_bindgen {
         "//apex_available:platform",
         "//apex_available:anyapex",
     ],
-    min_sdk_version: "35",
+    min_sdk_version: "34",
 }
 
 // TODO: b/291544011 - Replace with autogenerated wrappers once they are supported.
@@ -107,5 +107,5 @@ cc_library_static {
         "//apex_available:platform",
         "//apex_available:anyapex",
     ],
-    min_sdk_version: "35",
+    min_sdk_version: "34",
 }
diff --git a/memory_replay/Alloc.cpp b/memory_replay/Alloc.cpp
index e97dca0a..26606426 100644
--- a/memory_replay/Alloc.cpp
+++ b/memory_replay/Alloc.cpp
@@ -31,6 +31,7 @@ bool AllocDoesFree(const memory_trace::Entry& entry) {
     case memory_trace::CALLOC:
     case memory_trace::MEMALIGN:
     case memory_trace::THREAD_DONE:
+    case memory_trace::UNKNOWN:
       return false;
 
     case memory_trace::FREE:
@@ -45,7 +46,7 @@ static uint64_t MallocExecute(const memory_trace::Entry& entry, Pointers* pointe
   int pagesize = getpagesize();
   uint64_t time_nsecs = Nanotime();
   void* memory = malloc(entry.size);
-  MakeAllocationResident(memory, entry.size, pagesize);
+  MakeAllocationResident(memory, entry.size, entry.present_bytes, pagesize);
   time_nsecs = Nanotime() - time_nsecs;
 
   pointers->Add(entry.ptr, memory);
@@ -57,7 +58,7 @@ static uint64_t CallocExecute(const memory_trace::Entry& entry, Pointers* pointe
   int pagesize = getpagesize();
   uint64_t time_nsecs = Nanotime();
   void* memory = calloc(entry.u.n_elements, entry.size);
-  MakeAllocationResident(memory, entry.u.n_elements * entry.size, pagesize);
+  MakeAllocationResident(memory, entry.u.n_elements * entry.size, entry.present_bytes, pagesize);
   time_nsecs = Nanotime() - time_nsecs;
 
   pointers->Add(entry.ptr, memory);
@@ -74,7 +75,7 @@ static uint64_t ReallocExecute(const memory_trace::Entry& entry, Pointers* point
   int pagesize = getpagesize();
   uint64_t time_nsecs = Nanotime();
   void* memory = realloc(old_memory, entry.size);
-  MakeAllocationResident(memory, entry.size, pagesize);
+  MakeAllocationResident(memory, entry.size, entry.present_bytes, pagesize);
   time_nsecs = Nanotime() - time_nsecs;
 
   pointers->Add(entry.ptr, memory);
@@ -86,7 +87,7 @@ static uint64_t MemalignExecute(const memory_trace::Entry& entry, Pointers* poin
   int pagesize = getpagesize();
   uint64_t time_nsecs = Nanotime();
   void* memory = memalign(entry.u.align, entry.size);
-  MakeAllocationResident(memory, entry.size, pagesize);
+  MakeAllocationResident(memory, entry.size, entry.present_bytes, pagesize);
   time_nsecs = Nanotime() - time_nsecs;
 
   pointers->Add(entry.ptr, memory);
diff --git a/memory_replay/Android.bp b/memory_replay/Android.bp
index c75218fe..c5c6909b 100644
--- a/memory_replay/Android.bp
+++ b/memory_replay/Android.bp
@@ -91,7 +91,7 @@ cc_library_static {
 cc_binary {
     name: "memory_replay",
     defaults: ["memory_replay_defaults"],
-    host_supported: false,
+    host_supported: true,
 
     srcs: ["main.cpp"],
 
@@ -108,6 +108,15 @@ cc_binary {
             suffix: "64",
         },
     },
+
+    target: {
+        host: {
+            // Keep debug information for host executables.
+            strip: {
+                none: true,
+            },
+        },
+    },
 }
 
 cc_binary_host {
diff --git a/memory_replay/File.cpp b/memory_replay/File.cpp
index 4983b4de..d60ed659 100644
--- a/memory_replay/File.cpp
+++ b/memory_replay/File.cpp
@@ -18,11 +18,13 @@
 #include <errno.h>
 #include <stdint.h>
 #include <sys/mman.h>
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
 
 #include <string>
+#include <unordered_map>
 
 #include <android-base/file.h>
 #include <android-base/strings.h>
@@ -75,6 +77,53 @@ static void WaitPid(pid_t pid) {
   }
 }
 
+static void UpdatePresentBytes(std::unordered_map<uint64_t, memory_trace::Entry*>& entries_by_ptr,
+                               memory_trace::Entry* entry) {
+  switch (entry->type) {
+    case memory_trace::FREE:
+      if (entry->present_bytes != -1) {
+        // Need to find the pointer for this free and update the present bytes
+        // on the original pointer.
+        auto iter = entries_by_ptr.find(entry->ptr);
+        if (iter != entries_by_ptr.end()) {
+          // Present bytes can be larger than the recorded size when the
+          // real size returned by malloc_usable_size is greater than that.
+          // Therefore, always choose the smaller of the two.
+          iter->second->present_bytes =
+              MIN(entry->present_bytes, static_cast<int64_t>(iter->second->size));
+          entries_by_ptr.erase(entry->ptr);
+        }
+      }
+      break;
+    case memory_trace::CALLOC:
+    case memory_trace::MALLOC:
+    case memory_trace::MEMALIGN:
+      entries_by_ptr[entry->ptr] = entry;
+      break;
+
+    case memory_trace::REALLOC:
+      if (entry->ptr != 0) {
+        entries_by_ptr[entry->ptr] = entry;
+      }
+      if (entry->u.old_ptr != 0 && entry->present_bytes != -1) {
+        // The old pointer got freed, so add it that way.
+        auto iter = entries_by_ptr.find(entry->u.old_ptr);
+        if (iter != entries_by_ptr.end()) {
+          // Present bytes can be larger than the recorded size when the
+          // real size returned by malloc_usable_size is greater than that.
+          // Therefore, always choose the smaller of the two.
+          iter->second->present_bytes =
+              MIN(entry->present_bytes, static_cast<int64_t>(iter->second->size));
+          entries_by_ptr.erase(entry->u.old_ptr);
+          entry->present_bytes = -1;
+        }
+      }
+      break;
+    default:
+      break;
+  }
+}
+
 // This function should not do any memory allocations in the main function.
 // Any true allocation should happen in fork'd code.
 void GetUnwindInfo(const char* filename, memory_trace::Entry** entries, size_t* num_entries) {
@@ -142,6 +191,7 @@ void GetUnwindInfo(const char* filename, memory_trace::Entry** entries, size_t*
       errx(1, "Contents of zip file %s is empty.", filename);
     }
 
+    std::unordered_map<uint64_t, memory_trace::Entry*> entries_by_ptr;
     size_t entry_idx = 0;
     size_t start_str = 0;
     size_t end_str = 0;
@@ -154,12 +204,17 @@ void GetUnwindInfo(const char* filename, memory_trace::Entry** entries, size_t*
         errx(1, "Too many entries, stopped at entry %zu", entry_idx);
       }
       contents[end_str] = '\0';
+
       std::string error;
-      if (!memory_trace::FillInEntryFromString(&contents[start_str], (*entries)[entry_idx++],
-                                               error)) {
+      memory_trace::Entry* entry = &(*entries)[entry_idx++];
+      if (!memory_trace::FillInEntryFromString(&contents[start_str], *entry, error)) {
         errx(1, "%s", error.c_str());
       }
       start_str = end_str + 1;
+
+      // If this operation does a free, set the present_bytes on the original
+      // allocation.
+      UpdatePresentBytes(entries_by_ptr, entry);
     }
     if (entry_idx != *num_entries) {
       errx(1, "Mismatched number of entries found: expected %zu, found %zu", *num_entries,
diff --git a/memory_replay/MemoryTrace.cpp b/memory_replay/MemoryTrace.cpp
index e6d21dfc..8d1089c5 100644
--- a/memory_replay/MemoryTrace.cpp
+++ b/memory_replay/MemoryTrace.cpp
@@ -48,6 +48,11 @@ bool FillInEntryFromString(const std::string& line, Entry& entry, std::string& e
     return false;
   }
 
+  entry.u.old_ptr = 0;
+  entry.present_bytes = -1;
+  entry.start_ns = 0;
+  entry.end_ns = 0;
+
   // Handle each individual type of entry type.
   std::string type(name);
   if (type == "thread_done") {
@@ -68,62 +73,73 @@ bool FillInEntryFromString(const std::string& line, Entry& entry, std::string& e
     return true;
   }
 
+  bool read_present_bytes = false;
   int args_offset = 0;
-  const char* args_beg = &line[op_prefix_pos];
+  const char* args = &line[op_prefix_pos];
   if (type == "malloc") {
     // Format:
     //   TID: malloc POINTER SIZE_OF_ALLOCATION [START_TIME_NS END_TIME_NS]
-    if (sscanf(args_beg, "%zu%n", &entry.size, &args_offset) != 1) {
+    if (sscanf(args, "%zu%n", &entry.size, &args_offset) != 1) {
       error = "Failed to read malloc data: " + line;
       return false;
     }
     entry.type = MALLOC;
   } else if (type == "free") {
     // Format:
-    //   TID: free POINTER [START_TIME_NS END_TIME_NS]
+    //   TID: free POINTER [START_TIME_NS END_TIME_NS] [PRESENT_BYTES]
     entry.type = FREE;
+    read_present_bytes = true;
   } else if (type == "calloc") {
     // Format:
     //   TID: calloc POINTER ITEM_COUNT ITEM_SIZE [START_TIME_NS END_TIME_NS]
-    if (sscanf(args_beg, "%" SCNd64 " %zu%n", &entry.u.n_elements, &entry.size, &args_offset) !=
-        2) {
+    if (sscanf(args, "%" SCNd64 " %zu%n", &entry.u.n_elements, &entry.size, &args_offset) != 2) {
       error = "Failed to read calloc data: " + line;
       return false;
     }
     entry.type = CALLOC;
   } else if (type == "realloc") {
     // Format:
-    //   TID: realloc POINTER OLD_POINTER NEW_SIZE [START_TIME_NS END_TIME_NS]
-    if (sscanf(args_beg, "%" SCNx64 " %zu%n", &entry.u.old_ptr, &entry.size, &args_offset) != 2) {
+    //   TID: realloc POINTER OLD_POINTER NEW_SIZE [START_TIME_NS END_TIME_NS] [PRESENT_BYTES]
+    if (sscanf(args, "%" SCNx64 " %zu%n", &entry.u.old_ptr, &entry.size, &args_offset) != 2) {
       error = "Failed to read realloc data: " + line;
       return false;
     }
+    read_present_bytes = true;
     entry.type = REALLOC;
   } else if (type == "memalign") {
     // Format:
     //   TID: memalign POINTER ALIGNMENT SIZE [START_TIME_NS END_TIME_NS]
-    if (sscanf(args_beg, "%" SCNd64 " %zu%n", &entry.u.align, &entry.size, &args_offset) != 2) {
+    if (sscanf(args, "%" SCNd64 " %zu%n", &entry.u.align, &entry.size, &args_offset) != 2) {
       error = "Failed to read memalign data: " + line;
       return false;
     }
     entry.type = MEMALIGN;
   } else {
-    printf("Unknown type %s: %s\n", type.c_str(), line.c_str());
     error = "Unknown type " + type + ": " + line;
     return false;
   }
 
-  const char* timestamps_beg = &args_beg[args_offset];
-
   // Get the optional timestamps if they exist.
-  int n_match = sscanf(timestamps_beg, "%" SCNd64 " %" SCNd64, &entry.start_ns, &entry.end_ns);
+  args = &args[args_offset];
+  int n_match =
+      sscanf(args, "%" SCNd64 " %" SCNd64 "%n", &entry.start_ns, &entry.end_ns, &args_offset);
   if (n_match == EOF) {
-    entry.start_ns = 0;
-    entry.end_ns = 0;
-  } else if (n_match != 2) {
+    return true;
+  }
+
+  if (n_match != 2) {
     error = "Failed to read timestamps: " + line;
     return false;
   }
+
+  // Get the optional present bytes if it exists.
+  if (read_present_bytes) {
+    n_match = sscanf(&args[args_offset], "%" SCNd64, &entry.present_bytes);
+    if (n_match != EOF && n_match != 1) {
+      error = "Failed to read present bytes: " + line;
+      return false;
+    }
+  }
   return true;
 }
 
@@ -141,8 +157,9 @@ static const char* TypeToName(const TypeEnum type) {
       return "realloc";
     case THREAD_DONE:
       return "thread_done";
+    default:
+      return "unknown";
   }
-  return "unknown";
 }
 
 static size_t FormatEntry(const Entry& entry, char* buffer, size_t buffer_len) {
@@ -152,9 +169,13 @@ static size_t FormatEntry(const Entry& entry, char* buffer, size_t buffer_len) {
     return 0;
   }
   size_t cur_len = len;
+  bool output_present_bytes = false;
   switch (entry.type) {
     case FREE:
       len = 0;
+      if (entry.present_bytes != -1) {
+        output_present_bytes = true;
+      }
       break;
     case CALLOC:
       len = snprintf(&buffer[cur_len], buffer_len - cur_len, " %" PRIu64 " %zu", entry.u.n_elements,
@@ -170,6 +191,9 @@ static size_t FormatEntry(const Entry& entry, char* buffer, size_t buffer_len) {
     case REALLOC:
       len = snprintf(&buffer[cur_len], buffer_len - cur_len, " 0x%" PRIx64 " %zu", entry.u.old_ptr,
                      entry.size);
+      if (entry.present_bytes != -1) {
+        output_present_bytes = true;
+      }
       break;
     case THREAD_DONE:
       // Thread done only has a single optional timestamp, end_ns.
@@ -189,7 +213,7 @@ static size_t FormatEntry(const Entry& entry, char* buffer, size_t buffer_len) {
   }
 
   cur_len += len;
-  if (entry.start_ns == 0) {
+  if (entry.start_ns == 0 && !output_present_bytes) {
     return cur_len;
   }
 
@@ -198,6 +222,16 @@ static size_t FormatEntry(const Entry& entry, char* buffer, size_t buffer_len) {
   if (len < 0) {
     return 0;
   }
+
+  cur_len += len;
+  if (!output_present_bytes) {
+    return cur_len;
+  }
+
+  len = snprintf(&buffer[cur_len], buffer_len - cur_len, " %" PRId64, entry.present_bytes);
+  if (len < 0) {
+    return 0;
+  }
   return cur_len + len;
 }
 
diff --git a/memory_replay/TraceBenchmark.cpp b/memory_replay/TraceBenchmark.cpp
index 16129970..76809941 100644
--- a/memory_replay/TraceBenchmark.cpp
+++ b/memory_replay/TraceBenchmark.cpp
@@ -138,6 +138,7 @@ static void GetTraceData(const std::string& filename, TraceDataType* trace_data)
         }
         break;
       case memory_trace::THREAD_DONE:
+      case memory_trace::UNKNOWN:
         break;
     }
   }
@@ -165,7 +166,7 @@ static void RunTrace(benchmark::State& state, TraceDataType* trace_data) {
         if (ptr == nullptr) {
           errx(1, "malloc returned nullptr");
         }
-        MakeAllocationResident(ptr, entry.size, pagesize);
+        MakeAllocationResident(ptr, entry.size, entry.present_bytes, pagesize);
         total_ns += Nanotime() - start_ns;
 
         if (ptrs[entry.ptr] != nullptr) {
@@ -180,7 +181,7 @@ static void RunTrace(benchmark::State& state, TraceDataType* trace_data) {
         if (ptr == nullptr) {
           errx(1, "calloc returned nullptr");
         }
-        MakeAllocationResident(ptr, entry.size, pagesize);
+        MakeAllocationResident(ptr, entry.size, entry.present_bytes, pagesize);
         total_ns += Nanotime() - start_ns;
 
         if (ptrs[entry.ptr] != nullptr) {
@@ -195,7 +196,7 @@ static void RunTrace(benchmark::State& state, TraceDataType* trace_data) {
         if (ptr == nullptr) {
           errx(1, "memalign returned nullptr");
         }
-        MakeAllocationResident(ptr, entry.size, pagesize);
+        MakeAllocationResident(ptr, entry.size, entry.present_bytes, pagesize);
         total_ns += Nanotime() - start_ns;
 
         if (ptrs[entry.ptr] != nullptr) {
@@ -216,7 +217,7 @@ static void RunTrace(benchmark::State& state, TraceDataType* trace_data) {
           if (ptr == nullptr) {
             errx(1, "realloc returned nullptr");
           }
-          MakeAllocationResident(ptr, entry.size, pagesize);
+          MakeAllocationResident(ptr, entry.size, entry.present_bytes, pagesize);
         }
         total_ns += Nanotime() - start_ns;
 
@@ -239,6 +240,7 @@ static void RunTrace(benchmark::State& state, TraceDataType* trace_data) {
         break;
 
       case memory_trace::THREAD_DONE:
+      case memory_trace::UNKNOWN:
         break;
     }
   }
diff --git a/memory_replay/Utils.h b/memory_replay/Utils.h
index 44ce93ac..d36acd84 100644
--- a/memory_replay/Utils.h
+++ b/memory_replay/Utils.h
@@ -19,15 +19,31 @@
 #include <stdint.h>
 #include <time.h>
 
-static __always_inline uint64_t Nanotime() {
+__attribute__((always_inline))
+static uint64_t Nanotime() {
   struct timespec t = {};
   clock_gettime(CLOCK_MONOTONIC, &t);
   return static_cast<uint64_t>(t.tv_sec) * 1000000000LL + t.tv_nsec;
 }
 
-static __always_inline void MakeAllocationResident(void* ptr, size_t nbytes, int pagesize) {
+__attribute__((always_inline))
+static void MakeAllocationResident(void* ptr, size_t nbytes, int64_t present_bytes,
+                                                   int pagesize) {
+  if (present_bytes != -1 && static_cast<size_t>(present_bytes) < nbytes) {
+    nbytes = present_bytes;
+  }
+
+  size_t start = 0;
+  uintptr_t page_aligned = reinterpret_cast<uintptr_t>(__builtin_align_up(ptr, pagesize));
   uint8_t* data = reinterpret_cast<uint8_t*>(ptr);
-  for (size_t i = 0; i < nbytes; i += pagesize) {
+  if (page_aligned != reinterpret_cast<uintptr_t>(data)) {
+    // Make the first page of the allocation resident.
+    data[0] = 1;
+
+    // Skip to the start of the next page.
+    start = page_aligned - reinterpret_cast<uintptr_t>(ptr);
+  }
+  for (size_t i = start; i < nbytes; i += pagesize) {
     data[i] = 1;
   }
 }
diff --git a/memory_replay/VerifyTrace.cpp b/memory_replay/VerifyTrace.cpp
index 0094940c..f93aa59c 100644
--- a/memory_replay/VerifyTrace.cpp
+++ b/memory_replay/VerifyTrace.cpp
@@ -78,16 +78,21 @@ static void VerifyTrace(const char* trace_file, bool attempt_repair) {
   for (size_t i = 0; i < num_entries; i++) {
     memory_trace::Entry* entry = &entries[i];
 
+    size_t size = 0;
     uint64_t ptr = 0;
     switch (entry->type) {
       case memory_trace::MALLOC:
       case memory_trace::MEMALIGN:
+        size = entry->size;
         ptr = entry->ptr;
         break;
       case memory_trace::CALLOC:
+        size = entry->size * entry->u.n_elements;
         ptr = entry->ptr;
         break;
+        break;
       case memory_trace::REALLOC:
+        size = entry->size;
         if (entry->ptr != 0) {
           ptr = entry->ptr;
         }
@@ -129,54 +134,64 @@ static void VerifyTrace(const char* trace_file, bool attempt_repair) {
         }
         break;
       case memory_trace::THREAD_DONE:
+      case memory_trace::UNKNOWN:
         break;
     }
 
-    if (ptr != 0) {
-      auto old_entry = live_ptrs.find(ptr);
-      if (old_entry != live_ptrs.end()) {
-        printf("  Line %zu: duplicate ptr 0x%" PRIx64 "\n", i + 1, ptr);
-        printf("    Original entry at line %zu:\n", old_entry->second.second);
-        printf("      %s\n", memory_trace::CreateStringFromEntry(*old_entry->second.first).c_str());
-        printf("    Duplicate entry at line %zu:\n", i + 1);
-        printf("      %s\n", memory_trace::CreateStringFromEntry(*entry).c_str());
-        errors_found++;
-        if (attempt_repair) {
-          // There is a small chance of a race where the same pointer is returned
-          // in two different threads before the free is recorded. If this occurs,
-          // the way to repair is to search forward for the free of the pointer and
-          // swap the two entries.
-          bool fixed = false;
-          for (size_t j = i + 1; j < num_entries; j++) {
-            if ((entries[j].type == memory_trace::FREE && entries[j].ptr == ptr) ||
-                (entries[j].type == memory_trace::REALLOC && entries[j].u.old_ptr == ptr)) {
-              memory_trace::Entry tmp_entry = *entry;
-              *entry = entries[j];
-              entries[j] = tmp_entry;
-              errors_repaired++;
-
-              live_ptrs.erase(old_entry);
-              if (entry->type == memory_trace::REALLOC) {
-                if (entry->ptr != 0) {
-                  // Need to add the newly allocated pointer.
-                  live_ptrs[entry->ptr] = std::make_pair(entry, i + 1);
-                }
-                if (erased.first != nullptr) {
-                  // Need to put the erased old ptr back.
-                  live_ptrs[tmp_entry.u.old_ptr] = erased;
-                }
+    if (ptr == 0) {
+      continue;
+    }
+
+    auto old_entry = live_ptrs.find(ptr);
+    if (old_entry != live_ptrs.end()) {
+      printf("  Line %zu: duplicate ptr 0x%" PRIx64 "\n", i + 1, ptr);
+      printf("    Original entry at line %zu:\n", old_entry->second.second);
+      printf("      %s\n", memory_trace::CreateStringFromEntry(*old_entry->second.first).c_str());
+      printf("    Duplicate entry at line %zu:\n", i + 1);
+      printf("      %s\n", memory_trace::CreateStringFromEntry(*entry).c_str());
+      errors_found++;
+      if (attempt_repair) {
+        // There is a small chance of a race where the same pointer is returned
+        // in two different threads before the free is recorded. If this occurs,
+        // the way to repair is to search forward for the free of the pointer and
+        // swap the two entries.
+        bool fixed = false;
+        for (size_t j = i + 1; j < num_entries; j++) {
+          if ((entries[j].type == memory_trace::FREE && entries[j].ptr == ptr) ||
+              (entries[j].type == memory_trace::REALLOC && entries[j].u.old_ptr == ptr)) {
+            memory_trace::Entry tmp_entry = *entry;
+            *entry = entries[j];
+            entries[j] = tmp_entry;
+            errors_repaired++;
+
+            live_ptrs.erase(old_entry);
+            if (entry->type == memory_trace::REALLOC) {
+              if (entry->ptr != 0) {
+                // Need to add the newly allocated pointer.
+                live_ptrs[entry->ptr] = std::make_pair(entry, i + 1);
+              }
+              if (erased.first != nullptr) {
+                // Need to put the erased old ptr back.
+                live_ptrs[tmp_entry.u.old_ptr] = erased;
               }
-              fixed = true;
-              break;
             }
-          }
-          if (!fixed) {
-            printf("  Unable to fix error.\n");
+            fixed = true;
+            break;
           }
         }
-      } else {
-        live_ptrs[ptr] = std::make_pair(entry, i + 1);
+        if (!fixed) {
+          printf("  Unable to fix error.\n");
+        }
       }
+    } else {
+      live_ptrs[ptr] = std::make_pair(entry, i + 1);
+    }
+
+    if (entry->present_bytes != -1 && size != 0 &&
+        static_cast<size_t>(entry->present_bytes) > size) {
+      printf("Line %zu: present bytes %" PRId64 " greater than size %zu\n  %s\n", i + 1,
+             entry->present_bytes, size, memory_trace::CreateStringFromEntry(*entry).c_str());
+      errors_found++;
     }
   }
 
diff --git a/memory_replay/include/memory_trace/MemoryTrace.h b/memory_replay/include/memory_trace/MemoryTrace.h
index 108a9218..f632f11a 100644
--- a/memory_replay/include/memory_trace/MemoryTrace.h
+++ b/memory_replay/include/memory_trace/MemoryTrace.h
@@ -29,6 +29,7 @@ enum TypeEnum : uint8_t {
   REALLOC,
   FREE,
   THREAD_DONE,
+  UNKNOWN,
 };
 
 struct Entry {
@@ -41,6 +42,7 @@ struct Entry {
     uint64_t n_elements;
     uint64_t align;
   } u;
+  int64_t present_bytes = -1;
   uint64_t start_ns = 0;
   uint64_t end_ns = 0;
 };
diff --git a/memory_replay/main.cpp b/memory_replay/main.cpp
index 0f509533..2cffe6e3 100644
--- a/memory_replay/main.cpp
+++ b/memory_replay/main.cpp
@@ -47,6 +47,7 @@ static size_t GetMaxAllocs(const memory_trace::Entry* entries, size_t num_entrie
   for (size_t i = 0; i < num_entries; i++) {
     switch (entries[i].type) {
       case memory_trace::THREAD_DONE:
+      case memory_trace::UNKNOWN:
         break;
       case memory_trace::MALLOC:
       case memory_trace::CALLOC:
@@ -94,7 +95,7 @@ static void PrintLogStats(const char* log_name) {
       }
       // EAGAIN means there is nothing left to read when ANDROID_LOG_NONBLOCK is set.
       if (retval != -EAGAIN) {
-        printf("Failed to read log entry: %s\n", strerrordesc_np(retval));
+        printf("Failed to read log entry: %s\n", strerror(-retval));
       }
       break;
     }
@@ -183,8 +184,10 @@ static void ProcessDump(const memory_trace::Entry* entries, size_t num_entries,
   NativeFormatFloat(buffer, sizeof(buffer), total_nsecs, 1000000000);
   dprintf(STDOUT_FILENO, "Total Allocation/Free Time: %" PRIu64 "ns %ss\n", total_nsecs, buffer);
 
+#if defined(__BIONIC__)
   // Send native allocator stats to the log
   mallopt(M_LOG_STATS, 0);
+#endif
 
   // No need to avoid allocations at this point since all stats have been sent to the log.
   printf("Native Allocator Stats:\n");
diff --git a/memory_replay/tests/FileTest.cpp b/memory_replay/tests/FileTest.cpp
index 5d92c3de..1ffe0d16 100644
--- a/memory_replay/tests/FileTest.cpp
+++ b/memory_replay/tests/FileTest.cpp
@@ -111,3 +111,136 @@ TEST(FileTest, get_unwind_info_bad_file) {
   size_t num_entries;
   EXPECT_DEATH(GetUnwindInfo("/does/not/exist", &entries, &num_entries), "");
 }
+
+TEST(FileTest, present_bytes_updated) {
+  TemporaryFile tf;
+  ASSERT_NE(-1, tf.fd);
+  // Entry 0
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x100, .size = 100}));
+  // Entry 1
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x200, .size = 10}));
+  // Entry 2
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{
+                 .type = memory_trace::MEMALIGN, .ptr = 0x300, .size = 300, .u.align = 16}));
+  // Entry 3
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{
+                 .type = memory_trace::CALLOC, .ptr = 0x400, .size = 400, .u.n_elements = 100}));
+  // Entry 4
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x400, .present_bytes = 400}));
+  // Entry 5
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x100, .present_bytes = 100}));
+  // Entry 6
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x100, .size = 101}));
+  // Entry 7
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x300, .present_bytes = 300}));
+  // Entry 8
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x100, .present_bytes = 101}));
+  // Entry 9
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x700, .size = 1000}));
+  // Enrty 10
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(tf.fd, memory_trace::Entry{.type = memory_trace::REALLOC,
+                                                                      .ptr = 0x800,
+                                                                      .size = 800,
+                                                                      .u.old_ptr = 0x700,
+                                                                      .present_bytes = 700}));
+  // Entry 11
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x800, .present_bytes = 800}));
+  close(tf.fd);
+  tf.fd = -1;
+
+  memory_trace::Entry* entries;
+  size_t num_entries;
+  GetUnwindInfo(tf.path, &entries, &num_entries);
+  EXPECT_EQ(12U, num_entries);
+
+  // Only verify the present bytes values.
+  EXPECT_EQ(100, entries[0].present_bytes);
+  // No free for this allocation.
+  EXPECT_EQ(-1, entries[1].present_bytes);
+  EXPECT_EQ(300, entries[2].present_bytes);
+  EXPECT_EQ(400, entries[3].present_bytes);
+  EXPECT_EQ(400, entries[4].present_bytes);
+  EXPECT_EQ(100, entries[5].present_bytes);
+  EXPECT_EQ(101, entries[6].present_bytes);
+  EXPECT_EQ(300, entries[7].present_bytes);
+  EXPECT_EQ(101, entries[8].present_bytes);
+  EXPECT_EQ(700, entries[9].present_bytes);
+  EXPECT_EQ(800, entries[10].present_bytes);
+  EXPECT_EQ(800, entries[11].present_bytes);
+
+  FreeEntries(entries, num_entries);
+}
+
+TEST(FileTest, present_bytes_reset_realloc) {
+  TemporaryFile tf;
+  ASSERT_NE(-1, tf.fd);
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x100, .size = 200}));
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(tf.fd, memory_trace::Entry{.type = memory_trace::REALLOC,
+                                                                      .ptr = 0x200,
+                                                                      .size = 400,
+                                                                      .u.old_ptr = 0x100,
+                                                                      .present_bytes = 200}));
+
+  memory_trace::Entry* entries;
+  size_t num_entries;
+  GetUnwindInfo(tf.path, &entries, &num_entries);
+  EXPECT_EQ(2U, num_entries);
+
+  // Verify that the present bytes is -1 for the actual realloc since it was
+  // never freed.
+  EXPECT_EQ(200, entries[0].present_bytes);
+  EXPECT_EQ(-1, entries[1].present_bytes);
+
+  FreeEntries(entries, num_entries);
+}
+
+TEST(FileTest, present_bytes_adjusted) {
+  TemporaryFile tf;
+  ASSERT_NE(-1, tf.fd);
+  // Entry 0
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x100, .size = 10}));
+  // Entry 1
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x100, .present_bytes = 30}));
+  // Entry 2
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::MALLOC, .ptr = 0x200, .size = 100}));
+  // Entry 3
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(tf.fd, memory_trace::Entry{.type = memory_trace::REALLOC,
+                                                                      .ptr = 0x300,
+                                                                      .size = 700,
+                                                                      .u.old_ptr = 0x200,
+                                                                      .present_bytes = 200}));
+  // Entry 4
+  ASSERT_TRUE(memory_trace::WriteEntryToFd(
+      tf.fd, memory_trace::Entry{.type = memory_trace::FREE, .ptr = 0x300, .present_bytes = 1000}));
+  close(tf.fd);
+  tf.fd = -1;
+
+  memory_trace::Entry* entries;
+  size_t num_entries;
+  GetUnwindInfo(tf.path, &entries, &num_entries);
+  EXPECT_EQ(5U, num_entries);
+
+  // Only verify the present bytes values.
+  EXPECT_EQ(10, entries[0].present_bytes);
+  EXPECT_EQ(30, entries[1].present_bytes);
+  EXPECT_EQ(100, entries[2].present_bytes);
+  EXPECT_EQ(700, entries[3].present_bytes);
+  EXPECT_EQ(1000, entries[4].present_bytes);
+
+  FreeEntries(entries, num_entries);
+}
diff --git a/memory_replay/tests/MemoryTraceTest.cpp b/memory_replay/tests/MemoryTraceTest.cpp
index 1cdd3e29..4968e4f6 100644
--- a/memory_replay/tests/MemoryTraceTest.cpp
+++ b/memory_replay/tests/MemoryTraceTest.cpp
@@ -34,6 +34,7 @@ TEST(MemoryTraceReadTest, malloc_valid) {
   EXPECT_EQ(0xabd0000U, entry.ptr);
   EXPECT_EQ(20U, entry.size);
   EXPECT_EQ(0U, entry.u.align);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(0U, entry.end_ns);
 
@@ -44,6 +45,7 @@ TEST(MemoryTraceReadTest, malloc_valid) {
   EXPECT_EQ(0xabd0000U, entry.ptr);
   EXPECT_EQ(20U, entry.size);
   EXPECT_EQ(0U, entry.u.align);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(1000U, entry.start_ns);
   EXPECT_EQ(1020U, entry.end_ns);
 }
@@ -77,6 +79,7 @@ TEST(MemoryTraceReadTest, free_valid) {
   EXPECT_EQ(0x5000U, entry.ptr);
   EXPECT_EQ(0U, entry.size);
   EXPECT_EQ(0U, entry.u.align);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(0U, entry.end_ns);
 
@@ -87,6 +90,17 @@ TEST(MemoryTraceReadTest, free_valid) {
   EXPECT_EQ(0x5000U, entry.ptr);
   EXPECT_EQ(0U, entry.size);
   EXPECT_EQ(0U, entry.u.align);
+  EXPECT_EQ(-1, entry.present_bytes);
+  EXPECT_EQ(540U, entry.start_ns);
+  EXPECT_EQ(2000U, entry.end_ns);
+
+  line += " 234";
+  ASSERT_TRUE(memory_trace::FillInEntryFromString(line, entry, error)) << error;
+  EXPECT_EQ(memory_trace::FREE, entry.type);
+  EXPECT_EQ(1235, entry.tid);
+  EXPECT_EQ(0x5000U, entry.ptr);
+  EXPECT_EQ(0U, entry.size);
+  EXPECT_EQ(234, entry.present_bytes);
   EXPECT_EQ(540U, entry.start_ns);
   EXPECT_EQ(2000U, entry.end_ns);
 }
@@ -115,6 +129,7 @@ TEST(MemoryTraceReadTest, calloc_valid) {
   EXPECT_EQ(0x8000U, entry.ptr);
   EXPECT_EQ(30U, entry.size);
   EXPECT_EQ(50U, entry.u.n_elements);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(0U, entry.end_ns);
 
@@ -125,6 +140,7 @@ TEST(MemoryTraceReadTest, calloc_valid) {
   EXPECT_EQ(0x8000U, entry.ptr);
   EXPECT_EQ(30U, entry.size);
   EXPECT_EQ(50U, entry.u.n_elements);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(700U, entry.start_ns);
   EXPECT_EQ(1000U, entry.end_ns);
 }
@@ -163,6 +179,7 @@ TEST(MemoryTraceReadTest, realloc_valid) {
   EXPECT_EQ(0x9000U, entry.ptr);
   EXPECT_EQ(80U, entry.size);
   EXPECT_EQ(0x4000U, entry.u.old_ptr);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(0U, entry.end_ns);
 
@@ -173,6 +190,18 @@ TEST(MemoryTraceReadTest, realloc_valid) {
   EXPECT_EQ(0x9000U, entry.ptr);
   EXPECT_EQ(80U, entry.size);
   EXPECT_EQ(0x4000U, entry.u.old_ptr);
+  EXPECT_EQ(-1, entry.present_bytes);
+  EXPECT_EQ(3999U, entry.start_ns);
+  EXPECT_EQ(10020U, entry.end_ns);
+
+  line += " 50";
+  ASSERT_TRUE(memory_trace::FillInEntryFromString(line, entry, error)) << error;
+  EXPECT_EQ(memory_trace::REALLOC, entry.type);
+  EXPECT_EQ(1237, entry.tid);
+  EXPECT_EQ(0x9000U, entry.ptr);
+  EXPECT_EQ(80U, entry.size);
+  EXPECT_EQ(0x4000U, entry.u.old_ptr);
+  EXPECT_EQ(50, entry.present_bytes);
   EXPECT_EQ(3999U, entry.start_ns);
   EXPECT_EQ(10020U, entry.end_ns);
 }
@@ -211,6 +240,7 @@ TEST(MemoryTraceReadTest, memalign_valid) {
   EXPECT_EQ(0xa000U, entry.ptr);
   EXPECT_EQ(89U, entry.size);
   EXPECT_EQ(16U, entry.u.align);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(0U, entry.end_ns);
 
@@ -221,6 +251,7 @@ TEST(MemoryTraceReadTest, memalign_valid) {
   EXPECT_EQ(0xa000U, entry.ptr);
   EXPECT_EQ(89U, entry.size);
   EXPECT_EQ(16U, entry.u.align);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(900U, entry.start_ns);
   EXPECT_EQ(1000U, entry.end_ns);
 }
@@ -259,6 +290,7 @@ TEST(MemoryTraceReadTest, thread_done_valid) {
   EXPECT_EQ(0U, entry.ptr);
   EXPECT_EQ(0U, entry.size);
   EXPECT_EQ(0U, entry.u.old_ptr);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(0U, entry.end_ns);
 
@@ -269,6 +301,7 @@ TEST(MemoryTraceReadTest, thread_done_valid) {
   EXPECT_EQ(0U, entry.ptr);
   EXPECT_EQ(0U, entry.size);
   EXPECT_EQ(0U, entry.u.old_ptr);
+  EXPECT_EQ(-1, entry.present_bytes);
   EXPECT_EQ(0U, entry.start_ns);
   EXPECT_EQ(290U, entry.end_ns);
 }
@@ -294,6 +327,7 @@ class MemoryTraceOutputTest : public ::testing::Test {
   void WriteAndReadString(const memory_trace::Entry& entry, std::string& str) {
     EXPECT_EQ(lseek(tmp_file_->fd, 0, SEEK_SET), 0);
     EXPECT_TRUE(memory_trace::WriteEntryToFd(tmp_file_->fd, entry));
+    EXPECT_NE(-1, ftruncate(tmp_file_->fd, lseek(tmp_file_->fd, 0, SEEK_CUR)));
     EXPECT_EQ(lseek(tmp_file_->fd, 0, SEEK_SET), 0);
     EXPECT_TRUE(android::base::ReadFdToString(tmp_file_->fd, &str));
   }
@@ -359,6 +393,15 @@ TEST_F(MemoryTraceOutputTest, free_output) {
   entry.start_ns = 60;
   entry.end_ns = 2000;
   VerifyEntry(entry, "123: free 0x123 60 2000");
+
+  entry.present_bytes = 456;
+  VerifyEntry(entry, "123: free 0x123 60 2000 456");
+
+  // Verify if present bytes is set, the timestamps are in the output.
+  entry.start_ns = 0;
+  entry.end_ns = 0;
+  entry.present_bytes = 456;
+  VerifyEntry(entry, "123: free 0x123 0 0 456");
 }
 
 TEST_F(MemoryTraceOutputTest, thread_done_output) {
diff --git a/mtectrl/OWNERS b/mtectrl/OWNERS
index c95d3cfd..a49d9ced 100644
--- a/mtectrl/OWNERS
+++ b/mtectrl/OWNERS
@@ -1,4 +1,3 @@
 fmayer@google.com
 
-eugenis@google.com
 pcc@google.com
diff --git a/multinetwork/dnschk.cpp b/multinetwork/dnschk.cpp
index 07338538..0444a2b4 100644
--- a/multinetwork/dnschk.cpp
+++ b/multinetwork/dnschk.cpp
@@ -22,10 +22,10 @@
 #include <string.h>
 #include <sys/socket.h>
 
+#include <format>
 #include <iostream>
 #include <string>
 
-#include <android-base/format.h>
 #include <android/multinetwork.h>
 #include "common.h"
 
@@ -37,6 +37,7 @@ int main(int argc, const char* argv[]) {
     if (!args.parseArguments(argc, argv)) { return rval; }
 
     const struct addrinfo hints = {
+            .ai_flags = AI_ADDRCONFIG,  // Use the same parameter as Inet6AddressImpl.java.
             .ai_family = args.family,
             .ai_socktype = SOCK_DGRAM,
     };
@@ -50,7 +51,7 @@ int main(int argc, const char* argv[]) {
         std::string name;
 
         if (args.random_name) {
-            name = fmt::format("{}-{}-ds.metric.gstatic.com", rand(), rand());
+            name = std::format("{}-{}-ds.metric.gstatic.com", rand(), rand());
         } else {
             name = args.arg1;
         }
diff --git a/perf2cfg/Android.bp b/perf2cfg/Android.bp
index 6e4efe97..9419ef36 100644
--- a/perf2cfg/Android.bp
+++ b/perf2cfg/Android.bp
@@ -49,9 +49,4 @@ python_test_host {
     test_options: {
         unit_test: true,
     },
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
 }
diff --git a/perf_tools/Android.bp b/perf_tools/Android.bp
index 26b93511..7a3fe5d7 100644
--- a/perf_tools/Android.bp
+++ b/perf_tools/Android.bp
@@ -22,10 +22,7 @@ package {
 python_binary_host {
     name: "progress_report",
     srcs: ["progress_report.py"],
-    libs: [ "report_proto",],
-    version: {
-    	     py3: { embedded_launcher: true },
-    },
+    libs: ["report_proto"],
     main: "progress_report.py",
 }
 
diff --git a/profcollectd/binder/com/android/server/profcollect/IProfCollectd.aidl b/profcollectd/binder/com/android/server/profcollect/IProfCollectd.aidl
index 14767689..970c0fab 100644
--- a/profcollectd/binder/com/android/server/profcollect/IProfCollectd.aidl
+++ b/profcollectd/binder/com/android/server/profcollect/IProfCollectd.aidl
@@ -20,8 +20,6 @@ import com.android.server.profcollect.IProviderStatusCallback;
 
 /** {@hide} */
 interface IProfCollectd {
-    void schedule();
-    void terminate();
     void trace_system(@utf8InCpp String tag);
     void trace_process(@utf8InCpp String tag, @utf8InCpp String processes, float duration);
     void process();
diff --git a/profcollectd/libprofcollectd/lib.rs b/profcollectd/libprofcollectd/lib.rs
index 4663e686..741bed12 100644
--- a/profcollectd/libprofcollectd/lib.rs
+++ b/profcollectd/libprofcollectd/lib.rs
@@ -49,14 +49,12 @@ impl IProviderStatusCallback for ProviderStatusCallback {
         if elapsed < TIMEOUT_TO_COLLECT_BOOT_PROFILE {
             trace_system("boot").map_err(err_to_binder_status)?;
         }
-        schedule().map_err(err_to_binder_status)?;
         Ok(())
     }
 }
 
-/// Initialise profcollectd service.
-/// * `schedule_now` - Immediately schedule collection after service is initialised.
-pub fn init_service(schedule_now: bool) -> Result<()> {
+/// Initialize profcollectd service.
+pub fn init_service() -> Result<()> {
     binder::ProcessState::start_thread_pool();
 
     let profcollect_binder_service = ProfcollectdBinderService::new()?;
@@ -67,13 +65,11 @@ pub fn init_service(schedule_now: bool) -> Result<()> {
     )
     .context("Failed to register service.")?;
 
-    if schedule_now {
-        let cb = BnProviderStatusCallback::new_binder(
-            ProviderStatusCallback { service_start_time: Instant::now() },
-            BinderFeatures::default(),
-        );
-        get_profcollectd_service()?.registerProviderStatusCallback(&cb)?;
-    }
+    let cb = BnProviderStatusCallback::new_binder(
+        ProviderStatusCallback { service_start_time: Instant::now() },
+        BinderFeatures::default(),
+    );
+    get_profcollectd_service()?.registerProviderStatusCallback(&cb)?;
 
     binder::ProcessState::join_thread_pool();
     Ok(())
@@ -84,18 +80,6 @@ fn get_profcollectd_service() -> Result<binder::Strong<dyn IProfCollectd::IProfC
         .context("Failed to get profcollectd binder service, is profcollectd running?")
 }
 
-/// Schedule periodic profile collection.
-pub fn schedule() -> Result<()> {
-    get_profcollectd_service()?.schedule()?;
-    Ok(())
-}
-
-/// Terminate periodic profile collection.
-pub fn terminate() -> Result<()> {
-    get_profcollectd_service()?.terminate()?;
-    Ok(())
-}
-
 /// Immediately schedule a one-off trace.
 pub fn trace_system(tag: &str) -> Result<()> {
     get_profcollectd_service()?.trace_system(tag)?;
diff --git a/profcollectd/libprofcollectd/scheduler.rs b/profcollectd/libprofcollectd/scheduler.rs
index e37ffe7c..9229086b 100644
--- a/profcollectd/libprofcollectd/scheduler.rs
+++ b/profcollectd/libprofcollectd/scheduler.rs
@@ -19,7 +19,6 @@
 use std::fs;
 use std::mem;
 use std::path::Path;
-use std::sync::mpsc::{sync_channel, SyncSender};
 use std::sync::Arc;
 use std::sync::Mutex;
 use std::thread;
@@ -27,12 +26,9 @@ use std::time::{Duration, Instant};
 
 use crate::config::{get_sampling_period, Config, LOG_FILE, PROFILE_OUTPUT_DIR, TRACE_OUTPUT_DIR};
 use crate::trace_provider::{self, TraceProvider};
-use anyhow::{anyhow, ensure, Context, Result};
+use anyhow::{anyhow, Context, Result};
 
 pub struct Scheduler {
-    /// Signal to terminate the periodic collection worker thread, None if periodic collection is
-    /// not scheduled.
-    termination_ch: Option<SyncSender<()>>,
     /// The preferred trace provider for the system.
     trace_provider: Arc<Mutex<dyn TraceProvider + Send>>,
     provider_ready_callbacks: Arc<Mutex<Vec<Box<dyn FnOnce() + Send>>>>,
@@ -43,57 +39,11 @@ impl Scheduler {
         let p = trace_provider::get_trace_provider()?;
         p.lock().map_err(|e| anyhow!(e.to_string()))?.set_log_file(&LOG_FILE);
         Ok(Scheduler {
-            termination_ch: None,
             trace_provider: p,
             provider_ready_callbacks: Arc::new(Mutex::new(Vec::new())),
         })
     }
 
-    fn is_scheduled(&self) -> bool {
-        self.termination_ch.is_some()
-    }
-
-    pub fn schedule_periodic(&mut self, config: &Config) -> Result<()> {
-        ensure!(!self.is_scheduled(), "Already scheduled.");
-
-        let (sender, receiver) = sync_channel(1);
-        self.termination_ch = Some(sender);
-
-        // Clone config and trace_provider ARC for the worker thread.
-        let config = config.clone();
-        let trace_provider = self.trace_provider.clone();
-
-        thread::spawn(move || {
-            loop {
-                match receiver.recv_timeout(config.collection_interval) {
-                    Ok(_) => break,
-                    Err(_) => {
-                        // Did not receive a termination signal, initiate trace event.
-                        if check_space_limit(&TRACE_OUTPUT_DIR, &config).unwrap() {
-                            trace_provider.lock().unwrap().trace_system(
-                                &TRACE_OUTPUT_DIR,
-                                "periodic",
-                                &get_sampling_period(),
-                                &config.binary_filter,
-                            );
-                        }
-                    }
-                }
-            }
-        });
-        Ok(())
-    }
-
-    pub fn terminate_periodic(&mut self) -> Result<()> {
-        self.termination_ch
-            .as_ref()
-            .ok_or_else(|| anyhow!("Not scheduled"))?
-            .send(())
-            .context("Scheduler worker disappeared.")?;
-        self.termination_ch = None;
-        Ok(())
-    }
-
     pub fn trace_system(&self, config: &Config, tag: &str) -> Result<()> {
         let trace_provider = self.trace_provider.clone();
         if check_space_limit(&TRACE_OUTPUT_DIR, config)? {
diff --git a/profcollectd/libprofcollectd/service.rs b/profcollectd/libprofcollectd/service.rs
index 5e3097af..49c54067 100644
--- a/profcollectd/libprofcollectd/service.rs
+++ b/profcollectd/libprofcollectd/service.rs
@@ -51,20 +51,6 @@ struct Lock {
 impl binder::Interface for ProfcollectdBinderService {}
 
 impl IProfCollectd for ProfcollectdBinderService {
-    fn schedule(&self) -> BinderResult<()> {
-        let lock = &mut *self.lock();
-        lock.scheduler
-            .schedule_periodic(&lock.config)
-            .context("Failed to schedule collection.")
-            .map_err(err_to_binder_status)
-    }
-    fn terminate(&self) -> BinderResult<()> {
-        self.lock()
-            .scheduler
-            .terminate_periodic()
-            .context("Failed to terminate collection.")
-            .map_err(err_to_binder_status)
-    }
     fn trace_system(&self, tag: &str) -> BinderResult<()> {
         let lock = &mut *self.lock();
         lock.scheduler
diff --git a/profcollectd/profcollectctl.rs b/profcollectd/profcollectctl.rs
index bc22d3b2..c5336914 100644
--- a/profcollectd/profcollectctl.rs
+++ b/profcollectd/profcollectctl.rs
@@ -25,8 +25,6 @@ usage: profcollectctl [command]
 Command to control profcollectd behaviour.
 
 command:
-    start       Schedule periodic collection.
-    stop        Terminate periodic collection.
     trace       Request an one-off system-wide trace.
     process     Convert traces to perf profiles.
     report      Create a report containing all profiles.
@@ -44,14 +42,6 @@ fn main() -> Result<()> {
 
     let action = &args[1];
     match action.as_str() {
-        "start" => {
-            println!("Scheduling profile collection");
-            libprofcollectd::schedule().context("Failed to schedule collection.")?;
-        }
-        "stop" => {
-            println!("Terminating profile collection");
-            libprofcollectd::terminate().context("Failed to terminate collection.")?;
-        }
         "trace" => {
             println!("Performing system-wide trace");
             libprofcollectd::trace_system("manual").context("Failed to trace.")?;
diff --git a/profcollectd/profcollectd.rs b/profcollectd/profcollectd.rs
index 0c2e87d9..3ae9121e 100644
--- a/profcollectd/profcollectd.rs
+++ b/profcollectd/profcollectd.rs
@@ -22,7 +22,7 @@ use std::env;
 const HELP_MSG: &str = r#"
 profcollectd background daemon.
 usage: profcollectd [command]
-    nostart       Start daemon but do not schedule profile collection.
+    help       Print help message.
 "#;
 
 fn main() -> Result<()> {
@@ -33,12 +33,11 @@ fn main() -> Result<()> {
         bail!("This program only takes one or no argument{}", &HELP_MSG);
     }
     if args.len() == 1 {
-        libprofcollectd::init_service(true)?;
+        libprofcollectd::init_service()?;
     }
 
     let action = &args[1];
     match action.as_str() {
-        "nostart" => libprofcollectd::init_service(false)?,
         "help" => println!("{}", &HELP_MSG),
         arg => bail!("Unknown argument: {}\n{}", &arg, &HELP_MSG),
     }
diff --git a/simpleperf/Android.bp b/simpleperf/Android.bp
index c1b45f1e..ac412398 100644
--- a/simpleperf/Android.bp
+++ b/simpleperf/Android.bp
@@ -43,6 +43,7 @@ cc_defaults {
         },
         windows: {
             host_ldlibs: [
+                "-lntdll",
                 "-lole32",
                 "-luuid",
             ],
@@ -143,10 +144,8 @@ cc_defaults {
         "libziparchive",
         "libzstd",
     ],
+    stl: "libc++_static",
     target: {
-        host: {
-            stl: "libc++_static",
-        },
         linux: {
             static_libs: [
                 "libunwindstack",
@@ -309,7 +308,6 @@ cc_library_static {
 
     target: {
         linux: {
-            // See note for libdexfile_static in simpleperf_ndk.
             static_libs: ["libdexfile_support"],
             runtime_libs: ["libdexfile"], // libdexfile_support dependency
         },
@@ -394,13 +392,8 @@ cc_binary {
         "libsimpleperf",
     ],
 
+    min_sdk_version: "31",
     target: {
-        android: {
-            static_executable: true,
-            static_libs: [
-                "libc",
-            ],
-        },
         android_arm: {
             dist: {
                 dir: "simpleperf/android/arm",
@@ -435,11 +428,8 @@ cc_binary {
             },
         },
         linux: {
-            // In the NDK we need libdexfile_static which links libdexfile and
-            // its ART dependencies statically. However in other libraries we
-            // must use libdexfile_support, which dlopen's libdexfile.so from
-            // the ART APEX, to avoid getting ART internals in the system image.
-            static_libs: ["libdexfile_static"],
+            static_libs: ["libdexfile_support"],
+            runtime_libs: ["libdexfile"], // libdexfile_support dependency
         },
         linux_glibc_x86: {
             dist: {
@@ -492,13 +482,13 @@ cc_library {
         darwin: {
             enabled: false,
         },
+        linux: {
+            static_libs: ["libdexfile_support"],
+            runtime_libs: ["libdexfile"], // libdexfile_support dependency
+        },
         windows: {
             enabled: false,
         },
-        linux: {
-            // See note for libdexfile_static in simpleperf_ndk.
-            static_libs: ["libdexfile_static"],
-        },
     },
 }
 
@@ -522,7 +512,6 @@ cc_library_shared {
         },
         linux: {
             ldflags: ["-Wl,--exclude-libs,ALL"],
-            // See note for libdexfile_static in simpleperf_ndk.
             static_libs: ["libdexfile_static"],
         },
         darwin: {
diff --git a/simpleperf/ETMDecoder.cpp b/simpleperf/ETMDecoder.cpp
index cf77beab..99017f15 100644
--- a/simpleperf/ETMDecoder.cpp
+++ b/simpleperf/ETMDecoder.cpp
@@ -513,6 +513,25 @@ class InstrRangeParser : public ElementCallback {
   ETMDecoder::InstrRangeCallbackFn callback_;
 };
 
+class UserElementCallback : public ElementCallback {
+ public:
+  UserElementCallback(MapLocator& map_locator, const ETMDecoder::UserCallback& callback)
+      : map_locator_(map_locator), callback_(callback) {}
+
+  ocsd_datapath_resp_t ProcessElement(const ocsd_trc_index_t, uint8_t trace_id,
+                                      const OcsdTraceElement& elem,
+                                      const ocsd_instr_info*) override {
+    // Make sure it is a pointer to the struct, to make it accessible through a C API.
+    const ocsd_generic_trace_elem* ptr = &elem;
+    callback_(trace_id, ptr);
+    return OCSD_RESP_CONT;
+  }
+
+ private:
+  MapLocator& map_locator_;
+  ETMDecoder::UserCallback callback_;
+};
+
 // It parses ETMBranchLists from ETMV4IPackets.
 // It doesn't do element decoding and instruction decoding, thus is about 5 timers faster than
 // InstrRangeParser. But some data will be lost when converting ETMBranchLists to InstrRanges:
@@ -731,6 +750,20 @@ class ETMDecoderImpl : public ETMDecoder {
     InstallPacketCallback(branch_list_parser_.get());
   }
 
+  void RegisterCallback(const UserCallback& callback) {
+    InstallMapLocator();
+    user_element_callback_.reset(new UserElementCallback(*map_locator_, callback));
+    InstallElementCallback(user_element_callback_.get());
+  }
+
+  const MapEntry* FindMap(uint8_t trace_id, uint64_t addr) {
+    if (!map_locator_) {
+      InstallMapLocator();
+    }
+
+    return map_locator_->FindMap(trace_id, addr);
+  }
+
   bool ProcessData(const uint8_t* data, size_t size, bool formatted, uint32_t cpu) override {
     // Reset decoders before processing each data block. Because:
     // 1. Data blocks are not continuous. So decoders shouldn't keep previous states when
@@ -826,6 +859,7 @@ class ETMDecoderImpl : public ETMDecoder {
   std::unique_ptr<InstrRangeParser> instr_range_parser_;
   std::unique_ptr<MapLocator> map_locator_;
   std::unique_ptr<BranchListParser> branch_list_parser_;
+  std::unique_ptr<UserElementCallback> user_element_callback_;
 };
 
 }  // namespace
diff --git a/simpleperf/ETMDecoder.h b/simpleperf/ETMDecoder.h
index cb5c8dc8..d247e46b 100644
--- a/simpleperf/ETMDecoder.h
+++ b/simpleperf/ETMDecoder.h
@@ -83,6 +83,11 @@ class ETMDecoder {
   using BranchListCallbackFn = std::function<void(const ETMBranchList&)>;
   virtual void RegisterCallback(const BranchListCallbackFn& callback) = 0;
 
+  using UserCallback = std::function<void(const uint8_t, const void*)>;
+  virtual void RegisterCallback(const UserCallback& callback) = 0;
+
+  virtual const MapEntry* FindMap(uint8_t trace_id, uint64_t addr) = 0;
+
   virtual bool ProcessData(const uint8_t* data, size_t size, bool formatted, uint32_t cpu) = 0;
   virtual bool FinishData() = 0;
 };
diff --git a/simpleperf/JITDebugReader_test.cpp b/simpleperf/JITDebugReader_test.cpp
index 4aaad813..cbfba551 100644
--- a/simpleperf/JITDebugReader_test.cpp
+++ b/simpleperf/JITDebugReader_test.cpp
@@ -56,9 +56,9 @@ TEST(TempSymFile, smoke) {
 TEST(JITDebugReader, read_dex_file_in_memory) {
   // 1. Create dex file in memory. Use mmap instead of malloc, to avoid the pointer from
   // being modified by memory tag (or pointer authentication?) on ARM64.
-  std::string dex_file = GetTestData("base.vdex");
+  std::string dex_file = GetTestData("base.dex");
   uint64_t file_size = GetFileSize(dex_file);
-  const uint64_t dex_file_offset = 0x28;
+  const uint64_t dex_file_offset = 0;
   ASSERT_GT(file_size, dex_file_offset);
   uint64_t symfile_size = file_size - dex_file_offset;
   void* symfile_addr =
@@ -90,7 +90,7 @@ TEST(JITDebugReader, read_dex_file_in_memory) {
   ASSERT_EQ(info.dex_file_map->start_addr, reinterpret_cast<uintptr_t>(symfile_addr));
   ASSERT_EQ(info.dex_file_map->len, symfile_size);
   ASSERT_TRUE(android::base::StartsWith(info.dex_file_map->name, kDexFileInMemoryPrefix));
-  ASSERT_EQ(info.symbols.size(), 12435);
+  ASSERT_EQ(info.symbols.size(), 3912);
   // 4. Test if the symbols are sorted.
   uint64_t prev_addr = 0;
   for (const auto& symbol : info.symbols) {
diff --git a/simpleperf/ProbeEvents.cpp b/simpleperf/ProbeEvents.cpp
index 53b2d47f..28d18185 100644
--- a/simpleperf/ProbeEvents.cpp
+++ b/simpleperf/ProbeEvents.cpp
@@ -18,6 +18,7 @@
 
 #include <inttypes.h>
 
+#include <filesystem>
 #include <memory>
 #include <string>
 
@@ -45,17 +46,23 @@ using android::base::WriteStringToFd;
 
 static const std::string kKprobeEventPrefix = "kprobes:";
 
-bool ProbeEvents::ParseKprobeEventName(const std::string& kprobe_cmd, ProbeEvent* event) {
+bool ProbeEvents::ParseProbeEventName(ProbeEventType type, const std::string& probe_cmd,
+                                      ProbeEvent* event) {
   // kprobe_cmd is in formats described in <kernel>/Documentation/trace/kprobetrace.rst:
   //   p[:[GRP/]EVENT] [MOD:]SYM[+offs]|MEMADDR [FETCHARGS]
   //   r[MAXACTIVE][:[GRP/]EVENT] [MOD:]SYM[+offs] [FETCHARGS]
-  std::vector<std::string> args = Split(kprobe_cmd, " ");
+  // uprobe_cmd is in formats described in <kernel>/Documentation/trace/uprobetracer.rst:
+  //   p[:[GRP/][EVENT]] PATH:OFFSET [FETCHARGS] : Set a uprobe
+  //   r[:[GRP/][EVENT]] PATH:OFFSET [FETCHARGS] : Set a return uprobe (uretprobe)
+  std::vector<std::string> args = Split(probe_cmd, " ");
   if (args.size() < 2) {
     return false;
   }
 
+  event->type = type;
+  event->group_name = type == ProbeEventType::kKprobe ? "kprobes" : "uprobes";
+
   // Parse given name.
-  event->group_name = "kprobes";
   auto name_reg = RegEx::Create(R"(:([a-zA-Z_][\w_]*/)?([a-zA-Z_][\w_]*))");
   auto match = name_reg->SearchAll(args[0]);
   if (match->IsValid()) {
@@ -67,30 +74,49 @@ bool ProbeEvents::ParseKprobeEventName(const std::string& kprobe_cmd, ProbeEvent
     return true;
   }
 
-  // Generate name from MEMADDR.
-  char probe_type = args[0][0];
-  uint64_t kaddr;
-  if (ParseUint(args[1], &kaddr)) {
-    event->event_name = StringPrintf("%c_0x%" PRIx64, probe_type, kaddr);
-    return true;
-  }
+  if (type == ProbeEventType::kKprobe) {
+    // Generate name from MEMADDR.
+    char probe_type = args[0][0];
+    uint64_t kaddr;
+    if (ParseUint(args[1], &kaddr)) {
+      event->event_name = StringPrintf("%c_0x%" PRIx64, probe_type, kaddr);
+      return true;
+    }
 
-  // Generate name from [MOD:]SYM[+offs].
-  std::string symbol;
-  int64_t offset;
-  size_t split_pos = args[1].find_first_of("+-");
-  if (split_pos == std::string::npos) {
-    symbol = args[1];
-    offset = 0;
+    // Generate name from [MOD:]SYM[+offs].
+    std::string symbol;
+    int64_t offset;
+    size_t split_pos = args[1].find_first_of("+-");
+    if (split_pos == std::string::npos) {
+      symbol = args[1];
+      offset = 0;
+    } else {
+      symbol = args[1].substr(0, split_pos);
+      if (!ParseInt(args[1].substr(split_pos), &offset) || offset < 0) {
+        return false;
+      }
+    }
+    std::string s = StringPrintf("%c_%s_%" PRId64, probe_type, symbol.c_str(), offset);
+    event->event_name = RegEx::Create(R"(\.|:)")->Replace(s, "_").value();
+    return true;
   } else {
-    symbol = args[1].substr(0, split_pos);
-    if (!ParseInt(args[1].substr(split_pos), &offset) || offset < 0) {
-      return false;
+    // Generate name from PATH:OFFSET.
+    uint64_t offset;
+    std::vector<std::string> target = Split(args[1], ":");
+    if (target.size() == 2 && ParseUint(target[1], &offset)) {
+      std::filesystem::path path(target[0]);
+      std::string filename = path.filename().string();
+      auto pos = filename.find_first_of(".-_");
+      if (pos != std::string::npos) {
+        filename = filename.substr(0, pos);
+      }
+      // 'p' is used in the event name even if it's a uretprobe.
+      event->event_name = StringPrintf("p_%s_0x%" PRIx64, filename.c_str(), offset);
+      return true;
     }
+
+    return false;
   }
-  std::string s = StringPrintf("%c_%s_%" PRId64, probe_type, symbol.c_str(), offset);
-  event->event_name = RegEx::Create(R"(\.|:)")->Replace(s, "_").value();
-  return true;
 }
 
 ProbeEvents::~ProbeEvents() {
@@ -101,73 +127,89 @@ ProbeEvents::~ProbeEvents() {
   }
 }
 
-bool ProbeEvents::IsKprobeSupported() {
-  if (!kprobe_control_path_.has_value()) {
-    kprobe_control_path_ = "";
+bool ProbeEvents::IsProbeSupported(ProbeEventType type) {
+  const char* file_name = type == ProbeEventType::kKprobe ? "kprobe_events" : "uprobe_events";
+  auto& path = GetProbeControlPath(type);
+  if (!path.has_value()) {
+    path = "";
     if (const char* tracefs_dir = GetTraceFsDir(); tracefs_dir != nullptr) {
-      std::string path = std::string(tracefs_dir) + "/kprobe_events";
-      if (IsRegularFile(path)) {
-        kprobe_control_path_ = std::move(path);
+      std::string probe_event_path = std::string(tracefs_dir) + "/" + file_name;
+      if (IsRegularFile(probe_event_path)) {
+        path = std::move(probe_event_path);
       }
     }
   }
-  return !kprobe_control_path_.value().empty();
+  return !path.value().empty();
 }
 
-bool ProbeEvents::AddKprobe(const std::string& kprobe_cmd) {
+bool ProbeEvents::AddProbe(ProbeEventType type, const std::string& probe_cmd) {
   ProbeEvent event;
-  if (!ParseKprobeEventName(kprobe_cmd, &event)) {
-    LOG(ERROR) << "invalid kprobe cmd: " << kprobe_cmd;
+  if (!IsProbeSupported(type)) {
+    LOG(ERROR) << "probe events isn't supported by the kernel.";
     return false;
   }
-  if (!WriteKprobeCmd(kprobe_cmd)) {
+  if (!ParseProbeEventName(type, probe_cmd, &event)) {
+    LOG(ERROR) << "invalid probe cmd: " << probe_cmd;
     return false;
   }
-  kprobe_events_.emplace_back(std::move(event));
+  if (!WriteProbeCmd(type, probe_cmd)) {
+    return false;
+  }
+  probe_events_.emplace_back(std::move(event));
   return true;
 }
 
-bool ProbeEvents::IsProbeEvent(const std::string& event_name) {
+bool ProbeEvents::IsKprobeEvent(const std::string& event_name) {
   return android::base::StartsWith(event_name, kKprobeEventPrefix);
 }
 
 bool ProbeEvents::CreateProbeEventIfNotExist(const std::string& event_name) {
-  if (!IsProbeEvent(event_name) || (EventTypeManager::Instance().FindType(event_name) != nullptr)) {
+  // uprobes aren't supported in this function because we can't identify the binary from an event
+  // name.
+  if (!IsKprobeEvent(event_name) ||
+      (EventTypeManager::Instance().FindType(event_name) != nullptr)) {
     // No need to create a probe event.
     return true;
   }
   std::string function_name = event_name.substr(kKprobeEventPrefix.size());
-  return AddKprobe(StringPrintf("p:%s %s", function_name.c_str(), function_name.c_str()));
+  return AddProbe(ProbeEventType::kKprobe,
+                  StringPrintf("p:%s %s", function_name.c_str(), function_name.c_str()));
 }
 
 void ProbeEvents::Clear() {
-  for (const auto& kprobe_event : kprobe_events_) {
-    if (!WriteKprobeCmd("-:" + kprobe_event.group_name + "/" + kprobe_event.event_name)) {
-      LOG(WARNING) << "failed to delete kprobe event " << kprobe_event.group_name << ":"
-                   << kprobe_event.event_name;
+  for (const auto& probe_event : probe_events_) {
+    if (!WriteProbeCmd(probe_event.type,
+                       "-:" + probe_event.group_name + "/" + probe_event.event_name)) {
+      LOG(WARNING) << "failed to delete probe event " << probe_event.group_name << ":"
+                   << probe_event.event_name;
     }
-    EventTypeManager::Instance().RemoveProbeType(kprobe_event.group_name + ":" +
-                                                 kprobe_event.event_name);
+    EventTypeManager::Instance().RemoveProbeType(probe_event.group_name + ":" +
+                                                 probe_event.event_name);
   }
-  kprobe_events_.clear();
+  probe_events_.clear();
 }
 
-bool ProbeEvents::WriteKprobeCmd(const std::string& kprobe_cmd) {
-  if (!IsKprobeSupported()) {
-    LOG(ERROR) << "kprobe events isn't supported by the kernel.";
-    return false;
-  }
-  const std::string& path = kprobe_control_path_.value();
-  unique_fd fd(open(path.c_str(), O_APPEND | O_WRONLY | O_CLOEXEC));
+bool ProbeEvents::WriteProbeCmd(ProbeEventType type, const std::string& probe_cmd) {
+  const std::string& file_path = GetProbeControlPath(type).value();
+  unique_fd fd(open(file_path.c_str(), O_APPEND | O_WRONLY | O_CLOEXEC));
   if (!fd.ok()) {
-    PLOG(ERROR) << "failed to open " << path;
+    PLOG(ERROR) << "failed to open " << file_path;
     return false;
   }
-  if (!WriteStringToFd(kprobe_cmd, fd)) {
-    PLOG(ERROR) << "failed to write '" << kprobe_cmd << "' to " << path;
+  if (!WriteStringToFd(probe_cmd, fd)) {
+    PLOG(ERROR) << "failed to write '" << probe_cmd << "' to " << file_path;
     return false;
   }
   return true;
 }
 
+std::optional<std::string>& ProbeEvents::GetProbeControlPath(ProbeEventType type) {
+  switch (type) {
+    case ProbeEventType::kKprobe:
+      return kprobe_control_path_;
+    case ProbeEventType::kUprobe:
+      return uprobe_control_path_;
+  }
+}
+
 }  // namespace simpleperf
diff --git a/simpleperf/ProbeEvents.h b/simpleperf/ProbeEvents.h
index 645dbc91..ce6067ec 100644
--- a/simpleperf/ProbeEvents.h
+++ b/simpleperf/ProbeEvents.h
@@ -24,7 +24,13 @@ namespace simpleperf {
 
 class EventSelectionSet;
 
+enum class ProbeEventType {
+  kKprobe,
+  kUprobe,
+};
+
 struct ProbeEvent {
+  ProbeEventType type;
   std::string group_name;
   std::string event_name;
 };
@@ -36,23 +42,27 @@ class ProbeEvents {
   ProbeEvents(EventSelectionSet& event_selection_set) : event_selection_set_(event_selection_set) {}
   ~ProbeEvents();
 
-  static bool ParseKprobeEventName(const std::string& kprobe_cmd, ProbeEvent* event);
-  bool IsKprobeSupported();
+  static bool ParseProbeEventName(ProbeEventType type, const std::string& kprobe_cmd,
+                                  ProbeEvent* event);
+  bool IsProbeSupported(ProbeEventType type);
 
-  // Accept kprobe cmd as in <linux_kernel>/Documentation/trace/kprobetrace.rst.
-  bool AddKprobe(const std::string& kprobe_cmd);
+  // Accept kprobe cmd as in <linux_kernel>/Documentation/trace/kprobetrace.rst
+  // or uprobe cmd as in <linux_kernel>/Documentation/trace/uprobetracer.rst.
+  bool AddProbe(ProbeEventType type, const std::string& probe_cmd);
   // If not exist, add a kprobe tracepoint at the function entry.
   bool CreateProbeEventIfNotExist(const std::string& event_name);
 
  private:
-  bool IsProbeEvent(const std::string& event_name);
-  bool IsEmpty() const { return kprobe_events_.empty(); }
+  bool IsKprobeEvent(const std::string& event_name);
+  bool IsEmpty() const { return probe_events_.empty(); }
   void Clear();
-  bool WriteKprobeCmd(const std::string& kprobe_cmd);
+  bool WriteProbeCmd(ProbeEventType type, const std::string& probe_cmd);
+  std::optional<std::string>& GetProbeControlPath(ProbeEventType type);
 
   EventSelectionSet& event_selection_set_;
-  std::vector<ProbeEvent> kprobe_events_;
+  std::vector<ProbeEvent> probe_events_;
   std::optional<std::string> kprobe_control_path_;
+  std::optional<std::string> uprobe_control_path_;
 };
 
 }  // namespace simpleperf
diff --git a/simpleperf/ProbeEvents_test.cpp b/simpleperf/ProbeEvents_test.cpp
index 630c5761..bacfc8e7 100644
--- a/simpleperf/ProbeEvents_test.cpp
+++ b/simpleperf/ProbeEvents_test.cpp
@@ -26,27 +26,60 @@ using namespace simpleperf;
 // @CddTest = 6.1/C-0-2
 TEST(probe_events, ParseKprobeEventName) {
   ProbeEvent event;
-  ASSERT_TRUE(ProbeEvents::ParseKprobeEventName("p:myprobe do_sys_open", &event));
+  ASSERT_TRUE(
+      ProbeEvents::ParseProbeEventName(ProbeEventType::kKprobe, "p:myprobe do_sys_open", &event));
   ASSERT_EQ(event.group_name, "kprobes");
   ASSERT_EQ(event.event_name, "myprobe");
 
-  ASSERT_TRUE(ProbeEvents::ParseKprobeEventName("p:mygroup/myprobe do_sys_open", &event));
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kKprobe,
+                                               "p:mygroup/myprobe do_sys_open", &event));
   ASSERT_EQ(event.group_name, "mygroup");
   ASSERT_EQ(event.event_name, "myprobe");
 
-  ASSERT_TRUE(ProbeEvents::ParseKprobeEventName("p do_sys_open", &event));
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kKprobe, "p do_sys_open", &event));
   ASSERT_EQ(event.group_name, "kprobes");
   ASSERT_EQ(event.event_name, "p_do_sys_open_0");
 
-  ASSERT_TRUE(ProbeEvents::ParseKprobeEventName("r do_sys_open+138", &event));
+  ASSERT_TRUE(
+      ProbeEvents::ParseProbeEventName(ProbeEventType::kKprobe, "r do_sys_open+138", &event));
   ASSERT_EQ(event.group_name, "kprobes");
   ASSERT_EQ(event.event_name, "r_do_sys_open_138");
 
-  ASSERT_TRUE(ProbeEvents::ParseKprobeEventName("r module:do_sys_open+138", &event));
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kKprobe, "r module:do_sys_open+138",
+                                               &event));
   ASSERT_EQ(event.group_name, "kprobes");
   ASSERT_EQ(event.event_name, "r_module_do_sys_open_138");
 
-  ASSERT_TRUE(ProbeEvents::ParseKprobeEventName("p 0x12345678", &event));
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kKprobe, "p 0x12345678", &event));
   ASSERT_EQ(event.group_name, "kprobes");
   ASSERT_EQ(event.event_name, "p_0x12345678");
 }
+
+// @CddTest = 6.1/C-0-2
+TEST(probe_events, ParseUprobeEventName) {
+  ProbeEvent event;
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kUprobe,
+                                               "p:myprobe /system/lib64/libc.so:0x88e80", &event));
+  ASSERT_EQ(event.group_name, "uprobes");
+  ASSERT_EQ(event.event_name, "myprobe");
+
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(
+      ProbeEventType::kUprobe, "p:mygroup/myprobe /system/lib64/libc.so:0x88e80", &event));
+  ASSERT_EQ(event.group_name, "mygroup");
+  ASSERT_EQ(event.event_name, "myprobe");
+
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kUprobe,
+                                               "p /system/lib64/libc.so:0x88e80", &event));
+  ASSERT_EQ(event.group_name, "uprobes");
+  ASSERT_EQ(event.event_name, "p_libc_0x88e80");
+
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kUprobe,
+                                               "p /system/lib64/libc.so:560768", &event));
+  ASSERT_EQ(event.group_name, "uprobes");
+  ASSERT_EQ(event.event_name, "p_libc_0x88e80");
+
+  ASSERT_TRUE(ProbeEvents::ParseProbeEventName(ProbeEventType::kUprobe,
+                                               "r /system/lib64/libc.so:0x88e80", &event));
+  ASSERT_EQ(event.group_name, "uprobes");
+  ASSERT_EQ(event.event_name, "p_libc_0x88e80");
+}
diff --git a/simpleperf/app_api/cpp/simpleperf.cpp b/simpleperf/app_api/cpp/simpleperf.cpp
index 72f129b8..0ff932c3 100644
--- a/simpleperf/app_api/cpp/simpleperf.cpp
+++ b/simpleperf/app_api/cpp/simpleperf.cpp
@@ -166,7 +166,6 @@ class ProfileSessionImpl {
 
  private:
   std::string FindSimpleperf();
-  std::string FindSimpleperfInTempDir();
   void CheckIfPerfEnabled();
   std::string GetProperty(const std::string& name);
   void CreateSimpleperfDataDir();
@@ -336,12 +335,7 @@ static bool RunCmd(std::vector<const char*> args, std::string* stdout) {
 }
 
 std::string ProfileSessionImpl::FindSimpleperf() {
-  // 1. Try /data/local/tmp/simpleperf first. Probably it's newer than /system/bin/simpleperf.
-  std::string simpleperf_path = FindSimpleperfInTempDir();
-  if (!simpleperf_path.empty()) {
-    return simpleperf_path;
-  }
-  // 2. Try /system/bin/simpleperf, which is available on Android >= Q.
+  // Try /system/bin/simpleperf, which is available on Android >= Q.
   simpleperf_path = "/system/bin/simpleperf";
   if (IsExecutableFile(simpleperf_path)) {
     return simpleperf_path;
@@ -350,29 +344,6 @@ std::string ProfileSessionImpl::FindSimpleperf() {
   return "";
 }
 
-std::string ProfileSessionImpl::FindSimpleperfInTempDir() {
-  const std::string path = "/data/local/tmp/simpleperf";
-  if (!IsExecutableFile(path)) {
-    return "";
-  }
-  // Copy it to app_dir to execute it.
-  const std::string to_path = app_data_dir_ + "/simpleperf";
-  if (!RunCmd({"/system/bin/cp", path.c_str(), to_path.c_str()}, nullptr)) {
-    return "";
-  }
-  // For apps with target sdk >= 29, executing app data file isn't allowed.
-  // For android R, app context isn't allowed to use perf_event_open.
-  // So test executing downloaded simpleperf.
-  std::string s;
-  if (!RunCmd({to_path.c_str(), "list", "sw"}, &s)) {
-    return "";
-  }
-  if (s.find("cpu-clock") == std::string::npos) {
-    return "";
-  }
-  return to_path;
-}
-
 void ProfileSessionImpl::CheckIfPerfEnabled() {
   if (GetProperty("persist.simpleperf.profile_app_uid") == std::to_string(getuid())) {
     std::string time_str = GetProperty("persist.simpleperf.profile_app_expiration_time");
diff --git a/simpleperf/app_api/java/com/android/simpleperf/ProfileSession.java b/simpleperf/app_api/java/com/android/simpleperf/ProfileSession.java
index aa840d89..e3b2e692 100644
--- a/simpleperf/app_api/java/com/android/simpleperf/ProfileSession.java
+++ b/simpleperf/app_api/java/com/android/simpleperf/ProfileSession.java
@@ -43,20 +43,21 @@ import java.util.stream.Collectors;
  *
  * <p>
  * Example:
- *   RecordOptions options = new RecordOptions();
- *   options.setDwarfCallGraph();
- *   ProfileSession session = new ProfileSession();
- *   session.StartRecording(options);
- *   Thread.sleep(1000);
- *   session.PauseRecording();
- *   Thread.sleep(1000);
- *   session.ResumeRecording();
- *   Thread.sleep(1000);
- *   session.StopRecording();
+ * RecordOptions options = new RecordOptions();
+ * options.setDwarfCallGraph();
+ * ProfileSession session = new ProfileSession();
+ * session.StartRecording(options);
+ * Thread.sleep(1000);
+ * session.PauseRecording();
+ * Thread.sleep(1000);
+ * session.ResumeRecording();
+ * Thread.sleep(1000);
+ * session.StopRecording();
  * </p>
  *
  * <p>
- * It throws an Error when error happens. To read error messages of simpleperf record
+ * It throws an Error when error happens. To read error messages of simpleperf
+ * record
  * process, filter logcat with `simpleperf`.
  * </p>
  */
@@ -80,7 +81,8 @@ public class ProfileSession {
 
     /**
      * @param appDataDir the same as android.content.Context.getDataDir().
-     *                   ProfileSession stores profiling data in appDataDir/simpleperf_data/.
+     *                   ProfileSession stores profiling data in
+     *                   appDataDir/simpleperf_data/.
      */
     public ProfileSession(@NonNull String appDataDir) {
         mAppDataDir = appDataDir;
@@ -120,6 +122,7 @@ public class ProfileSession {
 
     /**
      * Start recording.
+     *
      * @param options RecordOptions
      */
     public void startRecording(@NonNull RecordOptions options) {
@@ -128,6 +131,7 @@ public class ProfileSession {
 
     /**
      * Start recording.
+     *
      * @param args arguments for `simpleperf record` cmd.
      */
     public synchronized void startRecording(@NonNull List<String> args) {
@@ -173,7 +177,8 @@ public class ProfileSession {
     }
 
     /**
-     * Stop recording and generate a recording file under appDataDir/simpleperf_data/.
+     * Stop recording and generate a recording file under
+     * appDataDir/simpleperf_data/.
      */
     public synchronized void stopRecording() {
         if (mState != State.STARTED && mState != State.PAUSED) {
@@ -181,7 +186,8 @@ public class ProfileSession {
         }
         if (Build.VERSION.SDK_INT == Build.VERSION_CODES.P + 1
                 && mSimpleperfPath.equals(SIMPLEPERF_PATH_IN_IMAGE)) {
-            // The simpleperf shipped on Android Q contains a bug, which may make it abort if
+            // The simpleperf shipped on Android Q contains a bug, which may make it abort
+            // if
             // calling simpleperfProcess.destroy().
             destroySimpleperfProcessWithoutClosingStdin();
         } else {
@@ -225,12 +231,7 @@ public class ProfileSession {
     }
 
     private String findSimpleperf() {
-        // 1. Try /data/local/tmp/simpleperf. Probably it's newer than /system/bin/simpleperf.
-        String simpleperfPath = findSimpleperfInTempDir();
-        if (simpleperfPath != null) {
-            return simpleperfPath;
-        }
-        // 2. Try /system/bin/simpleperf, which is available on Android >= Q.
+        // Try /system/bin/simpleperf, which is available on Android >= Q.
         simpleperfPath = SIMPLEPERF_PATH_IN_IMAGE;
         if (isExecutableFile(simpleperfPath)) {
             return simpleperfPath;
@@ -243,41 +244,6 @@ public class ProfileSession {
         return file.canExecute();
     }
 
-    @Nullable
-    private String findSimpleperfInTempDir() {
-        String path = "/data/local/tmp/simpleperf";
-        File file = new File(path);
-        if (!file.isFile()) {
-            return null;
-        }
-        // Copy it to app dir to execute it.
-        String toPath = mAppDataDir + "/simpleperf";
-        try {
-            Process process = new ProcessBuilder()
-                    .command("cp", path, toPath).start();
-            process.waitFor();
-        } catch (Exception e) {
-            return null;
-        }
-        if (!isExecutableFile(toPath)) {
-            return null;
-        }
-        // For apps with target sdk >= 29, executing app data file isn't allowed.
-        // For android R, app context isn't allowed to use perf_event_open.
-        // So test executing downloaded simpleperf.
-        try {
-            Process process = new ProcessBuilder().command(toPath, "list", "sw").start();
-            process.waitFor();
-            String data = readInputStream(process.getInputStream());
-            if (!data.contains("cpu-clock")) {
-                return null;
-            }
-        } catch (Exception e) {
-            return null;
-        }
-        return toPath;
-    }
-
     private void checkIfPerfEnabled() {
         if (getProperty("persist.simpleperf.profile_app_uid").equals("" + Os.getuid())) {
             String timeStr = getProperty("persist.simpleperf.profile_app_expiration_time");
@@ -364,8 +330,8 @@ public class ProfileSession {
 
     @NonNull
     private String readReply() {
-        // Read one byte at a time to stop at line break or EOF. BufferedReader will try to read
-        // more than available and make us blocking, so don't use it.
+        // Read one byte at a time to stop at line break or EOF. BufferedReader will try
+        // to read more than available and make us blocking, so don't use it.
         String s = "";
         while (true) {
             int c = -1;
diff --git a/simpleperf/cmd_api_test.cpp b/simpleperf/cmd_api_test.cpp
index d1fb044a..40fd5e1c 100644
--- a/simpleperf/cmd_api_test.cpp
+++ b/simpleperf/cmd_api_test.cpp
@@ -75,7 +75,6 @@ static void RecordApp(const std::string& package_name, const std::string& apk_pa
   ASSERT_TRUE(WaitUntilAppExit(package_name));
 
   // 5. Collect perf.data.
-  SetRunInAppToolForTesting(true, true);
   TemporaryFile tmpfile;
   ASSERT_TRUE(
       CreateCommandInstance("api-collect")->Run({"--app", package_name, "-o", tmpfile.path}));
diff --git a/simpleperf/cmd_list.cpp b/simpleperf/cmd_list.cpp
index f6a474d1..1f904c2e 100644
--- a/simpleperf/cmd_list.cpp
+++ b/simpleperf/cmd_list.cpp
@@ -25,6 +25,7 @@
 
 #include <android-base/file.h>
 #include <android-base/logging.h>
+#include <android-base/strings.h>
 
 #include "ETMRecorder.h"
 #include "RegEx.h"
@@ -157,7 +158,11 @@ class RawEventSupportChecker {
           got_status = true;
         }
       } else if (model.arch == "x86") {
-        if (event_type.limited_arch != model_name) {
+        std::string limited_arch = event_type.limited_arch;
+        if (auto pos = limited_arch.find(':'); pos != std::string::npos) {
+          limited_arch = limited_arch.substr(0, pos);
+        }
+        if (limited_arch != model_name) {
           supported = false;
           got_status = true;
         }
@@ -196,10 +201,10 @@ class RawEventSupportChecker {
       return it->second;
     }
 #elif defined(__i386__) || defined(__x86_64__)
-    if (model.x86_data.vendor_id == "GenuineIntel") {
+    if (android::base::StartsWith(model.x86_data.vendor_id, "GenuineIntel")) {
       return "x86-intel";
     }
-    if (model.x86_data.vendor_id == "AuthenticAMD") {
+    if (android::base::StartsWith(model.x86_data.vendor_id, "AuthenticAMD")) {
       return "x86-amd";
     }
 #endif  // defined(__i386__) || defined(__x86_64__)
@@ -220,6 +225,13 @@ class RawEventSupportChecker {
       std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
     perf_event_attr attr = CreateDefaultPerfEventAttr(event_type);
+    attr.exclude_kernel = 1;
+#if defined(__i386__) || defined(__x86_64__)
+    std::set<int> atom_cpus = GetX86IntelAtomCpus();
+    if (atom_cpus.count(cpu) > 0) {
+      attr.config = event_type.GetIntelAtomCpuConfig();
+    }
+#endif  // defined(__i386__) || defined(__x86_64__)
     std::unique_ptr<EventFd> event_fd = EventFd::OpenEventFile(
         attr, test_thread_arg.tid, test_thread_arg.cpu, nullptr, event_type.name, false);
     test_thread_arg.start = true;
diff --git a/simpleperf/cmd_record.cpp b/simpleperf/cmd_record.cpp
index de4b8578..6c8f793f 100644
--- a/simpleperf/cmd_record.cpp
+++ b/simpleperf/cmd_record.cpp
@@ -173,6 +173,7 @@ class RecordCommand : public Command {
 "               2) a raw PMU event in rN format. N is a hex number.\n"
 "                  For example, r1b selects event number 0x1b.\n"
 "               3) a kprobe event added by --kprobe option.\n"
+"               4) a uprobe event added by --uprobe option.\n"
 "             Modifiers can be added to define how the event should be\n"
 "             monitored. Possible modifiers are:\n"
 "                u - monitor user space events only\n"
@@ -188,6 +189,13 @@ class RecordCommand : public Command {
 "             Documentation/trace/kprobetrace.rst in the kernel. Examples:\n"
 "               'p:myprobe do_sys_openat2 $arg2:string'   - add event kprobes:myprobe\n"
 "               'r:myretprobe do_sys_openat2 $retval:s64' - add event kprobes:myretprobe\n"
+"--uprobe uprobe_event1,uprobe_event2,...\n"
+"             Add uprobe events during recording. The uprobe_event format is in\n"
+"             Documentation/trace/uprobetracer.rst in the kernel. Examples:\n"
+"               'p:myprobe /system/lib64/libc.so:0x1000'\n"
+"                   - add event uprobes:myprobe\n"
+"               'r:myretprobe /system/lib64/libc.so:0x1000'\n"
+"                   - add event uprobes:myretprobe\n"
 "--add-counter event1,event2,...     Add additional event counts in record samples. For example,\n"
 "                                    we can use `-e cpu-cycles --add-counter instructions` to\n"
 "                                    get samples for cpu-cycles event, while having instructions\n"
@@ -592,6 +600,12 @@ bool RecordCommand::PrepareRecording(Workload* workload) {
 
   // 3. Process options before opening perf event files.
   exclude_kernel_callchain_ = event_selection_set_.ExcludeKernel();
+#if defined(__ANDROID__)
+  // Enforce removing kernel IP addresses to prevent KASLR disclosure.
+  if (!IsRoot()) {
+    exclude_kernel_callchain_ = true;
+  }
+#endif  // defined(__ANDROID__)
   if (trace_offcpu_ && !TraceOffCpu()) {
     return false;
   }
@@ -1126,7 +1140,15 @@ bool RecordCommand::ParseOptions(const std::vector<std::string>& args,
   for (const OptionValue& value : options.PullValues("--kprobe")) {
     std::vector<std::string> cmds = android::base::Split(value.str_value, ",");
     for (const auto& cmd : cmds) {
-      if (!probe_events.AddKprobe(cmd)) {
+      if (!probe_events.AddProbe(ProbeEventType::kKprobe, cmd)) {
+        return false;
+      }
+    }
+  }
+  for (const OptionValue& value : options.PullValues("--uprobe")) {
+    std::vector<std::string> cmds = android::base::Split(value.str_value, ",");
+    for (const auto& cmd : cmds) {
+      if (!probe_events.AddProbe(ProbeEventType::kUprobe, cmd)) {
         return false;
       }
     }
@@ -1244,6 +1266,12 @@ bool RecordCommand::ParseOptions(const std::vector<std::string>& args,
 
   CHECK(options.values.empty());
 
+  bool check_event_type = true;
+  if (!app_package_name_.empty() && !in_app_context_ && !IsRoot()) {
+    // Defer event type checking when RunInAppContext() is called.
+    check_event_type = false;
+  }
+
   // Process ordered options.
   for (const auto& pair : ordered_options) {
     const OptionName& name = pair.first;
@@ -1263,6 +1291,7 @@ bool RecordCommand::ParseOptions(const std::vector<std::string>& args,
           return false;
         }
         rate.sample_freq = value.uint_value;
+        max_sample_freq_ = std::max(max_sample_freq_, rate.sample_freq);
       }
       event_selection_set_.SetSampleRateForNewEvents(rate);
 
@@ -1306,7 +1335,7 @@ bool RecordCommand::ParseOptions(const std::vector<std::string>& args,
         if (!probe_events.CreateProbeEventIfNotExist(event_type)) {
           return false;
         }
-        if (!event_selection_set_.AddEventType(event_type)) {
+        if (!event_selection_set_.AddEventType(event_type, check_event_type)) {
           return false;
         }
       }
@@ -1320,7 +1349,7 @@ bool RecordCommand::ParseOptions(const std::vector<std::string>& args,
           return false;
         }
       }
-      if (!event_selection_set_.AddEventGroup(event_types)) {
+      if (!event_selection_set_.AddEventGroup(event_types, check_event_type)) {
         return false;
       }
     } else if (name == "--tp-filter") {
@@ -1984,14 +2013,18 @@ bool RecordCommand::JoinCallChains() {
 
 static void LoadSymbolMapFile(int pid, const std::string& package, ThreadTree* thread_tree) {
   // On Linux, symbol map files usually go to /tmp/perf-<pid>.map
-  // On Android, there is no directory where any process can create files.
-  // For now, use /data/local/tmp/perf-<pid>.map, which works for standalone programs,
-  // and /data/data/<package>/perf-<pid>.map, which works for apps.
-  auto path = package.empty()
-                  ? android::base::StringPrintf("/data/local/tmp/perf-%d.map", pid)
-                  : android::base::StringPrintf("/data/data/%s/perf-%d.map", package.c_str(), pid);
-
-  auto symbols = ReadSymbolMapFromFile(path);
+  // On Android, use /tmp/perf-<pid>.map and /data/local/tmp/perf-<pid>.map, which works for
+  // standalone programs, and /data/data/<package>/perf-<pid>.map, which works for apps.
+  std::vector<Symbol> symbols;
+  std::string filename = android::base::StringPrintf("perf-%d.map", pid);
+  if (package.empty()) {
+    symbols = ReadSymbolMapFromFile("/tmp/" + filename);
+    if (symbols.empty()) {
+      symbols = ReadSymbolMapFromFile("/data/local/tmp/" + filename);
+    }
+  } else {
+    symbols = ReadSymbolMapFromFile("/data/data/" + package + "/" + filename);
+  }
   if (!symbols.empty()) {
     thread_tree->AddSymbolsForProcess(pid, &symbols);
   }
diff --git a/simpleperf/cmd_record_impl.h b/simpleperf/cmd_record_impl.h
index 1d92be7e..774a917d 100644
--- a/simpleperf/cmd_record_impl.h
+++ b/simpleperf/cmd_record_impl.h
@@ -69,6 +69,7 @@ inline const OptionFormatMap& GetRecordCmdOptionFormats() {
         {"--keep-failed-unwinding-debug-info",
          {OptionValueType::NONE, OptionType::SINGLE, AppRunnerType::NOT_ALLOWED}},
         {"--kprobe", {OptionValueType::STRING, OptionType::MULTIPLE, AppRunnerType::NOT_ALLOWED}},
+        {"--uprobe", {OptionValueType::STRING, OptionType::MULTIPLE, AppRunnerType::NOT_ALLOWED}},
         {"-m", {OptionValueType::UINT, OptionType::SINGLE, AppRunnerType::ALLOWED}},
         {"--no-callchain-joiner",
          {OptionValueType::NONE, OptionType::SINGLE, AppRunnerType::ALLOWED}},
diff --git a/simpleperf/cmd_record_test.cpp b/simpleperf/cmd_record_test.cpp
index 924bbcf0..a7aef6b4 100644
--- a/simpleperf/cmd_record_test.cpp
+++ b/simpleperf/cmd_record_test.cpp
@@ -58,7 +58,10 @@ static std::unique_ptr<Command> RecordCmd() {
 }
 
 static const char* GetDefaultEvent() {
-  return HasHardwareCounter() ? "cpu-cycles" : "task-clock";
+  if (HasHardwareCounter()) {
+    return IsKernelEventSupported() ? "cpu-cycles" : "cpu-cycles:u";
+  }
+  return IsKernelEventSupported() ? "task-clock" : "task-clock:u";
 }
 
 static bool RunRecordCmd(std::vector<std::string> v, const char* output_file = nullptr) {
@@ -97,7 +100,11 @@ TEST(record_cmd, system_wide_option) {
 
 static void CheckEventType(const std::string& record_file, const std::string& event_type,
                            uint64_t sample_period, uint64_t sample_freq) {
-  const EventType* type = FindEventTypeByName(event_type);
+  std::string event_name = event_type;
+  if (auto pos = event_name.find(":u"); pos != std::string::npos) {
+    event_name = event_name.substr(0, pos);
+  }
+  const EventType* type = FindEventTypeByName(event_name);
   ASSERT_TRUE(type != nullptr);
   std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(record_file);
   ASSERT_TRUE(reader);
@@ -126,7 +133,7 @@ TEST(record_cmd, sample_period_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, event_option) {
-  ASSERT_TRUE(RunRecordCmd({"-e", "cpu-clock"}));
+  ASSERT_TRUE(RunRecordCmd({"-e", "cpu-clock:u"}));
 }
 
 // @CddTest = 6.1/C-0-2
@@ -134,15 +141,15 @@ TEST(record_cmd, freq_option) {
   TemporaryFile tmpfile;
   ASSERT_TRUE(RunRecordCmd({"-f", "99"}, tmpfile.path));
   CheckEventType(tmpfile.path, GetDefaultEvent(), 0, 99u);
-  ASSERT_TRUE(RunRecordCmd({"-e", "cpu-clock", "-f", "99"}, tmpfile.path));
-  CheckEventType(tmpfile.path, "cpu-clock", 0, 99u);
+  ASSERT_TRUE(RunRecordCmd({"-e", "cpu-clock:u", "-f", "99"}, tmpfile.path));
+  CheckEventType(tmpfile.path, "cpu-clock:u", 0, 99u);
   ASSERT_FALSE(RunRecordCmd({"-f", std::to_string(UINT_MAX)}));
 }
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, multiple_freq_or_sample_period_option) {
   TemporaryFile tmpfile;
-  ASSERT_TRUE(RunRecordCmd({"-f", "99", "-e", "task-clock", "-c", "1000000", "-e", "cpu-clock"},
+  ASSERT_TRUE(RunRecordCmd({"-f", "99", "-e", "task-clock:u", "-c", "1000000", "-e", "cpu-clock:u"},
                            tmpfile.path));
   CheckEventType(tmpfile.path, "task-clock", 0, 99u);
   CheckEventType(tmpfile.path, "cpu-clock", 1000000u, 0u);
@@ -156,6 +163,7 @@ TEST(record_cmd, output_file_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, dump_kernel_mmap) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   TemporaryFile tmpfile;
   ASSERT_TRUE(RunRecordCmd({}, tmpfile.path));
   std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);
@@ -211,7 +219,7 @@ TEST(record_cmd, rN_event) {
     GTEST_LOG_(INFO) << "Omit arch " << GetTargetArch();
     return;
   }
-  std::string event_name = android::base::StringPrintf("r%zx", event_number);
+  std::string event_name = android::base::StringPrintf("r%zx:u", event_number);
   TemporaryFile tmpfile;
   ASSERT_TRUE(RunRecordCmd({"-e", event_name}, tmpfile.path));
   std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);
@@ -239,7 +247,11 @@ TEST(record_cmd, branch_sampling) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, event_modifier) {
-  ASSERT_TRUE(RunRecordCmd({"-e", GetDefaultEvent() + std::string(":u")}));
+  std::string event_name = GetDefaultEvent();
+  if (event_name.find(':') == std::string::npos) {
+    event_name += ":u";
+  }
+  ASSERT_TRUE(RunRecordCmd({"-e", event_name}));
 }
 
 // @CddTest = 6.1/C-0-2
@@ -340,8 +352,8 @@ TEST(record_cmd, no_monitored_threads) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, more_than_one_event_types) {
-  ASSERT_TRUE(RunRecordCmd({"-e", "task-clock,cpu-clock"}));
-  ASSERT_TRUE(RunRecordCmd({"-e", "task-clock", "-e", "cpu-clock"}));
+  ASSERT_TRUE(RunRecordCmd({"-e", "task-clock:u,cpu-clock:u"}));
+  ASSERT_TRUE(RunRecordCmd({"-e", "task-clock:u", "-e", "cpu-clock:u"}));
 }
 
 // @CddTest = 6.1/C-0-2
@@ -451,10 +463,12 @@ TEST(record_cmd, dump_kernel_symbols) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, group_option) {
-  ASSERT_TRUE(RunRecordCmd({"--group", "task-clock,cpu-clock", "-m", "16"}));
-  ASSERT_TRUE(
-      RunRecordCmd({"--group", "task-clock,cpu-clock", "--group", "task-clock:u,cpu-clock:u",
-                    "--group", "task-clock:k,cpu-clock:k", "-m", "16"}));
+  ASSERT_TRUE(RunRecordCmd({"--group", "task-clock:u,cpu-clock:u", "-m", "16"}));
+  if (IsRoot()) {
+    ASSERT_TRUE(
+        RunRecordCmd({"--group", "task-clock,cpu-clock", "--group", "task-clock:u,cpu-clock:u",
+                      "--group", "task-clock:k,cpu-clock:k", "-m", "16"}));
+  }
 }
 
 // @CddTest = 6.1/C-0-2
@@ -473,6 +487,7 @@ TEST(record_cmd, duration_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, support_modifier_for_clock_events) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   for (const std::string& e : {"cpu-clock", "task-clock"}) {
     for (const std::string& m : {"u", "k"}) {
       ASSERT_TRUE(RunRecordCmd({"-e", e + ":" + m})) << "event " << e << ":" << m;
@@ -571,7 +586,7 @@ TEST(record_cmd, cpu_clock_for_a_long_time) {
   std::string pid = std::to_string(workloads[0]->GetPid());
   TemporaryFile tmpfile;
   ASSERT_TRUE(
-      RecordCmd()->Run({"-e", "cpu-clock", "-o", tmpfile.path, "-p", pid, "--duration", "3"}));
+      RecordCmd()->Run({"-e", "cpu-clock:u", "-o", tmpfile.path, "-p", pid, "--duration", "3"}));
 }
 
 // @CddTest = 6.1/C-0-2
@@ -587,6 +602,7 @@ TEST(record_cmd, dump_regs_for_tracepoint_events) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, trace_offcpu_option) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   // On linux host, we need root privilege to read tracepoint events.
   TEST_REQUIRE_HOST_ROOT();
   TEST_REQUIRE_TRACEPOINT_EVENTS();
@@ -646,7 +662,7 @@ TEST(record_cmd, clockid_option) {
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, generate_samples_by_hw_counters) {
   TEST_REQUIRE_HW_COUNTER();
-  std::vector<std::string> events = {"cpu-cycles", "instructions"};
+  std::vector<std::string> events = {"cpu-cycles:u", "instructions:u"};
   for (auto& event : events) {
     TemporaryFile tmpfile;
     ASSERT_TRUE(RecordCmd()->Run({"-e", event, "-o", tmpfile.path, "sleep", "1"}));
@@ -732,7 +748,7 @@ TEST(record_cmd, kernel_bug_making_zero_dyn_size_for_kernel_samples) {
   // kernels. If it fails, please cherry pick below kernel patch:
   // 02e184476eff8 perf/core: Force USER_DS when recording user stack data
   OMIT_TEST_ON_NON_NATIVE_ABIS();
-  TEST_REQUIRE_HOST_ROOT();
+  TEST_REQUIRE_ROOT();
   TEST_REQUIRE_TRACEPOINT_EVENTS();
   std::vector<std::unique_ptr<Workload>> workloads;
   CreateProcesses(1, &workloads);
@@ -859,6 +875,20 @@ static void TestRecordingApps(const std::string& app_name, const std::string& ap
   it = meta_info.find("app_type");
   ASSERT_NE(it, meta_info.end());
   ASSERT_EQ(it->second, app_type);
+
+  if (!IsRoot()) {
+    // Check that we are not leaking kernel ip addresses.
+    auto process_record = [](std::unique_ptr<Record> r) {
+      if (r->type() == PERF_RECORD_SAMPLE) {
+        const SampleRecord* sr = static_cast<const SampleRecord*>(r.get());
+        if (sr->InKernel()) {
+          return false;
+        }
+      }
+      return true;
+    };
+    ASSERT_TRUE(reader->ReadDataSection(process_record));
+  }
   reader.reset(nullptr);
 
   // Check that simpleperf can't execute child command in app uid.
@@ -871,17 +901,16 @@ static void TestRecordingApps(const std::string& app_name, const std::string& ap
 TEST(record_cmd, app_option_for_debuggable_app) {
   OMIT_TEST_ON_NON_NATIVE_ABIS();
   TEST_REQUIRE_APPS();
-  SetRunInAppToolForTesting(true, false);
   TestRecordingApps("com.android.simpleperf.debuggable", "debuggable");
-  SetRunInAppToolForTesting(false, true);
+  SetRunInAppToolForTesting(true, false);
   TestRecordingApps("com.android.simpleperf.debuggable", "debuggable");
+  SetRunInAppToolForTesting(true, true);
 }
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, app_option_for_profileable_app) {
   OMIT_TEST_ON_NON_NATIVE_ABIS();
   TEST_REQUIRE_APPS();
-  SetRunInAppToolForTesting(false, true);
   TestRecordingApps("com.android.simpleperf.profileable", "profileable");
 }
 
@@ -901,7 +930,6 @@ static void RecordJavaApp(RecordingAppHelper& helper) {
                       "androidx.test.runner.AndroidJUnitRunner"));
 
   // 3. Record perf.data.
-  SetRunInAppToolForTesting(true, true);
   ASSERT_TRUE(helper.RecordData(
       "-e cpu-clock --app com.example.android.displayingbitmaps -g --duration 15"));
 }
@@ -956,7 +984,6 @@ TEST(record_cmd, record_native_app) {
                       "android.intent.action.MAIN -c android.intent.category.LAUNCHER"));
 
   // 3. Record perf.data.
-  SetRunInAppToolForTesting(true, true);
   ASSERT_TRUE(helper.RecordData("-e cpu-clock --app com.google.sample.tunnel -g --duration 10"));
 
   // 4. Check perf.data.
@@ -1279,7 +1306,7 @@ TEST(record_cmd, exclude_perf_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, tp_filter_option) {
-  TEST_REQUIRE_HOST_ROOT();
+  TEST_REQUIRE_KERNEL_EVENTS();
   TEST_REQUIRE_TRACEPOINT_EVENTS();
   // Test string operands both with quotes and without quotes.
   for (const auto& filter :
@@ -1336,7 +1363,7 @@ TEST(record_cmd, kprobe_option) {
   TEST_REQUIRE_ROOT();
   EventSelectionSet event_selection_set(false);
   ProbeEvents probe_events(event_selection_set);
-  if (!probe_events.IsKprobeSupported()) {
+  if (!probe_events.IsProbeSupported(ProbeEventType::kKprobe)) {
     GTEST_LOG_(INFO) << "Skip this test as kprobe isn't supported by the kernel.";
     return;
   }
@@ -1346,6 +1373,29 @@ TEST(record_cmd, kprobe_option) {
   ASSERT_TRUE(RunRecordCmd({"--group", "kprobes:do_sys_openat2"}));
 }
 
+// @CddTest = 6.1/C-0-2
+TEST(record_cmd, uprobe_option) {
+  TEST_REQUIRE_ROOT();
+  EventSelectionSet event_selection_set(false);
+  ProbeEvents probe_events(event_selection_set);
+  if (!probe_events.IsProbeSupported(ProbeEventType::kUprobe)) {
+    GTEST_LOG_(INFO) << "Skip this test as uprobe isn't supported by the kernel.";
+    return;
+  }
+  if (!IsRegularFile("/system/lib64/libc.so")) {
+    GTEST_LOG_(INFO) << "Skip this test as /system/lib64/libc.so doesn't exist";
+    return;
+  }
+  ASSERT_TRUE(RunRecordCmd(
+      {"-e", "uprobes:myprobe", "--uprobe", "p:myprobe /system/lib64/libc.so:0x88e80"}));
+  ASSERT_TRUE(RunRecordCmd(
+      {"-e", "uprobes:p_libc_0x88e80", "--uprobe", "p /system/lib64/libc.so:0x88e80"}));
+  ASSERT_TRUE(RunRecordCmd(
+      {"-e", "uprobes:myprobe", "--uprobe", "r:myprobe /system/lib64/libc.so:0x88e80"}));
+  ASSERT_TRUE(RunRecordCmd(
+      {"-e", "uprobes:p_libc_0x88e80", "--uprobe", "r /system/lib64/libc.so:0x88e80"}));
+}
+
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, record_filter_options) {
   ASSERT_TRUE(
@@ -1368,6 +1418,7 @@ TEST(record_cmd, keep_failed_unwinding_result_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(record_cmd, kernel_address_warning) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   TEST_REQUIRE_NON_ROOT();
   const std::string warning_msg = "Access to kernel symbol addresses is restricted.";
   CapturedStderr capture;
@@ -1437,8 +1488,8 @@ TEST(record_cmd, device_meta_info) {
 TEST(record_cmd, add_counter_option) {
   TEST_REQUIRE_HW_COUNTER();
   TemporaryFile tmpfile;
-  ASSERT_TRUE(RecordCmd()->Run({"-e", "cpu-cycles", "--add-counter", "instructions", "--no-inherit",
-                                "-o", tmpfile.path, "sleep", "1"}));
+  ASSERT_TRUE(RecordCmd()->Run({"-e", "cpu-cycles:u", "--add-counter", "instructions:u",
+                                "--no-inherit", "-o", tmpfile.path, "sleep", "1"}));
   std::unique_ptr<RecordFileReader> reader = RecordFileReader::CreateInstance(tmpfile.path);
   ASSERT_TRUE(reader);
   bool has_sample = false;
@@ -1497,3 +1548,12 @@ TEST(record_cmd, compression_option) {
 
   ASSERT_TRUE(RunRecordCmd({"-z=3"}, tmpfile.path));
 }
+
+// @CddTest = 6.1/C-0-2
+TEST(record_cmd, child_process) {
+  // Test that we can run simpleperf to record samples for a child process in shell.
+  TemporaryFile tmpfile;
+  ASSERT_TRUE(Workload::RunCmd({"/system/bin/simpleperf", "record", "-e", GetDefaultEvent(), "-o",
+                                tmpfile.path, "sleep", SLEEP_SEC},
+                               true));
+}
diff --git a/simpleperf/cmd_report_test.cpp b/simpleperf/cmd_report_test.cpp
index 9170beb2..b2084791 100644
--- a/simpleperf/cmd_report_test.cpp
+++ b/simpleperf/cmd_report_test.cpp
@@ -715,7 +715,8 @@ TEST_F(ReportCommandTest, dwarf_callgraph) {
   CreateProcesses(1, &workloads);
   std::string pid = std::to_string(workloads[0]->GetPid());
   TemporaryFile tmp_file;
-  ASSERT_TRUE(RecordCmd()->Run({"-p", pid, "-g", "-o", tmp_file.path, "sleep", SLEEP_SEC}));
+  ASSERT_TRUE(RecordCmd()->Run(
+      {"-p", pid, "-g", "-o", tmp_file.path, "-e", "cpu-cycles:u", "sleep", SLEEP_SEC}));
   ReportRaw(tmp_file.path, {"-g"});
   ASSERT_TRUE(success);
 }
@@ -731,6 +732,7 @@ TEST_F(ReportCommandTest, report_dwarf_callgraph_of_nativelib_in_apk) {
 
 // @CddTest = 6.1/C-0-2
 TEST_F(ReportCommandTest, exclude_kernel_callchain) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   TEST_REQUIRE_HW_COUNTER();
   TEST_REQUIRE_HOST_ROOT();
   OMIT_TEST_ON_NON_NATIVE_ABIS();
diff --git a/simpleperf/cmd_stat.cpp b/simpleperf/cmd_stat.cpp
index 386f47a6..8f8e416f 100644
--- a/simpleperf/cmd_stat.cpp
+++ b/simpleperf/cmd_stat.cpp
@@ -348,6 +348,78 @@ class DevfreqCounters {
   std::vector<std::string> mem_latency_governor_paths_;
 };
 
+// Periodically scan /proc for new threads. If found, create new perf event files for the
+// new threads.
+class NewThreadMonitor {
+ private:
+  const int SCAN_INTERVAL_US = 1;
+
+ public:
+  NewThreadMonitor(EventSelectionSet& event_selection_set, bool monitor_all_processes,
+                   const std::set<pid_t>& monitored_processes,
+                   std::unordered_map<pid_t, ThreadInfo>& threads)
+      : event_selection_set_(event_selection_set),
+        monitor_all_processes_(monitor_all_processes),
+        monitored_processes_(monitored_processes),
+        threads_(threads) {}
+
+  bool Start() {
+    IOEventLoop* loop = event_selection_set_.GetIOEventLoop();
+    timeval tv;
+    tv.tv_sec = 0;
+    tv.tv_usec = SCAN_INTERVAL_US;
+    if (!loop->AddPeriodicEvent(tv, std::bind(&NewThreadMonitor::Scan, this))) {
+      return false;
+    }
+    // Ensure perf event files opened for new threads are immediately enabled.
+    event_selection_set_.SetEnableCondition(true, false);
+    return true;
+  }
+
+ private:
+  bool Scan() {
+    std::unordered_set<pid_t> new_tids;
+    if (monitor_all_processes_) {
+      for (int pid : GetAllProcesses()) {
+        for (auto tid : GetThreadsInProcess(pid)) {
+          if (threads_.count(tid) == 0) {
+            new_tids.insert(tid);
+          }
+        }
+      }
+    } else {
+      for (auto tid : monitored_processes_) {
+        for (auto tid : GetThreadsInProcess(tid)) {
+          if (threads_.count(tid) == 0) {
+            new_tids.insert(tid);
+          }
+        }
+      }
+    }
+    std::set<pid_t> open_event_file_tids;
+    for (auto tid : new_tids) {
+      ThreadInfo info;
+      if (ReadThreadNameAndPid(tid, &info.name, &info.pid)) {
+        info.tid = tid;
+        threads_[tid] = std::move(info);
+        open_event_file_tids.insert(tid);
+      }
+    }
+    if (!open_event_file_tids.empty()) {
+      // It's okay for OpenEventFilesForThreads() to return false. It happens
+      // when the new threads exit before we can open event files for them.
+      event_selection_set_.OpenEventFilesForThreads(open_event_file_tids);
+    }
+    return true;
+  }
+
+ private:
+  EventSelectionSet& event_selection_set_;
+  bool monitor_all_processes_ = false;
+  std::set<pid_t> monitored_processes_;
+  std::unordered_map<pid_t, ThreadInfo>& threads_;
+};
+
 class StatCommand : public Command {
  public:
   StatCommand()
@@ -394,10 +466,19 @@ class StatCommand : public Command {
 "             Documentation/trace/kprobetrace.rst in the kernel. Examples:\n"
 "               'p:myprobe do_sys_openat2 $arg2:string'   - add event kprobes:myprobe\n"
 "               'r:myretprobe do_sys_openat2 $retval:s64' - add event kprobes:myretprobe\n"
+"--uprobe uprobe_event1,uprobe_event2,...\n"
+"             Add uprobe events during stating. The uprobe_event format is in\n"
+"             Documentation/trace/uprobetracer.rst in the kernel. Examples:\n"
+"               'p:myprobe /system/lib64/libc.so:0x1000'\n"
+"                   - add event uprobes:myprobe\n"
+"               'r:myretprobe /system/lib64/libc.so:0x1000'\n"
+"                   - add event uprobes:myretprobe\n"
 "--no-inherit     Don't stat created child threads/processes.\n"
 "-o output_filename  Write report to output_filename instead of standard output.\n"
 "--per-core       Print counters for each cpu core.\n"
 "--per-thread     Print counters for each thread.\n"
+"--monitor-new-thread  Print counters for new threads created after stating. It should be used\n"
+"                      With --per-thread and --no-inherit.\n"
 "-p pid_or_process_name_regex1,pid_or_process_name_regex2,...\n"
 "                      Stat events on existing processes. Processes are searched either by pid\n"
 "                      or process name regex. Mutually exclusive with -a.\n"
@@ -459,7 +540,7 @@ class StatCommand : public Command {
   void PrintHardwareCounters();
   bool AddDefaultMeasuredEventTypes();
   void SetEventSelectionFlags();
-  void MonitorEachThread();
+  void MonitorEachThread(std::unique_ptr<Workload>& workload);
   void AdjustToIntervalOnlyValues(std::vector<CountersInfo>& counters);
   bool ShowCounters(const std::vector<CountersInfo>& counters, double duration_in_sec, FILE* fp);
   void CheckHardwareCounterMultiplexing();
@@ -483,6 +564,7 @@ class StatCommand : public Command {
 
   bool report_per_core_ = false;
   bool report_per_thread_ = false;
+  bool monitor_new_thread_ = false;
   // used to report event count for each thread
   std::unordered_map<pid_t, ThreadInfo> thread_info_;
   // used to sort report
@@ -555,9 +637,14 @@ bool StatCommand::Run(const std::vector<std::string>& args) {
   } else {
     need_to_check_targets = true;
   }
-
+  std::unique_ptr<NewThreadMonitor> new_thread_monitor;
+  if (monitor_new_thread_) {
+    new_thread_monitor.reset(new NewThreadMonitor(event_selection_set_, system_wide_collection_,
+                                                  event_selection_set_.GetMonitoredProcesses(),
+                                                  thread_info_));
+  }
   if (report_per_thread_) {
-    MonitorEachThread();
+    MonitorEachThread(workload);
   }
 
   // 3. Open perf_event_files and output file if defined.
@@ -622,6 +709,9 @@ bool StatCommand::Run(const std::vector<std::string>& args) {
       return false;
     }
   }
+  if (new_thread_monitor && !new_thread_monitor->Start()) {
+    return false;
+  }
 
   // 5. Count events while workload running.
   start_time = std::chrono::steady_clock::now();
@@ -677,11 +767,19 @@ bool StatCommand::ParseOptions(const std::vector<std::string>& args,
   in_app_context_ = options.PullBoolValue("--in-app");
   for (const OptionValue& value : options.PullValues("--kprobe")) {
     for (const auto& cmd : Split(value.str_value, ",")) {
-      if (!probe_events.AddKprobe(cmd)) {
+      if (!probe_events.AddProbe(ProbeEventType::kKprobe, cmd)) {
         return false;
       }
     }
   }
+  for (const OptionValue& value : options.PullValues("--uprobe")) {
+    for (const auto& cmd : Split(value.str_value, ",")) {
+      if (!probe_events.AddProbe(ProbeEventType::kUprobe, cmd)) {
+        return false;
+      }
+    }
+  }
+  monitor_new_thread_ = options.PullBoolValue("--monitor-new-thread");
   child_inherit_ = !options.PullBoolValue("--no-inherit");
 
   if (auto value = options.PullValue("-o"); value) {
@@ -730,6 +828,12 @@ bool StatCommand::ParseOptions(const std::vector<std::string>& args,
 
   CHECK(options.values.empty());
 
+  bool check_event_type = true;
+  if (!app_package_name_.empty() && !in_app_context_ && !IsRoot()) {
+    // Defer event type checking when RunInAppContext() is called.
+    check_event_type = false;
+  }
+
   // Process ordered options.
   for (const auto& pair : ordered_options) {
     const OptionName& name = pair.first;
@@ -747,7 +851,7 @@ bool StatCommand::ParseOptions(const std::vector<std::string>& args,
         if (!probe_events.CreateProbeEventIfNotExist(event_type)) {
           return false;
         }
-        if (!event_selection_set_.AddEventType(event_type)) {
+        if (!event_selection_set_.AddEventType(event_type, check_event_type)) {
           return false;
         }
       }
@@ -758,7 +862,7 @@ bool StatCommand::ParseOptions(const std::vector<std::string>& args,
           return false;
         }
       }
-      if (!event_selection_set_.AddEventGroup(event_types)) {
+      if (!event_selection_set_.AddEventGroup(event_types, check_event_type)) {
         return false;
       }
     } else if (name == "--tp-filter") {
@@ -780,6 +884,12 @@ bool StatCommand::ParseOptions(const std::vector<std::string>& args,
     LOG(ERROR) << "System wide profiling needs root privilege.";
     return false;
   }
+  if (monitor_new_thread_) {
+    if (!report_per_thread_ || child_inherit_) {
+      LOG(ERROR) << "--monitor-new-thread should be used with --per-thread and --no-inherit";
+      return false;
+    }
+  }
 
   if (report_per_core_ || report_per_thread_) {
     summary_comparator_ = BuildSummaryComparator(sort_keys_, report_per_thread_, report_per_core_);
@@ -799,6 +909,7 @@ std::optional<bool> CheckHardwareCountersOnCpu(int cpu, size_t counters) {
     return std::nullopt;
   }
   perf_event_attr attr = CreateDefaultPerfEventAttr(*event);
+  attr.exclude_kernel = true;
   auto workload = Workload::CreateWorkload({"sleep", "0.1"});
   if (!workload || !workload->SetCpuAffinity(cpu)) {
     return std::nullopt;
@@ -857,11 +968,22 @@ void StatCommand::PrintHardwareCounters() {
 }
 
 bool StatCommand::AddDefaultMeasuredEventTypes() {
-  for (auto& name : default_measured_event_types) {
+  for (std::string name : default_measured_event_types) {
     // It is not an error when some event types in the default list are not
     // supported by the kernel.
     const EventType* type = FindEventTypeByName(name);
-    if (type != nullptr && IsEventAttrSupported(CreateDefaultPerfEventAttr(*type), name)) {
+    if (type == nullptr) {
+      continue;
+    }
+    perf_event_attr attr = CreateDefaultPerfEventAttr(*type);
+    if (!IsKernelEventSupported()) {
+      attr.exclude_kernel = true;
+      if (name == "cpu-clock" || name == "task-clock") {
+        continue;
+      }
+      name += ":u";
+    }
+    if (IsEventAttrSupported(attr, name)) {
       if (!event_selection_set_.AddEventType(name)) {
         return false;
       }
@@ -878,12 +1000,15 @@ void StatCommand::SetEventSelectionFlags() {
   event_selection_set_.SetInherit(child_inherit_);
 }
 
-void StatCommand::MonitorEachThread() {
+void StatCommand::MonitorEachThread(std::unique_ptr<Workload>& workload) {
   std::vector<pid_t> threads;
   for (auto pid : event_selection_set_.GetMonitoredProcesses()) {
     for (auto tid : GetThreadsInProcess(pid)) {
       ThreadInfo info;
       if (GetThreadName(tid, &info.name)) {
+        if (tid == pid && workload && workload->GetPid() == pid) {
+          info.name = workload->GetCommandName();
+        }
         info.tid = tid;
         info.pid = pid;
         thread_info_[tid] = std::move(info);
diff --git a/simpleperf/cmd_stat_impl.h b/simpleperf/cmd_stat_impl.h
index a7397477..bf7a6ca5 100644
--- a/simpleperf/cmd_stat_impl.h
+++ b/simpleperf/cmd_stat_impl.h
@@ -317,6 +317,8 @@ inline const OptionFormatMap& GetStatCmdOptionFormats() {
       {"--group", {OptionValueType::STRING, OptionType::ORDERED, AppRunnerType::ALLOWED}},
       {"--in-app", {OptionValueType::NONE, OptionType::SINGLE, AppRunnerType::ALLOWED}},
       {"--kprobe", {OptionValueType::STRING, OptionType::MULTIPLE, AppRunnerType::NOT_ALLOWED}},
+      {"--uprobe", {OptionValueType::STRING, OptionType::MULTIPLE, AppRunnerType::NOT_ALLOWED}},
+      {"--monitor-new-thread", {OptionValueType::NONE, OptionType::SINGLE, AppRunnerType::ALLOWED}},
       {"--no-inherit", {OptionValueType::NONE, OptionType::SINGLE, AppRunnerType::ALLOWED}},
       {"-o", {OptionValueType::STRING, OptionType::SINGLE, AppRunnerType::NOT_ALLOWED}},
       {"--out-fd", {OptionValueType::UINT, OptionType::SINGLE, AppRunnerType::CHECK_FD}},
@@ -337,4 +339,4 @@ inline const OptionFormatMap& GetStatCmdOptionFormats() {
   return option_formats;
 }
 
-}  // namespace simpleperf
\ No newline at end of file
+}  // namespace simpleperf
diff --git a/simpleperf/cmd_stat_test.cpp b/simpleperf/cmd_stat_test.cpp
index c47ad729..6a989a82 100644
--- a/simpleperf/cmd_stat_test.cpp
+++ b/simpleperf/cmd_stat_test.cpp
@@ -43,7 +43,8 @@ TEST(stat_cmd, no_options) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, event_option) {
-  ASSERT_TRUE(StatCmd()->Run({"-e", "cpu-clock,task-clock", "sleep", "1"}));
+  TEST_REQUIRE_HW_COUNTER();
+  ASSERT_TRUE(StatCmd()->Run({"-e", "cpu-cycles:u,instructions:u", "sleep", "1"}));
 }
 
 // @CddTest = 6.1/C-0-2
@@ -53,7 +54,8 @@ TEST(stat_cmd, system_wide_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, verbose_option) {
-  ASSERT_TRUE(StatCmd()->Run({"--verbose", "sleep", "1"}));
+  TEST_REQUIRE_HW_COUNTER();
+  ASSERT_TRUE(StatCmd()->Run({"--verbose", "-e", "cpu-cycles:u", "sleep", "1"}));
 }
 
 // @CddTest = 6.1/C-0-2
@@ -81,7 +83,7 @@ TEST(stat_cmd, rN_event) {
     GTEST_LOG_(INFO) << "Omit arch " << GetTargetArch();
     return;
   }
-  std::string event_name = android::base::StringPrintf("r%zx", event_number);
+  std::string event_name = android::base::StringPrintf("r%zx:u", event_number);
   ASSERT_TRUE(StatCmd()->Run({"-e", event_name, "sleep", "1"}));
 }
 
@@ -106,13 +108,13 @@ TEST(stat_cmd, pmu_event) {
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, event_modifier) {
   TEST_REQUIRE_HW_COUNTER();
+  TEST_REQUIRE_ROOT();
   ASSERT_TRUE(StatCmd()->Run({"-e", "cpu-cycles:u,cpu-cycles:k", "sleep", "1"}));
 }
 
 void RunWorkloadFunction() {
   while (true) {
-    for (volatile int i = 0; i < 10000; ++i)
-      ;
+    for (volatile int i = 0; i < 10000; ++i);
     usleep(1);
   }
 }
@@ -156,6 +158,7 @@ TEST(stat_cmd, no_monitored_threads) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, group_option) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   TEST_REQUIRE_HW_COUNTER();
   ASSERT_TRUE(StatCmd()->Run({"--group", "cpu-clock,page-faults", "sleep", "1"}));
   ASSERT_TRUE(StatCmd()->Run({"--group", "cpu-cycles,instructions", "--group",
@@ -165,6 +168,7 @@ TEST(stat_cmd, group_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, auto_generated_summary) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   TEST_REQUIRE_HW_COUNTER();
   TemporaryFile tmp_file;
   ASSERT_TRUE(StatCmd()->Run(
@@ -217,6 +221,7 @@ TEST(stat_cmd, interval_only_values_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, no_modifier_for_clock_events) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   for (const std::string& e : {"cpu-clock", "task-clock"}) {
     for (const std::string& m : {"u", "k"}) {
       ASSERT_FALSE(StatCmd()->Run({"-e", e + ":" + m, "sleep", "0.1"}))
@@ -243,8 +248,7 @@ TEST(stat_cmd, stop_when_no_more_targets) {
     sleep(1);
   });
   thread.detach();
-  while (tid == 0)
-    ;
+  while (tid == 0);
   ASSERT_TRUE(StatCmd()->Run({"-t", std::to_string(tid), "--in-app"}));
 }
 
@@ -252,7 +256,7 @@ TEST(stat_cmd, stop_when_no_more_targets) {
 TEST(stat_cmd, sample_rate_should_be_zero) {
   TEST_REQUIRE_HW_COUNTER();
   EventSelectionSet set(true);
-  ASSERT_TRUE(set.AddEventType("cpu-cycles"));
+  ASSERT_TRUE(set.AddEventType("cpu-cycles:u"));
   set.AddMonitoredProcesses({getpid()});
   set.SetCpusForNewEvents({-1});
   ASSERT_TRUE(set.OpenEventFiles());
@@ -267,6 +271,7 @@ TEST(stat_cmd, sample_rate_should_be_zero) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, calculating_cpu_frequency) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   TEST_REQUIRE_HW_COUNTER();
   CaptureStdout capture;
   ASSERT_TRUE(capture.Start());
@@ -293,6 +298,7 @@ TEST(stat_cmd, calculating_cpu_frequency) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, set_comm_in_another_thread) {
+  TEST_REQUIRE_KERNEL_EVENTS();
   // Test a kernel bug which was fixed in 3.15. If kernel panic happens, please cherry pick kernel
   // patch: e041e328c4b41e perf: Fix perf_event_comm() vs. exec() assumption
   TEST_REQUIRE_HW_COUNTER();
@@ -347,16 +353,12 @@ static void TestStatingApps(const std::string& app_name) {
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, app_option_for_debuggable_app) {
   TEST_REQUIRE_APPS();
-  SetRunInAppToolForTesting(true, false);
-  TestStatingApps("com.android.simpleperf.debuggable");
-  SetRunInAppToolForTesting(false, true);
   TestStatingApps("com.android.simpleperf.debuggable");
 }
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, app_option_for_profileable_app) {
   TEST_REQUIRE_APPS();
-  SetRunInAppToolForTesting(false, true);
   TestStatingApps("com.android.simpleperf.profileable");
 }
 
@@ -375,6 +377,14 @@ TEST(stat_cmd, per_thread_option) {
   TEST_IN_ROOT(StatCmd()->Run({"--per-thread", "-a", "--duration", "0.1"}));
 }
 
+// @CddTest = 6.1/C-0-2
+TEST(stat_cmd, monitor_new_thread_option) {
+  ASSERT_TRUE(
+      StatCmd()->Run({"--per-thread", "--monitor-new-thread", "--no-inherit", "sleep", "0.1"}));
+  TEST_IN_ROOT(StatCmd()->Run(
+      {"--per-thread", "--monitor-new-thread", "--no-inherit", "-a", "--duration", "0.1"}));
+}
+
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, per_core_option) {
   ASSERT_TRUE(StatCmd()->Run({"--per-core", "sleep", "0.1"}));
@@ -419,6 +429,7 @@ TEST(stat_cmd, print_hw_counter_option) {
 
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, record_different_counters_for_different_cpus) {
+  TEST_REQUIRE_HW_COUNTER();
   std::vector<int> online_cpus = GetOnlineCpus();
   ASSERT_FALSE(online_cpus.empty());
   std::string cpu0 = std::to_string(online_cpus[0]);
@@ -426,22 +437,20 @@ TEST(stat_cmd, record_different_counters_for_different_cpus) {
 
   CaptureStdout capture;
   ASSERT_TRUE(capture.Start());
-  ASSERT_TRUE(StatCmd()->Run({"--csv", "--cpu", cpu0, "-e", "cpu-clock", "--cpu", cpu1, "-e",
-                              "task-clock", "--verbose", "sleep", SLEEP_SEC}));
+  ASSERT_TRUE(StatCmd()->Run({"--csv", "--cpu", cpu0, "-e", "cpu-cycles:u", "--cpu", cpu1, "-e",
+                              "instructions:u", "--verbose", "sleep", SLEEP_SEC}));
   std::string output = capture.Finish();
-  bool has_cpu_clock = false;
-  bool has_task_clock = false;
+  int mask = 0;
   for (auto& line : android::base::Split(output, "\n")) {
-    if (android::base::StartsWith(line, "cpu-clock,")) {
+    if (android::base::StartsWith(line, "cpu-cycles,")) {
       ASSERT_NE(line.find("cpu," + cpu0 + ","), line.npos) << output;
-      has_cpu_clock = true;
-    } else if (android::base::StartsWith(line, "task-clock,")) {
+      mask |= 1;
+    } else if (android::base::StartsWith(line, "instructions,")) {
       ASSERT_NE(line.find("cpu," + cpu1 + ","), line.npos) << output;
-      has_task_clock = true;
+      mask |= 2;
     }
   }
-  ASSERT_TRUE(has_cpu_clock) << output;
-  ASSERT_TRUE(has_task_clock) << output;
+  ASSERT_EQ(mask, 3) << output;
 }
 
 // @CddTest = 6.1/C-0-2
@@ -449,7 +458,7 @@ TEST(stat_cmd, kprobe_option) {
   TEST_REQUIRE_ROOT();
   EventSelectionSet event_selection_set(false);
   ProbeEvents probe_events(event_selection_set);
-  if (!probe_events.IsKprobeSupported()) {
+  if (!probe_events.IsProbeSupported(ProbeEventType::kKprobe)) {
     GTEST_LOG_(INFO) << "Skip this test as kprobe isn't supported by the kernel.";
     return;
   }
@@ -460,10 +469,36 @@ TEST(stat_cmd, kprobe_option) {
   ASSERT_TRUE(StatCmd()->Run({"--group", "kprobes:do_sys_openat2", "-a", "--duration", SLEEP_SEC}));
 }
 
+// @CddTest = 6.1/C-0-2
+TEST(stat_cmd, uprobe_option) {
+  TEST_REQUIRE_ROOT();
+  EventSelectionSet event_selection_set(false);
+  ProbeEvents probe_events(event_selection_set);
+  if (!probe_events.IsProbeSupported(ProbeEventType::kUprobe)) {
+    GTEST_LOG_(INFO) << "Skip this test as uprobe isn't supported by the kernel.";
+    return;
+  }
+  if (!IsRegularFile("/system/lib64/libc.so")) {
+    GTEST_LOG_(INFO) << "Skip this test as /system/lib64/libc.so doesn't exist";
+    return;
+  }
+  ASSERT_TRUE(
+      StatCmd()->Run({"-e", "uprobes:myprobe", "--uprobe",
+                      "p:myprobe /system/lib64/libc.so:0x88e80", "-a", "--duration", SLEEP_SEC}));
+  ASSERT_TRUE(StatCmd()->Run({"-e", "uprobes:p_libc_0x88e80", "--uprobe",
+                              "p /system/lib64/libc.so:0x88e80", "-a", "--duration", SLEEP_SEC}));
+  ASSERT_TRUE(
+      StatCmd()->Run({"-e", "uprobes:myprobe", "--uprobe",
+                      "r:myprobe /system/lib64/libc.so:0x88e80", "-a", "--duration", SLEEP_SEC}));
+  ASSERT_TRUE(StatCmd()->Run({"-e", "uprobes:p_libc_0x88e80", "--uprobe",
+                              "r /system/lib64/libc.so:0x88e80", "-a", "--duration", SLEEP_SEC}));
+}
+
 // @CddTest = 6.1/C-0-2
 TEST(stat_cmd, tp_filter_option) {
   TEST_REQUIRE_HOST_ROOT();
   TEST_REQUIRE_TRACEPOINT_EVENTS();
+  TEST_REQUIRE_KERNEL_EVENTS();
   ASSERT_TRUE(StatCmd()->Run(
       {"-e", "sched:sched_switch", "--tp-filter", "prev_comm != sleep", "sleep", SLEEP_SEC}));
 }
diff --git a/simpleperf/demo/CppApi/app/build.gradle b/simpleperf/demo/CppApi/app/build.gradle
index dd2f172d..6fbd40d9 100644
--- a/simpleperf/demo/CppApi/app/build.gradle
+++ b/simpleperf/demo/CppApi/app/build.gradle
@@ -1,13 +1,12 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 30
     defaultConfig {
         applicationId "simpleperf.demo.cpp_api"
         // Simpleperf suggests running on Android >= N.
         // (https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md#why-we-suggest-profiling-on-android-n-devices)
         minSdkVersion 24
-        targetSdkVersion 30
+        targetSdkVersion 33
         versionCode 1
         versionName "1.0"
         externalNativeBuild {
@@ -27,6 +26,8 @@ android {
             path "src/main/cpp/CMakeLists.txt"
         }
     }
+    compileSdk 34
+    namespace 'simpleperf.demo.cpp_api'
 }
 
 dependencies {
diff --git a/simpleperf/demo/CppApi/app/src/main/cpp/CMakeLists.txt b/simpleperf/demo/CppApi/app/src/main/cpp/CMakeLists.txt
index 739b5690..104d566d 100644
--- a/simpleperf/demo/CppApi/app/src/main/cpp/CMakeLists.txt
+++ b/simpleperf/demo/CppApi/app/src/main/cpp/CMakeLists.txt
@@ -18,4 +18,6 @@ find_library(
 target_link_libraries(
         native-lib
         PRIVATE
-        ${log-lib})
\ No newline at end of file
+        ${log-lib})
+
+target_link_options(native-lib PRIVATE "-Wl,-z,max-page-size=16384")
\ No newline at end of file
diff --git a/simpleperf/demo/CppApi/build.gradle b/simpleperf/demo/CppApi/build.gradle
index 416b90cc..ddfc3490 100644
--- a/simpleperf/demo/CppApi/build.gradle
+++ b/simpleperf/demo/CppApi/build.gradle
@@ -1,20 +1,5 @@
-buildscript {
-    repositories {
-        google()
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:4.2.2'
-    }
-}
-
-allprojects {
-    repositories {
-        google()
-        jcenter()
-    }
-}
-
-task clean(type: Delete) {
-    delete rootProject.buildDir
-}
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+    id 'com.android.application' version '8.7.3' apply false
+    id 'com.android.library' version '8.7.3' apply false
+}
\ No newline at end of file
diff --git a/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.jar b/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.jar
index f6b961fd..a4b76b95 100644
Binary files a/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.jar and b/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.properties b/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.properties
index cddfac7e..e2847c82 100644
--- a/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.properties
+++ b/simpleperf/demo/CppApi/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,7 @@
-#Thu Nov 04 10:39:12 PDT 2021
 distributionBase=GRADLE_USER_HOME
-distributionUrl=https\://services.gradle.org/distributions/gradle-6.7.1-bin.zip
 distributionPath=wrapper/dists
-zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
+networkTimeout=10000
+validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/simpleperf/demo/CppApi/gradlew b/simpleperf/demo/CppApi/gradlew
index cccdd3d5..f5feea6d 100755
--- a/simpleperf/demo/CppApi/gradlew
+++ b/simpleperf/demo/CppApi/gradlew
@@ -1,78 +1,130 @@
-#!/usr/bin/env sh
+#!/bin/sh
+
+#
+# Copyright  2015-2021 the original authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
 
 ##############################################################################
-##
-##  Gradle start up script for UN*X
-##
+#
+#   Gradle start up script for POSIX generated by Gradle.
+#
+#   Important for running:
+#
+#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
+#       noncompliant, but you have some other compliant shell such as ksh or
+#       bash, then to run this script, type that shell name before the whole
+#       command line, like:
+#
+#           ksh Gradle
+#
+#       Busybox and similar reduced shells will NOT work, because this script
+#       requires all of these POSIX shell features:
+#         * functions;
+#         * expansions $var, ${var}, ${var:-default}, ${var+SET},
+#           ${var#prefix}, ${var%suffix}, and $( cmd );
+#         * compound commands having a testable exit status, especially case;
+#         * various built-in commands including command, set, and ulimit.
+#
+#   Important for patching:
+#
+#   (2) This script targets any POSIX shell, so it avoids extensions provided
+#       by Bash, Ksh, etc; in particular arrays are avoided.
+#
+#       The "traditional" practice of packing multiple parameters into a
+#       space-separated string is a well documented source of bugs and security
+#       problems, so this is (mostly) avoided, by progressively accumulating
+#       options in "$@", and eventually passing that to Java.
+#
+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
+#       see the in-line comments for details.
+#
+#       There are tweaks for specific operating systems such as AIX, CygWin,
+#       Darwin, MinGW, and NonStop.
+#
+#   (3) This script is generated from the Groovy template
+#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       within the Gradle project.
+#
+#       You can find Gradle at https://github.com/gradle/gradle/.
+#
 ##############################################################################
 
 # Attempt to set APP_HOME
+
 # Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
+app_path=$0
+
+# Need this for daisy-chained symlinks.
+while
+    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
+    [ -h "$app_path" ]
+do
+    ls=$( ls -ld "$app_path" )
+    link=${ls#*' -> '}
+    case $link in             #(
+      /*)   app_path=$link ;; #(
+      *)    app_path=$APP_HOME$link ;;
+    esac
 done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# This is normally unused
+# shellcheck disable=SC2034
+APP_BASE_NAME=${0##*/}
+# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
+APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
+' "$PWD" ) || exit
 
 # Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
+MAX_FD=maximum
 
 warn () {
     echo "$*"
-}
+} >&2
 
 die () {
     echo
     echo "$*"
     echo
     exit 1
-}
+} >&2
 
 # OS specific support (must be 'true' or 'false').
 cygwin=false
 msys=false
 darwin=false
 nonstop=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-  NONSTOP* )
-    nonstop=true
-    ;;
+case "$( uname )" in                #(
+  CYGWIN* )         cygwin=true  ;; #(
+  Darwin* )         darwin=true  ;; #(
+  MSYS* | MINGW* )  msys=true    ;; #(
+  NONSTOP* )        nonstop=true ;;
 esac
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
+
 # Determine the Java command to use to start the JVM.
 if [ -n "$JAVA_HOME" ] ; then
     if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
         # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
+        JAVACMD=$JAVA_HOME/jre/sh/java
     else
-        JAVACMD="$JAVA_HOME/bin/java"
+        JAVACMD=$JAVA_HOME/bin/java
     fi
     if [ ! -x "$JAVACMD" ] ; then
         die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
@@ -81,92 +133,120 @@ Please set the JAVA_HOME variable in your environment to match the
 location of your Java installation."
     fi
 else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+    JAVACMD=java
+    if ! command -v java >/dev/null 2>&1
+    then
+        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
 
 Please set the JAVA_HOME variable in your environment to match the
 location of your Java installation."
+    fi
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
+if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
+    case $MAX_FD in #(
+      max*)
+        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        MAX_FD=$( ulimit -H -n ) ||
+            warn "Could not query maximum file descriptor limit"
+    esac
+    case $MAX_FD in  #(
+      '' | soft) :;; #(
+      *)
+        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        ulimit -n "$MAX_FD" ||
+            warn "Could not set maximum file descriptor limit to $MAX_FD"
+    esac
 fi
 
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
+# Collect all arguments for the java command, stacking in reverse order:
+#   * args from the command line
+#   * the main class name
+#   * -classpath
+#   * -D...appname settings
+#   * --module-path (only if needed)
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if "$cygwin" || "$msys" ; then
+    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
+    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
+
+    JAVACMD=$( cygpath --unix "$JAVACMD" )
 
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-    JAVACMD=`cygpath --unix "$JAVACMD"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
     # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
+    for arg do
+        if
+            case $arg in                                #(
+              -*)   false ;;                            # don't mess with options #(
+              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
+                    [ -e "$t" ] ;;                      #(
+              *)    false ;;
+            esac
+        then
+            arg=$( cygpath --path --ignore --mixed "$arg" )
         fi
-        i=$((i+1))
+        # Roll the args list around exactly as many times as the number of
+        # args, so each arg winds up back in the position where it started, but
+        # possibly modified.
+        #
+        # NB: a `for` loop captures its iteration list before it begins, so
+        # changing the positional parameters here affects neither the number of
+        # iterations, nor the values presented in `arg`.
+        shift                   # remove old arg
+        set -- "$@" "$arg"      # push replacement arg
     done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
 fi
 
-# Escape application args
-save () {
-    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
-    echo " "
-}
-APP_ARGS=$(save "$@")
-
-# Collect all arguments for the java command, following the shell quoting and substitution rules
-eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
 
-# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
-if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
-  cd "$(dirname "$0")"
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Collect all arguments for the java command:
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
+#     and any embedded shellness will be escaped.
+#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
+#     treated as '${Hostname}' itself on the command line.
+
+set -- \
+        "-Dorg.gradle.appname=$APP_BASE_NAME" \
+        -classpath "$CLASSPATH" \
+        org.gradle.wrapper.GradleWrapperMain \
+        "$@"
+
+# Stop when "xargs" is not available.
+if ! command -v xargs >/dev/null 2>&1
+then
+    die "xargs is not available"
 fi
 
+# Use "xargs" to parse quoted args.
+#
+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
+#
+# In Bash we could simply go:
+#
+#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
+#   set -- "${ARGS[@]}" "$@"
+#
+# but POSIX shell has neither arrays nor command substitution, so instead we
+# post-process each arg (as a line of input to sed) to backslash-escape any
+# character that might be a shell metacharacter, then use eval to reverse
+# that process (while maintaining the separation between arguments), and wrap
+# the whole thing up as a single "set" statement.
+#
+# This will of course break if any of these variables contains a newline or
+# an unmatched quote.
+#
+
+eval "set -- $(
+        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
+        xargs -n1 |
+        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
+        tr '\n' ' '
+    )" '"$@"'
+
 exec "$JAVACMD" "$@"
diff --git a/simpleperf/demo/CppApi/gradlew.bat b/simpleperf/demo/CppApi/gradlew.bat
index e95643d6..9b42019c 100644
--- a/simpleperf/demo/CppApi/gradlew.bat
+++ b/simpleperf/demo/CppApi/gradlew.bat
@@ -1,4 +1,22 @@
-@if "%DEBUG%" == "" @echo off
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+@rem SPDX-License-Identifier: Apache-2.0
+@rem
+
+@if "%DEBUG%"=="" @echo off
 @rem ##########################################################################
 @rem
 @rem  Gradle startup script for Windows
@@ -9,25 +27,29 @@
 if "%OS%"=="Windows_NT" setlocal
 
 set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
+if "%DIRNAME%"=="" set DIRNAME=.
+@rem This is normally unused
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
 @rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
 
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
 set JAVA_EXE=java.exe
 %JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
+if %ERRORLEVEL% equ 0 goto execute
 
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
+echo. 1>&2
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
 
 goto fail
 
@@ -35,48 +57,36 @@ goto fail
 set JAVA_HOME=%JAVA_HOME:"=%
 set JAVA_EXE=%JAVA_HOME%/bin/java.exe
 
-if exist "%JAVA_EXE%" goto init
+if exist "%JAVA_EXE%" goto execute
 
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
+echo. 1>&2
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
 
 goto fail
 
-:init
-@rem Get command-line arguments, handling Windows variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-
 :execute
 @rem Setup the command line
 
 set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
 
+
 @rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
 
 :end
 @rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
+if %ERRORLEVEL% equ 0 goto mainEnd
 
 :fail
 rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
 rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
+set EXIT_CODE=%ERRORLEVEL%
+if %EXIT_CODE% equ 0 set EXIT_CODE=1
+if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
+exit /b %EXIT_CODE%
 
 :mainEnd
 if "%OS%"=="Windows_NT" endlocal
diff --git a/simpleperf/demo/CppApi/settings.gradle b/simpleperf/demo/CppApi/settings.gradle
index e7b4def4..7072b1c5 100644
--- a/simpleperf/demo/CppApi/settings.gradle
+++ b/simpleperf/demo/CppApi/settings.gradle
@@ -1 +1,16 @@
+pluginManagement {
+    repositories {
+        gradlePluginPortal()
+        google()
+        mavenCentral()
+    }
+}
+dependencyResolutionManagement {
+    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositories {
+        google()
+        mavenCentral()
+    }
+}
+rootProject.name = "SimpleperfCppApi"
 include ':app'
diff --git a/simpleperf/demo/JavaApi/app/build.gradle b/simpleperf/demo/JavaApi/app/build.gradle
index 11be7545..45b98a41 100644
--- a/simpleperf/demo/JavaApi/app/build.gradle
+++ b/simpleperf/demo/JavaApi/app/build.gradle
@@ -1,13 +1,12 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 30
     defaultConfig {
         applicationId "simpleperf.demo.java_api"
         // Simpleperf profiles interpreted/jitted Java code on Android >= P.
         // https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md#prepare-an-android-application
         minSdkVersion 28
-        targetSdkVersion 30
+        targetSdkVersion 33
         versionCode 1
         versionName "1.0"
     }
@@ -21,6 +20,9 @@ android {
     sourceSets {
         main.java.srcDirs += '../../../app_api/java'
     }
+
+    compileSdk 34
+    namespace 'simpleperf.demo.java_api'
 }
 
 dependencies {
diff --git a/simpleperf/demo/JavaApi/build.gradle b/simpleperf/demo/JavaApi/build.gradle
index 416b90cc..ddfc3490 100644
--- a/simpleperf/demo/JavaApi/build.gradle
+++ b/simpleperf/demo/JavaApi/build.gradle
@@ -1,20 +1,5 @@
-buildscript {
-    repositories {
-        google()
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:4.2.2'
-    }
-}
-
-allprojects {
-    repositories {
-        google()
-        jcenter()
-    }
-}
-
-task clean(type: Delete) {
-    delete rootProject.buildDir
-}
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+    id 'com.android.application' version '8.7.3' apply false
+    id 'com.android.library' version '8.7.3' apply false
+}
\ No newline at end of file
diff --git a/simpleperf/demo/JavaApi/gradle-wrapper.properties b/simpleperf/demo/JavaApi/gradle-wrapper.properties
new file mode 100644
index 00000000..e2847c82
--- /dev/null
+++ b/simpleperf/demo/JavaApi/gradle-wrapper.properties
@@ -0,0 +1,7 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
+networkTimeout=10000
+validateDistributionUrl=true
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.jar b/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.jar
index f6b961fd..a4b76b95 100644
Binary files a/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.jar and b/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.properties b/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.properties
index a86e0569..9355b415 100644
--- a/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.properties
+++ b/simpleperf/demo/JavaApi/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,7 @@
-#Fri Nov 05 14:04:48 PDT 2021
 distributionBase=GRADLE_USER_HOME
-distributionUrl=https\://services.gradle.org/distributions/gradle-6.7.1-bin.zip
 distributionPath=wrapper/dists
-zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
+networkTimeout=10000
+validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/simpleperf/demo/JavaApi/gradlew b/simpleperf/demo/JavaApi/gradlew
index cccdd3d5..f5feea6d 100755
--- a/simpleperf/demo/JavaApi/gradlew
+++ b/simpleperf/demo/JavaApi/gradlew
@@ -1,78 +1,130 @@
-#!/usr/bin/env sh
+#!/bin/sh
+
+#
+# Copyright  2015-2021 the original authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
 
 ##############################################################################
-##
-##  Gradle start up script for UN*X
-##
+#
+#   Gradle start up script for POSIX generated by Gradle.
+#
+#   Important for running:
+#
+#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
+#       noncompliant, but you have some other compliant shell such as ksh or
+#       bash, then to run this script, type that shell name before the whole
+#       command line, like:
+#
+#           ksh Gradle
+#
+#       Busybox and similar reduced shells will NOT work, because this script
+#       requires all of these POSIX shell features:
+#         * functions;
+#         * expansions $var, ${var}, ${var:-default}, ${var+SET},
+#           ${var#prefix}, ${var%suffix}, and $( cmd );
+#         * compound commands having a testable exit status, especially case;
+#         * various built-in commands including command, set, and ulimit.
+#
+#   Important for patching:
+#
+#   (2) This script targets any POSIX shell, so it avoids extensions provided
+#       by Bash, Ksh, etc; in particular arrays are avoided.
+#
+#       The "traditional" practice of packing multiple parameters into a
+#       space-separated string is a well documented source of bugs and security
+#       problems, so this is (mostly) avoided, by progressively accumulating
+#       options in "$@", and eventually passing that to Java.
+#
+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
+#       see the in-line comments for details.
+#
+#       There are tweaks for specific operating systems such as AIX, CygWin,
+#       Darwin, MinGW, and NonStop.
+#
+#   (3) This script is generated from the Groovy template
+#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       within the Gradle project.
+#
+#       You can find Gradle at https://github.com/gradle/gradle/.
+#
 ##############################################################################
 
 # Attempt to set APP_HOME
+
 # Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
+app_path=$0
+
+# Need this for daisy-chained symlinks.
+while
+    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
+    [ -h "$app_path" ]
+do
+    ls=$( ls -ld "$app_path" )
+    link=${ls#*' -> '}
+    case $link in             #(
+      /*)   app_path=$link ;; #(
+      *)    app_path=$APP_HOME$link ;;
+    esac
 done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# This is normally unused
+# shellcheck disable=SC2034
+APP_BASE_NAME=${0##*/}
+# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
+APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
+' "$PWD" ) || exit
 
 # Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
+MAX_FD=maximum
 
 warn () {
     echo "$*"
-}
+} >&2
 
 die () {
     echo
     echo "$*"
     echo
     exit 1
-}
+} >&2
 
 # OS specific support (must be 'true' or 'false').
 cygwin=false
 msys=false
 darwin=false
 nonstop=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-  NONSTOP* )
-    nonstop=true
-    ;;
+case "$( uname )" in                #(
+  CYGWIN* )         cygwin=true  ;; #(
+  Darwin* )         darwin=true  ;; #(
+  MSYS* | MINGW* )  msys=true    ;; #(
+  NONSTOP* )        nonstop=true ;;
 esac
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
+
 # Determine the Java command to use to start the JVM.
 if [ -n "$JAVA_HOME" ] ; then
     if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
         # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
+        JAVACMD=$JAVA_HOME/jre/sh/java
     else
-        JAVACMD="$JAVA_HOME/bin/java"
+        JAVACMD=$JAVA_HOME/bin/java
     fi
     if [ ! -x "$JAVACMD" ] ; then
         die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
@@ -81,92 +133,120 @@ Please set the JAVA_HOME variable in your environment to match the
 location of your Java installation."
     fi
 else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+    JAVACMD=java
+    if ! command -v java >/dev/null 2>&1
+    then
+        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
 
 Please set the JAVA_HOME variable in your environment to match the
 location of your Java installation."
+    fi
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
+if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
+    case $MAX_FD in #(
+      max*)
+        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        MAX_FD=$( ulimit -H -n ) ||
+            warn "Could not query maximum file descriptor limit"
+    esac
+    case $MAX_FD in  #(
+      '' | soft) :;; #(
+      *)
+        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        ulimit -n "$MAX_FD" ||
+            warn "Could not set maximum file descriptor limit to $MAX_FD"
+    esac
 fi
 
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
+# Collect all arguments for the java command, stacking in reverse order:
+#   * args from the command line
+#   * the main class name
+#   * -classpath
+#   * -D...appname settings
+#   * --module-path (only if needed)
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if "$cygwin" || "$msys" ; then
+    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
+    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
+
+    JAVACMD=$( cygpath --unix "$JAVACMD" )
 
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-    JAVACMD=`cygpath --unix "$JAVACMD"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
     # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
+    for arg do
+        if
+            case $arg in                                #(
+              -*)   false ;;                            # don't mess with options #(
+              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
+                    [ -e "$t" ] ;;                      #(
+              *)    false ;;
+            esac
+        then
+            arg=$( cygpath --path --ignore --mixed "$arg" )
         fi
-        i=$((i+1))
+        # Roll the args list around exactly as many times as the number of
+        # args, so each arg winds up back in the position where it started, but
+        # possibly modified.
+        #
+        # NB: a `for` loop captures its iteration list before it begins, so
+        # changing the positional parameters here affects neither the number of
+        # iterations, nor the values presented in `arg`.
+        shift                   # remove old arg
+        set -- "$@" "$arg"      # push replacement arg
     done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
 fi
 
-# Escape application args
-save () {
-    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
-    echo " "
-}
-APP_ARGS=$(save "$@")
-
-# Collect all arguments for the java command, following the shell quoting and substitution rules
-eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
 
-# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
-if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
-  cd "$(dirname "$0")"
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Collect all arguments for the java command:
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
+#     and any embedded shellness will be escaped.
+#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
+#     treated as '${Hostname}' itself on the command line.
+
+set -- \
+        "-Dorg.gradle.appname=$APP_BASE_NAME" \
+        -classpath "$CLASSPATH" \
+        org.gradle.wrapper.GradleWrapperMain \
+        "$@"
+
+# Stop when "xargs" is not available.
+if ! command -v xargs >/dev/null 2>&1
+then
+    die "xargs is not available"
 fi
 
+# Use "xargs" to parse quoted args.
+#
+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
+#
+# In Bash we could simply go:
+#
+#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
+#   set -- "${ARGS[@]}" "$@"
+#
+# but POSIX shell has neither arrays nor command substitution, so instead we
+# post-process each arg (as a line of input to sed) to backslash-escape any
+# character that might be a shell metacharacter, then use eval to reverse
+# that process (while maintaining the separation between arguments), and wrap
+# the whole thing up as a single "set" statement.
+#
+# This will of course break if any of these variables contains a newline or
+# an unmatched quote.
+#
+
+eval "set -- $(
+        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
+        xargs -n1 |
+        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
+        tr '\n' ' '
+    )" '"$@"'
+
 exec "$JAVACMD" "$@"
diff --git a/simpleperf/demo/JavaApi/gradlew.bat b/simpleperf/demo/JavaApi/gradlew.bat
index e95643d6..9b42019c 100644
--- a/simpleperf/demo/JavaApi/gradlew.bat
+++ b/simpleperf/demo/JavaApi/gradlew.bat
@@ -1,4 +1,22 @@
-@if "%DEBUG%" == "" @echo off
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+@rem SPDX-License-Identifier: Apache-2.0
+@rem
+
+@if "%DEBUG%"=="" @echo off
 @rem ##########################################################################
 @rem
 @rem  Gradle startup script for Windows
@@ -9,25 +27,29 @@
 if "%OS%"=="Windows_NT" setlocal
 
 set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
+if "%DIRNAME%"=="" set DIRNAME=.
+@rem This is normally unused
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
 @rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
 
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
 set JAVA_EXE=java.exe
 %JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
+if %ERRORLEVEL% equ 0 goto execute
 
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
+echo. 1>&2
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
 
 goto fail
 
@@ -35,48 +57,36 @@ goto fail
 set JAVA_HOME=%JAVA_HOME:"=%
 set JAVA_EXE=%JAVA_HOME%/bin/java.exe
 
-if exist "%JAVA_EXE%" goto init
+if exist "%JAVA_EXE%" goto execute
 
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
+echo. 1>&2
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
 
 goto fail
 
-:init
-@rem Get command-line arguments, handling Windows variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-
 :execute
 @rem Setup the command line
 
 set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
 
+
 @rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
 
 :end
 @rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
+if %ERRORLEVEL% equ 0 goto mainEnd
 
 :fail
 rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
 rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
+set EXIT_CODE=%ERRORLEVEL%
+if %EXIT_CODE% equ 0 set EXIT_CODE=1
+if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
+exit /b %EXIT_CODE%
 
 :mainEnd
 if "%OS%"=="Windows_NT" endlocal
diff --git a/simpleperf/demo/JavaApi/settings.gradle b/simpleperf/demo/JavaApi/settings.gradle
index e7b4def4..bc964d31 100644
--- a/simpleperf/demo/JavaApi/settings.gradle
+++ b/simpleperf/demo/JavaApi/settings.gradle
@@ -1 +1,16 @@
+pluginManagement {
+    repositories {
+        gradlePluginPortal()
+        google()
+        mavenCentral()
+    }
+}
+dependencyResolutionManagement {
+    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositories {
+        google()
+        mavenCentral()
+    }
+}
+rootProject.name = "SimpleperfJavaApi"
 include ':app'
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/AndroidProjectSystem.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/AndroidProjectSystem.xml
new file mode 100644
index 00000000..4a53bee8
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/AndroidProjectSystem.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AndroidProjectSystem">
+    <option name="providerId" value="com.android.tools.idea.GradleProjectSystem" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/compiler.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/compiler.xml
new file mode 100644
index 00000000..b86273d9
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/compiler.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <bytecodeTargetLevel target="21" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/deploymentTargetSelector.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/deploymentTargetSelector.xml
new file mode 100644
index 00000000..b268ef36
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/deploymentTargetSelector.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="deploymentTargetSelector">
+    <selectionStates>
+      <SelectionState runConfigName="app">
+        <option name="selectionMode" value="DROPDOWN" />
+      </SelectionState>
+    </selectionStates>
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/gradle.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/gradle.xml
new file mode 100644
index 00000000..639c779c
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/gradle.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="GradleMigrationSettings" migrationVersion="1" />
+  <component name="GradleSettings">
+    <option name="linkedExternalProjectsSettings">
+      <GradleProjectSettings>
+        <option name="testRunner" value="CHOOSE_PER_TEST" />
+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
+        <option name="gradleJvm" value="#GRADLE_LOCAL_JAVA_HOME" />
+        <option name="modules">
+          <set>
+            <option value="$PROJECT_DIR$" />
+            <option value="$PROJECT_DIR$/app" />
+          </set>
+        </option>
+      </GradleProjectSettings>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/migrations.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/migrations.xml
new file mode 100644
index 00000000..f8051a6f
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/migrations.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectMigrations">
+    <option name="MigrateToGradleLocalJavaHome">
+      <set>
+        <option value="$PROJECT_DIR$" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/misc.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/misc.xml
new file mode 100644
index 00000000..74dd639e
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/misc.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="jbr-21" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/build/classes" />
+  </component>
+  <component name="ProjectType">
+    <option name="id" value="Android" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/runConfigurations.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/runConfigurations.xml
new file mode 100644
index 00000000..16660f1d
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/runConfigurations.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RunConfigurationProducerService">
+    <option name="ignoredProducers">
+      <set>
+        <option value="com.intellij.execution.junit.AbstractAllInDirectoryConfigurationProducer" />
+        <option value="com.intellij.execution.junit.AllInPackageConfigurationProducer" />
+        <option value="com.intellij.execution.junit.PatternConfigurationProducer" />
+        <option value="com.intellij.execution.junit.TestInClassConfigurationProducer" />
+        <option value="com.intellij.execution.junit.UniqueIdConfigurationProducer" />
+        <option value="com.intellij.execution.junit.testDiscovery.JUnitTestDiscoveryConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinJUnitRunConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinPatternConfigurationProducer" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/.idea/vcs.xml b/simpleperf/demo/SimpleperfExampleCpp/.idea/vcs.xml
new file mode 100644
index 00000000..c2365ab1
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$/../../.." vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build.gradle b/simpleperf/demo/SimpleperfExampleCpp/app/build.gradle
index 8cbdf272..76ad69da 100644
--- a/simpleperf/demo/SimpleperfExampleCpp/app/build.gradle
+++ b/simpleperf/demo/SimpleperfExampleCpp/app/build.gradle
@@ -3,12 +3,11 @@ plugins {
 }
 
 android {
-    compileSdkVersion 32
 
     defaultConfig {
         applicationId "simpleperf.example.cpp"
         minSdkVersion 24
-        targetSdkVersion 32
+        targetSdkVersion 33
         versionCode 1
         versionName "1.0"
 
@@ -41,6 +40,9 @@ android {
     buildFeatures {
         viewBinding true
     }
+    compileSdk 34
+    ndkVersion '27.1.12297006'
+    namespace 'simpleperf.example.cpp'
 }
 
 dependencies {
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/arm64-v8a/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/arm64-v8a/libnative-lib.so
deleted file mode 100755
index 6c366c0d..00000000
Binary files a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/arm64-v8a/libnative-lib.so and /dev/null differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/armeabi-v7a/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/armeabi-v7a/libnative-lib.so
deleted file mode 100755
index d8ec66de..00000000
Binary files a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/armeabi-v7a/libnative-lib.so and /dev/null differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/x86/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/x86/libnative-lib.so
deleted file mode 100755
index a1505db0..00000000
Binary files a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/x86/libnative-lib.so and /dev/null differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/x86_64/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/x86_64/libnative-lib.so
deleted file mode 100755
index 93a68ca1..00000000
Binary files a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/cmake/debug/obj/x86_64/libnative-lib.so and /dev/null differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/arm64-v8a/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/arm64-v8a/libnative-lib.so
new file mode 100644
index 00000000..9e010955
Binary files /dev/null and b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/arm64-v8a/libnative-lib.so differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/armeabi-v7a/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/armeabi-v7a/libnative-lib.so
new file mode 100644
index 00000000..4d0cf7e7
Binary files /dev/null and b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/armeabi-v7a/libnative-lib.so differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/x86/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/x86/libnative-lib.so
new file mode 100644
index 00000000..28e6dd7e
Binary files /dev/null and b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/x86/libnative-lib.so differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/x86_64/libnative-lib.so b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/x86_64/libnative-lib.so
new file mode 100644
index 00000000..c9e43396
Binary files /dev/null and b/simpleperf/demo/SimpleperfExampleCpp/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/x86_64/libnative-lib.so differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/build/outputs/apk/debug/app-debug.apk b/simpleperf/demo/SimpleperfExampleCpp/app/build/outputs/apk/debug/app-debug.apk
index b1aa5c4e..473b3917 100644
Binary files a/simpleperf/demo/SimpleperfExampleCpp/app/build/outputs/apk/debug/app-debug.apk and b/simpleperf/demo/SimpleperfExampleCpp/app/build/outputs/apk/debug/app-debug.apk differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/release/app-release.apk b/simpleperf/demo/SimpleperfExampleCpp/app/release/app-release.apk
index 01e0e5a7..229df43b 100644
Binary files a/simpleperf/demo/SimpleperfExampleCpp/app/release/app-release.apk and b/simpleperf/demo/SimpleperfExampleCpp/app/release/app-release.apk differ
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/release/output-metadata.json b/simpleperf/demo/SimpleperfExampleCpp/app/release/output-metadata.json
new file mode 100644
index 00000000..121d77bf
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleCpp/app/release/output-metadata.json
@@ -0,0 +1,21 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "APK",
+    "kind": "Directory"
+  },
+  "applicationId": "simpleperf.example.cpp",
+  "variantName": "release",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "versionCode": 1,
+      "versionName": "1.0",
+      "outputFile": "app-release.apk"
+    }
+  ],
+  "elementType": "File",
+  "minSdkVersionForDexing": 24
+}
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/src/main/AndroidManifest.xml b/simpleperf/demo/SimpleperfExampleCpp/app/src/main/AndroidManifest.xml
index 7bb592da..00456072 100644
--- a/simpleperf/demo/SimpleperfExampleCpp/app/src/main/AndroidManifest.xml
+++ b/simpleperf/demo/SimpleperfExampleCpp/app/src/main/AndroidManifest.xml
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="simpleperf.example.cpp">
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
 
     <application
         android:allowBackup="true"
diff --git a/simpleperf/demo/SimpleperfExampleCpp/app/src/main/cpp/CMakeLists.txt b/simpleperf/demo/SimpleperfExampleCpp/app/src/main/cpp/CMakeLists.txt
index 9c11f078..0c4d3770 100644
--- a/simpleperf/demo/SimpleperfExampleCpp/app/src/main/cpp/CMakeLists.txt
+++ b/simpleperf/demo/SimpleperfExampleCpp/app/src/main/cpp/CMakeLists.txt
@@ -45,4 +45,6 @@ target_link_libraries( # Specifies the target library.
 
                        # Links the target library to the log library
                        # included in the NDK.
-                       ${log-lib} )
\ No newline at end of file
+                       ${log-lib} )
+
+target_link_options(native-lib PRIVATE "-Wl,-z,max-page-size=16384")
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/build.gradle b/simpleperf/demo/SimpleperfExampleCpp/build.gradle
index 71b99f4c..ddfc3490 100644
--- a/simpleperf/demo/SimpleperfExampleCpp/build.gradle
+++ b/simpleperf/demo/SimpleperfExampleCpp/build.gradle
@@ -1,5 +1,5 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 plugins {
-    id 'com.android.application' version '7.3.1' apply false
-    id 'com.android.library' version '7.3.1' apply false
+    id 'com.android.application' version '8.7.3' apply false
+    id 'com.android.library' version '8.7.3' apply false
 }
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/gradle.properties b/simpleperf/demo/SimpleperfExampleCpp/gradle.properties
index 6826e61b..a1af1661 100644
--- a/simpleperf/demo/SimpleperfExampleCpp/gradle.properties
+++ b/simpleperf/demo/SimpleperfExampleCpp/gradle.properties
@@ -14,4 +14,7 @@ org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
 # AndroidX package structure to make it clearer which packages are bundled with the
 # Android operating system, and which are packaged with your app"s APK
 # https://developer.android.com/topic/libraries/support-library/androidx-rn
-android.useAndroidX=true
\ No newline at end of file
+android.useAndroidX=true
+android.defaults.buildfeatures.buildconfig=true
+android.nonTransitiveRClass=false
+android.nonFinalResIds=false
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleCpp/gradle/wrapper/gradle-wrapper.properties b/simpleperf/demo/SimpleperfExampleCpp/gradle/wrapper/gradle-wrapper.properties
index 6903aadd..f69dfc7d 100644
--- a/simpleperf/demo/SimpleperfExampleCpp/gradle/wrapper/gradle-wrapper.properties
+++ b/simpleperf/demo/SimpleperfExampleCpp/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 #Fri Oct 15 16:48:24 PDT 2021
 distributionBase=GRADLE_USER_HOME
-distributionUrl=https\://services.gradle.org/distributions/gradle-7.4-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
 distributionPath=wrapper/dists
 zipStorePath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/simpleperf/demo/SimpleperfExampleJava/.idea/gradle.xml b/simpleperf/demo/SimpleperfExampleJava/.idea/gradle.xml
index a9f4e522..b8e0269b 100644
--- a/simpleperf/demo/SimpleperfExampleJava/.idea/gradle.xml
+++ b/simpleperf/demo/SimpleperfExampleJava/.idea/gradle.xml
@@ -1,10 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="GradleMigrationSettings" migrationVersion="1" />
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
-        <option name="testRunner" value="GRADLE" />
-        <option name="distributionType" value="DEFAULT_WRAPPED" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
         <option name="modules">
           <set>
@@ -12,6 +11,7 @@
             <option value="$PROJECT_DIR$/app" />
           </set>
         </option>
+        <option name="resolveExternalAnnotations" value="false" />
       </GradleProjectSettings>
     </option>
   </component>
diff --git a/simpleperf/demo/SimpleperfExampleJava/.idea/migrations.xml b/simpleperf/demo/SimpleperfExampleJava/.idea/migrations.xml
new file mode 100644
index 00000000..f8051a6f
--- /dev/null
+++ b/simpleperf/demo/SimpleperfExampleJava/.idea/migrations.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectMigrations">
+    <option name="MigrateToGradleLocalJavaHome">
+      <set>
+        <option value="$PROJECT_DIR$" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
diff --git a/simpleperf/demo/SimpleperfExampleJava/.idea/misc.xml b/simpleperf/demo/SimpleperfExampleJava/.idea/misc.xml
index bdd92780..c6ac1301 100644
--- a/simpleperf/demo/SimpleperfExampleJava/.idea/misc.xml
+++ b/simpleperf/demo/SimpleperfExampleJava/.idea/misc.xml
@@ -1,4 +1,3 @@
-<?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ExternalStorageConfigurationManager" enabled="true" />
   <component name="ProjectRootManager" version="2" languageLevel="JDK_11" default="true" project-jdk-name="Android Studio default JDK" project-jdk-type="JavaSDK">
diff --git a/simpleperf/doc/AFDOFlow.png b/simpleperf/doc/AFDOFlow.png
new file mode 100644
index 00000000..134e8fc0
Binary files /dev/null and b/simpleperf/doc/AFDOFlow.png differ
diff --git a/simpleperf/doc/collect_lbr_data_for_autofdo.md b/simpleperf/doc/collect_lbr_data_for_autofdo.md
new file mode 100644
index 00000000..1b6bc5b2
--- /dev/null
+++ b/simpleperf/doc/collect_lbr_data_for_autofdo.md
@@ -0,0 +1,391 @@
+# Collect LBR (x86 Architectures) data for AutoFDO
+
+# Table of Contents
+
+-   Introduction
+-   AFDO Compiler Optimizations
+    -   Sampling Profiler
+    -   Execution Profiles
+    -   Limitations of Code Coverage
+    -   Generating Sampling Profiles
+    -   AFDO Flow Diagram
+-   Intel's Performance Monitoring Unit (PMU)
+-   Examples
+    -   A complete example: autofdo_inline_test.cpp
+-   Related docs
+
+## Introduction
+
+The following user guide provides an overview of AFDO compiler
+optimizations, details on Intel Performance Monitoring Units (PMU), and
+instructions for collecting Last Branch Record (LBR) related profiles on
+x86 platforms.
+
+## AFDO Compiler Optimization
+
+**AutoFDO compiler** optimization refer to a set of advanced techniques
+employed by compilers to enhance the performance of software
+applications. These optimizations are based on insights gained from
+hardware performance metrics, specifically focusing on events such as
+`br_inst_retired.neartaken` and `cpu_cycles`.
+
+### Sampling Profiler
+
+A sampling profiler can generate a performance profile with very low
+runtime overhead. This profile is crucial for optimization purposes but
+is not suitable for code coverage analysis. The profiler collects data
+by periodically sampling the program's execution, which provides a
+statistical representation of where time is being spent in the code.
+
+### Execution Profiles
+
+Compilers utilize **execution profiles** that consist of basic block and
+edge frequency counts. These profiles guide various optimizations,
+including:
+
+-   **Instruction Scheduling**: Reordering instructions to minimize
+    delays and improve pipeline efficiency.
+-   **Basic Block Re-ordering**: Rearranging basic blocks to enhance
+    cache performance and reduce branch mispredictions.
+-   **Function Splitting**: Dividing functions into smaller parts to
+    improve inlining and reduce code size.
+-   **Register Allocation**: Efficiently assigning variables to CPU
+    registers to minimize memory access.
+
+These optimizations aim to improve execution speed, reduce resource
+consumption, and enhance the overall efficiency of applications on
+specific hardware configurations.
+
+### Limitations for Code Coverage
+
+While it is technically possible to use sampling profiles for code
+coverage, they are generally too coarse-grained for this purpose.
+Sampling profiles provide a statistical view rather than a precise
+execution trace, leading to poor results in code coverage analysis.
+
+### Generating Sampling Profiles
+
+Sampling profiles must be generated by an external tool like simpleperf
+in the below case. Once generated, the profile needs to be converted
+into a format that can be read by LLVM using create_llvm_prof tool
+
+### AFDO Flow Diagram
+
+![AFDOFlow Image](./AFDOFlow.png)
+
+## Intel's Performance Monitoring Unit (PMU)
+
+Intel's Performance Monitoring Unit (PMU) is a hardware feature built
+into their processors to measure various performance parameters. These
+parameters include instruction cycles, cache hits, cache misses, branch
+misses, and more. The PMU helps in understanding how effectively code
+uses hardware resources and provides insights for optimization.The Last
+Branch Record (LBR) is indeed a part of Intel's Performance Monitoring
+Unit (PMU). The PMU includes various performance monitoring features,
+and LBR is one of them.
+
+The Last Branch Record (LBR) is an advanced CPU feature designed to
+meticulously log the source and destination addresses of recently
+executed branch instructions. This capability serves as a vital tool for
+performance monitoring and debugging, allowing developers to track the
+intricate control flow of their programs. By analyzing the data captured
+through LBR, we can gain valuable insights into how applications
+navigate through their execution paths and pinpoint the areas where the
+program spends most of its time-often referred to as "hot paths."
+
+**Branch Statistics**: One of the remarkable applications of LBR is its
+ability to gather comprehensive branch statistics in C++ programs. This
+data can be pivotal in understanding the behavior of conditional
+decisions in the code.
+
+**Virtual Calls**: LBR proves particularly useful for analyzing the
+outcomes of indirect branches and virtual calls, key components in
+object-oriented programming that can significantly influence
+performance.
+
+LBR entries are rich with information, typically consisting of `FROM_IP`
+and `TO_IP`, which denote the source and destination addresses of the
+branching instructions. This detailed logging offers a clear view of the
+program's execution flow.
+
+**Model Specific Registers (MSRs)**: The configuration of LBR relies on
+Model Specific Registers (MSRs) specific to Intel CPUs. These registers
+play a crucial role in enabling and managing LBR functionalities.
+**IA32_DEBUGCTL**: To initiate LBR recording, one must set bit 0 of the
+IA32_DEBUGCTL register to 1, effectively activating this powerful
+feature. **MSR_LASTBRANCH_x\_FROM_IP**: This particular register is
+responsible for storing the originating addresses of the most recent
+branch instructions, preserving a trail of execution paths.
+**MSR_LASTBRANCH_x\_TO_IP**: Conversely, this register captures the
+destination addresses of those most recent branches, creating a
+comprehensive map of transitions within the program.
+
+**Clearing LBRs**: A noteworthy aspect of LBR is that it gets cleared
+when the CPU enters certain low-power sleep states deeper than C2. To
+maintain the integrity of the recorded data, it may be necessary to keep
+the CPU in an awake state.
+
+**Stopping LBR**: Ceasing LBR recording can present challenges and might
+require invoking performance monitoring interrupts (PMIs), introducing
+additional complexity to the management of this feature.
+
+**Advantages**: **Overhead**: One of the standout benefits of LBR is its
+minimal overhead; it provides nearly zero performance degradation
+compared to traditional software-based branch recording methods, making
+it an efficient choice in performance-sensitive applications.
+**Accuracy**: Although manual code instrumentation might yield slightly
+better precision in certain scenarios, this advantage comes at the
+significant cost of increased runtime performance overhead, making LBR a
+more appealing alternative in many cases. **Scenarios**: The utility of
+LBR shines particularly in situations where the source code is not
+readily accessible or when the software builds process remains shrouded
+in mystery. In such cases, LBR becomes an invaluable ally in uncovering
+insights into program behavior, allowing developers and analysts to make
+informed decisions based on the recorded execution paths.
+
+Simpleperf supports collecting LBR data and converting it to input files
+for AutoFDO, which can then be used for Feedback Directed Optimization
+during compilation.
+
+## Examples
+
+Below are examples collecting LBR data for AutoFDO. It has two steps:
+first recording LBR data,second converting LBR data to AutoFDO input
+files.
+
+Record LBR data:
+
+``` sh
+# preparation: we need to be root the device to record LBR data
+# for initial setup
+$ adb root
+$ adb remount
+# device will ask for reboot for changes to be applied
+# once initial setup is done,next time onwards the below steps only should be used
+$ adb root
+$ adb shell
+brya:/ \# cd data/local/tmp
+brya:/data/local/tmp \#
+
+# Do a system wide collection, it writes output to perf.data.
+# If only want LBR data for kernel, use `-e BR_INST_RETIRED.NEAR_TAKEN:k`.
+# If only want LBR data for userspace, use `-e BR_INST_RETIRED.NEAR_TAKEN:u`.
+# If want LBR data for system wide collection, use `-e BR_INST_RETIRED.NEAR_TAKEN -a`.
+
+brya:/data/local/tmp \# simpleperf record -b -p <processid> -e BR_INST_RETIRED.NEAR_TAKEN:u -c 10003
+
+# if you have a standalone binary the below command needs to be used
+
+brya:/data/local/tmp \# simpleperf record -b -e BR_INST_RETIRED.NEAR_TAKEN:u -c 10003 ./<binaryname>
+
+simpleperf record:
+The simpleperf record command is used to profile processes and store the profiling data in a file (usually perf.data).
+
+-b:
+This option enables branch recording. It uses the Last Branch Record (LBR) feature of the CPU to capture the
+most recent branches taken by the processor. This is useful for understanding the control flow of a program.
+
+-a:
+This option tells perf to record system-wide. It collects performance data from all CPUs, not just the one
+where the command is run. This is useful for capturing a comprehensive view of system performance.
+
+-e:
+This option specifies the event (BR_INST_RETIRED.NEAR_TAKEN in this case) to record.
+
+-c:
+This option is used to specify the event count threshold for sampling.
+
+
+# To reduce file size and time converting to AutoFDO input files, we recommend converting LBR data into an intermediate branch-list format.
+
+brya:/data/local/tmp \# simpleperf inject -i perf.data --output branch-list -o branch_list.data
+```
+
+Converting LBR data to AutoFDO input files needs to read binaries. So
+for userspace and kernel libraries, it needs to be converted on host,
+with vmlinux and kernel modules available.
+
+1) Convert LBR data for userspace libraries:
+
+``` sh
+# Injecting LBR data on device. It writes output to perf_inject.data.
+# perf_inject.data is a text file, containing branch counts for each library.
+# Host simpleperf is in <aosp-top>/aosp/out/host/linux-x86/bin/simpleperf,
+# or you can build simpleperf by `make simpleperf_ndk`.
+
+host $ adb pull /data/local/tmp/branch_list.data
+
+host $ simpleperf inject -i branch_list.data --binary <binaryorlibraryname> --symdir <aosp-top>/aosp/out/target/product/generic_x86_64/symbols/system/ -o perf_inject.data
+```
+
+2) Convert LBR data for Userspace & kernel:
+
+``` sh
+# pull LBR data to host.
+
+host $ adb pull /data/local/tmp/branch_list.data
+
+# download vmlinux and kernel modules to <binary_dir>
+# host simpleperf is in <aosp-top>/aosp/out/host/linux-x86/bin/simpleperf,
+# or you can build simpleperf by `make simpleperf_ndk`.
+
+host $ simpleperf inject -i branch_list.data --binary <userspacebinaryorlibrary> --symdir <symboldir> -o perf_inject.data
+```
+
+The generated perf_inject.data may contain branch info for multiple
+binaries. But AutoFDO only accepts one at a time. So we need to split
+perf_inject.data. The format of perf_inject.data is below:
+
+\`\`\`perf_inject.data format
+
+executed range with count info for binary1 branch with count info for
+binary1 // name for binary1
+
+executed range with count info for binary2 branch with count info for
+binary2 // name for binary2
+
+...
+
+    We need to split perf_inject.data, and make sure one file only contains info for one binary.
+
+    Then we can use [AutoFDO](https://github.com/google/autofdo) to create profile. Follow README.md
+    in AutoFDO to build create_llvm_prof, then use `create_llvm_prof` to create profiles for clang.
+
+    ```sh
+    # perf_inject_binary1.data is split from perf_inject.data, and only contains branch info for binary1.
+    host $ create_llvm_prof -profile perf_inject_binary1.data -profiler text -binary path_of_binary1 -out a.afdo -format extbinary
+
+    # perf_inject_kernel.data is split from perf_inject.data, and only contains branch info for [kernel.kallsyms].
+    host $ create_llvm_prof -profile perf_inject_kernel.data -profiler text -binary vmlinux -out a.afdo -format extbinary
+
+Then we can use a.prof for AFDO during compilation, via
+`-fprofile-sample-use=a.afdo`.
+[Here](https://clang.llvm.org/docs/UsersManual.html#using-sampling-profilers)
+are more details.
+
+### A complete example: autofdo_inline_test.cpp
+
+`autofdo_inline_test.cpp` is an example to show the complete
+process. The source code is in
+[autofdo_inline_test.cpp](https://android.googlesource.com/platform/system/extras/+/main/simpleperf/runtest/autofdo_inline_test.cpp).
+The build script is in
+[Android.bp](https://android.googlesource.com/platform/system/extras/+/main/simpleperf/runtest/Android.bp).
+It builds an executable called `autofdo_inline_test`, which runs on device
+(Referred here as brya).
+
+**Step 1: Build `autofdo_inline_test` binary**
+
+``` sh
+(host) <AOSP>$ source build/envsetup.sh
+(host) <AOSP>$ lunch aosp_x86_64-trunk_staging-userdebug
+(host) <AOSP>$ make autofdo_inline_test
+```
+
+**Step 2: Run `autofdo_inline_test.cpp` on brya, and collect LBR
+data for its running**
+
+``` sh
+(host) <AOSP>$ adb push out/target/product/generic_x86_64/system/bin/autofdo_inline_test /data/local/tmp
+(host) <AOSP>$ adb root
+(host) <AOSP>$ adb shell
+(brya) / $ cd /data/local/tmp
+(brya) /data/local/tmp $ chmod a+x autofdo_inline_test
+(brya) /data/local/tmp $ simpleperf record -b -p <processidofautofdobinary> -e BR_INST_RETIRED.NEAR_TAKEN:u
+simpleperf I cmd_record.cpp:840] Recorded for 4.0012 seconds. Start post processing.
+simpleperf I cmd_record.cpp:941] Samples recorded: 7. Samples lost: 0.
+(brya) /data/local/tmp $ simpleperf inject --output branch-list -o branch_list.data
+(brya) /data/local/tmp $ simpleperf inject -i branch_list.data
+(brya) /data/local/tmp $ exit
+(host) <AOSP>$ adb pull /data/local/tmp/perf_inject.data
+```
+
+**Step 3: Convert LBR data to AutoFDO profile**
+
+``` sh
+# Build simpleperf tool on host.
+(host) <AOSP>$ make simpleperf_ndk
+(host) <AOSP>$ cat perf_inject.data
+2
+4160-418d:8
+419d-41bb:9
+3
+4170:1
+419d:1
+41a7:1
+4
+4159->4187:3
+4185->41d2:1
+418d->419d:9
+41bb->4160:11
+// build_id: 0x1631385c6a846e19fd38cec137041c2200000000
+// /data/local/tmp/latest/autofdo_inline_test
+
+(host) <AOSP>$ create_llvm_prof --binary <AOSP>/out/target/product/generic_x86_64/system/bin/autofdo_inline_test  --format extbinary --out autofdo_inline_test.afdo --profile perf_inject.data --profiler text
+
+(host) <AOSP>$ ls -lh autofdo_inline_test.afdo
+-rw-rw-rw- 1 root root 1.0K 2025-03-11 10:18 autofdo_inline_test.afdo
+```
+
+**Step 4: Use AutoFDO profile to build optimized binary**
+
+``` sh
+(host) <AOSP>$ cp autofdo_inline_test.afdo toolchain/pgo-profiles/sampling/
+(host) <AOSP>$ vi toolchain/pgo-profiles/sampling/Android.bp
+# Edit Android.bp to add a fdo_profile module:
+#
+# fdo_profile {
+#    name: "autofdo_inline_test",
+#    profile: "autofdo_inline_test.afdo"
+# }
+(host) <AOSP>$ vi toolchain/pgo-profiles/sampling/afdo_profiles.mk
+# Edit afdo_profiles.mk to add autofdo_inline_test profile mapping:
+#
+# AFDO_PROFILES += keystore2://toolchain/pgo-profiles/sampling:keystore2 \
+#  ...
+#  server_configurable_flags://toolchain/pgo-profiles/sampling:server_configurable_flags \
+#  autofdo_inline_test://toolchain/pgo-profiles/sampling:autofdo_inline_test
+#
+
+(host) <AOSP>$ make autofdo_inline_test
+```
+
+We can check if `autofdo_inline_test.afdo` is used when building autofdo_inline_test binary.
+
+``` sh
+(host) <AOSP>$ gzip -d out/verbose.log.gz
+(host) <AOSP>$ cat out/verbose.log | grep autofdo_inline_test`
+   ... -fprofile-sample-use=toolchain/pgo-profiles/sampling/autofdo_inline_test.afdo ...
+```
+
+If comparing the disassembly of
+`out/target/product/generic_x86_64/system/bin/autofdo_inline_test` before and after
+optimizing with AutoFDO data, we can see different preferences in
+inlining, branching & basic block re-ordering. In addition we can also
+monitor Intel(R) PMU Branch Monitoring events using simpleperf. Refer below events
+comparison data.
+
+|Intel(R) PerfMon EventName|Without AFDO|With AFDO|% Delta|
+|-|-|-|-|
+|BR_INST_RETIRED.ALL_BRANCHES|25289601|25680449|2%|
+|BR_MISP_RETIRED.ALL_BRANCHES|2,693,141|2,376,465|-12%|
+|BR_MISP_RETIRED.COND|2,477,232|2,133,468|-14%|
+|BR_MISP_RETIRED.COND_TAKEN|2,136,117|1,897,894|-11%|
+|BR_MISP_RETIRED.INDIRECT|238,063|200,008|-16%|
+|BR_MISP_RETIRED.INDIRECT_CALL|205,970|179,661|-13%|
+|BR_MISP_RETIRED.RET|76,709|72,147|-6%|
+|BACLEARS.ANY|6,217,138|5,761,070|-7%|
+
+|Standard Events|Without AFDO|With AFDO|% Delta|
+|-|-|-|-|
+|cpu-cycles      |780,810,870|743,257,553|-5%|
+|context-switches|7,463|6,659|-11%|
+|task-clock      (ms)|187128.967|174391.7821|-7%|
+
+## Related docs
+
+-   [Last Branch Record
+    Stack](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
+-   [Performance monitoring events supported by Intel Performance
+    Monitoring Units (PMUs)](https://perfmon-events.intel.com/)
+-   [AutoFDO tool for converting profile
+    data](https://github.com/google/autofdo)
diff --git a/simpleperf/doc/jit_symbols.md b/simpleperf/doc/jit_symbols.md
index e50d34fb..afce55a6 100644
--- a/simpleperf/doc/jit_symbols.md
+++ b/simpleperf/doc/jit_symbols.md
@@ -24,7 +24,7 @@ For example, process `123` of application `foo.bar.baz` should create
 
 ### Symbol map file location for standalone program
 
-Standalone programs should create symbol map files in `/data/local/tmp`.
+Standalone programs should create symbol map files in `/data/local/tmp` or `/tmp`.
 
 For example, standalone program process `123` should create `/data/local/tmp/perf-123.map`.
 
diff --git a/simpleperf/doc/scripts_reference.md b/simpleperf/doc/scripts_reference.md
index 18611678..9f7a4f3d 100644
--- a/simpleperf/doc/scripts_reference.md
+++ b/simpleperf/doc/scripts_reference.md
@@ -98,6 +98,11 @@ record without the USB cable connected.
 `binary_cache_builder.py` can either pull binaries from an Android device, or find binaries in
 directories on the host (via `-lib`).
 
+By default, `binary_cache_builder.py` only pulls binaries that are actually mentioned in samples.
+For `perf.data` files that are not sample based, like those containing ETM traces, the `--every`
+command-line paremeter can be used to pull every binary that was recorded with a build id in the
+`perf.data`.
+
 ```sh
 # Generate binary_cache for perf.data, by pulling binaries from the device.
 $ ./binary_cache_builder.py
@@ -306,6 +311,46 @@ $ gunzip -c profile.folded.gz \
     > profile.svg
 ```
 
+### report_etm.py
+
+`report_etm.py` generates instruction trace from profiles recorded with the `cs-etm` event.
+
+Example use:
+
+```sh
+# Record userspace-only trace of /bin/true.
+$ ./app_profiler.py -r "-e cs-etm:u" -nb -cmd /bin/true
+# Download binaries to use while decoding the trace.
+$ ./binary_cache_builder.py --every
+# Generate instruction trace.
+$ ./report_etm.py
+```
+
+### report_fuchsia.py
+
+`report_fuchsia.py` generates [Fuchsia Trace](https://fuchsia.dev/fuchsia-src/reference/tracing/trace-format)
+from ETM trace with timestamps that can be viewed with [Perfetto](https://ui.perfetto.dev/) or on
+[https://magic-trace.org/](https://magic-trace.org/). The trace shows how the stack changes as time
+progresses. This is not always easy to do, and the script might fumble on traces where the stack is
+changed in unusual ways.
+
+It can be used like this:
+
+```sh
+# Record userspace-only trace of /bin/true with timestamps.
+$ ./app_profiler.py -r "-e cs-etm:u --record-timestamp" -nb -cmd /bin/true
+# Download binaries to use while decoding the trace.
+$ ./binary_cache_builder.py --every
+# Generate instruction trace.
+$ ./report_fuchsia.py
+```
+
+Make sure that `--record-timestamp` is used when recording the trace on the device. Without
+timestamps, `report_fuchsia.py` will generate an empty trace.
+
+Note that it is assumed that 1 tick in the timestamps equals 1 nanosecond. This is always true for
+cores that implement Armv8.6 or later, or Armv9.1 or later, but is not the case for other cores.
+
 ## simpleperf_report_lib.py
 
 `simpleperf_report_lib.py` is a Python library used to parse profiling data files generated by the
@@ -317,7 +362,7 @@ Then we can read all samples through GetNextSample(). For each sample, we can re
 (via GetRecordCmd), the arch of the device (via GetArch) and meta strings (via MetaInfo).
 
 Examples of using `simpleperf_report_lib.py` are in `report_sample.py`, `report_html.py`,
-`pprof_proto_generator.py` and `inferno/inferno.py`.
+`report_etm.py`, `pprof_proto_generator.py` and `inferno/inferno.py`.
 
 ## ipc.py
 `ipc.py`captures the instructions per cycle (IPC) of the system during a specified duration.
diff --git a/simpleperf/dso_test.cpp b/simpleperf/dso_test.cpp
index 710299b4..e68804fe 100644
--- a/simpleperf/dso_test.cpp
+++ b/simpleperf/dso_test.cpp
@@ -183,16 +183,16 @@ TEST(DebugElfFileFinder, build_id_mismatch) {
 TEST(dso, dex_file_dso) {
 #if defined(__linux__)
   for (DsoType dso_type : {DSO_DEX_FILE, DSO_ELF_FILE}) {
-    std::unique_ptr<Dso> dso = Dso::CreateDso(dso_type, GetTestData("base.vdex"));
+    std::unique_ptr<Dso> dso = Dso::CreateDso(dso_type, GetTestData("base.dex"));
     ASSERT_TRUE(dso);
-    dso->AddDexFileOffset(0x28);
+    dso->AddDexFileOffset(0);
     ASSERT_EQ(DSO_DEX_FILE, dso->type());
-    const Symbol* symbol = dso->FindSymbol(0x6c77e);
+    const Symbol* symbol = dso->FindSymbol(0x613ec);
     ASSERT_NE(symbol, nullptr);
-    ASSERT_EQ(symbol->addr, static_cast<uint64_t>(0x6c77e));
-    ASSERT_EQ(symbol->len, static_cast<uint64_t>(0x16));
+    ASSERT_EQ(symbol->addr, static_cast<uint64_t>(0x613ec));
+    ASSERT_EQ(symbol->len, static_cast<uint64_t>(0x128));
     ASSERT_STREQ(symbol->DemangledName(),
-                 "com.example.simpleperf.simpleperfexamplewithnative.MixActivity$1.run");
+                 "com.example.android.displayingbitmaps.ui.ImageDetailActivity.onCreate");
     uint64_t min_vaddr;
     uint64_t file_offset_of_min_vaddr;
     dso->GetMinExecutableVaddr(&min_vaddr, &file_offset_of_min_vaddr);
@@ -384,7 +384,7 @@ TEST(dso, read_symbol_warning) {
   }
   {
     // Don't warn when the file may not be an ELF file.
-    auto dso = Dso::CreateDso(DSO_ELF_FILE, GetTestData("base.vdex"));
+    auto dso = Dso::CreateDso(DSO_ELF_FILE, GetTestData("base.dex"));
     CapturedStderr capture;
     dso->LoadSymbols();
     ASSERT_EQ(capture.str().find("failed to read symbols"), std::string::npos);
diff --git a/simpleperf/environment.cpp b/simpleperf/environment.cpp
index 316aee41..d101b432 100644
--- a/simpleperf/environment.cpp
+++ b/simpleperf/environment.cpp
@@ -815,14 +815,7 @@ bool RunInAppContext(const std::string& app_package_name, const std::string& cmd
   if (app_type == "unknown" && IsAppDebuggable(user_id, app_package_name)) {
     app_type = "debuggable";
   }
-
-  if (allow_run_as && app_type == "debuggable") {
-    in_app_runner.reset(new RunAs(user_id, app_package_name));
-    if (!in_app_runner->Prepare()) {
-      in_app_runner = nullptr;
-    }
-  }
-  if (!in_app_runner && allow_simpleperf_app_runner) {
+  if (allow_simpleperf_app_runner) {
     if (app_type == "debuggable" || app_type == "profileable" || app_type == "unknown") {
       in_app_runner.reset(new SimpleperfAppRunner(user_id, app_package_name, app_type));
       if (!in_app_runner->Prepare()) {
@@ -830,6 +823,12 @@ bool RunInAppContext(const std::string& app_package_name, const std::string& cmd
       }
     }
   }
+  if (!in_app_runner && allow_run_as && app_type == "debuggable") {
+    in_app_runner.reset(new RunAs(user_id, app_package_name));
+    if (!in_app_runner->Prepare()) {
+      in_app_runner = nullptr;
+    }
+  }
   if (!in_app_runner) {
     LOG(ERROR) << "Package " << app_package_name
                << " doesn't exist or isn't debuggable/profileable.";
@@ -1101,6 +1100,7 @@ class CPUModelParser {
   }
 
   std::vector<CpuModel> ParseX86CpuModel(const std::vector<std::string>& lines) {
+    std::set<int> atom_cpus = GetX86IntelAtomCpus();
     std::vector<CpuModel> cpu_models;
     uint32_t processor = 0;
     CpuModel model;
@@ -1112,6 +1112,9 @@ class CPUModelParser {
         parsed |= 1;
       } else if (name == "vendor_id") {
         model.x86_data.vendor_id = value;
+        if (atom_cpus.count(static_cast<int>(processor)) > 0) {
+          model.x86_data.vendor_id += "-atom";
+        }
         AddCpuModel(processor, model, cpu_models);
         parsed = 0;
       }
@@ -1181,4 +1184,26 @@ std::vector<CpuModel> GetCpuModels() {
 #endif
 }
 
+std::set<int> GetX86IntelAtomCpus() {
+  std::string data;
+  if (!android::base::ReadFileToString("/sys/devices/cpu_atom/cpus", &data)) {
+    return {};
+  }
+  std::optional<std::set<int>> atom_cpus = GetCpusFromString(data);
+  return atom_cpus.has_value() ? atom_cpus.value() : std::set<int>();
+}
+
+std::optional<uint32_t> GetX86IntelAtomCpuEventType() {
+  std::string data;
+  if (!android::base::ReadFileToString("/sys/bus/event_source/devices/cpu_atom/type", &data)) {
+    return std::nullopt;
+  }
+  data = android::base::Trim(data);
+  uint32_t result;
+  if (android::base::ParseUint(data, &result)) {
+    return result;
+  }
+  return std::nullopt;
+}
+
 }  // namespace simpleperf
diff --git a/simpleperf/environment.h b/simpleperf/environment.h
index 7d0d7f03..72000563 100644
--- a/simpleperf/environment.h
+++ b/simpleperf/environment.h
@@ -173,6 +173,8 @@ struct CpuModel {
 };
 
 std::vector<CpuModel> GetCpuModels();
+std::set<int> GetX86IntelAtomCpus();
+std::optional<uint32_t> GetX86IntelAtomCpuEventType();
 
 #endif  // defined(__linux__)
 
diff --git a/simpleperf/event_selection_set.cpp b/simpleperf/event_selection_set.cpp
index 58f82506..b2426429 100644
--- a/simpleperf/event_selection_set.cpp
+++ b/simpleperf/event_selection_set.cpp
@@ -47,6 +47,7 @@ bool IsBranchSamplingSupported() {
   perf_event_attr attr = CreateDefaultPerfEventAttr(*type);
   attr.sample_type |= PERF_SAMPLE_BRANCH_STACK;
   attr.branch_sample_type = PERF_SAMPLE_BRANCH_ANY;
+  attr.exclude_kernel = true;
   return IsEventAttrSupported(attr, type->name);
 }
 
@@ -62,6 +63,7 @@ bool IsDwarfCallChainSamplingSupported() {
   perf_event_attr attr = CreateDefaultPerfEventAttr(*type);
   attr.sample_type |= PERF_SAMPLE_CALLCHAIN | PERF_SAMPLE_REGS_USER | PERF_SAMPLE_STACK_USER;
   attr.exclude_callchain_user = 1;
+  attr.exclude_kernel = true;
   attr.sample_regs_user = GetSupportedRegMask(GetTargetArch());
   attr.sample_stack_user = 8192;
   return IsEventAttrSupported(attr, type->name);
@@ -161,6 +163,7 @@ bool IsHardwareEventSupported() {
     return false;
   }
   perf_event_attr attr = CreateDefaultPerfEventAttr(*type);
+  attr.exclude_kernel = true;
   return IsEventAttrSupported(attr, type->name);
 }
 
@@ -170,6 +173,15 @@ bool IsSwitchRecordSupported() {
   return version && version.value() >= std::make_pair(4, 3);
 }
 
+bool IsKernelEventSupported() {
+  const EventType* type = FindEventTypeByName("cpu-clock");
+  if (type == nullptr) {
+    return false;
+  }
+  perf_event_attr attr = CreateDefaultPerfEventAttr(*type);
+  return IsEventAttrSupported(attr, type->name);
+}
+
 std::string AddrFilter::ToString() const {
   switch (type) {
     case FILE_RANGE:
@@ -193,7 +205,7 @@ EventSelectionSet::EventSelectionSet(bool for_stat_cmd)
 EventSelectionSet::~EventSelectionSet() {}
 
 bool EventSelectionSet::BuildAndCheckEventSelection(const std::string& event_name, bool first_event,
-                                                    EventSelection* selection) {
+                                                    EventSelection* selection, bool check) {
   std::unique_ptr<EventTypeAndModifier> event_type = ParseEventType(event_name);
   if (event_type == nullptr) {
     return false;
@@ -256,11 +268,13 @@ bool EventSelectionSet::BuildAndCheckEventSelection(const std::string& event_nam
       }
     }
   }
-  // PMU events are provided by kernel, so they should be supported
-  if (!event_type->event_type.IsPmuEvent() &&
-      !IsEventAttrSupported(selection->event_attr, selection->event_type_modifier.name)) {
-    LOG(ERROR) << "Event type '" << event_type->name << "' is not supported on the device";
-    return false;
+  if (check) {
+    // PMU events are provided by kernel, so they should be supported
+    if (!event_type->event_type.IsPmuEvent() &&
+        !IsEventAttrSupported(selection->event_attr, selection->event_type_modifier.name)) {
+      LOG(ERROR) << "Event type '" << event_type->name << "' is not supported on the device";
+      return false;
+    }
   }
   if (set_default_sample_freq) {
     selection->event_attr.sample_freq = DEFAULT_SAMPLE_FREQ_FOR_NONTRACEPOINT_EVENT;
@@ -279,8 +293,8 @@ bool EventSelectionSet::BuildAndCheckEventSelection(const std::string& event_nam
   return true;
 }
 
-bool EventSelectionSet::AddEventType(const std::string& event_name) {
-  return AddEventGroup(std::vector<std::string>(1, event_name));
+bool EventSelectionSet::AddEventType(const std::string& event_name, bool check) {
+  return AddEventGroup(std::vector<std::string>(1, event_name), check);
 }
 
 bool EventSelectionSet::AddEventType(const std::string& event_name, const SampleRate& sample_rate) {
@@ -291,13 +305,13 @@ bool EventSelectionSet::AddEventType(const std::string& event_name, const Sample
   return true;
 }
 
-bool EventSelectionSet::AddEventGroup(const std::vector<std::string>& event_names) {
+bool EventSelectionSet::AddEventGroup(const std::vector<std::string>& event_names, bool check) {
   EventSelectionGroup group;
   bool first_event = groups_.empty();
   bool first_in_group = true;
   for (const auto& event_name : event_names) {
     EventSelection selection;
-    if (!BuildAndCheckEventSelection(event_name, first_event, &selection)) {
+    if (!BuildAndCheckEventSelection(event_name, first_event, &selection, check)) {
       return false;
     }
     if (IsEtmEventType(selection.event_attr.type)) {
@@ -332,7 +346,7 @@ bool EventSelectionSet::AddCounters(const std::vector<std::string>& event_names)
   }
   for (const auto& event_name : event_names) {
     EventSelection selection;
-    if (!BuildAndCheckEventSelection(event_name, false, &selection)) {
+    if (!BuildAndCheckEventSelection(event_name, false, &selection, true)) {
       return false;
     }
     // Use a big sample_period to avoid getting samples for added counters.
@@ -666,8 +680,23 @@ bool EventSelectionSet::OpenEventFilesOnGroup(EventSelectionGroup& group, pid_t
   // successfully or all failed to open.
   EventFd* group_fd = nullptr;
   for (auto& selection : group.selections) {
+#if defined(__i386__) || defined(__x86_64__)
+    perf_event_attr attr = selection.event_attr;
+    if (attr.type == PERF_TYPE_RAW && GetX86IntelAtomCpus().count(cpu) > 0) {
+      std::optional<uint32_t> atom_type = GetX86IntelAtomCpuEventType();
+      if (!atom_type.has_value()) {
+        LOG(ERROR) << "Can't read pmu type for Intel Atom CPU";
+        return false;
+      }
+      attr.type = atom_type.value();
+      attr.config = selection.event_type_modifier.event_type.GetIntelAtomCpuConfig();
+    }
+    std::unique_ptr<EventFd> event_fd =
+        EventFd::OpenEventFile(attr, tid, cpu, group_fd, selection.event_type_modifier.name, false);
+#else   // defined(__i386__) || defined(__x86_64__)
     std::unique_ptr<EventFd> event_fd = EventFd::OpenEventFile(
         selection.event_attr, tid, cpu, group_fd, selection.event_type_modifier.name, false);
+#endif  // defined(__i386__) || defined(__x86_64__)
     if (!event_fd) {
       *failed_event_type = selection.event_type_modifier.name;
       return false;
@@ -695,6 +724,11 @@ static std::set<pid_t> PrepareThreads(const std::set<pid_t>& processes,
 }
 
 bool EventSelectionSet::OpenEventFiles() {
+  std::set<pid_t> threads = PrepareThreads(processes_, threads_);
+  return OpenEventFilesForThreads(threads);
+}
+
+bool EventSelectionSet::OpenEventFilesForThreads(const std::set<pid_t>& threads) {
   std::vector<int> online_cpus = GetOnlineCpus();
 
   auto check_if_cpus_online = [&](const std::vector<int>& cpus) {
@@ -710,7 +744,6 @@ bool EventSelectionSet::OpenEventFiles() {
     return true;
   };
 
-  std::set<pid_t> threads = PrepareThreads(processes_, threads_);
   for (auto& group : groups_) {
     const std::vector<int>* pcpus = &group.cpus;
     if (!group.selections[0].allowed_cpus.empty()) {
diff --git a/simpleperf/event_selection_set.h b/simpleperf/event_selection_set.h
index a892d51e..3d655694 100644
--- a/simpleperf/event_selection_set.h
+++ b/simpleperf/event_selection_set.h
@@ -107,9 +107,9 @@ class EventSelectionSet {
 
   bool empty() const { return groups_.empty(); }
 
-  bool AddEventType(const std::string& event_name);
+  bool AddEventType(const std::string& event_name, bool check = true);
   bool AddEventType(const std::string& event_name, const SampleRate& sample_rate);
-  bool AddEventGroup(const std::vector<std::string>& event_names);
+  bool AddEventGroup(const std::vector<std::string>& event_names, bool check = true);
   // For each sample generated for the existing event group, add counters for selected events.
   bool AddCounters(const std::vector<std::string>& event_names);
   std::vector<const EventType*> GetEvents() const;
@@ -165,6 +165,7 @@ class EventSelectionSet {
   IOEventLoop* GetIOEventLoop() { return loop_.get(); }
 
   bool OpenEventFiles();
+  bool OpenEventFilesForThreads(const std::set<pid_t>& threads);
   bool ReadCounters(std::vector<CountersInfo>* counters);
   bool MmapEventFiles(size_t min_mmap_pages, size_t max_mmap_pages, size_t aux_buffer_size,
                       size_t record_buffer_size, bool allow_truncating_samples, bool exclude_perf);
@@ -206,7 +207,7 @@ class EventSelectionSet {
   };
 
   bool BuildAndCheckEventSelection(const std::string& event_name, bool first_event,
-                                   EventSelection* selection);
+                                   EventSelection* selection, bool check);
   void UnionSampleType();
   void SetSampleRateForGroup(EventSelectionGroup& group, const SampleRate& rate);
   bool OpenEventFilesOnGroup(EventSelectionGroup& group, pid_t tid, int cpu,
@@ -248,6 +249,7 @@ bool IsSettingClockIdSupported();
 bool IsMmap2Supported();
 bool IsHardwareEventSupported();
 bool IsSwitchRecordSupported();
+bool IsKernelEventSupported();
 
 }  // namespace simpleperf
 
diff --git a/simpleperf/event_selection_set_test.cpp b/simpleperf/event_selection_set_test.cpp
index e60d81a8..75bffe49 100644
--- a/simpleperf/event_selection_set_test.cpp
+++ b/simpleperf/event_selection_set_test.cpp
@@ -48,13 +48,13 @@ TEST(EventSelectionSet, set_sample_rate_for_new_events) {
 TEST(EventSelectionSet, add_event_with_sample_rate) {
   EventSelectionSet event_selection_set(false);
   ASSERT_TRUE(event_selection_set.AddEventType("cpu-clock:u"));
-  ASSERT_TRUE(event_selection_set.AddEventType("context-switches", SampleRate(0, 1)));
+  ASSERT_TRUE(event_selection_set.AddEventType("context-switches:u", SampleRate(0, 1)));
   EventAttrIds attrs = event_selection_set.GetEventAttrWithId();
   ASSERT_EQ(attrs.size(), 2);
   ASSERT_EQ(GetEventNameByAttr(attrs[0].attr), "cpu-clock:u");
   ASSERT_EQ(attrs[0].attr.freq, 1);
   ASSERT_EQ(attrs[0].attr.sample_freq, 4000);
-  ASSERT_EQ(GetEventNameByAttr(attrs[1].attr), "context-switches");
+  ASSERT_EQ(GetEventNameByAttr(attrs[1].attr), "context-switches:u");
   ASSERT_EQ(attrs[1].attr.freq, 0);
   ASSERT_EQ(attrs[1].attr.sample_period, 1);
 }
diff --git a/simpleperf/event_table.json b/simpleperf/event_table.json
index ddcbfbf7..739fdd86 100644
--- a/simpleperf/event_table.json
+++ b/simpleperf/event_table.json
@@ -965,6 +965,26 @@
           "0x8165", "0x8167", "0x8168", "0x816A", "0x816B", "0x816D", "0x8171", "0x8172", "0x8173", "0x8284", "0x8285", "0x828C", "0x828D"
         ]
       },
+      {
+        "name": "Cortex-A725",
+        "implementer": "0x41",
+        "partnum": "0xd87",
+        "common_events": [
+          "0x0000", "0x0001", "0x0002", "0x0003", "0x0004", "0x0005", "0x0008", "0x0009", "0x000A", "0x000B", "0x000C", "0x000D", "0x000E", "0x0010", "0x0011", "0x0012",
+          "0x0013", "0x0014", "0x0015", "0x0016", "0x0017", "0x0018", "0x0019", "0x001B", "0x001C", "0x001D", "0x0020", "0x0021", "0x0022", "0x0023", "0x0024", "0x0025",
+          "0x0026", "0x0027", "0x0028", "0x0029", "0x002A", "0x002B", "0x002D", "0x002F", "0x0031", "0x0032", "0x0033", "0x0034", "0x0035", "0x0036", "0x0037", "0x0039",
+          "0x003A", "0x003C", "0x003D", "0x003E", "0x003F", "0x0040", "0x0041", "0x0044", "0x0045", "0x0048", "0x0050", "0x0051", "0x0052", "0x0053", "0x0056", "0x0057",
+          "0x0058", "0x0060", "0x0061", "0x0066", "0x0067", "0x006E", "0x006F", "0x0070", "0x0071", "0x0073", "0x0074", "0x0075", "0x0076", "0x0077", "0x007C", "0x007D",
+          "0x007E", "0x0081", "0x0082", "0x0083", "0x0084", "0x0086", "0x0087", "0x0088", "0x008A", "0x008B", "0x008C", "0x008D", "0x008E", "0x008F", "0x0090", "0x0091",
+          "0x00A0", "0x4000", "0x4001", "0x4002", "0x4003", "0x4004", "0x4005", "0x4006", "0x4009", "0x400A", "0x400B", "0x400C", "0x4010", "0x4011", "0x4012", "0x4013",
+          "0x4018", "0x4019", "0x401A", "0x401B", "0x4020", "0x4021", "0x4022", "0x4024", "0x4025", "0x4026", "0x8005", "0x8006", "0x8014", "0x8018", "0x801C", "0x8074",
+          "0x8075", "0x8076", "0x8077", "0x8079", "0x80BC", "0x80BD", "0x80C0", "0x80C1", "0x80E3", "0x80E7", "0x80EB", "0x80EF", "0x8108", "0x810C", "0x8110", "0x8111",
+          "0x8112", "0x8113", "0x8114", "0x8115", "0x8116", "0x8117", "0x811C", "0x811D", "0x8120", "0x8121", "0x8124", "0x8128", "0x8129", "0x812A", "0x812B", "0x812C",
+          "0x812D", "0x812E", "0x812F", "0x8134", "0x8135", "0x8136", "0x8137", "0x8138", "0x8139", "0x813A", "0x813B", "0x8140", "0x8148", "0x8149", "0x8152", "0x8154",
+          "0x8158", "0x8159", "0x815B", "0x815C", "0x8160", "0x8162", "0x8164", "0x8165", "0x8167", "0x8168", "0x816A", "0x816B", "0x816D", "0x8171", "0x8172", "0x8173",
+          "0x81BC", "0x8285", "0x828D", "0x829A"
+        ]
+      },
       {
         "name": "Cortex-X1",
         "implementer": "0x41",
@@ -1045,7 +1065,40 @@
   },
   "x86-intel": {
     "events": [
-      ["0x20c4", "BR_INST_RETIRED.NEAR_TAKEN", "Taken branch instructions retired"]
+      ["0x0160", "BACLEARS.ANY", "Count the number of BACLEARS occur when Branch Target Buffer prediction or lackthereof", "atom=0x01e6"],
+      ["0x00c4", "BR_INST_RETIRED.ALL_BRANCHES", "Count all branch instructions retired", "atom=0x00c4"],
+      ["0x11c4", "BR_INST_RETIRED.COND", "Count conditional branch instructions retired", "atom=0x7ec4"],
+      ["0x10c4", "BR_INST_RETIRED.COND_NTAKEN", "Count not taken branch instructions retired","atom=0x0000"],
+      ["0x01c4", "BR_INST_RETIRED.COND_TAKEN", "Counts taken conditional branch instructions retired", "atom=0xfeC4"],
+      ["0x40c4", "BR_INST_RETIRED.FAR_BRANCH", "Counts the number of far branch instructions retired", "atom=0xbfc4"],
+      ["0x80c4", "BR_INST_RETIRED.INDIRECT", "Count near indirect branch instructions retired excluding returns", "atom=0xebc4"],
+      ["0x02c4", "BR_INST_RETIRED.NEAR_CALL", "Count the number of near CALL branch instructions retired", "atom=0xf9c4"],
+      ["0x08c4", "BR_INST_RETIRED.NEAR_RETURN", "Counts the number of near RET branch instructions retired", "atom=0xf7c4"],
+      ["0x20c4", "BR_INST_RETIRED.NEAR_TAKEN", "Counts the number of near taken branch instructions retired", "atom=0xc0c4"],
+      ["0x00c5", "BR_MISP_RETIRED.ALL_BRANCHES", "Counts the total number of mispredicted branch instructions retired", "atom=0x00c5"],
+      ["0x11c5", "BR_MISP_RETIRED.COND", "Counts mispredicted conditional branch instructions retired", "atom=0x7ec5"],
+      ["0x01c5", "BR_MISP_RETIRED.COND_TAKEN", "Counts taken conditional mispredicted branch instructions retired", "atom=0xfec5"],
+      ["0x80c5", "BR_MISP_RETIRED.INDIRECT", "Counts miss-predicted near indirect branch instructions retired excluding returns. TSX abort is an indirect branch.", "atom=0xebc5"],
+      ["0x02c5", "BR_MISP_RETIRED.INDIRECT_CALL", "Counts retired mispredicted indirect (near taken) CALL instructions, including both register and memory indirect.", "atom=0xfbc5"],
+      ["0x08c5", "BR_MISP_RETIRED.RET", "Counts the number of mispredicted near RET branch instructions retired.", "atom=0xf7c5"],
+      ["0x0261", "DSB2MITE_SWITCHES.PENALTY_CYCLES", "event counts fetch penalty cycles when a transition occurs from DSB to MITE","atom=0x0000"],
+      ["0x03C6", "FRONTEND_RETIRED.ANY_DSB_MISS", "Counts retired Instructions that experienced DSB (Decode stream buffer i.e. the decoded instruction-cache) miss","atom=0x0000"],
+      ["0x03C6" , "FRONTEND_RETIRED.DSB_MISS", "event count number of retired Instructions that experienced a critical DSB","atom=0x0000"],
+      ["0x0879", "IDQ.DSB_CYCLES_ANY", "Counts the number of cycles uops delivered to Instruction Decode Queue (IDQ) from the Decode Stream Buffer (DSB) path","atom=0x0000"],
+      ["0x0879", "IDQ.DSB_CYCLES_OK", "Counts the number of cycles where optimal number of uops was delivered to the Instruction Decode Queue (IDQ) from the Decode Stream Buffer (DSB) path","atom=0x0000"],
+      ["0x0879", "IDQ.DSB_UOPS", "Counts the number of uops delivered to Instruction Decode Queue (IDQ) from the Decode Stream Buffer (DSB) path","atom=0x0000"],
+      ["0x0479", "IDQ.MITE_CYCLES_ANY", "Counts the number of cycles uops were delivered to the Instruction Decode Queue (IDQ) from the MITE","atom=0x0000"],
+      ["0x0479", "IDQ.MITE_CYCLES_OK", "Counts the number of cycles where optimal number of uops was delivered to the Instruction Decode Queue (IDQ) from the MITE path","atom=0x0000"],
+      ["0x0479", "IDQ.MITE_UOPS", "Counts the number of uops delivered to Instruction Decode Queue (IDQ) from the MITE path","atom=0x0000"],
+      ["0x2079", "IDQ.MS_CYCLES_ANY", "Counts cycles during which uops are being delivered to Instruction Decode Queue (IDQ) while the Microcode Sequencer (MS) is busy","atom=0x0000"],
+      ["0x2079", "IDQ.MS_SWITCHES", "Number of switches from DSB (Decode Stream Buffer) or MITE (legacy decode pipeline) to the Microcode Sequencer","atom=0x0000"],
+      ["0x2079", "IDQ.MS_UOPS", "Count the number of uops initiated by by MITE or DSB and delivered to Instruction Decode Queue (IDQ) while the Micrococde sequencer (MS) is busy","atom=0x0000"],
+      ["0x019C", "IDQ_UOPS_NOT_DELIVERED.CORE", "Counts the number of uops not delivered to by the Instruction Decode Queue (IDQ) to the back-end of the pipeline when there was no back-end stalls. This event counts for one SMT thread in a given cycle.","atom=0x0000"],
+      ["0x069C", "IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE", "Counts the number of cycles when no uops were delivered by the Instruction Decode Queue (IDQ) to the back-end of the pipeline when there was no back-end stalls. This event counts for one SMT thread in a given cycle.","atom=0x0000"],
+      ["0x069C", "IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE", "Counts the number of cycles when no uops were delivered by the Instruction Decode Queue (IDQ) to the back-end of the pipeline when there was no back-end stalls. This event counts for one SMT thread in a given cycle.","atom=0x0000"],
+      ["0x069C", "IDQ_UOPS_NOT_DELIVERED.CYCLES_FE_WAS_OK", "Counts the number of cycles when the optimal number of uops were delivered by the Instruction Decode Queue (IDQ) to the back-end of the pipeline when there was no back-end stalls. This event counts for one SMT thread in a given cycle.","atom=0x0000"],
+      ["0x0100", "INST_RETIRED.ANY", "Number of instructions retired. Fixed Counter - architectural event","atom=0x0100"],
+      ["0x0200", "CPU_CLK_UNHALTED.THREAD", "Counts the number of unhalted core clock cycles. (Fixed event)","atom=0x0200"]
     ]
   },
   "x86-amd": {
diff --git a/simpleperf/event_table_generator.py b/simpleperf/event_table_generator.py
index d44cbb6b..31f678be 100755
--- a/simpleperf/event_table_generator.py
+++ b/simpleperf/event_table_generator.py
@@ -189,7 +189,10 @@ class X86ArchData:
             number = int(event[0], 16)
             name = event[1]
             desc = event[2]
-            self.events.append(RawEvent(number, name, desc, self.arch))
+            limited_arch = self.arch
+            if len(event) > 3:
+                limited_arch += ":" + event[3]
+            self.events.append(RawEvent(number, name, desc, limited_arch))
 
 
 class RawEventGenerator:
@@ -210,7 +213,7 @@ class RawEventGenerator:
             lines = []
             for event in events:
                 lines.append(gen_event_type_entry_str(event.name, 'PERF_TYPE_RAW', '0x%x' %
-                         event.number, event.desc, event.limited_arch))
+                                                      event.number, event.desc, event.limited_arch))
             return guard(''.join(lines))
 
         lines_arm64 = generate_event_entries(self.arm64_data.events, self.add_arm_guard)
diff --git a/simpleperf/event_type.cpp b/simpleperf/event_type.cpp
index fef1a9f1..d54ac274 100644
--- a/simpleperf/event_type.cpp
+++ b/simpleperf/event_type.cpp
@@ -463,6 +463,16 @@ std::vector<int> EventType::GetPmuCpumask() {
   return empty_result;
 }
 
+uint64_t EventType::GetIntelAtomCpuConfig() const {
+  if (auto pos = limited_arch.find("atom="); pos != std::string::npos) {
+    uint64_t atom_config;
+    if (android::base::ParseUint(limited_arch.substr(pos + 5), &atom_config)) {
+      return atom_config;
+    }
+  }
+  return config;
+}
+
 std::string ScopedEventTypes::BuildString(const std::vector<const EventType*>& event_types) {
   std::string result;
   for (auto type : event_types) {
diff --git a/simpleperf/event_type.h b/simpleperf/event_type.h
index d85f71d1..ecc3d175 100644
--- a/simpleperf/event_type.h
+++ b/simpleperf/event_type.h
@@ -19,6 +19,7 @@
 
 #include <stdint.h>
 #include <strings.h>
+#include <functional>
 #include <memory>
 #include <set>
 #include <string>
@@ -58,6 +59,7 @@ struct EventType {
   bool IsTracepointEvent() const { return type == PERF_TYPE_TRACEPOINT; }
 
   std::vector<int> GetPmuCpumask();
+  uint64_t GetIntelAtomCpuConfig() const;
 
   std::string name;
   uint32_t type;
diff --git a/simpleperf/main.cpp b/simpleperf/main.cpp
index 221ecd07..4cbb0aa4 100644
--- a/simpleperf/main.cpp
+++ b/simpleperf/main.cpp
@@ -16,6 +16,7 @@
 
 #if defined(__ANDROID__)
 #include <android-base/properties.h>
+#include <sys/prctl.h>
 #endif
 
 #include "command.h"
@@ -75,6 +76,10 @@ int main(int argc, char** argv) {
   if (!AndroidSecurityCheck()) {
     return 1;
   }
+  if (IsInAppUid()) {
+    // Disable core dump in app context to avoid leaking raw sample info.
+    prctl(PR_SET_DUMPABLE, 0);
+  }
 #endif
   RegisterAllCommands();
   return RunSimpleperfCmd(argc, argv) ? 0 : 1;
diff --git a/simpleperf/read_dex_file_test.cpp b/simpleperf/read_dex_file_test.cpp
index a9860f83..74a2aac9 100644
--- a/simpleperf/read_dex_file_test.cpp
+++ b/simpleperf/read_dex_file_test.cpp
@@ -33,12 +33,12 @@ TEST(read_dex_file, smoke) {
   auto symbol_callback = [&](DexFileSymbol* symbol) {
     symbols.emplace_back(symbol->name, symbol->addr, symbol->size);
   };
-  ASSERT_TRUE(ReadSymbolsFromDexFile(GetTestData("base.vdex"), {0x28}, symbol_callback));
-  ASSERT_EQ(12435u, symbols.size());
+  ASSERT_TRUE(ReadSymbolsFromDexFile(GetTestData("base.dex"), {0}, symbol_callback));
+  ASSERT_EQ(3912u, symbols.size());
   auto it = std::find_if(symbols.begin(), symbols.end(),
-                         [](const Symbol& symbol) { return symbol.addr == 0x6c77e; });
+                         [](const Symbol& symbol) { return symbol.addr == 0x613ec; });
   ASSERT_NE(it, symbols.end());
-  ASSERT_EQ(it->addr, 0x6c77e);
-  ASSERT_EQ(it->len, 0x16);
-  ASSERT_STREQ(it->Name(), "com.example.simpleperf.simpleperfexamplewithnative.MixActivity$1.run");
+  ASSERT_EQ(it->addr, 0x613ec);
+  ASSERT_EQ(it->len, 0x128);
+  ASSERT_STREQ(it->Name(), "com.example.android.displayingbitmaps.ui.ImageDetailActivity.onCreate");
 }
diff --git a/simpleperf/read_elf.cpp b/simpleperf/read_elf.cpp
index 8e9ddb1a..a8c92dd9 100644
--- a/simpleperf/read_elf.cpp
+++ b/simpleperf/read_elf.cpp
@@ -130,13 +130,25 @@ ElfStatus GetBuildIdFromNoteFile(const std::string& filename, BuildId* build_id)
 }
 
 bool IsArmMappingSymbol(const char* name) {
-  // Mapping symbols in arm, which are described in "ELF for ARM Architecture" and
-  // "ELF for ARM 64-bit Architecture". The regular expression to match mapping symbol
-  // is ^\$(a|d|t|x)(\..*)?$
+  // Matches ARM ELF mapping symbols (e.g., $a, $d, $t, $x, $x.foo).
+  // See:
+  //   - ARM64 (ELF for the ARM 64-bit Architecture):
+  //   https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#mapping-symbols
+  //   - ARM (ELF for the ARM Architecture):
+  //   https://github.com/ARM-software/abi-aa/blob/main/aaelf32/aaelf32.rst#mapping-symbols
+  // Regex: ^\$(a|d|t|x)(\..*)?$
   return name[0] == '$' && strchr("adtx", name[1]) != nullptr &&
          (name[2] == '\0' || name[2] == '.');
 }
 
+bool IsRISCVMappingSymbol(const char* name) {
+  // Mapping symbols in RISC-V, which are described in "RISC-V ABIs Specification", in
+  // https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#mapping-symbol.
+  // It could be $d, $d.<any>, $x, $x.<any>, $x<isa> or $x<isa>.<any>.
+  // We just loosely check the first character is '$' and the second character is 'd' or 'x'.
+  return name[0] == '$' && strchr("dx", name[1]) != nullptr;
+}
+
 namespace {
 
 struct BinaryWrapper {
@@ -230,8 +242,10 @@ static inline llvm::Expected<llvm::StringRef> GetELFSectionName(
 }
 
 void ReadSymbolTable(llvm::object::symbol_iterator sym_begin, llvm::object::symbol_iterator sym_end,
-                     const std::function<void(const ElfFileSymbol&)>& callback, bool is_arm,
+                     const std::function<void(const ElfFileSymbol&)>& callback, int machine,
                      const llvm::object::section_iterator& section_end) {
+  bool is_arm = (machine == llvm::ELF::EM_ARM || machine == llvm::ELF::EM_AARCH64);
+  bool is_riscv = machine == llvm::ELF::EM_RISCV;
   for (; sym_begin != sym_end; ++sym_begin) {
     ElfFileSymbol symbol;
     auto symbol_ref = static_cast<const llvm::object::ELFSymbolRef*>(&*sym_begin);
@@ -277,14 +291,12 @@ void ReadSymbolTable(llvm::object::symbol_iterator sym_begin, llvm::object::symb
     } else if (symbol_type == llvm::object::SymbolRef::ST_Unknown) {
       if (symbol.is_in_text_section) {
         symbol.is_label = true;
-        if (is_arm) {
-          // Remove mapping symbols in arm.
-          const char* p = (symbol.name.compare(0, linker_prefix.size(), linker_prefix) == 0)
-                              ? symbol.name.c_str() + linker_prefix.size()
-                              : symbol.name.c_str();
-          if (IsArmMappingSymbol(p)) {
-            symbol.is_label = false;
-          }
+        const char* p = (symbol.name.compare(0, linker_prefix.size(), linker_prefix) == 0)
+                            ? symbol.name.c_str() + linker_prefix.size()
+                            : symbol.name.c_str();
+        // Remove mapping symbols in arm and RISC-V.
+        if ((is_arm && IsArmMappingSymbol(p)) || (is_riscv && IsRISCVMappingSymbol(p))) {
+          symbol.is_label = false;
         }
       }
     }
@@ -417,28 +429,29 @@ class ElfFileImpl<llvm::object::ELFObjectFile<ELFT>> : public ElfFile {
   }
 
   ElfStatus ParseSymbols(const ParseSymbolCallback& callback) override {
-    auto machine = GetELFHeader(elf_).e_machine;
-    bool is_arm = (machine == llvm::ELF::EM_ARM || machine == llvm::ELF::EM_AARCH64);
     AddSymbolForPltSection(elf_obj_, callback);
     // Some applications deliberately ship elf files with broken section tables.
     // So check the existence of .symtab section and .dynsym section before reading symbols.
     bool has_symtab;
     bool has_dynsym;
     CheckSymbolSections(elf_obj_, &has_symtab, &has_dynsym);
+    int machine = GetELFHeader(elf_).e_machine;
     if (has_symtab && elf_obj_->symbol_begin() != elf_obj_->symbol_end()) {
-      ReadSymbolTable(elf_obj_->symbol_begin(), elf_obj_->symbol_end(), callback, is_arm,
+      ReadSymbolTable(elf_obj_->symbol_begin(), elf_obj_->symbol_end(), callback, machine,
                       elf_obj_->section_end());
       return ElfStatus::NO_ERROR;
-    } else if (has_dynsym && elf_obj_->dynamic_symbol_begin()->getRawDataRefImpl() !=
-                                 llvm::object::DataRefImpl()) {
+    }
+    if (has_dynsym &&
+        elf_obj_->dynamic_symbol_begin()->getRawDataRefImpl() != llvm::object::DataRefImpl()) {
       ReadSymbolTable(elf_obj_->dynamic_symbol_begin(), elf_obj_->dynamic_symbol_end(), callback,
-                      is_arm, elf_obj_->section_end());
+                      machine, elf_obj_->section_end());
     }
     std::string debugdata;
     ElfStatus result = ReadSection(".gnu_debugdata", &debugdata);
     if (result == ElfStatus::SECTION_NOT_FOUND) {
       return ElfStatus::NO_SYMBOL_TABLE;
-    } else if (result == ElfStatus::NO_ERROR) {
+    }
+    if (result == ElfStatus::NO_ERROR) {
       std::string decompressed_data;
       if (XzDecompress(debugdata, &decompressed_data)) {
         auto debugdata_elf =
@@ -452,10 +465,8 @@ class ElfFileImpl<llvm::object::ELFObjectFile<ELFT>> : public ElfFile {
   }
 
   void ParseDynamicSymbols(const ParseSymbolCallback& callback) override {
-    auto machine = GetELFHeader(elf_).e_machine;
-    bool is_arm = (machine == llvm::ELF::EM_ARM || machine == llvm::ELF::EM_AARCH64);
     ReadSymbolTable(elf_obj_->dynamic_symbol_begin(), elf_obj_->dynamic_symbol_end(), callback,
-                    is_arm, elf_obj_->section_end());
+                    GetELFHeader(elf_).e_machine, elf_obj_->section_end());
   }
 
   ElfStatus ReadSection(const std::string& section_name, std::string* content) override {
diff --git a/simpleperf/read_elf.h b/simpleperf/read_elf.h
index 3ade27fa..6ee8ab26 100644
--- a/simpleperf/read_elf.h
+++ b/simpleperf/read_elf.h
@@ -108,6 +108,7 @@ class ElfFile {
 };
 
 bool IsArmMappingSymbol(const char* name);
+bool IsRISCVMappingSymbol(const char* name);
 ElfStatus IsValidElfFile(int fd, uint64_t file_offset = 0);
 bool IsValidElfFileMagic(const char* buf, size_t buf_size);
 bool GetBuildIdFromNoteSection(const char* section, size_t section_size, BuildId* build_id);
diff --git a/simpleperf/read_elf_test.cpp b/simpleperf/read_elf_test.cpp
index 709205a8..fd48af69 100644
--- a/simpleperf/read_elf_test.cpp
+++ b/simpleperf/read_elf_test.cpp
@@ -178,6 +178,17 @@ TEST(read_elf, arm_mapping_symbol) {
   ASSERT_FALSE(IsArmMappingSymbol("$a_no_dot"));
 }
 
+// @CddTest = 6.1/C-0-2
+TEST(read_elf, riscv_mapping_symbol) {
+  ASSERT_TRUE(IsRISCVMappingSymbol("$d"));
+  ASSERT_TRUE(IsRISCVMappingSymbol("$x"));
+  ASSERT_TRUE(IsRISCVMappingSymbol("$xrv64imafd"));
+  ASSERT_FALSE(IsRISCVMappingSymbol("$b"));
+  ASSERT_TRUE(IsRISCVMappingSymbol("$d.anything"));
+  ASSERT_TRUE(IsRISCVMappingSymbol("$x.anything"));
+  ASSERT_TRUE(IsRISCVMappingSymbol("$xrv64imafd.anything"));
+}
+
 // @CddTest = 6.1/C-0-2
 TEST(read_elf, ElfFile_Open) {
   auto IsValidElfPath = [](const std::string& path) {
diff --git a/simpleperf/record.cpp b/simpleperf/record.cpp
index 2685f375..5c704be2 100644
--- a/simpleperf/record.cpp
+++ b/simpleperf/record.cpp
@@ -734,7 +734,7 @@ void SampleRecord::ReplaceRegAndStackWithCallChain(const std::vector<uint64_t>&
 
 bool SampleRecord::ExcludeKernelCallChain() {
   if (!(sample_type & PERF_SAMPLE_CALLCHAIN)) {
-    return true;
+    return false;
   }
   size_t i;
   for (i = 0; i < callchain_data.ip_nr; ++i) {
diff --git a/simpleperf/record_test.cpp b/simpleperf/record_test.cpp
index 9624dfd8..e391cab7 100644
--- a/simpleperf/record_test.cpp
+++ b/simpleperf/record_test.cpp
@@ -66,7 +66,7 @@ TEST_F(RecordTest, SampleRecordMatchBinary) {
 // @CddTest = 6.1/C-0-2
 TEST_F(RecordTest, SampleRecord_exclude_kernel_callchain) {
   SampleRecord r(event_attr, 0, 1, 0, 0, 0, 0, 0, {}, {}, {}, 0);
-  ASSERT_TRUE(r.ExcludeKernelCallChain());
+  ASSERT_FALSE(r.ExcludeKernelCallChain());
 
   event_attr.sample_type |= PERF_SAMPLE_CALLCHAIN;
   SampleRecord r1(event_attr, 0, 1, 0, 0, 0, 0, 0, {}, {PERF_CONTEXT_USER, 2}, {}, 0);
diff --git a/simpleperf/report_lib_interface.cpp b/simpleperf/report_lib_interface.cpp
index 0f9d9006..42a0ac95 100644
--- a/simpleperf/report_lib_interface.cpp
+++ b/simpleperf/report_lib_interface.cpp
@@ -23,6 +23,7 @@
 #include <android-base/logging.h>
 #include <android-base/strings.h>
 
+#include "ETMDecoder.h"
 #include "JITDebugReader.h"
 #include "RecordFilter.h"
 #include "dso.h"
@@ -108,6 +109,22 @@ struct FeatureSection {
   uint32_t data_size;
 };
 
+struct BuildIdPair {
+  const unsigned char* build_id;
+  const char* filename;
+};
+
+struct DsoAddress {
+  const char* path;
+  uint64_t offset;
+};
+
+struct Thread {
+  int pid;
+  int tid;
+  const char* comm;
+};
+
 }  // extern "C"
 
 namespace simpleperf {
@@ -175,6 +192,18 @@ struct TraceOffCpuData {
 
 }  // namespace
 
+using UserCallback = ETMDecoder::UserCallback;
+class ETMThreadTreeSimple : public ETMThreadTree {
+ public:
+  ETMThreadTreeSimple(ThreadTree& thread_tree) : thread_tree_(thread_tree) {}
+  void DisableThreadExitRecords() override { thread_tree_.DisableThreadExitRecords(); }
+  const ThreadEntry* FindThread(int tid) override { return thread_tree_.FindThread(tid); }
+  const MapSet& GetKernelMaps() override { return thread_tree_.GetKernelMaps(); }
+
+ private:
+  ThreadTree& thread_tree_;
+};
+
 class ReportLib {
  public:
   ReportLib()
@@ -182,7 +211,8 @@ class ReportLib {
         record_filename_("perf.data"),
         current_thread_(nullptr),
         callchain_report_builder_(thread_tree_),
-        record_filter_(thread_tree_) {}
+        record_filter_(thread_tree_),
+        etm_thread_tree_(thread_tree_) {}
 
   bool SetLogSeverity(const char* log_level);
 
@@ -233,11 +263,19 @@ class ReportLib {
 
   const char* GetBuildIdForPath(const char* path);
   FeatureSection* GetFeatureSection(const char* feature_name);
+  BuildIdPair* GetAllBuildIds();
+
+  void SetCallback(UserCallback callback) { callback_ = callback; }
+  DsoAddress ConvertETMAddressToVaddrInFile(uint8_t trace_id, uint64_t address);
+
+  Thread GetThread(int tid);
+  SymbolEntry* ReadSymbolsForPath(const char* path);
 
  private:
   std::unique_ptr<SampleRecord> GetNextSampleRecord();
   void ProcessSampleRecord(std::unique_ptr<Record> r);
   void ProcessSwitchRecord(std::unique_ptr<Record> r);
+  bool ProcessAuxData(std::unique_ptr<Record> r);
   void AddSampleRecordToQueue(SampleRecord* r);
   bool SetCurrentSample(std::unique_ptr<SampleRecord> sample_record);
   void SetEventCounters(const SampleRecord& r);
@@ -271,6 +309,16 @@ class ReportLib {
   ThreadReportBuilder thread_report_builder_;
   std::unique_ptr<Tracing> tracing_;
   RecordFilter record_filter_;
+  std::vector<BuildIdRecord> buildid_records_;
+  std::vector<BuildIdPair> buildids_;
+
+  ETMThreadTreeSimple etm_thread_tree_;
+  std::unique_ptr<ETMDecoder> etm_decoder_;
+  UserCallback callback_;
+  std::vector<uint8_t> aux_data_buffer_;
+  std::string filepath_;
+  std::string comm_;
+  std::vector<SymbolEntry> symbols_;
 };
 
 bool ReportLib::SetLogSeverity(const char* log_level) {
@@ -416,6 +464,21 @@ std::unique_ptr<SampleRecord> ReportLib::GetNextSampleRecord() {
       if (!tracing_) {
         return nullptr;
       }
+    } else if (record->type() == PERF_RECORD_AUXTRACE_INFO) {
+      if (!callback_) {
+        LOG(ERROR) << "ETM trace found but no callback was set!";
+        return nullptr;
+      }
+      etm_decoder_ =
+          ETMDecoder::Create(static_cast<AuxTraceInfoRecord&>(*record), etm_thread_tree_);
+      if (!etm_decoder_) {
+        return nullptr;
+      }
+      etm_decoder_->RegisterCallback(callback_);
+    } else if (record->type() == PERF_RECORD_AUX) {
+      if (!ProcessAuxData(std::move(record))) {
+        return nullptr;
+      }
     }
   }
   std::unique_ptr<SampleRecord> result = std::move(sample_record_queue_.front());
@@ -486,6 +549,29 @@ void ReportLib::ProcessSwitchRecord(std::unique_ptr<Record> r) {
   }
 }
 
+bool ReportLib::ProcessAuxData(std::unique_ptr<Record> r) {
+  AuxRecord& aux = static_cast<AuxRecord&>(*r);
+  if (aux.data->aux_size > SIZE_MAX) {
+    LOG(ERROR) << "invalid aux size";
+    return false;
+  }
+  size_t aux_size = aux.data->aux_size;
+  if (aux_size > 0) {
+    bool error = false;
+    if (!record_file_reader_->ReadAuxData(aux.Cpu(), aux.data->aux_offset, aux_size,
+                                          aux_data_buffer_, error)) {
+      return !error;
+    }
+    if (!etm_decoder_) {
+      LOG(ERROR) << "ETMDecoder has not been created";
+      return false;
+    }
+    return etm_decoder_->ProcessData(aux_data_buffer_.data(), aux_size, !aux.Unformatted(),
+                                     aux.Cpu());
+  }
+  return true;
+}
+
 void ReportLib::AddSampleRecordToQueue(SampleRecord* r) {
   if (record_filter_.Check(*r)) {
     sample_record_queue_.emplace(r);
@@ -654,6 +740,68 @@ FeatureSection* ReportLib::GetFeatureSection(const char* feature_name) {
   return &feature_section_;
 }
 
+BuildIdPair* ReportLib::GetAllBuildIds() {
+  if (!OpenRecordFileIfNecessary()) {
+    return nullptr;
+  }
+  buildid_records_.clear();
+  buildid_records_ = record_file_reader_->ReadBuildIdFeature();
+  if (buildid_records_.empty()) {
+    return nullptr;
+  }
+  buildids_.clear();
+  buildids_.reserve(buildid_records_.size() + 1);
+  for (const auto& r : buildid_records_) {
+    buildids_.emplace_back(r.build_id.Data(), r.filename);
+  }
+  buildids_.emplace_back(nullptr, nullptr);
+  return buildids_.data();
+}
+
+DsoAddress ReportLib::ConvertETMAddressToVaddrInFile(uint8_t trace_id, uint64_t address) {
+  if (!etm_decoder_) {
+    LOG(ERROR) << "ETMDecoder was not created yet!";
+    return DsoAddress{.path = nullptr, .offset = 0};
+  }
+  const simpleperf::MapEntry* e = etm_decoder_->FindMap(trace_id, address);
+  if (e) {
+    filepath_ = e->dso->Path();
+    return DsoAddress{.path = filepath_.c_str(), .offset = e->GetVaddrInFile(address)};
+  } else {
+    return DsoAddress{.path = nullptr, .offset = address};
+  }
+}
+
+Thread ReportLib::GetThread(int tid) {
+  Thread result{.pid = -1, .tid = -1, .comm = nullptr};
+  ThreadEntry* thread = thread_tree_.FindThread(tid);
+  if (thread) {
+    comm_ = thread->comm;
+    result.pid = thread->pid;
+    result.tid = thread->tid;
+    result.comm = comm_.c_str();
+  }
+  return result;
+}
+
+SymbolEntry* ReportLib::ReadSymbolsForPath(const char* path) {
+  std::string filename(path);
+  Dso* dso = thread_tree_.FindUserDso(filename);
+  if (!dso) {
+    return nullptr;
+  }
+  dso->LoadSymbols();
+  auto symbols = dso->GetSymbols();
+
+  symbols_.clear();
+  symbols_.reserve(symbols.size() + 1);
+  for (auto& symbol : symbols) {
+    symbols_.emplace_back(nullptr, 0, symbol.DemangledName(), symbol.addr, symbol.len, nullptr);
+  }
+  symbols_.emplace_back(nullptr, 0, nullptr, 0, 0, nullptr);
+  return symbols_.data();
+}
+
 }  // namespace simpleperf
 
 using ReportLib = simpleperf::ReportLib;
@@ -694,6 +842,13 @@ const char* GetProcessNameOfCurrentSample(ReportLib* report_lib) EXPORT;
 
 const char* GetBuildIdForPath(ReportLib* report_lib, const char* path) EXPORT;
 FeatureSection* GetFeatureSection(ReportLib* report_lib, const char* feature_name) EXPORT;
+BuildIdPair* GetAllBuildIds(ReportLib* report_lib) EXPORT;
+
+void SetETMCallback(ReportLib* report_lib, void (*callback)(const uint8_t, const void*)) EXPORT;
+DsoAddress ConvertETMAddressToVaddrInFile(ReportLib* report_lib, uint8_t trace_id,
+                                          uint64_t address) EXPORT;
+Thread GetThread(ReportLib* report_lib, int tid) EXPORT;
+SymbolEntry* ReadSymbolsForPath(ReportLib* report_lib, const char* path) EXPORT;
 }
 
 // Exported methods working with a client created instance
@@ -793,3 +948,24 @@ const char* GetBuildIdForPath(ReportLib* report_lib, const char* path) {
 FeatureSection* GetFeatureSection(ReportLib* report_lib, const char* feature_name) {
   return report_lib->GetFeatureSection(feature_name);
 }
+
+BuildIdPair* GetAllBuildIds(ReportLib* report_lib) {
+  return report_lib->GetAllBuildIds();
+}
+
+void SetETMCallback(ReportLib* report_lib, void (*callback)(const uint8_t, const void*)) {
+  report_lib->SetCallback(callback);
+}
+
+DsoAddress ConvertETMAddressToVaddrInFile(ReportLib* report_lib, uint8_t trace_id,
+                                          uint64_t address) {
+  return report_lib->ConvertETMAddressToVaddrInFile(trace_id, address);
+}
+
+Thread GetThread(ReportLib* report_lib, int tid) {
+  return report_lib->GetThread(tid);
+}
+
+SymbolEntry* ReadSymbolsForPath(ReportLib* report_lib, const char* path) {
+  return report_lib->ReadSymbolsForPath(path);
+}
diff --git a/simpleperf/runtest/Android.bp b/simpleperf/runtest/Android.bp
index cbc10c7c..6723702b 100644
--- a/simpleperf/runtest/Android.bp
+++ b/simpleperf/runtest/Android.bp
@@ -115,6 +115,13 @@ cc_binary {
     ],
 }
 
+// Used as an example in collect_lbr_data_for_autofdo.md.
+cc_binary {
+    name: "autofdo_inline_test",
+    srcs: ["autofdo_inline_test.cpp"],
+    afdo: true,
+}
+
 cc_binary {
     name: "autofdo_addr_test",
     srcs: ["autofdo_addr_test.cpp"],
diff --git a/simpleperf/runtest/autofdo_inline_test.cpp b/simpleperf/runtest/autofdo_inline_test.cpp
new file mode 100644
index 00000000..813daf66
--- /dev/null
+++ b/simpleperf/runtest/autofdo_inline_test.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <unistd.h>  // For usleep function
+
+typedef uint32_t UInt32;
+typedef uint16_t UInt16;
+
+void cond_branch_example_function(uint16_t* prob, uint8_t* buf) {
+  UInt32 range = 0xFFFFFFFF;
+  UInt32 code = 0;
+  UInt32 bound;
+  UInt16 ttt;
+  UInt32 symbol = 0;
+
+  do {
+    ttt = *(prob + symbol);
+    if (range < ((UInt32)1 << 24)) {
+      range <<= 8;
+      code = (code << 8) | (*buf++);
+    }
+    bound = (range >> 11) * ttt;
+    if (code < bound) {  // <== This is mispredicted branch (conditional branch)
+      range = bound;
+      *(prob + symbol) = (UInt16)(ttt + (((1 << 11) - ttt) >> 5));
+      symbol = (symbol + symbol);
+    } else {
+      range -= bound;
+      code -= bound;
+      *(prob + symbol) = (UInt16)(ttt - (ttt >> 5));
+      symbol = (symbol + symbol) + 1;
+    }
+  } while (symbol < 0x100);  // conditional branch
+}
+
+int main() {
+  uint16_t prob[256] = {0};
+  uint8_t buf[256] = {0};
+
+  usleep(15000000);
+
+  // Call the conditional branch example function
+  cond_branch_example_function(prob, buf);
+
+  return 0;
+}
diff --git a/simpleperf/scripts/Android.bp b/simpleperf/scripts/Android.bp
index df94b8e0..bc556a71 100644
--- a/simpleperf/scripts/Android.bp
+++ b/simpleperf/scripts/Android.bp
@@ -26,6 +26,7 @@ package {
 python_library_host {
     name: "simpleperf_report_lib",
     srcs: [
+        "etm_types.py",
         "report_sample_pb2.py",
         "simpleperf_report_lib.py",
         "simpleperf_utils.py",
diff --git a/simpleperf/scripts/bin/android/arm/simpleperf b/simpleperf/scripts/bin/android/arm/simpleperf
index 6f29b6d2..405f57fb 100755
Binary files a/simpleperf/scripts/bin/android/arm/simpleperf and b/simpleperf/scripts/bin/android/arm/simpleperf differ
diff --git a/simpleperf/scripts/bin/android/arm64/simpleperf b/simpleperf/scripts/bin/android/arm64/simpleperf
index a7f5ed40..95edda55 100755
Binary files a/simpleperf/scripts/bin/android/arm64/simpleperf and b/simpleperf/scripts/bin/android/arm64/simpleperf differ
diff --git a/simpleperf/scripts/bin/android/riscv64/simpleperf b/simpleperf/scripts/bin/android/riscv64/simpleperf
index 23a6f90c..0253f1a8 100755
Binary files a/simpleperf/scripts/bin/android/riscv64/simpleperf and b/simpleperf/scripts/bin/android/riscv64/simpleperf differ
diff --git a/simpleperf/scripts/bin/android/x86/simpleperf b/simpleperf/scripts/bin/android/x86/simpleperf
index 08922302..73d1108d 100755
Binary files a/simpleperf/scripts/bin/android/x86/simpleperf and b/simpleperf/scripts/bin/android/x86/simpleperf differ
diff --git a/simpleperf/scripts/bin/android/x86_64/simpleperf b/simpleperf/scripts/bin/android/x86_64/simpleperf
index be336cf8..7276e3ed 100755
Binary files a/simpleperf/scripts/bin/android/x86_64/simpleperf and b/simpleperf/scripts/bin/android/x86_64/simpleperf differ
diff --git a/simpleperf/scripts/bin/darwin/x86_64/libsimpleperf_report.dylib b/simpleperf/scripts/bin/darwin/x86_64/libsimpleperf_report.dylib
index 06f07c7c..b7f10324 100755
Binary files a/simpleperf/scripts/bin/darwin/x86_64/libsimpleperf_report.dylib and b/simpleperf/scripts/bin/darwin/x86_64/libsimpleperf_report.dylib differ
diff --git a/simpleperf/scripts/bin/darwin/x86_64/simpleperf b/simpleperf/scripts/bin/darwin/x86_64/simpleperf
index 2a04b7b7..96b4a2e2 100755
Binary files a/simpleperf/scripts/bin/darwin/x86_64/simpleperf and b/simpleperf/scripts/bin/darwin/x86_64/simpleperf differ
diff --git a/simpleperf/scripts/bin/linux/x86_64/libsimpleperf_report.so b/simpleperf/scripts/bin/linux/x86_64/libsimpleperf_report.so
index 333428c0..4924726d 100755
Binary files a/simpleperf/scripts/bin/linux/x86_64/libsimpleperf_report.so and b/simpleperf/scripts/bin/linux/x86_64/libsimpleperf_report.so differ
diff --git a/simpleperf/scripts/bin/linux/x86_64/simpleperf b/simpleperf/scripts/bin/linux/x86_64/simpleperf
index 4d0adc41..b4aede5f 100755
Binary files a/simpleperf/scripts/bin/linux/x86_64/simpleperf and b/simpleperf/scripts/bin/linux/x86_64/simpleperf differ
diff --git a/simpleperf/scripts/binary_cache_builder.py b/simpleperf/scripts/binary_cache_builder.py
index 31f03e67..acfa639d 100755
--- a/simpleperf/scripts/binary_cache_builder.py
+++ b/simpleperf/scripts/binary_cache_builder.py
@@ -257,9 +257,13 @@ class BinaryCacheBuilder:
         self.binary_cache = BinaryCache(self.binary_cache_dir)
         self.binaries = {}
 
-    def build_binary_cache(self, perf_data_path: str, symfs_dirs: List[Union[Path, str]]) -> bool:
+    def build_binary_cache(self, perf_data_path: str, symfs_dirs: List[Union[Path, str]],
+                           every: bool = False) -> bool:
         self.binary_cache_dir.mkdir(exist_ok=True)
-        self.collect_used_binaries(perf_data_path)
+        if every:
+            self.collect_all_binaries(perf_data_path)
+        else:
+            self.collect_used_binaries(perf_data_path)
         if not self.copy_binaries_from_symfs_dirs(symfs_dirs):
             return False
         self.pull_binaries_from_device()
@@ -292,6 +296,24 @@ class BinaryCacheBuilder:
                     binaries[name] = lib.GetBuildIdForPath(dso_name)
         self.binaries = binaries
 
+    def collect_all_binaries(self, perf_data_path: str) -> None:
+        """Read perf.data, and collect all binaries with build id, even if
+           they were not used in any samples.
+        """
+        binaries = {}
+        lib = ReportLib()
+        lib.SetRecordFile(perf_data_path)
+        lib.SetLogSeverity('error')
+
+        binaries = lib.GetAllBuildIds()
+
+        if '[kernel.kallsyms]' in binaries:
+            binaries['vmlinux'] = binaries['[kernel.kallsyms]']
+            del binaries['[kernel.kallsyms]']
+
+        lib.Close()
+        self.binaries = binaries
+
     def copy_binaries_from_symfs_dirs(self, symfs_dirs: List[Union[str, Path]]) -> bool:
         if symfs_dirs:
             lib_dirs: List[Path] = []
@@ -340,11 +362,13 @@ def main() -> bool:
     parser.add_argument('--disable_adb_root', action='store_true', help="""
         Force adb to run in non root mode.""")
     parser.add_argument('--ndk_path', nargs=1, help='Find tools in the ndk path.')
+    parser.add_argument('--every', action='store_true', help="""
+        Download every binary mentioned in the perf.data, not just those with samples.""")
     args = parser.parse_args()
     ndk_path = None if not args.ndk_path else args.ndk_path[0]
     builder = BinaryCacheBuilder(ndk_path, args.disable_adb_root)
     symfs_dirs = flatten_arg_list(args.native_lib_dir)
-    return builder.build_binary_cache(args.perf_data_path, symfs_dirs)
+    return builder.build_binary_cache(args.perf_data_path, symfs_dirs, args.every)
 
 
 if __name__ == '__main__':
diff --git a/simpleperf/scripts/etm_types.py b/simpleperf/scripts/etm_types.py
new file mode 100644
index 00000000..1cc344f3
--- /dev/null
+++ b/simpleperf/scripts/etm_types.py
@@ -0,0 +1,300 @@
+#!/usr/bin/env python3
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+"""etm_types.py: ctypes based structures to handle ocsd_generic_trace_elem from OpenCSD.
+
+   Please refer to the documentation of OpenCSD to see the fields available and their meaning:
+   https://github.com/Linaro/OpenCSD/blob/master/decoder/docs/prog_guide/prog_guide_generic_pkts.md
+
+"""
+
+import ctypes as ct
+from enum import Enum, auto
+import sys
+
+# On 32 bit machines, ocsd_vaddr_t is 32 bit only.
+VADDR_TYPE = ct.c_uint64 if sys.maxsize > 2**32 else ct.c_uint32
+
+
+class SecLevel(Enum):
+    """ocsd_sec_level in OpenCSD."""
+    SECURE = 0
+    NONSECURE = 1
+    ROOT = 2
+    REALM = 3
+
+
+class ExLevel(Enum):
+    """ocsd_ex_level in OpenCSD."""
+    UNKNOWN = -1
+    EL0 = 0
+    EL1 = 1
+    EL2 = 2
+    EL3 = 3
+
+
+class PeContext(ct.Structure):
+    """ocsd_pe_context in OpenCSD."""
+    _fields_ = [("_security_level", ct.c_int),
+                ("_exception_level", ct.c_int),
+                ("context_id", ct.c_uint32),
+                ("vmid", ct.c_uint32),
+                ("bits64", ct.c_uint32, 1),
+                ("ctxt_id_valid", ct.c_uint32, 1),
+                ("vmid_valid", ct.c_uint32, 1),
+                ("el_valid", ct.c_uint32, 1)]
+
+    @property
+    def security_level(self) -> SecLevel:
+        return SecLevel(self._security_level)
+
+    @property
+    def exception_level(self) -> ExLevel:
+        return ExLevel(self._exception_level)
+
+
+class TraceEvent(ct.Structure):
+    """trace_event_t in OpenCSD."""
+    _fields_ = [("ev_type", ct.c_uint16),
+                ("ev_number", ct.c_uint16)]
+
+
+class TraceOnReason(Enum):
+    """trace_on_reason_t in OpenCSD."""
+    NORMAL = 0
+    OVERFLOW = 1
+    EX_DEBUG = 2
+
+
+class _SwtInfoInnerStruct(ct.Structure):
+    _fields_ = [("swt_payload_pkt_bitsize", ct.c_uint32, 8),
+                ("swt_payload_num_packets", ct.c_uint32, 8),
+                ("swt_marker_packet", ct.c_uint32, 1),
+                ("swt_has_timestamp", ct.c_uint32, 1),
+                ("swt_marker_first", ct.c_uint32, 1),
+                ("swt_master_err", ct.c_uint32, 1),
+                ("swt_global_err", ct.c_uint32, 1),
+                ("swt_trigger_event", ct.c_uint32, 1),
+                ("swt_frequency", ct.c_uint32, 1),
+                ("swt_id_valid", ct.c_uint32, 1)]
+
+
+class _SwtInfoInnerUnion(ct.Union):
+    _anonymous_ = ("_s",)
+    _fields_ = [("_s", _SwtInfoInnerStruct),
+                ("swt_flag_bits", ct.c_uint32)]
+
+
+class SwtInfo(ct.Structure):
+    """ocsd_swt_info_t in OpenCSD."""
+    _anonymous_ = ("_u",)
+    _fields_ = [("swt_master_id", ct.c_uint16),
+                ("swt_channel_id", ct.c_uint16),
+                ("_u", _SwtInfoInnerUnion)]
+
+
+class UnsyncInfo(Enum):
+    """unsync_info_t in OpenCSD."""
+    UNSYNC_UNKNOWN = 0
+    UNSYNC_INIT_DECODER = 1
+    UNSYNC_RESET_DECODER = 2
+    UNSYNC_OVERFLOW = 3
+    UNSYNC_DISCARD = 4
+    UNSYNC_BAD_PACKET = 5
+    UNSYNC_EOT = 6
+
+
+class TraceSyncMarker(Enum):
+    """trace_sync_marker_t in OpenCSD."""
+    ELEM_MARKER_TS = 0
+
+
+class TraceMarkerPayload(ct.Structure):
+    """trace_marker_payload_t in OpenCSD."""
+    _fields_ = [("_type", ct.c_int),
+                ("value", ct.c_uint32)]
+
+    @property
+    def type(self) -> TraceSyncMarker:
+        return TraceSyncMarker(self._type)
+
+
+class TraceMemtrans(Enum):
+    """trace_memtrans_t in OpenCSD."""
+    MEM_TRANS_TRACE_INIT = 0
+    MEM_TRANS_START = 1
+    MEM_TRANS_COMMIT = 2
+    MEM_TRANS_FAIL = 3
+
+
+class TraceSwIte(ct.Structure):
+    """trace_sw_ite_t in OpenCSD."""
+    _fields_ = [("el", ct.c_uint8),
+                ("value", ct.c_uint64)]
+
+
+class _ElementFlags(ct.Structure):
+    _fields_ = [("last_instr_exec", ct.c_uint32, 1),
+                ("last_instr_sz", ct.c_uint32, 3),
+                ("has_cc", ct.c_uint32, 1),
+                ("cpu_freq_change", ct.c_uint32, 1),
+                ("excep_ret_addr", ct.c_uint32, 1),
+                ("excep_data_marker", ct.c_uint32, 1),
+                ("extended_data", ct.c_uint32, 1),
+                ("has_ts", ct.c_uint32, 1),
+                ("last_instr_cond", ct.c_uint32, 1),
+                ("excep_ret_addr_br_tgt", ct.c_uint32, 1),
+                ("excep_M_tail_chain", ct.c_uint32, 1)]
+
+
+class _ElementFlagsUnion(ct.Union):
+    _anonymous_ = ("_s",)
+    _fields_ = [("_s", _ElementFlags),
+                ("flag_bits", ct.c_uint32)]
+
+
+class _Payload(ct.Union):
+    _fields_ = [("exception_number", ct.c_uint32),
+                ("trace_event", TraceEvent),
+                ("_trace_on_reason", ct.c_int),
+                ("sw_trace_info", SwtInfo),
+                ("num_instr_range", ct.c_uint32),
+                ("_unsync_eot_info", ct.c_int),
+                ("sync_marker", TraceMarkerPayload),
+                ("_mem_trans", ct.c_int),
+                ("sw_ite", TraceSwIte)]
+
+
+class ElemType(Enum):
+    """ocsd_gen_trc_elem_t in OpenCSD."""
+    UNKNOWN = 0
+    NO_SYNC = 1
+    TRACE_ON = 2
+    EO_TRACE = 3
+    PE_CONTEXT = 4
+    INSTR_RANGE = 5
+    I_RANGE_NOPATH = 6
+    ADDR_NACC = 7
+    ADDR_UNKNOWN = 8
+    EXCEPTION = 9
+    EXCEPTION_RET = 10
+    TIMESTAMP = 11
+    CYCLE_COUNT = 12
+    EVENT = 13
+    SWTRACE = 14
+    SYNC_MARKER = 15
+    MEMTRANS = 16
+    INSTRUMENTATION = 17
+    CUSTOM = 18
+
+
+class IsaType(Enum):
+    """ocsd_isa in OpenCSD."""
+    ARM = 0
+    THUMB2 = 1
+    AARCH64 = 2
+    TEE = 3
+    JAZELLE = 4
+    CUSTOM = 5
+    UNKNOWN = 6
+
+
+class InstrType(Enum):
+    """ocsd_instr_type in OpenCSD."""
+    OTHER = 0
+    BR = 1
+    BR_INDIRECT = 2
+    ISB = 3
+    DSB_DMB = 4
+    WFI_WFE = 5
+    TSTART = 6
+
+
+class InstrSubtype(Enum):
+    """ocsd_instr_subtype in OpenCSD."""
+    NONE = 0
+    BR_LINK = 1
+    V8_RET = 2
+    V8_ERET = 3
+    V7_IMPLIED_RET = 4
+
+
+class GenericTraceElement(ct.Structure):
+    """ocsd_generic_trace_elem in OpenCSD."""
+    _anonymous_ = ("_payload", "_flags")
+    _fields_ = [("_elem_type", ct.c_int),
+                ("_isa", ct.c_int),
+                ("st_addr", VADDR_TYPE),
+                ("en_addr", VADDR_TYPE),
+                ("context", PeContext),
+                ("timestamp", ct.c_uint64),
+                ("cycle_count", ct.c_uint32),
+                ("_last_i_type", ct.c_int),
+                ("_last_i_subtype", ct.c_int),
+                ("_flags", _ElementFlagsUnion),
+                ("_payload", _Payload),
+                ("ptr_extended_data", ct.c_void_p)]
+
+    @property
+    def elem_type(self) -> ElemType:
+        return ElemType(self._elem_type)
+
+    @property
+    def isa(self) -> IsaType:
+        return IsaType(self._isa)
+
+    @property
+    def last_i_type(self) -> InstrType:
+        return InstrType(self._last_i_type)
+
+    @property
+    def last_i_subtype(self) -> InstrSubtype:
+        return InstrSubtype(self._last_i_subtype)
+
+    @property
+    def trace_on_reason(self) -> TraceOnReason:
+        # This is from the anonymous structure that is called _Payload in _fields_.
+        return TraceOnReason(self._trace_on_reason)
+
+    @property
+    def unsync_eot_info(self) -> UnsyncInfo:
+        # This is from the anonymous structure that is called _Payload in _fields_.
+        return UnsyncInfo(self._unsync_eot_info)
+
+    @property
+    def mem_trans(self) -> TraceMemtrans:
+        # This is from the anonymous structure that is called _Payload in _fields_.
+        return TraceMemtrans(self._mem_trans)
+
+    def exception_type(self) -> str:
+        """Return the exception type indicated by exception_number."""
+        # The values are taken from the Arm Architecture Reference Manual for A-profile, "D5.3.30
+        # Exception 64-bit Address IS0 Packet". The reasons for generating them are listed in
+        # "D4.4.4 Exceptions to Exception element encoding".
+        names = ["PE Reset", "Debug halt", "Call", "Trap", "System Error", "Unknown",
+                 "Inst debug", "Data debug", "Unknown", "Unknown",
+                 "Alignment", "Inst Fault", "Data Fault", "Unknown",
+                 "IRQ", "FIQ",
+                 "Implementation defined 0", "Implementation defined 1",
+                 "Implementation defined 2", "Implementation defined 3",
+                 "Implementation defined 4", "Implementation defined 5",
+                 "Implementation defined 6", "Implementation defined 7",
+                 "Reserved"]
+        if self.exception_number < len(names):
+            return names[self.exception_number]
+
+        return "Reserved"
diff --git a/simpleperf/scripts/pprof_proto_generator.py b/simpleperf/scripts/pprof_proto_generator.py
index 3a471daa..8ac0faef 100755
--- a/simpleperf/scripts/pprof_proto_generator.py
+++ b/simpleperf/scripts/pprof_proto_generator.py
@@ -589,14 +589,16 @@ class PprofProfileGenerator(object):
             sources = addr2line.get_addr_source(dso, location.vaddr_in_dso)
             if not sources:
                 continue
+
+            orig_function_id = location.lines[0].function_id
+            # Clear default line info.
+            location.lines.clear()
             for i, source in enumerate(sources):
                 source_file, source_line, function_name = source
-                if i == 0:
+                if i == len(sources) - 1:
                     # Don't override original function name from report library, which is more
                     # accurate when proguard mapping file is given.
-                    function_id = location.lines[0].function_id
-                    # Clear default line info.
-                    location.lines.clear()
+                    function_id = orig_function_id
                 else:
                     function_id = self.get_function_id(function_name, dso_name, 0)
                 if function_id == 0:
diff --git a/simpleperf/scripts/report_etm.py b/simpleperf/scripts/report_etm.py
new file mode 100755
index 00000000..a5449ec5
--- /dev/null
+++ b/simpleperf/scripts/report_etm.py
@@ -0,0 +1,220 @@
+#!/usr/bin/env python3
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import argparse
+import functools
+import pathlib
+import subprocess
+import re
+from pathlib import Path
+from typing import Callable, Dict, Optional, Tuple
+
+import etm_types as etm
+from simpleperf_report_lib import ReportLib
+from simpleperf_utils import bytes_to_str, BinaryFinder, EtmContext, log_exit, ReadElf, Objdump, ToolFinder
+
+
+class Tracer:
+    def __init__(self, lib: ReportLib, binary_finder: BinaryFinder, objdump: Objdump) -> None:
+        self.abort = False
+
+        self.last_timestamp: Optional[int] = None
+        self.lost_decoding = False
+
+        self.context = EtmContext()
+
+        self.instructions = 0
+        self.cycles = 0
+
+        self.lib = lib
+        self.binary_finder = binary_finder
+        self.objdump = objdump
+
+        self.disassembly: Dict[str, Dict[int, str]] = {}
+
+    def __call__(self, trace_id: int, elem: etm.GenericTraceElement) -> None:
+        if self.abort:
+            return
+
+        try:
+            self.process(trace_id, elem)
+        except Exception as e:
+            self.abort = True
+            raise e
+
+    def reset_trace(self) -> None:
+        self.context.clear()
+        self.lost_decoding = False
+        self.last_timestamp = None
+
+    def process(self, trace_id: int, elem: etm.GenericTraceElement) -> None:
+        if elem.elem_type == etm.ElemType.TRACE_ON:
+            self.reset_trace()
+            return
+
+        elif elem.elem_type == etm.ElemType.NO_SYNC:
+            print("NO_SYNC: trace is lost, possibly due to overflow.")
+            self.reset_trace()
+            return
+
+        elif elem.elem_type == etm.ElemType.PE_CONTEXT:
+            if self.context.update(elem.context):
+                print("New Context: ", end='')
+                self.context.print()
+                if self.context.tid:
+                    process = self.lib.GetThread(self.context.tid)
+                    if process:
+                        print(f"PID: {process[0]}, TID: {process[1]}, comm: {process[2]}")
+            return
+
+        elif elem.elem_type == etm.ElemType.ADDR_NACC:
+            if not self.lost_decoding:
+                self.lost_decoding = True
+                mapped = self.lib.ConvertETMAddressToVaddrInFile(trace_id, elem.st_addr)
+                if mapped:
+                    print(f'ADDR_NACC: path {mapped[0]} cannot be decoded!')
+                else:
+                    print(f'ADDR_NACC: trace address {hex(elem.st_addr)} is not mapped!')
+            return
+
+        elif elem.elem_type == etm.ElemType.EXCEPTION:
+            print(f'Exception: "{elem.exception_type()}" ({elem.exception_number})!' +
+                  (f" (Excepted return: {hex(elem.en_addr)})" if elem.excep_ret_addr else ""))
+            if elem.exception_number == 3 and elem.excep_ret_addr:
+                # For traps, output the instruction that it trapped on; it is usual to return to a
+                # different address, to skip the trapping instruction.
+                mapped = self.lib.ConvertETMAddressToVaddrInFile(trace_id, elem.en_addr)
+                if mapped:
+                    print("Trapped on:")
+                    start_path, start_offset = mapped
+                    b = str(self.find_binary(start_path))
+                    self.print_disassembly(b, start_offset, start_offset)
+                else:
+                    print(f"Trapped on unmapped address {hex(elem.en_addr)}!")
+            return
+
+        elif elem.elem_type == etm.ElemType.TIMESTAMP:
+            if self.last_timestamp != elem.timestamp:
+                self.last_timestamp = elem.timestamp
+                print(f'Current timestamp: {elem.timestamp}')
+            return
+
+        elif elem.elem_type == etm.ElemType.CYCLE_COUNT and elem.has_cc:
+            print("Cycles: ", elem.cycle_count)
+            self.cycles += elem.cycle_count
+            return
+
+        elif elem.elem_type != etm.ElemType.INSTR_RANGE:
+            return
+
+        self.lost_decoding = False
+        self.instructions += elem.num_instr_range
+        start_path, start_offset = self.lib.ConvertETMAddressToVaddrInFile(
+            trace_id, elem.st_addr) or ("", 0)
+        end_path, end_offset = self.lib.ConvertETMAddressToVaddrInFile(
+            trace_id, elem.en_addr - elem.last_instr_sz) or ("", 0)
+
+        error_messages = []
+        if not start_path:
+            error_messages.append(f"Couldn't determine start path for address {elem.st_addr}!")
+        if not end_path:
+            error_messages.append(
+                f"Couldn't determine start path for address {elem.en_addr - elem.last_instr_sz}!")
+        if error_messages:
+            raise RuntimeError(' '.join(error_messages))
+
+        if start_path == '[kernel.kallsyms]':
+            start_path = 'vmlinux'
+
+        cpu = (trace_id - 0x10) // 2
+        print(f'CPU{cpu} {start_path}: {hex(start_offset)} -> {hex(end_offset)}')
+        b = str(self.find_binary(start_path))
+        self.print_disassembly(b, start_offset, end_offset)
+        if not elem.last_instr_cond and not elem.last_instr_exec:
+            raise RuntimeError(f'Wrong binary! Unconditional branch at {hex(end_offset)}'
+                               f' in {start_path} was not taken!')
+
+    @functools.lru_cache
+    def find_binary(self, path: str) -> Optional[Path]:
+        # binary_finder.find_binary opens the binary to check if it is an ELF, and runs readelf on
+        # it to ensure that the build ids match. This is too much to do in our hot loop, therefore
+        # its result should be cached.
+        buildid = self.lib.GetBuildIdForPath(path)
+        return self.binary_finder.find_binary(path, buildid)
+
+    def print_disassembly(self, path: str, start: int, end: int) -> None:
+        disassembly = self.disassemble(path)
+        if not disassembly:
+            log_exit(f"Failed to disassemble '{path}'!")
+
+        for i in range(start, end + 4, 4):
+            print(disassembly[i])
+
+    def disassemble(self, path: str) -> Dict[int, str]:
+        if path in self.disassembly:
+            return self.disassembly[path]
+
+        dso_info = self.objdump.get_dso_info(path, None)
+        self.disassembly[path] = self.objdump.disassemble_whole(dso_info)
+        return self.disassembly[path]
+
+
+def get_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(description='Generate instruction trace from ETM data.')
+    parser.add_argument('-i', '--record_file', nargs=1, default=['perf.data'], help="""
+                        Set profiling data file to process.""")
+    parser.add_argument('--binary_cache', nargs=1, default=["binary_cache"], help="""
+                        Set path to the binary cache.""")
+    parser.add_argument('--ndk_path', nargs=1, help='Find tools in the ndk path.')
+    return parser.parse_args()
+
+
+def main() -> None:
+    args = get_args()
+
+    binary_cache_path = args.binary_cache[0]
+    if not pathlib.Path(binary_cache_path).is_dir():
+        log_exit(f"Binary cache '{binary_cache_path}' is not a directory!")
+        return
+
+    ndk_path = args.ndk_path[0] if args.ndk_path else None
+
+    lib = ReportLib()
+    try:
+        lib.SetRecordFile(args.record_file[0])
+        lib.SetSymfs(binary_cache_path)
+        lib.SetLogSeverity('error')
+
+        binary_finder = BinaryFinder(binary_cache_path, ReadElf(ndk_path))
+        objdump = Objdump(ndk_path, binary_finder)
+
+        callback = Tracer(lib, binary_finder, objdump)
+
+        lib.SetETMCallback(callback)
+        while not callback.abort and lib.GetNextSample():
+            pass
+
+        if callback.cycles:
+            print("Total cycles:", callback.cycles)
+        print("Total decoded instructions:", callback.instructions)
+
+    finally:
+        lib.Close()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/simpleperf/scripts/report_fuchsia.py b/simpleperf/scripts/report_fuchsia.py
new file mode 100755
index 00000000..2646c8a1
--- /dev/null
+++ b/simpleperf/scripts/report_fuchsia.py
@@ -0,0 +1,647 @@
+#!/usr/bin/env python3
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import argparse
+import pathlib
+import subprocess
+from bisect import bisect
+from collections import deque
+from dataclasses import dataclass
+from itertools import chain
+from math import ceil
+from typing import BinaryIO, Callable, Deque, Dict, List, Optional, Tuple
+
+import etm_types as etm
+from simpleperf_report_lib import ReportLib
+from simpleperf_utils import bytes_to_str, BinaryFinder, EtmContext, log_exit, ReadElf, Objdump, ToolFinder
+
+
+class TraceWriter:
+    """A writer for the Fuchsia trace format:
+       https://fuchsia.dev/fuchsia-src/reference/tracing/trace-format
+    """
+
+    def __init__(self, output: BinaryIO):
+        self.output = output
+
+        # The following dictionaries are for keeping track of the fuchsia records already made, to
+        # use them as references. They map the "value" of the record to their index that can be used
+        # as the reference.
+
+        # Strings are strings.
+        self.strings: Dict[str, int] = {}
+        # Providers are just strings.
+        self.providers: Dict[str, int] = {}
+        # Kernel objects are a type and a name.
+        self.kernel_objects: Dict[Tuple[int, str], int] = {}
+        # Threads are made of two kernel object ids, the first is for the process, the second for
+        # the thread.
+        self.threads: Dict[Tuple[int, int], int] = {}
+
+    def _write_bits(self, desc: List[Tuple[int, int, int]]) -> None:
+        v = 0
+        for (start, end, value) in desc:
+            old_value = value
+            # Check if the value fits into its field.
+            value &= (1 << (end+1)) - 1
+            assert old_value == value
+            v |= value << start
+        self.output.write(v.to_bytes(8, 'little'))
+
+    def _write_padded(self, array: bytearray) -> None:
+        pad = 8 - (len(array) % 8)
+        if pad == 8:
+            pad = 0
+
+        self.output.write(array)
+        self.output.write(bytearray(pad))
+
+    def magic(self) -> None:
+        self._write_bits([(0, 3, 0),
+                          (4, 15, 1),
+                          (16, 19, 4),
+                          (20, 23, 0),
+                          (24, 55, 0x16547846),
+                          (56, 63, 0)])
+
+    def switch_provider(self, name: str) -> None:
+        if name not in self.providers:
+            n = bytearray(name, 'utf-8')
+            length = ceil(len(n) / 8)
+            provider_id = len(self.providers)
+            self._write_bits([(0, 3, 0),
+                              (4, 15, 1 + length),
+                              (20, 51, provider_id),
+                              (52, 59, len(n)),
+                              (60, 63, 0)])
+            self._write_padded(n)
+            self.providers[name] = provider_id
+
+        provider_id = self.providers[name]
+        self._write_bits([(0, 3, 0),
+                          (4, 15, 1),
+                          (16, 19, 2),
+                          (20, 51, provider_id),
+                          (52, 63, 0)])
+
+    def encode_string(self, value: str) -> int:
+        if value in self.strings:
+            return self.strings[value]
+
+        if len(self.strings) >= 0x7fff - 1:
+            raise RuntimeError("Ran out of space in the string table!")
+
+        n = bytearray(value, 'utf-8')
+        length = ceil(len(n) / 8)
+        string_id = len(self.strings) + 1
+        self._write_bits([(0, 3, 2),
+                          (4, 15, 1 + length),
+                          (16, 30, string_id),
+                          (31, 31, 0),
+                          (32, 46, len(n)),
+                          (47, 47, 0),
+                          (48, 63, 0)])
+        self._write_padded(n)
+        self.strings[value] = string_id
+        return string_id
+
+    def kernel_object(self, kobj_type: int, name: str, process: Optional[int] = None) -> int:
+        if (kobj_type, name) in self.kernel_objects:
+            return self.kernel_objects[(kobj_type, name)]
+
+        name_ref = self.encode_string(name)
+        arg_name = 0
+        if process:
+            arg_name = self.encode_string("process")
+
+        self._write_bits([(0, 3, 7),
+                          (4, 15, 4 if process else 2),
+                          (16, 23, kobj_type),
+                          (24, 39, name_ref),
+                          (40, 43, 1 if process else 0),
+                          (44, 63, 0)])
+
+        koid = len(self.kernel_objects)
+        self._write_bits([(0, 63, koid)])
+
+        if process:
+            self._write_bits([(0, 3, 8),
+                              (4, 15, 2),
+                              (16, 31, arg_name),
+                              (32, 63, 0)])
+            self._write_bits([(0, 63, process)])
+
+        self.kernel_objects[(kobj_type, name)] = koid
+        return koid
+
+    def thread(self, process_koid: int, thread_koid: int) -> int:
+        if (process_koid, thread_koid) in self.threads:
+            return self.threads[(process_koid, thread_koid)]
+
+        thread_index = len(self.threads) + 1
+        self._write_bits([(0, 3, 3),
+                          (4, 15, 3),
+                          (16, 23, thread_index),
+                          (24, 63, 0)])
+        self._write_bits([(0, 63, process_koid)])
+        self._write_bits([(0, 63, thread_koid)])
+        self.threads[(process_koid, thread_koid)] = thread_index
+        return thread_index
+
+    def duration(self, begin: bool, thread: int, category: Optional[str],
+                 name: Optional[str], timestamp: int) -> None:
+        category_ref = self.encode_string(category) if category else 0
+        name_ref = self.encode_string(name) if name else 0
+        self._write_bits([(0, 3, 4),
+                          (4, 15, 2),
+                          (16, 19, 2 if begin else 3),
+                          (20, 23, 0),
+                          (24, 31, thread),
+                          (32, 47, category_ref),
+                          (48, 63, name_ref)])
+        self._write_bits([(0, 63, timestamp)])
+
+
+@dataclass
+class Event:
+    call: bool
+    name: str
+    timestamp: Optional[int]
+
+
+class Stacker:
+    """Stacker tries to keep track of how a thread's stack changes, and uses TraceWriter to
+       generate the corresponding Fuchsia trace.
+    """
+
+    def __init__(self, writer: TraceWriter, thread: int):
+        self.writer = writer
+        self.thread = thread
+        self.stack: List[str] = []
+        self.events: Deque[Event] = deque()
+        self.early_events: List[Event] = []
+        self.waiting: List[Event] = []
+
+        self.reset()
+
+    def reset(self) -> None:
+        self.was_call = False
+        self.was_ret = False
+        self.was_plt = False
+        self.last_symbol: Optional[str] = None
+        self.exception_name: Optional[str] = None
+        self.excepted_return: Optional[int] = None
+        self.first_timestamp: Optional[int] = None
+        self.last_timestamp: Optional[int] = None
+
+    def flush(self) -> None:
+        last = -1
+        for event in chain(self.early_events, self.events):
+            if event.timestamp:
+                assert last <= event.timestamp
+                last = event.timestamp
+                self.writer.duration(event.call, self.thread, None, event.name, event.timestamp)
+
+        self.early_events.clear()
+        self.events.clear()
+        self.events.extend(self.waiting)
+
+    def check_waiting(self, timestamp: Optional[int]) -> None:
+        if not timestamp:
+            return
+
+        if not self.first_timestamp:
+            self.first_timestamp = timestamp
+        self.last_timestamp = timestamp
+
+        for event in self.waiting:
+            event.timestamp = timestamp
+
+        self.waiting.clear()
+
+    def call(self, symbol: str, timestamp: Optional[int], front: bool = False) -> None:
+        event = Event(True, symbol, timestamp)
+
+        if not timestamp:
+            self.waiting.append(event)
+
+        for entry in self.stack:
+            if entry.startswith('Exception: '):
+                raise RuntimeError("New call while an exception is still on the stack!",
+                                   symbol, self.stack)
+
+        if front and self.events and not self.events[0].call:
+            # If the front of the events is a return, and we need to fake a call at the start, the
+            # returns will have to come before the call, otherwise Perfetto can't deal with it.
+            assert(
+                not timestamp or not self.events[0].timestamp or self.events[0].timestamp <=
+                timestamp)
+            while self.events and not self.events[0].call:
+                self.early_events.append(self.events.popleft())
+
+        self.stack.append(symbol)
+        insert = self.events.appendleft if front else self.events.append
+        insert(event)
+
+    def ret(self, symbol: str, timestamp: Optional[int]) -> None:
+        event = Event(False, symbol, timestamp)
+        if not timestamp:
+            self.waiting.append(event)
+
+        if self.stack and self.stack[-1] != symbol:
+            raise RuntimeError('Top of the stack does not match the function being returned from! '
+                               f'Current function: {symbol}, top of the stack: {self.stack[-1]}')
+
+        if self.stack:
+            self.stack.pop()
+        self.events.append(event)
+
+    def lost_stack(self, timestamp: Optional[int]) -> None:
+        self.check_waiting(timestamp)
+
+        for symbol in reversed(self.stack):
+            self.ret(symbol, timestamp)
+        self.stack.clear()
+        self.flush()
+        self.reset()
+
+    def gap(self, timestamp: Optional[int]) -> None:
+        self.last_timestamp = None
+        if self.exception_name:
+            return
+
+        if self.last_symbol and self.last_symbol.endswith('@plt'):
+            self.was_plt = True
+            return
+
+        self.lost_stack(timestamp)
+
+    def timestamp(self, timestamp: Optional[int]) -> None:
+        self.check_waiting(timestamp)
+
+    def exception(self, timestamp: Optional[int],
+                  name: str, excepted_return: Optional[int]) -> None:
+        self.check_waiting(timestamp)
+
+        if self.exception_name:
+            if excepted_return is not None and self.excepted_return == excepted_return:
+                # Same return, mark the end of the previous but carry on:
+                self.ret(self.exception_name, timestamp)
+            else:
+                # Interrupted, but for a different return. This most likely means some trace was
+                # lost. Drop the stack.
+                self.lost_stack(timestamp)
+
+        for e in self.stack:
+            if e.startswith('Exception '):
+                raise RuntimeError("Exception while another exception is already on the stack!",
+                                   name, self.stack)
+
+        self.exception_name = name
+        self.excepted_return = excepted_return
+        self.call(name, timestamp)
+        if timestamp:
+            self.last_timestamp = timestamp
+
+    def instr_range(self, timestamp: Optional[int], start: str, start_addr: int,
+                    end: str, _end_addr: int, isubtype: etm.InstrSubtype) -> None:
+        self.check_waiting(timestamp)
+
+        if self.exception_name:
+            self.ret(self.exception_name, timestamp)
+            self.exception_name = None
+
+            if start_addr != self.excepted_return:
+                # If we are in the same symbol, assume we managed to get back safe and sound.
+                # Otherwise, drop the stack.
+                if not self.stack or self.stack[-1] != start:
+                    self.lost_stack(self.last_timestamp)
+
+        if self.was_plt:
+            self.was_plt = False
+            if len(self.stack) > 1 and self.stack[-2] == start:
+                # When was_plt was set, last_symbol should have been too.
+                assert self.last_symbol
+                self.ret(self.last_symbol, timestamp)
+                self.last_symbol = start
+            else:
+                self.lost_stack(timestamp)
+
+        if self.last_symbol == 'art_quick_do_long_jump' and self.last_symbol != start:
+            # Art's long jump rewinds the stack to a previous state.
+            self.lost_stack(timestamp)
+
+        # check_waiting already set the timestamps, but lost_stack above might have nulled them. Set
+        # them again to make sure everything below can use the timestamps correctly.
+        self.first_timestamp = self.first_timestamp or timestamp
+        self.last_timestamp = timestamp or self.last_timestamp
+
+        if not self.was_call and not self.was_ret and self.last_symbol != start:
+            # If the symbol changed without us detecting a call or a return, we recognize two cases:
+            # if there's a last symbol saved, this was a tail call, and we emit a return and a call.
+            # Otherwise, this is the beginning of a new reconstruction of a stack, and we emit only
+            # the call.
+            if self.last_symbol:
+                # Tail call.
+                self.ret(self.last_symbol, timestamp)
+            self.call(start, timestamp)
+        if self.was_ret and not self.stack:
+            # If we have just returned into a function but the stack is empty, pretend that the
+            # current (new) function has been running since the first known timestamp.
+            self.call(start, self.first_timestamp, front=True)
+        if self.was_call:
+            # If the last instruction of the previous instruction range was a call (branch with
+            # link), emit a call.
+            self.call(start, timestamp)
+        if start != end:
+            # If for some reason the symbol changes inside an instruction range, pretend it was a
+            # tail call, even though this really shouldn't happen.
+            self.ret(start, timestamp)
+            self.call(end, timestamp)
+        if isubtype == etm.InstrSubtype.V8_RET:
+            # If the last instruction of the range is a return, we are returning from the current
+            # symbol.
+            self.ret(end, timestamp)
+
+        self.was_ret = isubtype == etm.InstrSubtype.V8_RET
+        self.was_call = isubtype == etm.InstrSubtype.BR_LINK
+        self.last_symbol = end
+        if timestamp:
+            self.last_timestamp = timestamp
+
+
+class Tracer:
+    def __init__(self, lib: ReportLib, binary_finder: BinaryFinder, readelf: ReadElf,
+                 objdump: Objdump, w: TraceWriter) -> None:
+        self.abort: bool = False
+
+        self.last_timestamp: Optional[int] = None
+        self.lost_decoding: bool = False
+
+        self.context: EtmContext = EtmContext()
+
+        self.lib: ReportLib = lib
+        self.binary_finder: BinaryFinder = binary_finder
+        self.readelf: ReadElf = readelf
+        self.objdump: Objdump = objdump
+
+        self.processes: Dict[int, str] = {}
+
+        self.symbols: Dict[str, Tuple[List[Tuple[int, int, str]], List[int]]] = {}
+        self.symbol_cache: Optional[Tuple[str, Tuple[int, int, str]]] = None
+
+        self.stacks: Dict[int, Stacker] = {}
+        self.w: TraceWriter = w
+        w.magic()
+        w.switch_provider('etm')
+
+        self.s: Optional[Stacker] = None
+
+    def __call__(self, trace_id: int, elem: etm.GenericTraceElement) -> None:
+        if self.abort:
+            return
+
+        try:
+            self.process(trace_id, elem)
+        except Exception as e:
+            self.abort = True
+            self.gap()
+            self.flush()
+            raise e
+
+    def reset_trace(self) -> None:
+        self.context = EtmContext()
+        self.lost_decoding = False
+        self.last_timestamp = None
+
+    def process(self, trace_id: int, elem: etm.GenericTraceElement) -> None:
+        if elem.elem_type == etm.ElemType.TRACE_ON or elem.elem_type == etm.ElemType.NO_SYNC:
+            if self.s:
+                self.s.gap(self.last_timestamp)
+            self.reset_trace()
+            return
+
+        if elem.elem_type == etm.ElemType.PE_CONTEXT:
+            if self.context.update(elem.context):
+                tid = self.context.tid
+                if tid:
+                    process = self.lib.GetThread(tid)
+                    if process:
+                        pid, tid, comm = process
+                    else:
+                        pid = tid
+                        comm = f'Unknown process'
+                else:
+                    pid = -1
+                    tid = -1
+                    comm = 'Unknown process'
+
+                kernel = "" if self.context.ex_level == etm.ExLevel.EL0 else " (kernel)"
+                thread_name = f'{tid} {comm or ""}{kernel}'
+
+                if pid in self.processes:
+                    process_name = self.processes[pid]
+                else:
+                    if pid == tid:
+                        parent_name = comm
+                    else:
+                        t = self.lib.GetThread(pid)
+                        parent_name = t[2] if t else "Unknown process"
+                    process_name = f'{pid} {parent_name or ""}'
+                    self.processes[pid] = process_name
+
+                pobj = self.w.kernel_object(1, process_name)
+                tobj = self.w.kernel_object(2, thread_name, process=pobj)
+                thread = self.w.thread(pobj, tobj)
+                # It is possible that the thread_name changed and we have the old one saved here.
+                # The Fuchsia trace does not seem to have any nice ways to handle changing names,
+                # therefore we are sticking with the first name we saw.
+                if tid not in self.stacks:
+                    self.stacks[tid] = Stacker(self.w, thread)
+
+                self.s = self.stacks[tid]
+            return
+
+        if elem.elem_type == etm.ElemType.TIMESTAMP:
+            if self.last_timestamp != elem.timestamp:
+                self.last_timestamp = elem.timestamp
+                if self.s:
+                    self.s.timestamp(elem.timestamp)
+
+        # For the other elements, a context should have happened before and must have set s.
+        assert self.s
+
+        if elem.elem_type == etm.ElemType.ADDR_NACC:
+            if not self.lost_decoding:
+                self.lost_decoding = True
+                mapped = self.lib.ConvertETMAddressToVaddrInFile(trace_id, elem.st_addr)
+                if mapped:
+                    print(f'ADDR_NACC: path {mapped[0]} cannot be decoded! ({hex(elem.st_addr)})')
+                else:
+                    print(f'ADDR_NACC: trace address {hex(elem.st_addr)} is not mapped!')
+
+                # We have lost trace. Give up on the stack.
+                # print(self.s.stack)
+                # print(self.last_timestamp, self.s.last_timestamp, self.s.waiting)
+                self.s.lost_stack(self.last_timestamp)
+                # print(self.last_timestamp, self.s.last_timestamp, self.s.waiting)
+
+            return
+
+        if elem.elem_type == etm.ElemType.EXCEPTION:
+            name = f'Exception: "{elem.exception_type()}" ({elem.exception_number})!'
+            self.s.exception(self.last_timestamp, name,
+                             elem.en_addr if elem.excep_ret_addr else None)
+            return
+
+        if elem.elem_type != etm.ElemType.INSTR_RANGE:
+            return
+
+        self.lost_decoding = False
+
+        start_path, start_offset = self.lib.ConvertETMAddressToVaddrInFile(
+            trace_id, elem.st_addr) or ("", 0)
+        end_path, end_offset = self.lib.ConvertETMAddressToVaddrInFile(
+            trace_id, elem.en_addr - elem.last_instr_sz) or ("", 0)
+
+        error_messages = []
+        if not start_path:
+            error_messages.append(f"Couldn't determine start path for address {elem.st_addr}!")
+        if not end_path:
+            error_messages.append(
+                f"Couldn't determine start path for address {elem.en_addr - elem.last_instr_sz}!")
+        if error_messages:
+            raise RuntimeError(' '.join(error_messages))
+
+        start = self.get_symbol(start_path, start_offset) or "Unknown"
+        end = self.get_symbol(end_path, end_offset) or "Unknown"
+
+        if not elem.last_instr_cond and not elem.last_instr_exec:
+            buildid = self.lib.GetBuildIdForPath(end_path)
+            raise RuntimeError(f"Wrong binary! Unconditional branch at {hex(end_offset)}"
+                               f" in {end_path} (build id: {buildid}) was not taken!")
+
+        self.s.instr_range(self.last_timestamp,
+                           start, elem.st_addr,
+                           end, elem.en_addr,
+                           elem.last_i_subtype)
+
+    def gap(self) -> None:
+        for stack in self.stacks.values():
+            stack.lost_stack(stack.last_timestamp)
+
+    def flush(self) -> None:
+        for stack in self.stacks.values():
+            stack.flush()
+
+    def get_symbol(self, path: str, offset: int) -> Optional[str]:
+        if (self.symbol_cache and self.symbol_cache[0] == path and
+                (self.symbol_cache[1][0]) <= offset < (self.symbol_cache[1][0] + self.symbol_cache[1][1])):
+            return self.symbol_cache[1][2]
+
+        (symbols, offsets) = self.get_symbols(path)
+        if symbols:
+            i = bisect(offsets, offset)
+            if i:
+                i -= 1
+                if symbols[i][0] <= offset < symbols[i][0] + symbols[i][1]:
+                    self.symbol_cache = (path, symbols[i])
+                    return symbols[i][2]
+
+        return None
+
+    def get_symbols(self, path: str) -> Tuple[List[Tuple[int, int, str]], List[int]]:
+        if path not in self.symbols:
+            s = self.lib.GetSymbols(path)
+
+            if not s:
+                log_exit(f"Can't find symbols for unknown binary '{path}'!")
+                return ([], [])
+
+            # Since other use cases don't care about the PLT, simpleperf represents it only as a
+            # single symbol called '@plt'. If it is present, try to get the actual names by parsing
+            # objdump's output.
+            if s[-1][2] == '@plt':
+                dso_info = self.objdump.get_dso_info(path, self.lib.GetBuildIdForPath(path))
+                plts = self.objdump.get_plt_symbols(dso_info)
+                if plts:
+                    del s[-1]
+                    s.extend(plts)
+
+            self.symbols[path] = (s, [e[0] for e in s])
+
+        return self.symbols[path]
+
+
+def get_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(description='Generate Fuchsia trace from ETM data.')
+    parser.add_argument('-i', '--record_file', nargs=1, default=['perf.data'], help="""
+                        Set profiling data file to process.""")
+    parser.add_argument('--binary_cache', nargs=1, default=["binary_cache"], help="""
+                        Set path to the binary cache.""")
+    parser.add_argument('--ndk_path', nargs=1, help='Find tools in the ndk path.')
+    parser.add_argument('-o', '--output', nargs=1, help="""
+                        Output path for the trace. If not specified, the record file's name is
+                        used, with .fxt appended.""")
+    return parser.parse_args()
+
+
+def main() -> None:
+    args = get_args()
+
+    binary_cache_path = args.binary_cache[0]
+    if not pathlib.Path(binary_cache_path).is_dir():
+        log_exit(f"Binary cache '{binary_cache_path}' is not a directory!")
+        return
+
+    ndk_path = args.ndk_path[0] if args.ndk_path else None
+
+    lib = ReportLib()
+    try:
+        lib.SetRecordFile(args.record_file[0])
+        lib.SetSymfs(binary_cache_path)
+        lib.SetLogSeverity('error')
+
+        readelf = ReadElf(ndk_path)
+        binary_finder = BinaryFinder(binary_cache_path, readelf)
+        objdump = Objdump(ndk_path, binary_finder)
+
+        filename = args.output[0] if args.output else f'{args.record_file[0]}.fxt'
+
+        with open(filename, 'wb') as f:
+            callback = Tracer(lib, binary_finder, readelf, objdump, TraceWriter(f))
+            lib.SetETMCallback(callback)
+            while not callback.abort and lib.GetNextSample():
+                pass
+
+            # Trace has ended, make sure every call has a corresponding return. Use the largest
+            # timestamp and end everything there.
+            last_timestamps = [stacker.last_timestamp for stacker
+                               in callback.stacks.values()
+                               if stacker.last_timestamp]
+            last_timestamp = max(last_timestamps, default=None)
+            for stacker in callback.stacks.values():
+                stacker.last_timestamp = last_timestamp
+            callback.gap()
+            callback.flush()
+
+    finally:
+        lib.Close()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/simpleperf/scripts/simpleperf_report_lib.py b/simpleperf/scripts/simpleperf_report_lib.py
index 95dcbf5e..832bc8bb 100644
--- a/simpleperf/scripts/simpleperf_report_lib.py
+++ b/simpleperf/scripts/simpleperf_report_lib.py
@@ -23,9 +23,10 @@
 import collections
 from collections import namedtuple
 import ctypes as ct
+import etm_types as etm
 from pathlib import Path
 import struct
-from typing import Any, Dict, List, Optional, Union
+from typing import Any, Callable, Dict, List, Optional, Tuple, Union
 
 from simpleperf_utils import (bytes_to_str, get_host_binary_path, is_windows, log_exit,
                               str_to_bytes, ReportLibOptions)
@@ -258,6 +259,22 @@ class FeatureSectionStructure(ct.Structure):
                 ('data_size', ct.c_uint32)]
 
 
+class BuildIdPairStructure(ct.Structure):
+    _fields_ = [("build_id", ct.POINTER(ct.c_char)),
+                ("filename", ct.c_char_p)]
+
+
+class DsoAddress(ct.Structure):
+    _fields_ = [('path', ct.c_char_p),
+                ('offset', ct.c_uint64)]
+
+
+class Thread(ct.Structure):
+    _fields_ = [('pid', ct.c_int),
+                ('tid', ct.c_int),
+                ('comm', ct.c_char_p)]
+
+
 class ReportLibStructure(ct.Structure):
     _fields_ = []
 
@@ -329,12 +346,28 @@ class ReportLib(object):
         self._GetBuildIdForPathFunc.restype = ct.c_char_p
         self._GetFeatureSection = self._lib.GetFeatureSection
         self._GetFeatureSection.restype = ct.POINTER(FeatureSectionStructure)
+        self._GetAllBuildIds = self._lib.GetAllBuildIds
+        self._GetAllBuildIds.restype = ct.POINTER(BuildIdPairStructure)
+        self._ETMCallbackType = ct.CFUNCTYPE(
+            None, ct.c_uint8, ct.POINTER(etm.GenericTraceElement))
+        self._SetETMCallback = self._lib.SetETMCallback
+        self._SetETMCallback.argtypes = [ct.POINTER(ReportLibStructure), self._ETMCallbackType]
+        self._ConvertETMAddressToVaddrInFile = self._lib.ConvertETMAddressToVaddrInFile
+        self._ConvertETMAddressToVaddrInFile.restype = DsoAddress
+        self._ConvertETMAddressToVaddrInFile.argtypes = [
+            ct.POINTER(ReportLibStructure), ct.c_uint8, ct.c_uint64]
+        self._GetThread = self._lib.GetThread
+        self._GetThread.restype = Thread
+        self._GetThread.argtypes = [ct.POINTER(ReportLibStructure), ct.c_int]
+        self._ReadSymbolsForPath = self._lib.ReadSymbolsForPath
+        self._ReadSymbolsForPath.restype = ct.POINTER(SymbolStruct)
         self._instance = self._CreateReportLibFunc()
         assert not _is_null(self._instance)
 
         self.meta_info: Optional[Dict[str, str]] = None
         self.current_sample: Optional[SampleStruct] = None
         self.record_cmd: Optional[str] = None
+        self.callback: Optional[ct._FuncPointer] = None
 
     def _get_native_lib(self) -> str:
         return get_host_binary_path('libsimpleperf_report.so')
@@ -582,6 +615,76 @@ class ReportLib(object):
             raise Exception('Instance is Closed')
         return self._instance
 
+    def GetAllBuildIds(self) -> Dict[str, str]:
+        """Return a dictionary mapping all filenames to their build ids.
+        """
+        ids = self._GetAllBuildIds(self.getInstance())
+        if not ids:
+            return {}
+
+        result = {}
+        i = 0
+        while ids[i].filename:
+            filename = _char_pt_to_str(ids[i].filename)
+            # A build_id is always 20 bytes long.
+            build_id = f"0x{ids[i].build_id[0:20].hex()}"
+            result[filename] = build_id
+            i += 1
+
+        return result
+
+    def SetETMCallback(self, callback: Callable[[int, etm.GenericTraceElement], None]) -> None:
+        """Set the callback to be called while decoding ETM traces. The callback will be called
+           for every element. The callback will receive the following parameters:
+           trace_id: CoreSight Trace ID that identifies the trace source.
+           elem: the decoded element as etm_types.GenericTraceElement.
+        """
+        def inner(trace_id, elem):
+            callback(trace_id, elem.contents)
+
+        # Save the callback, preventing GC from taking it.
+        self.callback = self._ETMCallbackType(inner)
+        self._SetETMCallback(self.getInstance(), self.callback)
+
+    def ConvertETMAddressToVaddrInFile(self, trace_id: int, addr: int) -> Optional[Tuple[str, int]]:
+        """Given the trace id and a virtual address in an ETM trace, return a tuple containing the
+           path to the DSO and the offset inside it. If the address is not mapped, return
+           None.
+        """
+        v = self._ConvertETMAddressToVaddrInFile(self.getInstance(), trace_id, addr)
+        if v.path:
+            path = _char_pt_to_str(v.path)
+            return (path, v.offset)
+        return None
+
+    def GetThread(self, tid: int) -> Optional[Tuple[int, int, str]]:
+        """Return a tuple containing PID, TID and comm for the given TID. If the thread is not found, return
+           None.
+        """
+        r = self._GetThread(self.getInstance(), tid)
+        if r.pid != -1:
+            return (r.pid, r.tid, _char_pt_to_str(r.comm))
+        else:
+            return None
+
+    def GetSymbols(self, path: str) -> Optional[List[Tuple[int, int, str]]]:
+        """Return a list of symbols for path, in the form of tuples of start address,
+           length and name.
+        """
+        symbols = self._ReadSymbolsForPath(self.getInstance(), _char_pt(path))
+        if not symbols:
+            return None
+
+        i = 0
+        result = []
+        while symbols[i]._symbol_name:
+            result.append((symbols[i].symbol_addr,
+                           symbols[i].symbol_len,
+                           symbols[i].symbol_name))
+            i += 1
+
+        return result
+
 
 ProtoSample = namedtuple('ProtoSample', ['ip', 'pid', 'tid',
                          'thread_comm', 'time', 'in_kernel', 'cpu', 'period'])
diff --git a/simpleperf/scripts/simpleperf_utils.py b/simpleperf/scripts/simpleperf_utils.py
index 93cd76d9..c8f1f298 100644
--- a/simpleperf/scripts/simpleperf_utils.py
+++ b/simpleperf/scripts/simpleperf_utils.py
@@ -22,6 +22,7 @@ from __future__ import annotations
 import argparse
 from concurrent.futures import Future, ThreadPoolExecutor
 from dataclasses import dataclass
+import etm_types as etm
 import logging
 import os
 import os.path
@@ -827,6 +828,16 @@ class Objdump(object):
         self.readelf = ReadElf(ndk_path)
         self.objdump_paths: Dict[str, str] = {}
 
+    def _objdump_path(self, arch):
+        objdump_path = self.objdump_paths.get(arch)
+        if not objdump_path:
+            objdump_path = ToolFinder.find_tool_path('llvm-objdump', self.ndk_path, arch)
+            if not objdump_path:
+                log_exit("Can't find llvm-objdump." + NDK_ERROR_MESSAGE)
+            self.objdump_paths[arch] = objdump_path
+
+        return objdump_path
+
     def get_dso_info(self, dso_path: str, expected_build_id: Optional[str]
                      ) -> Optional[Tuple[str, str]]:
         real_path = self.binary_finder.find_binary(dso_path, expected_build_id)
@@ -837,17 +848,35 @@ class Objdump(object):
             return None
         return (str(real_path), arch)
 
+    def disassemble_whole(self, dso_info) -> Dict[int, str]:
+        """Disassemble all code in a binary, returning a dictionary mapping
+           addresses to assembly output.
+        """
+        real_path, arch = dso_info
+        objdump_path = self._objdump_path(arch)
+
+        disassembly = {}
+        try:
+            raw_output = subprocess.check_output([objdump_path, '-d', '--demangle', real_path])
+            output = bytes_to_str(raw_output)
+            for line in output.split('\n'):
+                match = re.match(r'^\s*([0-9A-Fa-f]+):', line)
+                if not match:
+                    continue
+                addr = int(match.group(1), 16)
+                disassembly[addr] = line
+
+        except subprocess.CalledProcessError:
+            pass
+
+        return disassembly
+
     def disassemble_function(self, dso_info, addr_range: AddrRange) -> Optional[Disassembly]:
         """ Disassemble code for an addr range in a binary.
         """
         real_path, arch = dso_info
-        objdump_path = self.objdump_paths.get(arch)
-        if not objdump_path:
-            objdump_path = ToolFinder.find_tool_path('llvm-objdump', self.ndk_path, arch)
-            if not objdump_path:
-                log_exit("Can't find llvm-objdump." + NDK_ERROR_MESSAGE)
-            self.objdump_paths[arch] = objdump_path
 
+        objdump_path = self._objdump_path(arch)
         # Run objdump.
         args = [objdump_path, '-dlC', '--no-show-raw-insn',
                 '--start-address=0x%x' % addr_range.start,
@@ -884,12 +913,7 @@ class Objdump(object):
         if not sorted_addr_ranges:
             return []
         real_path, arch = dso_info
-        objdump_path = self.objdump_paths.get(arch)
-        if not objdump_path:
-            objdump_path = ToolFinder.find_tool_path('llvm-objdump', self.ndk_path, arch)
-            if not objdump_path:
-                log_exit("Can't find llvm-objdump." + NDK_ERROR_MESSAGE)
-            self.objdump_paths[arch] = objdump_path
+        objdump_path = self._objdump_path(arch)
 
         # Run objdump.
         start_addr = sorted_addr_ranges[0].start
@@ -948,6 +972,43 @@ class Objdump(object):
         except ValueError:
             return 0
 
+    def get_plt_symbols(self, dso_info) -> List[Tuple[int, int, str]]:
+        """Get the symbols of sorted list of (start, length, name) tuples."""
+        # This uses objdump to get the names of the PLT stubs since nothing else seems to be capable
+        # of figuring them out.
+        real_path, arch = dso_info
+        objdump_path = self._objdump_path(arch)
+
+        symbols = []
+        try:
+            raw_output = subprocess.check_output([objdump_path,
+                                                  '-d', '--section=.plt', real_path])
+            output = bytes_to_str(raw_output)
+            name = None
+            start = None
+            last = None
+            for line in output.split('\n'):
+                if line.endswith('@plt>:'):
+                    (start, name) = line.split()
+                    name = name[1:-2]
+                    last = start
+                if start:
+                    if line == '':
+                        if start is not None and last is not None and name:
+                            symbols.append((int(start, 16),
+                                            int(last, 16) - int(start, 16) + 4, name))
+                        name = None
+                        start = None
+                        last = None
+                    else:
+                        last = line.split()[0][:-1]
+
+        except subprocess.CalledProcessError:
+            pass
+
+        symbols.sort(key=lambda e: e[0])
+        return symbols
+
 
 class ReadElf(object):
     """ A wrapper of readelf. """
@@ -1242,3 +1303,58 @@ class BaseArgumentParser(argparse.ArgumentParser):
         if not Log.initialized:
             Log.init(namespace.log)
         return namespace, left_args
+
+
+class EtmContext:
+    """Represents a context in ETM traces. It can be updated with the context field of a
+       GenericTraceElement with elem_type PE_CONTEXT.
+    """
+
+    def __init__(self) -> None:
+        self.valid = False
+        self.sec_level: etm.SecLevel = etm.SecLevel.SECURE
+        self.ex_level: etm.ExLevel = etm.ExLevel.EL3
+        self.bits64: bool = False
+        self.context_id: Optional[int] = None
+        self.vmid: Optional[int] = None
+        self.tid: Optional[int] = None
+
+    def clear(self) -> None:
+        self.valid = False
+        self.context_id = None
+        self.vmid = None
+        self.tid = None
+
+    def update(self, context: etm.PeContext) -> bool:
+        self.valid = True
+        changed = self.sec_level == context.security_level
+        self.sec_level = context.security_level
+
+        if context.el_valid and self.ex_level != context.exception_level:
+            changed = True
+            self.ex_level = context.exception_level
+        if context.ctxt_id_valid and self.context_id != context.context_id:
+            changed = True
+            self.context_id = context.context_id
+        if context.vmid_valid and self.vmid != context.vmid:
+            changed = True
+            self.vmid = context.vmid
+
+        if changed:
+            if self.context_id is not None:
+                self.tid = self.context_id
+            else:
+                self.tid = self.vmid
+
+        old_bits = self.bits64
+        self.bits64 = context.bits64 != 0
+        return changed or old_bits != self.bits64
+
+    def print(self) -> None:
+        if not self.valid:
+            print('Invalid context!')
+            return
+
+        print(f'{self.ex_level.name} ({self.sec_level.name})'
+              f' {"64" if self.bits64 else "32"}-bit'
+              f' ctid: {self.context_id} vmid: {self.vmid}')
diff --git a/simpleperf/scripts/test/app_profiler_test.py b/simpleperf/scripts/test/app_profiler_test.py
index 99982f5f..02606730 100644
--- a/simpleperf/scripts/test/app_profiler_test.py
+++ b/simpleperf/scripts/test/app_profiler_test.py
@@ -85,7 +85,7 @@ class TestNativeLibDownloader(TestBase):
         # Sync all native libs on device.
         downloader = NativeLibDownloader(self.ndk_path, 'arm64', self.adb)
         downloader.collect_native_libs_on_host(TestHelper.testdata_path(
-            'SimpleperfExampleCpp/app/build/intermediates/cmake/debug'))
+            'SimpleperfExampleCpp/app/build/intermediates'))
         self.assertEqual(len(downloader.host_build_id_map), 2)
         for entry in downloader.host_build_id_map.values():
             self.assertEqual(entry.score, 3)
diff --git a/simpleperf/scripts/test/app_test.py b/simpleperf/scripts/test/app_test.py
index 2c6835d3..fe1056c5 100644
--- a/simpleperf/scripts/test/app_test.py
+++ b/simpleperf/scripts/test/app_test.py
@@ -42,7 +42,7 @@ class TestExampleBase(TestBase):
         cls.apk_path = apk_files[0]
         cls.package_name = package_name
         cls.activity_name = activity_name
-        args = ["install", "-r"]
+        args = ["install", "-r", "-t"]
         if abi:
             args += ["--abi", abi]
         args.append(cls.apk_path)
diff --git a/simpleperf/scripts/test/do_test.py b/simpleperf/scripts/test/do_test.py
index d341c20b..e05420a8 100755
--- a/simpleperf/scripts/test/do_test.py
+++ b/simpleperf/scripts/test/do_test.py
@@ -49,6 +49,7 @@ from . app_test import *
 from . binary_cache_builder_test import *
 from . cpp_app_test import *
 from . debug_unwind_reporter_test import *
+from . etm_stack_test import *
 from . gecko_profile_generator_test import *
 from . inferno_test import *
 from . java_app_test import *
@@ -129,6 +130,7 @@ def get_test_type(test: str) -> Optional[str]:
     if testcase_name in ('TestAnnotate',
                          'TestBinaryCacheBuilder',
                          'TestDebugUnwindReporter',
+                         'TestEtmStacker',
                          'TestInferno',
                          'TestPprofProtoGenerator',
                          'TestProtoFileReportLib',
diff --git a/simpleperf/scripts/test/etm_stack_test.py b/simpleperf/scripts/test/etm_stack_test.py
new file mode 100644
index 00000000..e01cc506
--- /dev/null
+++ b/simpleperf/scripts/test/etm_stack_test.py
@@ -0,0 +1,329 @@
+#!/usr/bin/env python3
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+
+from report_fuchsia import Stacker
+from etm_types import InstrSubtype
+from . test_utils import TestBase
+
+
+class Result:
+    def __init__(self):
+        self.events = []
+
+    def duration(self, begin, thread, category, name, timestamp):
+        self.events.append(('call' if begin else 'ret', name, timestamp))
+
+
+class TestEtmStacker(TestBase):
+    def setUp(self):
+        super().setUp()
+        self.r = Result()
+        self.s = Stacker(self.r, 0)
+
+    def assertResult(self, sequence):
+        self.s.flush()
+        self.assertEqual(self.r.events, sequence)
+
+    # Primitives.
+    def test_primitives_call(self):
+        self.s.call('main', 1)
+        self.assertResult([('call', 'main', 1)])
+
+    def test_primitives_ret(self):
+        self.s.call('main', 1)
+        self.s.ret('main', 2)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 2)])
+
+    def test_primitives_no_timestamp(self):
+        self.s.call('main', None)
+        self.s.ret('main', None)
+        self.assertResult([])
+
+    # Simple stacks.
+    def test_simple_start(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 1)])
+
+    def test_simple_return(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 1)])
+
+    def test_simple_inner(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'inner', 0, 'inner', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('call', 'inner', 2), ('ret', 'inner', 2)])
+
+    def test_simple_recursion(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.s.instr_range(3, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('call', 'main', 2),
+                           ('ret', 'main', 2), ('ret', 'main', 3)])
+
+    def test_simple_tailcall(self):
+        # If not a return or a call, the jump is considered a tail call.
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.instr_range(2, 'next', 0, 'next', 0, None)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 2), ('call', 'next', 2)])
+
+    def test_simple_tailcall_single(self):
+        # If the symbol is different between the start and the end, it changed without a jump.
+        # Pretend that it is a tail-call.
+        self.s.instr_range(1, 'main', 0, 'next', 0, None)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 1), ('call', 'next', 1)])
+
+    def test_simple_no_call(self):
+        # If execution returns below the known stack, pretend that we have known about the function
+        # running since the first known timestamp.
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.instr_range(2, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.s.instr_range(3, 'next', 0, 'next', 0, None)
+        self.assertResult([('call', 'next', 1),
+                           ('call', 'main', 1), ('ret', 'main', 2)])
+
+    # Delayed events (i.e., no timestamps).
+    def test_delay_later(self):
+        self.s.instr_range(None, 'main', 0, 'main', 0, None)
+        self.s.timestamp(1)
+        self.assertResult([('call', 'main', 1)])
+
+    def test_delay_later_ret(self):
+        self.s.instr_range(None, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.s.timestamp(1)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 1)])
+
+    def test_delay_inner(self):
+        self.s.instr_range(None, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'inner', 0, 'inner', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 2), ('call', 'inner', 2), ('ret', 'inner', 2)])
+
+    def test_delay_no_call(self):
+        self.s.instr_range(None, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.s.instr_range(2, 'next', 0, 'next', 0, None)
+        self.assertResult([('call', 'next', 2),
+                           ('call', 'main', 2), ('ret', 'main', 2)])
+
+    # Gaps.
+    def test_gaps_gap(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.gap(2)
+        self.s.instr_range(3, 'next', 0, 'next', 0, None)
+        self.assertResult([('call', 'main', 1), ('ret', 'main', 2),
+                           ('call', 'next', 3)])
+
+    def test_gaps_exception_start(self):
+        self.s.exception(1, 'exception', 0)
+        self.assertResult([('call', 'exception', 1)])
+
+    def test_gaps_exception_twice(self):
+        self.s.exception(1, 'exception', 0)
+        self.s.gap(2)
+        self.s.exception(2, 'another', 0)
+        self.assertResult([('call', 'exception', 1), ('ret', 'exception', 2),
+                           ('call', 'another', 2)])
+
+    def test_gaps_exception_ret(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 1)
+        self.s.gap(2)
+        self.s.instr_range(3, 'main', 1, 'main', 1, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3), ('ret', 'main', 3)])
+
+    def test_gaps_exception_ret_twice(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 1)
+        self.s.gap(2)
+        self.s.exception(3, 'another', 1)
+        self.s.gap(3)
+        self.s.instr_range(4, 'main', 1, 'main', 1, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3), ('call', 'another', 3),
+                           ('ret', 'another', 4), ('ret', 'main', 4)])
+
+    def test_gaps_exception_ret_bad(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 100)
+        self.s.gap(2)
+        self.s.instr_range(3, 'next', 1, 'next', 1, None)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3), ('ret', 'main', 3),
+                           ('call', 'next', 3)])
+
+    def test_gaps_exception_ret_twice_bad(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 1)
+        self.s.gap(2)
+        self.s.exception(3, 'another', 2)
+        self.s.gap(3)
+        self.s.instr_range(4, 'next', 3, 'next', 3, None)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3), ('ret', 'main', 3),
+                           ('call', 'another', 3), ('ret', 'another', 4), ('call', 'next', 4)])
+
+    def test_gaps_exception_call_preserved(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.exception(2, 'exception', 1)
+        self.s.gap(2)
+        self.s.instr_range(3, 'next', 1, 'next', 2, None)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3), ('call', 'next', 3)])
+
+    def test_gaps_exception_ret_preserved(self):
+        # The actual ret is not preserved, but the starting point of elements below the known stack
+        # should be.
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.s.exception(2, 'exception', 1)
+        self.s.gap(2)
+        self.s.instr_range(3, 'next', 1, 'next', 2, None)
+        self.assertResult([('call', 'next', 1),
+                           ('call', 'main', 1), ('ret', 'main', 1),
+                           ('call', 'exception', 2), ('ret', 'exception', 3)])
+
+    def test_gaps_plt(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'func@plt', 0, 'func@plt', 0, None)
+        self.s.gap(3)
+        self.s.instr_range(4, 'main', 0, 'main', 0, None)
+        self.s.instr_range(5, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('call', 'func@plt', 2),
+                           ('ret', 'func@plt', 4), ('ret', 'main', 5)])
+
+    def test_gaps_plt_wrong(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'func@plt', 0, 'func@plt', 0, None)
+        self.s.gap(3)
+        self.s.instr_range(4, 'next', 0, 'next', 0, None)
+        self.assertResult([('call', 'main', 1), ('call', 'func@plt', 2),
+                           ('ret', 'func@plt', 4), ('ret', 'main', 4),
+                           ('call', 'next', 4)])
+
+    def test_gaps_danger(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 100)
+        self.s.gap(2)
+        self.s.instr_range(3, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3), ('ret', 'main', 3)])
+
+    # Stack was lost.
+    def test_lost_lost(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'next', 0, 'next', 0, None)
+        self.s.lost_stack(3)
+        self.assertResult([('call', 'main', 1), ('call', 'next', 2),
+                           ('ret', 'next', 3), ('ret', 'main', 3)])
+
+    def test_lost_ordering(self):
+        self.s.exception(1, 'exception', 0)
+        self.s.gap(None)
+        self.s.lost_stack(None)
+        self.s.timestamp(2)
+        self.assertResult([('call', 'exception', 1), ('ret', 'exception', 2)])
+
+    def test_lost_assumption(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 0)
+        self.s.gap(2)
+        self.s.instr_range(3, 'main', 0, 'main', 0, None)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 2),
+                           ('ret', 'exception', 3)])
+
+    def test_lost_late(self):
+        self.s.instr_range(None, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.exception(None, 'exception', 0)
+        self.s.gap(None)
+        self.s.instr_range(1, 'next', 0, 'next', 0, None)
+        self.assertResult([('call', 'main', 1), ('call', 'exception', 1), ('ret', 'exception', 1),
+                           ('call', 'next', 1)])
+
+    # Timestamps.
+    def test_timestamps_updates(self):
+        self.s.timestamp(10)
+        self.assertEqual(self.s.last_timestamp, 10)
+
+    def test_timestamps_gap_removes(self):
+        self.s.timestamp(10)
+        self.s.gap(11)
+        self.assertEqual(self.s.last_timestamp, None)
+
+    def test_timestamps_gap_removes_exception(self):
+        self.s.timestamp(10)
+        self.s.exception(10, "exception", 0)
+        self.s.gap(10)
+        self.assertEqual(self.s.last_timestamp, None)
+
+    def test_timestamps_gap_removes_plt(self):
+        self.s.instr_range(1, 'foo@plt', 0, 'foo@plt', 0, None)
+        self.s.gap(10)
+        self.assertEqual(self.s.last_timestamp, None)
+
+    def test_timestamps_gap_again(self):
+        self.s.timestamp(10)
+        self.s.gap(11)
+        self.s.timestamp(11)
+        self.assertEqual(self.s.last_timestamp, 11)
+
+    def test_timestamps_first(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.instr_range(2, 'main', 0, 'main', 0, None)
+        self.assertEqual(self.s.first_timestamp, 1)
+        self.assertEqual(self.s.last_timestamp, 2)
+
+    def test_timestamps_first_gap(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.gap(10)
+        self.s.instr_range(11, 'main', 0, 'main', 0, None)
+        self.assertEqual(self.s.first_timestamp, 11)
+
+    def test_timestamps_first_exception_good(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 100)
+        self.s.gap(10)
+        self.s.instr_range(11, 'main', 100, 'main', 100, None)
+        self.assertEqual(self.s.first_timestamp, 1)
+
+    def test_timestamps_first_exception_bad(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, None)
+        self.s.exception(2, 'exception', 100)
+        self.s.gap(10)
+        self.s.instr_range(11, 'next', 200, 'next', 200, None)
+        self.assertEqual(self.s.first_timestamp, 11)
+
+    def test_timestamps_first_plt_good(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'foo@plt', 0, 'foo@plt', 0, None)
+        self.s.gap(10)
+        self.s.instr_range(11, 'main', 200, 'main', 200, None)
+        self.assertEqual(self.s.first_timestamp, 1)
+
+    def test_timestamps_first_plt_bad(self):
+        self.s.instr_range(1, 'main', 0, 'main', 0, InstrSubtype.BR_LINK)
+        self.s.instr_range(2, 'foo@plt', 0, 'foo@plt', 0, None)
+        self.s.gap(10)
+        self.s.instr_range(11, 'next', 200, 'next', 200, None)
+        self.assertEqual(self.s.first_timestamp, 11)
+
+    def test_timestamps_exception_fake_start(self):
+        self.s.exception(1, 'exception', 100)
+        self.s.lost_stack(None)
+        self.s.instr_range(None, 'main', 0, 'main', 0, InstrSubtype.V8_RET)
+        self.s.instr_range(2, 'deep', 0, 'deep', 0, None)
+        self.assertResult([('call', 'exception', 1), ('ret', 'exception', 2),
+                           ('call', 'deep', 2), ('call', 'main', 2), ('ret', 'main', 2)])
diff --git a/simpleperf/scripts/test/pprof_proto_generator_test.py b/simpleperf/scripts/test/pprof_proto_generator_test.py
index a1f43458..883fcc6b 100644
--- a/simpleperf/scripts/test/pprof_proto_generator_test.py
+++ b/simpleperf/scripts/test/pprof_proto_generator_test.py
@@ -253,6 +253,41 @@ class TestPprofProtoGenerator(TestBase):
         source_filename = generator.get_string(function.source_filename_id)
         self.assertIn('two_functions.cpp', source_filename)
 
+    def test_inlined_function_names(self):
+        """ Test that we are getting correct function callstacks for inlined functions.
+        """
+        testdata_file = TestHelper.testdata_path("runtest_two_functions_arm64_inlined.data")
+        # Build binary_cache.
+        binary_cache_builder = BinaryCacheBuilder(TestHelper.ndk_path, False)
+        binary_cache_builder.build_binary_cache(testdata_file, [TestHelper.testdata_dir])
+
+        # Generate profile.
+        profile = self.generate_profile(None, [testdata_file])
+
+        CheckItem = namedtuple('CheckItem', ['func_name1', 'line1', 'func_name2', 'line2'])
+
+        check_items = {
+            0x40c8: CheckItem('Function1()', 9, 'main', 22),
+            0x40dc: CheckItem('Function2()', 16, 'main', 23),
+        }
+        results = {}
+
+        for location in profile.location:
+            mapping = profile.mapping[location.mapping_id - 1]
+            addr = location.address - mapping.memory_start + mapping.file_offset
+            if check_item := check_items.get(addr):
+                self.assertEqual(len(location.line), 2)
+                function1 = profile.function[location.line[0].function_id - 1]
+                line1 = location.line[0].line
+                function2 = profile.function[location.line[1].function_id - 1]
+                line2 = location.line[1].line
+                self.assertEqual(profile.string_table[function1.name], check_item.func_name1)
+                self.assertEqual(line1, check_item.line1)
+                self.assertEqual(profile.string_table[function2.name], check_item.func_name2)
+                self.assertEqual(line2, check_item.line2)
+                results[addr] = True
+        self.assertEqual(len(results), len(check_items))
+
     def test_comments(self):
         profile = self.generate_profile(None, ['perf_with_interpreter_frames.data'])
         comments = "\n".join([profile.string_table[i] for i in profile.comment])
diff --git a/simpleperf/scripts/test/report_lib_test.py b/simpleperf/scripts/test/report_lib_test.py
index bde19165..89a6680b 100644
--- a/simpleperf/scripts/test/report_lib_test.py
+++ b/simpleperf/scripts/test/report_lib_test.py
@@ -407,6 +407,27 @@ class TestReportLib(TestBase):
             process_name = self.report_lib.GetProcessNameOfCurrentSample()
             self.assertEqual(process_name, expected_process_name)
 
+    def test_all_build_ids(self):
+        """Test if it is possible to collect all binaries with build ids."""
+        record_file = TestHelper.testdata_path("runtest_two_functions_arm64_perf.data")
+        self.report_lib.SetRecordFile(record_file)
+        self.assertEqual(
+            self.report_lib.GetAllBuildIds(),
+            {'/apex/com.android.runtime/lib64/bionic/libc.so':
+             '0x43dd431c97ac668afc7e90ace442d58400000000',
+             '/data/local/tmp/simpleperf_runtest_two_functions_arm64':
+             '0xb4f1b49b0fe9e34e78fb14e5374c930c00000000'}
+        )
+
+    def test_symbols(self):
+        record_file = TestHelper.testdata_path("runtest_two_functions_arm64_perf.data")
+        self.report_lib.SetRecordFile(record_file)
+        self.assertEqual(set(self.report_lib.GetSymbols("/data/local/tmp/simpleperf_runtest_two_functions_arm64")),
+                         set([(4172, 112, 'Function1()'),
+                              (4284, 112, 'Function2()'),
+                              (4396, 28, 'main')]))
+        self.assertEqual(self.report_lib.GetSymbols("/nonexistent_file.so"), None)
+
 
 class TestProtoFileReportLib(TestBase):
     def test_smoke(self):
diff --git a/simpleperf/scripts/test/script_testdata/cpp_api-debuggable.apk b/simpleperf/scripts/test/script_testdata/cpp_api-debuggable.apk
index e86ba697..0acb4adf 100644
Binary files a/simpleperf/scripts/test/script_testdata/cpp_api-debuggable.apk and b/simpleperf/scripts/test/script_testdata/cpp_api-debuggable.apk differ
diff --git a/simpleperf/scripts/test/script_testdata/cpp_api-profileable.apk b/simpleperf/scripts/test/script_testdata/cpp_api-profileable.apk
index 9aa469f7..79414a9d 100644
Binary files a/simpleperf/scripts/test/script_testdata/cpp_api-profileable.apk and b/simpleperf/scripts/test/script_testdata/cpp_api-profileable.apk differ
diff --git a/simpleperf/scripts/test/script_testdata/java_api-debuggable.apk b/simpleperf/scripts/test/script_testdata/java_api-debuggable.apk
index 2827350a..b5c161ce 100644
Binary files a/simpleperf/scripts/test/script_testdata/java_api-debuggable.apk and b/simpleperf/scripts/test/script_testdata/java_api-debuggable.apk differ
diff --git a/simpleperf/scripts/test/script_testdata/java_api-profileable.apk b/simpleperf/scripts/test/script_testdata/java_api-profileable.apk
index 53798bc0..0c5b738e 100644
Binary files a/simpleperf/scripts/test/script_testdata/java_api-profileable.apk and b/simpleperf/scripts/test/script_testdata/java_api-profileable.apk differ
diff --git a/simpleperf/scripts/test/script_testdata/runtest_two_functions_arm64_inlined.data b/simpleperf/scripts/test/script_testdata/runtest_two_functions_arm64_inlined.data
new file mode 100644
index 00000000..03400ece
Binary files /dev/null and b/simpleperf/scripts/test/script_testdata/runtest_two_functions_arm64_inlined.data differ
diff --git a/simpleperf/scripts/test/script_testdata/simpleperf_runtest_two_functions_arm64_inlined b/simpleperf/scripts/test/script_testdata/simpleperf_runtest_two_functions_arm64_inlined
new file mode 100755
index 00000000..cb256cc3
Binary files /dev/null and b/simpleperf/scripts/test/script_testdata/simpleperf_runtest_two_functions_arm64_inlined differ
diff --git a/simpleperf/scripts/test/tools_test.py b/simpleperf/scripts/test/tools_test.py
index 2d572301..7dffa0ee 100644
--- a/simpleperf/scripts/test/tools_test.py
+++ b/simpleperf/scripts/test/tools_test.py
@@ -334,6 +334,22 @@ ffffffc0089bbb34:      	stp	x29, x30, [sp, #-0x30]!
             ('  200004:      	stp	x20, x19, [sp, #0x10]', 0x200004),
             ('', 0)])
 
+    def test_objdump_whole(self):
+        binary_finder = BinaryFinder(TestHelper.testdata_dir, ReadElf(TestHelper.ndk_path))
+        objdump = Objdump(TestHelper.ndk_path, binary_finder)
+        dso_info = objdump.get_dso_info("/simpleperf_runtest_two_functions_arm64", None)
+        disassembly = objdump.disassemble_whole(dso_info)
+        self.assertEqual(len(disassembly), 98)
+        self.assertEqual(disassembly[4492], '    118c: d61f0220     \tbr\tx17')
+
+    def test_objdump_plt(self):
+        binary_finder = BinaryFinder(TestHelper.testdata_dir, ReadElf(TestHelper.ndk_path))
+        objdump = Objdump(TestHelper.ndk_path, binary_finder)
+        dso_info = objdump.get_dso_info("/simpleperf_runtest_two_functions_arm64", None)
+        symbols = objdump.get_plt_symbols(dso_info)
+        self.assertEqual(len(symbols), 2)
+        self.assertEqual(symbols, [(4464, 16, '__libc_init@plt'), (4480, 16, 'atoi@plt')])
+
     def test_readelf(self):
         test_map = {
             'simpleperf_runtest_two_functions_arm64': {
diff --git a/simpleperf/test_util.h b/simpleperf/test_util.h
index 4264c9a3..94a570d7 100644
--- a/simpleperf/test_util.h
+++ b/simpleperf/test_util.h
@@ -108,6 +108,14 @@ bool HasTracepointEvents();
     }                                                                                         \
   } while (0)
 
+#define TEST_REQUIRE_KERNEL_EVENTS()                                                           \
+  do {                                                                                         \
+    if (!IsKernelEventSupported()) {                                                           \
+      GTEST_LOG_(INFO) << "Skip this test as the test environment can't count kernel events."; \
+      return;                                                                                  \
+    }                                                                                          \
+  } while (0)
+
 #if defined(IN_CTS_TEST)
 #define TEST_REQUIRE_APPS()
 #else
diff --git a/simpleperf/testdata/base.dex b/simpleperf/testdata/base.dex
new file mode 100644
index 00000000..1864c29b
Binary files /dev/null and b/simpleperf/testdata/base.dex differ
diff --git a/simpleperf/testdata/base.vdex b/simpleperf/testdata/base.vdex
deleted file mode 100644
index b0ea0184..00000000
Binary files a/simpleperf/testdata/base.vdex and /dev/null differ
diff --git a/simpleperf/thread_tree.cpp b/simpleperf/thread_tree.cpp
index 4a17ee05..dde562f8 100644
--- a/simpleperf/thread_tree.cpp
+++ b/simpleperf/thread_tree.cpp
@@ -202,6 +202,14 @@ void ThreadTree::AddThreadMapsForDsoSymbols(ThreadEntry* thread, Dso* dso) {
   }
 }
 
+Dso* ThreadTree::FindUserDso(const std::string& filename) {
+  auto it = user_dso_tree_.find(filename);
+  if (it == user_dso_tree_.end()) {
+    return nullptr;
+  }
+  return it->second.get();
+}
+
 Dso* ThreadTree::FindUserDsoOrNew(const std::string& filename, uint64_t start_addr,
                                   DsoType dso_type) {
   auto it = user_dso_tree_.find(filename);
diff --git a/simpleperf/thread_tree.h b/simpleperf/thread_tree.h
index a502a239..2cdff1ed 100644
--- a/simpleperf/thread_tree.h
+++ b/simpleperf/thread_tree.h
@@ -140,6 +140,7 @@ class ThreadTree {
   void Update(const Record& record);
 
   std::vector<Dso*> GetAllDsos() const;
+  Dso* FindUserDso(const std::string& filename);
   Dso* FindUserDsoOrNew(const std::string& filename, uint64_t start_addr = 0,
                         DsoType dso_type = DSO_ELF_FILE);
 
diff --git a/simpleperf/workload.cpp b/simpleperf/workload.cpp
index 92c6537b..d34d6fc0 100644
--- a/simpleperf/workload.cpp
+++ b/simpleperf/workload.cpp
@@ -87,6 +87,17 @@ Workload::~Workload() {
   }
 }
 
+std::string Workload::GetCommandName() {
+  if (child_proc_args_.empty()) {
+    return "";
+  }
+  std::string name = child_proc_args_[0];
+  if (auto split_pos = name.rfind('/'); split_pos != std::string::npos) {
+    name = name.substr(split_pos + 1);
+  }
+  return name;
+}
+
 bool Workload::CreateNewProcess() {
   CHECK_EQ(work_state_, NotYetCreateNewProcess);
 
diff --git a/simpleperf/workload.h b/simpleperf/workload.h
index 86b28924..b6dfcc8c 100644
--- a/simpleperf/workload.h
+++ b/simpleperf/workload.h
@@ -47,6 +47,7 @@ class Workload {
   bool Start();
   bool IsStarted() { return work_state_ == Started; }
   pid_t GetPid() { return work_pid_; }
+  std::string GetCommandName();
 
   bool WaitChildProcess(bool wait_forever, int* exit_code);
 
diff --git a/torq/Android.bp b/torq/Android.bp
index e3245df1..6546f0f0 100644
--- a/torq/Android.bp
+++ b/torq/Android.bp
@@ -20,21 +20,13 @@ package {
 python_defaults {
     name: "torq_defaults",
     srcs: [
-        "torq.py",
-        "command.py",
-        "command_executor.py",
-        "validation_error.py",
-        "device.py",
-        "config_builder.py",
-        "open_ui.py",
-        "utils.py",
-        "validate_simpleperf.py",
+        "src/**/*.py",
     ],
 }
 
 python_binary_host {
     name: "torq",
-    main: "torq.py",
+    main: "src/torq.py",
     defaults: ["torq_defaults"],
 }
 
@@ -43,12 +35,7 @@ python_test_host {
     main: "tests/torq_unit_test.py",
     srcs: ["tests/torq_unit_test.py"],
     defaults: ["torq_defaults"],
-    version: {
-        py3: {
-            enabled: true,
-            embedded_launcher: false,
-        },
-    },
+    embedded_launcher: false,
     test_options: {
         unit_test: true,
     },
@@ -59,12 +46,7 @@ python_test_host {
     main: "tests/device_unit_test.py",
     srcs: ["tests/device_unit_test.py"],
     defaults: ["torq_defaults"],
-    version: {
-        py3: {
-            enabled: true,
-            embedded_launcher: false,
-        },
-    },
+    embedded_launcher: false,
     test_options: {
         unit_test: true,
     },
@@ -75,28 +57,18 @@ python_test_host {
     main: "tests/config_builder_unit_test.py",
     srcs: ["tests/config_builder_unit_test.py"],
     defaults: ["torq_defaults"],
-    version: {
-        py3: {
-            enabled: true,
-            embedded_launcher: false,
-        },
-    },
+    embedded_launcher: false,
     test_options: {
         unit_test: true,
     },
 }
 
 python_test_host {
-    name: "command_executor_unit_test",
-    main: "tests/command_executor_unit_test.py",
-    srcs: ["tests/command_executor_unit_test.py"],
+    name: "perfetto_command_executor_unit_test",
+    main: "tests/perfetto_command_executor_unit_test.py",
+    srcs: ["tests/perfetto_command_executor_unit_test.py"],
     defaults: ["torq_defaults"],
-    version: {
-        py3: {
-            enabled: true,
-            embedded_launcher: false,
-        },
-    },
+    embedded_launcher: false,
     test_options: {
         unit_test: true,
     },
@@ -107,12 +79,29 @@ python_test_host {
     main: "tests/validate_simpleperf_unit_test.py",
     srcs: ["tests/validate_simpleperf_unit_test.py"],
     defaults: ["torq_defaults"],
-    version: {
-        py3: {
-            enabled: true,
-            embedded_launcher: false,
-        },
+    embedded_launcher: false,
+    test_options: {
+        unit_test: true,
     },
+}
+
+python_test_host {
+    name: "utils_unit_test",
+    main: "tests/utils_unit_test.py",
+    srcs: ["tests/utils_unit_test.py"],
+    defaults: ["torq_defaults"],
+    embedded_launcher: false,
+    test_options: {
+        unit_test: true,
+    },
+}
+
+python_test_host {
+    name: "open_ui_unit_test",
+    main: "tests/open_ui_unit_test.py",
+    srcs: ["tests/open_ui_unit_test.py"],
+    defaults: ["torq_defaults"],
+    embedded_launcher: false,
     test_options: {
         unit_test: true,
     },
diff --git a/torq/README.md b/torq/README.md
index 128669fd..6acb3618 100644
--- a/torq/README.md
+++ b/torq/README.md
@@ -63,31 +63,53 @@ config.
 config, in which the ftrace event, power/cpu_idle, is not collected.
 
 
-## CLI Arguments
-
-| Argument                                | Description                                                                                                                                                                                                                                                                        | Currently Supported Arguments                                                                | Default                              |
-|-----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|--------------------------------------|
-| `-e, --event`                           | The event to trace/profile.                                                                                                                                                                                                                                                        | `boot`, `user-switch`,`app-startup`, `custom`                                                | `custom`                             |
-| `-p, --profiler`                        | The performance data profiler.                                                                                                                                                                                                                                                     | `perfetto`, (`simpleperf` coming soon)                                                       | `perfetto`                           |
-| `-o, --out-dir`                         | The path to the output directory.                                                                                                                                                                                                                                                  | Any local path                                                                               | Current directory: `.`               |
-| `-d, --dur-ms`                          | The duration (ms) of the event. Determines when to stop collecting performance data.                                                                                                                                                                                               | Float >= `3000`                                                                              | `10000`                              |
-| `-a, --app`                             | The package name of the app to start.<br/>(Requires use of `-e app-startup`)                                                                                                                                                                                                       | Any package on connected device                                                              |                                      |
-| `-r, --runs`                            | The amount of times to run the event and capture the performance data.                                                                                                                                                                                                             | Integer >= `1`                                                                               | `1`                                  |
-| `--serial`                              | The serial of the connected device that you want to use.<br/>(If not provided, the ANDROID_SERIAL environment variable is used. If ANDROID_SERIAL is also not set and there is only one device connected, the device is chosen.)                                                   |                                                                                              |                                      |
-| `--perfetto-config`                     | The local file path of the user's Perfetto config or used to specify a predefined Perfetto configs.                                                                                                                                                                                | `default`, any local perfetto config,<br/>(`lightweight`, `memory` coming soon)              | `default`                            |
-| `--between-dur-ms`                      | The amount of time (ms) to wait between different runs.<br/>(Requires that `--r` is set to a value greater than 1)                                                                                                                                                                 | Float >= `3000`                                                                              | `10000`                              |
-| `--ui`                                  | Specifies opening of UI visualization tool after profiling is complete.<br/>(Requires that `-r` is not set to a value greater than 1)                                                                                                                                              | `--ui`, `--no-ui`,                                                                           | `ui` if `runs` is `1`                |
-| `--exclude-ftrace-event`                | Excludes the ftrace event from the Perfetto config. Can be defined multiple times in a command.<br/>(Requires use of `-p perfetto`)<br/>(Currently only works with `--perfetto-config default`,<br/>support for local Perfetto configs, `lightweight`, and `memory` coming soon)   | Any supported perfetto ftrace event<br/>(e.g., `power/cpu_idle`, `sched/sched_process_exit`) | Empty list                           |
-| `--include-ftrace-event`                | Includes the ftrace event in the Perfetto config. Can be defined multiple times in a command.<br/>(Requires use of `-p perfetto`)<br/>(Currently only works with `--perfetto-config default`,<br/>support for any local Perfetto configs, `lightweight`, and `memory` coming soon) | Any supported perfetto ftrace event<br/>(e.g., `power/cpu_idle`, `sched/sched_process_exit`) | Empty list                           |
-| `--from-user`                           | The user ID from which to start the user switch. (Requires use of `-e user-switch`)                                                                                                                                                                                                | ID of any user on connected device                                                           | Current user on the device           |
-| `--to-user`                             | The user ID of user that device is switching to. (Requires use of `-e user-switch`).                                                                                                                                                                                               | ID of any user on connected device                                                           |                                      |
-| `config list`                           | Subcommand to list the predefined Perfetto configs (`default`, `lightweight`, `memory`).                                                                                                                                                                                           |                                                                                              |                                      |
-| `config show <config-name>`             | Subcommand to print the contents of a predefined Perfetto config to the terminal.                                                                                                                                                                                                  | `default`, `lightweight`, `memory`                                                           |                                      |
-| `config pull <config-name> [file-path]` | Subcommand to download a predefined Perfetto config to a specified local file path.                                                                                                                                                                                                | <config-name>: `default`, `lightweight`, `memory`<br/> [file-path]: Any local file path      | [file-path]: `./<config-name>.pbtxt` |
-| `open <file-path>`                      | Subcommand to open a Perfetto or Simpleperf trace in the Perfetto UI.                                                                                                                                                                                                              | Any local path to a Perfetto or Simpleperf trace file                                        |                                      |
-
-## Functionality Coming Soon
-
-| Argument                                | Description                                                                                                                                                   | Accepted Values                                                                         | Default                               |
-|-----------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|---------------------------------------|
-| `-s, --simpleperf-event`                | Simpleperf supported events that should be collected. Can be defined multiple times in a command.                                                             | Any supported simpleperf event<br/>(e.g., `cpu-cycles`, `instructions`)                 | Empty list                            |
+## Main CLI Arguments
+
+| Argument                                   | Description                                                                                                                                                                                                                                                                        | Currently Supported Arguments                                                                | Default                              |
+|--------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|--------------------------------------|
+| `-e, --event`                              | The event to trace/profile.                                                                                                                                                                                                                                                        | `boot`, `user-switch`,`app-startup`, `custom`                                                | `custom`                             |
+| `-p, --profiler`                           | The performance data profiler.                                                                                                                                                                                                                                                     | `perfetto`, (`simpleperf` coming soon)                                                       | `perfetto`                           |
+| `-o, --out-dir`                            | The path to the output directory.                                                                                                                                                                                                                                                  | Any local path                                                                               | Current directory: `.`               |
+| `-d, --dur-ms`                             | The duration (ms) of the event. Determines when to stop collecting performance data.                                                                                                                                                                                               | Float >= `3000`                                                                              | `10000`                              |
+| `-a, --app`                                | The package name of the app to start.<br/>(Requires use of `-e app-startup`)                                                                                                                                                                                                       | Any package on connected device                                                              |                                      |
+| `-r, --runs`                               | The amount of times to run the event and capture the performance data.                                                                                                                                                                                                             | Integer >= `1`                                                                               | `1`                                  |
+| `-s, --simpleperf-event`                   | Simpleperf supported events that should be collected. Can be defined multiple times in a command. (Requires use of `-p simpleperf`).                                                                                                                                               | Any supported simpleperf event<br/>(e.g., `cpu-cycles`, `instructions`)                      | `cpu-clock`                          |
+| `--serial`                                 | The serial of the connected device that you want to use.<br/>(If not provided, the ANDROID_SERIAL environment variable is used. If ANDROID_SERIAL is also not set and there is only one device connected, the device is chosen.)                                                   |                                                                                              |                                      |
+| `--perfetto-config`                        | The local file path of the user's Perfetto config or used to specify a predefined Perfetto configs.                                                                                                                                                                                | `default`, any local perfetto config,<br/>(`lightweight`, `memory` coming soon)              | `default`                            |
+| `--between-dur-ms`                         | The amount of time (ms) to wait between different runs.<br/>(Requires that `--r` is set to a value greater than 1)                                                                                                                                                                 | Float >= `3000`                                                                              | `10000`                              |
+| `--ui`                                     | Specifies opening of UI visualization tool after profiling is complete.<br/>(Requires that `-r` is not set to a value greater than 1)                                                                                                                                              | `--ui`, `--no-ui`,                                                                           | `ui` if `runs` is `1`                |
+| `--exclude-ftrace-event`                   | Excludes the ftrace event from the Perfetto config. Can be defined multiple times in a command.<br/>(Requires use of `-p perfetto`)<br/>(Currently only works with `--perfetto-config default`,<br/>support for local Perfetto configs, `lightweight`, and `memory` coming soon)   | Any supported perfetto ftrace event<br/>(e.g., `power/cpu_idle`, `sched/sched_process_exit`) | Empty list                           |
+| `--include-ftrace-event`                   | Includes the ftrace event in the Perfetto config. Can be defined multiple times in a command.<br/>(Requires use of `-p perfetto`)<br/>(Currently only works with `--perfetto-config default`,<br/>support for any local Perfetto configs, `lightweight`, and `memory` coming soon) | Any supported perfetto ftrace event<br/>(e.g., `power/cpu_idle`, `sched/sched_process_exit`) | Empty list                           |
+| `--from-user`                              | The user ID from which to start the user switch. (Requires use of `-e user-switch`)                                                                                                                                                                                                | ID of any user on connected device                                                           | Current user on the device           |
+| `--to-user`                                | The user ID of user that device is switching to. (Requires use of `-e user-switch`).                                                                                                                                                                                               | ID of any user on connected device                                                           |                                      |
+| `--symbols`                                | The device symbols library. (Requires use of `-p simpleperf`).                                                                                                                                                                                                                     | Path to a device symbols library                                                             |                                      |
+| `config list`                              | Subcommand to list the predefined Perfetto configs (`default`, `lightweight`, `memory`).                                                                                                                                                                                           |                                                                                              |                                      |
+| `config show <config-name>`                | Subcommand to print the contents of a predefined Perfetto config to the terminal.                                                                                                                                                                                                  | `default`, `lightweight`, `memory`                                                           |                                      |
+| `config pull <config-name> [file-path]`    | Subcommand to download a predefined Perfetto config to a specified local file path.                                                                                                                                                                                                | <config-name>: `default`, `lightweight`, `memory`<br/> [file-path]: Any local file path      | [file-path]: `./<config-name>.pbtxt` |
+| `open <file-path> [--use_trace_processor]` | Subcommand to open a Perfetto or Simpleperf trace in the Perfetto UI. --use_trace_processor specifies that the trace should be opened with the trace_processor binary regardless of its size.                                                                                      | Any local path to a Perfetto or Simpleperf trace file                                        | [--use_trace_processor]: false       |
+
+## Configure perfetto in virtualized Android
+
+Working on a multi-VM environments has its challenges. In order to obtain a unified trace
+containing the trace data from multiple VMs you could leverage Perfetto's *traced* and *traced_relay*
+binaries. Torq provides commands to greatly simplify the configuration process.
+
+For example, to switch a VM from using `traced` to `traced_relay`, you could run:
+```console
+torq vm traced-relay enable vsock://3:30001
+```
+To enable the relay producer port in `traced`, you could run:
+```console
+torq vm relay-producer enable
+```
+
+### CLI Arguments
+
+These are the arguments for the `torq vm` CLI subcommand.
+
+| Argument | Description | Currently Supported Arguments | Default |
+|----------|-------------|-------------------------------|---------|
+| `traced-relay enable <socket-address>` | Enables traced_relay and uses the *<socket-address>* as the relay socket to communicate with the central traced VM. |    |    |
+| `traced-relay disable` | Disables traced_relay and switches to traced. |    |    |
+| `relay-producer enable [--address <relay_producer_socket>]` | Enables traced's relay producer support. The `--address` specifies the relay producer socket to use. |    | --address: `vsock://-1:30001`  |
+| `relay-producer disable` | Disables traced's relay producer support. |    |    |
diff --git a/torq/open_ui.py b/torq/open_ui.py
deleted file mode 100644
index f0bbc082..00000000
--- a/torq/open_ui.py
+++ /dev/null
@@ -1,60 +0,0 @@
-#
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# Implementation taken from external/perfetto/tools/record_android_trace.
-#
-
-import webbrowser
-import socketserver
-import http.server
-import os
-
-
-class HttpHandler(http.server.SimpleHTTPRequestHandler):
-
-  def end_headers(self):
-    self.send_header("Access-Control-Allow-Origin", self.server.allow_origin)
-    self.send_header("Cache-Control", "no-cache")
-    super().end_headers()
-
-  def do_GET(self):
-    if self.path != "/" + self.server.expected_fname:
-      self.send_error(404, "File not found")
-      return
-    self.server.fname_get_completed = True
-    super().do_GET()
-
-  def do_POST(self):
-    self.send_error(404, "File not found")
-
-  def log_message(self, format, *args):
-    pass
-
-
-def open_trace(path, origin):
-  PORT = 9001
-  path = os.path.abspath(path)
-  os.chdir(os.path.dirname(path))
-  fname = os.path.basename(path)
-  socketserver.TCPServer.allow_reuse_address = True
-  with socketserver.TCPServer(("127.0.0.1", PORT), HttpHandler) as httpd:
-    address = (f"{origin}/#!/?url=http://127.0.0.1:"
-               f"{PORT}/{fname}&referrer=open_trace_in_ui")
-    webbrowser.open_new_tab(address)
-    httpd.expected_fname = fname
-    httpd.fname_get_completed = None
-    httpd.allow_origin = origin
-    while httpd.fname_get_completed is None:
-      httpd.handle_request()
diff --git a/torq/src/__init__.py b/torq/src/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/torq/command.py b/torq/src/command.py
similarity index 93%
rename from torq/command.py
rename to torq/src/command.py
index a2a72620..699fd2da 100644
--- a/torq/command.py
+++ b/torq/src/command.py
@@ -15,11 +15,11 @@
 #
 
 from abc import ABC, abstractmethod
-from command_executor import ProfilerCommandExecutor, \
+from .command_executor import ProfilerCommandExecutor, \
   UserSwitchCommandExecutor, BootCommandExecutor, AppStartupCommandExecutor, \
   ConfigCommandExecutor, WEB_UI_ADDRESS
-from validation_error import ValidationError
-from open_ui import open_trace
+from .validation_error import ValidationError
+from .open_ui import open_trace
 
 ANDROID_SDK_VERSION_T = 33
 
@@ -48,7 +48,8 @@ class ProfilerCommand(Command):
   """
   def __init__(self, type, event, profiler, out_dir, dur_ms, app, runs,
       simpleperf_event, perfetto_config, between_dur_ms, ui,
-      excluded_ftrace_events, included_ftrace_events, from_user, to_user):
+      excluded_ftrace_events, included_ftrace_events, from_user, to_user,
+      scripts_path, symbols):
     super().__init__(type)
     self.event = event
     self.profiler = profiler
@@ -64,6 +65,8 @@ class ProfilerCommand(Command):
     self.included_ftrace_events = included_ftrace_events
     self.from_user = from_user
     self.to_user = to_user
+    self.scripts_path = scripts_path
+    self.symbols = symbols
     match event:
       case "custom":
         self.command_executor = ProfilerCommandExecutor()
@@ -159,12 +162,13 @@ class OpenCommand(Command):
   """
   Represents commands which open traces.
   """
-  def __init__(self, file_path):
+  def __init__(self, file_path, use_trace_processor):
     super().__init__(type)
     self.file_path = file_path
+    self.use_trace_processor = use_trace_processor
 
   def validate(self, device):
     raise NotImplementedError
 
   def execute(self, device):
-    open_trace(self.file_path, WEB_UI_ADDRESS)
+    return open_trace(self.file_path, WEB_UI_ADDRESS, self.use_trace_processor)
diff --git a/torq/command_executor.py b/torq/src/command_executor.py
similarity index 82%
rename from torq/command_executor.py
rename to torq/src/command_executor.py
index 20ce3a44..5993cac6 100644
--- a/torq/command_executor.py
+++ b/torq/src/command_executor.py
@@ -18,9 +18,10 @@ import datetime
 import subprocess
 import time
 from abc import ABC, abstractmethod
-from config_builder import PREDEFINED_PERFETTO_CONFIGS, build_custom_config
-from open_ui import open_trace
-from device import SIMPLEPERF_TRACE_FILE
+from .config_builder import PREDEFINED_PERFETTO_CONFIGS, build_custom_config
+from .open_ui import open_trace
+from .device import SIMPLEPERF_TRACE_FILE
+from .utils import convert_simpleperf_to_gecko
 
 PERFETTO_TRACE_FILE = "/data/misc/perfetto-traces/trace.perfetto-trace"
 PERFETTO_BOOT_TRACE_FILE = "/data/misc/perfetto-traces/boottrace.perfetto-trace"
@@ -61,20 +62,23 @@ class ProfilerCommandExecutor(CommandExecutor):
     error = self.prepare_device(command, device, config)
     if error is not None:
       return error
-    host_file = None
+    host_raw_trace_filename = None
+    host_gecko_trace_filename = None
     for run in range(1, command.runs + 1):
       timestamp = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
       if command.profiler == "perfetto":
-        host_file = f"{command.out_dir}/trace-{timestamp}.perfetto-trace"
+        host_raw_trace_filename = f"{command.out_dir}/trace-{timestamp}.perfetto-trace"
       else:
-        host_file = f"{command.out_dir}/perf-{timestamp}.data"
+        host_raw_trace_filename = f"{command.out_dir}/perf-{timestamp}.data"
+        host_gecko_trace_filename = f"{command.out_dir}/perf-{timestamp}.json"
       error = self.prepare_device_for_run(command, device)
       if error is not None:
         return error
       error = self.execute_run(command, device, config, run)
       if error is not None:
         return error
-      error = self.retrieve_perf_data(command, device, host_file)
+      error = self.retrieve_perf_data(command, device, host_raw_trace_filename,
+                                      host_gecko_trace_filename)
       if error is not None:
         return error
       if command.runs != run:
@@ -83,7 +87,11 @@ class ProfilerCommandExecutor(CommandExecutor):
     if error is not None:
       return error
     if command.use_ui:
-      open_trace(host_file, WEB_UI_ADDRESS)
+        error = open_trace(host_raw_trace_filename
+                           if command.profiler == "perfetto" else
+                           host_gecko_trace_filename, WEB_UI_ADDRESS, False)
+        if error is not None:
+          return error
     return None
 
   @staticmethod
@@ -119,11 +127,14 @@ class ProfilerCommandExecutor(CommandExecutor):
   def trigger_system_event(self, command, device):
     return None
 
-  def retrieve_perf_data(self, command, device, host_file):
+  def retrieve_perf_data(self, command, device, host_raw_trace_filename,
+      host_gecko_trace_filename):
     if command.profiler == "perfetto":
-      device.pull_file(PERFETTO_TRACE_FILE, host_file)
+      device.pull_file(PERFETTO_TRACE_FILE, host_raw_trace_filename)
     else:
-      device.pull_file(SIMPLEPERF_TRACE_FILE, host_file)
+      device.pull_file(SIMPLEPERF_TRACE_FILE, host_raw_trace_filename)
+      convert_simpleperf_to_gecko(command.scripts_path, host_raw_trace_filename,
+                                  host_gecko_trace_filename, command.symbols)
 
   def cleanup(self, command, device):
     return None
@@ -181,8 +192,9 @@ class BootCommandExecutor(ProfilerCommandExecutor):
   def trigger_system_event(self, command, device):
     device.reboot()
 
-  def retrieve_perf_data(self, command, device, host_file):
-    device.pull_file(PERFETTO_BOOT_TRACE_FILE, host_file)
+  def retrieve_perf_data(self, command, device, host_raw_trace_filename,
+      host_gecko_trace_filename):
+    device.pull_file(PERFETTO_BOOT_TRACE_FILE, host_raw_trace_filename)
 
 
 class AppStartupCommandExecutor(ProfilerCommandExecutor):
diff --git a/torq/config_builder.py b/torq/src/config_builder.py
similarity index 99%
rename from torq/config_builder.py
rename to torq/src/config_builder.py
index fab42d6a..5a004a7d 100644
--- a/torq/config_builder.py
+++ b/torq/src/config_builder.py
@@ -15,7 +15,7 @@
 #
 
 import textwrap
-from validation_error import ValidationError
+from .validation_error import ValidationError
 
 ANDROID_SDK_VERSION_T = 33
 
diff --git a/torq/device.py b/torq/src/device.py
similarity index 85%
rename from torq/device.py
rename to torq/src/device.py
index 323c3001..f4c51d87 100644
--- a/torq/device.py
+++ b/torq/src/device.py
@@ -17,9 +17,10 @@
 import math
 import os
 import subprocess
+import sys
 import time
-
-from validation_error import ValidationError
+from .handle_input import HandleInput
+from .validation_error import ValidationError
 
 ADB_ROOT_TIMED_OUT_LIMIT_SECS = 5
 ADB_BOOT_COMPLETED_TIMED_OUT_LIMIT_SECS = 30
@@ -72,11 +73,29 @@ class AdbDevice:
     elif len(devices) == 1:
       self.serial = devices[0]
     else:
-      return ValidationError(("There is more than one device currently"
-                              " connected."),
-                             ("Run one of the following commands to choose one"
-                              " of the connected devices:\n\t torq --serial %s"
-                              % "\n\t torq --serial ".join(devices)))
+      options = ""
+      choices = {}
+      for i, device in enumerate(devices):
+        options += ("%d: torq --serial %s %s\n\t"
+                    % (i, device, " ".join(sys.argv[1:])))
+        # Lambdas are bound to local scope, so assign var d to prevent
+        # future values of device from overriding the current value we want
+        choices[str(i)] = lambda d=device: d
+      # Remove last \t
+      options = options[:-1]
+      chosen_serial = (HandleInput("There is more than one device currently "
+                                  "connected. Press the corresponding number "
+                                  "for the following options to choose the "
+                                  "device you want to use.\n\t%sSelect "
+                                  "device[0-%d]: "
+                                  % (options, len(devices) - 1),
+                                  "Please select a valid option.",
+                                  choices)
+                       .handle_input())
+      if isinstance(chosen_serial, ValidationError):
+        return chosen_serial
+      print("Using device with serial %s" % chosen_serial)
+      self.serial = chosen_serial
     return None
 
   @staticmethod
@@ -110,8 +129,8 @@ class AdbDevice:
   def start_simpleperf_trace(self, command):
     events_param = "-e " + ",".join(command.simpleperf_event)
     return subprocess.Popen(("adb -s %s shell simpleperf record -a -f 1000 "
-                             "--post-unwind=yes -m 8192 -g --duration %d"
-                             " %s -o %s"
+                             "--exclude-perf --post-unwind=yes -m 8192 -g "
+                             "--duration %d %s -o %s"
                              % (self.serial,
                                 int(math.ceil(command.dur_ms/1000)),
                                 events_param, SIMPLEPERF_TRACE_FILE)),
@@ -153,6 +172,9 @@ class AdbDevice:
   def set_prop(self, prop, value):
     subprocess.run(["adb", "-s", self.serial, "shell", "setprop", prop, value])
 
+  def clear_prop(self, prop):
+    subprocess.run(["adb", "-s", self.serial, "shell", "setprop", prop, "\"\""])
+
   def reboot(self):
     subprocess.run(["adb", "-s", self.serial, "reboot"])
     if not self.poll_is_task_completed(ADB_ROOT_TIMED_OUT_LIMIT_SECS,
@@ -229,6 +251,9 @@ class AdbDevice:
                             capture_output=True)
 
     if output is None or len(output.stdout) == 0:
+      if "not found" in output.stderr.decode("utf-8"):
+        return ValidationError("Simpleperf was not found in the device",
+                               "Push the simpleperf binary to the device")
       raise Exception("Error while validating simpleperf events.")
     lines = output.stdout.decode("utf-8").split("\n")
 
diff --git a/torq/src/handle_input.py b/torq/src/handle_input.py
new file mode 100644
index 00000000..0e772cb1
--- /dev/null
+++ b/torq/src/handle_input.py
@@ -0,0 +1,55 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+from .validation_error import ValidationError
+
+class HandleInput:
+  """Class that requests input from the user with a message and then calls a
+  callback based on the user's input, or gives an error if no valid input was
+  given
+
+  Attributes:
+    input_msg: A string containing a message that is displayed when requesting user input
+    fail_suggestion: A string containing a suggestion displayed when the user exceeds max attempts
+    choices: A dictionary mapping possible user inputs (key) to functions (value)
+    default_choice: A default choice from the choices dictionary if the user inputs nothing.
+  """
+  def __init__(self, input_msg, fail_suggestion, choices,
+      default_choice = None):
+    self.input_msg = input_msg
+    self.fail_suggestion = fail_suggestion
+    self.choices = choices
+    self.max_attempts = 3
+    if default_choice is not None and default_choice not in choices:
+      raise Exception("Default choice is not in choices dictionary.")
+    self.default_choice = default_choice
+
+  def handle_input(self):
+    i = 0
+    while i < self.max_attempts:
+      response = input(self.input_msg).lower()
+
+      if response == "" and self.default_choice is not None:
+        return self.choices[self.default_choice]()
+      elif response in self.choices:
+        return self.choices[response]()
+
+      i += 1
+      if i < self.max_attempts:
+        print("Invalid input. Please try again.")
+
+    return ValidationError("Invalid inputs.",
+                           self.fail_suggestion)
diff --git a/torq/src/open_ui.py b/torq/src/open_ui.py
new file mode 100644
index 00000000..d80bc169
--- /dev/null
+++ b/torq/src/open_ui.py
@@ -0,0 +1,131 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Implementation taken from external/perfetto/tools/record_android_trace.
+#
+
+import webbrowser
+import socketserver
+import http.server
+import os
+import subprocess
+from .handle_input import HandleInput
+from .utils import path_exists, wait_for_process_or_ctrl_c, wait_for_output
+from .validation_error import ValidationError
+
+TORQ_TEMP_DIR = "/tmp/.torq"
+TRACE_PROCESSOR_BINARY = "/trace_processor"
+TORQ_TEMP_TRACE_PROCESSOR = TORQ_TEMP_DIR + TRACE_PROCESSOR_BINARY
+ANDROID_PERFETTO_TOOLS_DIR = "/external/perfetto/tools"
+ANDROID_TRACE_PROCESSOR = ANDROID_PERFETTO_TOOLS_DIR + TRACE_PROCESSOR_BINARY
+LARGE_FILE_SIZE = 1024 * 1024 * 512  # 512 MB
+WAIT_FOR_TRACE_PROCESSOR_MS = 3000
+
+
+class HttpHandler(http.server.SimpleHTTPRequestHandler):
+
+  def end_headers(self):
+    self.send_header("Access-Control-Allow-Origin", self.server.allow_origin)
+    self.send_header("Cache-Control", "no-cache")
+    super().end_headers()
+
+  def do_GET(self):
+    if self.path != "/" + self.server.expected_fname:
+      self.send_error(404, "File not found")
+      return
+    self.server.fname_get_completed = True
+    super().do_GET()
+
+  def do_POST(self):
+    self.send_error(404, "File not found")
+
+  def log_message(self, format, *args):
+    pass
+
+def download_trace_processor(path):
+  if (("ANDROID_BUILD_TOP" in os.environ and
+       path_exists(os.environ["ANDROID_BUILD_TOP"] + ANDROID_TRACE_PROCESSOR))):
+    return os.environ["ANDROID_BUILD_TOP"] + ANDROID_TRACE_PROCESSOR
+  if path_exists(TORQ_TEMP_TRACE_PROCESSOR):
+    return TORQ_TEMP_TRACE_PROCESSOR
+
+  def download_accepted_callback():
+    subprocess.run(("mkdir -p %s && wget -P %s "
+                    "https://get.perfetto.dev/trace_processor && chmod +x "
+                    "%s/trace_processor"
+                    % (TORQ_TEMP_DIR, TORQ_TEMP_DIR, TORQ_TEMP_DIR)),
+                   shell=True)
+
+    if not path_exists(TORQ_TEMP_TRACE_PROCESSOR):
+      print("Could not download perfetto scripts. Continuing.")
+      return None
+
+    return TORQ_TEMP_TRACE_PROCESSOR
+
+  def rejected_callback():
+    print("Will continue without downloading perfetto scripts.")
+    return None
+
+  return (HandleInput("You do not have $ANDROID_BUILD_TOP configured "
+                     "with the $ANDROID_BUILD_TOP%s directory.\nYour "
+                     "perfetto trace is larger than 512MB, so "
+                     "attempting to load the trace in the perfetto UI "
+                     "without the perfetto scripts might not work.\n"
+                     "torq can download the perfetto scripts to '%s'. "
+                     "Are you ok with this download? [Y/N]: "
+                     % (ANDROID_PERFETTO_TOOLS_DIR, TORQ_TEMP_DIR),
+                     "Please accept or reject the download.",
+                     {"y": download_accepted_callback,
+                      "n": rejected_callback})
+          .handle_input())
+
+def open_trace(path, origin, use_trace_processor):
+  PORT = 9001
+  path = os.path.abspath(path)
+  trace_processor_path = None
+  if os.path.getsize(path) >= LARGE_FILE_SIZE or use_trace_processor:
+    trace_processor_path = download_trace_processor(path)
+  if isinstance(trace_processor_path, ValidationError):
+    return trace_processor_path
+  if trace_processor_path is not None:
+    process = subprocess.Popen("%s --httpd %s" % (trace_processor_path, path),
+                               shell=True, stdout=subprocess.PIPE,
+                               stderr=subprocess.STDOUT)
+    print("\033[93m##### Loading trace. #####")
+    if wait_for_output("Trace loaded", process,
+                       WAIT_FOR_TRACE_PROCESSOR_MS):
+      process.kill()
+      return ValidationError("Trace took too long to load.",
+                             "Please try again.")
+    webbrowser.open_new_tab(origin)
+    print("##### Follow the directions in the Perfetto UI. Do not "
+          "exit out of torq until you are done viewing the trace. Press "
+          "CTRL+C to exit torq and close the trace_processor. #####\033[0m")
+    wait_for_process_or_ctrl_c(process)
+  else: # Open trace directly in UI
+    os.chdir(os.path.dirname(path))
+    fname = os.path.basename(path)
+    socketserver.TCPServer.allow_reuse_address = True
+    with (socketserver.TCPServer(("127.0.0.1", PORT), HttpHandler)
+          as httpd):
+      address = (f"{origin}/#!/?url=http://127.0.0.1:"
+                 f"{PORT}/{fname}&referrer=open_trace_in_ui")
+      webbrowser.open_new_tab(address)
+      httpd.expected_fname = fname
+      httpd.fname_get_completed = None
+      httpd.allow_origin = origin
+      while httpd.fname_get_completed is None:
+        httpd.handle_request()
+  return None
diff --git a/torq/torq.py b/torq/src/torq.py
similarity index 77%
rename from torq/torq.py
rename to torq/src/torq.py
index a01dadbe..de272c8f 100644
--- a/torq/torq.py
+++ b/torq/src/torq.py
@@ -16,12 +16,16 @@
 
 import argparse
 import os
-from command import ProfilerCommand, ConfigCommand, OpenCommand
-from device import AdbDevice
-from validation_error import ValidationError
-from config_builder import PREDEFINED_PERFETTO_CONFIGS
-from utils import path_exists
-from validate_simpleperf import verify_simpleperf_args
+from .command import ProfilerCommand, ConfigCommand, OpenCommand
+from .device import AdbDevice
+from .validation_error import ValidationError
+from .config_builder import PREDEFINED_PERFETTO_CONFIGS
+from .utils import path_exists, set_default_subparser
+from .validate_simpleperf import verify_simpleperf_args
+from .vm import add_vm_parser, create_vm_command
+
+# Add default parser capability to argparse
+argparse.ArgumentParser.set_default_subparser = set_default_subparser
 
 DEFAULT_DUR_MS = 10000
 MIN_DURATION_MS = 3000
@@ -32,50 +36,61 @@ def create_parser():
   parser = argparse.ArgumentParser(prog='torq command',
                                    description=('Torq CLI tool for performance'
                                                 ' tests.'))
-  parser.add_argument('-e', '--event',
+  # Global options
+  # NOTE: All global options must have the 'nargs' option set to an int.
+  parser.add_argument('--serial', nargs=1,
+                      help=(('Specifies serial of the device that will be'
+                             ' used.')))
+
+  # Subparsers
+  subparsers = parser.add_subparsers(dest='subcommands', help='Subcommands')
+
+  # Profiler options
+  profiler_parser = subparsers.add_parser('profiler', help=('Profiler subcommand'
+                                                            ' used to trace and'
+                                                            ' profile Android'))
+  profiler_parser.add_argument('-e', '--event',
                       choices=['boot', 'user-switch', 'app-startup', 'custom'],
                       default='custom', help='The event to trace/profile.')
-  parser.add_argument('-p', '--profiler', choices=['perfetto', 'simpleperf'],
+  profiler_parser.add_argument('-p', '--profiler', choices=['perfetto', 'simpleperf'],
                       default='perfetto', help='The performance data source.')
-  parser.add_argument('-o', '--out-dir', default=DEFAULT_OUT_DIR,
+  profiler_parser.add_argument('-o', '--out-dir', default=DEFAULT_OUT_DIR,
                       help='The path to the output directory.')
-  parser.add_argument('-d', '--dur-ms', type=int, default=DEFAULT_DUR_MS,
+  profiler_parser.add_argument('-d', '--dur-ms', type=int, default=DEFAULT_DUR_MS,
                       help=('The duration (ms) of the event. Determines when'
                             ' to stop collecting performance data.'))
-  parser.add_argument('-a', '--app',
+  profiler_parser.add_argument('-a', '--app',
                       help='The package name of the app we want to start.')
-  parser.add_argument('-r', '--runs', type=int, default=1,
+  profiler_parser.add_argument('-r', '--runs', type=int, default=1,
                       help=('The number of times to run the event and'
                             ' capture the perf data.'))
-  parser.add_argument('-s', '--simpleperf-event', action='append',
+  profiler_parser.add_argument('-s', '--simpleperf-event', action='append',
                       help=('Simpleperf supported events to be collected.'
                             ' e.g. cpu-cycles, instructions'))
-  parser.add_argument('--perfetto-config', default='default',
+  profiler_parser.add_argument('--perfetto-config', default='default',
                       help=('Predefined perfetto configs can be used:'
                             ' %s. A filepath with a custom config could'
                             ' also be provided.'
                             % (", ".join(PREDEFINED_PERFETTO_CONFIGS.keys()))))
-  parser.add_argument('--between-dur-ms', type=int, default=DEFAULT_DUR_MS,
+  profiler_parser.add_argument('--between-dur-ms', type=int, default=DEFAULT_DUR_MS,
                       help='Time (ms) to wait before executing the next event.')
-  parser.add_argument('--ui', action=argparse.BooleanOptionalAction,
+  profiler_parser.add_argument('--ui', action=argparse.BooleanOptionalAction,
                       help=('Specifies opening of UI visualization tool'
                             ' after profiling is complete.'))
-  parser.add_argument('--excluded-ftrace-events', action='append',
+  profiler_parser.add_argument('--excluded-ftrace-events', action='append',
                       help=('Excludes specified ftrace event from the perfetto'
                             ' config events.'))
-  parser.add_argument('--included-ftrace-events', action='append',
+  profiler_parser.add_argument('--included-ftrace-events', action='append',
                       help=('Includes specified ftrace event in the perfetto'
                             ' config events.'))
-  parser.add_argument('--from-user', type=int,
+  profiler_parser.add_argument('--from-user', type=int,
                       help='The user id from which to start the user switch')
-  parser.add_argument('--to-user', type=int,
+  profiler_parser.add_argument('--to-user', type=int,
                       help='The user id of user that system is switching to.')
-  parser.add_argument('--serial',
-                      help=(('Specifies serial of the device that will be'
-                             ' used.')))
-  parser.add_argument('--symbols',
+  profiler_parser.add_argument('--symbols',
                       help='Specifies path to symbols library.')
-  subparsers = parser.add_subparsers(dest='subcommands', help='Subcommands')
+
+  # Config options
   config_parser = subparsers.add_parser('config',
                                         help=('The config subcommand used'
                                               ' to list and show the'
@@ -95,6 +110,16 @@ def create_parser():
                                   choices=['lightweight', 'default', 'memory'],
                                   help=('Name of the predefined perfetto'
                                         ' config to print.'))
+  config_show_parser.add_argument('-d', '--dur-ms', type=int, default=DEFAULT_DUR_MS,
+                      help=('The duration (ms) of the event. Determines when'
+                            ' to stop collecting performance data.'))
+  config_show_parser.add_argument('--excluded-ftrace-events', action='append',
+                      help=('Excludes specified ftrace event from the perfetto'
+                            ' config events.'))
+  config_show_parser.add_argument('--included-ftrace-events', action='append',
+                      help=('Includes specified ftrace event in the perfetto'
+                            ' config events.'))
+
   config_pull_parser = config_subparsers.add_parser('pull',
                                                     help=('Command to copy'
                                                           ' a predefined config'
@@ -106,11 +131,33 @@ def create_parser():
   config_pull_parser.add_argument('file_path', nargs='?',
                                   help=('File path to copy the predefined'
                                         ' config to'))
+  config_pull_parser.add_argument('-d', '--dur-ms', type=int, default=DEFAULT_DUR_MS,
+                      help=('The duration (ms) of the event. Determines when'
+                            ' to stop collecting performance data.'))
+  config_pull_parser.add_argument('--excluded-ftrace-events', action='append',
+                      help=('Excludes specified ftrace event from the perfetto'
+                            ' config events.'))
+  config_pull_parser.add_argument('--included-ftrace-events', action='append',
+                      help=('Includes specified ftrace event in the perfetto'
+                            ' config events.'))
+
+  # Open options
   open_parser = subparsers.add_parser('open',
                                       help=('The open subcommand is used '
                                             'to open trace files in the '
                                             'perfetto ui.'))
   open_parser.add_argument('file_path', help='Path to trace file.')
+  open_parser.add_argument('--use_trace_processor', default=False,
+                           action='store_true',
+                                  help=('Enables using trace_processor to open '
+                                        'the trace regardless of its size.'))
+
+  # Configure perfetto in virtualized Android
+  add_vm_parser(subparsers)
+
+  # Set 'profiler' as the default parser
+  parser.set_default_subparser('profiler')
+
   return parser
 
 
@@ -128,18 +175,9 @@ def user_changed_default_arguments(args):
               args.excluded_ftrace_events is not None,
               args.included_ftrace_events is not None,
               args.from_user is not None,
-              args.to_user is not None,
-              args.serial is not None])
-
-
-def verify_args(args):
-  if (args.subcommands is not None and
-      user_changed_default_arguments(args)):
-    return None, ValidationError(
-        ("Command is invalid because profiler command is followed by a config"
-         " command."),
-        "Remove the 'config' subcommand to profile the device instead.")
+              args.to_user is not None])
 
+def verify_profiler_args(args):
   if args.out_dir != DEFAULT_OUT_DIR and not os.path.isdir(args.out_dir):
     return None, ValidationError(
         ("Command is invalid because --out-dir is not a valid directory"
@@ -300,7 +338,23 @@ def verify_args(args):
                         % (event, event, event, event)
                         for event in ftrace_event_intersection)))
 
-  if args.subcommands == "config" and args.config_subcommand is None:
+  if args.profiler == "simpleperf" and args.simpleperf_event is None:
+    args.simpleperf_event = ['cpu-cycles']
+
+  if args.ui is None:
+    args.ui = args.runs == 1
+
+  if args.profiler == "simpleperf":
+    args, error = verify_simpleperf_args(args)
+    if error is not None:
+      return None, error
+  else:
+    args.scripts_path = None
+
+  return args, None
+
+def verify_config_args(args):
+  if args.config_subcommand is None:
     return None, ValidationError(
         ("Command is invalid because torq config cannot be called"
          " without a subcommand."),
@@ -309,13 +363,7 @@ def verify_args(args):
          "\t torq config show\n"
          "\t torq config pull\n"))
 
-  if args.profiler == "simpleperf" and args.simpleperf_event is None:
-    args.simpleperf_event = ['cpu-cycles']
-
-  if args.ui is None:
-    args.ui = args.runs == 1
-
-  if args.subcommands == "config" and args.config_subcommand == "pull":
+  if args.config_subcommand == "pull":
     if args.file_path is None:
       args.file_path = "./" + args.config_name + ".pbtxt"
     elif not os.path.isfile(args.file_path):
@@ -327,20 +375,28 @@ def verify_args(args):
            "\t torq pull lightweight to copy to ./lightweight.pbtxt\n"
            "\t torq pull memory to copy to ./memory.pbtxt"))
 
-  if args.subcommands == "open" and not path_exists(args.file_path):
+  return args, None
+
+def verify_open_args(args):
+  if not path_exists(args.file_path):
     return None, ValidationError(
         "Command is invalid because %s is an invalid file path."
         % args.file_path, "Make sure your file exists.")
 
-  if args.profiler == "simpleperf":
-    args, error = verify_simpleperf_args(args)
-    if error is not None:
-      return None, error
-  else:
-    args.scripts_path = None
-
   return args, None
 
+def verify_args(args):
+  match args.subcommands:
+    case "profiler":
+      return verify_profiler_args(args)
+    case "config":
+      return verify_config_args(args)
+    case "open":
+      return verify_open_args(args)
+    case "vm":
+      return args, None
+    case _:
+      raise ValueError("Invalid command type used")
 
 def create_profiler_command(args):
   return ProfilerCommand("profiler", args.event, args.profiler, args.out_dir,
@@ -349,7 +405,7 @@ def create_profiler_command(args):
                          args.perfetto_config, args.between_dur_ms,
                          args.ui, args.excluded_ftrace_events,
                          args.included_ftrace_events, args.from_user,
-                         args.to_user)
+                         args.to_user, args.scripts_path, args.symbols)
 
 
 def create_config_command(args):
@@ -373,14 +429,17 @@ def create_config_command(args):
 
 
 def get_command_type(args):
-  command = None
-  if args.subcommands is None:
-    command = create_profiler_command(args)
-  if args.subcommands == "config":
-    command = create_config_command(args)
-  if args.subcommands == "open":
-    command = OpenCommand(args.file_path)
-  return command
+  match args.subcommands:
+    case "profiler":
+      return create_profiler_command(args)
+    case "config":
+      return create_config_command(args)
+    case "open":
+      return OpenCommand(args.file_path, args.use_trace_processor)
+    case "vm":
+      return create_vm_command(args)
+    case _:
+      raise ValueError("Invalid command type used")
 
 
 def print_error(error):
@@ -397,7 +456,8 @@ def main():
     print_error(error)
     return
   command = get_command_type(args)
-  device = AdbDevice(args.serial)
+  serial = args.serial[0] if args.serial else None
+  device = AdbDevice(serial)
   error = command.execute(device)
   if error is not None:
     print_error(error)
diff --git a/torq/src/utils.py b/torq/src/utils.py
new file mode 100644
index 00000000..97dcd93b
--- /dev/null
+++ b/torq/src/utils.py
@@ -0,0 +1,104 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import argparse
+import os
+import signal
+import subprocess
+import sys
+import time
+
+def path_exists(path: str):
+  if path is None:
+    return False
+  return os.path.exists(os.path.expanduser(path))
+
+def dir_exists(path: str):
+  if path is None:
+    return False
+  return os.path.isdir(os.path.expanduser(path))
+
+def convert_simpleperf_to_gecko(scripts_path, host_raw_trace_filename,
+    host_gecko_trace_filename, symbols):
+  expanded_symbols = os.path.expanduser(symbols)
+  expanded_scripts_path = os.path.expanduser(scripts_path)
+  print("Building binary cache, please wait. If no samples were recorded,"
+        " the trace will be empty.")
+  subprocess.run(("%s/binary_cache_builder.py -i %s -lib %s"
+                  % (expanded_scripts_path, host_raw_trace_filename,
+                     expanded_symbols)),
+                 shell=True)
+  subprocess.run(("%s/gecko_profile_generator.py -i %s > %s"
+                  % (expanded_scripts_path, host_raw_trace_filename,
+                     host_gecko_trace_filename)),
+                 shell=True)
+  if not path_exists(host_gecko_trace_filename):
+    raise Exception("Gecko file was not created.")
+
+def wait_for_process_or_ctrl_c(process):
+  def signal_handler(sig, frame):
+    print("Exiting...")
+    process.kill()
+    sys.exit()
+
+  signal.signal(signal.SIGINT, signal_handler)
+  signal.signal(signal.SIGTERM, signal_handler)
+
+  process.wait()
+  print("Process was killed.")
+
+def wait_for_output(pattern, process, timeout):
+  start_time = time.time()
+  while time.time() - start_time < timeout:
+    line = process.stdout.readline()
+    if pattern in line.decode():
+      process.stderr = None
+      return False
+  return True  # Timed out
+
+def set_default_subparser(self, name):
+  """
+  A hack to add a default subparser to an argparse.ArgumentParser
+  class. This will add the default subparser after all the global
+  options in sys.argv.
+
+  NOTE: Only works properly if all the global options have the
+        'nargs' argument set to an integer.
+  """
+  subparser_found = False
+  insertion_idx = 1
+
+  # Get all global options
+  global_opts = {}
+  for action in self._actions:
+      for opt in action.option_strings:
+          global_opts[opt] = action.nargs
+
+  for idx, arg in enumerate(sys.argv[1:]):
+    if arg in ['-h', '--help']:
+      break
+    if arg in global_opts:
+      insertion_idx = idx + global_opts[arg] + 2
+  else:
+    for action in self._subparsers._actions:
+      if not isinstance(action, argparse._SubParsersAction):
+        continue
+      for sp_name in action._name_parser_map.keys():
+        if sp_name in sys.argv[1:]:
+          subparser_found = True
+    if not subparser_found:
+      # insert default subparser
+      sys.argv.insert(insertion_idx, name)
diff --git a/torq/validate_simpleperf.py b/torq/src/validate_simpleperf.py
similarity index 57%
rename from torq/validate_simpleperf.py
rename to torq/src/validate_simpleperf.py
index 4b8c41ca..06dddfc5 100644
--- a/torq/validate_simpleperf.py
+++ b/torq/src/validate_simpleperf.py
@@ -16,8 +16,9 @@
 
 import os
 import subprocess
-from utils import path_exists, dir_exists
-from validation_error import ValidationError
+from .utils import path_exists, dir_exists
+from .validation_error import ValidationError
+from .handle_input import HandleInput
 
 TORQ_TEMP_DIR = "/tmp/.torq"
 TEMP_CACHE_BUILDER_SCRIPT = TORQ_TEMP_DIR + "/binary_cache_builder.py"
@@ -65,42 +66,36 @@ def verify_simpleperf_args(args):
   return args, None
 
 def download_simpleperf_scripts():
-  i = 0
-  while i <= 3:
-    i += 1
-    confirmation = input("You do not have an Android Root configured with "
-                         "the simpleperf directory. To use simpleperf, torq "
-                         "will download simpleperf scripts to '%s'. "
-                         "Are you ok with this download? [Y/N]: "
-                         % TORQ_TEMP_DIR)
+  fail_suggestion = ("Set $ANDROID_BUILD_TOP to your android root "
+                     "path and make sure you have $ANDROID_BUILD_TOP"
+                     "/system/extras/simpleperf/scripts "
+                     "downloaded.")
 
-    if confirmation.lower() == "y":
-      break
-    elif confirmation.lower() == "n":
-      return ValidationError("Did not download simpleperf scripts.",
-                             "Set $ANDROID_BUILD_TOP to your android root "
-                             "path and make sure you have $ANDROID_BUILD_TOP"
-                             "/system/extras/simpleperf/scripts "
-                             "downloaded.")
-    if i == 3:
-      return ValidationError("Invalid inputs.",
-                             "Set $ANDROID_BUILD_TOP to your android root "
-                             "path and make sure you have $ANDROID_BUILD_TOP"
-                             "/system/extras/simpleperf/scripts "
-                             "downloaded.")
+  def download_accepted_callback():
+    subprocess.run(("mkdir -p %s && wget -P %s "
+                    "https://android.googlesource.com/platform/system/extras"
+                    "/+archive/refs/heads/main/simpleperf/scripts.tar.gz "
+                    "&& tar -xvzf %s/scripts.tar.gz -C %s"
+                    % (TORQ_TEMP_DIR, TORQ_TEMP_DIR, TORQ_TEMP_DIR,
+                       TORQ_TEMP_DIR)),
+                   shell=True)
 
-  subprocess.run(("mkdir -p %s && wget -P %s "
-                 "https://android.googlesource.com/platform/system/extras"
-                 "/+archive/refs/heads/main/simpleperf/scripts.tar.gz "
-                 "&& tar -xvzf %s/scripts.tar.gz -C %s"
-                  % (TORQ_TEMP_DIR, TORQ_TEMP_DIR, TORQ_TEMP_DIR,
-                     TORQ_TEMP_DIR)),
-                 shell=True)
+    if not path_exists(TEMP_CACHE_BUILDER_SCRIPT):
+      raise Exception("Error while downloading simpleperf scripts. Try again "
+                      "or set $ANDROID_BUILD_TOP to your android root path and "
+                      "make sure you have $ANDROID_BUILD_TOP/system/extras/"
+                      "simpleperf/scripts downloaded.")
+    return None
 
-  if not path_exists(TEMP_CACHE_BUILDER_SCRIPT):
-    raise Exception("Error while downloading simpleperf scripts. Try again "
-                    "or set $ANDROID_BUILD_TOP to your android root path and "
-                    "make sure you have $ANDROID_BUILD_TOP/system/extras/"
-                    "simpleperf/scripts downloaded.")
+  def rejected_callback():
+    return ValidationError("Did not download simpleperf scripts.",
+                           fail_suggestion)
 
-  return None
+  return (HandleInput(("You do not have an Android Root configured "
+                      "with the simpleperf directory. To use "
+                      "simpleperf, torq will download simpleperf "
+                      "scripts to '%s'. Are you ok with this download?"
+                      " [Y/N]: " % TORQ_TEMP_DIR), fail_suggestion,
+                     {"y": download_accepted_callback,
+                      "n": rejected_callback})
+          .handle_input())
diff --git a/torq/validation_error.py b/torq/src/validation_error.py
similarity index 100%
rename from torq/validation_error.py
rename to torq/src/validation_error.py
diff --git a/torq/src/vm.py b/torq/src/vm.py
new file mode 100644
index 00000000..14d6bcb5
--- /dev/null
+++ b/torq/src/vm.py
@@ -0,0 +1,124 @@
+#
+# Copyright (C) 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import argparse
+from .command import Command
+from .validation_error import ValidationError
+
+TRACED_ENABLE_PROP = "persist.traced.enable"
+TRACED_RELAY_PRODUCER_PORT_PROP = "traced.relay_producer_port"
+TRACED_RELAY_PORT_PROP = "traced_relay.relay_port"
+TRACED_HYPERVISOR_PROP = "ro.traced.hypervisor"
+
+def add_vm_parser(subparsers):
+  vm_parser = subparsers.add_parser('vm',
+                                      help=('The vm subcommand is used '
+                                            'to configure perfetto in '
+                                            'virtualized Android.'))
+  vm_subparsers = vm_parser.add_subparsers(dest='vm_subcommand')
+
+  # Traced relay subcommand
+  traced_relay_parser = vm_subparsers.add_parser('traced-relay',
+                                                  help=('Configure traced_relay'))
+  traced_relay_subparsers = traced_relay_parser.add_subparsers(dest='vm_traced_relay_subcommand')
+
+  enable_tr_parser = traced_relay_subparsers.add_parser('enable', help=('Enable traced_relay'))
+  enable_tr_parser.add_argument('relay_port', help='Socket address to communicate with traced.')
+
+  traced_relay_subparsers.add_parser('disable', help=('Disable traced_relay'))
+
+  # Traced relay producer subcommand
+  relay_producer_parser = vm_subparsers.add_parser('relay-producer',
+                                                  help=('Configure traced\'s relay '
+                                                        'producer socket'))
+  relay_producer_subparsers = \
+        relay_producer_parser.add_subparsers(dest='vm_relay_producer_subcommand')
+
+  enable_rp_parser = \
+        relay_producer_subparsers.add_parser('enable',
+                                             help=('Enable traced\'s relay producer port'))
+  enable_rp_parser.add_argument('--address', dest='relay_prod_port',
+                                default='vsock://-1:30001',
+                                help='Socket address used for relayed communication.')
+
+  relay_producer_subparsers.add_parser('disable', help=('Disable traced\'s relay producer port'))
+
+
+def create_vm_command(args):
+  if args.vm_subcommand == 'traced-relay':
+    relay_port = None
+    if args.vm_traced_relay_subcommand == 'enable':
+      relay_port = args.relay_port
+
+    return VmCommand(args.vm_subcommand,
+                     args.vm_traced_relay_subcommand,
+                     relay_port, None)
+  # relay-producer command
+  relay_prod_port = None
+  if args.vm_relay_producer_subcommand == 'enable':
+    relay_prod_port = args.relay_prod_port
+  return VmCommand(args.vm_subcommand,
+                   args.vm_relay_producer_subcommand,
+                   None, relay_prod_port)
+
+class VmCommand(Command):
+  """
+  Represents commands which configure perfetto
+  in virtualized Android.
+  """
+  def __init__(self, type, subcommand, relay_port, relay_prod_port):
+    super().__init__(type)
+    self.subcommand = subcommand
+    self.relay_port = relay_port
+    self.relay_prod_port = relay_prod_port
+
+  def validate(self, device):
+    raise NotImplementedError
+
+  def execute(self, device):
+    error = device.check_device_connection()
+    if error is not None:
+      return error
+    device.root_device()
+    if self.type == 'traced-relay':
+      return self.traced_relay_execute(device)
+    # else it's a relay-producer command
+    return self.relay_producer_execute(device)
+
+  def traced_relay_execute(self, device):
+    if self.subcommand == 'enable':
+      if (len(device.get_prop(TRACED_HYPERVISOR_PROP)) == 0):
+        # Traced_relay can only be used in virtualized environments,
+        # therefore set the |TRACED_HYPERVISOR_PROP| to true if
+        # enabling traced_relay.
+        print(f"Setting sysprop \"{TRACED_HYPERVISOR_PROP}\" to \"true\"")
+        device.set_prop(TRACED_HYPERVISOR_PROP, "true")
+      device.set_prop(TRACED_RELAY_PORT_PROP, self.relay_port)
+      device.set_prop(TRACED_ENABLE_PROP, "2")
+    else: # disable
+      device.set_prop(TRACED_ENABLE_PROP, "1")
+    return None
+
+  def relay_producer_execute(self, device):
+    if self.subcommand == 'enable':
+      device.set_prop(TRACED_ENABLE_PROP, "0")
+      device.set_prop(TRACED_RELAY_PRODUCER_PORT_PROP, self.relay_prod_port)
+      device.set_prop(TRACED_ENABLE_PROP, "1")
+    else: #disable
+      device.set_prop(TRACED_ENABLE_PROP, "0")
+      device.clear_prop(TRACED_RELAY_PRODUCER_PORT_PROP)
+      device.set_prop(TRACED_ENABLE_PROP, "1")
+    return None
diff --git a/torq/tests/config_builder_unit_test.py b/torq/tests/config_builder_unit_test.py
index 42e9f4eb..e206950e 100644
--- a/torq/tests/config_builder_unit_test.py
+++ b/torq/tests/config_builder_unit_test.py
@@ -17,9 +17,9 @@
 import unittest
 import builtins
 from unittest import mock
-from config_builder import build_default_config, build_custom_config
-from command import ProfilerCommand
-from torq import DEFAULT_DUR_MS
+from src.config_builder import build_default_config, build_custom_config
+from src.command import ProfilerCommand
+from src.torq import DEFAULT_DUR_MS
 
 TEST_FAILURE_MSG = "Test failure."
 TEST_DUR_MS = 9000
@@ -339,7 +339,7 @@ class ConfigBuilderUnitTest(unittest.TestCase):
   def setUp(self):
     self.command = ProfilerCommand(
         None, "custom", None, None, DEFAULT_DUR_MS, None, None, "test-path",
-        None, None, None, None, None, None, None)
+        None, None, None, None, None, None, None, None, None)
 
   def test_build_default_config_setting_valid_dur_ms(self):
     self.command.dur_ms = TEST_DUR_MS
diff --git a/torq/tests/device_unit_test.py b/torq/tests/device_unit_test.py
index da0c3724..01d5d7b9 100644
--- a/torq/tests/device_unit_test.py
+++ b/torq/tests/device_unit_test.py
@@ -14,12 +14,13 @@
 # limitations under the License.
 #
 
+import builtins
 import unittest
 import os
 import subprocess
 from unittest import mock
-from command import ProfilerCommand
-from device import AdbDevice
+from src.command import ProfilerCommand
+from src.device import AdbDevice
 
 TEST_DEVICE_SERIAL = "test-device-serial"
 TEST_DEVICE_SERIAL2 = "test-device-serial2"
@@ -244,8 +245,10 @@ class DeviceUnitTest(unittest.TestCase):
 
   @mock.patch.dict(os.environ, {}, clear=True)
   @mock.patch.object(subprocess, "run", autospec=True)
-  def test_check_device_connection_multiple_devices_error(self,
+  @mock.patch.object(builtins, "input")
+  def test_check_device_connection_multiple_devices_select_first(self, mock_input,
       mock_subprocess_run):
+    mock_input.return_value = "0"
     mock_subprocess_run.return_value = (
         self.generate_adb_devices_result([TEST_DEVICE_SERIAL,
                                           TEST_DEVICE_SERIAL2]))
@@ -253,15 +256,24 @@ class DeviceUnitTest(unittest.TestCase):
 
     error = adbDevice.check_device_connection()
 
-    self.assertNotEqual(error, None)
-    self.assertEqual(error.message, ("There is more than one device currently"
-                                     " connected."))
-    self.assertEqual(error.suggestion, ("Run one of the following commands to"
-                                        " choose one of the connected devices:"
-                                        "\n\t torq --serial %s"
-                                        "\n\t torq --serial %s"
-                                        % (TEST_DEVICE_SERIAL,
-                                           TEST_DEVICE_SERIAL2)))
+    self.assertEqual(error, None)
+    self.assertEqual(adbDevice.serial, TEST_DEVICE_SERIAL)
+
+  @mock.patch.dict(os.environ, {}, clear=True)
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(builtins, "input")
+  def test_check_device_connection_multiple_devices_select_second(self, mock_input,
+      mock_subprocess_run):
+    mock_input.return_value = "1"
+    mock_subprocess_run.return_value = (
+        self.generate_adb_devices_result([TEST_DEVICE_SERIAL,
+                                          TEST_DEVICE_SERIAL2]))
+    adbDevice = AdbDevice(None)
+
+    error = adbDevice.check_device_connection()
+
+    self.assertEqual(error, None)
+    self.assertEqual(adbDevice.serial, TEST_DEVICE_SERIAL2)
 
   @mock.patch.object(subprocess, "run", autospec=True)
   def test_root_device_success(self, mock_subprocess_run):
@@ -356,7 +368,7 @@ class DeviceUnitTest(unittest.TestCase):
     adbDevice = AdbDevice(TEST_DEVICE_SERIAL)
     command = ProfilerCommand("profiler", "custom", None, None,
                               10000, None, None, ["cpu-cycles"], None, None,
-                              None, None, None, None, None)
+                              None, None, None, None, None, None, None)
     mock_process = adbDevice.start_simpleperf_trace(command)
 
     # No exception is expected to be thrown
@@ -369,7 +381,7 @@ class DeviceUnitTest(unittest.TestCase):
 
     command = ProfilerCommand("profiler", "custom", None, None,
                               10000, None, None, ["cpu-cycles"], None, None,
-                              None, None, None, None, None)
+                              None, None, None, None, None, None, None)
     with self.assertRaises(Exception) as e:
       adbDevice.start_simpleperf_trace(command)
 
@@ -857,6 +869,20 @@ class DeviceUnitTest(unittest.TestCase):
     self.assertEqual(error.suggestion, "Run adb shell simpleperf list to"
                                        " see valid simpleperf events.")
 
+  @mock.patch.object(subprocess, "run", autospec=True)
+  def test_simpleperf_not_installed(self, mock_subprocess_run):
+    mock_subprocess_run.return_value = (
+        self.generate_mock_completed_process(
+            b'',
+            b'/system/bin/sh: simpleperf: inaccessible or not found\n')
+    )
+    adbDevice = AdbDevice(TEST_DEVICE_SERIAL)
+
+    error = adbDevice.simpleperf_event_exists(["cpu-clock", "minor-faults",
+                                               "List"])
+
+    self.assertEqual(error.message, "Simpleperf was not found in the device")
+    self.assertEqual(error.suggestion, "Push the simpleperf binary to the device")
 
 if __name__ == '__main__':
   unittest.main()
diff --git a/torq/tests/open_ui_unit_test.py b/torq/tests/open_ui_unit_test.py
new file mode 100644
index 00000000..1d6aeec4
--- /dev/null
+++ b/torq/tests/open_ui_unit_test.py
@@ -0,0 +1,274 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+
+import builtins
+import io
+from io import BytesIO
+import socketserver
+import unittest
+import subprocess
+import sys
+import os
+import webbrowser
+from unittest import mock
+from src.command import OpenCommand
+from src.open_ui import download_trace_processor, open_trace
+
+ANDROID_BUILD_TOP = "/main"
+TEST_FILE = "file.pbtxt"
+TORQ_TEMP_DIR = "/tmp/.torq"
+PERFETTO_BINARY = "/trace_processor"
+TORQ_TEMP_TRACE_PROCESSOR = TORQ_TEMP_DIR + PERFETTO_BINARY
+ANDROID_PERFETTO_TOOLS_DIR = "/external/perfetto/tools"
+ANDROID_TRACE_PROCESSOR = ANDROID_PERFETTO_TOOLS_DIR + PERFETTO_BINARY
+LARGE_FILE_SIZE = 1024 * 1024 * 512  # 512 MB
+WEB_UI_ADDRESS = "https://ui.perfetto.dev"
+
+
+class OpenUiUnitTest(unittest.TestCase):
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(builtins, "input")
+  def test_download_trace_processor_successfully(self, mock_input,
+      mock_subprocess_run, mock_getsize, mock_exists):
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_input.return_value = "y"
+    mock_exists.side_effect = [False, False, True]
+    mock_subprocess_run.return_value = None
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    trace_processor_path = download_trace_processor(TEST_FILE)
+
+    self.assertEqual(trace_processor_path, TORQ_TEMP_TRACE_PROCESSOR)
+    self.assertEqual(terminal_output.getvalue(), "")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(builtins, "input")
+  def test_download_trace_processor_failed(self, mock_input,
+      mock_subprocess_run, mock_getsize, mock_exists):
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_input.return_value = "y"
+    mock_exists.side_effect = [False, False, False]
+    mock_subprocess_run.return_value = None
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    trace_processor_path = download_trace_processor(TEST_FILE)
+
+    self.assertEqual(trace_processor_path, None)
+    self.assertEqual(terminal_output.getvalue(),
+                     "Could not download perfetto scripts. Continuing.\n")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(builtins, "input")
+  def test_download_trace_processor_wrong_input(self, mock_input,
+      mock_getsize, mock_exists):
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_input.return_value = "bad-input"
+    mock_exists.side_effect = [False, False]
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    error = download_trace_processor(TEST_FILE)
+
+    self.assertNotEqual(error, None)
+    self.assertEqual(error.message, "Invalid inputs.")
+    self.assertEqual(error.suggestion, "Please accept or reject the download.")
+    self.assertEqual(terminal_output.getvalue(),
+                     "Invalid input. Please try again.\n"
+                     "Invalid input. Please try again.\n")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(builtins, "input")
+  def test_download_trace_processor_refused(self, mock_input, mock_getsize,
+      mock_exists):
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_input.return_value = "n"
+    mock_exists.side_effect = [False, False]
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    trace_processor_path = download_trace_processor(TEST_FILE)
+
+    self.assertEqual(trace_processor_path, None)
+    self.assertEqual(terminal_output.getvalue(),
+                     "Will continue without downloading perfetto scripts.\n")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(os.path, "abspath", autospec=True)
+  @mock.patch.object(webbrowser, "open_new_tab", autospec=True)
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "expanduser", autospec=True)
+  @mock.patch.object(subprocess, "Popen", autospec=True)
+  def test_open_trace_scripts_large_file(self, mock_popen, mock_expanduser,
+      mock_exists, mock_subprocess_run, mock_open_new_tab, mock_abspath,
+      mock_getsize):
+    mock_expanduser.return_value = ""
+    mock_subprocess_run.return_value = None
+    mock_open_new_tab.return_value = None
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_abspath.return_value = TEST_FILE
+    mock_exists.return_value = True
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+    mock_process = mock_popen.return_value
+    mock_process.stdout = BytesIO(b'Trace loaded')
+
+    error = open_trace(TEST_FILE, WEB_UI_ADDRESS, False)
+
+    mock_open_new_tab.assert_called()
+    self.assertEqual(error, None)
+    self.assertEqual(terminal_output.getvalue(),
+                     "\033[93m##### Loading trace. #####\n##### "
+                     "Follow the directions in the Perfetto UI. Do not exit "
+                     "out of torq until you are done viewing the trace. Press "
+                     "CTRL+C to exit torq and close the trace_processor. "
+                     "#####\033[0m\nProcess was killed.\n")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(webbrowser, "open_new_tab", autospec=True)
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(subprocess, "Popen", autospec=True)
+  def test_open_trace_scripts_large_file_use_trace_processor_enabled(self,
+      mock_popen, mock_subprocess_run, mock_open_new_tab, mock_getsize,
+      mock_exists):
+    mock_subprocess_run.return_value = None
+    mock_open_new_tab.return_value = None
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_exists.return_value = True
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+    mock_process = mock_popen.return_value
+    mock_process.stdout = BytesIO(b'Trace loaded')
+
+    error = open_trace(TEST_FILE, WEB_UI_ADDRESS, True)
+
+    mock_open_new_tab.assert_called()
+    self.assertEqual(error, None)
+    self.assertEqual(terminal_output.getvalue(),
+                     "\033[93m##### Loading trace. #####\n##### "
+                     "Follow the directions in the Perfetto UI. Do not exit "
+                     "out of torq until you are done viewing the trace. Press "
+                     "CTRL+C to exit torq and close the trace_processor. "
+                     "#####\033[0m\nProcess was killed.\n")
+
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(webbrowser, "open_new_tab", autospec=True)
+  @mock.patch.object(socketserver, "TCPServer", autospec=True)
+  def test_open_trace_scripts_small_file(self, mock_tcpserver,
+      mock_open_new_tab, mock_getsize):
+    def handle_request():
+      mock_process.fname_get_completed = 0
+      return
+    mock_process = type('', (), {})()
+    mock_process.handle_request = handle_request
+    mock_tcpserver.return_value.__enter__.return_value = mock_process
+    mock_open_new_tab.return_value = None
+    mock_getsize.return_value = 0
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    error = open_trace(TEST_FILE, WEB_UI_ADDRESS, False)
+
+    mock_open_new_tab.assert_called()
+    self.assertEqual(error, None)
+    self.assertEqual(terminal_output.getvalue(), "")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  @mock.patch.object(webbrowser, "open_new_tab", autospec=True)
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(subprocess, "Popen", autospec=True)
+  def test_download_trace_processor_small_file_use_trace_processor_enabled(self,
+      mock_popen, mock_subprocess_run, mock_open_new_tab, mock_getsize,
+      mock_exists):
+    mock_subprocess_run.return_value = None
+    mock_open_new_tab.return_value = None
+    mock_getsize.return_value = 0
+    mock_exists.return_value = True
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+    mock_process = mock_popen.return_value
+    mock_process.stdout = BytesIO(b'Trace loaded')
+
+    error = open_trace(TEST_FILE, WEB_UI_ADDRESS, True)
+
+    mock_open_new_tab.assert_called()
+    self.assertEqual(error, None)
+    self.assertEqual(terminal_output.getvalue(),
+                     "\033[93m##### Loading trace. #####\n##### "
+                     "Follow the directions in the Perfetto UI. Do not exit "
+                     "out of torq until you are done viewing the trace. Press "
+                     "CTRL+C to exit torq and close the trace_processor. "
+                     "#####\033[0m\nProcess was killed.\n")
+
+  @mock.patch.dict(os.environ, {"ANDROID_BUILD_TOP": ANDROID_BUILD_TOP},
+                   clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  def test_download_trace_processor_android_scripts_exist(self, mock_getsize,
+      mock_exists):
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_exists.return_value = True
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    trace_processor_path = download_trace_processor(TEST_FILE)
+
+    self.assertEqual(trace_processor_path, "%s%s"
+                     % (ANDROID_BUILD_TOP, ANDROID_TRACE_PROCESSOR))
+    self.assertEqual(terminal_output.getvalue(), "")
+
+  @mock.patch.dict(os.environ, {}, clear=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  @mock.patch.object(os.path, "getsize", autospec=True)
+  def test_download_trace_processor_temp_scripts_exist(self, mock_getsize,
+      mock_exists):
+    mock_getsize.return_value = LARGE_FILE_SIZE
+    mock_exists.return_value = True
+    terminal_output = io.StringIO()
+    sys.stdout = terminal_output
+
+    trace_processor_path = download_trace_processor(TEST_FILE)
+
+    self.assertEqual(trace_processor_path, TORQ_TEMP_TRACE_PROCESSOR)
+    self.assertEqual(terminal_output.getvalue(), "")
+
+if __name__ == '__main__':
+  unittest.main()
diff --git a/torq/tests/command_executor_unit_test.py b/torq/tests/perfetto_command_executor_unit_test.py
similarity index 93%
rename from torq/tests/command_executor_unit_test.py
rename to torq/tests/perfetto_command_executor_unit_test.py
index 19226bf9..db91a768 100644
--- a/torq/tests/command_executor_unit_test.py
+++ b/torq/tests/perfetto_command_executor_unit_test.py
@@ -14,18 +14,18 @@
 # limitations under the License.
 #
 
+import os
 import unittest
 import subprocess
 import sys
 import io
 from unittest import mock
-from command import ProfilerCommand, ConfigCommand
-from device import AdbDevice
-from validation_error import ValidationError
-from torq import DEFAULT_DUR_MS, DEFAULT_OUT_DIR, PREDEFINED_PERFETTO_CONFIGS
+from src.command import ProfilerCommand, ConfigCommand
+from src.device import AdbDevice
+from src.validation_error import ValidationError
+from src.torq import DEFAULT_DUR_MS, DEFAULT_OUT_DIR, PREDEFINED_PERFETTO_CONFIGS
 
 PROFILER_COMMAND_TYPE = "profiler"
-PROFILER_TYPE = "perfetto"
 TEST_ERROR_MSG = "test-error"
 TEST_EXCEPTION = Exception(TEST_ERROR_MSG)
 TEST_VALIDATION_ERROR = ValidationError(TEST_ERROR_MSG, None)
@@ -374,9 +374,9 @@ class ProfilerCommandExecutorUnitTest(unittest.TestCase):
 
   def setUp(self):
     self.command = ProfilerCommand(
-        PROFILER_COMMAND_TYPE, "custom", PROFILER_TYPE, DEFAULT_OUT_DIR, DEFAULT_DUR_MS,
+        PROFILER_COMMAND_TYPE, "custom", "perfetto", DEFAULT_OUT_DIR, DEFAULT_DUR_MS,
         None, 1, None, DEFAULT_PERFETTO_CONFIG, None, False, None, None, None,
-        None)
+        None, None, None)
     self.mock_device = mock.create_autospec(AdbDevice, instance=True,
                                             serial=TEST_SERIAL)
     self.mock_device.check_device_connection.return_value = None
@@ -384,7 +384,9 @@ class ProfilerCommandExecutorUnitTest(unittest.TestCase):
 
   @mock.patch.object(subprocess, "Popen", autospec=True)
   def test_execute_one_run_and_use_ui_success(self, mock_process):
-    with mock.patch("command_executor.open_trace", autospec=True):
+    with (mock.patch("src.command_executor.open_trace", autospec=True)
+          as mock_open_trace):
+      mock_open_trace.return_value = None
       self.command.use_ui = True
       self.mock_device.start_perfetto_trace.return_value = mock_process
 
@@ -393,6 +395,48 @@ class ProfilerCommandExecutorUnitTest(unittest.TestCase):
       self.assertEqual(error, None)
       self.assertEqual(self.mock_device.pull_file.call_count, 1)
 
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(subprocess, "Popen", autospec=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  def test_execute_one_simpleperf_run_success(self,
+      mock_exists, mock_process, mock_run):
+    with (mock.patch("src.command_executor.open_trace", autospec=True)
+          as mock_open_trace):
+      mock_open_trace.return_value = None
+      self.mock_device.start_simpleperf_trace.return_value = mock_process
+      mock_exists.return_value = True
+      mock_run.return_value = None
+      simpleperf_command = ProfilerCommand(
+          PROFILER_COMMAND_TYPE, "custom", "simpleperf", DEFAULT_OUT_DIR,
+          DEFAULT_DUR_MS, None, 1, None, DEFAULT_PERFETTO_CONFIG, None, False,
+          None, None, None, None, "/", "/")
+      simpleperf_command.use_ui = True
+
+      error = simpleperf_command.execute(self.mock_device)
+
+      self.assertEqual(error, None)
+      self.assertEqual(self.mock_device.pull_file.call_count, 1)
+
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(subprocess, "Popen", autospec=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  def test_execute_one_simpleperf_run_failure(self,
+      mock_exists, mock_process, mock_run):
+    with mock.patch("src.command_executor.open_trace", autospec=True):
+      self.mock_device.start_simpleperf_trace.return_value = mock_process
+      mock_exists.return_value = False
+      mock_run.return_value = None
+      simpleperf_command = ProfilerCommand(
+          PROFILER_COMMAND_TYPE, "custom", "simpleperf", DEFAULT_OUT_DIR,
+          DEFAULT_DUR_MS, None, 1, None, DEFAULT_PERFETTO_CONFIG, None, False,
+          None, None, None, None, "/", "/")
+      simpleperf_command.use_ui = True
+
+      with self.assertRaises(Exception) as e:
+        simpleperf_command.execute(self.mock_device)
+
+        self.assertEqual(str(e.exception), "Gecko file was not created.")
+
   @mock.patch.object(subprocess, "Popen", autospec=True)
   def test_execute_one_run_no_ui_success(self, mock_process):
     self.mock_device.start_perfetto_trace.return_value = mock_process
@@ -563,9 +607,9 @@ class UserSwitchCommandExecutorUnitTest(unittest.TestCase):
 
   def setUp(self):
     self.command = ProfilerCommand(
-        PROFILER_COMMAND_TYPE, "user-switch", PROFILER_TYPE, DEFAULT_OUT_DIR,
+        PROFILER_COMMAND_TYPE, "user-switch", "perfetto", DEFAULT_OUT_DIR,
         DEFAULT_DUR_MS, None, 1, None, DEFAULT_PERFETTO_CONFIG, None, False,
-        None, None, None, None)
+        None, None, None, None, None, None)
     self.mock_device = mock.create_autospec(AdbDevice, instance=True,
                                             serial=TEST_SERIAL)
     self.mock_device.check_device_connection.return_value = None
@@ -687,9 +731,9 @@ class BootCommandExecutorUnitTest(unittest.TestCase):
 
   def setUp(self):
     self.command = ProfilerCommand(
-        PROFILER_COMMAND_TYPE, "boot", PROFILER_TYPE, DEFAULT_OUT_DIR,
+        PROFILER_COMMAND_TYPE, "boot", "perfetto", DEFAULT_OUT_DIR,
         TEST_DURATION, None, 1, None, DEFAULT_PERFETTO_CONFIG, TEST_DURATION,
-        False, None, None, None, None)
+        False, None, None, None, None, None, None)
     self.mock_device = mock.create_autospec(AdbDevice, instance=True,
                                             serial=TEST_SERIAL)
     self.mock_device.check_device_connection.return_value = None
@@ -801,9 +845,9 @@ class AppStartupExecutorUnitTest(unittest.TestCase):
 
   def setUp(self):
     self.command = ProfilerCommand(
-        PROFILER_COMMAND_TYPE, "app-startup", PROFILER_TYPE, DEFAULT_OUT_DIR,
+        PROFILER_COMMAND_TYPE, "app-startup", "perfetto", DEFAULT_OUT_DIR,
         DEFAULT_DUR_MS, TEST_PACKAGE_1, 1, None, DEFAULT_PERFETTO_CONFIG, None,
-        False, None, None, None, None)
+        False, None, None, None, None, None, None)
     self.mock_device = mock.create_autospec(AdbDevice, instance=True,
                                             serial=TEST_SERIAL)
     self.mock_device.check_device_connection.return_value = None
diff --git a/torq/tests/torq_unit_test.py b/torq/tests/torq_unit_test.py
index 5a0e4a91..88a115ba 100644
--- a/torq/tests/torq_unit_test.py
+++ b/torq/tests/torq_unit_test.py
@@ -18,7 +18,7 @@ import unittest
 import sys
 import os
 from unittest import mock
-from torq import create_parser, verify_args, get_command_type,\
+from src.torq import create_parser, verify_args, get_command_type,\
   DEFAULT_DUR_MS, DEFAULT_OUT_DIR
 
 TEST_USER_ID = 10
@@ -30,9 +30,8 @@ SYMBOLS_PATH = "/folder/symbols"
 class TorqUnitTest(unittest.TestCase):
 
   def set_up_parser(self, command_string):
-    parser = create_parser()
     sys.argv = command_string.split()
-    return parser
+    return create_parser()
 
   # TODO(b/285191111): Parameterize the test functions.
   def test_create_parser_default_values(self):
@@ -759,18 +758,6 @@ class TorqUnitTest(unittest.TestCase):
   def test_verify_args_invalid_mixing_of_profiler_and_config_subcommand(self):
     parser = self.set_up_parser("torq.py -d 20000 config pull lightweight")
 
-    args = parser.parse_args()
-    args, error = verify_args(args)
-
-    self.assertEqual(error.message, ("Command is invalid because profiler"
-                                     " command is followed by a config"
-                                     " command."))
-    self.assertEqual(error.suggestion, ("Remove the 'config' subcommand to"
-                                        " profile the device instead."))
-
-  def test_create_parser_invalid_mixing_of_profiler_and_config_subcommand(self):
-    parser = self.set_up_parser("torq.py config pull lightweight -d 20000")
-
     with self.assertRaises(SystemExit):
       parser.parse_args()
 
diff --git a/torq/tests/utils_unit_test.py b/torq/tests/utils_unit_test.py
new file mode 100644
index 00000000..23ce6bd4
--- /dev/null
+++ b/torq/tests/utils_unit_test.py
@@ -0,0 +1,53 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import unittest
+import subprocess
+import os
+from unittest import mock
+from src.device import AdbDevice
+from src.utils import convert_simpleperf_to_gecko
+
+
+class UtilsUnitTest(unittest.TestCase):
+
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  def test_convert_simpleperf_to_gecko_success(self, mock_exists,
+      mock_subprocess_run):
+    mock_exists.return_value = True
+    mock_subprocess_run.return_value = None
+
+    # No exception is expected to be thrown
+    convert_simpleperf_to_gecko("/scripts", "/path/file.data",
+                                "/path/file.json", "/symbols")
+
+  @mock.patch.object(subprocess, "run", autospec=True)
+  @mock.patch.object(os.path, "exists", autospec=True)
+  def test_convert_simpleperf_to_gecko_failure(self, mock_exists,
+      mock_subprocess_run):
+    mock_exists.return_value = False
+    mock_subprocess_run.return_value = None
+
+    with self.assertRaises(Exception) as e:
+      convert_simpleperf_to_gecko("/scripts", "/path/file.data",
+                                  "/path/file.json", "/symbols")
+
+      self.assertEqual(str(e.exception), "Gecko file was not created.")
+
+
+if __name__ == '__main__':
+  unittest.main()
diff --git a/torq/tests/validate_simpleperf_unit_test.py b/torq/tests/validate_simpleperf_unit_test.py
index 3eec988d..8abca598 100644
--- a/torq/tests/validate_simpleperf_unit_test.py
+++ b/torq/tests/validate_simpleperf_unit_test.py
@@ -20,7 +20,7 @@ import sys
 import os
 import subprocess
 from unittest import mock
-from torq import create_parser, verify_args
+from src.torq import create_parser, verify_args
 
 TORQ_TEMP_DIR = "/tmp/.torq"
 ANDROID_BUILD_TOP = "/folder"
@@ -31,9 +31,8 @@ SYMBOLS_PATH = "/folder/symbols"
 class ValidateSimpleperfUnitTest(unittest.TestCase):
 
   def set_up_parser(self, command_string):
-    parser = create_parser()
     sys.argv = command_string.split()
-    return parser
+    return create_parser()
 
   @mock.patch.object(os.path, "exists", autospec=True)
   @mock.patch.object(os.path, "isdir", autospec=True)
diff --git a/torq/tools/torq_test b/torq/tools/torq_test
new file mode 100755
index 00000000..c813707c
--- /dev/null
+++ b/torq/tools/torq_test
@@ -0,0 +1,64 @@
+#!/usr/bin/env python
+#
+# Copyright (C) 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+import os
+import subprocess
+import sys
+
+"""
+This script runs all of Torq's unit tests specified in
+the Android.bp file.
+
+All tests can be run with:
+    ./torq_test
+
+You can filter to only run specific tests with:
+    ./torq_test torq_unit_test device_unit_test
+"""
+if __name__ == "__main__":
+  # Find the Android.bp file
+  script_dir = os.path.dirname(os.path.abspath(__file__))
+  android_bp_path = os.path.join(script_dir, '..', 'Android.bp')
+
+  # Get all test names
+  tests = []
+  has_pending_test = False
+  try:
+    with open(android_bp_path, 'r') as f:
+      for line in f:
+        text = line.strip()
+        if 'python_test_host' in text:
+            has_pending_test = True
+        elif has_pending_test and 'name' in text:
+            # parse the test host name
+            tests.append(text.split(':')[-1].strip()[1:-2])
+            has_pending_test = False
+  except FileNotFoundError:
+    print(f"Error: Android.bp file not found at: {android_bp_path}")
+    sys.exit(1)
+  except Exception as e:
+    print(f"Error reading Android.bp: {e}")
+    sys.exit(1)
+
+  # Filter out unwanted tests
+  filter_tests = sys.argv[1:]
+  if len(filter_tests) > 0:
+    tests = list(filter(lambda e: e in filter_tests, tests))
+
+  cmd = ['atest'] + tests
+  # Run atest for all the tests
+  subprocess.run(cmd)
diff --git a/torq/utils.py b/torq/utils.py
deleted file mode 100644
index 8716d9f9..00000000
--- a/torq/utils.py
+++ /dev/null
@@ -1,27 +0,0 @@
-#
-# Copyright (C) 2024 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-import os
-
-def path_exists(path: str):
-  if path is None:
-    return False
-  return os.path.exists(os.path.expanduser(path))
-
-def dir_exists(path: str):
-  if path is None:
-    return False
-  return os.path.isdir(os.path.expanduser(path))
diff --git a/verity/Android.bp b/verity/Android.bp
index f2e3f0b4..25148853 100644
--- a/verity/Android.bp
+++ b/verity/Android.bp
@@ -157,9 +157,4 @@ cc_test {
 python_binary_host {
     name: "build_verity_metadata",
     srcs: ["build_verity_metadata.py"],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
 }
```

