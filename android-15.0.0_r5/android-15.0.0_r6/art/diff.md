```diff
diff --git a/Android.bp b/Android.bp
index 83d72d1bcc..095d0aff3d 100644
--- a/Android.bp
+++ b/Android.bp
@@ -16,3 +16,47 @@ license {
         "NOTICE",
     ],
 }
+
+// The art-tools package depends on helpers and tools that are useful for
+// developers. Similar dependencies exist for the APEX builds for these tools
+// (see build/apex/Android.bp).
+phony {
+    name: "art-tools",
+    // If the dependencies have changed, please sync them to
+    // build/core/target/product/base_system.mk as well.
+    required: [
+        "ahat",
+        "dexdump",
+        "hprof-conv",
+        // A subset of the tools are disabled when HOST_PREFER_32_BIT is
+        // defined as make reports that they are not supported on host
+        // (b/129323791). This is likely due to art_apex disabling host APEX
+        // builds when HOST_PREFER_32_BIT is set (b/120617876).
+    ] + select(soong_config_variable("art_module", "host_prefer_32_bit"), {
+        true: [],
+        default: [
+            "dexlist",
+            "oatdump",
+        ],
+    }),
+}
+
+// Fake packages to ensure generation of libopenjdkd when one builds with mm/mmm/mmma.
+//
+// The library is required for starting a runtime in debug mode, but libartd does not depend on it
+// (dependency cycle otherwise).
+//
+// Note: * As the package is phony to create a dependency the package name is irrelevant.
+//       * We make MULTILIB explicit to "both," just to state here that we want both libraries on
+//         64-bit systems, even if it is the default.
+phony_rule {
+    name: "art-libartd-libopenjdkd-host-dependency",
+    phony_deps: [
+        "libopenjdkd",
+    ],
+    compile_multilib: "both",
+    enabled: select(soong_config_variable("art_module", "art_build_host_debug"), {
+        false: false,
+        default: true,
+    }),
+}
diff --git a/Android.mk b/Android.mk
index 6ab2fb5cbe..f83c13cdf9 100644
--- a/Android.mk
+++ b/Android.mk
@@ -25,36 +25,6 @@ include $(art_path)/build/Android.common_path.mk
 
 include $(art_path)/build/Android.cpplint.mk
 
-########################################################################
-# The art-tools package depends on helpers and tools that are useful for developers. Similar
-# dependencies exist for the APEX builds for these tools (see build/apex/Android.bp).
-
-ifneq ($(HOST_OS),darwin)
-include $(CLEAR_VARS)
-LOCAL_MODULE := art-tools
-LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
-LOCAL_LICENSE_CONDITIONS := notice
-LOCAL_NOTICE_FILE := $(LOCAL_PATH)/NOTICE
-LOCAL_IS_HOST_MODULE := true
-
-LOCAL_REQUIRED_MODULES := \
-    ahat \
-    dexdump \
-    hprof-conv \
-
-# A subset of the tools are disabled when HOST_PREFER_32_BIT is defined as make reports that
-# they are not supported on host (b/129323791). This is likely due to art_apex disabling host
-# APEX builds when HOST_PREFER_32_BIT is set (b/120617876).
-ifneq ($(HOST_PREFER_32_BIT),true)
-LOCAL_REQUIRED_MODULES += \
-    dexlist \
-    oatdump \
-
-endif
-
-include $(BUILD_PHONY_PACKAGE)
-endif # HOST_OS != darwin
-
 ########################################################################
 # product rules
 
@@ -277,31 +247,6 @@ endif
 # "include $(BUILD_...)".
 LOCAL_PATH := $(art_path)
 
-####################################################################################################
-# Fake packages to ensure generation of libopenjdkd when one builds with mm/mmm/mmma.
-#
-# The library is required for starting a runtime in debug mode, but libartd does not depend on it
-# (dependency cycle otherwise).
-#
-# Note: * As the package is phony to create a dependency the package name is irrelevant.
-#       * We make MULTILIB explicit to "both," just to state here that we want both libraries on
-#         64-bit systems, even if it is the default.
-
-# ART on the host.
-ifneq ($(HOST_OS),darwin)
-ifeq ($(ART_BUILD_HOST_DEBUG),true)
-include $(CLEAR_VARS)
-LOCAL_MODULE := art-libartd-libopenjdkd-host-dependency
-LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
-LOCAL_LICENSE_CONDITIONS := notice
-LOCAL_NOTICE_FILE := $(LOCAL_PATH)/NOTICE
-LOCAL_MULTILIB := both
-LOCAL_REQUIRED_MODULES := libopenjdkd
-LOCAL_IS_HOST_MODULE := true
-include $(BUILD_PHONY_PACKAGE)
-endif
-endif # HOST_OS != darwin
-
 ########################################################################
 # "m build-art" for quick minimal build
 .PHONY: build-art
@@ -479,11 +424,10 @@ endef
 # ART APEX.
 #
 # TODO(b/129332183): This approach is flawed: We mix DSOs from prebuilt APEXes
-# and prebuilts/runtime/mainline/platform/impl with source built ones, and both
-# may depend on the same DSOs, and some of them don't have stable ABIs.
-# libbase.so in particular is such a problematic dependency. When those
-# dependencies eventually don't work anymore we don't have much choice but to
-# update all prebuilts.
+# with source built ones, and some of them don't have stable ABIs. libbase.so in
+# particular is such a problematic dependency. When those dependencies
+# eventually don't work anymore we don't have much choice but to update all
+# prebuilts.
 .PHONY: standalone-apex-files
 standalone-apex-files: deapexer \
                        $(RELEASE_ART_APEX) \
@@ -493,19 +437,21 @@ standalone-apex-files: deapexer \
                        $(STATSD_APEX) \
                        $(TZDATA_APEX) \
                        $(HOST_OUT)/bin/generate-boot-image64 \
-                       $(HOST_OUT)/bin/dex2oat64
+                       $(HOST_OUT)/bin/dex2oat64 \
+                       libartpalette_fake \
+                       art_fake_heapprofd_client_api
 	$(call extract-from-apex,$(RELEASE_ART_APEX),\
 	  $(PRIVATE_ART_APEX_DEPENDENCY_LIBS) $(PRIVATE_ART_APEX_DEPENDENCY_FILES))
 	# The Runtime APEX has the Bionic libs in ${LIB}/bionic subdirectories,
 	# so we need to move them up a level after extraction.
-	# Also, platform libraries are installed in prebuilts, so copy them over.
+	# Also, copy fake platform libraries.
 	$(call extract-from-apex,$(RUNTIME_APEX),\
 	  $(PRIVATE_RUNTIME_APEX_DEPENDENCY_FILES)) && \
 	  libdir=$(TARGET_OUT)/lib$$(expr $(TARGET_ARCH) : '.*\(64\)' || :) && \
 	  if [ -d $$libdir/bionic ]; then \
 	    mv -f $$libdir/bionic/*.so $$libdir; \
 	  fi && \
-	  cp prebuilts/runtime/mainline/platform/impl/$(TARGET_ARCH)/*.so $$libdir
+	  cp $$libdir/art_fake/*.so $$libdir
 	$(call extract-from-apex,$(CONSCRYPT_APEX),\
 	  $(PRIVATE_CONSCRYPT_APEX_DEPENDENCY_LIBS))
 	$(call extract-from-apex,$(I18N_APEX),\
@@ -528,15 +474,25 @@ standalone-apex-files: deapexer \
 
 .PHONY: build-art-target-golem
 
+ART_TARGET_PLATFORM_LIBS := \
+  libcutils \
+  libprocessgroup \
+  libprocinfo \
+  libselinux \
+  libtombstoned_client \
+  libz \
+
 ART_TARGET_PLATFORM_DEPENDENCIES := \
   $(TARGET_OUT)/etc/public.libraries.txt \
-  $(TARGET_OUT_SHARED_LIBRARIES)/libcutils.so \
-  $(TARGET_OUT_SHARED_LIBRARIES)/liblz4.so \
-  $(TARGET_OUT_SHARED_LIBRARIES)/libprocessgroup.so \
-  $(TARGET_OUT_SHARED_LIBRARIES)/libprocinfo.so \
-  $(TARGET_OUT_SHARED_LIBRARIES)/libselinux.so \
-  $(TARGET_OUT_SHARED_LIBRARIES)/libtombstoned_client.so \
-  $(TARGET_OUT_SHARED_LIBRARIES)/libz.so \
+  $(foreach lib,$(ART_TARGET_PLATFORM_LIBS), $(TARGET_OUT_SHARED_LIBRARIES)/$(lib).so)
+ifdef TARGET_2ND_ARCH
+ART_TARGET_PLATFORM_DEPENDENCIES += \
+  $(foreach lib,$(ART_TARGET_PLATFORM_LIBS), $(2ND_TARGET_OUT_SHARED_LIBRARIES)/$(lib).so)
+endif
+
+# Despite `liblz4` being included in the ART apex, Golem benchmarks need another one in /system/ .
+ART_TARGET_PLATFORM_DEPENDENCIES_GOLEM= \
+  $(TARGET_OUT_SHARED_LIBRARIES)/liblz4.so
 
 # Also include libartbenchmark, we always include it when running golem.
 # libstdc++ is needed when building for ART_TARGET_LINUX.
@@ -546,6 +502,7 @@ build-art-target-golem: $(RELEASE_ART_APEX) com.android.runtime $(CONSCRYPT_APEX
                         $(TARGET_OUT_EXECUTABLES)/art \
                         $(TARGET_OUT_EXECUTABLES)/dex2oat_wrapper \
                         $(ART_TARGET_PLATFORM_DEPENDENCIES) \
+                        $(ART_TARGET_PLATFORM_DEPENDENCIES_GOLEM) \
                         $(ART_TARGET_SHARED_LIBRARY_BENCHMARK) \
                         $(TARGET_OUT_SHARED_LIBRARIES)/libgolemtiagent.so \
                         standalone-apex-files
@@ -584,11 +541,14 @@ build-art-host-tests: build-art-host-gtests build-art-host-run-tests
 
 .PHONY: build-art-target-gtests build-art-target-run-tests build-art-target-tests
 
-build-art-target-gtests: build-art-target $(ART_TEST_TARGET_GTEST_DEPENDENCIES)
+build-art-target-gtests: build-art-target \
+                         $(ART_TEST_TARGET_GTEST_DEPENDENCIES) \
+                         $(ART_TARGET_PLATFORM_DEPENDENCIES)
 
 build-art-target-run-tests: build-art-target \
                             $(TEST_ART_RUN_TEST_DEPENDENCIES) \
                             $(ART_TEST_TARGET_RUN_TEST_DEPENDENCIES) \
+                            $(ART_TARGET_PLATFORM_DEPENDENCIES) \
                             art-run-test-target-data
 
 build-art-target-tests: build-art-target-gtests build-art-target-run-tests
diff --git a/OWNERS b/OWNERS
index 9965354cbb..1643bc04ff 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,11 +1,15 @@
 # Bug component: 86431
+dobrota@google.com
 dsrbecky@google.com
 hboehm@google.com
+ishcheikin@google.com
+islamelbanna@google.com
 jiakaiz@google.com
 lokeshgidra@google.com
 mast@google.com
 mythria@google.com
 ngeoffray@google.com
+prashantdubey@google.com
 rpl@google.com
 scianciulli@google.com
 skvadrik@google.com
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 1b48489d6e..29ecd3bfe3 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -31,6 +31,9 @@
     {
       "name": "art-run-test-011-array-copy"
     },
+    {
+      "name": "art-run-test-011-array-copy2"
+    },
     {
       "name": "art-run-test-012-math"
     },
@@ -451,6 +454,9 @@
     {
       "name": "art-run-test-2244-checker-remove-try-boundary"
     },
+    {
+      "name": "art-run-test-2247-checker-write-barrier-elimination"
+    },
     {
       "name": "art-run-test-2249-checker-return-try-boundary-exit-in-loop"
     },
@@ -500,7 +506,28 @@
       "name": "art-run-test-2268-checker-remove-dead-phis"
     },
     {
-      "name": "art-run-test-2269-checker-constant-folding-instrinsics"
+      "name": "art-run-test-2269-checker-constant-folding-intrinsics"
+    },
+    {
+      "name": "art-run-test-2273-checker-unreachable-intrinsics"
+    },
+    {
+      "name": "art-run-test-2274-checker-bitwise-gvn"
+    },
+    {
+      "name": "art-run-test-2275-checker-empty-loops"
+    },
+    {
+      "name": "art-run-test-2275-integral-unsigned-arithmetic"
+    },
+    {
+      "name": "art-run-test-2278-nested-loops"
+    },
+    {
+      "name": "art-run-test-2279-aconfig-flags"
+    },
+    {
+      "name": "art-run-test-2279-second-inner-loop-references-first"
     },
     {
       "name": "art-run-test-300-package-override"
@@ -670,6 +697,9 @@
     {
       "name": "art-run-test-456-baseline-array-set"
     },
+    {
+      "name": "art-run-test-458-checker-riscv64-shift-add"
+    },
     {
       "name": "art-run-test-458-long-to-fpu"
     },
@@ -1342,6 +1372,12 @@
     {
       "name": "art-run-test-853-checker-inlining"
     },
+    {
+      "name": "art-run-test-856-clone"
+    },
+    {
+      "name": "art-run-test-857-default-access"
+    },
     {
       "name": "art-run-test-963-default-range-smali"
     },
@@ -1377,6 +1413,9 @@
     {
       "name": "art_standalone_dexlist_tests"
     },
+    {
+      "name": "art_standalone_dexopt_chroot_setup_tests"
+    },
     {
       "name": "art_standalone_dexoptanalyzer_tests"
     },
@@ -1421,6 +1460,9 @@
     {
       "name": "art_standalone_sigchain_tests"
     },
+    {
+      "name": "libnativebridge-tests"
+    },
     {
       "name": "libnativeloader_e2e_tests"
     },
@@ -1459,6 +1501,9 @@
     {
       "name": "art-run-test-011-array-copy[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-011-array-copy2[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-012-math[com.google.android.art.apex]"
     },
@@ -1879,6 +1924,9 @@
     {
       "name": "art-run-test-2244-checker-remove-try-boundary[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-2247-checker-write-barrier-elimination[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-2249-checker-return-try-boundary-exit-in-loop[com.google.android.art.apex]"
     },
@@ -1928,7 +1976,28 @@
       "name": "art-run-test-2268-checker-remove-dead-phis[com.google.android.art.apex]"
     },
     {
-      "name": "art-run-test-2269-checker-constant-folding-instrinsics[com.google.android.art.apex]"
+      "name": "art-run-test-2269-checker-constant-folding-intrinsics[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2273-checker-unreachable-intrinsics[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2274-checker-bitwise-gvn[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2275-checker-empty-loops[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2275-integral-unsigned-arithmetic[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2278-nested-loops[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2279-aconfig-flags[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2279-second-inner-loop-references-first[com.google.android.art.apex]"
     },
     {
       "name": "art-run-test-300-package-override[com.google.android.art.apex]"
@@ -2098,6 +2167,9 @@
     {
       "name": "art-run-test-456-baseline-array-set[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-458-checker-riscv64-shift-add[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-458-long-to-fpu[com.google.android.art.apex]"
     },
@@ -2770,6 +2842,12 @@
     {
       "name": "art-run-test-853-checker-inlining[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-856-clone[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-857-default-access[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-963-default-range-smali[com.google.android.art.apex]"
     },
@@ -2805,6 +2883,9 @@
     {
       "name": "art_standalone_dexlist_tests[com.google.android.art.apex]"
     },
+    {
+      "name": "art_standalone_dexopt_chroot_setup_tests[com.google.android.art.apex]"
+    },
     {
       "name": "art_standalone_dexoptanalyzer_tests[com.google.android.art.apex]"
     },
@@ -2905,6 +2986,9 @@
     {
       "name": "art-run-test-011-array-copy"
     },
+    {
+      "name": "art-run-test-011-array-copy2"
+    },
     {
       "name": "art-run-test-012-math"
     },
@@ -3325,6 +3409,9 @@
     {
       "name": "art-run-test-2244-checker-remove-try-boundary"
     },
+    {
+      "name": "art-run-test-2247-checker-write-barrier-elimination"
+    },
     {
       "name": "art-run-test-2249-checker-return-try-boundary-exit-in-loop"
     },
@@ -3374,7 +3461,28 @@
       "name": "art-run-test-2268-checker-remove-dead-phis"
     },
     {
-      "name": "art-run-test-2269-checker-constant-folding-instrinsics"
+      "name": "art-run-test-2269-checker-constant-folding-intrinsics"
+    },
+    {
+      "name": "art-run-test-2273-checker-unreachable-intrinsics"
+    },
+    {
+      "name": "art-run-test-2274-checker-bitwise-gvn"
+    },
+    {
+      "name": "art-run-test-2275-checker-empty-loops"
+    },
+    {
+      "name": "art-run-test-2275-integral-unsigned-arithmetic"
+    },
+    {
+      "name": "art-run-test-2278-nested-loops"
+    },
+    {
+      "name": "art-run-test-2279-aconfig-flags"
+    },
+    {
+      "name": "art-run-test-2279-second-inner-loop-references-first"
     },
     {
       "name": "art-run-test-300-package-override"
@@ -3544,6 +3652,9 @@
     {
       "name": "art-run-test-456-baseline-array-set"
     },
+    {
+      "name": "art-run-test-458-checker-riscv64-shift-add"
+    },
     {
       "name": "art-run-test-458-long-to-fpu"
     },
@@ -4216,6 +4327,12 @@
     {
       "name": "art-run-test-853-checker-inlining"
     },
+    {
+      "name": "art-run-test-856-clone"
+    },
+    {
+      "name": "art-run-test-857-default-access"
+    },
     {
       "name": "art-run-test-963-default-range-smali"
     },
@@ -4341,6 +4458,9 @@
     {
       "name": "art-run-test-011-array-copy"
     },
+    {
+      "name": "art-run-test-011-array-copy2"
+    },
     {
       "name": "art-run-test-012-math"
     },
@@ -4761,6 +4881,9 @@
     {
       "name": "art-run-test-2244-checker-remove-try-boundary"
     },
+    {
+      "name": "art-run-test-2247-checker-write-barrier-elimination"
+    },
     {
       "name": "art-run-test-2249-checker-return-try-boundary-exit-in-loop"
     },
@@ -4810,7 +4933,28 @@
       "name": "art-run-test-2268-checker-remove-dead-phis"
     },
     {
-      "name": "art-run-test-2269-checker-constant-folding-instrinsics"
+      "name": "art-run-test-2269-checker-constant-folding-intrinsics"
+    },
+    {
+      "name": "art-run-test-2273-checker-unreachable-intrinsics"
+    },
+    {
+      "name": "art-run-test-2274-checker-bitwise-gvn"
+    },
+    {
+      "name": "art-run-test-2275-checker-empty-loops"
+    },
+    {
+      "name": "art-run-test-2275-integral-unsigned-arithmetic"
+    },
+    {
+      "name": "art-run-test-2278-nested-loops"
+    },
+    {
+      "name": "art-run-test-2279-aconfig-flags"
+    },
+    {
+      "name": "art-run-test-2279-second-inner-loop-references-first"
     },
     {
       "name": "art-run-test-300-package-override"
@@ -4980,6 +5124,9 @@
     {
       "name": "art-run-test-456-baseline-array-set"
     },
+    {
+      "name": "art-run-test-458-checker-riscv64-shift-add"
+    },
     {
       "name": "art-run-test-458-long-to-fpu"
     },
@@ -5652,6 +5799,12 @@
     {
       "name": "art-run-test-853-checker-inlining"
     },
+    {
+      "name": "art-run-test-856-clone"
+    },
+    {
+      "name": "art-run-test-857-default-access"
+    },
     {
       "name": "art-run-test-963-default-range-smali"
     },
@@ -5738,10 +5891,10 @@
   ],
   "postsubmit": [
     {
-      "name": "art-run-test-2247-checker-write-barrier-elimination"
+      "name": "art-run-test-057-math-intrinsics"
     },
     {
-      "name": "art-run-test-2273-checker-unreachable-intrinsics"
+      "name": "art_standalone_dex2oat_cts_tests"
     }
   ]
 }
diff --git a/artd/Android.bp b/artd/Android.bp
index e1768c8868..ea4de5219f 100644
--- a/artd/Android.bp
+++ b/artd/Android.bp
@@ -45,6 +45,11 @@ cc_defaults {
         "artd-aidl-ndk",
         "libfstab",
     ],
+    target: {
+        android: {
+            compile_multilib: "first",
+        },
+    },
 }
 
 art_cc_binary {
@@ -84,7 +89,7 @@ art_cc_defaults {
     ],
 }
 
-// Version of ART gtest `art_artd_tests` bundled with the ART APEX on target.
+// Version of ART gtest `art_artd_tests` for host.
 //
 // This test requires the full libbinder_ndk implementation on host, which is
 // not available as a prebuilt on the thin master-art branch. Hence it won't
@@ -92,6 +97,7 @@ art_cc_defaults {
 // test-art-host-gtest.
 art_cc_test {
     name: "art_artd_tests",
+    device_supported: false,
     defaults: [
         "art_gtest_defaults",
         "art_artd_tests_defaults",
diff --git a/artd/art_standalone_artd_tests.xml b/artd/art_standalone_artd_tests.xml
index 951e7acb05..c132b010b1 100644
--- a/artd/art_standalone_artd_tests.xml
+++ b/artd/art_standalone_artd_tests.xml
@@ -15,23 +15,17 @@
 -->
 <!-- Note: This test config file for {MODULE} is generated from a template. -->
 <configuration description="Runs {MODULE}.">
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.art.apex" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.android.art.apex" />
 
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
         <option name="cleanup" value="true" />
-        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}/{MODULE}" />
-        <option name="append-bitness" value="true" />
-    </target_preparer>
-
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-        <option name="cleanup" value="true" />
-        <option name="push" value="art-gtest-jars-Main.jar->/data/local/tmp/{MODULE}/art-gtest-jars-Main.jar" />
-        <option name="push" value="art-gtest-jars-Nested.jar->/data/local/tmp/{MODULE}/art-gtest-jars-Nested.jar" />
+        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
     </target_preparer>
 
     <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/{MODULE}" />
+        <option name="native-test-device-path" value="/data/local/tmp" />
         <option name="module-name" value="{MODULE}" />
     </test>
 
diff --git a/artd/artd.cc b/artd/artd.cc
index 1173dfd284..493cc10926 100644
--- a/artd/artd.cc
+++ b/artd/artd.cc
@@ -1171,22 +1171,33 @@ ndk::ScopedAStatus Artd::dexopt(
             << "\nOpened FDs: " << fd_logger;
 
   ProcessStat stat;
-  Result<int> result = ExecAndReturnCode(
-      art_exec_args.Get(), kLongTimeoutSec, cancellation_signal->CreateExecCallbacks(), &stat);
+  std::string error_msg;
+  ExecResult result = exec_utils_->ExecAndReturnResult(art_exec_args.Get(),
+                                                       kLongTimeoutSec,
+                                                       cancellation_signal->CreateExecCallbacks(),
+                                                       /*new_process_group=*/true,
+                                                       &stat,
+                                                       &error_msg);
   _aidl_return->wallTimeMs = stat.wall_time_ms;
   _aidl_return->cpuTimeMs = stat.cpu_time_ms;
-  if (!result.ok()) {
+
+  auto result_info = ART_FORMAT("[status={},exit_code={},signal={}]",
+                                static_cast<int>(result.status),
+                                result.exit_code,
+                                result.signal);
+  if (result.status != ExecResult::kExited) {
     if (cancellation_signal->IsCancelled()) {
       _aidl_return->cancelled = true;
       return ScopedAStatus::ok();
     }
-    return NonFatal("Failed to run dex2oat: " + result.error().message());
+    return NonFatal(ART_FORMAT("Failed to run dex2oat: {} {}", error_msg, result_info));
   }
 
-  LOG(INFO) << ART_FORMAT("dex2oat returned code {}", result.value());
+  LOG(INFO) << ART_FORMAT("dex2oat returned code {}", result.exit_code);
 
-  if (result.value() != 0) {
-    return NonFatal(ART_FORMAT("dex2oat returned an unexpected code: {}", result.value()));
+  if (result.exit_code != 0) {
+    return NonFatal(
+        ART_FORMAT("dex2oat returned an unexpected code: {} {}", result.exit_code, result_info));
   }
 
   int64_t size_bytes = 0;
@@ -1604,8 +1615,17 @@ bool Artd::DenyArtApexDataFilesLocked() {
 Result<std::string> Artd::GetProfman() { return BuildArtBinPath("profman"); }
 
 Result<CmdlineBuilder> Artd::GetArtExecCmdlineBuilder() {
+  std::string art_exec_path = OR_RETURN(BuildArtBinPath("art_exec"));
+  if (options_.is_pre_reboot) {
+    // "/mnt/compat_env" is prepared by dexopt_chroot_setup on Android V.
+    std::string compat_art_exec_path = "/mnt/compat_env" + art_exec_path;
+    if (OS::FileExists(compat_art_exec_path.c_str())) {
+      art_exec_path = std::move(compat_art_exec_path);
+    }
+  }
+
   CmdlineBuilder args;
-  args.Add(OR_RETURN(BuildArtBinPath("art_exec")))
+  args.Add(art_exec_path)
       .Add("--drop-capabilities")
       .AddIf(options_.is_pre_reboot, "--process-name-suffix=Pre-reboot Dexopt chroot");
   return args;
@@ -1935,10 +1955,11 @@ Result<BuildSystemProperties> BuildSystemProperties::Create(const std::string& f
   if (!ReadFileToString(filename, &content)) {
     return ErrnoErrorf("Failed to read '{}'", filename);
   }
+  std::regex import_pattern(R"re(import\s.*)re");
   std::unordered_map<std::string, std::string> system_properties;
   for (const std::string& raw_line : Split(content, "\n")) {
     std::string line = Trim(raw_line);
-    if (line.empty() || line.starts_with('#')) {
+    if (line.empty() || line.starts_with('#') || std::regex_match(line, import_pattern)) {
       continue;
     }
     size_t pos = line.find('=');
diff --git a/artd/artd.h b/artd/artd.h
index 0733f098be..3b3375b841 100644
--- a/artd/artd.h
+++ b/artd/artd.h
@@ -342,6 +342,9 @@ class Artd : public aidl::com::android::server::art::BnArtd {
 };
 
 // A class for getting system properties from a `build.prop` file.
+// Note that this class ignores import statements and only reads properties from the given file
+// itself. To read properties from an imported file, insatiate this class with the imported file
+// directly.
 class BuildSystemProperties : public tools::SystemProperties {
  public:
   // Creates an instance and loads system properties from the `build.prop` file specified at the
diff --git a/artd/artd_test.cc b/artd/artd_test.cc
index 285dd5022f..34950eee74 100644
--- a/artd/artd_test.cc
+++ b/artd/artd_test.cc
@@ -65,7 +65,6 @@
 #include "testing.h"
 #include "tools/binder_utils.h"
 #include "tools/system_properties.h"
-#include "tools/tools.h"
 #include "ziparchive/zip_writer.h"
 
 extern char** environ;
@@ -101,7 +100,6 @@ using ::android::base::Split;
 using ::android::base::WriteStringToFd;
 using ::android::base::WriteStringToFile;
 using ::android::base::testing::HasValue;
-using ::art::tools::GetProcMountsAncestorsOfPath;
 using ::testing::_;
 using ::testing::AllOf;
 using ::testing::AnyNumber;
@@ -133,6 +131,11 @@ using WritableProfilePath = ProfilePath::WritableProfilePath;
 
 using std::literals::operator""s;  // NOLINT
 
+// User build is missing the SELinux permission for the test process (run as `shell`) to reopen
+// the memfd that it creates itself
+// (https://cs.android.com/android/platform/superproject/main/+/main:system/sepolicy/private/shell.te;l=221;drc=3335a04676d400bda57d42d4af0ef4b1d311de21).
+#define TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS() TEST_DISABLED_FOR_USER_BUILD()
+
 ScopeGuard<std::function<void()>> ScopedSetLogger(android::base::LogFunction&& logger) {
   android::base::LogFunction old_logger = android::base::SetLogger(std::move(logger));
   return make_scope_guard([old_logger = std::move(old_logger)]() mutable {
@@ -310,8 +313,9 @@ class MockExecUtils : public ExecUtils {
     Result<int> code = DoExecAndReturnCode(arg_vector, callbacks, stat);
     if (code.ok()) {
       return {.status = ExecResult::kExited, .exit_code = code.value()};
+    } else {
+      return {.status = ExecResult::kSignaled, .signal = SIGKILL};
     }
-    return {.status = ExecResult::kUnknown};
   }
 
   MOCK_METHOD(Result<int>,
@@ -1110,14 +1114,29 @@ TEST_F(ArtdTest, dexoptAllResourceControlBackground) {
   RunDexopt();
 }
 
+TEST_F(ArtdTest, dexoptTerminatedBySignal) {
+  EXPECT_CALL(*mock_exec_utils_, DoExecAndReturnCode(_, _, _))
+      .WillOnce(Return(Result<int>(Error())));
+  RunDexopt(AllOf(Property(&ndk::ScopedAStatus::getExceptionCode, EX_SERVICE_SPECIFIC),
+                  Property(&ndk::ScopedAStatus::getMessage,
+                           HasSubstr(ART_FORMAT("[status={},exit_code=-1,signal={}]",
+                                                static_cast<int>(ExecResult::kSignaled),
+                                                SIGKILL)))));
+}
+
 TEST_F(ArtdTest, dexoptFailed) {
   dexopt_options_.generateAppImage = true;
+  constexpr int kExitCode = 135;
   EXPECT_CALL(*mock_exec_utils_, DoExecAndReturnCode(_, _, _))
       .WillOnce(DoAll(WithArg<0>(WriteToFdFlag("--oat-fd=", "new_oat")),
                       WithArg<0>(WriteToFdFlag("--output-vdex-fd=", "new_vdex")),
                       WithArg<0>(WriteToFdFlag("--app-image-fd=", "new_art")),
-                      Return(1)));
-  RunDexopt(EX_SERVICE_SPECIFIC);
+                      Return(kExitCode)));
+  RunDexopt(AllOf(Property(&ndk::ScopedAStatus::getExceptionCode, EX_SERVICE_SPECIFIC),
+                  Property(&ndk::ScopedAStatus::getMessage,
+                           HasSubstr(ART_FORMAT("[status={},exit_code={},signal=0]",
+                                                static_cast<int>(ExecResult::kExited),
+                                                kExitCode)))));
 
   CheckContent(scratch_path_ + "/a/oat/arm64/b.odex", "old_oat");
   CheckContent(scratch_path_ + "/a/oat/arm64/b.vdex", "old_vdex");
@@ -1581,6 +1600,8 @@ TEST_F(ArtdTest, copyAndRewriteProfileException) {
 }
 
 TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileSuccess) {
+  TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS();
+
   CreateZipWithSingleEntry(dex_file_, "assets/art-profile/baseline.prof", "valid_profile");
 
   EXPECT_CALL(
@@ -1610,6 +1631,8 @@ TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileSuccess) {
 
 // The input is a plain dex file.
 TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileNoProfilePlainDex) {
+  TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS();
+
   constexpr const char* kDexMagic = "dex\n";
   CreateFile(dex_file_, kDexMagic + "dex_code"s);
 
@@ -1622,6 +1645,8 @@ TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileNoProfilePlainDex) {
 
 // The input is neither a zip nor a plain dex file.
 TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileNotZipNotDex) {
+  TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS();
+
   CreateFile(dex_file_, "wrong_format");
 
   auto [status, dst] = OR_FAIL(RunCopyAndRewriteEmbeddedProfile</*kExpectOk=*/false>());
@@ -1635,6 +1660,8 @@ TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileNotZipNotDex) {
 
 // The input is a zip file without a profile entry.
 TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileNoProfileZipNoEntry) {
+  TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS();
+
   CreateZipWithSingleEntry(dex_file_, "classes.dex", "dex_code");
 
   auto [result, dst] = OR_FAIL(RunCopyAndRewriteEmbeddedProfile());
@@ -1646,6 +1673,8 @@ TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileNoProfileZipNoEntry) {
 
 // The input is a zip file with a profile entry that doesn't match itself.
 TEST_F(ArtdTest, copyAndRewriteEmbeddedProfileBadProfileNoMatch) {
+  TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS();
+
   CreateZipWithSingleEntry(dex_file_, "assets/art-profile/baseline.prof", "no_match");
 
   EXPECT_CALL(*mock_exec_utils_, DoExecAndReturnCode(_, _, _))
@@ -2281,10 +2310,6 @@ TEST_F(ArtdCleanupTest, cleanUpPreRebootStagedFiles) {
 TEST_F(ArtdTest, isInDalvikCache) {
   TEST_DISABLED_FOR_HOST();
 
-  if (GetProcMountsAncestorsOfPath("/")->empty()) {
-    GTEST_SKIP() << "Skipped for chroot";
-  }
-
   auto is_in_dalvik_cache = [this](const std::string& dex_file) -> Result<bool> {
     bool result;
     ndk::ScopedAStatus status = artd_->isInDalvikCache(dex_file, &result);
@@ -2637,6 +2662,8 @@ TEST_F(ArtdTest, BuildSystemProperties) {
     property.bar?=000
     property.bar=789
     property.baz?=111
+    import /vendor/my_import.prop ro.*
+    import=222
   )";
 
   CreateFile(scratch_path_ + "/build.prop", kContent);
@@ -2645,6 +2672,7 @@ TEST_F(ArtdTest, BuildSystemProperties) {
   EXPECT_EQ(props.GetOrEmpty("property.foo"), "123");
   EXPECT_EQ(props.GetOrEmpty("property.bar"), "789");
   EXPECT_EQ(props.GetOrEmpty("property.baz"), "111");
+  EXPECT_EQ(props.GetOrEmpty("import"), "222");
 }
 
 class ArtdPreRebootTest : public ArtdTest {
@@ -2929,6 +2957,8 @@ TEST_F(ArtdPreRebootTest, copyAndRewriteProfile) {
 }
 
 TEST_F(ArtdPreRebootTest, copyAndRewriteEmbeddedProfile) {
+  TEST_DISABLED_FOR_SHELL_WITHOUT_MEMFD_ACCESS();
+
   CreateZipWithSingleEntry(dex_file_, "assets/art-profile/baseline.prof", "valid_profile");
 
   EXPECT_CALL(*mock_exec_utils_, DoExecAndReturnCode)
diff --git a/artd/binder/com/android/server/art/IArtd.aidl b/artd/binder/com/android/server/art/IArtd.aidl
index 47fc89966b..75b634dffa 100644
--- a/artd/binder/com/android/server/art/IArtd.aidl
+++ b/artd/binder/com/android/server/art/IArtd.aidl
@@ -155,7 +155,19 @@ interface IArtd {
     /**
      * Dexopts a dex file for the given instruction set.
      *
-     * Throws fatal and non-fatal errors.
+     * Throws fatal and non-fatal errors. When dexopt fails, the non-fatal status includes an error
+     * message containing a substring formatted as:
+     * [status=%STATUS%,exit_code=%EXIT_CODE%,signal=%SIGNAL%]
+     * where %STATUS% is the integer value of the corresponding ExecResultStatus enumeration defined
+     * in frameworks/proto_logging/stats/enums/art/common_enums.proto,
+     * %EXIT_CODE% is the exit code for the dex2oat process and set only when %STATUS% is set to
+     * EXEC_RESULT_STATUS_EXITED (-1 otherwsie),
+     * and %SIGNAL% is the signal that interrupted the dex2oat
+     * process and set only when %STATUS% is EXEC_RESULT_STATUS_SIGNALED (0 otherwise).
+     *
+     * The purpose of this format is to share information about the dex2oat run result with the
+     * ArtService code in Java that orchestrates the dexopt process, so that it can be reported to
+     * StatsD.
      */
     com.android.server.art.ArtdDexoptResult dexopt(
             in com.android.server.art.OutputArtifacts outputArtifacts,
diff --git a/build/Android.bp b/build/Android.bp
index b18888122b..e2d724b99e 100644
--- a/build/Android.bp
+++ b/build/Android.bp
@@ -76,13 +76,6 @@ art_clang_tidy_disabled = [
     "-modernize-use-using",
 ]
 
-soong_config_module_type_import {
-    from: "art/build/SoongConfig.bp",
-    module_types: [
-        "art_debug_defaults",
-    ],
-}
-
 art_global_defaults {
     // Additional flags are computed by art.go
 
@@ -285,7 +278,7 @@ cc_defaults {
     },
 }
 
-art_debug_defaults {
+cc_defaults {
     name: "art_debug_defaults",
     defaults: ["art_defaults"],
     visibility: ["//art:__subpackages__"],
@@ -293,7 +286,10 @@ art_debug_defaults {
         "-DDYNAMIC_ANNOTATIONS_ENABLED=1",
         "-DVIXL_DEBUG",
         "-UNDEBUG",
-    ],
+    ] + select(soong_config_variable("art_module", "art_debug_opt_flag"), {
+        any @ flag_val: [flag_val],
+        default: ["-Og"],
+    }),
     asflags: [
         "-UNDEBUG",
     ],
@@ -308,14 +304,6 @@ art_debug_defaults {
             cflags: ["-Wno-frame-larger-than="],
         },
     },
-    soong_config_variables: {
-        art_debug_opt_flag: {
-            cflags: ["%s"],
-            conditions_default: {
-                cflags: ["-Og"],
-            },
-        },
-    },
 }
 
 // A version of conscrypt only for enabling the "-hostdex" version to test ART on host.
@@ -342,6 +330,19 @@ java_library {
     },
 }
 
+// A version of conscrypt only for the ART fuzzer.
+java_library {
+    name: "conscrypt-fuzzer",
+    visibility: [
+        "//art/tools/fuzzer",
+    ],
+    static_libs: ["conscrypt-for-host"],
+    stem: "conscrypt",
+    compile_dex: true,
+    sdk_version: "none",
+    system_modules: "none",
+}
+
 // A version of core-icu4j only for enabling the "-hostdex" version to test ART on host.
 java_library {
     // We need our own name to not clash with the core-icu4j library.
diff --git a/build/Android.common_path.mk b/build/Android.common_path.mk
index 8a2829382f..95eeeb430a 100644
--- a/build/Android.common_path.mk
+++ b/build/Android.common_path.mk
@@ -132,7 +132,7 @@ TESTING_ART_APEX := com.android.art.testing
 RUNTIME_APEX := com.android.runtime
 CONSCRYPT_APEX := com.android.conscrypt
 I18N_APEX := com.android.i18n
-STATSD_APEX := com.android.os.statsd
+STATSD_APEX := art_fake_com.android.os.statsd
 TZDATA_APEX := com.android.tzdata
 
 # A phony file to create the ICU data file for host.
diff --git a/build/Android.gtest.mk b/build/Android.gtest.mk
index 3257942c6b..ae40d01db4 100644
--- a/build/Android.gtest.mk
+++ b/build/Android.gtest.mk
@@ -113,9 +113,6 @@ ART_TEST_MODULES_COMMON := \
     art_hiddenapi_tests \
     art_imgdiag_tests \
     art_libartbase_tests \
-    art_libartpalette_tests \
-    art_libartservice_tests \
-    art_libarttools_tests \
     art_libdexfile_external_tests \
     art_libdexfile_support_static_tests \
     art_libdexfile_support_tests \
@@ -133,10 +130,12 @@ ifeq (,$(SANITIZE_HOST))
 endif
 
 ART_TEST_MODULES_TARGET := $(ART_TEST_MODULES_COMMON) \
-    art_artd_tests \
     art_odrefresh_tests \
 
-ART_TEST_MODULES_HOST := $(ART_TEST_MODULES_COMMON)
+ART_TEST_MODULES_HOST := $(ART_TEST_MODULES_COMMON) \
+    art_libartpalette_tests \
+    art_libartservice_tests \
+    art_libarttools_tests \
 
 ifneq (,$(wildcard frameworks/native/libs/binder))
   # Only include the artd host tests if we have the binder sources available and
@@ -249,9 +248,6 @@ $$(gtest_build_rule) : $$(gtest_exe) $$(gtest_deps)
 .PHONY: $$(gtest_rule)
 $$(gtest_rule): $$(gtest_output)
 
-# Re-run the tests, even if nothing changed. Until the build system has a dedicated "no cache"
-# option, claim to write a file that is never produced.
-$$(gtest_output): .KATI_IMPLICIT_OUTPUTS := $$(gtest_output)-nocache
 # Limit concurrent runs. Each test itself is already highly parallel (and thus memory hungry).
 $$(gtest_output): .KATI_NINJA_POOL := highmem_pool
 $$(gtest_output): NAME := $$(gtest_rule)
diff --git a/build/SoongConfig.bp b/build/SoongConfig.bp
deleted file mode 100644
index d97349cc0e..0000000000
--- a/build/SoongConfig.bp
+++ /dev/null
@@ -1,10 +0,0 @@
-// Set up Soong config variables.
-// https://android.googlesource.com/platform/build/soong/+/master/README.md#soong-config-variables
-
-soong_config_module_type {
-    name: "art_debug_defaults",
-    module_type: "cc_defaults",
-    config_namespace: "art_module",
-    value_variables: ["art_debug_opt_flag"],
-    properties: ["cflags"],
-}
diff --git a/build/apex/Android.bp b/build/apex/Android.bp
index e882513801..312d40477d 100644
--- a/build/apex/Android.bp
+++ b/build/apex/Android.bp
@@ -20,8 +20,12 @@ art_runtime_binaries_both = [
 
 // Binaries for which the "first" version is preferred.
 art_runtime_binaries_first = [
+    "art_boot",
+    "art_exec",
+    "artd",
     "dexdump",
     "dexlist",
+    "dexopt_chroot_setup",
     "dexoptanalyzer",
     "oatdump",
     "profman",
@@ -57,9 +61,6 @@ art_runtime_base_native_shared_libs_minus_libart = [
     "libopenjdkjvm",
     "libopenjdkjvmti",
     "libperfetto_hprof",
-    // TODO(chriswailes): Make libarttools a dependency for another target
-    // when such a target exists
-    "libarttools",
 ]
 // Actual version of ART runtime base libs, used in non-test ART APEXes.
 art_runtime_base_native_shared_libs = ["libart"] +
@@ -191,21 +192,15 @@ apex_defaults {
     compat_configs: ["libcore-platform-compat-config"],
     native_shared_libs: art_runtime_base_native_shared_libs +
         libcore_native_shared_libs,
-    jni_libs: [
-        "libartservice",
-    ],
-    binaries: [
-        "art_boot",
-        "art_exec",
-        "artd",
-        "dexopt_chroot_setup",
-    ],
     multilib: {
         both: {
             binaries: art_runtime_binaries_both,
         },
         first: {
             binaries: art_runtime_binaries_first,
+            jni_libs: [
+                "libartservice",
+            ],
         },
     },
     key: "com.android.art.key",
@@ -241,15 +236,15 @@ apex_defaults {
     manifest: "manifest-art-debug.json",
     native_shared_libs: art_runtime_debug_native_shared_libs +
         libcore_debug_native_shared_libs,
-    jni_libs: [
-        "libartserviced",
-    ],
     multilib: {
         both: {
             binaries: art_debug_binaries_both,
         },
         first: {
             binaries: art_debug_binaries_first,
+            jni_libs: [
+                "libartserviced",
+            ],
         },
     },
 }
@@ -299,6 +294,23 @@ apex_test {
     installable: false,
 }
 
+// Same as "com.android.art" APEX, but also contains "imgdiag" binary.
+// Used to collect dirty-image-objects.
+apex_test {
+    name: "test_imgdiag_com.android.art",
+    defaults: ["com.android.art-defaults"],
+    multilib: {
+        both: {
+            binaries: ["imgdiag"],
+        },
+    },
+    key: "com.android.art.key",
+    manifest: "test_apex_manifest.json",
+    file_contexts: ":com.android.art-file_contexts",
+    certificate: ":com.android.art.certificate",
+    installable: false,
+}
+
 // Release version of the ART APEX module (not containing debug
 // variants nor tools), included in user builds. Also used for
 // storage-constrained devices in userdebug and eng builds.
@@ -319,11 +331,13 @@ apex {
     name: "com.android.art.debug",
     defaults: ["com.android.art-devel-defaults"],
     certificate: ":com.android.art.certificate",
+    visibility: [
+        "//packages/modules/common/build",
+    ],
 }
 
 // ART gtests with dependencies on internal ART APEX libraries.
 art_gtests = [
-    "art_artd_tests",
     "art_cmdline_tests",
     "art_compiler_tests",
     "art_dex2oat_tests",
@@ -334,19 +348,20 @@ art_gtests = [
     "art_dexoptanalyzer_tests",
     "art_imgdiag_tests",
     "art_libartbase_tests",
-    "art_libartpalette_tests",
-    "art_libartservice_tests",
-    "art_libarttools_tests",
     "art_libdexfile_tests",
     "art_libdexfile_support_tests",
     "art_libprofile_tests",
     "art_oatdump_tests",
-    "art_odrefresh_tests",
     "art_profman_tests",
     "art_runtime_tests",
     "art_sigchain_tests",
 ]
 
+// ART gtests for which the "first" version is preferred.
+art_gtests_first = [
+    "art_odrefresh_tests",
+]
+
 // "Testing" version of the ART APEX module (containing both release
 // and debug variants, additional tools, and ART gtests), for testing
 // purposes only.
@@ -372,12 +387,11 @@ apex_test {
     // and b/233357459). Marking this APEX as "future updatable"
     // disables all symlink optimizations for it.
     future_updatable: true,
-}
-
-// TODO(b/279835185) This is a placeholder to satisfy the current references.
-//   Remove this when all references are removed.
-host_snapshot {
-    name: "com.android.art.host",
+    multilib: {
+        first: {
+            tests: art_gtests_first,
+        },
+    },
 }
 
 python_binary_host {
diff --git a/build/apex/art.rc b/build/apex/art.rc
index 8a98a5f670..baadf3a6e7 100644
--- a/build/apex/art.rc
+++ b/build/apex/art.rc
@@ -26,6 +26,7 @@ service artd /apex/com.android.art/bin/artd
 # Same as above, but for Pre-reboot Dexopt. It runs in a chroot environment that
 # is set up by dexopt_chroot_setup. It's a lazy service that is started and
 # stopped dynamically as needed.
+# The path to the artd binary may be overridden by art_exec.
 service artd_pre_reboot /apex/com.android.art/bin/art_exec \
         --chroot=/mnt/pre_reboot_dexopt/chroot \
         --process-name-suffix="Pre-reboot Dexopt chroot" \
diff --git a/build/apex/art_apex_test.py b/build/apex/art_apex_test.py
index b1e0ebc8f2..1b82302d7a 100755
--- a/build/apex/art_apex_test.py
+++ b/build/apex/art_apex_test.py
@@ -525,7 +525,7 @@ class ReleaseChecker:
     self._checker.check_native_library('libart-disassembler')
     self._checker.check_native_library('libartbase')
     self._checker.check_native_library('libartpalette')
-    self._checker.check_native_library('libarttools')
+    self._checker.check_prefer64_library('libarttools')
     self._checker.check_native_library('libdt_fd_forward')
     self._checker.check_native_library('libopenjdkjvm')
     self._checker.check_native_library('libopenjdkjvmti')
@@ -595,7 +595,7 @@ class ReleaseTargetChecker:
     self._checker.check_symlinked_multilib_executable('dex2oat')
 
     # Check internal libraries for ART.
-    self._checker.check_native_library('libartservice')
+    self._checker.check_prefer64_library('libartservice')
     self._checker.check_native_library('libperfetto_hprof')
 
     # Check internal Java libraries
@@ -677,7 +677,7 @@ class DebugTargetChecker:
     self._checker.check_symlinked_multilib_executable('dex2oatd')
 
     # Check ART internal libraries.
-    self._checker.check_native_library('libartserviced')
+    self._checker.check_prefer64_library('libartserviced')
     self._checker.check_native_library('libperfetto_hprofd')
 
     # Check internal native library dependencies.
@@ -710,7 +710,6 @@ class TestingTargetChecker:
       self._checker.check_dir(arch_dir)
 
     # Check ART test binaries.
-    self._checker.check_art_test_executable('art_artd_tests')
     self._checker.check_art_test_executable('art_cmdline_tests')
     self._checker.check_art_test_executable('art_compiler_tests')
     self._checker.check_art_test_executable('art_dex2oat_tests')
@@ -721,14 +720,11 @@ class TestingTargetChecker:
     self._checker.check_art_test_executable('art_disassembler_tests')
     self._checker.check_art_test_executable('art_imgdiag_tests')
     self._checker.check_art_test_executable('art_libartbase_tests')
-    self._checker.check_art_test_executable('art_libartpalette_tests')
-    self._checker.check_art_test_executable('art_libartservice_tests')
-    self._checker.check_art_test_executable('art_libarttools_tests')
     self._checker.check_art_test_executable('art_libdexfile_support_tests')
     self._checker.check_art_test_executable('art_libdexfile_tests')
     self._checker.check_art_test_executable('art_libprofile_tests')
     self._checker.check_art_test_executable('art_oatdump_tests')
-    self._checker.check_art_test_executable('art_odrefresh_tests')
+    self._checker.check_art_test_executable('art_odrefresh_tests', MULTILIB_FIRST)
     self._checker.check_art_test_executable('art_profman_tests')
     self._checker.check_art_test_executable('art_runtime_tests')
     self._checker.check_art_test_executable('art_sigchain_tests')
@@ -793,7 +789,8 @@ class TestingTargetChecker:
     self._checker.check_art_test_data('art-gtest-jars-SuperWithAccessChecks.dex')
 
     # Fuzzer cases
-    self._checker.check_art_test_data('fuzzer_corpus.zip')
+    self._checker.check_art_test_data('dex_verification_fuzzer_corpus.zip')
+    self._checker.check_art_test_data('class_verification_fuzzer_corpus.zip')
 
 
 class NoSuperfluousFilesChecker:
diff --git a/build/art.go b/build/art.go
index 0e06c62979..26794a0a9a 100644
--- a/build/art.go
+++ b/build/art.go
@@ -107,9 +107,14 @@ func globalFlags(ctx android.LoadHookContext) ([]string, []string) {
 			"-DART_STACK_OVERFLOW_GAP_x86_64=8192")
 	}
 
-	if ctx.Config().NoBionicPageSizeMacro() {
-		cflags = append(cflags, "-DART_PAGE_SIZE_AGNOSTIC=1")
-	}
+	// This was originally coupled to targets, with the no bionic page size
+	// macro. However, we want all devices to have the same layout for Art
+	// targets. This is important to share optimizations across devices as
+	// well as to make sure all test configurations are consistent (Android
+	// shares tests between targets, and tests built with this option will
+	// only work on devices with this option.
+	// Previously contingent on  ctx.Config().NoBionicPageSizeMacro()
+	cflags = append(cflags, "-DART_PAGE_SIZE_AGNOSTIC=1")
 
 	if ctx.Config().IsEnvTrue("ART_ENABLE_ADDRESS_SANITIZER") {
 		// Used to enable full sanitization, i.e., user poisoning, under ASAN.
@@ -126,7 +131,7 @@ func globalFlags(ctx android.LoadHookContext) ([]string, []string) {
 
 func deviceFlags(ctx android.LoadHookContext) []string {
 	var cflags []string
-	deviceFrameSizeLimit := 1736
+	deviceFrameSizeLimit := 1744
 	if len(ctx.Config().SanitizeDevice()) > 0 {
 		deviceFrameSizeLimit = 7400
 	}
@@ -146,7 +151,7 @@ func deviceFlags(ctx android.LoadHookContext) []string {
 
 func hostFlags(ctx android.LoadHookContext) []string {
 	var cflags []string
-	hostFrameSizeLimit := 1736
+	hostFrameSizeLimit := 1744
 	if len(ctx.Config().SanitizeHost()) > 0 {
 		// art/test/137-cfi/cfi.cc
 		// error: stack frame size of 1944 bytes in function 'Java_Main_unwindInProcess'
diff --git a/build/boot/Android.bp b/build/boot/Android.bp
index a2fa55ca42..b9cc291561 100644
--- a/build/boot/Android.bp
+++ b/build/boot/Android.bp
@@ -21,43 +21,19 @@ package {
     default_applicable_licenses: ["art_license"],
 }
 
-// TODO: b/319697968 - Remove the conditional logic and let art-bootclasspath-fragment always
-// depend on the exportable stubs once metalava fully supports flagged api handling.
-soong_config_module_type {
-    name: "art_bootclasspath_fragment_soong_config_defaults",
-    module_type: "java_defaults",
-    config_namespace: "ANDROID",
-    bool_variables: [
-        "release_hidden_api_exportable_stubs",
-    ],
-    properties: [
-        "core_platform_api.stub_libs",
-    ],
-}
-
-art_bootclasspath_fragment_soong_config_defaults {
+java_defaults {
     name: "art-bootclasspath-fragment-soong-config-defaults",
-    soong_config_variables: {
-        release_hidden_api_exportable_stubs: {
+    core_platform_api: {
+        // TODO: b/319697968 - Remove the conditional logic and let art-bootclasspath-fragment
+        // always depend on the exportable stubs once metalava fully supports flagged api handling.
+        stub_libs: select(release_flag("RELEASE_HIDDEN_API_EXPORTABLE_STUBS"), {
             // When "RELEASE_HIDDEN_API_EXPORTABLE_STUBS" build flag is set,
-            // depend on the exportable stubs
-            core_platform_api: {
-                stub_libs: [
-                    // Core platform (aka. module_lib) stubs for all the non-coverage contents.
-                    "art.module.public.api.stubs.exportable.module_lib",
-                ],
-            },
-            conditions_default: {
-                // When "RELEASE_HIDDEN_API_EXPORTABLE_STUBS" build flag is not set,
-                // depend on the everything stubs
-                core_platform_api: {
-                    stub_libs: [
-                        // Core platform (aka. module_lib) stubs for all the non-coverage contents.
-                        "art.module.public.api.stubs.module_lib",
-                    ],
-                },
-            },
-        },
+            // depend on the exportable stubs, otherwise depend on the everything stubs.
+            // In both cases, use core platform (aka. module_lib) stubs for all the non-coverage
+            // contents.
+            true: ["art.module.public.api.stubs.exportable.module_lib"],
+            false: ["art.module.public.api.stubs.module_lib"],
+        }),
     },
 }
 
@@ -143,6 +119,8 @@ bootclasspath_fragment {
         package_prefixes: [
             "android.compat",
             "android.crypto.hpke",
+            "com.android.art.flags",
+            "com.android.libcore",
             "com.android.okhttp",
             "com.android.org.bouncycastle",
             "com.android.org.kxml2",
diff --git a/build/flags/Android.bp b/build/flags/Android.bp
new file mode 100644
index 0000000000..8ee33c7a6f
--- /dev/null
+++ b/build/flags/Android.bp
@@ -0,0 +1,61 @@
+//
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    default_applicable_licenses: ["art_license"],
+    default_visibility: [
+        "//art:__subpackages__",
+        "//libcore:__subpackages__",
+    ],
+}
+
+aconfig_declarations {
+    name: "art-aconfig-flags",
+    package: "com.android.art.flags",
+    container: "com.android.art",
+    exportable: true,
+    srcs: ["art-flags.aconfig"],
+    visibility: [
+        "//art:__subpackages__",
+        "//libcore:__subpackages__",
+        "//frameworks/base", // Needed for exporting flags.
+    ],
+}
+
+cc_aconfig_library {
+    name: "art-aconfig-flags-lib",
+    aconfig_declarations: "art-aconfig-flags",
+    host_supported: true,
+    min_sdk_version: "31",
+    apex_available: [
+        "//apex_available:platform",
+        "//apex_available:anyapex",
+    ],
+}
+
+java_aconfig_library {
+    name: "art-aconfig-flags-java-lib",
+    aconfig_declarations: "art-aconfig-flags",
+    min_sdk_version: "31", // ART module is enabled on Android 12 or above.
+    sdk_version: "none",
+    patch_module: "java.base",
+    system_modules: "core-all-system-modules",
+    libs: ["framework-api-annotations-lib"],
+    apex_available: [
+        "//apex_available:platform",
+        "//apex_available:anyapex",
+    ],
+}
diff --git a/build/flags/art-flags.aconfig b/build/flags/art-flags.aconfig
new file mode 100644
index 0000000000..e38f62a0ae
--- /dev/null
+++ b/build/flags/art-flags.aconfig
@@ -0,0 +1,36 @@
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+package: "com.android.art.flags"
+container: "com.android.art"
+
+# Flag for the experimental feature of on-demand method tracing
+flag {
+  name: "always_enable_profile_code"
+  namespace: "art_performance"
+  description: "Flag to control on-demand method tracing feature"
+  bug: "352518093"
+  is_fixed_read_only: true
+  is_exported: true
+}
+
+# TODO(b/352723620): Ramp this fully, then add tests with it.
+flag {
+  name: "test"
+  namespace: "art_mainline"
+  description: "Permanent test flag."
+  bug: "352723620"
+  is_fixed_read_only: true
+  is_exported: false
+}
diff --git a/build/sdk/Android.bp b/build/sdk/Android.bp
index 6944f0d263..f71f7c51fe 100644
--- a/build/sdk/Android.bp
+++ b/build/sdk/Android.bp
@@ -21,22 +21,11 @@ package {
     default_applicable_licenses: ["art_license"],
 }
 
-// Additional visibility to add to the prebuilt modules that are part of
-// the snapshots of the ART sdk/module_exports to ensure that they are
-// visible to each other.
-prebuilt_visibility = [
-    // TODO(b/155921753): Restrict this when prebuilts are in their proper
-    // locations.
-    "//prebuilts:__subpackages__",
-]
-
 // The SDK for the art module apex.
 sdk {
     name: "art-module-sdk",
     host_supported: true,
 
-    prebuilt_visibility: prebuilt_visibility,
-
     traits: {
         native_bridge_support: [
             "jni_headers",
@@ -70,12 +59,6 @@ sdk {
                 // via the workaround in https://r.android.com/3011798.
                 "libdexfile",
             ],
-
-            native_static_libs: [
-                "libdexfile_support",
-                "libdexfile_static",
-                "libnativehelper_lazy",
-            ],
         },
 
         android: {
@@ -112,14 +95,10 @@ sdk {
                 "art-module-lib-api-stubs-system-modules",
                 "art-module-intra-core-api-stubs-system-modules",
             ],
+
             native_header_libs: [
                 "libnativeloader-headers",
             ],
-            native_shared_libs: [
-                "libnativebridge_lazy",
-                "libnativehelper_compat_libc++",
-                "libnativeloader_lazy",
-            ],
         },
 
         linux_bionic: {
@@ -136,8 +115,6 @@ module_exports {
     name: "art-module-host-exports",
     host_supported: true,
 
-    prebuilt_visibility: prebuilt_visibility,
-
     target: {
         host: {
             // Set in target.host because the top level compile_multilib
@@ -183,8 +160,6 @@ module_exports {
 module_exports {
     name: "art-module-test-exports",
 
-    prebuilt_visibility: prebuilt_visibility,
-
     java_libs: [
         "core-compat-test-rules",
         "core-test-rules",
@@ -227,10 +202,4 @@ module_exports {
     native_shared_libs: [
         "libjavacoretests",
     ],
-    native_static_libs: [
-        // TODO(b/187288515): Providing this as a prebuilt introduces an issue
-        // with sdk_version propagation. Temporarily use the source library
-        // instead.
-        //"libctstiagent",
-    ],
 }
diff --git a/cmdline/cmdline_parser_test.cc b/cmdline/cmdline_parser_test.cc
index e586dd4292..ea688d650c 100644
--- a/cmdline/cmdline_parser_test.cc
+++ b/cmdline/cmdline_parser_test.cc
@@ -36,12 +36,11 @@ namespace art {
   // This has a gtest dependency, which is why it's in the gtest only.
   bool operator==(const ProfileSaverOptions& lhs, const ProfileSaverOptions& rhs) {
     return lhs.enabled_ == rhs.enabled_ &&
-        lhs.min_save_period_ms_ == rhs.min_save_period_ms_ &&
-        lhs.save_resolved_classes_delay_ms_ == rhs.save_resolved_classes_delay_ms_ &&
-        lhs.min_methods_to_save_ == rhs.min_methods_to_save_ &&
-        lhs.min_classes_to_save_ == rhs.min_classes_to_save_ &&
-        lhs.min_notification_before_wake_ == rhs.min_notification_before_wake_ &&
-        lhs.max_notification_before_wake_ == rhs.max_notification_before_wake_;
+           lhs.min_save_period_ms_ == rhs.min_save_period_ms_ &&
+           lhs.min_methods_to_save_ == rhs.min_methods_to_save_ &&
+           lhs.min_classes_to_save_ == rhs.min_classes_to_save_ &&
+           lhs.min_notification_before_wake_ == rhs.min_notification_before_wake_ &&
+           lhs.max_notification_before_wake_ == rhs.max_notification_before_wake_;
   }
 
   bool UsuallyEquals(double expected, double actual) {
@@ -489,18 +488,17 @@ TEST_F(CmdlineParserTest, TestJitOptions) {
 * -Xps-*
 */
 TEST_F(CmdlineParserTest, ProfileSaverOptions) {
-  ProfileSaverOptions opt = ProfileSaverOptions(true, 1, 2, 3, 4, 5, 6, 7, 8, "abc", true);
+  ProfileSaverOptions opt = ProfileSaverOptions(true, 1, 2, 3, 4, 5, 6, 7, "abc", true);
 
   EXPECT_SINGLE_PARSE_VALUE(opt,
                             "-Xjitsaveprofilinginfo "
                             "-Xps-min-save-period-ms:1 "
                             "-Xps-min-first-save-ms:2 "
-                            "-Xps-save-resolved-classes-delay-ms:3 "
-                            "-Xps-min-methods-to-save:4 "
-                            "-Xps-min-classes-to-save:5 "
-                            "-Xps-min-notification-before-wake:6 "
-                            "-Xps-max-notification-before-wake:7 "
-                            "-Xps-inline-cache-threshold:8 "
+                            "-Xps-min-methods-to-save:3 "
+                            "-Xps-min-classes-to-save:4 "
+                            "-Xps-min-notification-before-wake:5 "
+                            "-Xps-max-notification-before-wake:6 "
+                            "-Xps-inline-cache-threshold:7 "
                             "-Xps-profile-path:abc "
                             "-Xps-profile-boot-class-path",
                             M::ProfileSaverOpts);
diff --git a/cmdline/cmdline_types.h b/cmdline/cmdline_types.h
index 4a33fb8b55..fe7a55d559 100644
--- a/cmdline/cmdline_types.h
+++ b/cmdline/cmdline_types.h
@@ -826,10 +826,8 @@ struct CmdlineType<ProfileSaverOptions> : CmdlineTypeParser<ProfileSaverOptions>
              type_parser.Parse(suffix));
     }
     if (option.starts_with("save-resolved-classes-delay-ms:")) {
-      CmdlineType<unsigned int> type_parser;
-      return ParseInto(existing,
-             &ProfileSaverOptions::save_resolved_classes_delay_ms_,
-             type_parser.Parse(suffix));
+      LOG(WARNING) << "-Xps-save-resolved-classes-delay-ms is deprecated";
+      return Result::SuccessNoValue();
     }
     if (option.starts_with("hot-startup-method-samples:")) {
       LOG(WARNING) << "-Xps-hot-startup-method-samples option is deprecated";
diff --git a/compiler/Android.bp b/compiler/Android.bp
index 975bbf8335..05a599cf4a 100644
--- a/compiler/Android.bp
+++ b/compiler/Android.bp
@@ -458,6 +458,7 @@ art_cc_defaults {
         "jni/jni_compiler_test.cc",
         "linker/linker_patch_test.cc",
         "linker/output_stream_test.cc",
+        "oat/jni_stub_hash_map_test.cc",
         "optimizing/bounds_check_elimination_test.cc",
         "optimizing/constant_folding_test.cc",
         "optimizing/data_type_test.cc",
@@ -510,6 +511,7 @@ art_cc_defaults {
         },
         riscv64: {
             srcs: [
+                "optimizing/instruction_simplifier_riscv64_test.cc",
                 "utils/riscv64/managed_register_riscv64_test.cc",
             ],
         },
diff --git a/compiler/common_compiler_test.cc b/compiler/common_compiler_test.cc
index d7f6a2274f..392a0d1001 100644
--- a/compiler/common_compiler_test.cc
+++ b/compiler/common_compiler_test.cc
@@ -303,6 +303,23 @@ void CommonCompilerTestImpl::CompileMethod(ArtMethod* method) {
   }
 }
 
+std::vector<uint8_t> CommonCompilerTestImpl::JniCompileCode(ArtMethod* method) {
+  CHECK(method->IsNative());
+  Thread* self = Thread::Current();
+  StackHandleScope<1> hs(self);
+  const DexFile& dex_file = *method->GetDexFile();
+  Handle<mirror::DexCache> dex_cache =
+      hs.NewHandle(GetClassLinker()->FindDexCache(self, dex_file));
+  OneCompiledMethodStorage storage;
+  std::unique_ptr<Compiler> compiler(Compiler::Create(*compiler_options_, &storage));
+  compiler->JniCompile(method->GetAccessFlags(),
+                       method->GetDexMethodIndex(),
+                       dex_file,
+                       dex_cache);
+  ArrayRef<const uint8_t> code = storage.GetCode();
+  return std::vector<uint8_t>(code.begin(), code.end());
+}
+
 void CommonCompilerTestImpl::ClearBootImageOption() {
   compiler_options_->image_type_ = CompilerOptions::ImageType::kNone;
 }
diff --git a/compiler/common_compiler_test.h b/compiler/common_compiler_test.h
index 30d5734ba3..32a5234797 100644
--- a/compiler/common_compiler_test.h
+++ b/compiler/common_compiler_test.h
@@ -67,6 +67,7 @@ class EXPORT CommonCompilerTestImpl {
   void TearDown();
 
   void CompileMethod(ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_);
+  std::vector<uint8_t> JniCompileCode(ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_);
 
   void ApplyInstructionSet();
   void OverrideInstructionSetFeatures(InstructionSet instruction_set, const std::string& variant);
diff --git a/compiler/exception_test.cc b/compiler/exception_test.cc
index 89fe56dda0..0e289353c7 100644
--- a/compiler/exception_test.cc
+++ b/compiler/exception_test.cc
@@ -241,7 +241,7 @@ TEST_F(ExceptionTest, StackTraceElement) {
   // Set up thread to appear as if we called out of method_g_ at given pc dex.
   thread->SetTopOfStack(reinterpret_cast<ArtMethod**>(&fake_stack[0]));
 
-  jobject internal = thread->CreateInternalStackTrace(soa);
+  jobject internal = soa.AddLocalReference<jobject>(thread->CreateInternalStackTrace(soa));
   ASSERT_TRUE(internal != nullptr);
   jobjectArray ste_array = Thread::InternalStackTraceToStackTraceElementArray(soa, internal);
   ASSERT_TRUE(ste_array != nullptr);
diff --git a/compiler/jni/jni_compiler_test.cc b/compiler/jni/jni_compiler_test.cc
index 8a096d0744..2f4a1b5f44 100644
--- a/compiler/jni/jni_compiler_test.cc
+++ b/compiler/jni/jni_compiler_test.cc
@@ -1374,7 +1374,8 @@ jint Java_MyClassNatives_nativeUpCall(JNIEnv* env, jobject thisObj, jint i) {
     ScopedObjectAccess soa(env);
 
     // Build stack trace
-    jobject internal = Thread::Current()->CreateInternalStackTrace(soa);
+    jobject internal =
+        soa.AddLocalReference<jobject>(Thread::Current()->CreateInternalStackTrace(soa));
     jobjectArray ste_array = Thread::InternalStackTraceToStackTraceElementArray(soa, internal);
     ObjPtr<mirror::ObjectArray<mirror::StackTraceElement>> trace_array =
         soa.Decode<mirror::ObjectArray<mirror::StackTraceElement>>(ste_array);
diff --git a/runtime/oat/jni_stub_hash_map_test.cc b/compiler/oat/jni_stub_hash_map_test.cc
similarity index 85%
rename from runtime/oat/jni_stub_hash_map_test.cc
rename to compiler/oat/jni_stub_hash_map_test.cc
index cf6f4e2c0d..2a26bcfae6 100644
--- a/runtime/oat/jni_stub_hash_map_test.cc
+++ b/compiler/oat/jni_stub_hash_map_test.cc
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "jni_stub_hash_map.h"
+#include "oat/jni_stub_hash_map-inl.h"
 
 #include <gtest/gtest.h>
 
@@ -34,19 +34,18 @@
 #include "base/utils.h"
 #include "class_linker.h"
 #include "common_compiler_test.h"
-#include "common_compiler_test.cc"
 #include "compiler.h"
 #include "gc/heap.h"
 #include "gc/space/image_space.h"
 #include "handle.h"
 #include "handle_scope.h"
 #include "handle_scope-inl.h"
-#include "image.h"
-#include "image-inl.h"
 #include "jni.h"
 #include "mirror/class.h"
 #include "mirror/class_loader.h"
 #include "mirror/dex_cache.h"
+#include "oat/image-inl.h"
+#include "oat/oat_quick_method_header.h"
 #include "obj_ptr.h"
 #include "runtime.h"
 #include "scoped_thread_state_change.h"
@@ -97,61 +96,35 @@ class JniStubHashMapTest : public CommonCompilerTest {
 
   void SetBaseMethod(std::string_view base_method_name, std::string_view base_method_sig) {
     jni_stub_hash_map_.clear();
-    Thread* self = Thread::Current();
-    ScopedObjectAccess soa(self);
+    ScopedObjectAccess soa(Thread::Current());
     ObjPtr<mirror::Class> klass = soa.Decode<mirror::Class>(jklass_);
     base_method_ = klass->FindClassMethod(base_method_name, base_method_sig, pointer_size_);
     ASSERT_TRUE(base_method_ != nullptr);
     ASSERT_TRUE(base_method_->IsNative());
 
-    OneCompiledMethodStorage base_method_storage;
-    StackHandleScope<1> hs(self);
-    std::unique_ptr<Compiler> compiler(
-        Compiler::Create(*compiler_options_, &base_method_storage));
-    const DexFile& dex_file = *base_method_->GetDexFile();
-    Handle<mirror::DexCache> dex_cache =
-        hs.NewHandle(GetClassLinker()->FindDexCache(self, dex_file));
-    compiler->JniCompile(base_method_->GetAccessFlags(),
-                         base_method_->GetDexMethodIndex(),
-                         dex_file,
-                         dex_cache);
-    ArrayRef<const uint8_t> code = base_method_storage.GetCode();
-    base_method_code_.assign(code.begin(), code.end());
+    base_method_code_ = JniCompileCode(base_method_);
 
     jni_stub_hash_map_.insert(std::make_pair(JniStubKey(base_method_), base_method_));
   }
 
   void CompareMethod(std::string_view cmp_method_name, std::string_view cmp_method_sig) {
-    Thread* self = Thread::Current();
-    ScopedObjectAccess soa(self);
+    ScopedObjectAccess soa(Thread::Current());
     ObjPtr<mirror::Class> klass = soa.Decode<mirror::Class>(jklass_);
     ArtMethod* cmp_method = klass->FindClassMethod(cmp_method_name, cmp_method_sig, pointer_size_);
     ASSERT_TRUE(cmp_method != nullptr);
     ASSERT_TRUE(cmp_method->IsNative());
 
-    OneCompiledMethodStorage cmp_method_storage;
-    StackHandleScope<1> hs(self);
-    std::unique_ptr<Compiler> compiler(
-        Compiler::Create(*compiler_options_, &cmp_method_storage));
-    const DexFile& dex_file = *cmp_method->GetDexFile();
-    Handle<mirror::DexCache> dex_cache =
-        hs.NewHandle(GetClassLinker()->FindDexCache(self, dex_file));
-    compiler->JniCompile(cmp_method->GetAccessFlags(),
-                         cmp_method->GetDexMethodIndex(),
-                         dex_file,
-                         dex_cache);
+    std::vector<uint8_t> cmp_method_code = JniCompileCode(cmp_method);
 
-    ArrayRef<const uint8_t> method_code = ArrayRef<const uint8_t>(base_method_code_);
-    ArrayRef<const uint8_t> cmp_method_code = cmp_method_storage.GetCode();
     auto it = jni_stub_hash_map_.find(JniStubKey(cmp_method));
     if (it != jni_stub_hash_map_.end()) {
-      ASSERT_EQ(method_code, cmp_method_code)
+      ASSERT_EQ(base_method_code_, cmp_method_code)
           << "base method: " << base_method_->PrettyMethod() << ", compared method: "
           << cmp_method->PrettyMethod();
     } else if (strict_check_){
       // If the compared method maps to a different entry, then its compiled JNI stub should be
       // also different from the base one.
-      ASSERT_NE(method_code, cmp_method_code)
+      ASSERT_NE(base_method_code_, cmp_method_code)
           << "base method: " << base_method_->PrettyMethod() << ", compared method: "
           << cmp_method->PrettyMethod();
     }
diff --git a/compiler/optimizing/bounds_check_elimination_test.cc b/compiler/optimizing/bounds_check_elimination_test.cc
index 929a9e7fe7..246cd10ca7 100644
--- a/compiler/optimizing/bounds_check_elimination_test.cc
+++ b/compiler/optimizing/bounds_check_elimination_test.cc
@@ -35,13 +35,8 @@ namespace art HIDDEN {
  */
 class BoundsCheckEliminationTest : public OptimizingUnitTest {
  public:
-  BoundsCheckEliminationTest()  : graph_(CreateGraph()) {
-    graph_->SetHasBoundsChecks(true);
-  }
-
-  ~BoundsCheckEliminationTest() { }
-
   void RunBCE() {
+    graph_->SetHasBoundsChecks(true);
     graph_->BuildDominatorTree();
 
     InstructionSimplifier(graph_, /* codegen= */ nullptr).Run();
@@ -57,7 +52,10 @@ class BoundsCheckEliminationTest : public OptimizingUnitTest {
     BoundsCheckElimination(graph_, side_effects, &induction).Run();
   }
 
-  HGraph* graph_;
+  HInstruction* BuildSSAGraph1(int initial, int increment, IfCondition cond = kCondGE);
+  HInstruction* BuildSSAGraph2(int initial, int increment = -1, IfCondition cond = kCondLE);
+  HInstruction* BuildSSAGraph3(int initial, int increment, IfCondition cond);
+  HInstruction* BuildSSAGraph4(int initial, IfCondition cond = kCondGE);
 };
 
 
@@ -65,83 +63,49 @@ class BoundsCheckEliminationTest : public OptimizingUnitTest {
 // else if (i >= array.length) { array[i] = 1; // Can't eliminate. }
 // else { array[i] = 1; // Can eliminate. }
 TEST_F(BoundsCheckEliminationTest, NarrowingRangeArrayBoundsElimination) {
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
+  CreateGraph();
+  HBasicBlock* entry = AddNewBlock();
   graph_->SetEntryBlock(entry);
-  HInstruction* parameter1 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);  // array
-  HInstruction* parameter2 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);  // i
-  entry->AddInstruction(parameter1);
-  entry->AddInstruction(parameter2);
+  HInstruction* parameter1 = MakeParam(DataType::Type::kReference);  // array
+  HInstruction* parameter2 = MakeParam(DataType::Type::kInt32);  // i
 
   HInstruction* constant_1 = graph_->GetIntConstant(1);
   HInstruction* constant_0 = graph_->GetIntConstant(0);
 
-  HBasicBlock* block1 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block1);
-  HInstruction* cmp = new (GetAllocator()) HGreaterThanOrEqual(parameter2, constant_0);
-  HIf* if_inst = new (GetAllocator()) HIf(cmp);
-  block1->AddInstruction(cmp);
-  block1->AddInstruction(if_inst);
+  HBasicBlock* block1 = AddNewBlock();
+  HInstruction* cmp = MakeCondition(block1, kCondGE, parameter2, constant_0);
+  MakeIf(block1, cmp);
   entry->AddSuccessor(block1);
 
-  HBasicBlock* block2 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block2);
-  HNullCheck* null_check = new (GetAllocator()) HNullCheck(parameter1, 0);
-  HArrayLength* array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check2 = new (GetAllocator())
-      HBoundsCheck(parameter2, array_length, 0);
-  HArraySet* array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check2, constant_1, DataType::Type::kInt32, 0);
-  block2->AddInstruction(null_check);
-  block2->AddInstruction(array_length);
-  block2->AddInstruction(bounds_check2);
-  block2->AddInstruction(array_set);
-
-  HBasicBlock* block3 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block3);
-  null_check = new (GetAllocator()) HNullCheck(parameter1, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  cmp = new (GetAllocator()) HLessThan(parameter2, array_length);
-  if_inst = new (GetAllocator()) HIf(cmp);
-  block3->AddInstruction(null_check);
-  block3->AddInstruction(array_length);
-  block3->AddInstruction(cmp);
-  block3->AddInstruction(if_inst);
-
-  HBasicBlock* block4 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block4);
-  null_check = new (GetAllocator()) HNullCheck(parameter1, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check4 = new (GetAllocator())
-      HBoundsCheck(parameter2, array_length, 0);
-  array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check4, constant_1, DataType::Type::kInt32, 0);
-  block4->AddInstruction(null_check);
-  block4->AddInstruction(array_length);
-  block4->AddInstruction(bounds_check4);
-  block4->AddInstruction(array_set);
-
-  HBasicBlock* block5 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block5);
-  null_check = new (GetAllocator()) HNullCheck(parameter1, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check5 = new (GetAllocator())
-      HBoundsCheck(parameter2, array_length, 0);
-  array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check5, constant_1, DataType::Type::kInt32, 0);
-  block5->AddInstruction(null_check);
-  block5->AddInstruction(array_length);
-  block5->AddInstruction(bounds_check5);
-  block5->AddInstruction(array_set);
-
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(exit);
+  HBasicBlock* block2 = AddNewBlock();
+  HNullCheck* null_check = MakeNullCheck(block2, parameter1);
+  HArrayLength* array_length = MakeArrayLength(block2, null_check);
+  HBoundsCheck* bounds_check2 = MakeBoundsCheck(block2, parameter2, array_length);
+  MakeArraySet(block2, null_check, bounds_check2, constant_1, DataType::Type::kInt32);
+
+  HBasicBlock* block3 = AddNewBlock();
+  null_check = MakeNullCheck(block3, parameter1);
+  array_length = MakeArrayLength(block3, null_check);
+  cmp = MakeCondition(block3, kCondLT, parameter2, array_length);
+  MakeIf(block3, cmp);
+
+  HBasicBlock* block4 = AddNewBlock();
+  null_check = MakeNullCheck(block4, parameter1);
+  array_length = MakeArrayLength(block4, null_check);
+  HBoundsCheck* bounds_check4 = MakeBoundsCheck(block4, parameter2, array_length);
+  MakeArraySet(block4, null_check, bounds_check4, constant_1, DataType::Type::kInt32);
+
+  HBasicBlock* block5 = AddNewBlock();
+  null_check = MakeNullCheck(block5, parameter1);
+  array_length = MakeArrayLength(block5, null_check);
+  HBoundsCheck* bounds_check5 = MakeBoundsCheck(block5, parameter2, array_length);
+  MakeArraySet(block5, null_check, bounds_check5, constant_1, DataType::Type::kInt32);
+
+  HBasicBlock* exit = AddNewBlock();
   block2->AddSuccessor(exit);
   block4->AddSuccessor(exit);
   block5->AddSuccessor(exit);
-  exit->AddInstruction(new (GetAllocator()) HExit());
+  MakeExit(exit);
 
   block1->AddSuccessor(block3);  // True successor
   block1->AddSuccessor(block2);  // False successor
@@ -162,54 +126,34 @@ TEST_F(BoundsCheckEliminationTest, NarrowingRangeArrayBoundsElimination) {
 //   if (j < array.length) array[j] = 1;  // Can't eliminate.
 // }
 TEST_F(BoundsCheckEliminationTest, OverflowArrayBoundsElimination) {
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
+  CreateGraph();
+  HBasicBlock* entry = AddNewBlock();
   graph_->SetEntryBlock(entry);
-  HInstruction* parameter1 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);  // array
-  HInstruction* parameter2 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);  // i
-  entry->AddInstruction(parameter1);
-  entry->AddInstruction(parameter2);
+  HInstruction* parameter1 = MakeParam(DataType::Type::kReference);  // array
+  HInstruction* parameter2 = MakeParam(DataType::Type::kInt32);  // i
 
   HInstruction* constant_1 = graph_->GetIntConstant(1);
   HInstruction* constant_0 = graph_->GetIntConstant(0);
   HInstruction* constant_max_int = graph_->GetIntConstant(INT_MAX);
 
-  HBasicBlock* block1 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block1);
-  HInstruction* cmp = new (GetAllocator()) HLessThanOrEqual(parameter2, constant_0);
-  HIf* if_inst = new (GetAllocator()) HIf(cmp);
-  block1->AddInstruction(cmp);
-  block1->AddInstruction(if_inst);
+  HBasicBlock* block1 = AddNewBlock();
+  HInstruction* cmp = MakeCondition(block1, kCondLE, parameter2, constant_0);
+  MakeIf(block1, cmp);
   entry->AddSuccessor(block1);
 
-  HBasicBlock* block2 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block2);
-  HInstruction* add =
-      new (GetAllocator()) HAdd(DataType::Type::kInt32, parameter2, constant_max_int);
-  HNullCheck* null_check = new (GetAllocator()) HNullCheck(parameter1, 0);
-  HArrayLength* array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HInstruction* cmp2 = new (GetAllocator()) HGreaterThanOrEqual(add, array_length);
-  if_inst = new (GetAllocator()) HIf(cmp2);
-  block2->AddInstruction(add);
-  block2->AddInstruction(null_check);
-  block2->AddInstruction(array_length);
-  block2->AddInstruction(cmp2);
-  block2->AddInstruction(if_inst);
-
-  HBasicBlock* block3 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block3);
-  HBoundsCheck* bounds_check = new (GetAllocator())
-      HBoundsCheck(add, array_length, 0);
-  HArraySet* array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check, constant_1, DataType::Type::kInt32, 0);
-  block3->AddInstruction(bounds_check);
-  block3->AddInstruction(array_set);
-
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(exit);
-  exit->AddInstruction(new (GetAllocator()) HExit());
+  HBasicBlock* block2 = AddNewBlock();
+  HInstruction* add = MakeBinOp<HAdd>(block2, DataType::Type::kInt32, parameter2, constant_max_int);
+  HNullCheck* null_check = MakeNullCheck(block2, parameter1);
+  HArrayLength* array_length = MakeArrayLength(block2, null_check);
+  HInstruction* cmp2 = MakeCondition(block2, kCondGE, add, array_length);
+  MakeIf(block2, cmp2);
+
+  HBasicBlock* block3 = AddNewBlock();
+  HBoundsCheck* bounds_check = MakeBoundsCheck(block3, add, array_length);
+  MakeArraySet(block3, null_check, bounds_check, constant_1, DataType::Type::kInt32);
+
+  HBasicBlock* exit = AddNewBlock();
+  MakeExit(exit);
   block1->AddSuccessor(exit);    // true successor
   block1->AddSuccessor(block2);  // false successor
   block2->AddSuccessor(exit);    // true successor
@@ -227,56 +171,36 @@ TEST_F(BoundsCheckEliminationTest, OverflowArrayBoundsElimination) {
 //   if (j > 0) array[j] = 1;    // Can't eliminate.
 // }
 TEST_F(BoundsCheckEliminationTest, UnderflowArrayBoundsElimination) {
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
+  CreateGraph();
+  HBasicBlock* entry = AddNewBlock();
   graph_->SetEntryBlock(entry);
-  HInstruction* parameter1 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);  // array
-  HInstruction* parameter2 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);  // i
-  entry->AddInstruction(parameter1);
-  entry->AddInstruction(parameter2);
+  HInstruction* parameter1 = MakeParam(DataType::Type::kReference);  // array
+  HInstruction* parameter2 = MakeParam(DataType::Type::kInt32);  // i
 
   HInstruction* constant_1 = graph_->GetIntConstant(1);
   HInstruction* constant_0 = graph_->GetIntConstant(0);
   HInstruction* constant_max_int = graph_->GetIntConstant(INT_MAX);
 
-  HBasicBlock* block1 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block1);
-  HNullCheck* null_check = new (GetAllocator()) HNullCheck(parameter1, 0);
-  HArrayLength* array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HInstruction* cmp = new (GetAllocator()) HGreaterThanOrEqual(parameter2, array_length);
-  HIf* if_inst = new (GetAllocator()) HIf(cmp);
-  block1->AddInstruction(null_check);
-  block1->AddInstruction(array_length);
-  block1->AddInstruction(cmp);
-  block1->AddInstruction(if_inst);
+  HBasicBlock* block1 = AddNewBlock();
+  HNullCheck* null_check = MakeNullCheck(block1, parameter1);
+  HArrayLength* array_length = MakeArrayLength(block1, null_check);
+  HInstruction* cmp = MakeCondition(block1, kCondGE, parameter2, array_length);
+  MakeIf(block1, cmp);
   entry->AddSuccessor(block1);
 
-  HBasicBlock* block2 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block2);
+  HBasicBlock* block2 = AddNewBlock();
   HInstruction* sub1 =
-      new (GetAllocator()) HSub(DataType::Type::kInt32, parameter2, constant_max_int);
-  HInstruction* sub2 = new (GetAllocator()) HSub(DataType::Type::kInt32, sub1, constant_max_int);
-  HInstruction* cmp2 = new (GetAllocator()) HLessThanOrEqual(sub2, constant_0);
-  if_inst = new (GetAllocator()) HIf(cmp2);
-  block2->AddInstruction(sub1);
-  block2->AddInstruction(sub2);
-  block2->AddInstruction(cmp2);
-  block2->AddInstruction(if_inst);
-
-  HBasicBlock* block3 = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block3);
-  HBoundsCheck* bounds_check = new (GetAllocator())
-      HBoundsCheck(sub2, array_length, 0);
-  HArraySet* array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check, constant_1, DataType::Type::kInt32, 0);
-  block3->AddInstruction(bounds_check);
-  block3->AddInstruction(array_set);
-
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(exit);
-  exit->AddInstruction(new (GetAllocator()) HExit());
+      MakeBinOp<HSub>(block2, DataType::Type::kInt32, parameter2, constant_max_int);
+  HInstruction* sub2 = MakeBinOp<HSub>(block2, DataType::Type::kInt32, sub1, constant_max_int);
+  HInstruction* cmp2 = MakeCondition(block2, kCondLE, sub2, constant_0);
+  MakeIf(block2, cmp2);
+
+  HBasicBlock* block3 = AddNewBlock();
+  HBoundsCheck* bounds_check = MakeBoundsCheck(block3, sub2, array_length);
+  MakeArraySet(block3, null_check, bounds_check, constant_1, DataType::Type::kInt32);
+
+  HBasicBlock* exit = AddNewBlock();
+  MakeExit(exit);
   block1->AddSuccessor(exit);    // true successor
   block1->AddSuccessor(block2);  // false successor
   block2->AddSuccessor(exit);    // true successor
@@ -292,61 +216,28 @@ TEST_F(BoundsCheckEliminationTest, UnderflowArrayBoundsElimination) {
 // array[5] = 1; // Can eliminate.
 // array[4] = 1; // Can eliminate.
 TEST_F(BoundsCheckEliminationTest, ConstantArrayBoundsElimination) {
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
+  HBasicBlock* block = InitEntryMainExitGraphWithReturnVoid();
 
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
   HInstruction* constant_5 = graph_->GetIntConstant(5);
   HInstruction* constant_4 = graph_->GetIntConstant(4);
   HInstruction* constant_6 = graph_->GetIntConstant(6);
   HInstruction* constant_1 = graph_->GetIntConstant(1);
 
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block);
-  entry->AddSuccessor(block);
-
-  HNullCheck* null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  HArrayLength* array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check6 = new (GetAllocator())
-      HBoundsCheck(constant_6, array_length, 0);
-  HInstruction* array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check6, constant_1, DataType::Type::kInt32, 0);
-  block->AddInstruction(null_check);
-  block->AddInstruction(array_length);
-  block->AddInstruction(bounds_check6);
-  block->AddInstruction(array_set);
-
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check5 = new (GetAllocator())
-      HBoundsCheck(constant_5, array_length, 0);
-  array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check5, constant_1, DataType::Type::kInt32, 0);
-  block->AddInstruction(null_check);
-  block->AddInstruction(array_length);
-  block->AddInstruction(bounds_check5);
-  block->AddInstruction(array_set);
-
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check4 = new (GetAllocator())
-      HBoundsCheck(constant_4, array_length, 0);
-  array_set = new (GetAllocator()) HArraySet(
-    null_check, bounds_check4, constant_1, DataType::Type::kInt32, 0);
-  block->AddInstruction(null_check);
-  block->AddInstruction(array_length);
-  block->AddInstruction(bounds_check4);
-  block->AddInstruction(array_set);
-
-  block->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(exit);
-  block->AddSuccessor(exit);
-  exit->AddInstruction(new (GetAllocator()) HExit());
+  HNullCheck* null_check = MakeNullCheck(block, parameter);
+  HArrayLength* array_length = MakeArrayLength(block, null_check);
+  HBoundsCheck* bounds_check6 = MakeBoundsCheck(block, constant_6, array_length);
+  MakeArraySet(block, null_check, bounds_check6, constant_1, DataType::Type::kInt32);
+
+  null_check = MakeNullCheck(block, parameter);
+  array_length = MakeArrayLength(block, null_check);
+  HBoundsCheck* bounds_check5 = MakeBoundsCheck(block, constant_5, array_length);
+  MakeArraySet(block, null_check, bounds_check5, constant_1, DataType::Type::kInt32);
+
+  null_check = MakeNullCheck(block, parameter);
+  array_length = MakeArrayLength(block, null_check);
+  HBoundsCheck* bounds_check4 = MakeBoundsCheck(block, constant_4, array_length);
+  MakeArraySet(block, null_check, bounds_check4, constant_1, DataType::Type::kInt32);
 
   RunBCE();
 
@@ -356,101 +247,54 @@ TEST_F(BoundsCheckEliminationTest, ConstantArrayBoundsElimination) {
 }
 
 // for (int i=initial; i<array.length; i+=increment) { array[i] = 10; }
-static HInstruction* BuildSSAGraph1(HGraph* graph,
-                                    ArenaAllocator* allocator,
-                                    int initial,
-                                    int increment,
-                                    IfCondition cond = kCondGE) {
-  HBasicBlock* entry = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (allocator) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-
-  HInstruction* constant_initial = graph->GetIntConstant(initial);
-  HInstruction* constant_increment = graph->GetIntConstant(increment);
-  HInstruction* constant_10 = graph->GetIntConstant(10);
-
-  HBasicBlock* block = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
-  block->AddInstruction(new (allocator) HGoto());
-
-  HBasicBlock* loop_header = new (allocator) HBasicBlock(graph);
-  HBasicBlock* loop_body = new (allocator) HBasicBlock(graph);
-  HBasicBlock* exit = new (allocator) HBasicBlock(graph);
-
-  graph->AddBlock(loop_header);
-  graph->AddBlock(loop_body);
-  graph->AddBlock(exit);
-  block->AddSuccessor(loop_header);
-  loop_header->AddSuccessor(exit);       // true successor
-  loop_header->AddSuccessor(loop_body);  // false successor
-  loop_body->AddSuccessor(loop_header);
-
-  HPhi* phi = new (allocator) HPhi(allocator, 0, 0, DataType::Type::kInt32);
-  HInstruction* null_check = new (allocator) HNullCheck(parameter, 0);
-  HInstruction* array_length = new (allocator) HArrayLength(null_check, 0);
-  HInstruction* cmp = nullptr;
-  if (cond == kCondGE) {
-    cmp = new (allocator) HGreaterThanOrEqual(phi, array_length);
-  } else {
-    DCHECK(cond == kCondGT);
-    cmp = new (allocator) HGreaterThan(phi, array_length);
-  }
-  HInstruction* if_inst = new (allocator) HIf(cmp);
-  loop_header->AddPhi(phi);
-  loop_header->AddInstruction(null_check);
-  loop_header->AddInstruction(array_length);
-  loop_header->AddInstruction(cmp);
-  loop_header->AddInstruction(if_inst);
-  phi->AddInput(constant_initial);
-
-  null_check = new (allocator) HNullCheck(parameter, 0);
-  array_length = new (allocator) HArrayLength(null_check, 0);
-  HInstruction* bounds_check = new (allocator) HBoundsCheck(phi, array_length, 0);
-  HInstruction* array_set = new (allocator) HArraySet(
-      null_check, bounds_check, constant_10, DataType::Type::kInt32, 0);
-
-  HInstruction* add = new (allocator) HAdd(DataType::Type::kInt32, phi, constant_increment);
-  loop_body->AddInstruction(null_check);
-  loop_body->AddInstruction(array_length);
-  loop_body->AddInstruction(bounds_check);
-  loop_body->AddInstruction(array_set);
-  loop_body->AddInstruction(add);
-  loop_body->AddInstruction(new (allocator) HGoto());
-  phi->AddInput(add);
-
-  exit->AddInstruction(new (allocator) HExit());
+HInstruction* BoundsCheckEliminationTest::BuildSSAGraph1(int initial,
+                                                         int increment,
+                                                         IfCondition cond) {
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [pre_header, loop_header, loop_body] = CreateWhileLoop(return_block);
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+  HInstruction* constant_10 = graph_->GetIntConstant(10);
+
+  auto [phi, add] = MakeLinearLoopVar(loop_header, loop_body, initial, increment);
+  HInstruction* null_check = MakeNullCheck(loop_header, parameter);
+  HInstruction* array_length = MakeArrayLength(loop_header, null_check);
+  DCHECK(cond == kCondGE || cond == kCondGT) << cond;
+  HInstruction* cmp = MakeCondition(loop_header, cond, phi, array_length);
+  MakeIf(loop_header, cmp);
+
+  null_check = MakeNullCheck(loop_body, parameter);
+  array_length = MakeArrayLength(loop_body, null_check);
+  HInstruction* bounds_check = MakeBoundsCheck(loop_body, phi, array_length);
+  MakeArraySet(loop_body, null_check, bounds_check, constant_10, DataType::Type::kInt32);
 
   return bounds_check;
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1a) {
   // for (int i=0; i<array.length; i++) { array[i] = 10; // Can eliminate with gvn. }
-  HInstruction* bounds_check = BuildSSAGraph1(graph_, GetAllocator(), 0, 1);
+  HInstruction* bounds_check = BuildSSAGraph1(0, 1);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1b) {
   // for (int i=1; i<array.length; i++) { array[i] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph1(graph_, GetAllocator(), 1, 1);
+  HInstruction* bounds_check = BuildSSAGraph1(1, 1);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1c) {
   // for (int i=-1; i<array.length; i++) { array[i] = 10; // Can't eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph1(graph_, GetAllocator(), -1, 1);
+  HInstruction* bounds_check = BuildSSAGraph1(-1, 1);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1d) {
   // for (int i=0; i<=array.length; i++) { array[i] = 10; // Can't eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph1(graph_, GetAllocator(), 0, 1, kCondGT);
+  HInstruction* bounds_check = BuildSSAGraph1(0, 1, kCondGT);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
@@ -458,195 +302,105 @@ TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1d) {
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1e) {
   // for (int i=0; i<array.length; i += 2) {
   //   array[i] = 10; // Can't eliminate due to overflow concern. }
-  HInstruction* bounds_check = BuildSSAGraph1(graph_, GetAllocator(), 0, 2);
+  HInstruction* bounds_check = BuildSSAGraph1(0, 2);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination1f) {
   // for (int i=1; i<array.length; i += 2) { array[i] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph1(graph_, GetAllocator(), 1, 2);
+  HInstruction* bounds_check = BuildSSAGraph1(1, 2);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 // for (int i=array.length; i>0; i+=increment) { array[i-1] = 10; }
-static HInstruction* BuildSSAGraph2(HGraph *graph,
-                                    ArenaAllocator* allocator,
-                                    int initial,
-                                    int increment = -1,
-                                    IfCondition cond = kCondLE) {
-  HBasicBlock* entry = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (allocator) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-
-  HInstruction* constant_initial = graph->GetIntConstant(initial);
-  HInstruction* constant_increment = graph->GetIntConstant(increment);
-  HInstruction* constant_minus_1 = graph->GetIntConstant(-1);
-  HInstruction* constant_10 = graph->GetIntConstant(10);
-
-  HBasicBlock* block = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
-  HInstruction* null_check = new (allocator) HNullCheck(parameter, 0);
-  HInstruction* array_length = new (allocator) HArrayLength(null_check, 0);
-  block->AddInstruction(null_check);
-  block->AddInstruction(array_length);
-  block->AddInstruction(new (allocator) HGoto());
-
-  HBasicBlock* loop_header = new (allocator) HBasicBlock(graph);
-  HBasicBlock* loop_body = new (allocator) HBasicBlock(graph);
-  HBasicBlock* exit = new (allocator) HBasicBlock(graph);
-
-  graph->AddBlock(loop_header);
-  graph->AddBlock(loop_body);
-  graph->AddBlock(exit);
-  block->AddSuccessor(loop_header);
-  loop_header->AddSuccessor(exit);       // true successor
-  loop_header->AddSuccessor(loop_body);  // false successor
-  loop_body->AddSuccessor(loop_header);
-
-  HPhi* phi = new (allocator) HPhi(allocator, 0, 0, DataType::Type::kInt32);
-  HInstruction* cmp = nullptr;
-  if (cond == kCondLE) {
-    cmp = new (allocator) HLessThanOrEqual(phi, constant_initial);
-  } else {
-    DCHECK(cond == kCondLT);
-    cmp = new (allocator) HLessThan(phi, constant_initial);
-  }
-  HInstruction* if_inst = new (allocator) HIf(cmp);
-  loop_header->AddPhi(phi);
-  loop_header->AddInstruction(cmp);
-  loop_header->AddInstruction(if_inst);
-  phi->AddInput(array_length);
-
-  HInstruction* add = new (allocator) HAdd(DataType::Type::kInt32, phi, constant_minus_1);
-  null_check = new (allocator) HNullCheck(parameter, 0);
-  array_length = new (allocator) HArrayLength(null_check, 0);
-  HInstruction* bounds_check = new (allocator) HBoundsCheck(add, array_length, 0);
-  HInstruction* array_set = new (allocator) HArraySet(
-      null_check, bounds_check, constant_10, DataType::Type::kInt32, 0);
-  HInstruction* add_phi = new (allocator) HAdd(DataType::Type::kInt32, phi, constant_increment);
-  loop_body->AddInstruction(add);
-  loop_body->AddInstruction(null_check);
-  loop_body->AddInstruction(array_length);
-  loop_body->AddInstruction(bounds_check);
-  loop_body->AddInstruction(array_set);
-  loop_body->AddInstruction(add_phi);
-  loop_body->AddInstruction(new (allocator) HGoto());
-  phi->AddInput(add);
-
-  exit->AddInstruction(new (allocator) HExit());
+HInstruction* BoundsCheckEliminationTest::BuildSSAGraph2(int initial,
+                                                         int increment,
+                                                         IfCondition cond) {
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [pre_header, loop_header, loop_body] = CreateWhileLoop(return_block);
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+  HInstruction* constant_initial = graph_->GetIntConstant(initial);
+  HInstruction* constant_increment = graph_->GetIntConstant(increment);
+  HInstruction* constant_minus_1 = graph_->GetIntConstant(-1);
+  HInstruction* constant_10 = graph_->GetIntConstant(10);
+
+  HInstruction* null_check = MakeNullCheck(pre_header, parameter);
+  HInstruction* array_length = MakeArrayLength(pre_header, null_check);
+
+  auto [phi, add] = MakeLinearLoopVar(loop_header, loop_body, array_length, constant_minus_1);
+  DCHECK(cond == kCondLE || cond == kCondLT) << cond;
+  HInstruction* cmp = MakeCondition(loop_header, cond, phi, constant_initial);
+  MakeIf(loop_header, cmp);
+
+  null_check = MakeNullCheck(loop_body, parameter);
+  array_length = MakeArrayLength(loop_body, null_check);
+  HInstruction* bounds_check = MakeBoundsCheck(loop_body, add, array_length);
+  MakeArraySet(loop_body, null_check, bounds_check, constant_10, DataType::Type::kInt32);
 
   return bounds_check;
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination2a) {
   // for (int i=array.length; i>0; i--) { array[i-1] = 10; // Can eliminate with gvn. }
-  HInstruction* bounds_check = BuildSSAGraph2(graph_, GetAllocator(), 0);
+  HInstruction* bounds_check = BuildSSAGraph2(0);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination2b) {
   // for (int i=array.length; i>1; i--) { array[i-1] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph2(graph_, GetAllocator(), 1);
+  HInstruction* bounds_check = BuildSSAGraph2(1);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination2c) {
   // for (int i=array.length; i>-1; i--) { array[i-1] = 10; // Can't eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph2(graph_, GetAllocator(), -1);
+  HInstruction* bounds_check = BuildSSAGraph2(-1);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination2d) {
   // for (int i=array.length; i>=0; i--) { array[i-1] = 10; // Can't eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph2(graph_, GetAllocator(), 0, -1, kCondLT);
+  HInstruction* bounds_check = BuildSSAGraph2(0, -1, kCondLT);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination2e) {
   // for (int i=array.length; i>0; i-=2) { array[i-1] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph2(graph_, GetAllocator(), 0, -2);
+  HInstruction* bounds_check = BuildSSAGraph2(0, -2);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 // int[] array = new int[10];
 // for (int i=0; i<10; i+=increment) { array[i] = 10; }
-static HInstruction* BuildSSAGraph3(HGraph* graph,
-                                    ArenaAllocator* allocator,
-                                    int initial,
-                                    int increment,
-                                    IfCondition cond) {
-  HBasicBlock* entry = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-
-  HInstruction* constant_10 = graph->GetIntConstant(10);
-  HInstruction* constant_initial = graph->GetIntConstant(initial);
-  HInstruction* constant_increment = graph->GetIntConstant(increment);
-
-  HBasicBlock* block = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
+HInstruction* BoundsCheckEliminationTest::BuildSSAGraph3(int initial,
+                                                         int increment,
+                                                         IfCondition cond) {
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [pre_header, loop_header, loop_body] = CreateWhileLoop(return_block);
+
+  HInstruction* constant_10 = graph_->GetIntConstant(10);
+
   // We pass a bogus constant for the class to avoid mocking one.
-  HInstruction* new_array = new (allocator) HNewArray(
-      /* cls= */ constant_10,
-      /* length= */ constant_10,
-      /* dex_pc= */ 0,
-      /* component_size_shift= */ 0);
-  block->AddInstruction(new_array);
-  block->AddInstruction(new (allocator) HGoto());
-
-  HBasicBlock* loop_header = new (allocator) HBasicBlock(graph);
-  HBasicBlock* loop_body = new (allocator) HBasicBlock(graph);
-  HBasicBlock* exit = new (allocator) HBasicBlock(graph);
-
-  graph->AddBlock(loop_header);
-  graph->AddBlock(loop_body);
-  graph->AddBlock(exit);
-  block->AddSuccessor(loop_header);
-  loop_header->AddSuccessor(exit);       // true successor
-  loop_header->AddSuccessor(loop_body);  // false successor
-  loop_body->AddSuccessor(loop_header);
-
-  HPhi* phi = new (allocator) HPhi(allocator, 0, 0, DataType::Type::kInt32);
-  HInstruction* cmp = nullptr;
-  if (cond == kCondGE) {
-    cmp = new (allocator) HGreaterThanOrEqual(phi, constant_10);
-  } else {
-    DCHECK(cond == kCondGT);
-    cmp = new (allocator) HGreaterThan(phi, constant_10);
-  }
-  HInstruction* if_inst = new (allocator) HIf(cmp);
-  loop_header->AddPhi(phi);
-  loop_header->AddInstruction(cmp);
-  loop_header->AddInstruction(if_inst);
-  phi->AddInput(constant_initial);
-
-  HNullCheck* null_check = new (allocator) HNullCheck(new_array, 0);
-  HArrayLength* array_length = new (allocator) HArrayLength(null_check, 0);
-  HInstruction* bounds_check = new (allocator) HBoundsCheck(phi, array_length, 0);
-  HInstruction* array_set = new (allocator) HArraySet(
-      null_check, bounds_check, constant_10, DataType::Type::kInt32, 0);
-  HInstruction* add = new (allocator) HAdd(DataType::Type::kInt32, phi, constant_increment);
-  loop_body->AddInstruction(null_check);
-  loop_body->AddInstruction(array_length);
-  loop_body->AddInstruction(bounds_check);
-  loop_body->AddInstruction(array_set);
-  loop_body->AddInstruction(add);
-  loop_body->AddInstruction(new (allocator) HGoto());
-  phi->AddInput(add);
-
-  exit->AddInstruction(new (allocator) HExit());
+  HInstruction* new_array =
+      MakeNewArray(pre_header, /* cls= */ constant_10, /* length= */ constant_10);
+
+  auto [phi, add] = MakeLinearLoopVar(loop_header, loop_body, initial, increment);
+  DCHECK(cond == kCondGE || cond == kCondGT) << cond;
+  HInstruction* cmp = MakeCondition(loop_header, cond, phi, constant_10);
+  MakeIf(loop_header, cmp);
+
+  HNullCheck* null_check = MakeNullCheck(loop_body, new_array);
+  HArrayLength* array_length = MakeArrayLength(loop_body, null_check);
+  HInstruction* bounds_check = MakeBoundsCheck(loop_body, phi, array_length);
+  MakeArraySet(loop_body, null_check, bounds_check, constant_10, DataType::Type::kInt32);
 
   return bounds_check;
 }
@@ -654,7 +408,7 @@ static HInstruction* BuildSSAGraph3(HGraph* graph,
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3a) {
   // int[] array = new int[10];
   // for (int i=0; i<10; i++) { array[i] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph3(graph_, GetAllocator(), 0, 1, kCondGE);
+  HInstruction* bounds_check = BuildSSAGraph3(0, 1, kCondGE);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
@@ -662,7 +416,7 @@ TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3a) {
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3b) {
   // int[] array = new int[10];
   // for (int i=1; i<10; i++) { array[i] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph3(graph_, GetAllocator(), 1, 1, kCondGE);
+  HInstruction* bounds_check = BuildSSAGraph3(1, 1, kCondGE);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
@@ -670,7 +424,7 @@ TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3b) {
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3c) {
   // int[] array = new int[10];
   // for (int i=0; i<=10; i++) { array[i] = 10; // Can't eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph3(graph_, GetAllocator(), 0, 1, kCondGT);
+  HInstruction* bounds_check = BuildSSAGraph3(0, 1, kCondGT);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
@@ -678,103 +432,55 @@ TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3c) {
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination3d) {
   // int[] array = new int[10];
   // for (int i=1; i<10; i+=8) { array[i] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph3(graph_, GetAllocator(), 1, 8, kCondGE);
+  HInstruction* bounds_check = BuildSSAGraph3(1, 8, kCondGE);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 // for (int i=initial; i<array.length; i++) { array[array.length-i-1] = 10; }
-static HInstruction* BuildSSAGraph4(HGraph* graph,
-                                    ArenaAllocator* allocator,
-                                    int initial,
-                                    IfCondition cond = kCondGE) {
-  HBasicBlock* entry = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (allocator) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-
-  HInstruction* constant_initial = graph->GetIntConstant(initial);
-  HInstruction* constant_1 = graph->GetIntConstant(1);
-  HInstruction* constant_10 = graph->GetIntConstant(10);
-  HInstruction* constant_minus_1 = graph->GetIntConstant(-1);
-
-  HBasicBlock* block = new (allocator) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
-  block->AddInstruction(new (allocator) HGoto());
-
-  HBasicBlock* loop_header = new (allocator) HBasicBlock(graph);
-  HBasicBlock* loop_body = new (allocator) HBasicBlock(graph);
-  HBasicBlock* exit = new (allocator) HBasicBlock(graph);
-
-  graph->AddBlock(loop_header);
-  graph->AddBlock(loop_body);
-  graph->AddBlock(exit);
-  block->AddSuccessor(loop_header);
-  loop_header->AddSuccessor(exit);       // true successor
-  loop_header->AddSuccessor(loop_body);  // false successor
-  loop_body->AddSuccessor(loop_header);
-
-  HPhi* phi = new (allocator) HPhi(allocator, 0, 0, DataType::Type::kInt32);
-  HInstruction* null_check = new (allocator) HNullCheck(parameter, 0);
-  HInstruction* array_length = new (allocator) HArrayLength(null_check, 0);
-  HInstruction* cmp = nullptr;
-  if (cond == kCondGE) {
-    cmp = new (allocator) HGreaterThanOrEqual(phi, array_length);
-  } else if (cond == kCondGT) {
-    cmp = new (allocator) HGreaterThan(phi, array_length);
-  }
-  HInstruction* if_inst = new (allocator) HIf(cmp);
-  loop_header->AddPhi(phi);
-  loop_header->AddInstruction(null_check);
-  loop_header->AddInstruction(array_length);
-  loop_header->AddInstruction(cmp);
-  loop_header->AddInstruction(if_inst);
-  phi->AddInput(constant_initial);
-
-  null_check = new (allocator) HNullCheck(parameter, 0);
-  array_length = new (allocator) HArrayLength(null_check, 0);
-  HInstruction* sub = new (allocator) HSub(DataType::Type::kInt32, array_length, phi);
-  HInstruction* add_minus_1 = new (allocator)
-      HAdd(DataType::Type::kInt32, sub, constant_minus_1);
-  HInstruction* bounds_check = new (allocator) HBoundsCheck(add_minus_1, array_length, 0);
-  HInstruction* array_set = new (allocator) HArraySet(
-      null_check, bounds_check, constant_10, DataType::Type::kInt32, 0);
-  HInstruction* add = new (allocator) HAdd(DataType::Type::kInt32, phi, constant_1);
-  loop_body->AddInstruction(null_check);
-  loop_body->AddInstruction(array_length);
-  loop_body->AddInstruction(sub);
-  loop_body->AddInstruction(add_minus_1);
-  loop_body->AddInstruction(bounds_check);
-  loop_body->AddInstruction(array_set);
-  loop_body->AddInstruction(add);
-  loop_body->AddInstruction(new (allocator) HGoto());
-  phi->AddInput(add);
-
-  exit->AddInstruction(new (allocator) HExit());
+HInstruction* BoundsCheckEliminationTest::BuildSSAGraph4(int initial, IfCondition cond) {
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [pre_header, loop_header, loop_body] = CreateWhileLoop(return_block);
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+  HInstruction* constant_10 = graph_->GetIntConstant(10);
+  HInstruction* constant_minus_1 = graph_->GetIntConstant(-1);
+
+  auto [phi, add] = MakeLinearLoopVar(loop_header, loop_body, initial, /*increment=*/ 1);
+  HInstruction* null_check = MakeNullCheck(loop_header, parameter);
+  HInstruction* array_length = MakeArrayLength(loop_header, null_check);
+  DCHECK(cond == kCondGE || cond == kCondGT) << cond;
+  HInstruction* cmp = MakeCondition(loop_header, cond, phi, array_length);
+  MakeIf(loop_header, cmp);
+
+  null_check = MakeNullCheck(loop_body, parameter);
+  array_length = MakeArrayLength(loop_body, null_check);
+  HInstruction* sub = MakeBinOp<HSub>(loop_body, DataType::Type::kInt32, array_length, phi);
+  HInstruction* add_minus_1 =
+      MakeBinOp<HAdd>(loop_body, DataType::Type::kInt32, sub, constant_minus_1);
+  HInstruction* bounds_check = MakeBoundsCheck(loop_body, add_minus_1, array_length);
+  MakeArraySet(loop_body, null_check, bounds_check, constant_10, DataType::Type::kInt32);
 
   return bounds_check;
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination4a) {
   // for (int i=0; i<array.length; i++) { array[array.length-i-1] = 10; // Can eliminate with gvn. }
-  HInstruction* bounds_check = BuildSSAGraph4(graph_, GetAllocator(), 0);
+  HInstruction* bounds_check = BuildSSAGraph4(0);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination4b) {
   // for (int i=1; i<array.length; i++) { array[array.length-i-1] = 10; // Can eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph4(graph_, GetAllocator(), 1);
+  HInstruction* bounds_check = BuildSSAGraph4(1);
   RunBCE();
   ASSERT_TRUE(IsRemoved(bounds_check));
 }
 
 TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination4c) {
   // for (int i=0; i<=array.length; i++) { array[array.length-i] = 10; // Can't eliminate. }
-  HInstruction* bounds_check = BuildSSAGraph4(graph_, GetAllocator(), 0, kCondGT);
+  HInstruction* bounds_check = BuildSSAGraph4(0, kCondGT);
   RunBCE();
   ASSERT_FALSE(IsRemoved(bounds_check));
 }
@@ -782,165 +488,79 @@ TEST_F(BoundsCheckEliminationTest, LoopArrayBoundsElimination4c) {
 // Bubble sort:
 // (Every array access bounds-check can be eliminated.)
 // for (int i=0; i<array.length-1; i++) {
-//  for (int j=0; j<array.length-i-1; j++) {
+//   for (int j=0; j<array.length-i-1; j++) {
 //     if (array[j] > array[j+1]) {
 //       int temp = array[j+1];
 //       array[j+1] = array[j];
 //       array[j] = temp;
 //     }
-//  }
+//   }
 // }
 TEST_F(BoundsCheckEliminationTest, BubbleSortArrayBoundsElimination) {
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [outer_pre_header, outer_header, outer_body_add] = CreateWhileLoop(return_block);
+  auto [inner_pre_header, inner_header, inner_body_add] = CreateWhileLoop(outer_body_add);
+  auto [inner_body_compare, inner_body_swap, skip_swap] = CreateDiamondPattern(inner_body_add);
 
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
   HInstruction* constant_0 = graph_->GetIntConstant(0);
   HInstruction* constant_minus_1 = graph_->GetIntConstant(-1);
   HInstruction* constant_1 = graph_->GetIntConstant(1);
 
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block);
-  entry->AddSuccessor(block);
-  block->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(exit);
-  exit->AddInstruction(new (GetAllocator()) HExit());
-
-  HBasicBlock* outer_header = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(outer_header);
-  HPhi* phi_i = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HNullCheck* null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  HArrayLength* array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HAdd* add = new (GetAllocator()) HAdd(DataType::Type::kInt32, array_length, constant_minus_1);
-  HInstruction* cmp = new (GetAllocator()) HGreaterThanOrEqual(phi_i, add);
-  HIf* if_inst = new (GetAllocator()) HIf(cmp);
-  outer_header->AddPhi(phi_i);
-  outer_header->AddInstruction(null_check);
-  outer_header->AddInstruction(array_length);
-  outer_header->AddInstruction(add);
-  outer_header->AddInstruction(cmp);
-  outer_header->AddInstruction(if_inst);
-  phi_i->AddInput(constant_0);
-
-  HBasicBlock* inner_header = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(inner_header);
-  HPhi* phi_j = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HSub* sub = new (GetAllocator()) HSub(DataType::Type::kInt32, array_length, phi_i);
-  add = new (GetAllocator()) HAdd(DataType::Type::kInt32, sub, constant_minus_1);
-  cmp = new (GetAllocator()) HGreaterThanOrEqual(phi_j, add);
-  if_inst = new (GetAllocator()) HIf(cmp);
-  inner_header->AddPhi(phi_j);
-  inner_header->AddInstruction(null_check);
-  inner_header->AddInstruction(array_length);
-  inner_header->AddInstruction(sub);
-  inner_header->AddInstruction(add);
-  inner_header->AddInstruction(cmp);
-  inner_header->AddInstruction(if_inst);
-  phi_j->AddInput(constant_0);
-
-  HBasicBlock* inner_body_compare = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(inner_body_compare);
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check1 = new (GetAllocator()) HBoundsCheck(phi_j, array_length, 0);
-  HArrayGet* array_get_j = new (GetAllocator())
-      HArrayGet(null_check, bounds_check1, DataType::Type::kInt32, 0);
-  inner_body_compare->AddInstruction(null_check);
-  inner_body_compare->AddInstruction(array_length);
-  inner_body_compare->AddInstruction(bounds_check1);
-  inner_body_compare->AddInstruction(array_get_j);
-  HInstruction* j_plus_1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi_j, constant_1);
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HBoundsCheck* bounds_check2 = new (GetAllocator()) HBoundsCheck(j_plus_1, array_length, 0);
-  HArrayGet* array_get_j_plus_1 = new (GetAllocator())
-      HArrayGet(null_check, bounds_check2, DataType::Type::kInt32, 0);
-  cmp = new (GetAllocator()) HGreaterThanOrEqual(array_get_j, array_get_j_plus_1);
-  if_inst = new (GetAllocator()) HIf(cmp);
-  inner_body_compare->AddInstruction(j_plus_1);
-  inner_body_compare->AddInstruction(null_check);
-  inner_body_compare->AddInstruction(array_length);
-  inner_body_compare->AddInstruction(bounds_check2);
-  inner_body_compare->AddInstruction(array_get_j_plus_1);
-  inner_body_compare->AddInstruction(cmp);
-  inner_body_compare->AddInstruction(if_inst);
-
-  HBasicBlock* inner_body_swap = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(inner_body_swap);
-  j_plus_1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi_j, constant_1);
+  auto [phi_i, add_i] =
+      MakeLinearLoopVar(outer_header, outer_body_add, /*initial=*/ 0, /*increment=*/ 1);
+  HNullCheck* null_check = MakeNullCheck(outer_header, parameter);
+  HArrayLength* array_length = MakeArrayLength(outer_header, null_check);
+  HAdd* add = MakeBinOp<HAdd>(outer_header, DataType::Type::kInt32, array_length, constant_minus_1);
+  HInstruction* cmp = MakeCondition(outer_header, kCondGE, phi_i, add);
+  MakeIf(outer_header, cmp);
+
+  auto [phi_j, add_j] =
+      MakeLinearLoopVar(inner_header, inner_body_add, /*initial=*/ 0, /*increment=*/ 1);
+  null_check = MakeNullCheck(inner_header, parameter);
+  array_length = MakeArrayLength(inner_header, null_check);
+  HSub* sub = MakeBinOp<HSub>(inner_header, DataType::Type::kInt32, array_length, phi_i);
+  add = MakeBinOp<HAdd>(inner_header, DataType::Type::kInt32, sub, constant_minus_1);
+  cmp = MakeCondition(inner_header, kCondGE, phi_j, add);
+  MakeIf(inner_header, cmp);
+
+  null_check = MakeNullCheck(inner_body_compare, parameter);
+  array_length = MakeArrayLength(inner_body_compare, null_check);
+  HBoundsCheck* bounds_check1 = MakeBoundsCheck(inner_body_compare, phi_j, array_length);
+  HArrayGet* array_get_j =
+      MakeArrayGet(inner_body_compare, null_check, bounds_check1, DataType::Type::kInt32);
+  HInstruction* j_plus_1 =
+      MakeBinOp<HAdd>(inner_body_compare, DataType::Type::kInt32, phi_j, constant_1);
+  null_check = MakeNullCheck(inner_body_compare, parameter);
+  array_length = MakeArrayLength(inner_body_compare, null_check);
+  HBoundsCheck* bounds_check2 = MakeBoundsCheck(inner_body_compare, j_plus_1, array_length);
+  HArrayGet* array_get_j_plus_1 =
+      MakeArrayGet(inner_body_compare, null_check, bounds_check2, DataType::Type::kInt32);
+  cmp = MakeCondition(inner_body_compare, kCondGE, array_get_j, array_get_j_plus_1);
+  MakeIf(inner_body_compare, cmp);
+
+  j_plus_1 = MakeBinOp<HAdd>(inner_body_swap, DataType::Type::kInt32, phi_j, constant_1);
   // temp = array[j+1]
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HInstruction* bounds_check3 = new (GetAllocator()) HBoundsCheck(j_plus_1, array_length, 0);
-  array_get_j_plus_1 = new (GetAllocator())
-      HArrayGet(null_check, bounds_check3, DataType::Type::kInt32, 0);
-  inner_body_swap->AddInstruction(j_plus_1);
-  inner_body_swap->AddInstruction(null_check);
-  inner_body_swap->AddInstruction(array_length);
-  inner_body_swap->AddInstruction(bounds_check3);
-  inner_body_swap->AddInstruction(array_get_j_plus_1);
+  null_check = MakeNullCheck(inner_body_swap, parameter);
+  array_length = MakeArrayLength(inner_body_swap, null_check);
+  HInstruction* bounds_check3 = MakeBoundsCheck(inner_body_swap, j_plus_1, array_length);
+  array_get_j_plus_1 =
+      MakeArrayGet(inner_body_swap, null_check, bounds_check3, DataType::Type::kInt32);
   // array[j+1] = array[j]
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HInstruction* bounds_check4 = new (GetAllocator()) HBoundsCheck(phi_j, array_length, 0);
-  array_get_j = new (GetAllocator())
-      HArrayGet(null_check, bounds_check4, DataType::Type::kInt32, 0);
-  inner_body_swap->AddInstruction(null_check);
-  inner_body_swap->AddInstruction(array_length);
-  inner_body_swap->AddInstruction(bounds_check4);
-  inner_body_swap->AddInstruction(array_get_j);
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HInstruction* bounds_check5 = new (GetAllocator()) HBoundsCheck(j_plus_1, array_length, 0);
-  HArraySet* array_set_j_plus_1 = new (GetAllocator())
-      HArraySet(null_check, bounds_check5, array_get_j, DataType::Type::kInt32, 0);
-  inner_body_swap->AddInstruction(null_check);
-  inner_body_swap->AddInstruction(array_length);
-  inner_body_swap->AddInstruction(bounds_check5);
-  inner_body_swap->AddInstruction(array_set_j_plus_1);
+  null_check = MakeNullCheck(inner_body_swap, parameter);
+  array_length = MakeArrayLength(inner_body_swap, null_check);
+  HInstruction* bounds_check4 = MakeBoundsCheck(inner_body_swap, phi_j, array_length);
+  array_get_j = MakeArrayGet(inner_body_swap, null_check, bounds_check4, DataType::Type::kInt32);
+  null_check = MakeNullCheck(inner_body_swap, parameter);
+  array_length = MakeArrayLength(inner_body_swap, null_check);
+  HInstruction* bounds_check5 = MakeBoundsCheck(inner_body_swap, j_plus_1, array_length);
+  MakeArraySet(inner_body_swap, null_check, bounds_check5, array_get_j, DataType::Type::kInt32);
   // array[j] = temp
-  null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HInstruction* bounds_check6 = new (GetAllocator()) HBoundsCheck(phi_j, array_length, 0);
-  HArraySet* array_set_j = new (GetAllocator())
-      HArraySet(null_check, bounds_check6, array_get_j_plus_1, DataType::Type::kInt32, 0);
-  inner_body_swap->AddInstruction(null_check);
-  inner_body_swap->AddInstruction(array_length);
-  inner_body_swap->AddInstruction(bounds_check6);
-  inner_body_swap->AddInstruction(array_set_j);
-  inner_body_swap->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* inner_body_add = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(inner_body_add);
-  add = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi_j, constant_1);
-  inner_body_add->AddInstruction(add);
-  inner_body_add->AddInstruction(new (GetAllocator()) HGoto());
-  phi_j->AddInput(add);
-
-  HBasicBlock* outer_body_add = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(outer_body_add);
-  add = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi_i, constant_1);
-  outer_body_add->AddInstruction(add);
-  outer_body_add->AddInstruction(new (GetAllocator()) HGoto());
-  phi_i->AddInput(add);
-
-  block->AddSuccessor(outer_header);
-  outer_header->AddSuccessor(exit);
-  outer_header->AddSuccessor(inner_header);
-  inner_header->AddSuccessor(outer_body_add);
-  inner_header->AddSuccessor(inner_body_compare);
-  inner_body_compare->AddSuccessor(inner_body_add);
-  inner_body_compare->AddSuccessor(inner_body_swap);
-  inner_body_swap->AddSuccessor(inner_body_add);
-  inner_body_add->AddSuccessor(inner_header);
-  outer_body_add->AddSuccessor(outer_header);
+  null_check = MakeNullCheck(inner_body_swap, parameter);
+  array_length = MakeArrayLength(inner_body_swap, null_check);
+  HInstruction* bounds_check6 = MakeBoundsCheck(inner_body_swap, phi_j, array_length);
+  MakeArraySet(
+      inner_body_swap, null_check, bounds_check6, array_get_j_plus_1, DataType::Type::kInt32);
 
   RunBCE();  // gvn removes same bounds check already
 
@@ -962,146 +582,83 @@ TEST_F(BoundsCheckEliminationTest, BubbleSortArrayBoundsElimination) {
 //   array[param_i%10] = 10;      // Can't eliminate, when param_i < 0
 // }
 TEST_F(BoundsCheckEliminationTest, ModArrayBoundsElimination) {
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-  HInstruction* param_i = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  entry->AddInstruction(param_i);
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [pre_header, loop_header, loop_body] = CreateWhileLoop(return_block);
 
-  HInstruction* constant_0 = graph_->GetIntConstant(0);
+  HInstruction* param_i = MakeParam(DataType::Type::kInt32);
   HInstruction* constant_1 = graph_->GetIntConstant(1);
   HInstruction* constant_10 = graph_->GetIntConstant(10);
   HInstruction* constant_200 = graph_->GetIntConstant(200);
   HInstruction* constant_minus_10 = graph_->GetIntConstant(-10);
 
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block);
-  entry->AddSuccessor(block);
   // We pass a bogus constant for the class to avoid mocking one.
-  HInstruction* new_array = new (GetAllocator()) HNewArray(
-      /* cls= */ constant_10,
-      /* length= */ constant_10,
-      /* dex_pc= */ 0,
-      /* component_size_shift= */ 0);
-  block->AddInstruction(new_array);
-  block->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* loop_header = new (GetAllocator()) HBasicBlock(graph_);
-  HBasicBlock* loop_body = new (GetAllocator()) HBasicBlock(graph_);
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph_);
-
-  graph_->AddBlock(loop_header);
-  graph_->AddBlock(loop_body);
-  graph_->AddBlock(exit);
-  block->AddSuccessor(loop_header);
-  loop_header->AddSuccessor(exit);       // true successor
-  loop_header->AddSuccessor(loop_body);  // false successor
-  loop_body->AddSuccessor(loop_header);
-
-  HPhi* phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HInstruction* cmp = new (GetAllocator()) HGreaterThanOrEqual(phi, constant_200);
-  HInstruction* if_inst = new (GetAllocator()) HIf(cmp);
-  loop_header->AddPhi(phi);
-  loop_header->AddInstruction(cmp);
-  loop_header->AddInstruction(if_inst);
-  phi->AddInput(constant_0);
+  HInstruction* new_array =
+      MakeNewArray(pre_header, /* cls= */ constant_10, /* length= */ constant_10);
+
+  auto [phi, add] = MakeLinearLoopVar(loop_header, loop_body, /*initial=*/ 0, /*increment=*/ 1);
+  HInstruction* cmp = MakeCondition(loop_header, kCondGE, phi, constant_200);
+  MakeIf(loop_header, cmp);
 
   //////////////////////////////////////////////////////////////////////////////////
   // LOOP BODY:
   // array[i % 10] = 10;
-  HRem* i_mod_10 = new (GetAllocator()) HRem(DataType::Type::kInt32, phi, constant_10, 0);
-  HBoundsCheck* bounds_check_i_mod_10 = new (GetAllocator()) HBoundsCheck(i_mod_10, constant_10, 0);
-  HInstruction* array_set = new (GetAllocator()) HArraySet(
-      new_array, bounds_check_i_mod_10, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(i_mod_10);
-  loop_body->AddInstruction(bounds_check_i_mod_10);
-  loop_body->AddInstruction(array_set);
+  HRem* i_mod_10 = MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, phi, constant_10);
+  HBoundsCheck* bounds_check_i_mod_10 = MakeBoundsCheck(loop_body, i_mod_10, constant_10);
+  MakeArraySet(loop_body, new_array, bounds_check_i_mod_10, constant_10, DataType::Type::kInt32);
 
   // array[i % 1] = 10;
-  HRem* i_mod_1 = new (GetAllocator()) HRem(DataType::Type::kInt32, phi, constant_1, 0);
-  HBoundsCheck* bounds_check_i_mod_1 = new (GetAllocator()) HBoundsCheck(i_mod_1, constant_10, 0);
-  array_set = new (GetAllocator()) HArraySet(
-      new_array, bounds_check_i_mod_1, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(i_mod_1);
-  loop_body->AddInstruction(bounds_check_i_mod_1);
-  loop_body->AddInstruction(array_set);
+  HRem* i_mod_1 = MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, phi, constant_1);
+  HBoundsCheck* bounds_check_i_mod_1 = MakeBoundsCheck(loop_body, i_mod_1, constant_10);
+  MakeArraySet(loop_body, new_array, bounds_check_i_mod_1, constant_10, DataType::Type::kInt32);
 
   // array[i % 200] = 10;
-  HRem* i_mod_200 = new (GetAllocator()) HRem(DataType::Type::kInt32, phi, constant_1, 0);
-  HBoundsCheck* bounds_check_i_mod_200 = new (GetAllocator()) HBoundsCheck(
-      i_mod_200, constant_10, 0);
-  array_set = new (GetAllocator()) HArraySet(
-      new_array, bounds_check_i_mod_200, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(i_mod_200);
-  loop_body->AddInstruction(bounds_check_i_mod_200);
-  loop_body->AddInstruction(array_set);
+  HRem* i_mod_200 = MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, phi, constant_200);
+  HBoundsCheck* bounds_check_i_mod_200 = MakeBoundsCheck(loop_body, i_mod_200, constant_10);
+  MakeArraySet(loop_body, new_array, bounds_check_i_mod_200, constant_10, DataType::Type::kInt32);
 
   // array[i % -10] = 10;
-  HRem* i_mod_minus_10 = new (GetAllocator()) HRem(
-      DataType::Type::kInt32, phi, constant_minus_10, 0);
-  HBoundsCheck* bounds_check_i_mod_minus_10 = new (GetAllocator()) HBoundsCheck(
-      i_mod_minus_10, constant_10, 0);
-  array_set = new (GetAllocator()) HArraySet(
-      new_array, bounds_check_i_mod_minus_10, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(i_mod_minus_10);
-  loop_body->AddInstruction(bounds_check_i_mod_minus_10);
-  loop_body->AddInstruction(array_set);
+  HRem* i_mod_minus_10 = MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, phi, constant_minus_10);
+  HBoundsCheck* bounds_check_i_mod_minus_10 =
+      MakeBoundsCheck(loop_body, i_mod_minus_10, constant_10);
+  MakeArraySet(
+      loop_body, new_array, bounds_check_i_mod_minus_10, constant_10, DataType::Type::kInt32);
 
   // array[i%array.length] = 10;
-  HNullCheck* null_check = new (GetAllocator()) HNullCheck(new_array, 0);
-  HArrayLength* array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HRem* i_mod_array_length = new (GetAllocator()) HRem(
-      DataType::Type::kInt32, phi, array_length, 0);
-  HBoundsCheck* bounds_check_i_mod_array_len = new (GetAllocator()) HBoundsCheck(
-      i_mod_array_length, array_length, 0);
-  array_set = new (GetAllocator()) HArraySet(
-      null_check, bounds_check_i_mod_array_len, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(null_check);
-  loop_body->AddInstruction(array_length);
-  loop_body->AddInstruction(i_mod_array_length);
-  loop_body->AddInstruction(bounds_check_i_mod_array_len);
-  loop_body->AddInstruction(array_set);
+  HNullCheck* null_check = MakeNullCheck(loop_body, new_array);
+  HArrayLength* array_length = MakeArrayLength(loop_body, null_check);
+  HRem* i_mod_array_length = MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, phi, array_length);
+  HBoundsCheck* bounds_check_i_mod_array_len =
+      MakeBoundsCheck(loop_body, i_mod_array_length, array_length);
+  MakeArraySet(
+      loop_body, null_check, bounds_check_i_mod_array_len, constant_10, DataType::Type::kInt32);
 
   // array[param_i % 10] = 10;
-  HRem* param_i_mod_10 = new (GetAllocator()) HRem(DataType::Type::kInt32, param_i, constant_10, 0);
-  HBoundsCheck* bounds_check_param_i_mod_10 = new (GetAllocator()) HBoundsCheck(
-      param_i_mod_10, constant_10, 0);
-  array_set = new (GetAllocator()) HArraySet(
-      new_array, bounds_check_param_i_mod_10, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(param_i_mod_10);
-  loop_body->AddInstruction(bounds_check_param_i_mod_10);
-  loop_body->AddInstruction(array_set);
+  HRem* param_i_mod_10 = MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, param_i, constant_10);
+  HBoundsCheck* bounds_check_param_i_mod_10 =
+      MakeBoundsCheck(loop_body, param_i_mod_10, constant_10);
+  MakeArraySet(
+      loop_body, new_array, bounds_check_param_i_mod_10, constant_10, DataType::Type::kInt32);
 
   // array[param_i%array.length] = 10;
-  null_check = new (GetAllocator()) HNullCheck(new_array, 0);
-  array_length = new (GetAllocator()) HArrayLength(null_check, 0);
-  HRem* param_i_mod_array_length = new (GetAllocator()) HRem(
-      DataType::Type::kInt32, param_i, array_length, 0);
-  HBoundsCheck* bounds_check_param_i_mod_array_len = new (GetAllocator()) HBoundsCheck(
-      param_i_mod_array_length, array_length, 0);
-  array_set = new (GetAllocator()) HArraySet(
-      null_check, bounds_check_param_i_mod_array_len, constant_10, DataType::Type::kInt32, 0);
-  loop_body->AddInstruction(null_check);
-  loop_body->AddInstruction(array_length);
-  loop_body->AddInstruction(param_i_mod_array_length);
-  loop_body->AddInstruction(bounds_check_param_i_mod_array_len);
-  loop_body->AddInstruction(array_set);
-
-  // i++;
-  HInstruction* add = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi, constant_1);
-  loop_body->AddInstruction(add);
-  loop_body->AddInstruction(new (GetAllocator()) HGoto());
-  phi->AddInput(add);
-  //////////////////////////////////////////////////////////////////////////////////
+  null_check = MakeNullCheck(loop_body, new_array);
+  array_length = MakeArrayLength(loop_body, null_check);
+  HRem* param_i_mod_array_length =
+      MakeBinOp<HRem>(loop_body, DataType::Type::kInt32, param_i, array_length);
+  HBoundsCheck* bounds_check_param_i_mod_array_len =
+      MakeBoundsCheck(loop_body, param_i_mod_array_length, array_length);
+  MakeArraySet(loop_body,
+               null_check,
+               bounds_check_param_i_mod_array_len,
+               constant_10,
+               DataType::Type::kInt32);
 
-  exit->AddInstruction(new (GetAllocator()) HExit());
+  //////////////////////////////////////////////////////////////////////////////////
 
   RunBCE();
 
   ASSERT_TRUE(IsRemoved(bounds_check_i_mod_10));
   ASSERT_TRUE(IsRemoved(bounds_check_i_mod_1));
-  ASSERT_TRUE(IsRemoved(bounds_check_i_mod_200));
+  ASSERT_FALSE(IsRemoved(bounds_check_i_mod_200));
   ASSERT_TRUE(IsRemoved(bounds_check_i_mod_minus_10));
   ASSERT_TRUE(IsRemoved(bounds_check_i_mod_array_len));
   ASSERT_FALSE(IsRemoved(bounds_check_param_i_mod_10));
diff --git a/compiler/optimizing/code_generation_data.cc b/compiler/optimizing/code_generation_data.cc
index 7b23d46dc5..afc4f62f0f 100644
--- a/compiler/optimizing/code_generation_data.cc
+++ b/compiler/optimizing/code_generation_data.cc
@@ -20,6 +20,7 @@
 #include "intern_table.h"
 #include "mirror/object-inl.h"
 #include "runtime.h"
+#include "well_known_classes-inl.h"
 
 namespace art HIDDEN {
 
@@ -52,6 +53,16 @@ void CodeGenerationData::EmitJitRoots(
     entry.second = index;
     ++index;
   }
+  for (auto& entry : jit_method_type_roots_) {
+    // Update the `roots` with the MethodType, and replace the address temporarily
+    // stored to the index in the table.
+    uint64_t address = entry.second;
+    roots->emplace_back(reinterpret_cast<StackReference<mirror::Object>*>(address));
+    DCHECK(roots->back() != nullptr);
+    DCHECK(roots->back()->InstanceOf(WellKnownClasses::java_lang_invoke_MethodType.Get()));
+    entry.second = index;
+    ++index;
+  }
 }
 
 }  // namespace art
diff --git a/compiler/optimizing/code_generation_data.h b/compiler/optimizing/code_generation_data.h
index e78ba8f574..0d4db66ab4 100644
--- a/compiler/optimizing/code_generation_data.h
+++ b/compiler/optimizing/code_generation_data.h
@@ -23,10 +23,12 @@
 #include "base/scoped_arena_allocator.h"
 #include "base/scoped_arena_containers.h"
 #include "code_generator.h"
+#include "dex/proto_reference.h"
 #include "dex/string_reference.h"
 #include "dex/type_reference.h"
 #include "handle.h"
 #include "mirror/class.h"
+#include "mirror/method_type.h"
 #include "mirror/object.h"
 #include "mirror/string.h"
 #include "stack_map_stream.h"
@@ -82,8 +84,24 @@ class CodeGenerationData : public DeletableArenaObject<kArenaAllocCodeGenerator>
     return jit_class_roots_.size();
   }
 
+  void ReserveJitMethodTypeRoot(ProtoReference proto_reference,
+                                Handle<mirror::MethodType> method_type) {
+    jit_method_type_roots_.Overwrite(proto_reference,
+                                     reinterpret_cast64<uint64_t>(method_type.GetReference()));
+  }
+
+  uint64_t GetJitMethodTypeRootIndex(ProtoReference proto_reference) const {
+    return jit_method_type_roots_.Get(proto_reference);
+  }
+
+  size_t GetNumberOfJitMethodTypeRoots() const {
+    return jit_method_type_roots_.size();
+  }
+
   size_t GetNumberOfJitRoots() const {
-    return GetNumberOfJitStringRoots() + GetNumberOfJitClassRoots();
+    return GetNumberOfJitStringRoots() +
+           GetNumberOfJitClassRoots() +
+           GetNumberOfJitMethodTypeRoots();
   }
 
   void EmitJitRoots(/*out*/std::vector<Handle<mirror::Object>>* roots)
@@ -97,7 +115,9 @@ class CodeGenerationData : public DeletableArenaObject<kArenaAllocCodeGenerator>
         jit_string_roots_(StringReferenceValueComparator(),
                           allocator_.Adapter(kArenaAllocCodeGenerator)),
         jit_class_roots_(TypeReferenceValueComparator(),
-                         allocator_.Adapter(kArenaAllocCodeGenerator)) {
+                         allocator_.Adapter(kArenaAllocCodeGenerator)),
+        jit_method_type_roots_(ProtoReferenceValueComparator(),
+                               allocator_.Adapter(kArenaAllocCodeGenerator)) {
     slow_paths_.reserve(kDefaultSlowPathsCapacity);
   }
 
@@ -116,6 +136,12 @@ class CodeGenerationData : public DeletableArenaObject<kArenaAllocCodeGenerator>
   // Entries are initially added with a pointer in the handle zone, and `EmitJitRoots`
   // will compute all the indices.
   ScopedArenaSafeMap<TypeReference, uint64_t, TypeReferenceValueComparator> jit_class_roots_;
+
+  // Maps a ProtoReference (dex_file, proto_index) to the index in the literal table.
+  // Entries are initially added with a pointer in the handle zone, and `EmitJitRoots`
+  // will compute all the indices.
+  ScopedArenaSafeMap<ProtoReference, uint64_t, ProtoReferenceValueComparator>
+      jit_method_type_roots_;
 };
 
 }  // namespace art
diff --git a/compiler/optimizing/code_generator.cc b/compiler/optimizing/code_generator.cc
index 88bd818b0c..51714ef548 100644
--- a/compiler/optimizing/code_generator.cc
+++ b/compiler/optimizing/code_generator.cc
@@ -16,6 +16,7 @@
 
 #include "code_generator.h"
 #include "base/globals.h"
+#include "mirror/method_type.h"
 
 #ifdef ART_ENABLE_CODEGEN_arm
 #include "code_generator_arm_vixl.h"
@@ -209,11 +210,23 @@ uint64_t CodeGenerator::GetJitClassRootIndex(TypeReference type_reference) {
   return code_generation_data_->GetJitClassRootIndex(type_reference);
 }
 
+void CodeGenerator::ReserveJitMethodTypeRoot(ProtoReference proto_reference,
+                                             Handle<mirror::MethodType> method_type) {
+  DCHECK(code_generation_data_ != nullptr);
+  code_generation_data_->ReserveJitMethodTypeRoot(proto_reference, method_type);
+}
+
+uint64_t CodeGenerator::GetJitMethodTypeRootIndex(ProtoReference proto_reference) {
+  DCHECK(code_generation_data_ != nullptr);
+  return code_generation_data_->GetJitMethodTypeRootIndex(proto_reference);
+}
+
 void CodeGenerator::EmitJitRootPatches([[maybe_unused]] uint8_t* code,
                                        [[maybe_unused]] const uint8_t* roots_data) {
   DCHECK(code_generation_data_ != nullptr);
   DCHECK_EQ(code_generation_data_->GetNumberOfJitStringRoots(), 0u);
   DCHECK_EQ(code_generation_data_->GetNumberOfJitClassRoots(), 0u);
+  DCHECK_EQ(code_generation_data_->GetNumberOfJitMethodTypeRoots(), 0u);
 }
 
 uint32_t CodeGenerator::GetArrayLengthOffset(HArrayLength* array_length) {
diff --git a/compiler/optimizing/code_generator.h b/compiler/optimizing/code_generator.h
index aec7b45a1a..950bae5c8f 100644
--- a/compiler/optimizing/code_generator.h
+++ b/compiler/optimizing/code_generator.h
@@ -29,10 +29,12 @@
 #include "base/memory_region.h"
 #include "base/pointer_size.h"
 #include "class_root.h"
+#include "dex/proto_reference.h"
 #include "dex/string_reference.h"
 #include "dex/type_reference.h"
 #include "graph_visualizer.h"
 #include "locations.h"
+#include "mirror/method_type.h"
 #include "nodes.h"
 #include "oat/oat_quick_method_header.h"
 #include "optimizing_compiler_stats.h"
@@ -834,6 +836,9 @@ class CodeGenerator : public DeletableArenaObject<kArenaAllocCodeGenerator> {
   uint64_t GetJitStringRootIndex(StringReference string_reference);
   void ReserveJitClassRoot(TypeReference type_reference, Handle<mirror::Class> klass);
   uint64_t GetJitClassRootIndex(TypeReference type_reference);
+  void ReserveJitMethodTypeRoot(ProtoReference proto_reference,
+                                Handle<mirror::MethodType> method_type);
+  uint64_t GetJitMethodTypeRootIndex(ProtoReference proto_reference);
 
   // Emit the patches assocatied with JIT roots. Only applies to JIT compiled code.
   virtual void EmitJitRootPatches(uint8_t* code, const uint8_t* roots_data);
diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index 226e5343e2..42d955ef9e 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -27,6 +27,7 @@
 #include "class_root-inl.h"
 #include "class_table.h"
 #include "code_generator_utils.h"
+#include "com_android_art_flags.h"
 #include "entrypoints/quick/quick_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints_enum.h"
 #include "gc/accounting/card_table.h"
@@ -58,6 +59,8 @@ using vixl::ExactAssemblyScope;
 using vixl::CodeBufferCheckScope;
 using vixl::EmissionCheckScope;
 
+namespace art_flags = com::android::art::flags;
+
 #ifdef __
 #error "ARM64 Codegen VIXL macro-assembler macro already defined."
 #endif
@@ -100,12 +103,6 @@ uint16_t SYS_CNTVCT_EL0 = SystemRegisterEncoder<1, 3, 14, 0, 2>::value;
 // generates less code/data with a small num_entries.
 static constexpr uint32_t kPackedSwitchCompareJumpThreshold = 7;
 
-// Reference load (except object array loads) is using LDR Wt, [Xn, #offset] which can handle
-// offset < 16KiB. For offsets >= 16KiB, the load shall be emitted as two or more instructions.
-// For the Baker read barrier implementation using link-time generated thunks we need to split
-// the offset explicitly.
-constexpr uint32_t kReferenceLoadMinFarOffset = 16 * KB;
-
 inline Condition ARM64Condition(IfCondition cond) {
   switch (cond) {
     case kCondEQ: return eq;
@@ -818,6 +815,32 @@ class ReadBarrierForRootSlowPathARM64 : public SlowPathCodeARM64 {
   DISALLOW_COPY_AND_ASSIGN(ReadBarrierForRootSlowPathARM64);
 };
 
+class TracingMethodEntryExitHooksSlowPathARM64 : public SlowPathCodeARM64 {
+ public:
+  explicit TracingMethodEntryExitHooksSlowPathARM64(bool is_method_entry)
+      : SlowPathCodeARM64(/* instruction= */ nullptr), is_method_entry_(is_method_entry) {}
+
+  void EmitNativeCode(CodeGenerator* codegen) override {
+    QuickEntrypointEnum entry_point =
+        (is_method_entry_) ? kQuickRecordEntryTraceEvent : kQuickRecordExitTraceEvent;
+    vixl::aarch64::Label call;
+    __ Bind(GetEntryLabel());
+    uint32_t entrypoint_offset = GetThreadOffset<kArm64PointerSize>(entry_point).Int32Value();
+    __ Ldr(lr, MemOperand(tr, entrypoint_offset));
+    __ Blr(lr);
+    __ B(GetExitLabel());
+  }
+
+  const char* GetDescription() const override {
+    return "TracingMethodEntryExitHooksSlowPath";
+  }
+
+ private:
+  const bool is_method_entry_;
+
+  DISALLOW_COPY_AND_ASSIGN(TracingMethodEntryExitHooksSlowPathARM64);
+};
+
 class MethodEntryExitHooksSlowPathARM64 : public SlowPathCodeARM64 {
  public:
   explicit MethodEntryExitHooksSlowPathARM64(HInstruction* instruction)
@@ -1212,8 +1235,8 @@ void InstructionCodeGeneratorARM64::GenerateMethodEntryExitHook(HInstruction* in
   MacroAssembler* masm = GetVIXLAssembler();
   UseScratchRegisterScope temps(masm);
   Register addr = temps.AcquireX();
-  Register index = temps.AcquireX();
-  Register value = index.W();
+  Register curr_entry = temps.AcquireX();
+  Register value = curr_entry.W();
 
   SlowPathCodeARM64* slow_path =
       new (codegen_->GetScopedAllocator()) MethodEntryExitHooksSlowPathARM64(instruction);
@@ -1242,21 +1265,20 @@ void InstructionCodeGeneratorARM64::GenerateMethodEntryExitHook(HInstruction* in
   // If yes, just take the slow path.
   __ B(gt, slow_path->GetEntryLabel());
 
+  Register init_entry = addr;
   // Check if there is place in the buffer to store a new entry, if no, take slow path.
-  uint32_t trace_buffer_index_offset =
-      Thread::TraceBufferIndexOffset<kArm64PointerSize>().Int32Value();
-  __ Ldr(index, MemOperand(tr, trace_buffer_index_offset));
-  __ Subs(index, index, kNumEntriesForWallClock);
+  uint32_t trace_buffer_curr_entry_offset =
+      Thread::TraceBufferCurrPtrOffset<kArm64PointerSize>().Int32Value();
+  __ Ldr(curr_entry, MemOperand(tr, trace_buffer_curr_entry_offset));
+  __ Sub(curr_entry, curr_entry, kNumEntriesForWallClock * sizeof(void*));
+  __ Ldr(init_entry, MemOperand(tr, Thread::TraceBufferPtrOffset<kArm64PointerSize>().SizeValue()));
+  __ Cmp(curr_entry, init_entry);
   __ B(lt, slow_path->GetEntryLabel());
 
   // Update the index in the `Thread`.
-  __ Str(index, MemOperand(tr, trace_buffer_index_offset));
-  // Calculate the entry address in the buffer.
-  // addr = base_addr + sizeof(void*) * index;
-  __ Ldr(addr, MemOperand(tr, Thread::TraceBufferPtrOffset<kArm64PointerSize>().SizeValue()));
-  __ ComputeAddress(addr, MemOperand(addr, index, LSL, TIMES_8));
+  __ Str(curr_entry, MemOperand(tr, trace_buffer_curr_entry_offset));
 
-  Register tmp = index;
+  Register tmp = init_entry;
   // Record method pointer and trace action.
   __ Ldr(tmp, MemOperand(sp, 0));
   // Use last two bits to encode trace method action. For MethodEntry it is 0
@@ -1267,10 +1289,10 @@ void InstructionCodeGeneratorARM64::GenerateMethodEntryExitHook(HInstruction* in
     static_assert(enum_cast<int32_t>(TraceAction::kTraceMethodExit) == 1);
     __ Orr(tmp, tmp, Operand(enum_cast<int32_t>(TraceAction::kTraceMethodExit)));
   }
-  __ Str(tmp, MemOperand(addr, kMethodOffsetInBytes));
+  __ Str(tmp, MemOperand(curr_entry, kMethodOffsetInBytes));
   // Record the timestamp.
   __ Mrs(tmp, (SystemRegister)SYS_CNTVCT_EL0);
-  __ Str(tmp, MemOperand(addr, kTimestampOffsetInBytes));
+  __ Str(tmp, MemOperand(curr_entry, kTimestampOffsetInBytes));
   __ Bind(slow_path->GetExitLabel());
 }
 
@@ -1290,6 +1312,25 @@ void InstructionCodeGeneratorARM64::VisitMethodEntryHook(HMethodEntryHook* instr
   GenerateMethodEntryExitHook(instruction);
 }
 
+void CodeGeneratorARM64::MaybeRecordTraceEvent(bool is_method_entry) {
+  if (!art_flags::always_enable_profile_code()) {
+    return;
+  }
+
+  MacroAssembler* masm = GetVIXLAssembler();
+  UseScratchRegisterScope temps(masm);
+  Register addr = temps.AcquireX();
+  CHECK(addr.Is(vixl::aarch64::x16));
+
+  SlowPathCodeARM64* slow_path =
+      new (GetScopedAllocator()) TracingMethodEntryExitHooksSlowPathARM64(is_method_entry);
+  AddSlowPath(slow_path);
+
+  __ Ldr(addr, MemOperand(tr, Thread::TraceBufferPtrOffset<kArm64PointerSize>().SizeValue()));
+  __ Cbnz(addr, slow_path->GetEntryLabel());
+  __ Bind(slow_path->GetExitLabel());
+}
+
 void CodeGeneratorARM64::MaybeIncrementHotness(HSuspendCheck* suspend_check, bool is_frame_entry) {
   MacroAssembler* masm = GetVIXLAssembler();
   if (GetCompilerOptions().CountHotnessInCompiledCode()) {
@@ -1444,6 +1485,8 @@ void CodeGeneratorARM64::GenerateFrameEntry() {
       Register wzr = Register(VIXLRegCodeFromART(WZR), kWRegSize);
       __ Str(wzr, MemOperand(sp, GetStackOffsetOfShouldDeoptimizeFlag()));
     }
+
+    MaybeRecordTraceEvent(/* is_method_entry= */ true);
   }
   MaybeIncrementHotness(/* suspend_check= */ nullptr, /* is_frame_entry= */ true);
   MaybeGenerateMarkingRegisterCheck(/* code= */ __LINE__);
@@ -1452,6 +1495,8 @@ void CodeGeneratorARM64::GenerateFrameEntry() {
 void CodeGeneratorARM64::GenerateFrameExit() {
   GetAssembler()->cfi().RememberState();
   if (!HasEmptyFrame()) {
+    MaybeRecordTraceEvent(/* is_method_entry= */ false);
+
     int32_t frame_size = dchecked_integral_cast<int32_t>(GetFrameSize());
     uint32_t core_spills_offset = frame_size - GetCoreSpillSize();
     CPURegList preserved_core_registers = GetFramePreservedCoreRegisters();
@@ -2240,12 +2285,12 @@ void LocationsBuilderARM64::HandleFieldGet(HInstruction* instruction,
   if (DataType::IsFloatingPointType(instruction->GetType())) {
     locations->SetOut(Location::RequiresFpuRegister());
   } else {
-    // The output overlaps for an object field get when read barriers
-    // are enabled: we do not want the load to overwrite the object's
-    // location, as we need it to emit the read barrier.
-    locations->SetOut(
-        Location::RequiresRegister(),
-        object_field_get_with_read_barrier ? Location::kOutputOverlap : Location::kNoOutputOverlap);
+    // The output overlaps for an object field get for non-Baker read barriers: we do not want
+    // the load to overwrite the object's location, as we need it to emit the read barrier.
+    // Baker read barrier implementation with introspection does not have this restriction.
+    bool overlap = object_field_get_with_read_barrier && !kUseBakerReadBarrier;
+    locations->SetOut(Location::RequiresRegister(),
+                      overlap ? Location::kOutputOverlap : Location::kNoOutputOverlap);
   }
 }
 
@@ -2385,6 +2430,22 @@ void InstructionCodeGeneratorARM64::HandleBinaryOp(HBinaryOperation* instr) {
         __ Orr(dst, lhs, rhs);
       } else if (instr->IsSub()) {
         __ Sub(dst, lhs, rhs);
+      } else if (instr->IsRol()) {
+        if (rhs.IsImmediate()) {
+          uint32_t shift = (-rhs.GetImmediate()) & (lhs.GetSizeInBits() - 1);
+          __ Ror(dst, lhs, shift);
+        } else {
+          UseScratchRegisterScope temps(GetVIXLAssembler());
+
+          // Ensure shift distance is in the same size register as the result. If
+          // we are rotating a long and the shift comes in a w register originally,
+          // we don't need to sxtw for use as an x since the shift distances are
+          // all & reg_bits - 1.
+          Register right = RegisterFrom(instr->GetLocations()->InAt(1), type);
+          Register negated = (type == DataType::Type::kInt32) ? temps.AcquireW() : temps.AcquireX();
+          __ Neg(negated, right);
+          __ Ror(dst, lhs, negated);
+        }
       } else if (instr->IsRor()) {
         if (rhs.IsImmediate()) {
           uint32_t shift = rhs.GetImmediate() & (lhs.GetSizeInBits() - 1);
@@ -2734,12 +2795,12 @@ void LocationsBuilderARM64::VisitArrayGet(HArrayGet* instruction) {
   if (DataType::IsFloatingPointType(instruction->GetType())) {
     locations->SetOut(Location::RequiresFpuRegister(), Location::kNoOutputOverlap);
   } else {
-    // The output overlaps in the case of an object array get with
-    // read barriers enabled: we do not want the move to overwrite the
-    // array's location, as we need it to emit the read barrier.
-    locations->SetOut(
-        Location::RequiresRegister(),
-        object_array_get_with_read_barrier ? Location::kOutputOverlap : Location::kNoOutputOverlap);
+    // The output overlaps for an object array get for non-Baker read barriers: we do not want
+    // the load to overwrite the object's location, as we need it to emit the read barrier.
+    // Baker read barrier implementation with introspection does not have this restriction.
+    bool overlap = object_array_get_with_read_barrier && !kUseBakerReadBarrier;
+    locations->SetOut(Location::RequiresRegister(),
+                      overlap ? Location::kOutputOverlap : Location::kNoOutputOverlap);
   }
 }
 
@@ -3219,16 +3280,18 @@ void InstructionCodeGeneratorARM64::GenerateFcmp(HInstruction* instruction) {
 void LocationsBuilderARM64::VisitCompare(HCompare* compare) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(compare, LocationSummary::kNoCall);
-  DataType::Type in_type = compare->InputAt(0)->GetType();
+  DataType::Type compare_type = compare->GetComparisonType();
   HInstruction* rhs = compare->InputAt(1);
-  switch (in_type) {
+  switch (compare_type) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
     case DataType::Type::kUint16:
     case DataType::Type::kInt16:
     case DataType::Type::kInt32:
-    case DataType::Type::kInt64: {
+    case DataType::Type::kUint32:
+    case DataType::Type::kInt64:
+    case DataType::Type::kUint64: {
       locations->SetInAt(0, Location::RequiresRegister());
       locations->SetInAt(1, ARM64EncodableConstantOrRegister(rhs, compare));
       locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
@@ -3245,17 +3308,22 @@ void LocationsBuilderARM64::VisitCompare(HCompare* compare) {
       break;
     }
     default:
-      LOG(FATAL) << "Unexpected type for compare operation " << in_type;
+      LOG(FATAL) << "Unexpected type for compare operation " << compare_type;
   }
 }
 
 void InstructionCodeGeneratorARM64::VisitCompare(HCompare* compare) {
-  DataType::Type in_type = compare->InputAt(0)->GetType();
+  DataType::Type compare_type = compare->GetComparisonType();
 
   //  0 if: left == right
   //  1 if: left  > right
   // -1 if: left  < right
-  switch (in_type) {
+  Condition less_cond = lt;
+  switch (compare_type) {
+    case DataType::Type::kUint32:
+    case DataType::Type::kUint64:
+      less_cond = lo;
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
@@ -3267,8 +3335,8 @@ void InstructionCodeGeneratorARM64::VisitCompare(HCompare* compare) {
       Register left = InputRegisterAt(compare, 0);
       Operand right = InputOperandAt(compare, 1);
       __ Cmp(left, right);
-      __ Cset(result, ne);          // result == +1 if NE or 0 otherwise
-      __ Cneg(result, result, lt);  // result == -1 if LT or unchanged otherwise
+      __ Cset(result, ne);                 // result == +1 if NE or 0 otherwise
+      __ Cneg(result, result, less_cond);  // result == -1 if LT or unchanged otherwise
       break;
     }
     case DataType::Type::kFloat32:
@@ -3280,7 +3348,7 @@ void InstructionCodeGeneratorARM64::VisitCompare(HCompare* compare) {
       break;
     }
     default:
-      LOG(FATAL) << "Unimplemented compare type " << in_type;
+      LOG(FATAL) << "Unimplemented compare type " << compare_type;
   }
 }
 
@@ -6359,6 +6427,14 @@ void InstructionCodeGeneratorARM64::VisitReturnVoid([[maybe_unused]] HReturnVoid
   codegen_->GenerateFrameExit();
 }
 
+void LocationsBuilderARM64::VisitRol(HRol* rol) {
+  HandleBinaryOp(rol);
+}
+
+void InstructionCodeGeneratorARM64::VisitRol(HRol* rol) {
+  HandleBinaryOp(rol);
+}
+
 void LocationsBuilderARM64::VisitRor(HRor* ror) {
   HandleBinaryOp(ror);
 }
diff --git a/compiler/optimizing/code_generator_arm64.h b/compiler/optimizing/code_generator_arm64.h
index 04694ece3e..9f226e9e63 100644
--- a/compiler/optimizing/code_generator_arm64.h
+++ b/compiler/optimizing/code_generator_arm64.h
@@ -31,9 +31,10 @@
 #include "parallel_move_resolver.h"
 #include "utils/arm64/assembler_arm64.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/disasm-aarch64.h"
 #include "aarch64/macro-assembler-aarch64.h"
 #pragma GCC diagnostic pop
@@ -55,6 +56,12 @@ static constexpr size_t kArm64WordSize = static_cast<size_t>(kArm64PointerSize);
 // must be blocked.
 static constexpr int kMaxMacroInstructionSizeInBytes = 15 * vixl::aarch64::kInstructionSize;
 
+// Reference load (except object array loads) is using LDR Wt, [Xn, #offset] which can handle
+// offset < 16KiB. For offsets >= 16KiB, the load shall be emitted as two or more instructions.
+// For the Baker read barrier implementation using link-time generated thunks we need to split
+// the offset explicitly.
+static constexpr uint32_t kReferenceLoadMinFarOffset = 16 * KB;
+
 static const vixl::aarch64::Register kParameterCoreRegisters[] = {
     vixl::aarch64::x1,
     vixl::aarch64::x2,
@@ -124,6 +131,10 @@ const vixl::aarch64::CPURegList callee_saved_fp_registers(vixl::aarch64::CPURegi
 Location ARM64ReturnLocation(DataType::Type return_type);
 
 #define UNIMPLEMENTED_INTRINSIC_LIST_ARM64(V) \
+  V(MathSignumFloat)                          \
+  V(MathSignumDouble)                         \
+  V(MathCopySignFloat)                        \
+  V(MathCopySignDouble)                       \
   V(IntegerRemainderUnsigned)                 \
   V(LongRemainderUnsigned)                    \
   V(StringStringIndexOf)                      \
@@ -145,9 +156,12 @@ Location ARM64ReturnLocation(DataType::Type return_type);
   V(StringBuilderToString)                    \
   V(SystemArrayCopyByte)                      \
   V(SystemArrayCopyInt)                       \
+  V(UnsafeArrayBaseOffset)                    \
   /* 1.8 */                                   \
   V(MethodHandleInvokeExact)                  \
-  V(MethodHandleInvoke)
+  V(MethodHandleInvoke)                       \
+  /* OpenJDK 11 */                            \
+  V(JdkUnsafeArrayBaseOffset)
 
 class SlowPathCodeARM64 : public SlowPathCode {
  public:
@@ -1038,6 +1052,7 @@ class CodeGeneratorARM64 : public CodeGenerator {
 
   void MaybeGenerateInlineCacheCheck(HInstruction* instruction, vixl::aarch64::Register klass);
   void MaybeIncrementHotness(HSuspendCheck* suspend_check, bool is_frame_entry);
+  void MaybeRecordTraceEvent(bool is_method_entry);
 
   bool CanUseImplicitSuspendCheck() const;
 
diff --git a/compiler/optimizing/code_generator_arm_vixl.cc b/compiler/optimizing/code_generator_arm_vixl.cc
index 979db6ed75..fb8f8c0153 100644
--- a/compiler/optimizing/code_generator_arm_vixl.cc
+++ b/compiler/optimizing/code_generator_arm_vixl.cc
@@ -2220,19 +2220,18 @@ void InstructionCodeGeneratorARMVIXL::GenerateMethodEntryExitHook(HInstruction*
   __ B(gt, slow_path->GetEntryLabel());
 
   // Check if there is place in the buffer to store a new entry, if no, take slow path.
-  uint32_t trace_buffer_index_offset =
-      Thread::TraceBufferIndexOffset<kArmPointerSize>().Int32Value();
-  vixl32::Register index = value;
-  __ Ldr(index, MemOperand(tr, trace_buffer_index_offset));
-  __ Subs(index, index, kNumEntriesForWallClock);
+  uint32_t trace_buffer_curr_entry_offset =
+      Thread::TraceBufferCurrPtrOffset<kArmPointerSize>().Int32Value();
+  vixl32::Register curr_entry = value;
+  vixl32::Register init_entry = addr;
+  __ Ldr(curr_entry, MemOperand(tr, trace_buffer_curr_entry_offset));
+  __ Subs(curr_entry, curr_entry, static_cast<uint32_t>(kNumEntriesForWallClock * sizeof(void*)));
+  __ Ldr(init_entry, MemOperand(tr, Thread::TraceBufferPtrOffset<kArmPointerSize>().SizeValue()));
+  __ Cmp(curr_entry, init_entry);
   __ B(lt, slow_path->GetEntryLabel());
 
   // Update the index in the `Thread`.
-  __ Str(index, MemOperand(tr, trace_buffer_index_offset));
-  // Calculate the entry address in the buffer.
-  // addr = base_addr + sizeof(void*) * index
-  __ Ldr(addr, MemOperand(tr, Thread::TraceBufferPtrOffset<kArmPointerSize>().SizeValue()));
-  __ Add(addr, addr, Operand(index, LSL, TIMES_4));
+  __ Str(curr_entry, MemOperand(tr, trace_buffer_curr_entry_offset));
 
   // Record method pointer and trace action.
   __ Ldr(tmp, MemOperand(sp, 0));
@@ -2244,9 +2243,9 @@ void InstructionCodeGeneratorARMVIXL::GenerateMethodEntryExitHook(HInstruction*
     static_assert(enum_cast<int32_t>(TraceAction::kTraceMethodExit) == 1);
     __ Orr(tmp, tmp, Operand(enum_cast<int32_t>(TraceAction::kTraceMethodExit)));
   }
-  __ Str(tmp, MemOperand(addr, kMethodOffsetInBytes));
+  __ Str(tmp, MemOperand(curr_entry, kMethodOffsetInBytes));
 
-  vixl32::Register tmp1 = index;
+  vixl32::Register tmp1 = init_entry;
   // See Architecture Reference Manual ARMv7-A and ARMv7-R edition section B4.1.34.
   __ Mrrc(/* lower 32-bit */ tmp,
           /* higher 32-bit */ tmp1,
@@ -2255,7 +2254,7 @@ void InstructionCodeGeneratorARMVIXL::GenerateMethodEntryExitHook(HInstruction*
           /* crm= */ 14);
   static_assert(kHighTimestampOffsetInBytes ==
                 kTimestampOffsetInBytes + static_cast<uint32_t>(kRuntimePointerSize));
-  __ Strd(tmp, tmp1, MemOperand(addr, kTimestampOffsetInBytes));
+  __ Strd(tmp, tmp1, MemOperand(curr_entry, kTimestampOffsetInBytes));
   __ Bind(slow_path->GetExitLabel());
 }
 
@@ -5281,17 +5280,22 @@ void InstructionCodeGeneratorARMVIXL::VisitDivZeroCheck(HDivZeroCheck* instructi
   }
 }
 
-void InstructionCodeGeneratorARMVIXL::HandleIntegerRotate(HRor* ror) {
-  LocationSummary* locations = ror->GetLocations();
-  vixl32::Register in = InputRegisterAt(ror, 0);
+void InstructionCodeGeneratorARMVIXL::HandleIntegerRotate(HBinaryOperation* rotate) {
+  LocationSummary* locations = rotate->GetLocations();
+  vixl32::Register in = InputRegisterAt(rotate, 0);
   Location rhs = locations->InAt(1);
-  vixl32::Register out = OutputRegister(ror);
+  vixl32::Register out = OutputRegister(rotate);
 
   if (rhs.IsConstant()) {
     // Arm32 and Thumb2 assemblers require a rotation on the interval [1,31],
     // so map all rotations to a +ve. equivalent in that range.
     // (e.g. left *or* right by -2 bits == 30 bits in the same direction.)
     uint32_t rot = CodeGenerator::GetInt32ValueOf(rhs.GetConstant()) & 0x1F;
+
+    if (rotate->IsRol()) {
+      rot = -rot;
+    }
+
     if (rot) {
       // Rotate, mapping left rotations to right equivalents if necessary.
       // (e.g. left by 2 bits == right by 30.)
@@ -5300,7 +5304,16 @@ void InstructionCodeGeneratorARMVIXL::HandleIntegerRotate(HRor* ror) {
       __ Mov(out, in);
     }
   } else {
-    __ Ror(out, in, RegisterFrom(rhs));
+    if (rotate->IsRol()) {
+      UseScratchRegisterScope temps(GetVIXLAssembler());
+
+      vixl32::Register negated = temps.Acquire();
+      __ Rsb(negated, RegisterFrom(rhs), 0);
+      __ Ror(out, in, negated);
+    } else {
+      DCHECK(rotate->IsRor());
+      __ Ror(out, in, RegisterFrom(rhs));
+    }
   }
 }
 
@@ -5308,8 +5321,8 @@ void InstructionCodeGeneratorARMVIXL::HandleIntegerRotate(HRor* ror) {
 // rotates by swapping input regs (effectively rotating by the first 32-bits of
 // a larger rotation) or flipping direction (thus treating larger right/left
 // rotations as sub-word sized rotations in the other direction) as appropriate.
-void InstructionCodeGeneratorARMVIXL::HandleLongRotate(HRor* ror) {
-  LocationSummary* locations = ror->GetLocations();
+void InstructionCodeGeneratorARMVIXL::HandleLongRotate(HBinaryOperation* rotate) {
+  LocationSummary* locations = rotate->GetLocations();
   vixl32::Register in_reg_lo = LowRegisterFrom(locations->InAt(0));
   vixl32::Register in_reg_hi = HighRegisterFrom(locations->InAt(0));
   Location rhs = locations->InAt(1);
@@ -5318,6 +5331,11 @@ void InstructionCodeGeneratorARMVIXL::HandleLongRotate(HRor* ror) {
 
   if (rhs.IsConstant()) {
     uint64_t rot = CodeGenerator::GetInt64ValueOf(rhs.GetConstant());
+
+    if (rotate->IsRol()) {
+      rot = -rot;
+    }
+
     // Map all rotations to +ve. equivalents on the interval [0,63].
     rot &= kMaxLongShiftDistance;
     // For rotates over a word in size, 'pre-rotate' by 32-bits to keep rotate
@@ -5342,7 +5360,17 @@ void InstructionCodeGeneratorARMVIXL::HandleLongRotate(HRor* ror) {
     vixl32::Register shift_left = RegisterFrom(locations->GetTemp(1));
     vixl32::Label end;
     vixl32::Label shift_by_32_plus_shift_right;
-    vixl32::Label* final_label = codegen_->GetFinalLabel(ror, &end);
+    vixl32::Label* final_label = codegen_->GetFinalLabel(rotate, &end);
+
+    // Negate rhs, taken from VisitNeg
+    if (rotate->IsRol()) {
+      Location negated = locations->GetTemp(2);
+      Location in = rhs;
+
+      __ Rsb(RegisterFrom(negated), RegisterFrom(in), 0);
+
+      rhs = negated;
+    }
 
     __ And(shift_right, RegisterFrom(rhs), 0x1F);
     __ Lsrs(shift_left, RegisterFrom(rhs), 6);
@@ -5375,11 +5403,11 @@ void InstructionCodeGeneratorARMVIXL::HandleLongRotate(HRor* ror) {
   }
 }
 
-void LocationsBuilderARMVIXL::VisitRor(HRor* ror) {
+void LocationsBuilderARMVIXL::HandleRotate(HBinaryOperation* rotate) {
   LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(ror, LocationSummary::kNoCall);
-  HInstruction* shift = ror->InputAt(1);
-  switch (ror->GetResultType()) {
+      new (GetGraph()->GetAllocator()) LocationSummary(rotate, LocationSummary::kNoCall);
+  HInstruction* shift = rotate->InputAt(1);
+  switch (rotate->GetResultType()) {
     case DataType::Type::kInt32: {
       locations->SetInAt(0, Location::RequiresRegister());
       locations->SetInAt(1, Location::RegisterOrConstant(shift));
@@ -5392,26 +5420,39 @@ void LocationsBuilderARMVIXL::VisitRor(HRor* ror) {
         locations->SetInAt(1, Location::ConstantLocation(shift));
       } else {
         locations->SetInAt(1, Location::RequiresRegister());
-        locations->AddTemp(Location::RequiresRegister());
-        locations->AddTemp(Location::RequiresRegister());
+
+        if (rotate->IsRor()) {
+          locations->AddRegisterTemps(2);
+        } else {
+          DCHECK(rotate->IsRol());
+          locations->AddRegisterTemps(3);
+        }
       }
       locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
       break;
     }
     default:
-      LOG(FATAL) << "Unexpected operation type " << ror->GetResultType();
+      LOG(FATAL) << "Unexpected operation type " << rotate->GetResultType();
   }
 }
 
-void InstructionCodeGeneratorARMVIXL::VisitRor(HRor* ror) {
-  DataType::Type type = ror->GetResultType();
+void LocationsBuilderARMVIXL::VisitRol(HRol* rol) {
+  HandleRotate(rol);
+}
+
+void LocationsBuilderARMVIXL::VisitRor(HRor* ror) {
+  HandleRotate(ror);
+}
+
+void InstructionCodeGeneratorARMVIXL::HandleRotate(HBinaryOperation* rotate) {
+  DataType::Type type = rotate->GetResultType();
   switch (type) {
     case DataType::Type::kInt32: {
-      HandleIntegerRotate(ror);
+      HandleIntegerRotate(rotate);
       break;
     }
     case DataType::Type::kInt64: {
-      HandleLongRotate(ror);
+      HandleLongRotate(rotate);
       break;
     }
     default:
@@ -5420,6 +5461,14 @@ void InstructionCodeGeneratorARMVIXL::VisitRor(HRor* ror) {
   }
 }
 
+void InstructionCodeGeneratorARMVIXL::VisitRol(HRol* rol) {
+  HandleRotate(rol);
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitRor(HRor* ror) {
+  HandleRotate(ror);
+}
+
 void LocationsBuilderARMVIXL::HandleShift(HBinaryOperation* op) {
   DCHECK(op->IsShl() || op->IsShr() || op->IsUShr());
 
@@ -5757,14 +5806,16 @@ void InstructionCodeGeneratorARMVIXL::VisitBooleanNot(HBooleanNot* bool_not) {
 void LocationsBuilderARMVIXL::VisitCompare(HCompare* compare) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(compare, LocationSummary::kNoCall);
-  switch (compare->InputAt(0)->GetType()) {
+  switch (compare->GetComparisonType()) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
     case DataType::Type::kUint16:
     case DataType::Type::kInt16:
     case DataType::Type::kInt32:
-    case DataType::Type::kInt64: {
+    case DataType::Type::kUint32:
+    case DataType::Type::kInt64:
+    case DataType::Type::kUint64: {
       locations->SetInAt(0, Location::RequiresRegister());
       locations->SetInAt(1, Location::RequiresRegister());
       // Output overlaps because it is written before doing the low comparison.
@@ -5791,9 +5842,14 @@ void InstructionCodeGeneratorARMVIXL::VisitCompare(HCompare* compare) {
 
   vixl32::Label less, greater, done;
   vixl32::Label* final_label = codegen_->GetFinalLabel(compare, &done);
-  DataType::Type type = compare->InputAt(0)->GetType();
-  vixl32::Condition less_cond = vixl32::Condition::None();
+  DataType::Type type = compare->GetComparisonType();
+  vixl32::Condition less_cond = vixl32::ConditionType::lt;
+  vixl32::Condition greater_cond = vixl32::ConditionType::gt;
   switch (type) {
+    case DataType::Type::kUint32:
+      less_cond = vixl32::ConditionType::lo;
+      // greater_cond - is not needed below
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
@@ -5802,18 +5858,22 @@ void InstructionCodeGeneratorARMVIXL::VisitCompare(HCompare* compare) {
     case DataType::Type::kInt32: {
       // Emit move to `out` before the `Cmp`, as `Mov` might affect the status flags.
       __ Mov(out, 0);
-      __ Cmp(RegisterFrom(left), RegisterFrom(right));  // Signed compare.
-      less_cond = lt;
+      __ Cmp(RegisterFrom(left), RegisterFrom(right));
       break;
     }
+    case DataType::Type::kUint64:
+      less_cond = vixl32::ConditionType::lo;
+      greater_cond = vixl32::ConditionType::hi;
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kInt64: {
-      __ Cmp(HighRegisterFrom(left), HighRegisterFrom(right));  // Signed compare.
-      __ B(lt, &less, /* is_far_target= */ false);
-      __ B(gt, &greater, /* is_far_target= */ false);
+      __ Cmp(HighRegisterFrom(left), HighRegisterFrom(right));  // High part compare.
+      __ B(less_cond, &less, /* is_far_target= */ false);
+      __ B(greater_cond, &greater, /* is_far_target= */ false);
       // Emit move to `out` before the last `Cmp`, as `Mov` might affect the status flags.
       __ Mov(out, 0);
       __ Cmp(LowRegisterFrom(left), LowRegisterFrom(right));  // Unsigned compare.
-      less_cond = lo;
+      less_cond = vixl32::ConditionType::lo;
+      // greater_cond - is not needed below
       break;
     }
     case DataType::Type::kFloat32:
@@ -5948,8 +6008,7 @@ void LocationsBuilderARMVIXL::HandleFieldSet(HInstruction* instruction,
   // Temporary registers for the write barrier.
   // TODO: consider renaming StoreNeedsWriteBarrier to StoreNeedsGCMark.
   if (needs_write_barrier || check_gc_card) {
-    locations->AddTemp(Location::RequiresRegister());
-    locations->AddTemp(Location::RequiresRegister());
+    locations->AddRegisterTemps(2);
   } else if (generate_volatile) {
     // ARM encoding have some additional constraints for ldrexd/strexd:
     // - registers need to be consecutive
@@ -5957,9 +6016,7 @@ void LocationsBuilderARMVIXL::HandleFieldSet(HInstruction* instruction,
     // We don't test for ARM yet, and the assertion makes sure that we
     // revisit this if we ever enable ARM encoding.
     DCHECK_EQ(InstructionSet::kThumb2, codegen_->GetInstructionSet());
-
-    locations->AddTemp(Location::RequiresRegister());
-    locations->AddTemp(Location::RequiresRegister());
+    locations->AddRegisterTemps(2);
     if (field_type == DataType::Type::kFloat64) {
       // For doubles we need two more registers to copy the value.
       locations->AddTemp(LocationFrom(r2));
@@ -6118,14 +6175,14 @@ void LocationsBuilderARMVIXL::HandleFieldGet(HInstruction* instruction,
   bool volatile_for_double = field_info.IsVolatile()
       && (field_info.GetFieldType() == DataType::Type::kFloat64)
       && !codegen_->GetInstructionSetFeatures().HasAtomicLdrdAndStrd();
-  // The output overlaps in case of volatile long: we don't want the
-  // code generated by GenerateWideAtomicLoad to overwrite the
-  // object's location.  Likewise, in the case of an object field get
-  // with read barriers enabled, we do not want the load to overwrite
-  // the object's location, as we need it to emit the read barrier.
+  // The output overlaps in case of volatile long: we don't want the code generated by
+  // `GenerateWideAtomicLoad()` to overwrite the object's location.  Likewise, in the case
+  // of an object field get with non-Baker read barriers enabled, we do not want the load
+  // to overwrite the object's location, as we need it to emit the read barrier.
+  // Baker read barrier implementation with introspection does not have this restriction.
   bool overlap =
       (field_info.IsVolatile() && (field_info.GetFieldType() == DataType::Type::kInt64)) ||
-      object_field_get_with_read_barrier;
+      (object_field_get_with_read_barrier && !kUseBakerReadBarrier);
 
   if (DataType::IsFloatingPointType(instruction->GetType())) {
     locations->SetOut(Location::RequiresFpuRegister());
@@ -6140,8 +6197,7 @@ void LocationsBuilderARMVIXL::HandleFieldGet(HInstruction* instruction,
     // We don't test for ARM yet, and the assertion makes sure that we
     // revisit this if we ever enable ARM encoding.
     DCHECK_EQ(InstructionSet::kThumb2, codegen_->GetInstructionSet());
-    locations->AddTemp(Location::RequiresRegister());
-    locations->AddTemp(Location::RequiresRegister());
+    locations->AddRegisterTemps(2);
   } else if (object_field_get_with_read_barrier && kUseBakerReadBarrier) {
     // We need a temporary register for the read barrier load in
     // CodeGeneratorARMVIXL::GenerateFieldLoadWithBakerReadBarrier()
@@ -6571,12 +6627,12 @@ void LocationsBuilderARMVIXL::VisitArrayGet(HArrayGet* instruction) {
   if (DataType::IsFloatingPointType(instruction->GetType())) {
     locations->SetOut(Location::RequiresFpuRegister(), Location::kNoOutputOverlap);
   } else {
-    // The output overlaps in the case of an object array get with
-    // read barriers enabled: we do not want the move to overwrite the
-    // array's location, as we need it to emit the read barrier.
-    locations->SetOut(
-        Location::RequiresRegister(),
-        object_array_get_with_read_barrier ? Location::kOutputOverlap : Location::kNoOutputOverlap);
+    // The output overlaps for an object array get for non-Baker read barriers: we do not want
+    // the load to overwrite the object's location, as we need it to emit the read barrier.
+    // Baker read barrier implementation with introspection does not have this restriction.
+    bool overlap = object_array_get_with_read_barrier && !kUseBakerReadBarrier;
+    locations->SetOut(Location::RequiresRegister(),
+                      overlap ? Location::kOutputOverlap : Location::kNoOutputOverlap);
   }
   if (object_array_get_with_read_barrier && kUseBakerReadBarrier) {
     if (instruction->GetIndex()->IsConstant()) {
@@ -6865,8 +6921,7 @@ void LocationsBuilderARMVIXL::VisitArraySet(HArraySet* instruction) {
   if (needs_write_barrier || check_gc_card || instruction->NeedsTypeCheck()) {
     // Temporary registers for type checking, write barrier, checking the dirty bit, or register
     // poisoning.
-    locations->AddTemp(Location::RequiresRegister());
-    locations->AddTemp(Location::RequiresRegister());
+    locations->AddRegisterTemps(2);
   } else if (kPoisonHeapReferences && value_type == DataType::Type::kReference) {
     locations->AddTemp(Location::RequiresRegister());
   }
diff --git a/compiler/optimizing/code_generator_arm_vixl.h b/compiler/optimizing/code_generator_arm_vixl.h
index 05e5bdf2b7..00b5a69b1d 100644
--- a/compiler/optimizing/code_generator_arm_vixl.h
+++ b/compiler/optimizing/code_generator_arm_vixl.h
@@ -29,9 +29,10 @@
 #include "parallel_move_resolver.h"
 #include "utils/arm/assembler_arm_vixl.h"
 
-// TODO(VIXL): make vixl clean wrt -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch32/constants-aarch32.h"
 #include "aarch32/instructions-aarch32.h"
 #include "aarch32/macro-assembler-aarch32.h"
@@ -120,6 +121,10 @@ using VIXLInt32Literal = vixl::aarch32::Literal<int32_t>;
 using VIXLUInt32Literal = vixl::aarch32::Literal<uint32_t>;
 
 #define UNIMPLEMENTED_INTRINSIC_LIST_ARM(V)                                \
+  V(MathSignumFloat)                                                       \
+  V(MathSignumDouble)                                                      \
+  V(MathCopySignFloat)                                                     \
+  V(MathCopySignDouble)                                                    \
   V(MathRoundDouble) /* Could be done by changing rounding mode, maybe? */ \
   V(UnsafeCASLong)   /* High register pressure */                          \
   V(SystemArrayCopyChar)                                                   \
@@ -161,12 +166,14 @@ using VIXLUInt32Literal = vixl::aarch32::Literal<uint32_t>;
   V(StringBuilderToString)                                                 \
   V(SystemArrayCopyByte)                                                   \
   V(SystemArrayCopyInt)                                                    \
+  V(UnsafeArrayBaseOffset)                                                 \
   /* 1.8 */                                                                \
   V(MathFmaDouble)                                                         \
   V(MathFmaFloat)                                                          \
   V(MethodHandleInvokeExact)                                               \
   V(MethodHandleInvoke)                                                    \
   /* OpenJDK 11 */                                                         \
+  V(JdkUnsafeArrayBaseOffset)                                              \
   V(JdkUnsafeCASLong) /* High register pressure */                         \
   V(JdkUnsafeCompareAndSetLong)
 
@@ -383,13 +390,12 @@ class LocationsBuilderARMVIXL : public HGraphVisitor {
   void HandleInvoke(HInvoke* invoke);
   void HandleBitwiseOperation(HBinaryOperation* operation, Opcode opcode);
   void HandleCondition(HCondition* condition);
-  void HandleIntegerRotate(LocationSummary* locations);
-  void HandleLongRotate(LocationSummary* locations);
   void HandleShift(HBinaryOperation* operation);
   void HandleFieldSet(HInstruction* instruction,
                       const FieldInfo& field_info,
                       WriteBarrierKind write_barrier_kind);
   void HandleFieldGet(HInstruction* instruction, const FieldInfo& field_info);
+  void HandleRotate(HBinaryOperation* rotate);
 
   Location ArithmeticZeroOrFpuRegister(HInstruction* input);
   Location ArmEncodableConstantOrRegister(HInstruction* constant, Opcode opcode);
@@ -439,8 +445,9 @@ class InstructionCodeGeneratorARMVIXL : public InstructionCodeGenerator {
   void GenerateAddLongConst(Location out, Location first, uint64_t value);
   void HandleBitwiseOperation(HBinaryOperation* operation);
   void HandleCondition(HCondition* condition);
-  void HandleIntegerRotate(HRor* ror);
-  void HandleLongRotate(HRor* ror);
+  void HandleIntegerRotate(HBinaryOperation* rotate);
+  void HandleLongRotate(HBinaryOperation* rotate);
+  void HandleRotate(HBinaryOperation* rotate);
   void HandleShift(HBinaryOperation* operation);
 
   void GenerateWideAtomicStore(vixl::aarch32::Register addr,
diff --git a/compiler/optimizing/code_generator_riscv64.cc b/compiler/optimizing/code_generator_riscv64.cc
index 8581c38895..43f855a915 100644
--- a/compiler/optimizing/code_generator_riscv64.cc
+++ b/compiler/optimizing/code_generator_riscv64.cc
@@ -2331,6 +2331,7 @@ void LocationsBuilderRISCV64::HandleShift(HBinaryOperation* instruction) {
   DCHECK(instruction->IsShl() ||
          instruction->IsShr() ||
          instruction->IsUShr() ||
+         instruction->IsRol() ||
          instruction->IsRor());
 
   LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
@@ -2353,7 +2354,9 @@ void InstructionCodeGeneratorRISCV64::HandleShift(HBinaryOperation* instruction)
   DCHECK(instruction->IsShl() ||
          instruction->IsShr() ||
          instruction->IsUShr() ||
+         instruction->IsRol() ||
          instruction->IsRor());
+
   LocationSummary* locations = instruction->GetLocations();
   DataType::Type type = instruction->GetType();
 
@@ -2366,6 +2369,9 @@ void InstructionCodeGeneratorRISCV64::HandleShift(HBinaryOperation* instruction)
 
       if (rs2_location.IsConstant()) {
         int64_t imm = CodeGenerator::GetInt64ValueOf(rs2_location.GetConstant());
+        if (instruction->IsRol()) {
+          imm = -imm;
+        }
         uint32_t shamt =
             imm & (type == DataType::Type::kInt32 ? kMaxIntShiftDistance : kMaxLongShiftDistance);
 
@@ -2380,6 +2386,8 @@ void InstructionCodeGeneratorRISCV64::HandleShift(HBinaryOperation* instruction)
             __ Sraiw(rd, rs1, shamt);
           } else if (instruction->IsUShr()) {
             __ Srliw(rd, rs1, shamt);
+          } else if (instruction->IsRol()) {
+            __ Roriw(rd, rs1, shamt);
           } else {
             DCHECK(instruction->IsRor());
             __ Roriw(rd, rs1, shamt);
@@ -2391,6 +2399,8 @@ void InstructionCodeGeneratorRISCV64::HandleShift(HBinaryOperation* instruction)
             __ Srai(rd, rs1, shamt);
           } else if (instruction->IsUShr()) {
             __ Srli(rd, rs1, shamt);
+          } else if (instruction->IsRol()) {
+            __ Rori(rd, rs1, shamt);
           } else {
             DCHECK(instruction->IsRor());
             __ Rori(rd, rs1, shamt);
@@ -2405,6 +2415,8 @@ void InstructionCodeGeneratorRISCV64::HandleShift(HBinaryOperation* instruction)
             __ Sraw(rd, rs1, rs2);
           } else if (instruction->IsUShr()) {
             __ Srlw(rd, rs1, rs2);
+          } else if (instruction->IsRol()) {
+            __ Rolw(rd, rs1, rs2);
           } else {
             DCHECK(instruction->IsRor());
             __ Rorw(rd, rs1, rs2);
@@ -2416,6 +2428,8 @@ void InstructionCodeGeneratorRISCV64::HandleShift(HBinaryOperation* instruction)
             __ Sra(rd, rs1, rs2);
           } else if (instruction->IsUShr()) {
             __ Srl(rd, rs1, rs2);
+          } else if (instruction->IsRol()) {
+            __ Rol(rd, rs1, rs2);
           } else {
             DCHECK(instruction->IsRor());
             __ Ror(rd, rs1, rs2);
@@ -2640,24 +2654,20 @@ void InstructionCodeGeneratorRISCV64::GenerateMethodEntryExitHook(HInstruction*
   __ Addi(tmp, tmp, -1);
   __ Bnez(tmp, slow_path->GetEntryLabel());
 
-  // Check if there is place in the buffer to store a new entry, if no, take the slow path.
-  int32_t trace_buffer_index_offset =
-      Thread::TraceBufferIndexOffset<kRiscv64PointerSize>().Int32Value();
-  __ Loadd(tmp, TR, trace_buffer_index_offset);
-  __ Addi(tmp, tmp, -dchecked_integral_cast<int32_t>(kNumEntriesForWallClock));
-  __ Bltz(tmp, slow_path->GetEntryLabel());
-
-  // Update the index in the `Thread`.
-  __ Stored(tmp, TR, trace_buffer_index_offset);
-
   // Allocate second core scratch register. We can no longer use `Stored()`
   // and similar macro instructions because there is no core scratch register left.
   XRegister tmp2 = temps.AllocateXRegister();
 
-  // Calculate the entry address in the buffer.
-  // /*addr*/ tmp = TR->GetMethodTraceBuffer() + sizeof(void*) * /*index*/ tmp;
+  // Check if there is place in the buffer to store a new entry, if no, take the slow path.
+  int32_t trace_buffer_curr_entry_offset =
+      Thread::TraceBufferCurrPtrOffset<kRiscv64PointerSize>().Int32Value();
+  __ Loadd(tmp, TR, trace_buffer_curr_entry_offset);
   __ Loadd(tmp2, TR, Thread::TraceBufferPtrOffset<kRiscv64PointerSize>().SizeValue());
-  __ Sh3Add(tmp, tmp, tmp2);
+  __ Addi(tmp, tmp, -dchecked_integral_cast<int32_t>(kNumEntriesForWallClock * sizeof(void*)));
+  __ Blt(tmp, tmp2, slow_path->GetEntryLabel());
+
+  // Update the index in the `Thread`.
+  __ Sd(tmp, TR, trace_buffer_curr_entry_offset);
 
   // Record method pointer and trace action.
   __ Ld(tmp2, SP, 0);
@@ -3474,18 +3484,20 @@ void InstructionCodeGeneratorRISCV64::VisitClinitCheck(HClinitCheck* instruction
 }
 
 void LocationsBuilderRISCV64::VisitCompare(HCompare* instruction) {
-  DataType::Type in_type = instruction->InputAt(0)->GetType();
+  DataType::Type compare_type = instruction->GetComparisonType();
 
   LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
 
-  switch (in_type) {
+  switch (compare_type) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
     case DataType::Type::kUint16:
     case DataType::Type::kInt16:
     case DataType::Type::kInt32:
+    case DataType::Type::kUint32:
     case DataType::Type::kInt64:
+    case DataType::Type::kUint64:
       locations->SetInAt(0, Location::RequiresRegister());
       locations->SetInAt(1, RegisterOrZeroBitPatternLocation(instruction->InputAt(1)));
       locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
@@ -3499,7 +3511,7 @@ void LocationsBuilderRISCV64::VisitCompare(HCompare* instruction) {
       break;
 
     default:
-      LOG(FATAL) << "Unexpected type for compare operation " << in_type;
+      LOG(FATAL) << "Unexpected type for compare operation " << compare_type;
       UNREACHABLE();
   }
 }
@@ -3508,11 +3520,12 @@ void InstructionCodeGeneratorRISCV64::VisitCompare(HCompare* instruction) {
   LocationSummary* locations = instruction->GetLocations();
   XRegister result = locations->Out().AsRegister<XRegister>();
   DataType::Type in_type = instruction->InputAt(0)->GetType();
+  DataType::Type compare_type = instruction->GetComparisonType();
 
   //  0 if: left == right
   //  1 if: left  > right
   // -1 if: left  < right
-  switch (in_type) {
+  switch (compare_type) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
@@ -3530,6 +3543,18 @@ void InstructionCodeGeneratorRISCV64::VisitCompare(HCompare* instruction) {
       break;
     }
 
+    case DataType::Type::kUint32:
+    case DataType::Type::kUint64: {
+      XRegister left = locations->InAt(0).AsRegister<XRegister>();
+      XRegister right = InputXRegisterOrZero(locations->InAt(1));
+      ScratchRegisterScope srs(GetAssembler());
+      XRegister tmp = srs.AllocateXRegister();
+      __ Sltu(tmp, left, right);
+      __ Sltu(result, right, left);
+      __ Sub(result, result, tmp);
+      break;
+    }
+
     case DataType::Type::kFloat32:
     case DataType::Type::kFloat64: {
       FRegister left = locations->InAt(0).AsFpuRegister<FRegister>();
@@ -4995,6 +5020,14 @@ void InstructionCodeGeneratorRISCV64::VisitReturnVoid([[maybe_unused]] HReturnVo
   codegen_->GenerateFrameExit();
 }
 
+void LocationsBuilderRISCV64::VisitRol(HRol* instruction) {
+  HandleShift(instruction);
+}
+
+void InstructionCodeGeneratorRISCV64::VisitRol(HRol* instruction) {
+  HandleShift(instruction);
+}
+
 void LocationsBuilderRISCV64::VisitRor(HRor* instruction) {
   HandleShift(instruction);
 }
diff --git a/compiler/optimizing/code_generator_riscv64.h b/compiler/optimizing/code_generator_riscv64.h
index 227882e7b8..dcd36ffe67 100644
--- a/compiler/optimizing/code_generator_riscv64.h
+++ b/compiler/optimizing/code_generator_riscv64.h
@@ -56,9 +56,6 @@ static_assert(kQuietNaN == 0x200);
 static constexpr int32_t kFClassNaNMinValue = 0x100;
 
 #define UNIMPLEMENTED_INTRINSIC_LIST_RISCV64(V) \
-  V(SystemArrayCopyByte)                        \
-  V(SystemArrayCopyChar)                        \
-  V(SystemArrayCopyInt)                         \
   V(FP16Ceil)                                   \
   V(FP16Compare)                                \
   V(FP16Floor)                                  \
@@ -92,7 +89,9 @@ static constexpr int32_t kFClassNaNMinValue = 0x100;
   V(CRC32UpdateBytes)                           \
   V(CRC32UpdateByteBuffer)                      \
   V(MethodHandleInvokeExact)                    \
-  V(MethodHandleInvoke)
+  V(MethodHandleInvoke)                         \
+  V(UnsafeArrayBaseOffset)                      \
+  V(JdkUnsafeArrayBaseOffset)                   \
 
 // Method register on invoke.
 static const XRegister kArtMethodRegister = A0;
diff --git a/compiler/optimizing/code_generator_x86.cc b/compiler/optimizing/code_generator_x86.cc
index f549da189f..7e3c6216eb 100644
--- a/compiler/optimizing/code_generator_x86.cc
+++ b/compiler/optimizing/code_generator_x86.cc
@@ -1274,29 +1274,27 @@ void InstructionCodeGeneratorX86::GenerateMethodEntryExitHook(HInstruction* inst
   // If yes, just take the slow path.
   __ j(kGreater, slow_path->GetEntryLabel());
 
-  // For entry_addr use the first temp that isn't EAX or EDX. We need this after
+  // For curr_entry use the register that isn't EAX or EDX. We need this after
   // rdtsc which returns values in EAX + EDX.
-  Register entry_addr = locations->GetTemp(2).AsRegister<Register>();
-  Register index = locations->GetTemp(1).AsRegister<Register>();
+  Register curr_entry = locations->GetTemp(2).AsRegister<Register>();
+  Register init_entry = locations->GetTemp(1).AsRegister<Register>();
 
   // Check if there is place in the buffer for a new entry, if no, take slow path.
   uint32_t trace_buffer_ptr = Thread::TraceBufferPtrOffset<kX86PointerSize>().Int32Value();
-  uint64_t trace_buffer_index_offset =
-      Thread::TraceBufferIndexOffset<kX86PointerSize>().Int32Value();
+  uint64_t trace_buffer_curr_entry_offset =
+      Thread::TraceBufferCurrPtrOffset<kX86PointerSize>().Int32Value();
 
-  __ fs()->movl(index, Address::Absolute(trace_buffer_index_offset));
-  __ subl(index, Immediate(kNumEntriesForWallClock));
+  __ fs()->movl(curr_entry, Address::Absolute(trace_buffer_curr_entry_offset));
+  __ subl(curr_entry, Immediate(kNumEntriesForWallClock * sizeof(void*)));
+  __ fs()->movl(init_entry, Address::Absolute(trace_buffer_ptr));
+  __ cmpl(curr_entry, init_entry);
   __ j(kLess, slow_path->GetEntryLabel());
 
   // Update the index in the `Thread`.
-  __ fs()->movl(Address::Absolute(trace_buffer_index_offset), index);
-  // Calculate the entry address in the buffer.
-  // entry_addr = base_addr + sizeof(void*) * index
-  __ fs()->movl(entry_addr, Address::Absolute(trace_buffer_ptr));
-  __ leal(entry_addr, Address(entry_addr, index, TIMES_4, 0));
+  __ fs()->movl(Address::Absolute(trace_buffer_curr_entry_offset), curr_entry);
 
   // Record method pointer and trace action.
-  Register method = index;
+  Register method = init_entry;
   __ movl(method, Address(ESP, kCurrentMethodStackOffset));
   // Use last two bits to encode trace method action. For MethodEntry it is 0
   // so no need to set the bits since they are 0 already.
@@ -1306,11 +1304,11 @@ void InstructionCodeGeneratorX86::GenerateMethodEntryExitHook(HInstruction* inst
     static_assert(enum_cast<int32_t>(TraceAction::kTraceMethodExit) == 1);
     __ orl(method, Immediate(enum_cast<int32_t>(TraceAction::kTraceMethodExit)));
   }
-  __ movl(Address(entry_addr, kMethodOffsetInBytes), method);
+  __ movl(Address(curr_entry, kMethodOffsetInBytes), method);
   // Get the timestamp. rdtsc returns timestamp in EAX + EDX.
   __ rdtsc();
-  __ movl(Address(entry_addr, kTimestampOffsetInBytes), EAX);
-  __ movl(Address(entry_addr, kHighTimestampOffsetInBytes), EDX);
+  __ movl(Address(curr_entry, kTimestampOffsetInBytes), EAX);
+  __ movl(Address(curr_entry, kHighTimestampOffsetInBytes), EDX);
   __ Bind(slow_path->GetExitLabel());
 }
 
@@ -2239,8 +2237,7 @@ void LocationsBuilderX86::VisitIf(HIf* if_instr) {
         codegen_->GetCompilerOptions().ProfileBranches() &&
         !Runtime::Current()->IsAotCompiler()) {
       locations->SetInAt(0, Location::RequiresRegister());
-      locations->AddTemp(Location::RequiresRegister());
-      locations->AddTemp(Location::RequiresRegister());
+      locations->AddRegisterTemps(2);
     } else {
       locations->SetInAt(0, Location::Any());
     }
@@ -5055,11 +5052,19 @@ void InstructionCodeGeneratorX86::GenerateUShrLong(const Location& loc, Register
   __ Bind(&done);
 }
 
+void LocationsBuilderX86::VisitRol(HRol* rol) {
+  HandleRotate(rol);
+}
+
 void LocationsBuilderX86::VisitRor(HRor* ror) {
+  HandleRotate(ror);
+}
+
+void LocationsBuilderX86::HandleRotate(HBinaryOperation* rotate) {
   LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(ror, LocationSummary::kNoCall);
+      new (GetGraph()->GetAllocator()) LocationSummary(rotate, LocationSummary::kNoCall);
 
-  switch (ror->GetResultType()) {
+  switch (rotate->GetResultType()) {
     case DataType::Type::kInt64:
       // Add the temporary needed.
       locations->AddTemp(Location::RequiresRegister());
@@ -5067,39 +5072,62 @@ void LocationsBuilderX86::VisitRor(HRor* ror) {
     case DataType::Type::kInt32:
       locations->SetInAt(0, Location::RequiresRegister());
       // The shift count needs to be in CL (unless it is a constant).
-      locations->SetInAt(1, Location::ByteRegisterOrConstant(ECX, ror->InputAt(1)));
+      locations->SetInAt(1, Location::ByteRegisterOrConstant(ECX, rotate->InputAt(1)));
       locations->SetOut(Location::SameAsFirstInput());
       break;
     default:
-      LOG(FATAL) << "Unexpected operation type " << ror->GetResultType();
+      LOG(FATAL) << "Unexpected operation type " << rotate->GetResultType();
       UNREACHABLE();
   }
 }
 
+void InstructionCodeGeneratorX86::VisitRol(HRol* rol) {
+  HandleRotate(rol);
+}
+
 void InstructionCodeGeneratorX86::VisitRor(HRor* ror) {
-  LocationSummary* locations = ror->GetLocations();
+  HandleRotate(ror);
+}
+
+void InstructionCodeGeneratorX86::HandleRotate(HBinaryOperation* rotate) {
+  LocationSummary* locations = rotate->GetLocations();
   Location first = locations->InAt(0);
   Location second = locations->InAt(1);
 
-  if (ror->GetResultType() == DataType::Type::kInt32) {
+  if (rotate->GetResultType() == DataType::Type::kInt32) {
     Register first_reg = first.AsRegister<Register>();
     if (second.IsRegister()) {
       Register second_reg = second.AsRegister<Register>();
-      __ rorl(first_reg, second_reg);
+      if (rotate->IsRol()) {
+        __ roll(first_reg, second_reg);
+      } else {
+        DCHECK(rotate->IsRor());
+        __ rorl(first_reg, second_reg);
+      }
     } else {
       Immediate imm(second.GetConstant()->AsIntConstant()->GetValue() & kMaxIntShiftDistance);
-      __ rorl(first_reg, imm);
+      if (rotate->IsRol()) {
+        __ roll(first_reg, imm);
+      } else {
+        DCHECK(rotate->IsRor());
+        __ rorl(first_reg, imm);
+      }
     }
     return;
   }
 
-  DCHECK_EQ(ror->GetResultType(), DataType::Type::kInt64);
+  DCHECK_EQ(rotate->GetResultType(), DataType::Type::kInt64);
   Register first_reg_lo = first.AsRegisterPairLow<Register>();
   Register first_reg_hi = first.AsRegisterPairHigh<Register>();
   Register temp_reg = locations->GetTemp(0).AsRegister<Register>();
   if (second.IsRegister()) {
     Register second_reg = second.AsRegister<Register>();
     DCHECK_EQ(second_reg, ECX);
+
+    if (rotate->IsRol()) {
+      __ negl(second_reg);
+    }
+
     __ movl(temp_reg, first_reg_hi);
     __ shrd(first_reg_hi, first_reg_lo, second_reg);
     __ shrd(first_reg_lo, temp_reg, second_reg);
@@ -5108,7 +5136,12 @@ void InstructionCodeGeneratorX86::VisitRor(HRor* ror) {
     __ cmovl(kNotEqual, first_reg_hi, first_reg_lo);
     __ cmovl(kNotEqual, first_reg_lo, temp_reg);
   } else {
-    int32_t shift_amt = second.GetConstant()->AsIntConstant()->GetValue() & kMaxLongShiftDistance;
+    int32_t value = second.GetConstant()->AsIntConstant()->GetValue();
+    if (rotate->IsRol()) {
+      value = -value;
+    }
+    int32_t shift_amt = value & kMaxLongShiftDistance;
+
     if (shift_amt == 0) {
       // Already fine.
       return;
@@ -5290,14 +5323,16 @@ void InstructionCodeGeneratorX86::VisitBooleanNot(HBooleanNot* bool_not) {
 void LocationsBuilderX86::VisitCompare(HCompare* compare) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(compare, LocationSummary::kNoCall);
-  switch (compare->InputAt(0)->GetType()) {
+  switch (compare->GetComparisonType()) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
     case DataType::Type::kUint16:
     case DataType::Type::kInt16:
     case DataType::Type::kInt32:
-    case DataType::Type::kInt64: {
+    case DataType::Type::kUint32:
+    case DataType::Type::kInt64:
+    case DataType::Type::kUint64: {
       locations->SetInAt(0, Location::RequiresRegister());
       locations->SetInAt(1, Location::Any());
       locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
@@ -5329,8 +5364,13 @@ void InstructionCodeGeneratorX86::VisitCompare(HCompare* compare) {
 
   NearLabel less, greater, done;
   Condition less_cond = kLess;
+  Condition greater_cond = kGreater;
 
-  switch (compare->InputAt(0)->GetType()) {
+  switch (compare->GetComparisonType()) {
+    case DataType::Type::kUint32:
+      less_cond = kBelow;
+      // greater_cond - is not needed below
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
@@ -5340,6 +5380,10 @@ void InstructionCodeGeneratorX86::VisitCompare(HCompare* compare) {
       codegen_->GenerateIntCompare(left, right);
       break;
     }
+    case DataType::Type::kUint64:
+      less_cond = kBelow;
+      greater_cond = kAbove;
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kInt64: {
       Register left_low = left.AsRegisterPairLow<Register>();
       Register left_high = left.AsRegisterPairHigh<Register>();
@@ -5363,8 +5407,8 @@ void InstructionCodeGeneratorX86::VisitCompare(HCompare* compare) {
         DCHECK(right_is_const) << right;
         codegen_->Compare32BitValue(left_high, val_high);
       }
-      __ j(kLess, &less);  // Signed compare.
-      __ j(kGreater, &greater);  // Signed compare.
+      __ j(less_cond, &less);        // High part compare.
+      __ j(greater_cond, &greater);  // High part compare.
       if (right.IsRegisterPair()) {
         __ cmpl(left_low, right.AsRegisterPairLow<Register>());
       } else if (right.IsDoubleStackSlot()) {
@@ -5374,6 +5418,7 @@ void InstructionCodeGeneratorX86::VisitCompare(HCompare* compare) {
         codegen_->Compare32BitValue(left_low, val_low);
       }
       less_cond = kBelow;  // for CF (unsigned).
+      // greater_cond - is not needed below
       break;
     }
     case DataType::Type::kFloat32: {
diff --git a/compiler/optimizing/code_generator_x86.h b/compiler/optimizing/code_generator_x86.h
index 6ce0c506a0..321ee92e2e 100644
--- a/compiler/optimizing/code_generator_x86.h
+++ b/compiler/optimizing/code_generator_x86.h
@@ -49,6 +49,10 @@ static constexpr size_t kRuntimeParameterFpuRegistersLength =
     arraysize(kRuntimeParameterFpuRegisters);
 
 #define UNIMPLEMENTED_INTRINSIC_LIST_X86(V) \
+  V(MathSignumFloat)                        \
+  V(MathSignumDouble)                       \
+  V(MathCopySignFloat)                      \
+  V(MathCopySignDouble)                     \
   V(MathRoundDouble)                        \
   V(FloatIsInfinite)                        \
   V(DoubleIsInfinite)                       \
@@ -90,9 +94,12 @@ static constexpr size_t kRuntimeParameterFpuRegistersLength =
   V(StringBuilderAppendDouble)              \
   V(StringBuilderLength)                    \
   V(StringBuilderToString)                  \
+  V(UnsafeArrayBaseOffset)                  \
   /* 1.8 */                                 \
   V(MethodHandleInvokeExact)                \
-  V(MethodHandleInvoke)
+  V(MethodHandleInvoke)                     \
+  /* OpenJDK 11 */                          \
+  V(JdkUnsafeArrayBaseOffset)
 
 class InvokeRuntimeCallingConvention : public CallingConvention<Register, XmmRegister> {
  public:
@@ -242,6 +249,7 @@ class LocationsBuilderX86 : public HGraphVisitor {
   void HandleBitwiseOperation(HBinaryOperation* instruction);
   void HandleInvoke(HInvoke* invoke);
   void HandleCondition(HCondition* condition);
+  void HandleRotate(HBinaryOperation* rotate);
   void HandleShift(HBinaryOperation* instruction);
   void HandleFieldSet(HInstruction* instruction,
                       const FieldInfo& field_info,
@@ -332,6 +340,7 @@ class InstructionCodeGeneratorX86 : public InstructionCodeGenerator {
                       bool value_can_be_null,
                       WriteBarrierKind write_barrier_kind);
   void HandleFieldGet(HInstruction* instruction, const FieldInfo& field_info);
+  void HandleRotate(HBinaryOperation* rotate);
 
   // Generate a heap reference load using one register `out`:
   //
diff --git a/compiler/optimizing/code_generator_x86_64.cc b/compiler/optimizing/code_generator_x86_64.cc
index e2b4344be9..51ded684c6 100644
--- a/compiler/optimizing/code_generator_x86_64.cc
+++ b/compiler/optimizing/code_generator_x86_64.cc
@@ -35,6 +35,7 @@
 #include "lock_word.h"
 #include "mirror/array-inl.h"
 #include "mirror/class-inl.h"
+#include "mirror/method_type.h"
 #include "mirror/object_reference.h"
 #include "mirror/var_handle.h"
 #include "optimizing/nodes.h"
@@ -56,7 +57,6 @@ class GcRoot;
 namespace x86_64 {
 
 static constexpr int kCurrentMethodStackOffset = 0;
-static constexpr Register kMethodRegisterArgument = RDI;
 // The compare/jump sequence will generate about (1.5 * num_entries) instructions. A jump
 // table version generates 7 instructions and num_entries literals. Compare/jump sequence will
 // generates less code/data with a small num_entries.
@@ -1628,6 +1628,7 @@ CodeGeneratorX86_64::CodeGeneratorX86_64(HGraph* graph,
       boot_image_other_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       jit_string_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       jit_class_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      jit_method_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       fixups_to_jump_tables_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)) {
   AddAllocatedRegister(Location::RegisterLocation(kFakeReturnRegister));
 }
@@ -1693,28 +1694,29 @@ void InstructionCodeGeneratorX86_64::GenerateMethodEntryExitHook(HInstruction* i
   __ j(kGreater, slow_path->GetEntryLabel());
 
   // Check if there is place in the buffer for a new entry, if no, take slow path.
-  CpuRegister index = locations->GetTemp(0).AsRegister<CpuRegister>();
-  CpuRegister entry_addr = CpuRegister(TMP);
-  uint64_t trace_buffer_index_offset =
-      Thread::TraceBufferIndexOffset<kX86_64PointerSize>().SizeValue();
-  __ gs()->movq(CpuRegister(index),
-                Address::Absolute(trace_buffer_index_offset, /* no_rip= */ true));
-  __ subq(CpuRegister(index), Immediate(kNumEntriesForWallClock));
+  CpuRegister init_entry = locations->GetTemp(0).AsRegister<CpuRegister>();
+  // Use a register that is different from RAX and RDX. RDTSC returns result in RAX and RDX and we
+  // use curr entry to store the result into the buffer.
+  CpuRegister curr_entry = CpuRegister(TMP);
+  DCHECK(curr_entry.AsRegister() != RAX);
+  DCHECK(curr_entry.AsRegister() != RDX);
+  uint64_t trace_buffer_curr_entry_offset =
+      Thread::TraceBufferCurrPtrOffset<kX86_64PointerSize>().SizeValue();
+  __ gs()->movq(CpuRegister(curr_entry),
+                Address::Absolute(trace_buffer_curr_entry_offset, /* no_rip= */ true));
+  __ subq(CpuRegister(curr_entry), Immediate(kNumEntriesForWallClock * sizeof(void*)));
+  __ gs()->movq(init_entry,
+                Address::Absolute(Thread::TraceBufferPtrOffset<kX86_64PointerSize>().SizeValue(),
+                                  /* no_rip= */ true));
+  __ cmpq(curr_entry, init_entry);
   __ j(kLess, slow_path->GetEntryLabel());
 
   // Update the index in the `Thread`.
-  __ gs()->movq(Address::Absolute(trace_buffer_index_offset, /* no_rip= */ true),
-                CpuRegister(index));
-  // Calculate the entry address in the buffer.
-  // entry_addr = base_addr + sizeof(void*) * index
-  __ gs()->movq(entry_addr,
-                Address::Absolute(Thread::TraceBufferPtrOffset<kX86_64PointerSize>().SizeValue(),
-                                  /* no_rip= */ true));
-  __ leaq(CpuRegister(entry_addr),
-          Address(CpuRegister(entry_addr), CpuRegister(index), TIMES_8, 0));
+  __ gs()->movq(Address::Absolute(trace_buffer_curr_entry_offset, /* no_rip= */ true),
+                CpuRegister(curr_entry));
 
   // Record method pointer and action.
-  CpuRegister method = index;
+  CpuRegister method = init_entry;
   __ movq(CpuRegister(method), Address(CpuRegister(RSP), kCurrentMethodStackOffset));
   // Use last two bits to encode trace method action. For MethodEntry it is 0
   // so no need to set the bits since they are 0 already.
@@ -1724,12 +1726,12 @@ void InstructionCodeGeneratorX86_64::GenerateMethodEntryExitHook(HInstruction* i
     static_assert(enum_cast<int32_t>(TraceAction::kTraceMethodExit) == 1);
     __ orq(method, Immediate(enum_cast<int32_t>(TraceAction::kTraceMethodExit)));
   }
-  __ movq(Address(entry_addr, kMethodOffsetInBytes), CpuRegister(method));
+  __ movq(Address(curr_entry, kMethodOffsetInBytes), CpuRegister(method));
   // Get the timestamp. rdtsc returns timestamp in RAX + RDX even in 64-bit architectures.
   __ rdtsc();
   __ shlq(CpuRegister(RDX), Immediate(32));
   __ orq(CpuRegister(RAX), CpuRegister(RDX));
-  __ movq(Address(entry_addr, kTimestampOffsetInBytes), CpuRegister(RAX));
+  __ movq(Address(curr_entry, kTimestampOffsetInBytes), CpuRegister(RAX));
   __ Bind(slow_path->GetExitLabel());
 }
 
@@ -2724,14 +2726,16 @@ void InstructionCodeGeneratorX86_64::VisitAboveOrEqual(HAboveOrEqual* comp) {
 void LocationsBuilderX86_64::VisitCompare(HCompare* compare) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(compare, LocationSummary::kNoCall);
-  switch (compare->InputAt(0)->GetType()) {
+  switch (compare->GetComparisonType()) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
     case DataType::Type::kUint16:
     case DataType::Type::kInt16:
     case DataType::Type::kInt32:
-    case DataType::Type::kInt64: {
+    case DataType::Type::kUint32:
+    case DataType::Type::kInt64:
+    case DataType::Type::kUint64: {
       locations->SetInAt(0, Location::RequiresRegister());
       locations->SetInAt(1, Location::Any());
       locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
@@ -2756,10 +2760,13 @@ void InstructionCodeGeneratorX86_64::VisitCompare(HCompare* compare) {
   Location right = locations->InAt(1);
 
   NearLabel less, greater, done;
-  DataType::Type type = compare->InputAt(0)->GetType();
+  DataType::Type type = compare->GetComparisonType();
   Condition less_cond = kLess;
 
   switch (type) {
+    case DataType::Type::kUint32:
+      less_cond = kBelow;
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
@@ -2769,6 +2776,9 @@ void InstructionCodeGeneratorX86_64::VisitCompare(HCompare* compare) {
       codegen_->GenerateIntCompare(left, right);
       break;
     }
+    case DataType::Type::kUint64:
+      less_cond = kBelow;
+      FALLTHROUGH_INTENDED;
     case DataType::Type::kInt64: {
       codegen_->GenerateLongCompare(left, right);
       break;
@@ -5025,55 +5035,91 @@ void InstructionCodeGeneratorX86_64::HandleShift(HBinaryOperation* op) {
   }
 }
 
-void LocationsBuilderX86_64::VisitRor(HRor* ror) {
+void LocationsBuilderX86_64::HandleRotate(HBinaryOperation* rotate) {
   LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(ror, LocationSummary::kNoCall);
+      new (GetGraph()->GetAllocator()) LocationSummary(rotate, LocationSummary::kNoCall);
 
-  switch (ror->GetResultType()) {
+  switch (rotate->GetResultType()) {
     case DataType::Type::kInt32:
     case DataType::Type::kInt64: {
       locations->SetInAt(0, Location::RequiresRegister());
       // The shift count needs to be in CL (unless it is a constant).
-      locations->SetInAt(1, Location::ByteRegisterOrConstant(RCX, ror->InputAt(1)));
+      locations->SetInAt(1, Location::ByteRegisterOrConstant(RCX, rotate->InputAt(1)));
       locations->SetOut(Location::SameAsFirstInput());
       break;
     }
     default:
-      LOG(FATAL) << "Unexpected operation type " << ror->GetResultType();
+      LOG(FATAL) << "Unexpected operation type " << rotate->GetResultType();
       UNREACHABLE();
   }
 }
 
-void InstructionCodeGeneratorX86_64::VisitRor(HRor* ror) {
-  LocationSummary* locations = ror->GetLocations();
+void InstructionCodeGeneratorX86_64::HandleRotate(HBinaryOperation* rotate) {
+  LocationSummary* locations = rotate->GetLocations();
   CpuRegister first_reg = locations->InAt(0).AsRegister<CpuRegister>();
   Location second = locations->InAt(1);
 
-  switch (ror->GetResultType()) {
+  switch (rotate->GetResultType()) {
     case DataType::Type::kInt32:
       if (second.IsRegister()) {
         CpuRegister second_reg = second.AsRegister<CpuRegister>();
-        __ rorl(first_reg, second_reg);
+        if (rotate->IsRor()) {
+          __ rorl(first_reg, second_reg);
+        } else {
+          DCHECK(rotate->IsRol());
+          __ roll(first_reg, second_reg);
+        }
       } else {
         Immediate imm(second.GetConstant()->AsIntConstant()->GetValue() & kMaxIntShiftDistance);
-        __ rorl(first_reg, imm);
+        if (rotate->IsRor()) {
+          __ rorl(first_reg, imm);
+        } else {
+          DCHECK(rotate->IsRol());
+          __ roll(first_reg, imm);
+        }
       }
       break;
     case DataType::Type::kInt64:
       if (second.IsRegister()) {
         CpuRegister second_reg = second.AsRegister<CpuRegister>();
-        __ rorq(first_reg, second_reg);
+        if (rotate->IsRor()) {
+          __ rorq(first_reg, second_reg);
+        } else {
+          DCHECK(rotate->IsRol());
+          __ rolq(first_reg, second_reg);
+        }
       } else {
         Immediate imm(second.GetConstant()->AsIntConstant()->GetValue() & kMaxLongShiftDistance);
-        __ rorq(first_reg, imm);
+        if (rotate->IsRor()) {
+          __ rorq(first_reg, imm);
+        } else {
+          DCHECK(rotate->IsRol());
+          __ rolq(first_reg, imm);
+        }
       }
       break;
     default:
-      LOG(FATAL) << "Unexpected operation type " << ror->GetResultType();
+      LOG(FATAL) << "Unexpected operation type " << rotate->GetResultType();
       UNREACHABLE();
   }
 }
 
+void InstructionCodeGeneratorX86_64::VisitRor(HRor* ror) {
+  HandleRotate(ror);
+}
+
+void LocationsBuilderX86_64::VisitRol(HRol* rol) {
+  HandleRotate(rol);
+}
+
+void LocationsBuilderX86_64::VisitRor(HRor* ror) {
+  HandleRotate(ror);
+}
+
+void InstructionCodeGeneratorX86_64::VisitRol(HRol* rol) {
+  HandleRotate(rol);
+}
+
 void LocationsBuilderX86_64::VisitShl(HShl* shl) {
   HandleShift(shl);
 }
@@ -5367,9 +5413,8 @@ void LocationsBuilderX86_64::HandleFieldSet(HInstruction* instruction,
   if (needs_write_barrier ||
       check_gc_card ||
       (kPoisonHeapReferences && field_type == DataType::Type::kReference)) {
-    // Temporary registers for the write barrier.
-    locations->AddTemp(Location::RequiresRegister());
-    locations->AddTemp(Location::RequiresRegister());  // Possibly used for reference poisoning too.
+    // Temporary registers for the write barrier / reference poisoning.
+    locations->AddRegisterTemps(2);
   }
 }
 
@@ -6824,20 +6869,31 @@ void InstructionCodeGeneratorX86_64::VisitLoadMethodHandle(HLoadMethodHandle* lo
   codegen_->GenerateLoadMethodHandleRuntimeCall(load);
 }
 
+Label* CodeGeneratorX86_64::NewJitRootMethodTypePatch(const DexFile& dex_file,
+                                                      dex::ProtoIndex proto_index,
+                                                      Handle<mirror::MethodType> handle) {
+  ReserveJitMethodTypeRoot(ProtoReference(&dex_file, proto_index), handle);
+  // Add a patch entry and return the label.
+  jit_method_type_patches_.emplace_back(&dex_file, proto_index.index_);
+  PatchInfo<Label>* info = &jit_method_type_patches_.back();
+  return &info->label;
+}
+
 void LocationsBuilderX86_64::VisitLoadMethodType(HLoadMethodType* load) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(load, LocationSummary::kCallOnSlowPath);
   if (load->GetLoadKind() == HLoadMethodType::LoadKind::kRuntimeCall) {
-      Location location = Location::RegisterLocation(RAX);
-      CodeGenerator::CreateLoadMethodTypeRuntimeCallLocationSummary(load, location, location);
+    Location location = Location::RegisterLocation(RAX);
+    CodeGenerator::CreateLoadMethodTypeRuntimeCallLocationSummary(load, location, location);
   } else {
-    DCHECK_EQ(load->GetLoadKind(), HLoadMethodType::LoadKind::kBssEntry);
     locations->SetOut(Location::RequiresRegister());
-    if (codegen_->EmitNonBakerReadBarrier()) {
-      // For non-Baker read barrier we have a temp-clobbering call.
-    } else {
-      // Rely on the pResolveMethodType to save everything.
-      locations->SetCustomSlowPathCallerSaves(OneRegInReferenceOutSaveEverythingCallerSaves());
+    if (load->GetLoadKind() == HLoadMethodType::LoadKind::kBssEntry) {
+      if (codegen_->EmitNonBakerReadBarrier()) {
+        // For non-Baker read barrier we have a temp-clobbering call.
+      } else {
+        // Rely on the pResolveMethodType to save everything.
+        locations->SetCustomSlowPathCallerSaves(OneRegInReferenceOutSaveEverythingCallerSaves());
+      }
     }
   }
 }
@@ -6864,6 +6920,17 @@ void InstructionCodeGeneratorX86_64::VisitLoadMethodType(HLoadMethodType* load)
       __ Bind(slow_path->GetExitLabel());
       return;
     }
+    case HLoadMethodType::LoadKind::kJitTableAddress: {
+      Address address = Address::Absolute(CodeGeneratorX86_64::kPlaceholder32BitOffset,
+                                          /* no_rip= */ true);
+      Handle<mirror::MethodType> method_type = load->GetMethodType();
+      DCHECK(method_type != nullptr);
+      Label* fixup_label = codegen_->NewJitRootMethodTypePatch(
+          load->GetDexFile(), load->GetProtoIndex(), method_type);
+      GenerateGcRootFieldLoad(
+          load, out_loc, address, fixup_label, codegen_->GetCompilerReadBarrierOption());
+      return;
+    }
     default:
       DCHECK_EQ(load->GetLoadKind(), HLoadMethodType::LoadKind::kRuntimeCall);
       codegen_->GenerateLoadMethodTypeRuntimeCall(load);
@@ -8156,8 +8223,7 @@ void LocationsBuilderX86_64::VisitPackedSwitch(HPackedSwitch* switch_instr) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(switch_instr, LocationSummary::kNoCall);
   locations->SetInAt(0, Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(2);
 }
 
 void InstructionCodeGeneratorX86_64::VisitPackedSwitch(HPackedSwitch* switch_instr) {
@@ -8543,6 +8609,12 @@ void CodeGeneratorX86_64::EmitJitRootPatches(uint8_t* code, const uint8_t* roots
     uint64_t index_in_table = GetJitClassRootIndex(type_reference);
     PatchJitRootUse(code, roots_data, info, index_in_table);
   }
+
+  for (const PatchInfo<Label>& info : jit_method_type_patches_) {
+    ProtoReference proto_reference(info.target_dex_file, dex::ProtoIndex(info.offset_or_index));
+    uint64_t index_in_table = GetJitMethodTypeRootIndex(proto_reference);
+    PatchJitRootUse(code, roots_data, info, index_in_table);
+  }
 }
 
 bool LocationsBuilderX86_64::CpuHasAvxFeatureFlag() {
diff --git a/compiler/optimizing/code_generator_x86_64.h b/compiler/optimizing/code_generator_x86_64.h
index 81c8ead32e..b3eb1a0373 100644
--- a/compiler/optimizing/code_generator_x86_64.h
+++ b/compiler/optimizing/code_generator_x86_64.h
@@ -28,6 +28,8 @@
 namespace art HIDDEN {
 namespace x86_64 {
 
+static constexpr Register kMethodRegisterArgument = RDI;
+
 // Use a local definition to prevent copying mistakes.
 static constexpr size_t kX86_64WordSize = static_cast<size_t>(kX86_64PointerSize);
 
@@ -54,6 +56,10 @@ static constexpr size_t kRuntimeParameterFpuRegistersLength =
 static constexpr FloatRegister non_volatile_xmm_regs[] = { XMM12, XMM13, XMM14, XMM15 };
 
 #define UNIMPLEMENTED_INTRINSIC_LIST_X86_64(V) \
+  V(MathSignumFloat)                           \
+  V(MathSignumDouble)                          \
+  V(MathCopySignFloat)                         \
+  V(MathCopySignDouble)                        \
   V(CRC32Update)                               \
   V(CRC32UpdateBytes)                          \
   V(CRC32UpdateByteBuffer)                     \
@@ -88,9 +94,11 @@ static constexpr FloatRegister non_volatile_xmm_regs[] = { XMM12, XMM13, XMM14,
   V(StringBuilderAppendDouble)                 \
   V(StringBuilderLength)                       \
   V(StringBuilderToString)                     \
+  V(UnsafeArrayBaseOffset)                     \
   /* 1.8 */                                    \
-  V(MethodHandleInvokeExact)                   \
-  V(MethodHandleInvoke)
+  V(JdkUnsafeArrayBaseOffset)                  \
+  V(MethodHandleInvoke)                        \
+
 
 class InvokeRuntimeCallingConvention : public CallingConvention<Register, FloatRegister> {
  public:
@@ -239,6 +247,7 @@ class LocationsBuilderX86_64 : public HGraphVisitor {
   void HandleBitwiseOperation(HBinaryOperation* operation);
   void HandleCondition(HCondition* condition);
   void HandleShift(HBinaryOperation* operation);
+  void HandleRotate(HBinaryOperation* rotate);
   void HandleFieldSet(HInstruction* instruction,
                       const FieldInfo& field_info,
                       WriteBarrierKind write_barrier_kind);
@@ -312,6 +321,7 @@ class InstructionCodeGeneratorX86_64 : public InstructionCodeGenerator {
   void GenerateDivRemIntegral(HBinaryOperation* instruction);
   void HandleCondition(HCondition* condition);
   void HandleShift(HBinaryOperation* operation);
+  void HandleRotate(HBinaryOperation* rotate);
 
   void HandleFieldSet(HInstruction* instruction,
                       const FieldInfo& field_info,
@@ -546,6 +556,9 @@ class CodeGeneratorX86_64 : public CodeGenerator {
   Label* NewJitRootClassPatch(const DexFile& dex_file,
                               dex::TypeIndex type_index,
                               Handle<mirror::Class> handle);
+  Label* NewJitRootMethodTypePatch(const DexFile& dex_file,
+                                   dex::ProtoIndex proto_index,
+                                   Handle<mirror::MethodType> method_type);
 
   void LoadBootImageAddress(CpuRegister reg, uint32_t boot_image_reference);
   void LoadIntrinsicDeclaringClass(CpuRegister reg, HInvoke* invoke);
@@ -765,6 +778,8 @@ class CodeGeneratorX86_64 : public CodeGenerator {
   ArenaDeque<PatchInfo<Label>> jit_string_patches_;
   // Patches for class literals in JIT compiled code.
   ArenaDeque<PatchInfo<Label>> jit_class_patches_;
+  // Patches for method type in JIT compiled code.
+  ArenaDeque<PatchInfo<Label>> jit_method_type_patches_;
 
   // Fixups for jump tables need to be handled specially.
   ArenaVector<JumpTableRIPFixup*> fixups_to_jump_tables_;
diff --git a/compiler/optimizing/codegen_test.cc b/compiler/optimizing/codegen_test.cc
index c72d3ea24a..7365f0fb7f 100644
--- a/compiler/optimizing/codegen_test.cc
+++ b/compiler/optimizing/codegen_test.cc
@@ -417,16 +417,15 @@ TEST_F(CodegenTest, NonMaterializedCondition) {
     HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
     graph->AddBlock(entry);
     graph->SetEntryBlock(entry);
-    entry->AddInstruction(new (GetAllocator()) HGoto());
+    MakeGoto(entry);
 
     HBasicBlock* first_block = new (GetAllocator()) HBasicBlock(graph);
     graph->AddBlock(first_block);
     entry->AddSuccessor(first_block);
     HIntConstant* constant0 = graph->GetIntConstant(0);
     HIntConstant* constant1 = graph->GetIntConstant(1);
-    HEqual* equal = new (GetAllocator()) HEqual(constant0, constant0);
-    first_block->AddInstruction(equal);
-    first_block->AddInstruction(new (GetAllocator()) HIf(equal));
+    HInstruction* equal = MakeCondition(first_block, kCondEQ, constant0, constant0);
+    MakeIf(first_block, equal);
 
     HBasicBlock* then_block = new (GetAllocator()) HBasicBlock(graph);
     HBasicBlock* else_block = new (GetAllocator()) HBasicBlock(graph);
@@ -441,9 +440,9 @@ TEST_F(CodegenTest, NonMaterializedCondition) {
     then_block->AddSuccessor(exit_block);
     else_block->AddSuccessor(exit_block);
 
-    exit_block->AddInstruction(new (GetAllocator()) HExit());
-    then_block->AddInstruction(new (GetAllocator()) HReturn(constant0));
-    else_block->AddInstruction(new (GetAllocator()) HReturn(constant1));
+    MakeExit(exit_block);
+    MakeReturn(then_block, constant0);
+    MakeReturn(else_block, constant1);
 
     ASSERT_FALSE(equal->IsEmittedAtUseSite());
     graph->BuildDominatorTree();
@@ -479,12 +478,12 @@ TEST_F(CodegenTest, MaterializedCondition1) {
       HBasicBlock* entry_block = new (GetAllocator()) HBasicBlock(graph);
       graph->AddBlock(entry_block);
       graph->SetEntryBlock(entry_block);
-      entry_block->AddInstruction(new (GetAllocator()) HGoto());
+      MakeGoto(entry_block);
       HBasicBlock* code_block = new (GetAllocator()) HBasicBlock(graph);
       graph->AddBlock(code_block);
       HBasicBlock* exit_block = new (GetAllocator()) HBasicBlock(graph);
       graph->AddBlock(exit_block);
-      exit_block->AddInstruction(new (GetAllocator()) HExit());
+      MakeExit(exit_block);
 
       entry_block->AddSuccessor(code_block);
       code_block->AddSuccessor(exit_block);
@@ -492,10 +491,8 @@ TEST_F(CodegenTest, MaterializedCondition1) {
 
       HIntConstant* cst_lhs = graph->GetIntConstant(lhs[i]);
       HIntConstant* cst_rhs = graph->GetIntConstant(rhs[i]);
-      HLessThan cmp_lt(cst_lhs, cst_rhs);
-      code_block->AddInstruction(&cmp_lt);
-      HReturn ret(&cmp_lt);
-      code_block->AddInstruction(&ret);
+      HInstruction* cmp_lt = MakeCondition(code_block, kCondLT, cst_lhs, cst_rhs);
+      MakeReturn(code_block, cmp_lt);
 
       graph->BuildDominatorTree();
       auto hook_before_codegen = [](HGraph* graph_in) {
@@ -528,7 +525,7 @@ TEST_F(CodegenTest, MaterializedCondition2) {
       HBasicBlock* entry_block = new (GetAllocator()) HBasicBlock(graph);
       graph->AddBlock(entry_block);
       graph->SetEntryBlock(entry_block);
-      entry_block->AddInstruction(new (GetAllocator()) HGoto());
+      MakeGoto(entry_block);
 
       HBasicBlock* if_block = new (GetAllocator()) HBasicBlock(graph);
       graph->AddBlock(if_block);
@@ -538,7 +535,7 @@ TEST_F(CodegenTest, MaterializedCondition2) {
       graph->AddBlock(if_false_block);
       HBasicBlock* exit_block = new (GetAllocator()) HBasicBlock(graph);
       graph->AddBlock(exit_block);
-      exit_block->AddInstruction(new (GetAllocator()) HExit());
+      MakeExit(exit_block);
 
       graph->SetEntryBlock(entry_block);
       entry_block->AddSuccessor(if_block);
@@ -550,21 +547,18 @@ TEST_F(CodegenTest, MaterializedCondition2) {
 
       HIntConstant* cst_lhs = graph->GetIntConstant(lhs[i]);
       HIntConstant* cst_rhs = graph->GetIntConstant(rhs[i]);
-      HLessThan cmp_lt(cst_lhs, cst_rhs);
-      if_block->AddInstruction(&cmp_lt);
+      HInstruction* cmp_lt = MakeCondition(if_block, kCondLT, cst_lhs, cst_rhs);
       // We insert a fake instruction to separate the HIf from the HLessThan
       // and force the materialization of the condition.
-      HMemoryBarrier force_materialization(MemBarrierKind::kAnyAny, 0);
-      if_block->AddInstruction(&force_materialization);
-      HIf if_lt(&cmp_lt);
-      if_block->AddInstruction(&if_lt);
+      HInstruction* force_materialization =
+          new (GetAllocator()) HMemoryBarrier(MemBarrierKind::kAnyAny, 0);
+      if_block->AddInstruction(force_materialization);
+      MakeIf(if_block, cmp_lt);
 
       HIntConstant* cst_lt = graph->GetIntConstant(1);
-      HReturn ret_lt(cst_lt);
-      if_true_block->AddInstruction(&ret_lt);
+      MakeReturn(if_true_block, cst_lt);
       HIntConstant* cst_ge = graph->GetIntConstant(0);
-      HReturn ret_ge(cst_ge);
-      if_false_block->AddInstruction(&ret_ge);
+      MakeReturn(if_false_block, cst_ge);
 
       graph->BuildDominatorTree();
       auto hook_before_codegen = [](HGraph* graph_in) {
@@ -605,88 +599,61 @@ void CodegenTest::TestComparison(IfCondition condition,
                                  int64_t j,
                                  DataType::Type type,
                                  const CodegenTargetConfig target_config) {
-  HGraph* graph = CreateGraph();
-
-  HBasicBlock* entry_block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(entry_block);
-  graph->SetEntryBlock(entry_block);
-  entry_block->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(block);
-
-  HBasicBlock* exit_block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(exit_block);
-  graph->SetExitBlock(exit_block);
-  exit_block->AddInstruction(new (GetAllocator()) HExit());
-
-  entry_block->AddSuccessor(block);
-  block->AddSuccessor(exit_block);
+  HBasicBlock* block = InitEntryMainExitGraph();
 
   HInstruction* op1;
   HInstruction* op2;
   if (type == DataType::Type::kInt32) {
-    op1 = graph->GetIntConstant(i);
-    op2 = graph->GetIntConstant(j);
+    op1 = graph_->GetIntConstant(i);
+    op2 = graph_->GetIntConstant(j);
   } else {
     DCHECK_EQ(type, DataType::Type::kInt64);
-    op1 = graph->GetLongConstant(i);
-    op2 = graph->GetLongConstant(j);
+    op1 = graph_->GetLongConstant(i);
+    op2 = graph_->GetLongConstant(j);
   }
 
-  HInstruction* comparison = nullptr;
   bool expected_result = false;
   const uint64_t x = i;
   const uint64_t y = j;
   switch (condition) {
     case kCondEQ:
-      comparison = new (GetAllocator()) HEqual(op1, op2);
       expected_result = (i == j);
       break;
     case kCondNE:
-      comparison = new (GetAllocator()) HNotEqual(op1, op2);
       expected_result = (i != j);
       break;
     case kCondLT:
-      comparison = new (GetAllocator()) HLessThan(op1, op2);
       expected_result = (i < j);
       break;
     case kCondLE:
-      comparison = new (GetAllocator()) HLessThanOrEqual(op1, op2);
       expected_result = (i <= j);
       break;
     case kCondGT:
-      comparison = new (GetAllocator()) HGreaterThan(op1, op2);
       expected_result = (i > j);
       break;
     case kCondGE:
-      comparison = new (GetAllocator()) HGreaterThanOrEqual(op1, op2);
       expected_result = (i >= j);
       break;
     case kCondB:
-      comparison = new (GetAllocator()) HBelow(op1, op2);
       expected_result = (x < y);
       break;
     case kCondBE:
-      comparison = new (GetAllocator()) HBelowOrEqual(op1, op2);
       expected_result = (x <= y);
       break;
     case kCondA:
-      comparison = new (GetAllocator()) HAbove(op1, op2);
       expected_result = (x > y);
       break;
     case kCondAE:
-      comparison = new (GetAllocator()) HAboveOrEqual(op1, op2);
       expected_result = (x >= y);
       break;
   }
-  block->AddInstruction(comparison);
-  block->AddInstruction(new (GetAllocator()) HReturn(comparison));
+  HInstruction* comparison = MakeCondition(block, condition, op1, op2);
+  MakeReturn(block, comparison);
 
-  graph->BuildDominatorTree();
+  graph_->BuildDominatorTree();
   std::unique_ptr<CompilerOptions> compiler_options =
       CommonCompilerTest::CreateCompilerOptions(target_config.GetInstructionSet(), "default");
-  RunCode(target_config, *compiler_options, graph, [](HGraph*) {}, true, expected_result);
+  RunCode(target_config, *compiler_options, graph_, [](HGraph*) {}, true, expected_result);
 }
 
 TEST_F(CodegenTest, ComparisonsInt) {
diff --git a/compiler/optimizing/common_arm.h b/compiler/optimizing/common_arm.h
index 5f71cb906c..a6861fdbaf 100644
--- a/compiler/optimizing/common_arm.h
+++ b/compiler/optimizing/common_arm.h
@@ -23,9 +23,10 @@
 #include "nodes.h"
 #include "utils/arm/constants_arm.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch32/macro-assembler-aarch32.h"
 #pragma GCC diagnostic pop
 
diff --git a/compiler/optimizing/common_arm64.h b/compiler/optimizing/common_arm64.h
index 8b64b2e2e8..5a51d2c80e 100644
--- a/compiler/optimizing/common_arm64.h
+++ b/compiler/optimizing/common_arm64.h
@@ -24,9 +24,10 @@
 #include "nodes.h"
 #include "utils/arm64/assembler_arm64.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/disasm-aarch64.h"
 #include "aarch64/macro-assembler-aarch64.h"
 #include "aarch64/simulator-aarch64.h"
diff --git a/compiler/optimizing/constant_folding_test.cc b/compiler/optimizing/constant_folding_test.cc
index 689d77111c..95d3c67957 100644
--- a/compiler/optimizing/constant_folding_test.cc
+++ b/compiler/optimizing/constant_folding_test.cc
@@ -34,7 +34,7 @@ namespace art HIDDEN {
  */
 class ConstantFoldingTest : public CommonCompilerTest, public OptimizingUnitTestHelper {
  public:
-  ConstantFoldingTest() : graph_(nullptr) { }
+  ConstantFoldingTest() { }
 
   void TestCode(const std::vector<uint16_t>& data,
                 const std::string& expected_before,
@@ -82,8 +82,6 @@ class ConstantFoldingTest : public CommonCompilerTest, public OptimizingUnitTest
     std::string actual_after_dce = printer_after_dce.str();
     EXPECT_EQ(expected_after_dce, actual_after_dce);
   }
-
-  HGraph* graph_;
 };
 
 /**
@@ -735,109 +733,92 @@ TEST_F(ConstantFoldingTest, ConstantCondition) {
  * in the bytecode, we need to set up the graph explicitly.
  */
 TEST_F(ConstantFoldingTest, UnsignedComparisonsWithZero) {
-  graph_ = CreateGraph();
-  HBasicBlock* entry_block = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry_block);
-  graph_->SetEntryBlock(entry_block);
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(block);
-  HBasicBlock* exit_block = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(exit_block);
-  graph_->SetExitBlock(exit_block);
-  entry_block->AddSuccessor(block);
-  block->AddSuccessor(exit_block);
+  HBasicBlock* block = InitEntryMainExitGraph();
 
   // Make various unsigned comparisons with zero against a parameter.
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32, true);
-  entry_block->AddInstruction(parameter);
-  entry_block->AddInstruction(new (GetAllocator()) HGoto());
-
+  HInstruction* parameter = MakeParam(DataType::Type::kInt32);
   HInstruction* zero = graph_->GetIntConstant(0);
 
-  HInstruction* last;
-  block->AddInstruction(last = new (GetAllocator()) HAbove(zero, parameter));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HAbove(parameter, zero));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HAboveOrEqual(zero, parameter));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HAboveOrEqual(parameter, zero));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HBelow(zero, parameter));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HBelow(parameter, zero));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HBelowOrEqual(zero, parameter));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(last = new (GetAllocator()) HBelowOrEqual(parameter, zero));
-  block->AddInstruction(new (GetAllocator()) HSelect(last, parameter, parameter, 0));
-  block->AddInstruction(new (GetAllocator()) HReturn(zero));
-
-  exit_block->AddInstruction(new (GetAllocator()) HExit());
+  HInstruction* a1 = MakeCondition(block, kCondA, zero, parameter);
+  MakeSelect(block, a1, parameter, parameter);
+  HInstruction* a2 = MakeCondition(block, kCondA, parameter, zero);
+  MakeSelect(block, a2, parameter, parameter);
+  HInstruction* ae1 = MakeCondition(block, kCondAE, zero, parameter);
+  MakeSelect(block, ae1, parameter, parameter);
+  HInstruction* ae2 = MakeCondition(block, kCondAE, parameter, zero);
+  MakeSelect(block, ae2, parameter, parameter);
+  HInstruction* b1 = MakeCondition(block, kCondB, zero, parameter);
+  MakeSelect(block, b1, parameter, parameter);
+  HInstruction* b2 = MakeCondition(block, kCondB, parameter, zero);
+  MakeSelect(block, b2, parameter, parameter);
+  HInstruction* be1 = MakeCondition(block, kCondBE, zero, parameter);
+  MakeSelect(block, be1, parameter, parameter);
+  HInstruction* be2 = MakeCondition(block, kCondBE, parameter, zero);
+  MakeSelect(block, be2, parameter, parameter);
+  MakeReturn(block, zero);
 
   graph_->BuildDominatorTree();
 
   const std::string expected_before =
       "BasicBlock 0, succ: 1\n"
-      "  0: ParameterValue [18, 18, 17, 16, 16, 15, 14, 14, 13, 12, 12, 11, 10, 10, 9, "
-                            "8, 8, 7, 6, 6, 5, 4, 4, 3]\n"
-      "  2: IntConstant [19, 17, 15, 13, 11, 9, 7, 5, 3]\n"
-      "  1: Goto 1\n"
+      "  2: ParameterValue [19, 19, 18, 17, 17, 16, 15, 15, 14, 13, 13, 12, 11, 11, 10, "
+                            "9, 9, 8, 7, 7, 6, 5, 5, 4]\n"
+      "  3: IntConstant [20, 18, 16, 14, 12, 10, 8, 6, 4]\n"
+      "  0: Goto 1\n"
       "BasicBlock 1, pred: 0, succ: 2\n"
-      "  3: Above(2, 0) [4]\n"
-      "  4: Select(0, 0, 3)\n"
-      "  5: Above(0, 2) [6]\n"
-      "  6: Select(0, 0, 5)\n"
-      "  7: AboveOrEqual(2, 0) [8]\n"
-      "  8: Select(0, 0, 7)\n"
-      "  9: AboveOrEqual(0, 2) [10]\n"
-      "  10: Select(0, 0, 9)\n"
-      "  11: Below(2, 0) [12]\n"
-      "  12: Select(0, 0, 11)\n"
-      "  13: Below(0, 2) [14]\n"
-      "  14: Select(0, 0, 13)\n"
-      "  15: BelowOrEqual(2, 0) [16]\n"
-      "  16: Select(0, 0, 15)\n"
-      "  17: BelowOrEqual(0, 2) [18]\n"
-      "  18: Select(0, 0, 17)\n"
-      "  19: Return(2)\n"
+      "  4: Above(3, 2) [5]\n"
+      "  5: Select(2, 2, 4)\n"
+      "  6: Above(2, 3) [7]\n"
+      "  7: Select(2, 2, 6)\n"
+      "  8: AboveOrEqual(3, 2) [9]\n"
+      "  9: Select(2, 2, 8)\n"
+      "  10: AboveOrEqual(2, 3) [11]\n"
+      "  11: Select(2, 2, 10)\n"
+      "  12: Below(3, 2) [13]\n"
+      "  13: Select(2, 2, 12)\n"
+      "  14: Below(2, 3) [15]\n"
+      "  15: Select(2, 2, 14)\n"
+      "  16: BelowOrEqual(3, 2) [17]\n"
+      "  17: Select(2, 2, 16)\n"
+      "  18: BelowOrEqual(2, 3) [19]\n"
+      "  19: Select(2, 2, 18)\n"
+      "  20: Return(3)\n"
       "BasicBlock 2, pred: 1\n"
-      "  20: Exit\n";
+      "  1: Exit\n";
 
   const std::string expected_after_cf =
       "BasicBlock 0, succ: 1\n"
-      "  0: ParameterValue [18, 18, 17, 16, 16, 14, 14, 12, 12, 11, 10, 10, "
-                            "8, 8, 7, 6, 6, 5, 4, 4]\n"
-      "  2: IntConstant [14, 4, 19, 17, 11, 7, 5]\n"
-      "  21: IntConstant [16, 10]\n"
-      "  1: Goto 1\n"
+      "  2: ParameterValue [19, 19, 18, 17, 17, 15, 15, 13, 13, 12, 11, 11, "
+                            "9, 9, 8, 7, 7, 6, 5, 5]\n"
+      "  3: IntConstant [15, 5, 20, 18, 12, 8, 6]\n"
+      "  21: IntConstant [17, 11]\n"
+      "  0: Goto 1\n"
       "BasicBlock 1, pred: 0, succ: 2\n"
-      "  4: Select(0, 0, 2)\n"
-      "  5: Above(0, 2) [6]\n"
-      "  6: Select(0, 0, 5)\n"
-      "  7: AboveOrEqual(2, 0) [8]\n"
-      "  8: Select(0, 0, 7)\n"
-      "  10: Select(0, 0, 21)\n"
-      "  11: Below(2, 0) [12]\n"
-      "  12: Select(0, 0, 11)\n"
-      "  14: Select(0, 0, 2)\n"
-      "  16: Select(0, 0, 21)\n"
-      "  17: BelowOrEqual(0, 2) [18]\n"
-      "  18: Select(0, 0, 17)\n"
-      "  19: Return(2)\n"
+      "  5: Select(2, 2, 3)\n"
+      "  6: Above(2, 3) [7]\n"
+      "  7: Select(2, 2, 6)\n"
+      "  8: AboveOrEqual(3, 2) [9]\n"
+      "  9: Select(2, 2, 8)\n"
+      "  11: Select(2, 2, 21)\n"
+      "  12: Below(3, 2) [13]\n"
+      "  13: Select(2, 2, 12)\n"
+      "  15: Select(2, 2, 3)\n"
+      "  17: Select(2, 2, 21)\n"
+      "  18: BelowOrEqual(2, 3) [19]\n"
+      "  19: Select(2, 2, 18)\n"
+      "  20: Return(3)\n"
       "BasicBlock 2, pred: 1\n"
-      "  20: Exit\n";
+      "  1: Exit\n";
 
   const std::string expected_after_dce =
       "BasicBlock 0, succ: 1\n"
-      "  0: ParameterValue\n"
-      "  2: IntConstant [19]\n"
-      "  1: Goto 1\n"
+      "  2: ParameterValue\n"
+      "  3: IntConstant [20]\n"
+      "  0: Goto 1\n"
       "BasicBlock 1, pred: 0, succ: 2\n"
-      "  19: Return(2)\n"
+      "  20: Return(3)\n"
       "BasicBlock 2, pred: 1\n"
-      "  20: Exit\n";
+      "  1: Exit\n";
 
   auto check_after_cf = [](HGraph* graph) {
     CHECK(graph != nullptr);
diff --git a/compiler/optimizing/graph_checker.cc b/compiler/optimizing/graph_checker.cc
index 1ff0d4dc84..82f98ed5ea 100644
--- a/compiler/optimizing/graph_checker.cc
+++ b/compiler/optimizing/graph_checker.cc
@@ -754,10 +754,12 @@ void GraphChecker::VisitInvoke(HInvoke* invoke) {
   // Check for intrinsics which should have been replaced by intermediate representation in the
   // instruction builder.
   if (!IsValidIntrinsicAfterBuilder(invoke->GetIntrinsic())) {
+    std::stringstream ss;
+    ss << invoke->GetIntrinsic();
     AddError(
-        StringPrintf("The graph contains the instrinsic %d which should have been replaced in the "
+        StringPrintf("The graph contains the intrinsic %s which should have been replaced in the "
                      "instruction builder: %s:%d in block %d.",
-                     enum_cast<int>(invoke->GetIntrinsic()),
+                     ss.str().c_str(),
                      invoke->DebugName(),
                      invoke->GetId(),
                      invoke->GetBlock()->GetBlockId()));
@@ -766,7 +768,7 @@ void GraphChecker::VisitInvoke(HInvoke* invoke) {
 
 void GraphChecker::VisitInvokeStaticOrDirect(HInvokeStaticOrDirect* invoke) {
   // We call VisitInvoke and not VisitInstruction to de-duplicate the common code: always throwing
-  // and instrinsic checks.
+  // and intrinsic checks.
   VisitInvoke(invoke);
 
   if (invoke->IsStaticWithExplicitClinitCheck()) {
@@ -1402,7 +1404,7 @@ void GraphChecker::VisitBinaryOperation(HBinaryOperation* op) {
   DataType::Type result_type = op->GetType();
 
   // Type consistency between inputs.
-  if (op->IsUShr() || op->IsShr() || op->IsShl() || op->IsRor()) {
+  if (op->IsUShr() || op->IsShr() || op->IsShl() || op->IsRol() || op->IsRor()) {
     if (DataType::Kind(rhs_type) != DataType::Type::kInt32) {
       AddError(StringPrintf("Shift/rotate operation %s %d has a non-int kind second input: "
                             "%s of type %s.",
@@ -1426,7 +1428,7 @@ void GraphChecker::VisitBinaryOperation(HBinaryOperation* op) {
                             op->GetId(),
                             DataType::PrettyDescriptor(result_type)));
     }
-  } else if (op->IsUShr() || op->IsShr() || op->IsShl() || op->IsRor()) {
+  } else if (op->IsUShr() || op->IsShr() || op->IsShl() || op->IsRol() || op->IsRor()) {
     // Only check the first input (value), as the second one (distance)
     // must invariably be of kind `int`.
     if (result_type != DataType::Kind(lhs_type)) {
diff --git a/compiler/optimizing/graph_checker_test.cc b/compiler/optimizing/graph_checker_test.cc
index b256fbb46d..cea34b9e2c 100644
--- a/compiler/optimizing/graph_checker_test.cc
+++ b/compiler/optimizing/graph_checker_test.cc
@@ -37,11 +37,11 @@ class GraphCheckerTest : public CommonCompilerTest, public OptimizingUnitTestHel
 HGraph* GraphCheckerTest::CreateSimpleCFG() {
   HGraph* graph = CreateGraph();
   HBasicBlock* entry_block = new (GetAllocator()) HBasicBlock(graph);
-  entry_block->AddInstruction(new (GetAllocator()) HReturnVoid());
+  MakeReturnVoid(entry_block);
   graph->AddBlock(entry_block);
   graph->SetEntryBlock(entry_block);
   HBasicBlock* exit_block = new (GetAllocator()) HBasicBlock(graph);
-  exit_block->AddInstruction(new (GetAllocator()) HExit());
+  MakeExit(exit_block);
   graph->AddBlock(exit_block);
   graph->SetExitBlock(exit_block);
   entry_block->AddSuccessor(exit_block);
diff --git a/compiler/optimizing/graph_test.cc b/compiler/optimizing/graph_test.cc
index b5d712736f..5b43af3564 100644
--- a/compiler/optimizing/graph_test.cc
+++ b/compiler/optimizing/graph_test.cc
@@ -38,18 +38,15 @@ HBasicBlock* GraphTest::CreateIfBlock(HGraph* graph) {
   HBasicBlock* if_block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(if_block);
   HInstruction* instr = graph->GetIntConstant(4);
-  HInstruction* equal = new (GetAllocator()) HEqual(instr, instr);
-  if_block->AddInstruction(equal);
-  instr = new (GetAllocator()) HIf(equal);
-  if_block->AddInstruction(instr);
+  HInstruction* equal = MakeCondition(if_block, kCondEQ, instr, instr);
+  MakeIf(if_block, equal);
   return if_block;
 }
 
 HBasicBlock* GraphTest::CreateGotoBlock(HGraph* graph) {
   HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(block);
-  HInstruction* got = new (GetAllocator()) HGoto();
-  block->AddInstruction(got);
+  MakeGoto(block);
   return block;
 }
 
@@ -70,8 +67,7 @@ HBasicBlock* GraphTest::CreateReturnBlock(HGraph* graph) {
 HBasicBlock* GraphTest::CreateExitBlock(HGraph* graph) {
   HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(block);
-  HInstruction* exit_instr = new (GetAllocator()) HExit();
-  block->AddInstruction(exit_instr);
+  MakeExit(block);
   return block;
 }
 
diff --git a/compiler/optimizing/graph_visualizer.cc b/compiler/optimizing/graph_visualizer.cc
index 46db4489d6..0c42b9e85d 100644
--- a/compiler/optimizing/graph_visualizer.cc
+++ b/compiler/optimizing/graph_visualizer.cc
@@ -488,6 +488,7 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
 
   void VisitCompare(HCompare* compare) override {
     StartAttributeStream("bias") << compare->GetBias();
+    StartAttributeStream("comparison_type") << compare->GetComparisonType();
   }
 
   void VisitCondition(HCondition* condition) override {
@@ -517,6 +518,7 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
     if (method != nullptr) {
       StartAttributeStream("method_index") << method->GetMethodIndex();
     }
+    StartAttributeStream("intrinsic") << invoke->GetIntrinsic();
   }
 
   void VisitInvokeUnresolved(HInvokeUnresolved* invoke) override {
@@ -527,7 +529,6 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
   void VisitInvokeStaticOrDirect(HInvokeStaticOrDirect* invoke) override {
     VisitInvoke(invoke);
     StartAttributeStream("method_load_kind") << invoke->GetMethodLoadKind();
-    StartAttributeStream("intrinsic") << invoke->GetIntrinsic();
     if (invoke->IsStatic()) {
       StartAttributeStream("clinit_check") << invoke->GetClinitCheckRequirement();
     }
@@ -535,7 +536,6 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
 
   void VisitInvokeVirtual(HInvokeVirtual* invoke) override {
     VisitInvoke(invoke);
-    StartAttributeStream("intrinsic") << invoke->GetIntrinsic();
   }
 
   void VisitInvokePolymorphic(HInvokePolymorphic* invoke) override {
diff --git a/compiler/optimizing/gvn_test.cc b/compiler/optimizing/gvn_test.cc
index 1eb6307cb1..fba53ee157 100644
--- a/compiler/optimizing/gvn_test.cc
+++ b/compiler/optimizing/gvn_test.cc
@@ -28,80 +28,28 @@ namespace art HIDDEN {
 class GVNTest : public OptimizingUnitTest {};
 
 TEST_F(GVNTest, LocalFieldElimination) {
-  HGraph* graph = CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(graph->GetDexFile(),
-                                                                 dex::TypeIndex(0),
-                                                                 0,
-                                                                 DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
-
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kReference,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kReference,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  HInstruction* to_remove = block->GetLastInstruction();
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kReference,
-                                                               MemberOffset(43),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  HInstruction* different_offset = block->GetLastInstruction();
+  HBasicBlock* block = InitEntryMainExitGraphWithReturnVoid();
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+
+  MakeIFieldGet(block, parameter, DataType::Type::kReference, MemberOffset(42));
+  HInstruction* to_remove =
+      MakeIFieldGet(block, parameter, DataType::Type::kReference, MemberOffset(42));
+  HInstruction* different_offset =
+      MakeIFieldGet(block, parameter, DataType::Type::kReference, MemberOffset(43));
   // Kill the value.
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldSet(parameter,
-                                                               parameter,
-                                                               nullptr,
-                                                               DataType::Type::kReference,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kReference,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  HInstruction* use_after_kill = block->GetLastInstruction();
-  block->AddInstruction(new (GetAllocator()) HExit());
+  MakeIFieldSet(block, parameter, parameter, MemberOffset(42));
+  HInstruction* use_after_kill =
+      MakeIFieldGet(block, parameter, DataType::Type::kReference, MemberOffset(42));
 
   ASSERT_EQ(to_remove->GetBlock(), block);
   ASSERT_EQ(different_offset->GetBlock(), block);
   ASSERT_EQ(use_after_kill->GetBlock(), block);
 
-  graph->BuildDominatorTree();
-  SideEffectsAnalysis side_effects(graph);
+  graph_->BuildDominatorTree();
+  SideEffectsAnalysis side_effects(graph_);
   side_effects.Run();
-  GVNOptimization(graph, side_effects).Run();
+  GVNOptimization(graph_, side_effects).Run();
 
   ASSERT_TRUE(to_remove->GetBlock() == nullptr);
   ASSERT_EQ(different_offset->GetBlock(), block);
@@ -109,250 +57,101 @@ TEST_F(GVNTest, LocalFieldElimination) {
 }
 
 TEST_F(GVNTest, GlobalFieldElimination) {
-  HGraph* graph = CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(graph->GetDexFile(),
-                                                                 dex::TypeIndex(0),
-                                                                 0,
-                                                                 DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kBool,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-
-  block->AddInstruction(new (GetAllocator()) HIf(block->GetLastInstruction()));
-  HBasicBlock* then = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* else_ = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* join = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(then);
-  graph->AddBlock(else_);
-  graph->AddBlock(join);
-
-  block->AddSuccessor(then);
-  block->AddSuccessor(else_);
-  then->AddSuccessor(join);
-  else_->AddSuccessor(join);
-
-  then->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                              nullptr,
-                                                              DataType::Type::kBool,
-                                                              MemberOffset(42),
-                                                              false,
-                                                              kUnknownFieldIndex,
-                                                              kUnknownClassDefIndex,
-                                                              graph->GetDexFile(),
-                                                              0));
-  then->AddInstruction(new (GetAllocator()) HGoto());
-  else_->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kBool,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  else_->AddInstruction(new (GetAllocator()) HGoto());
-  join->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                              nullptr,
-                                                              DataType::Type::kBool,
-                                                              MemberOffset(42),
-                                                              false,
-                                                              kUnknownFieldIndex,
-                                                              kUnknownClassDefIndex,
-                                                              graph->GetDexFile(),
-                                                              0));
-  join->AddInstruction(new (GetAllocator()) HExit());
-
-  graph->BuildDominatorTree();
-  SideEffectsAnalysis side_effects(graph);
+  HBasicBlock* join = InitEntryMainExitGraphWithReturnVoid();
+  auto [block, then, else_] = CreateDiamondPattern(join);
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+
+  HInstruction* field_get =
+      MakeIFieldGet(block, parameter, DataType::Type::kBool, MemberOffset(42));
+  MakeIf(block, field_get);
+
+  MakeIFieldGet(then, parameter, DataType::Type::kBool, MemberOffset(42));
+  MakeIFieldGet(else_, parameter, DataType::Type::kBool, MemberOffset(42));
+  MakeIFieldGet(join, parameter, DataType::Type::kBool, MemberOffset(42));
+
+  graph_->BuildDominatorTree();
+  SideEffectsAnalysis side_effects(graph_);
   side_effects.Run();
-  GVNOptimization(graph, side_effects).Run();
+  GVNOptimization(graph_, side_effects).Run();
 
   // Check that all field get instructions have been GVN'ed.
   ASSERT_TRUE(then->GetFirstInstruction()->IsGoto());
   ASSERT_TRUE(else_->GetFirstInstruction()->IsGoto());
-  ASSERT_TRUE(join->GetFirstInstruction()->IsExit());
+  ASSERT_TRUE(join->GetFirstInstruction()->IsReturnVoid());
 }
 
 TEST_F(GVNTest, LoopFieldElimination) {
-  HGraph* graph = CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(graph->GetDexFile(),
-                                                                 dex::TypeIndex(0),
-                                                                 0,
-                                                                 DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-
-  HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(block);
-  entry->AddSuccessor(block);
-  block->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                               nullptr,
-                                                               DataType::Type::kBool,
-                                                               MemberOffset(42),
-                                                               false,
-                                                               kUnknownFieldIndex,
-                                                               kUnknownClassDefIndex,
-                                                               graph->GetDexFile(),
-                                                               0));
-  block->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* loop_header = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* loop_body = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph);
-
-  graph->AddBlock(loop_header);
-  graph->AddBlock(loop_body);
-  graph->AddBlock(exit);
-  block->AddSuccessor(loop_header);
-  loop_header->AddSuccessor(loop_body);
-  loop_header->AddSuccessor(exit);
-  loop_body->AddSuccessor(loop_header);
-
-  loop_header->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                                     nullptr,
-                                                                     DataType::Type::kBool,
-                                                                     MemberOffset(42),
-                                                                     false,
-                                                                     kUnknownFieldIndex,
-                                                                     kUnknownClassDefIndex,
-                                                                     graph->GetDexFile(),
-                                                                     0));
-  HInstruction* field_get_in_loop_header = loop_header->GetLastInstruction();
-  loop_header->AddInstruction(new (GetAllocator()) HIf(block->GetLastInstruction()));
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [pre_header, loop_header, loop_body] = CreateWhileLoop(return_block);
+  loop_header->SwapSuccessors();  // Move the loop exit to the "else" successor.
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+
+  MakeIFieldGet(pre_header, parameter, DataType::Type::kBool, MemberOffset(42));
+
+  HInstruction* field_get_in_loop_header =
+      MakeIFieldGet(loop_header, parameter, DataType::Type::kBool, MemberOffset(42));
+  MakeIf(loop_header, field_get_in_loop_header);
 
   // Kill inside the loop body to prevent field gets inside the loop header
   // and the body to be GVN'ed.
-  loop_body->AddInstruction(new (GetAllocator()) HInstanceFieldSet(parameter,
-                                                                   parameter,
-                                                                   nullptr,
-                                                                   DataType::Type::kBool,
-                                                                   MemberOffset(42),
-                                                                   false,
-                                                                   kUnknownFieldIndex,
-                                                                   kUnknownClassDefIndex,
-                                                                   graph->GetDexFile(),
-                                                                   0));
-  HInstruction* field_set = loop_body->GetLastInstruction();
-  loop_body->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                                   nullptr,
-                                                                   DataType::Type::kBool,
-                                                                   MemberOffset(42),
-                                                                   false,
-                                                                   kUnknownFieldIndex,
-                                                                   kUnknownClassDefIndex,
-                                                                   graph->GetDexFile(),
-                                                                   0));
-  HInstruction* field_get_in_loop_body = loop_body->GetLastInstruction();
-  loop_body->AddInstruction(new (GetAllocator()) HGoto());
-
-  exit->AddInstruction(new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                              nullptr,
-                                                              DataType::Type::kBool,
-                                                              MemberOffset(42),
-                                                              false,
-                                                              kUnknownFieldIndex,
-                                                              kUnknownClassDefIndex,
-                                                              graph->GetDexFile(),
-                                                              0));
-  HInstruction* field_get_in_exit = exit->GetLastInstruction();
-  exit->AddInstruction(new (GetAllocator()) HExit());
+  HInstruction* field_set =
+      MakeIFieldSet(loop_body, parameter, parameter, DataType::Type::kBool, MemberOffset(42));
+  HInstruction* field_get_in_loop_body =
+      MakeIFieldGet(loop_body, parameter, DataType::Type::kBool, MemberOffset(42));
+
+  HInstruction* field_get_in_return_block =
+      MakeIFieldGet(return_block, parameter, DataType::Type::kBool, MemberOffset(42));
 
   ASSERT_EQ(field_get_in_loop_header->GetBlock(), loop_header);
   ASSERT_EQ(field_get_in_loop_body->GetBlock(), loop_body);
-  ASSERT_EQ(field_get_in_exit->GetBlock(), exit);
+  ASSERT_EQ(field_get_in_return_block->GetBlock(), return_block);
 
-  graph->BuildDominatorTree();
+  graph_->BuildDominatorTree();
   {
-    SideEffectsAnalysis side_effects(graph);
+    SideEffectsAnalysis side_effects(graph_);
     side_effects.Run();
-    GVNOptimization(graph, side_effects).Run();
+    GVNOptimization(graph_, side_effects).Run();
   }
 
   // Check that all field get instructions are still there.
   ASSERT_EQ(field_get_in_loop_header->GetBlock(), loop_header);
   ASSERT_EQ(field_get_in_loop_body->GetBlock(), loop_body);
-  // The exit block is dominated by the loop header, whose field get
+  // The `return_block` is dominated by the `loop_header`, whose field get
   // does not get killed by the loop flags.
-  ASSERT_TRUE(field_get_in_exit->GetBlock() == nullptr);
+  ASSERT_TRUE(field_get_in_return_block->GetBlock() == nullptr);
 
   // Now remove the field set, and check that all field get instructions have been GVN'ed.
   loop_body->RemoveInstruction(field_set);
   {
-    SideEffectsAnalysis side_effects(graph);
+    SideEffectsAnalysis side_effects(graph_);
     side_effects.Run();
-    GVNOptimization(graph, side_effects).Run();
+    GVNOptimization(graph_, side_effects).Run();
   }
 
   ASSERT_TRUE(field_get_in_loop_header->GetBlock() == nullptr);
   ASSERT_TRUE(field_get_in_loop_body->GetBlock() == nullptr);
-  ASSERT_TRUE(field_get_in_exit->GetBlock() == nullptr);
+  ASSERT_TRUE(field_get_in_return_block->GetBlock() == nullptr);
 }
 
 // Test that inner loops affect the side effects of the outer loop.
 TEST_F(GVNTest, LoopSideEffects) {
   static const SideEffects kCanTriggerGC = SideEffects::CanTriggerGC();
 
-  HGraph* graph = CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-
-  HBasicBlock* outer_loop_header = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* outer_loop_body = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* outer_loop_exit = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* inner_loop_header = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* inner_loop_body = new (GetAllocator()) HBasicBlock(graph);
-  HBasicBlock* inner_loop_exit = new (GetAllocator()) HBasicBlock(graph);
-
-  graph->AddBlock(outer_loop_header);
-  graph->AddBlock(outer_loop_body);
-  graph->AddBlock(outer_loop_exit);
-  graph->AddBlock(inner_loop_header);
-  graph->AddBlock(inner_loop_body);
-  graph->AddBlock(inner_loop_exit);
-
-  entry->AddSuccessor(outer_loop_header);
-  outer_loop_header->AddSuccessor(outer_loop_body);
-  outer_loop_header->AddSuccessor(outer_loop_exit);
-  outer_loop_body->AddSuccessor(inner_loop_header);
-  inner_loop_header->AddSuccessor(inner_loop_body);
-  inner_loop_header->AddSuccessor(inner_loop_exit);
-  inner_loop_body->AddSuccessor(inner_loop_header);
-  inner_loop_exit->AddSuccessor(outer_loop_header);
-
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(graph->GetDexFile(),
-                                                                 dex::TypeIndex(0),
-                                                                 0,
-                                                                 DataType::Type::kBool);
-  entry->AddInstruction(parameter);
-  entry->AddInstruction(new (GetAllocator()) HGoto());
-  outer_loop_header->AddInstruction(new (GetAllocator()) HSuspendCheck());
-  outer_loop_header->AddInstruction(new (GetAllocator()) HIf(parameter));
-  outer_loop_body->AddInstruction(new (GetAllocator()) HGoto());
-  inner_loop_header->AddInstruction(new (GetAllocator()) HSuspendCheck());
-  inner_loop_header->AddInstruction(new (GetAllocator()) HIf(parameter));
-  inner_loop_body->AddInstruction(new (GetAllocator()) HGoto());
-  inner_loop_exit->AddInstruction(new (GetAllocator()) HGoto());
-  outer_loop_exit->AddInstruction(new (GetAllocator()) HExit());
-
-  graph->BuildDominatorTree();
+  HBasicBlock* outer_loop_exit = InitEntryMainExitGraphWithReturnVoid();
+  auto [outer_preheader, outer_loop_header, inner_loop_exit] = CreateWhileLoop(outer_loop_exit);
+  outer_loop_header->SwapSuccessors();  // Move the loop exit to the "else" successor.
+  auto [outer_loop_body, inner_loop_header, inner_loop_body] = CreateWhileLoop(inner_loop_exit);
+  inner_loop_header->SwapSuccessors();  // Move the loop exit to the "else" successor.
+
+  HInstruction* parameter = MakeParam(DataType::Type::kBool);
+  MakeSuspendCheck(outer_loop_header);
+  MakeIf(outer_loop_header, parameter);
+  MakeSuspendCheck(inner_loop_header);
+  MakeIf(inner_loop_header, parameter);
+
+  graph_->BuildDominatorTree();
 
   ASSERT_TRUE(inner_loop_header->GetLoopInformation()->IsIn(
       *outer_loop_header->GetLoopInformation()));
@@ -360,21 +159,12 @@ TEST_F(GVNTest, LoopSideEffects) {
   // Check that the only side effect of loops is to potentially trigger GC.
   {
     // Make one block with a side effect.
-    entry->AddInstruction(new (GetAllocator()) HInstanceFieldSet(parameter,
-                                                                 parameter,
-                                                                 nullptr,
-                                                                 DataType::Type::kReference,
-                                                                 MemberOffset(42),
-                                                                 false,
-                                                                 kUnknownFieldIndex,
-                                                                 kUnknownClassDefIndex,
-                                                                 graph->GetDexFile(),
-                                                                 0));
-
-    SideEffectsAnalysis side_effects(graph);
+    MakeIFieldSet(entry_block_, parameter, parameter, DataType::Type::kReference, MemberOffset(42));
+
+    SideEffectsAnalysis side_effects(graph_);
     side_effects.Run();
 
-    ASSERT_TRUE(side_effects.GetBlockEffects(entry).DoesAnyWrite());
+    ASSERT_TRUE(side_effects.GetBlockEffects(entry_block_).DoesAnyWrite());
     ASSERT_FALSE(side_effects.GetBlockEffects(outer_loop_body).DoesAnyWrite());
     ASSERT_FALSE(side_effects.GetLoopEffects(outer_loop_header).DoesAnyWrite());
     ASSERT_FALSE(side_effects.GetLoopEffects(inner_loop_header).DoesAnyWrite());
@@ -384,23 +174,13 @@ TEST_F(GVNTest, LoopSideEffects) {
 
   // Check that the side effects of the outer loop does not affect the inner loop.
   {
-    outer_loop_body->InsertInstructionBefore(
-        new (GetAllocator()) HInstanceFieldSet(parameter,
-                                               parameter,
-                                               nullptr,
-                                               DataType::Type::kReference,
-                                               MemberOffset(42),
-                                               false,
-                                               kUnknownFieldIndex,
-                                               kUnknownClassDefIndex,
-                                               graph->GetDexFile(),
-                                               0),
-        outer_loop_body->GetLastInstruction());
-
-    SideEffectsAnalysis side_effects(graph);
+    MakeIFieldSet(
+        outer_loop_body, parameter, parameter, DataType::Type::kReference, MemberOffset(42));
+
+    SideEffectsAnalysis side_effects(graph_);
     side_effects.Run();
 
-    ASSERT_TRUE(side_effects.GetBlockEffects(entry).DoesAnyWrite());
+    ASSERT_TRUE(side_effects.GetBlockEffects(entry_block_).DoesAnyWrite());
     ASSERT_TRUE(side_effects.GetBlockEffects(outer_loop_body).DoesAnyWrite());
     ASSERT_TRUE(side_effects.GetLoopEffects(outer_loop_header).DoesAnyWrite());
     ASSERT_FALSE(side_effects.GetLoopEffects(inner_loop_header).DoesAnyWrite());
@@ -410,23 +190,13 @@ TEST_F(GVNTest, LoopSideEffects) {
   // Check that the side effects of the inner loop affects the outer loop.
   {
     outer_loop_body->RemoveInstruction(outer_loop_body->GetFirstInstruction());
-    inner_loop_body->InsertInstructionBefore(
-        new (GetAllocator()) HInstanceFieldSet(parameter,
-                                               parameter,
-                                               nullptr,
-                                               DataType::Type::kReference,
-                                               MemberOffset(42),
-                                               false,
-                                               kUnknownFieldIndex,
-                                               kUnknownClassDefIndex,
-                                               graph->GetDexFile(),
-                                               0),
-        inner_loop_body->GetLastInstruction());
-
-    SideEffectsAnalysis side_effects(graph);
+    MakeIFieldSet(
+        inner_loop_body, parameter, parameter, DataType::Type::kReference, MemberOffset(42));
+
+    SideEffectsAnalysis side_effects(graph_);
     side_effects.Run();
 
-    ASSERT_TRUE(side_effects.GetBlockEffects(entry).DoesAnyWrite());
+    ASSERT_TRUE(side_effects.GetBlockEffects(entry_block_).DoesAnyWrite());
     ASSERT_FALSE(side_effects.GetBlockEffects(outer_loop_body).DoesAnyWrite());
     ASSERT_TRUE(side_effects.GetLoopEffects(outer_loop_header).DoesAnyWrite());
     ASSERT_TRUE(side_effects.GetLoopEffects(inner_loop_header).DoesAnyWrite());
diff --git a/compiler/optimizing/induction_var_analysis_test.cc b/compiler/optimizing/induction_var_analysis_test.cc
index 80c15371dc..b8f683774d 100644
--- a/compiler/optimizing/induction_var_analysis_test.cc
+++ b/compiler/optimizing/induction_var_analysis_test.cc
@@ -32,9 +32,6 @@ class InductionVarAnalysisTest : public OptimizingUnitTest {
  public:
   InductionVarAnalysisTest()
       : iva_(nullptr),
-        entry_(nullptr),
-        return_(nullptr),
-        exit_(nullptr),
         parameter_(nullptr),
         constant0_(nullptr),
         constant1_(nullptr),
@@ -43,58 +40,28 @@ class InductionVarAnalysisTest : public OptimizingUnitTest {
         constant100_(nullptr),
         constantm1_(nullptr),
         float_constant0_(nullptr) {
-    graph_ = CreateGraph();
   }
 
   ~InductionVarAnalysisTest() { }
 
-  // Builds single for-loop at depth d.
-  void BuildForLoop(int d, int n) {
-    ASSERT_LT(d, n);
-    loop_preheader_[d] = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(loop_preheader_[d]);
-    loop_header_[d] = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(loop_header_[d]);
-    loop_preheader_[d]->AddSuccessor(loop_header_[d]);
-    if (d < (n - 1)) {
-      BuildForLoop(d + 1, n);
-    }
-    loop_body_[d] = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(loop_body_[d]);
-    loop_body_[d]->AddSuccessor(loop_header_[d]);
-    if (d < (n - 1)) {
-      loop_header_[d]->AddSuccessor(loop_preheader_[d + 1]);
-      loop_header_[d + 1]->AddSuccessor(loop_body_[d]);
-    } else {
-      loop_header_[d]->AddSuccessor(loop_body_[d]);
-    }
-  }
-
   // Builds a n-nested loop in CFG where each loop at depth 0 <= d < n
   // is defined as "for (int i_d = 0; i_d < 100; i_d++)". Tests can further
   // populate the loop with instructions to set up interesting scenarios.
-  void BuildLoopNest(int n) {
+  void BuildLoopNest(size_t n) {
     ASSERT_LE(n, 10);
+    HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
     graph_->SetNumberOfVRegs(n + 3);
 
-    // Build basic blocks with entry, nested loop, exit.
-    entry_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(entry_);
-    BuildForLoop(0, n);
-    return_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(return_);
-    exit_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(exit_);
-    entry_->AddSuccessor(loop_preheader_[0]);
-    loop_header_[0]->AddSuccessor(return_);
-    return_->AddSuccessor(exit_);
-    graph_->SetEntryBlock(entry_);
-    graph_->SetExitBlock(exit_);
-
-    // Provide entry and exit instructions.
-    parameter_ = new (GetAllocator()) HParameterValue(
-        graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference, true);
-    entry_->AddInstruction(parameter_);
+    // Build nested loops.
+    HBasicBlock* loop_pos = return_block;
+    for (size_t d = 0; d < n; ++d) {
+      std::tie(loop_preheader_[d], loop_header_[d], loop_body_[d]) = CreateWhileLoop(loop_pos);
+      loop_header_[d]->SwapSuccessors();  // Move the loop exit to the "else" successor.
+      loop_pos = loop_body_[d];
+    }
+
+    // Provide entry instructions.
+    parameter_ = MakeParam(DataType::Type::kReference);
     constant0_ = graph_->GetIntConstant(0);
     constant1_ = graph_->GetIntConstant(1);
     constant2_ = graph_->GetIntConstant(2);
@@ -102,41 +69,28 @@ class InductionVarAnalysisTest : public OptimizingUnitTest {
     constant100_ = graph_->GetIntConstant(100);
     constantm1_ = graph_->GetIntConstant(-1);
     float_constant0_ = graph_->GetFloatConstant(0.0f);
-    return_->AddInstruction(new (GetAllocator()) HReturnVoid());
-    exit_->AddInstruction(new (GetAllocator()) HExit());
 
     // Provide loop instructions.
     for (int d = 0; d < n; d++) {
-      basic_[d] = new (GetAllocator()) HPhi(GetAllocator(), d, 0, DataType::Type::kInt32);
-      loop_preheader_[d]->AddInstruction(new (GetAllocator()) HGoto());
-      loop_header_[d]->AddPhi(basic_[d]);
-      HInstruction* compare = new (GetAllocator()) HLessThan(basic_[d], constant100_);
-      loop_header_[d]->AddInstruction(compare);
-      loop_header_[d]->AddInstruction(new (GetAllocator()) HIf(compare));
-      increment_[d] = new (GetAllocator()) HAdd(DataType::Type::kInt32, basic_[d], constant1_);
-      loop_body_[d]->AddInstruction(increment_[d]);
-      loop_body_[d]->AddInstruction(new (GetAllocator()) HGoto());
-
-      basic_[d]->AddInput(constant0_);
-      basic_[d]->AddInput(increment_[d]);
+      std::tie(basic_[d], increment_[d]) =
+          MakeLinearLoopVar(loop_header_[d], loop_body_[d], constant0_, constant1_);
+      HInstruction* compare = MakeCondition(loop_header_[d], kCondLT, basic_[d], constant100_);
+      MakeIf(loop_header_[d], compare);
     }
   }
 
   // Builds if-statement at depth d.
   HPhi* BuildIf(int d, HBasicBlock** ifT, HBasicBlock** ifF) {
-    HBasicBlock* cond = new (GetAllocator()) HBasicBlock(graph_);
-    HBasicBlock* ifTrue = new (GetAllocator()) HBasicBlock(graph_);
-    HBasicBlock* ifFalse = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(cond);
-    graph_->AddBlock(ifTrue);
-    graph_->AddBlock(ifFalse);
+    HBasicBlock* cond = AddNewBlock();
+    HBasicBlock* ifTrue = AddNewBlock();
+    HBasicBlock* ifFalse = AddNewBlock();
     // Conditional split.
     loop_header_[d]->ReplaceSuccessor(loop_body_[d], cond);
     cond->AddSuccessor(ifTrue);
     cond->AddSuccessor(ifFalse);
     ifTrue->AddSuccessor(loop_body_[d]);
     ifFalse->AddSuccessor(loop_body_[d]);
-    cond->AddInstruction(new (GetAllocator()) HIf(parameter_));
+    MakeIf(cond, parameter_);
     *ifT = ifTrue;
     *ifF = ifFalse;
 
@@ -201,13 +155,9 @@ class InductionVarAnalysisTest : public OptimizingUnitTest {
   }
 
   // General building fields.
-  HGraph* graph_;
   HInductionVarAnalysis* iva_;
 
   // Fixed basic blocks and instructions.
-  HBasicBlock* entry_;
-  HBasicBlock* return_;
-  HBasicBlock* exit_;
   HInstruction* parameter_;  // "this"
   HInstruction* constant0_;
   HInstruction* constant1_;
@@ -240,7 +190,7 @@ TEST_F(InductionVarAnalysisTest, ProperLoopSetup) {
   BuildLoopNest(10);
   graph_->BuildDominatorTree();
 
-  ASSERT_EQ(entry_->GetLoopInformation(), nullptr);
+  ASSERT_EQ(entry_block_->GetLoopInformation(), nullptr);
   for (int d = 0; d < 1; d++) {
     ASSERT_EQ(loop_preheader_[d]->GetLoopInformation(),
               (d == 0) ? nullptr
@@ -250,7 +200,7 @@ TEST_F(InductionVarAnalysisTest, ProperLoopSetup) {
     ASSERT_EQ(loop_header_[d]->GetLoopInformation(),
               loop_body_[d]->GetLoopInformation());
   }
-  ASSERT_EQ(exit_->GetLoopInformation(), nullptr);
+  ASSERT_EQ(exit_block_->GetLoopInformation(), nullptr);
 }
 
 TEST_F(InductionVarAnalysisTest, FindBasicInduction) {
@@ -348,12 +298,10 @@ TEST_F(InductionVarAnalysisTest, FindTwoWayBasicInduction) {
   HPhi* k_body = BuildIf(0, &ifTrue, &ifFalse);
 
   // True-branch.
-  HInstruction* inc1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, k_header, constant1_);
-  ifTrue->AddInstruction(inc1);
+  HInstruction* inc1 = MakeBinOp<HAdd>(ifTrue, DataType::Type::kInt32, k_header, constant1_);
   k_body->AddInput(inc1);
   // False-branch.
-  HInstruction* inc2 = new (GetAllocator()) HAdd(DataType::Type::kInt32, k_header, constant1_);
-  ifFalse->AddInstruction(inc2);
+  HInstruction* inc2 = MakeBinOp<HAdd>(ifFalse, DataType::Type::kInt32, k_header, constant1_);
   k_body->AddInput(inc2);
   // Merge over a phi.
   HInstruction* store = InsertArrayStore(k_body, 0);
@@ -381,12 +329,10 @@ TEST_F(InductionVarAnalysisTest, FindTwoWayDerivedInduction) {
   HPhi* k = BuildIf(0, &ifTrue, &ifFalse);
 
   // True-branch.
-  HInstruction* inc1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, basic_[0], constant1_);
-  ifTrue->AddInstruction(inc1);
+  HInstruction* inc1 = MakeBinOp<HAdd>(ifTrue, DataType::Type::kInt32, basic_[0], constant1_);
   k->AddInput(inc1);
   // False-branch.
-  HInstruction* inc2 = new (GetAllocator()) HAdd(DataType::Type::kInt32, basic_[0], constant1_);
-  ifFalse->AddInstruction(inc2);
+  HInstruction* inc2 = MakeBinOp<HAdd>(ifFalse, DataType::Type::kInt32, basic_[0], constant1_);
   k->AddInput(inc2);
   // Merge over a phi.
   HInstruction* store = InsertArrayStore(k, 0);
diff --git a/compiler/optimizing/induction_var_range.cc b/compiler/optimizing/induction_var_range.cc
index 8568062933..2f5a22ec0e 100644
--- a/compiler/optimizing/induction_var_range.cc
+++ b/compiler/optimizing/induction_var_range.cc
@@ -368,8 +368,8 @@ void InductionVarRange::Replace(HInstruction* instruction,
   for (HLoopInformation* lp = instruction->GetBlock()->GetLoopInformation();  // closest enveloping loop
        lp != nullptr;
        lp = lp->GetPreHeader()->GetLoopInformation()) {
-    // Update instruction's information.
-    ReplaceInduction(induction_analysis_->LookupInfo(lp, instruction), fetch, replacement);
+    // Update loop's InductionInfo about fetch.
+    ReplaceInduction(induction_analysis_->LookupInfo(lp, fetch), fetch, replacement);
     // Update loop's trip-count information.
     ReplaceInduction(induction_analysis_->LookupInfo(lp, GetLoopControl(lp)), fetch, replacement);
   }
@@ -384,6 +384,11 @@ bool InductionVarRange::HasKnownTripCount(const HLoopInformation* loop,
                                           /*out*/ int64_t* trip_count) const {
   bool is_constant = false;
   CheckForFiniteAndConstantProps(loop, &is_constant, trip_count);
+  // Set negative trip counts as 0, since it means that no trips would happen. Note that if the
+  // `is_constant` value is false, `trip_count` would be disregareded.
+  if (*trip_count < 0) {
+    *trip_count = 0;
+  }
   return is_constant;
 }
 
@@ -811,7 +816,7 @@ InductionVarRange::Value InductionVarRange::GetVal(const HBasicBlock* context,
           case HInductionVarAnalysis::kTripCountInLoopUnsafe:
             if (UseFullTripCount(context, loop, is_min)) {
               // Return the full trip count (do not subtract 1 as we do in loop body).
-              return GetVal(context, loop, info->op_a, trip, /*is_min=*/ false);
+              return GetVal(context, loop, info->op_a, trip, is_min);
             }
             FALLTHROUGH_INTENDED;
           case HInductionVarAnalysis::kTripCountInBody:
@@ -1556,7 +1561,7 @@ bool InductionVarRange::GenerateCode(const HBasicBlock* context,
                                   trip,
                                   graph,
                                   block,
-                                  /*is_min=*/false,
+                                  is_min,
                                   result,
                                   allow_potential_overflow);
             }
diff --git a/compiler/optimizing/induction_var_range.h b/compiler/optimizing/induction_var_range.h
index a81227b41b..ab497414c9 100644
--- a/compiler/optimizing/induction_var_range.h
+++ b/compiler/optimizing/induction_var_range.h
@@ -128,8 +128,8 @@ class InductionVarRange {
   HInstruction* GenerateLastValue(HInstruction* instruction, HGraph* graph, HBasicBlock* block);
 
   /**
-   * Updates all matching fetches with the given replacement in all induction information
-   * that is associated with the given instruction.
+   * Updates all matching `fetch`es with the given `replacement` in all induction information
+   * that is present in the loops of the given `instruction`.
    */
   void Replace(HInstruction* instruction, HInstruction* fetch, HInstruction* replacement);
 
diff --git a/compiler/optimizing/induction_var_range_test.cc b/compiler/optimizing/induction_var_range_test.cc
index 40fb0d6092..17ee6787ff 100644
--- a/compiler/optimizing/induction_var_range_test.cc
+++ b/compiler/optimizing/induction_var_range_test.cc
@@ -33,10 +33,10 @@ using Value = InductionVarRange::Value;
 class InductionVarRangeTest : public OptimizingUnitTest {
  public:
   InductionVarRangeTest()
-      : graph_(CreateGraph()),
-        iva_(new (GetAllocator()) HInductionVarAnalysis(graph_)),
+      : iva_(new (GetAllocator()) HInductionVarAnalysis(BuildGraph())),
         range_(iva_) {
-    BuildGraph();
+    // Set arbitrary range analysis hint while testing private methods.
+    SetHint(x_);
   }
 
   ~InductionVarRangeTest() { }
@@ -58,65 +58,27 @@ class InductionVarRangeTest : public OptimizingUnitTest {
   //
 
   /** Constructs bare minimum graph. */
-  void BuildGraph() {
+  HGraph* BuildGraph() {
+    return_block_ = InitEntryMainExitGraphWithReturnVoid();
     graph_->SetNumberOfVRegs(1);
-    entry_block_ = new (GetAllocator()) HBasicBlock(graph_);
-    exit_block_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(entry_block_);
-    graph_->AddBlock(exit_block_);
-    graph_->SetEntryBlock(entry_block_);
-    graph_->SetExitBlock(exit_block_);
     // Two parameters.
-    x_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                              dex::TypeIndex(0),
-                                              0,
-                                              DataType::Type::kInt32);
-    entry_block_->AddInstruction(x_);
-    y_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                              dex::TypeIndex(0),
-                                              0,
-                                              DataType::Type::kInt32);
-    entry_block_->AddInstruction(y_);
-    // Set arbitrary range analysis hint while testing private methods.
-    SetHint(x_);
+    x_ = MakeParam(DataType::Type::kInt32);
+    y_ = MakeParam(DataType::Type::kInt32);
+    return graph_;
   }
 
   /** Constructs loop with given upper bound. */
   void BuildLoop(int32_t lower, HInstruction* upper, int32_t stride) {
     // Control flow.
-    loop_preheader_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(loop_preheader_);
-    loop_header_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(loop_header_);
-    loop_body_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(loop_body_);
-    HBasicBlock* return_block = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(return_block);
-    entry_block_->AddSuccessor(loop_preheader_);
-    loop_preheader_->AddSuccessor(loop_header_);
-    loop_header_->AddSuccessor(loop_body_);
-    loop_header_->AddSuccessor(return_block);
-    loop_body_->AddSuccessor(loop_header_);
-    return_block->AddSuccessor(exit_block_);
+    std::tie(loop_preheader_, loop_header_, loop_body_) = CreateWhileLoop(return_block_);
+    loop_header_->SwapSuccessors();  // Move the loop exit to the "else" successor.
     // Instructions.
-    loop_preheader_->AddInstruction(new (GetAllocator()) HGoto());
-    HPhi* phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-    loop_header_->AddPhi(phi);
-    phi->AddInput(graph_->GetIntConstant(lower));  // i = l
-    if (stride > 0) {
-      condition_ = new (GetAllocator()) HLessThan(phi, upper);  // i < u
-    } else {
-      condition_ = new (GetAllocator()) HGreaterThan(phi, upper);  // i > u
-    }
-    loop_header_->AddInstruction(condition_);
-    loop_header_->AddInstruction(new (GetAllocator()) HIf(condition_));
-    increment_ =
-        new (GetAllocator()) HAdd(DataType::Type::kInt32, phi, graph_->GetIntConstant(stride));
-    loop_body_->AddInstruction(increment_);  // i += s
-    phi->AddInput(increment_);
-    loop_body_->AddInstruction(new (GetAllocator()) HGoto());
-    return_block->AddInstruction(new (GetAllocator()) HReturnVoid());
-    exit_block_->AddInstruction(new (GetAllocator()) HExit());
+    HInstruction* lower_const = graph_->GetIntConstant(lower);
+    HPhi* phi;
+    std::tie(phi, increment_) = MakeLinearLoopVar(loop_header_, loop_body_, lower, stride);
+    IfCondition cond = (stride > 0) ? kCondLT : kCondGT;
+    condition_ = MakeCondition(loop_header_, cond, phi, upper);  // i < u or i > u
+    MakeIf(loop_header_, condition_);
   }
 
   /** Constructs SSA and performs induction variable analysis. */
@@ -350,9 +312,7 @@ class InductionVarRangeTest : public OptimizingUnitTest {
   Value MaxValue(Value v1, Value v2) { return range_.MergeVal(v1, v2, false); }
 
   // General building fields.
-  HGraph* graph_;
-  HBasicBlock* entry_block_;
-  HBasicBlock* exit_block_;
+  HBasicBlock* return_block_;
   HBasicBlock* loop_preheader_;
   HBasicBlock* loop_header_;
   HBasicBlock* loop_body_;
@@ -922,14 +882,8 @@ TEST_F(InductionVarRangeTest, MaxValue) {
 
 TEST_F(InductionVarRangeTest, ArrayLengthAndHints) {
   // We pass a bogus constant for the class to avoid mocking one.
-  HInstruction* new_array = new (GetAllocator()) HNewArray(
-      /* cls= */ x_,
-      /* length= */ x_,
-      /* dex_pc= */ 0,
-      /* component_size_shift= */ 0);
-  entry_block_->AddInstruction(new_array);
-  HInstruction* array_length = new (GetAllocator()) HArrayLength(new_array, 0);
-  entry_block_->AddInstruction(array_length);
+  HInstruction* new_array = MakeNewArray(entry_block_, /* cls= */ x_, /* length= */ x_);
+  HInstruction* array_length = MakeArrayLength(entry_block_, new_array);
   // With null hint: yields extreme constants.
   const int32_t max_value = std::numeric_limits<int32_t>::max();
   SetHint(nullptr);
@@ -946,18 +900,12 @@ TEST_F(InductionVarRangeTest, ArrayLengthAndHints) {
 }
 
 TEST_F(InductionVarRangeTest, AddOrSubAndConstant) {
-  HInstruction* add = new (GetAllocator())
-      HAdd(DataType::Type::kInt32, x_, graph_->GetIntConstant(-1));
-  HInstruction* alt = new (GetAllocator())
-      HAdd(DataType::Type::kInt32, graph_->GetIntConstant(-1), x_);
-  HInstruction* sub = new (GetAllocator())
-      HSub(DataType::Type::kInt32, x_, graph_->GetIntConstant(1));
-  HInstruction* rev = new (GetAllocator())
-      HSub(DataType::Type::kInt32, graph_->GetIntConstant(1), x_);
-  entry_block_->AddInstruction(add);
-  entry_block_->AddInstruction(alt);
-  entry_block_->AddInstruction(sub);
-  entry_block_->AddInstruction(rev);
+  HInstruction* plus1 = graph_->GetIntConstant(1);
+  HInstruction* minus1 = graph_->GetIntConstant(-1);
+  HInstruction* add = MakeBinOp<HAdd>(entry_block_, DataType::Type::kInt32, x_, minus1);
+  HInstruction* alt = MakeBinOp<HAdd>(entry_block_, DataType::Type::kInt32, minus1, x_);
+  HInstruction* sub = MakeBinOp<HSub>(entry_block_, DataType::Type::kInt32, x_, plus1);
+  HInstruction* rev = MakeBinOp<HSub>(entry_block_, DataType::Type::kInt32, plus1, x_);
   ExpectEqual(Value(x_, 1, -1), GetMin(CreateFetch(add), nullptr));
   ExpectEqual(Value(x_, 1, -1), GetMax(CreateFetch(add), nullptr));
   ExpectEqual(Value(x_, 1, -1), GetMin(CreateFetch(alt), nullptr));
diff --git a/compiler/optimizing/inliner.cc b/compiler/optimizing/inliner.cc
index 8a25e82816..90df4521e8 100644
--- a/compiler/optimizing/inliner.cc
+++ b/compiler/optimizing/inliner.cc
@@ -1343,6 +1343,13 @@ bool HInliner::TryDevirtualize(HInvoke* invoke_instruction,
     return false;
   }
 
+  // Don't devirtualize to an intrinsic invalid after the builder phase. The ArtMethod might be an
+  // intrinsic even when the HInvoke isn't e.g. java.lang.CharSequence.isEmpty (not an intrinsic)
+  // can get devirtualized into java.lang.String.isEmpty (which is an intrinsic).
+  if (method->IsIntrinsic() && !IsValidIntrinsicAfterBuilder(method->GetIntrinsic())) {
+    return false;
+  }
+
   // Don't bother trying to call directly a default conflict method. It
   // doesn't have a proper MethodReference, but also `GetCanonicalMethod`
   // will return an actual default implementation.
@@ -1590,7 +1597,7 @@ bool HInliner::TryBuildAndInline(HInvoke* invoke_instruction,
   // another chance before we try to inline it.
   if (invoke_instruction->GetResolvedMethod() != method &&
       method->IsIntrinsic() &&
-      IsValidIntrinsicAfterBuilder(static_cast<Intrinsics>(method->GetIntrinsic()))) {
+      IsValidIntrinsicAfterBuilder(method->GetIntrinsic())) {
     MaybeRecordStat(stats_, MethodCompilationStat::kIntrinsicRecognized);
     // For simplicity, always create a new instruction to replace the existing
     // invoke.
diff --git a/compiler/optimizing/instruction_builder.cc b/compiler/optimizing/instruction_builder.cc
index 344a93707d..55e3267427 100644
--- a/compiler/optimizing/instruction_builder.cc
+++ b/compiler/optimizing/instruction_builder.cc
@@ -667,12 +667,16 @@ void HInstructionBuilder::InitializeParameters() {
 
 template<typename T, bool kCompareWithZero>
 void HInstructionBuilder::If_21_22t(const Instruction& instruction, uint32_t dex_pc) {
-  HInstruction* value = LoadLocal(instruction.VRegA(), DataType::Type::kInt32);
+  DCHECK_EQ(kCompareWithZero ? Instruction::Format::k21t : Instruction::Format::k22t,
+            Instruction::FormatOf(instruction.Opcode()));
+  HInstruction* value = LoadLocal(
+      kCompareWithZero ? instruction.VRegA_21t() : instruction.VRegA_22t(),
+      DataType::Type::kInt32);
   T* comparison = nullptr;
   if (kCompareWithZero) {
     comparison = new (allocator_) T(value, graph_->GetIntConstant(0, dex_pc), dex_pc);
   } else {
-    HInstruction* second = LoadLocal(instruction.VRegB(), DataType::Type::kInt32);
+    HInstruction* second = LoadLocal(instruction.VRegB_22t(), DataType::Type::kInt32);
     comparison = new (allocator_) T(value, second, dex_pc);
   }
   AppendInstruction(comparison);
@@ -697,90 +701,90 @@ template<typename T>
 void HInstructionBuilder::Unop_12x(const Instruction& instruction,
                                    DataType::Type type,
                                    uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), type);
+  HInstruction* first = LoadLocal(instruction.VRegB_12x(), type);
   AppendInstruction(new (allocator_) T(type, first, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_12x(), current_block_->GetLastInstruction());
 }
 
 void HInstructionBuilder::Conversion_12x(const Instruction& instruction,
                                          DataType::Type input_type,
                                          DataType::Type result_type,
                                          uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), input_type);
+  HInstruction* first = LoadLocal(instruction.VRegB_12x(), input_type);
   AppendInstruction(new (allocator_) HTypeConversion(result_type, first, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_12x(), current_block_->GetLastInstruction());
 }
 
 template<typename T>
 void HInstructionBuilder::Binop_23x(const Instruction& instruction,
                                     DataType::Type type,
                                     uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), type);
-  HInstruction* second = LoadLocal(instruction.VRegC(), type);
+  HInstruction* first = LoadLocal(instruction.VRegB_23x(), type);
+  HInstruction* second = LoadLocal(instruction.VRegC_23x(), type);
   AppendInstruction(new (allocator_) T(type, first, second, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_23x(), current_block_->GetLastInstruction());
 }
 
 template<typename T>
 void HInstructionBuilder::Binop_23x_shift(const Instruction& instruction,
                                           DataType::Type type,
                                           uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), type);
-  HInstruction* second = LoadLocal(instruction.VRegC(), DataType::Type::kInt32);
+  HInstruction* first = LoadLocal(instruction.VRegB_23x(), type);
+  HInstruction* second = LoadLocal(instruction.VRegC_23x(), DataType::Type::kInt32);
   AppendInstruction(new (allocator_) T(type, first, second, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_23x(), current_block_->GetLastInstruction());
 }
 
 void HInstructionBuilder::Binop_23x_cmp(const Instruction& instruction,
                                         DataType::Type type,
                                         ComparisonBias bias,
                                         uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), type);
-  HInstruction* second = LoadLocal(instruction.VRegC(), type);
+  HInstruction* first = LoadLocal(instruction.VRegB_23x(), type);
+  HInstruction* second = LoadLocal(instruction.VRegC_23x(), type);
   AppendInstruction(new (allocator_) HCompare(type, first, second, bias, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_23x(), current_block_->GetLastInstruction());
 }
 
 template<typename T>
 void HInstructionBuilder::Binop_12x_shift(const Instruction& instruction,
                                           DataType::Type type,
                                           uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegA(), type);
-  HInstruction* second = LoadLocal(instruction.VRegB(), DataType::Type::kInt32);
+  HInstruction* first = LoadLocal(instruction.VRegA_12x(), type);
+  HInstruction* second = LoadLocal(instruction.VRegB_12x(), DataType::Type::kInt32);
   AppendInstruction(new (allocator_) T(type, first, second, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_12x(), current_block_->GetLastInstruction());
 }
 
 template<typename T>
 void HInstructionBuilder::Binop_12x(const Instruction& instruction,
                                     DataType::Type type,
                                     uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegA(), type);
-  HInstruction* second = LoadLocal(instruction.VRegB(), type);
+  HInstruction* first = LoadLocal(instruction.VRegA_12x(), type);
+  HInstruction* second = LoadLocal(instruction.VRegB_12x(), type);
   AppendInstruction(new (allocator_) T(type, first, second, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_12x(), current_block_->GetLastInstruction());
 }
 
 template<typename T>
 void HInstructionBuilder::Binop_22s(const Instruction& instruction, bool reverse, uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), DataType::Type::kInt32);
+  HInstruction* first = LoadLocal(instruction.VRegB_22s(), DataType::Type::kInt32);
   HInstruction* second = graph_->GetIntConstant(instruction.VRegC_22s(), dex_pc);
   if (reverse) {
     std::swap(first, second);
   }
   AppendInstruction(new (allocator_) T(DataType::Type::kInt32, first, second, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_22s(), current_block_->GetLastInstruction());
 }
 
 template<typename T>
 void HInstructionBuilder::Binop_22b(const Instruction& instruction, bool reverse, uint32_t dex_pc) {
-  HInstruction* first = LoadLocal(instruction.VRegB(), DataType::Type::kInt32);
+  HInstruction* first = LoadLocal(instruction.VRegB_22b(), DataType::Type::kInt32);
   HInstruction* second = graph_->GetIntConstant(instruction.VRegC_22b(), dex_pc);
   if (reverse) {
     std::swap(first, second);
   }
   AppendInstruction(new (allocator_) T(DataType::Type::kInt32, first, second, dex_pc));
-  UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+  UpdateLocal(instruction.VRegA_22b(), current_block_->GetLastInstruction());
 }
 
 // Does the method being compiled need any constructor barriers being inserted?
@@ -809,7 +813,7 @@ static bool IsFallthroughInstruction(const Instruction& instruction,
 }
 
 void HInstructionBuilder::BuildSwitch(const Instruction& instruction, uint32_t dex_pc) {
-  HInstruction* value = LoadLocal(instruction.VRegA(), DataType::Type::kInt32);
+  HInstruction* value = LoadLocal(instruction.VRegA_31t(), DataType::Type::kInt32);
   DexSwitchTable table(instruction, dex_pc);
 
   if (table.GetNumEntries() == 0) {
@@ -835,6 +839,26 @@ void HInstructionBuilder::BuildSwitch(const Instruction& instruction, uint32_t d
   current_block_ = nullptr;
 }
 
+template <DataType::Type type>
+ALWAYS_INLINE inline void HInstructionBuilder::BuildMove(uint32_t dest_reg, uint32_t src_reg) {
+  // The verifier has no notion of a null type, so a move-object of constant 0
+  // will lead to the same constant 0 in the destination register. To mimic
+  // this behavior, we just pretend we haven't seen a type change (int to reference)
+  // for the 0 constant and phis. We rely on our type propagation to eventually get the
+  // types correct.
+  constexpr bool is_reference = type == DataType::Type::kReference;
+  HInstruction* value = is_reference ? (*current_locals_)[src_reg] : /* not needed */ nullptr;
+  if (is_reference && value->IsIntConstant()) {
+    DCHECK_EQ(value->AsIntConstant()->GetValue(), 0);
+  } else if (is_reference && value->IsPhi()) {
+    DCHECK(value->GetType() == DataType::Type::kInt32 ||
+           value->GetType() == DataType::Type::kReference);
+  } else {
+    value = LoadLocal(src_reg, type);
+  }
+  UpdateLocal(dest_reg, value);
+}
+
 void HInstructionBuilder::BuildReturn(const Instruction& instruction,
                                       DataType::Type type,
                                       uint32_t dex_pc) {
@@ -862,7 +886,7 @@ void HInstructionBuilder::BuildReturn(const Instruction& instruction,
     AppendInstruction(new (allocator_) HReturnVoid(dex_pc));
   } else {
     DCHECK(!RequiresConstructorBarrier(dex_compilation_unit_));
-    HInstruction* value = LoadLocal(instruction.VRegA(), type);
+    HInstruction* value = LoadLocal(instruction.VRegA_11x(), type);
     if (graph_->IsDebuggable() && code_generator_->GetCompilerOptions().IsJitCompiler()) {
       AppendInstruction(new (allocator_) HMethodExitHook(value, dex_pc));
     }
@@ -1366,8 +1390,24 @@ bool HInstructionBuilder::BuildInvokePolymorphic(uint32_t dex_pc,
                                             &is_string_constructor);
 
   MethodReference method_reference(&graph_->GetDexFile(), method_idx);
+
+  // MethodHandle.invokeExact intrinsic needs to check whether call-site matches with MethodHandle's
+  // type. To do that, MethodType corresponding to the call-site is passed as an extra input.
+  // Other invoke-polymorphic calls do not need it.
+  bool is_invoke_exact =
+      static_cast<Intrinsics>(resolved_method->GetIntrinsic()) ==
+          Intrinsics::kMethodHandleInvokeExact;
+  // Currently intrinsic works for MethodHandle targeting invoke-virtual calls only.
+  bool can_be_virtual = number_of_arguments >= 2 &&
+      DataType::FromShorty(shorty[1]) == DataType::Type::kReference;
+
+  bool can_be_intrinsified = is_invoke_exact && can_be_virtual;
+
+  uint32_t number_of_other_inputs = can_be_intrinsified ? 1u : 0u;
+
   HInvoke* invoke = new (allocator_) HInvokePolymorphic(allocator_,
                                                         number_of_arguments,
+                                                        number_of_other_inputs,
                                                         return_type,
                                                         dex_pc,
                                                         method_reference,
@@ -1378,6 +1418,8 @@ bool HInstructionBuilder::BuildInvokePolymorphic(uint32_t dex_pc,
     return false;
   }
 
+  DCHECK_EQ(invoke->AsInvokePolymorphic()->CanHaveFastPath(), can_be_intrinsified);
+
   if (invoke->GetIntrinsic() != Intrinsics::kNone &&
       invoke->GetIntrinsic() != Intrinsics::kMethodHandleInvoke &&
       invoke->GetIntrinsic() != Intrinsics::kMethodHandleInvokeExact &&
@@ -1855,6 +1897,26 @@ bool HInstructionBuilder::SetupInvokeArguments(HInstruction* invoke,
                           graph_->GetCurrentMethod());
   }
 
+  if (invoke->IsInvokePolymorphic()) {
+    HInvokePolymorphic* invoke_polymorphic = invoke->AsInvokePolymorphic();
+
+    // MethodHandle.invokeExact intrinsic expects MethodType corresponding to the call-site as an
+    // extra input to determine whether to throw WrongMethodTypeException or execute target method.
+    if (invoke_polymorphic->CanHaveFastPath()) {
+      HLoadMethodType* load_method_type =
+          new (allocator_) HLoadMethodType(graph_->GetCurrentMethod(),
+                                           invoke_polymorphic->GetProtoIndex(),
+                                           graph_->GetDexFile(),
+                                           invoke_polymorphic->GetDexPc());
+      HSharpening::ProcessLoadMethodType(load_method_type,
+                                         code_generator_,
+                                         *dex_compilation_unit_,
+                                         graph_->GetHandleCache()->GetHandles());
+      invoke->SetRawInputAt(invoke_polymorphic->GetNumberOfArguments(), load_method_type);
+      AppendInstruction(load_method_type);
+    }
+  }
+
   return true;
 }
 
@@ -1882,7 +1944,7 @@ bool HInstructionBuilder::BuildSimpleIntrinsic(ArtMethod* method,
                                                uint32_t dex_pc,
                                                const InstructionOperands& operands,
                                                const char* shorty) {
-  Intrinsics intrinsic = static_cast<Intrinsics>(method->GetIntrinsic());
+  Intrinsics intrinsic = method->GetIntrinsic();
   DCHECK_NE(intrinsic, Intrinsics::kNone);
   constexpr DataType::Type kInt32 = DataType::Type::kInt32;
   constexpr DataType::Type kInt64 = DataType::Type::kInt64;
@@ -1891,14 +1953,16 @@ bool HInstructionBuilder::BuildSimpleIntrinsic(ArtMethod* method,
   ReceiverArg receiver_arg = method->IsStatic() ? ReceiverArg::kNone : ReceiverArg::kNullCheckedArg;
   HInstruction* instruction = nullptr;
   switch (intrinsic) {
-    case Intrinsics::kIntegerRotateRight:
     case Intrinsics::kIntegerRotateLeft:
-      // For rotate left, we negate the distance below.
+      instruction = new (allocator_) HRol(kInt32, /*value=*/ nullptr, /*distance=*/ nullptr);
+      break;
+    case Intrinsics::kIntegerRotateRight:
       instruction = new (allocator_) HRor(kInt32, /*value=*/ nullptr, /*distance=*/ nullptr);
       break;
-    case Intrinsics::kLongRotateRight:
     case Intrinsics::kLongRotateLeft:
-      // For rotate left, we negate the distance below.
+      instruction = new (allocator_) HRol(kInt64, /*value=*/ nullptr, /*distance=*/ nullptr);
+      break;
+    case Intrinsics::kLongRotateRight:
       instruction = new (allocator_) HRor(kInt64, /*value=*/ nullptr, /*distance=*/ nullptr);
       break;
     case Intrinsics::kIntegerCompare:
@@ -2017,15 +2081,6 @@ bool HInstructionBuilder::BuildSimpleIntrinsic(ArtMethod* method,
   }
 
   switch (intrinsic) {
-    case Intrinsics::kIntegerRotateLeft:
-    case Intrinsics::kLongRotateLeft: {
-      // Negate the distance value for rotate left.
-      DCHECK(instruction->IsRor());
-      HNeg* neg = new (allocator_) HNeg(kInt32, instruction->InputAt(1u));
-      AppendInstruction(neg);
-      instruction->SetRawInputAt(1u, neg);
-      break;
-    }
     case Intrinsics::kFloatIsNaN:
     case Intrinsics::kDoubleIsNaN:
       // Set the second input to be the same as first.
@@ -2358,7 +2413,7 @@ void HInstructionBuilder::BuildCheckedDivRem(uint16_t out_vreg,
                                              uint32_t dex_pc,
                                              DataType::Type type,
                                              bool second_is_constant,
-                                             bool isDiv) {
+                                             bool is_div) {
   DCHECK(type == DataType::Type::kInt32 || type == DataType::Type::kInt64);
 
   HInstruction* first = LoadLocal(first_vreg, type);
@@ -2380,7 +2435,7 @@ void HInstructionBuilder::BuildCheckedDivRem(uint16_t out_vreg,
     AppendInstruction(second);
   }
 
-  if (isDiv) {
+  if (is_div) {
     AppendInstruction(new (allocator_) HDiv(type, first, second, dex_pc));
   } else {
     AppendInstruction(new (allocator_) HRem(type, first, second, dex_pc));
@@ -2696,9 +2751,10 @@ void HInstructionBuilder::BuildLoadMethodType(dex::ProtoIndex proto_index, uint3
   const DexFile& dex_file = *dex_compilation_unit_->GetDexFile();
   HLoadMethodType* load_method_type =
       new (allocator_) HLoadMethodType(graph_->GetCurrentMethod(), proto_index, dex_file, dex_pc);
-  if (!code_generator_->GetCompilerOptions().IsJitCompiler()) {
-    load_method_type->SetLoadKind(HLoadMethodType::LoadKind::kBssEntry);
-  }
+  HSharpening::ProcessLoadMethodType(load_method_type,
+                                     code_generator_,
+                                     *dex_compilation_unit_,
+                                     graph_->GetHandleCache()->GetHandles());
   AppendInstruction(load_method_type);
 }
 
@@ -2778,35 +2834,35 @@ void HInstructionBuilder::BuildTypeCheck(const Instruction& instruction,
 bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction, uint32_t dex_pc) {
   switch (instruction.Opcode()) {
     case Instruction::CONST_4: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_11n();
       HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_11n(), dex_pc);
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_16: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_21s();
       HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_21s(), dex_pc);
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_31i();
       HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_31i(), dex_pc);
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_HIGH16: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_21h();
       HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_21h() << 16, dex_pc);
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_WIDE_16: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_21s();
       // Get 16 bits of constant value, sign extended to 64 bits.
       int64_t value = instruction.VRegB_21s();
       value <<= 48;
@@ -2817,7 +2873,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     }
 
     case Instruction::CONST_WIDE_32: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_31i();
       // Get 32 bits of constant value, sign extended to 64 bits.
       int64_t value = instruction.VRegB_31i();
       value <<= 32;
@@ -2828,57 +2884,64 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     }
 
     case Instruction::CONST_WIDE: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_51l();
       HLongConstant* constant = graph_->GetLongConstant(instruction.VRegB_51l(), dex_pc);
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_WIDE_HIGH16: {
-      int32_t register_index = instruction.VRegA();
+      int32_t register_index = instruction.VRegA_21h();
       int64_t value = static_cast<int64_t>(instruction.VRegB_21h()) << 48;
       HLongConstant* constant = graph_->GetLongConstant(value, dex_pc);
       UpdateLocal(register_index, constant);
       break;
     }
 
-    // Note that the SSA building will refine the types.
-    case Instruction::MOVE:
-    case Instruction::MOVE_FROM16:
+    // Note that the SSA building will refine the types for moves.
+
+    case Instruction::MOVE: {
+      BuildMove<DataType::Type::kInt32>(instruction.VRegA_12x(), instruction.VRegB_12x());
+      break;
+    }
+
+    case Instruction::MOVE_FROM16: {
+      BuildMove<DataType::Type::kInt32>(instruction.VRegA_22x(), instruction.VRegB_22x());
+      break;
+    }
+
     case Instruction::MOVE_16: {
-      HInstruction* value = LoadLocal(instruction.VRegB(), DataType::Type::kInt32);
-      UpdateLocal(instruction.VRegA(), value);
+      BuildMove<DataType::Type::kInt32>(instruction.VRegA_32x(), instruction.VRegB_32x());
+      break;
+    }
+
+    case Instruction::MOVE_WIDE: {
+      BuildMove<DataType::Type::kInt64>(instruction.VRegA_12x(), instruction.VRegB_12x());
+      break;
+    }
+
+    case Instruction::MOVE_WIDE_FROM16: {
+      BuildMove<DataType::Type::kInt64>(instruction.VRegA_22x(), instruction.VRegB_22x());
       break;
     }
 
-    // Note that the SSA building will refine the types.
-    case Instruction::MOVE_WIDE:
-    case Instruction::MOVE_WIDE_FROM16:
     case Instruction::MOVE_WIDE_16: {
-      HInstruction* value = LoadLocal(instruction.VRegB(), DataType::Type::kInt64);
-      UpdateLocal(instruction.VRegA(), value);
+      BuildMove<DataType::Type::kInt64>(instruction.VRegA_32x(), instruction.VRegB_32x());
+      break;
+    }
+
+    case Instruction::MOVE_OBJECT: {
+      BuildMove<DataType::Type::kReference>(instruction.VRegA_12x(), instruction.VRegB_12x());
       break;
     }
 
-    case Instruction::MOVE_OBJECT:
-    case Instruction::MOVE_OBJECT_16:
     case Instruction::MOVE_OBJECT_FROM16: {
-      // The verifier has no notion of a null type, so a move-object of constant 0
-      // will lead to the same constant 0 in the destination register. To mimic
-      // this behavior, we just pretend we haven't seen a type change (int to reference)
-      // for the 0 constant and phis. We rely on our type propagation to eventually get the
-      // types correct.
-      uint32_t reg_number = instruction.VRegB();
-      HInstruction* value = (*current_locals_)[reg_number];
-      if (value->IsIntConstant()) {
-        DCHECK_EQ(value->AsIntConstant()->GetValue(), 0);
-      } else if (value->IsPhi()) {
-        DCHECK(value->GetType() == DataType::Type::kInt32 ||
-               value->GetType() == DataType::Type::kReference);
-      } else {
-        value = LoadLocal(reg_number, DataType::Type::kReference);
-      }
-      UpdateLocal(instruction.VRegA(), value);
+      BuildMove<DataType::Type::kReference>(instruction.VRegA_22x(), instruction.VRegB_22x());
+      break;
+    }
+
+    case Instruction::MOVE_OBJECT_16: {
+      BuildMove<DataType::Type::kReference>(instruction.VRegA_32x(), instruction.VRegB_32x());
       break;
     }
 
@@ -2901,6 +2964,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     IF_XX(HLessThanOrEqual, LE);
     IF_XX(HGreaterThan, GT);
     IF_XX(HGreaterThanOrEqual, GE);
+#undef IF_XX
 
     case Instruction::GOTO:
     case Instruction::GOTO_16:
@@ -2946,7 +3010,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     case Instruction::INVOKE_SUPER_RANGE:
     case Instruction::INVOKE_VIRTUAL_RANGE: {
       uint16_t method_idx = instruction.VRegB_3rc();
-      RangeInstructionOperands operands(instruction.VRegC(), instruction.VRegA_3rc());
+      RangeInstructionOperands operands(instruction.VRegC_3rc(), instruction.VRegA_3rc());
       if (!BuildInvoke(instruction, dex_pc, method_idx, operands)) {
         return false;
       }
@@ -3154,14 +3218,24 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     }
 
     case Instruction::DIV_INT: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegB(), instruction.VRegC(),
-                         dex_pc, DataType::Type::kInt32, false, true);
+      BuildCheckedDivRem(instruction.VRegA_23x(),
+                         instruction.VRegB_23x(),
+                         instruction.VRegC_23x(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ true);
       break;
     }
 
     case Instruction::DIV_LONG: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegB(), instruction.VRegC(),
-                         dex_pc, DataType::Type::kInt64, false, true);
+      BuildCheckedDivRem(instruction.VRegA_23x(),
+                         instruction.VRegB_23x(),
+                         instruction.VRegC_23x(),
+                         dex_pc,
+                         DataType::Type::kInt64,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ true);
       break;
     }
 
@@ -3176,14 +3250,24 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     }
 
     case Instruction::REM_INT: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegB(), instruction.VRegC(),
-                         dex_pc, DataType::Type::kInt32, false, false);
+      BuildCheckedDivRem(instruction.VRegA_23x(),
+                         instruction.VRegB_23x(),
+                         instruction.VRegC_23x(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ false);
       break;
     }
 
     case Instruction::REM_LONG: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegB(), instruction.VRegC(),
-                         dex_pc, DataType::Type::kInt64, false, false);
+      BuildCheckedDivRem(instruction.VRegA_23x(),
+                         instruction.VRegB_23x(),
+                         instruction.VRegC_23x(),
+                         dex_pc,
+                         DataType::Type::kInt64,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ false);
       break;
     }
 
@@ -3313,26 +3397,46 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     }
 
     case Instruction::DIV_INT_2ADDR: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegA(), instruction.VRegB(),
-                         dex_pc, DataType::Type::kInt32, false, true);
+      BuildCheckedDivRem(instruction.VRegA_12x(),
+                         instruction.VRegA_12x(),
+                         instruction.VRegB_12x(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ true);
       break;
     }
 
     case Instruction::DIV_LONG_2ADDR: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegA(), instruction.VRegB(),
-                         dex_pc, DataType::Type::kInt64, false, true);
+      BuildCheckedDivRem(instruction.VRegA_12x(),
+                         instruction.VRegA_12x(),
+                         instruction.VRegB_12x(),
+                         dex_pc,
+                         DataType::Type::kInt64,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ true);
       break;
     }
 
     case Instruction::REM_INT_2ADDR: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegA(), instruction.VRegB(),
-                         dex_pc, DataType::Type::kInt32, false, false);
+      BuildCheckedDivRem(instruction.VRegA_12x(),
+                         instruction.VRegA_12x(),
+                         instruction.VRegB_12x(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ false);
       break;
     }
 
     case Instruction::REM_LONG_2ADDR: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegA(), instruction.VRegB(),
-                         dex_pc, DataType::Type::kInt64, false, false);
+      BuildCheckedDivRem(instruction.VRegA_12x(),
+                         instruction.VRegA_12x(),
+                         instruction.VRegB_12x(),
+                         dex_pc,
+                         DataType::Type::kInt64,
+                         /* second_is_constant= */ false,
+                         /* is_div=*/ false);
       break;
     }
 
@@ -3476,17 +3580,47 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
       break;
     }
 
-    case Instruction::DIV_INT_LIT16:
+    case Instruction::DIV_INT_LIT16: {
+      BuildCheckedDivRem(instruction.VRegA_22s(),
+                         instruction.VRegB_22s(),
+                         instruction.VRegC_22s(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ true,
+                         /* is_div=*/ true);
+      break;
+    }
+
     case Instruction::DIV_INT_LIT8: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegB(), instruction.VRegC(),
-                         dex_pc, DataType::Type::kInt32, true, true);
+      BuildCheckedDivRem(instruction.VRegA_22b(),
+                         instruction.VRegB_22b(),
+                         instruction.VRegC_22b(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ true,
+                         /* is_div=*/ true);
+      break;
+    }
+
+    case Instruction::REM_INT_LIT16: {
+      BuildCheckedDivRem(instruction.VRegA_22s(),
+                         instruction.VRegB_22s(),
+                         instruction.VRegC_22s(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ true,
+                         /* is_div=*/ false);
       break;
     }
 
-    case Instruction::REM_INT_LIT16:
     case Instruction::REM_INT_LIT8: {
-      BuildCheckedDivRem(instruction.VRegA(), instruction.VRegB(), instruction.VRegC(),
-                         dex_pc, DataType::Type::kInt32, true, false);
+      BuildCheckedDivRem(instruction.VRegA_22b(),
+                         instruction.VRegB_22b(),
+                         instruction.VRegC_22b(),
+                         dex_pc,
+                         DataType::Type::kInt32,
+                         /* second_is_constant= */ true,
+                         /* is_div=*/ false);
       break;
     }
 
@@ -3510,7 +3644,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
           BuildNewInstance(dex::TypeIndex(instruction.VRegB_21c()), dex_pc);
       DCHECK(new_instance != nullptr);
 
-      UpdateLocal(instruction.VRegA(), current_block_->GetLastInstruction());
+      UpdateLocal(instruction.VRegA_21c(), current_block_->GetLastInstruction());
       BuildConstructorFenceForAllocation(new_instance);
       break;
     }
@@ -3552,7 +3686,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     case Instruction::MOVE_RESULT_WIDE:
     case Instruction::MOVE_RESULT_OBJECT: {
       DCHECK(latest_result_ != nullptr);
-      UpdateLocal(instruction.VRegA(), latest_result_);
+      UpdateLocal(instruction.VRegA_11x(), latest_result_);
       latest_result_ = nullptr;
       break;
     }
diff --git a/compiler/optimizing/instruction_builder.h b/compiler/optimizing/instruction_builder.h
index 5c165d7bf9..b3b5deae59 100644
--- a/compiler/optimizing/instruction_builder.h
+++ b/compiler/optimizing/instruction_builder.h
@@ -132,6 +132,9 @@ class HInstructionBuilder : public ValueObject {
                           bool second_is_lit,
                           bool is_div);
 
+  template <DataType::Type type>
+  void BuildMove(uint32_t dest_reg, uint32_t src_reg);
+
   void BuildReturn(const Instruction& instruction, DataType::Type type, uint32_t dex_pc);
 
   // Builds an instance field access node and returns whether the instruction is supported.
diff --git a/compiler/optimizing/instruction_simplifier.cc b/compiler/optimizing/instruction_simplifier.cc
index e972e4795e..a09a9f0ead 100644
--- a/compiler/optimizing/instruction_simplifier.cc
+++ b/compiler/optimizing/instruction_simplifier.cc
@@ -89,6 +89,7 @@ class InstructionSimplifierVisitor final : public HGraphDelegateVisitor {
   void VisitAbs(HAbs* instruction) override;
   void VisitAdd(HAdd* instruction) override;
   void VisitAnd(HAnd* instruction) override;
+  void VisitCompare(HCompare* instruction) override;
   void VisitCondition(HCondition* instruction) override;
   void VisitGreaterThan(HGreaterThan* condition) override;
   void VisitGreaterThanOrEqual(HGreaterThanOrEqual* condition) override;
@@ -126,10 +127,16 @@ class InstructionSimplifierVisitor final : public HGraphDelegateVisitor {
   void SimplifyReturnThis(HInvoke* invoke);
   void SimplifyAllocationIntrinsic(HInvoke* invoke);
   void SimplifyVarHandleIntrinsic(HInvoke* invoke);
+  void SimplifyArrayBaseOffset(HInvoke* invoke);
 
   bool CanUseKnownImageVarHandle(HInvoke* invoke);
   static bool CanEnsureNotNullAt(HInstruction* input, HInstruction* at);
 
+  // Returns an instruction with the opposite Boolean value from 'cond'.
+  // The instruction is inserted into the graph, either in the entry block
+  // (constant), or before the `cursor` (otherwise).
+  HInstruction* InsertOppositeCondition(HInstruction* cond, HInstruction* cursor);
+
   CodeGenerator* codegen_;
   OptimizingCompilerStats* stats_;
   bool simplification_occurred_ = false;
@@ -878,36 +885,50 @@ void InstructionSimplifierVisitor::VisitStaticFieldSet(HStaticFieldSet* instruct
   }
 }
 
-static HCondition* GetOppositeConditionSwapOps(ArenaAllocator* allocator, HInstruction* cond) {
-  HInstruction *lhs = cond->InputAt(0);
-  HInstruction *rhs = cond->InputAt(1);
-  switch (cond->GetKind()) {
-    case HInstruction::kEqual:
-      return new (allocator) HEqual(rhs, lhs);
-    case HInstruction::kNotEqual:
-      return new (allocator) HNotEqual(rhs, lhs);
-    case HInstruction::kLessThan:
-      return new (allocator) HGreaterThan(rhs, lhs);
-    case HInstruction::kLessThanOrEqual:
-      return new (allocator) HGreaterThanOrEqual(rhs, lhs);
-    case HInstruction::kGreaterThan:
-      return new (allocator) HLessThan(rhs, lhs);
-    case HInstruction::kGreaterThanOrEqual:
-      return new (allocator) HLessThanOrEqual(rhs, lhs);
-    case HInstruction::kBelow:
-      return new (allocator) HAbove(rhs, lhs);
-    case HInstruction::kBelowOrEqual:
-      return new (allocator) HAboveOrEqual(rhs, lhs);
-    case HInstruction::kAbove:
-      return new (allocator) HBelow(rhs, lhs);
-    case HInstruction::kAboveOrEqual:
-      return new (allocator) HBelowOrEqual(rhs, lhs);
+static IfCondition GetOppositeConditionForOperandSwap(IfCondition cond) {
+  switch (cond) {
+    case kCondEQ: return kCondEQ;
+    case kCondNE: return kCondNE;
+    case kCondLT: return kCondGT;
+    case kCondLE: return kCondGE;
+    case kCondGT: return kCondLT;
+    case kCondGE: return kCondLE;
+    case kCondB: return kCondA;
+    case kCondBE: return kCondAE;
+    case kCondA: return kCondB;
+    case kCondAE: return kCondBE;
     default:
-      LOG(FATAL) << "Unknown ConditionType " << cond->GetKind();
+      LOG(FATAL) << "Unknown ConditionType " << cond;
       UNREACHABLE();
   }
 }
 
+HInstruction* InstructionSimplifierVisitor::InsertOppositeCondition(HInstruction* cond,
+                                                                    HInstruction* cursor) {
+  if (cond->IsCondition() &&
+      !DataType::IsFloatingPointType(cond->InputAt(0)->GetType())) {
+    // Can't reverse floating point conditions. We have to use `HBooleanNot` in that case.
+    HInstruction* lhs = cond->InputAt(0);
+    HInstruction* rhs = cond->InputAt(1);
+    HInstruction* replacement =
+        GetGraph()->CreateCondition(cond->AsCondition()->GetOppositeCondition(), lhs, rhs);
+    cursor->GetBlock()->InsertInstructionBefore(replacement, cursor);
+    return replacement;
+  } else if (cond->IsIntConstant()) {
+    HIntConstant* int_const = cond->AsIntConstant();
+    if (int_const->IsFalse()) {
+      return GetGraph()->GetIntConstant(1);
+    } else {
+      DCHECK(int_const->IsTrue()) << int_const->GetValue();
+      return GetGraph()->GetIntConstant(0);
+    }
+  } else {
+    HInstruction* replacement = new (GetGraph()->GetAllocator()) HBooleanNot(cond);
+    cursor->GetBlock()->InsertInstructionBefore(replacement, cursor);
+    return replacement;
+  }
+}
+
 void InstructionSimplifierVisitor::VisitEqual(HEqual* equal) {
   HInstruction* input_const = equal->GetConstantRight();
   if (input_const != nullptr) {
@@ -923,7 +944,7 @@ void InstructionSimplifierVisitor::VisitEqual(HEqual* equal) {
         RecordSimplification();
       } else if (input_const->AsIntConstant()->IsFalse()) {
         // Replace (bool_value == false) with !bool_value
-        equal->ReplaceWith(GetGraph()->InsertOppositeCondition(input_value, equal));
+        equal->ReplaceWith(InsertOppositeCondition(input_value, equal));
         block->RemoveInstruction(equal);
         RecordSimplification();
       } else {
@@ -950,7 +971,7 @@ void InstructionSimplifierVisitor::VisitNotEqual(HNotEqual* not_equal) {
       // be any constant.
       if (input_const->AsIntConstant()->IsTrue()) {
         // Replace (bool_value != true) with !bool_value
-        not_equal->ReplaceWith(GetGraph()->InsertOppositeCondition(input_value, not_equal));
+        not_equal->ReplaceWith(InsertOppositeCondition(input_value, not_equal));
         block->RemoveInstruction(not_equal);
         RecordSimplification();
       } else if (input_const->AsIntConstant()->IsFalse()) {
@@ -992,7 +1013,7 @@ void InstructionSimplifierVisitor::VisitBooleanNot(HBooleanNot* bool_not) {
              // NaNs forces the compares to be done as written by the user.
              !DataType::IsFloatingPointType(input->InputAt(0)->GetType())) {
     // Replace condition with its opposite.
-    replace_with = GetGraph()->InsertOppositeCondition(input->AsCondition(), bool_not);
+    replace_with = InsertOppositeCondition(input->AsCondition(), bool_not);
   }
 
   if (replace_with != nullptr) {
@@ -1108,7 +1129,7 @@ void InstructionSimplifierVisitor::VisitSelect(HSelect* select) {
       replace_with = condition;
     } else if (true_value->AsIntConstant()->IsFalse() && false_value->AsIntConstant()->IsTrue()) {
       // Replace (cond ? false : true) with (!cond).
-      replace_with = GetGraph()->InsertOppositeCondition(condition, select);
+      replace_with = InsertOppositeCondition(condition, select);
     }
   } else if (condition->IsCondition()) {
     IfCondition cmp = condition->AsCondition()->GetCondition();
@@ -1794,6 +1815,56 @@ static bool RecognizeAndSimplifyClassCheck(HCondition* condition) {
   }
 }
 
+static HInstruction* CreateUnsignedConditionReplacement(ArenaAllocator* allocator,
+                                                        HCondition* cond,
+                                                        HCompare* compare) {
+  DCHECK(cond->InputAt(1)->IsIntConstant());
+  DCHECK_EQ(cond->InputAt(1)->AsIntConstant()->GetValue(), 0);
+  DCHECK(cond->InputAt(0) == compare);
+
+  HBasicBlock* block = cond->GetBlock();
+  HInstruction* lhs = compare->InputAt(0);
+  HInstruction* rhs = compare->InputAt(1);
+
+  switch (cond->GetKind()) {
+    case HInstruction::kLessThan:
+      return new (allocator) HBelow(lhs, rhs, cond->GetDexPc());
+    case HInstruction::kLessThanOrEqual:
+      return new (allocator) HBelowOrEqual(lhs, rhs, cond->GetDexPc());
+    case HInstruction::kGreaterThan:
+      return new (allocator) HAbove(lhs, rhs, cond->GetDexPc());
+    case HInstruction::kGreaterThanOrEqual:
+      return new (allocator) HAboveOrEqual(lhs, rhs, cond->GetDexPc());
+    case HInstruction::kBelow:
+      // Below(Compare(x, y), 0) always False since
+      //   unsigned(-1) < 0 -> False
+      //   0 < 0 -> False
+      //   1 < 0 -> False
+      return block->GetGraph()->GetConstant(DataType::Type::kBool, 0, cond->GetDexPc());
+    case HInstruction::kBelowOrEqual:
+      // BelowOrEqual(Compare(x, y), 0) transforms into Equal(x, y)
+      //    unsigned(-1) <= 0 -> False
+      //    0 <= 0 -> True
+      //    1 <= 0 -> False
+      return new (allocator) HEqual(lhs, rhs, cond->GetDexPc());
+    case HInstruction::kAbove:
+      // Above(Compare(x, y), 0) transforms into NotEqual(x, y)
+      //    unsigned(-1) > 0 -> True
+      //    0 > 0 -> False
+      //    1 > 0 -> True
+      return new (allocator) HNotEqual(lhs, rhs, cond->GetDexPc());
+    case HInstruction::kAboveOrEqual:
+      // AboveOrEqual(Compare(x, y), 0) always True since
+      //   unsigned(-1) >= 0 -> True
+      //   0 >= 0 -> True
+      //   1 >= 0 -> True
+      return block->GetGraph()->GetConstant(DataType::Type::kBool, 1, cond->GetDexPc());
+    default:
+      LOG(FATAL) << "Unknown ConditionType " << cond->GetKind();
+      UNREACHABLE();
+  }
+}
+
 void InstructionSimplifierVisitor::VisitCondition(HCondition* condition) {
   if (condition->IsEqual() || condition->IsNotEqual()) {
     if (RecognizeAndSimplifyClassCheck(condition)) {
@@ -1803,26 +1874,23 @@ void InstructionSimplifierVisitor::VisitCondition(HCondition* condition) {
 
   // Reverse condition if left is constant. Our code generators prefer constant
   // on the right hand side.
-  if (condition->GetLeft()->IsConstant() && !condition->GetRight()->IsConstant()) {
-    HBasicBlock* block = condition->GetBlock();
-    HCondition* replacement =
-        GetOppositeConditionSwapOps(block->GetGraph()->GetAllocator(), condition);
-    // If it is a fp we must set the opposite bias.
-    if (replacement != nullptr) {
-      if (condition->IsLtBias()) {
-        replacement->SetBias(ComparisonBias::kGtBias);
-      } else if (condition->IsGtBias()) {
-        replacement->SetBias(ComparisonBias::kLtBias);
-      }
-      block->ReplaceAndRemoveInstructionWith(condition, replacement);
-      RecordSimplification();
-
-      condition = replacement;
-    }
-  }
-
+  HBasicBlock* block = condition->GetBlock();
   HInstruction* left = condition->GetLeft();
   HInstruction* right = condition->GetRight();
+  if (left->IsConstant() && !right->IsConstant()) {
+    IfCondition new_cond = GetOppositeConditionForOperandSwap(condition->GetCondition());
+    HCondition* replacement = GetGraph()->CreateCondition(new_cond, right, left);
+    block->ReplaceAndRemoveInstructionWith(condition, replacement);
+    // If it is a FP condition, we must set the opposite bias.
+    if (condition->IsLtBias()) {
+      replacement->SetBias(ComparisonBias::kGtBias);
+    } else if (condition->IsGtBias()) {
+      replacement->SetBias(ComparisonBias::kLtBias);
+    }
+    RecordSimplification();
+    condition = replacement;
+    std::swap(left, right);
+  }
 
   // Try to fold an HCompare into this HCondition.
 
@@ -1856,11 +1924,26 @@ void InstructionSimplifierVisitor::VisitCondition(HCondition* condition) {
   left->RemoveEnvironmentUsers();
 
   // We have decided to fold the HCompare into the HCondition. Transfer the information.
-  condition->SetBias(left->AsCompare()->GetBias());
+  if (DataType::IsUnsignedType(left->AsCompare()->GetComparisonType()) &&
+      !condition->IsEqual() &&
+      !condition->IsNotEqual()) {
+    DCHECK_EQ(condition->GetBias(), ComparisonBias::kNoBias);
+    HInstruction* replacement = CreateUnsignedConditionReplacement(
+        block->GetGraph()->GetAllocator(), condition, left->AsCompare());
+
+    if (replacement->IsConstant()) {
+      condition->ReplaceWith(replacement);
+      block->RemoveInstruction(condition);
+    } else {
+      block->ReplaceAndRemoveInstructionWith(condition, replacement);
+    }
+  } else {
+    condition->SetBias(left->AsCompare()->GetBias());
 
-  // Replace the operands of the HCondition.
-  condition->ReplaceInput(left->InputAt(0), 0);
-  condition->ReplaceInput(left->InputAt(1), 1);
+    // Replace the operands of the HCondition.
+    condition->ReplaceInput(left->InputAt(0), 0);
+    condition->ReplaceInput(left->InputAt(1), 1);
+  }
 
   // Remove the HCompare.
   left->GetBlock()->RemoveInstruction(left);
@@ -1868,6 +1951,130 @@ void InstructionSimplifierVisitor::VisitCondition(HCondition* condition) {
   RecordSimplification();
 }
 
+static HInstruction* CheckSignedToUnsignedCompareConversion(HInstruction* operand,
+                                                            HCompare* compare) {
+  // Check if operand looks like `ADD op, MIN_INTEGRAL`
+  if (operand->IsConstant()) {
+    // CONSTANT #x -> CONSTANT #(x - MIN_INTEGRAL)
+    HConstant* constant = operand->AsConstant();
+    if (constant->IsIntConstant()) {
+      HIntConstant* int_constant = constant->AsIntConstant();
+      int32_t old_value = int_constant->GetValue();
+      int32_t new_value = old_value - std::numeric_limits<int32_t>::min();
+      return operand->GetBlock()->GetGraph()->GetIntConstant(new_value, constant->GetDexPc());
+    } else if (constant->IsLongConstant()) {
+      HLongConstant* long_constant = constant->AsLongConstant();
+      int64_t old_value = long_constant->GetValue();
+      int64_t new_value = old_value - std::numeric_limits<int64_t>::min();
+      return operand->GetBlock()->GetGraph()->GetLongConstant(new_value, constant->GetDexPc());
+    } else {
+      return nullptr;
+    }
+  }
+
+  if (!operand->IsAdd() && !operand->IsXor()) {
+    return nullptr;
+  }
+
+  if (!operand->GetEnvUses().empty()) {
+    // There is a reference to the compare result in an environment. Do we really need it?
+    if (operand->GetBlock()->GetGraph()->IsDebuggable()) {
+      return nullptr;
+    }
+
+    // We have to ensure that there are no deopt points in the sequence.
+    if (operand->HasAnyEnvironmentUseBefore(compare)) {
+      return nullptr;
+    }
+  }
+
+  HBinaryOperation* additive_operand = operand->AsBinaryOperation();
+
+  HInstruction* left = additive_operand->GetLeft();
+  HInstruction* right = additive_operand->GetRight();
+
+  HConstant* constant = nullptr;
+  HInstruction* value = nullptr;
+
+  if (left->IsConstant() && !right->IsConstant()) {
+    constant = left->AsConstant();
+    value = right;
+  } else if (!left->IsConstant() && right->IsConstant()) {
+    value = left;
+    constant = right->AsConstant();
+  } else {
+    return nullptr;
+  }
+
+  if (constant->IsIntConstant()) {
+    HIntConstant* int_constant = constant->AsIntConstant();
+    if (int_constant->GetValue() != std::numeric_limits<int32_t>::min()) {
+      return nullptr;
+    }
+  } else if (constant->IsLongConstant()) {
+    HLongConstant* long_constant = constant->AsLongConstant();
+    if (long_constant->GetValue() != std::numeric_limits<int64_t>::min()) {
+      return nullptr;
+    }
+  } else {
+    return nullptr;
+  }
+
+  return value;
+}
+
+static DataType::Type GetOpositeSignType(DataType::Type type) {
+  return DataType::IsUnsignedType(type) ? DataType::ToSigned(type) : DataType::ToUnsigned(type);
+}
+
+void InstructionSimplifierVisitor::VisitCompare(HCompare* compare) {
+  // Transform signed compare into unsigned if possible
+  // Replace code looking like
+  //    ADD normalizedLeft, left, MIN_INTEGRAL
+  //    ADD normalizedRight, right, MIN_INTEGRAL
+  //    COMPARE normalizedLeft, normalizedRight, sign
+  // with
+  //    COMPARE left, right, !sign
+
+  if (!DataType::IsIntegralType(compare->GetComparisonType())) {
+    return;
+  }
+
+  HInstruction* compare_left = compare->GetLeft();
+  HInstruction* compare_right = compare->GetRight();
+
+  if (compare_left->IsConstant() && compare_right->IsConstant()) {
+    // Do not simplify, let it be folded.
+    return;
+  }
+
+  HInstruction* left = CheckSignedToUnsignedCompareConversion(compare_left, compare);
+  if (left == nullptr) {
+    return;
+  }
+
+  HInstruction* right = CheckSignedToUnsignedCompareConversion(compare_right, compare);
+  if (right == nullptr) {
+    return;
+  }
+
+  compare->SetComparisonType(GetOpositeSignType(compare->GetComparisonType()));
+  compare->ReplaceInput(left, 0);
+  compare->ReplaceInput(right, 1);
+
+  RecordSimplification();
+
+  if (compare_left->GetUses().empty()) {
+    compare_left->RemoveEnvironmentUsers();
+    compare_left->GetBlock()->RemoveInstruction(compare_left);
+  }
+
+  if (compare_right->GetUses().empty()) {
+    compare_right->RemoveEnvironmentUsers();
+    compare_right->GetBlock()->RemoveInstruction(compare_right);
+  }
+}
+
 // Return whether x / divisor == x * (1.0f / divisor), for every float x.
 static constexpr bool CanDivideByReciprocalMultiplyFloat(int32_t divisor) {
   // True, if the most significant bits of divisor are 0.
@@ -3233,11 +3440,36 @@ void InstructionSimplifierVisitor::VisitInvoke(HInvoke* instruction) {
     case Intrinsics::kVarHandleWeakCompareAndSetRelease:
       SimplifyVarHandleIntrinsic(instruction);
       break;
+    case Intrinsics::kUnsafeArrayBaseOffset:
+    case Intrinsics::kJdkUnsafeArrayBaseOffset:
+      SimplifyArrayBaseOffset(instruction);
+      break;
     default:
       break;
   }
 }
 
+void InstructionSimplifierVisitor::SimplifyArrayBaseOffset(HInvoke* invoke) {
+  if (!invoke->InputAt(1)->IsLoadClass()) {
+    return;
+  }
+  HLoadClass* load_class = invoke->InputAt(1)->AsLoadClass();
+  ReferenceTypeInfo info = load_class->GetLoadedClassRTI();
+  if (!info.IsValid()) {
+    return;
+  }
+  ScopedObjectAccess soa(Thread::Current());
+  ObjPtr<mirror::Class> cls = info.GetTypeHandle()->GetComponentType();
+  if (cls == nullptr) {
+    return;
+  }
+  uint32_t base_offset =
+      mirror::Array::DataOffset(Primitive::ComponentSize(cls->GetPrimitiveType())).Int32Value();
+  invoke->ReplaceWith(GetGraph()->GetIntConstant(base_offset));
+  RecordSimplification();
+  return;
+}
+
 void InstructionSimplifierVisitor::VisitDeoptimize(HDeoptimize* deoptimize) {
   HInstruction* cond = deoptimize->InputAt(0);
   if (cond->IsConstant()) {
diff --git a/compiler/optimizing/instruction_simplifier_arm.cc b/compiler/optimizing/instruction_simplifier_arm.cc
index a050f86363..7dccc036b5 100644
--- a/compiler/optimizing/instruction_simplifier_arm.cc
+++ b/compiler/optimizing/instruction_simplifier_arm.cc
@@ -74,6 +74,7 @@ class InstructionSimplifierArmVisitor final : public HGraphVisitor {
   void VisitArraySet(HArraySet* instruction) override;
   void VisitMul(HMul* instruction) override;
   void VisitOr(HOr* instruction) override;
+  void VisitRol(HRol* instruction) override;
   void VisitShl(HShl* instruction) override;
   void VisitShr(HShr* instruction) override;
   void VisitSub(HSub* instruction) override;
@@ -263,6 +264,11 @@ void InstructionSimplifierArmVisitor::VisitOr(HOr* instruction) {
   }
 }
 
+void InstructionSimplifierArmVisitor::VisitRol(HRol* instruction) {
+  UnfoldRotateLeft(instruction);
+  RecordSimplification();
+}
+
 void InstructionSimplifierArmVisitor::VisitShl(HShl* instruction) {
   if (instruction->InputAt(1)->IsConstant()) {
     TryMergeIntoUsersShifterOperand(instruction);
diff --git a/compiler/optimizing/instruction_simplifier_arm64.cc b/compiler/optimizing/instruction_simplifier_arm64.cc
index f57448d70f..8dd64e59ee 100644
--- a/compiler/optimizing/instruction_simplifier_arm64.cc
+++ b/compiler/optimizing/instruction_simplifier_arm64.cc
@@ -77,6 +77,7 @@ class InstructionSimplifierArm64Visitor final : public HGraphVisitor {
   void VisitArraySet(HArraySet* instruction) override;
   void VisitMul(HMul* instruction) override;
   void VisitOr(HOr* instruction) override;
+  void VisitRol(HRol* instruction) override;
   void VisitShl(HShl* instruction) override;
   void VisitShr(HShr* instruction) override;
   void VisitSub(HSub* instruction) override;
@@ -234,6 +235,11 @@ void InstructionSimplifierArm64Visitor::VisitOr(HOr* instruction) {
   }
 }
 
+void InstructionSimplifierArm64Visitor::VisitRol(HRol* rol) {
+  UnfoldRotateLeft(rol);
+  RecordSimplification();
+}
+
 void InstructionSimplifierArm64Visitor::VisitShl(HShl* instruction) {
   if (instruction->InputAt(1)->IsConstant()) {
     TryMergeIntoUsersShifterOperand(instruction);
diff --git a/compiler/optimizing/instruction_simplifier_riscv64.cc b/compiler/optimizing/instruction_simplifier_riscv64.cc
index 8f47f66d8b..6dc269f8c5 100644
--- a/compiler/optimizing/instruction_simplifier_riscv64.cc
+++ b/compiler/optimizing/instruction_simplifier_riscv64.cc
@@ -41,51 +41,60 @@ class InstructionSimplifierRiscv64Visitor final : public HGraphVisitor {
     }
   }
 
-  bool TryReplaceShiftAddWithOneInstruction(HShl* shl, HAdd* add) {
+  // Replace Add which has Shl with distance of 1 or 2 or 3 with Riscv64ShiftAdd
+  bool TryReplaceAddsWithShiftAdds(HShl* shl) {
     // There is no reason to replace Int32 Shl+Add with ShiftAdd because of
     // additional sign-extension required.
     if (shl->GetType() != DataType::Type::kInt64) {
       return false;
     }
 
-    if (!shl->GetRight()->IsIntConstant()) {
+    if (!shl->GetRight()->IsConstant()) {
       return false;
     }
 
+    // The bytecode does not permit the shift distance to come from a wide variable
+    DCHECK(shl->GetRight()->IsIntConstant());
+
     const int32_t distance = shl->GetRight()->AsIntConstant()->GetValue();
-    if (distance != 1 && distance != 2 && distance != 3) {
+    if (distance < 1 || distance > 3) {
       return false;
     }
 
-    if (!shl->HasOnlyOneNonEnvironmentUse()) {
-      return false;
-    }
+    bool replaced = false;
 
-    auto* const add_other_input = add->GetLeft() == shl ? add->GetRight() : add->GetLeft();
-    auto* const shift_add = new (GetGraph()->GetAllocator())
-        HRiscv64ShiftAdd(shl->GetLeft(), add_other_input, distance);
+    for (const HUseListNode<HInstruction*>& use : shl->GetUses()) {
+      HInstruction* user = use.GetUser();
 
-    DCHECK_EQ(add->GetType(), DataType::Type::kInt64)
-        << "Riscv64ShiftAdd replacement should have the same 64 bit type";
-    add->GetBlock()->ReplaceAndRemoveInstructionWith(add, shift_add);
-    shl->GetBlock()->RemoveInstruction(shl);
+      if (!user->IsAdd()) {
+        continue;
+      }
+      HAdd* add = user->AsAdd();
+      HInstruction* left = add->GetLeft();
+      HInstruction* right = add->GetRight();
+      DCHECK_EQ(add->GetType(), DataType::Type::kInt64)
+          << "Replaceable Add must be the same 64 bit type as the input";
+
+      // If the HAdd to replace has both inputs the same HShl<1|2|3>, then
+      // don't perform the optimization. The processor will not be able to execute
+      // these shifts parallel which is the purpose of the replace below.
+      if (left == right) {
+        continue;
+      }
 
-    return true;
-  }
+      HInstruction* add_other_input = left == shl ? right : left;
+      HRiscv64ShiftAdd* shift_add = new (GetGraph()->GetAllocator())
+          HRiscv64ShiftAdd(shl->GetLeft(), add_other_input, distance);
 
-  // Replace code looking like
-  //    SHL tmp, a, 1 or 2 or 3
-  //    ADD dst, tmp, b
-  // with
-  //    Riscv64ShiftAdd dst, a, b
-  void VisitAdd(HAdd* add) override {
-    auto* const left = add->GetLeft();
-    auto* const right = add->GetRight();
-    if (left->IsShl() && TryReplaceShiftAddWithOneInstruction(left->AsShl(), add)) {
-      return;
-    } else if (right->IsShl() && TryReplaceShiftAddWithOneInstruction(right->AsShl(), add)) {
-      return;
+      add->GetBlock()->ReplaceAndRemoveInstructionWith(add, shift_add);
+      replaced = true;
     }
+
+    if (!shl->HasUses()) {
+      shl->GetBlock()->RemoveInstruction(shl);
+    }
+
+    return replaced;
   }
 
   void VisitAnd(HAnd* inst) override {
@@ -100,6 +109,17 @@ class InstructionSimplifierRiscv64Visitor final : public HGraphVisitor {
     }
   }
 
+  // Replace code looking like
+  //    SHL tmp, a, 1 or 2 or 3
+  //    ADD dst, tmp, b
+  // with
+  //    Riscv64ShiftAdd dst, a, b
+  void VisitShl(HShl* inst) override {
+    if (TryReplaceAddsWithShiftAdds(inst)) {
+      RecordSimplification();
+    }
+  }
+
   void VisitSub(HSub* inst) override {
     if (TryMergeWithAnd(inst)) {
       RecordSimplification();
diff --git a/compiler/optimizing/instruction_simplifier_riscv64_test.cc b/compiler/optimizing/instruction_simplifier_riscv64_test.cc
new file mode 100644
index 0000000000..15c81c8957
--- /dev/null
+++ b/compiler/optimizing/instruction_simplifier_riscv64_test.cc
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "instruction_simplifier_riscv64.h"
+
+#include <gtest/gtest.h>
+
+#include "base/globals.h"
+#include "optimizing_unit_test.h"
+
+namespace art HIDDEN {
+namespace riscv64 {
+
+class InstructionSimplifierRiscv64Test : public OptimizingUnitTest {};
+
+TEST_F(InstructionSimplifierRiscv64Test, SimplifyShiftAdd) {
+  HGraph* graph = CreateGraph();
+  HBasicBlock* entry = AddNewBlock();
+  graph->SetEntryBlock(entry);
+  graph->BuildDominatorTree();
+
+  HInstruction* param0 = MakeParam(DataType::Type::kInt64);
+  HInstruction* param1 = MakeParam(DataType::Type::kInt64);
+  HInstruction* c0 = graph->GetIntConstant(0);
+  HInstruction* c1 = graph->GetIntConstant(1);
+  HInstruction* c2 = graph->GetIntConstant(2);
+  HInstruction* c3 = graph->GetIntConstant(3);
+  HInstruction* c4 = graph->GetIntConstant(4);
+
+  HInstruction* shl0 = MakeBinOp<HShl>(entry, DataType::Type::kInt64, param0, c0);
+  HInstruction* add_shl0 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param1, shl0);
+  HInstruction* shl1 = MakeBinOp<HShl>(entry, DataType::Type::kInt64, param0, c1);
+  HInstruction* add_shl1 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param1, shl1);
+  HInstruction* shl2 = MakeBinOp<HShl>(entry, DataType::Type::kInt64, param0, c2);
+  HInstruction* add_shl2 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param1, shl2);
+  HInstruction* shl3 = MakeBinOp<HShl>(entry, DataType::Type::kInt64, param0, c3);
+  HInstruction* add_shl3 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param1, shl3);
+  HInstruction* shl4 = MakeBinOp<HShl>(entry, DataType::Type::kInt64, param0, c4);
+  HInstruction* add_shl4 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param1, shl4);
+
+  InstructionSimplifierRiscv64 simplifier(graph, /*stats=*/ nullptr);
+  simplifier.Run();
+
+  EXPECT_FALSE(add_shl0->GetBlock() == nullptr);
+  EXPECT_TRUE(add_shl1->GetBlock() == nullptr);
+  EXPECT_TRUE(add_shl2->GetBlock() == nullptr);
+  EXPECT_TRUE(add_shl3->GetBlock() == nullptr);
+  EXPECT_FALSE(add_shl4->GetBlock() == nullptr);
+}
+
+TEST_F(InstructionSimplifierRiscv64Test, SimplifyShiftAddReusedShift) {
+  HGraph* graph = CreateGraph();
+  HBasicBlock* entry = AddNewBlock();
+  graph->SetEntryBlock(entry);
+  graph->BuildDominatorTree();
+
+  HInstruction* param0 = MakeParam(DataType::Type::kInt64);
+  HInstruction* param1 = MakeParam(DataType::Type::kInt64);
+  HInstruction* param2 = MakeParam(DataType::Type::kInt64);
+  HInstruction* param3 = MakeParam(DataType::Type::kInt64);
+  HInstruction* c1 = graph->GetIntConstant(1);
+
+  HInstruction* shl1 = MakeBinOp<HShl>(entry, DataType::Type::kInt64, param0, c1);
+  HInstruction* add1 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param1, shl1);
+  HInstruction* add2 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param2, shl1);
+  HInstruction* add3 = MakeBinOp<HAdd>(entry, DataType::Type::kInt64, param3, shl1);
+
+  InstructionSimplifierRiscv64 simplifier(graph, /*stats=*/ nullptr);
+  simplifier.Run();
+
+  EXPECT_TRUE(shl1->GetBlock() == nullptr);
+  EXPECT_TRUE(add1->GetBlock() == nullptr);
+  EXPECT_TRUE(add2->GetBlock() == nullptr);
+  EXPECT_TRUE(add3->GetBlock() == nullptr);
+}
+
+}  // namespace riscv64
+}  // namespace art
diff --git a/compiler/optimizing/instruction_simplifier_shared.cc b/compiler/optimizing/instruction_simplifier_shared.cc
index b7d76da548..7f575c0348 100644
--- a/compiler/optimizing/instruction_simplifier_shared.cc
+++ b/compiler/optimizing/instruction_simplifier_shared.cc
@@ -316,4 +316,23 @@ bool TryReplaceSubSubWithSubAdd(HSub* last_sub) {
   }
 }
 
+void UnfoldRotateLeft(HRol* rol) {
+  HBasicBlock* block = rol->GetBlock();
+  HGraph* graph = block->GetGraph();
+  ArenaAllocator* allocator = graph->GetAllocator();
+  HRor* ror;
+
+  if (rol->GetRight()->IsConstant()) {
+    int32_t value = rol->GetRight()->AsIntConstant()->GetValue();
+    HIntConstant* negated = graph->GetIntConstant(-value);
+    ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), negated);
+  } else {
+    HNeg* neg = new (allocator) HNeg(DataType::Type::kInt32, rol->GetRight());
+    block->InsertInstructionBefore(neg, rol);
+    ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), neg);
+  }
+
+  block->ReplaceAndRemoveInstructionWith(rol, ror);
+}
+
 }  // namespace art
diff --git a/compiler/optimizing/instruction_simplifier_shared.h b/compiler/optimizing/instruction_simplifier_shared.h
index de70ec5a8a..8e61109b0e 100644
--- a/compiler/optimizing/instruction_simplifier_shared.h
+++ b/compiler/optimizing/instruction_simplifier_shared.h
@@ -77,6 +77,14 @@ bool TryExtractVecArrayAccessAddress(HVecMemoryOperation* access, HInstruction*
 //   Add(c, Sub(b, a))
 bool TryReplaceSubSubWithSubAdd(HSub* last_sub);
 
+// ARM does not contain instruction ROL so replace
+//   ROL dest, a, distance
+// with
+//   NEG neg, distance
+//   ROR dest, a, neg
+// before GVN to give it a chance to deduplicate the instructions, if it's able.
+void UnfoldRotateLeft(HRol* rol);
+
 }  // namespace art
 
 #endif  // ART_COMPILER_OPTIMIZING_INSTRUCTION_SIMPLIFIER_SHARED_H_
diff --git a/compiler/optimizing/instruction_simplifier_test.cc b/compiler/optimizing/instruction_simplifier_test.cc
index 9f47995cf5..a2e3882c19 100644
--- a/compiler/optimizing/instruction_simplifier_test.cc
+++ b/compiler/optimizing/instruction_simplifier_test.cc
@@ -52,16 +52,16 @@ class InstructionSimplifierTestBase : public SuperClass, public OptimizingUnitTe
     gLogVerbosity.compiler = false;
   }
 
-  void PerformSimplification(const AdjacencyListGraph& blks) {
+  void PerformSimplification() {
     if (kDebugSimplifierTests) {
-      LOG(INFO) << "Pre simplification " << blks;
+      graph_->Dump(LOG_STREAM(INFO) << "Pre simplification ", /* codegen_= */ nullptr);
     }
     graph_->ClearDominanceInformation();
     graph_->BuildDominatorTree();
     InstructionSimplifier simp(graph_, /*codegen=*/nullptr);
     simp.Run();
     if (kDebugSimplifierTests) {
-      LOG(INFO) << "Post simplify " << blks;
+      graph_->Dump(LOG_STREAM(INFO) << "Post simplify ", /* codegen_= */ nullptr);
     }
   }
 };
@@ -103,18 +103,21 @@ class InstanceOfInstructionSimplifierTestGroup
     }
   }
 
-  std::pair<HLoadClass*, HLoadClass*> GetLoadClasses(VariableSizedHandleScope* vshs) {
+  std::pair<HLoadClass*, HLoadClass*> GetLoadClasses(HBasicBlock* block,
+                                                     VariableSizedHandleScope* vshs)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
     InstanceOfKind kind = GetParam();
-    ScopedObjectAccess soa(Thread::Current());
     // New inst always needs to have a valid rti since we dcheck that.
-    HLoadClass* new_inst = MakeClassLoad(
-        /* ti= */ std::nullopt, vshs->NewHandle<mirror::Class>(GetClassRoot<mirror::ClassExt>()));
+    HLoadClass* new_inst = MakeLoadClass(
+        block,
+        /* ti= */ std::nullopt,
+        vshs->NewHandle<mirror::Class>(GetClassRoot<mirror::ClassExt>()));
     new_inst->SetValidLoadedClassRTI();
     if (kind == InstanceOfKind::kSelf) {
       return {new_inst, new_inst};
     }
     if (kind == InstanceOfKind::kUnrelatedUnloaded) {
-      HLoadClass* target_class = MakeClassLoad();
+      HLoadClass* target_class = MakeLoadClass(block);
       EXPECT_FALSE(target_class->GetLoadedClassRTI().IsValid());
       return {new_inst, target_class};
     }
@@ -122,7 +125,8 @@ class InstanceOfInstructionSimplifierTestGroup
     // For simplicity we use class-roots as the types. The new-inst will always
     // be a ClassExt, unrelated-loaded will always be Throwable and super will
     // always be Object
-    HLoadClass* target_class = MakeClassLoad(
+    HLoadClass* target_class = MakeLoadClass(
+        block,
         /* ti= */ std::nullopt,
         vshs->NewHandle<mirror::Class>(kind == InstanceOfKind::kSupertype ?
                                            GetClassRoot<mirror::Object>() :
@@ -146,27 +150,14 @@ class InstanceOfInstructionSimplifierTestGroup
 TEST_P(InstanceOfInstructionSimplifierTestGroup, ExactClassInstanceOfOther) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  InitGraph(/*handles=*/&vshs);
-
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry",
-                                                 "exit",
-                                                 {{"entry", "left"},
-                                                  {"entry", "right"},
-                                                  {"left", "breturn"},
-                                                  {"right", "breturn"},
-                                                  {"breturn", "exit"}}));
-#define GET_BLOCK(name) HBasicBlock* name = blks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(exit);
-  GET_BLOCK(breturn);
-  GET_BLOCK(left);
-  GET_BLOCK(right);
-#undef GET_BLOCK
+  HBasicBlock* breturn = InitEntryMainExitGraph(/*handles=*/&vshs);
+  auto [if_block, left, right] = CreateDiamondPattern(breturn);
   EnsurePredecessorOrder(breturn, {left, right});
+
   HInstruction* test_res = graph_->GetIntConstant(GetConstantResult() ? 1 : 0);
 
-  auto [new_inst_klass, target_klass] = GetLoadClasses(&vshs);
-  HInstruction* new_inst = MakeNewInstance(new_inst_klass);
+  auto [new_inst_klass, target_klass] = GetLoadClasses(if_block, &vshs);
+  HInstruction* new_inst = MakeNewInstance(if_block, new_inst_klass);
   new_inst->SetReferenceTypeInfo(
       ReferenceTypeInfo::Create(new_inst_klass->GetClass(), /*is_exact=*/true));
   HInstanceOf* instance_of = new (GetAllocator()) HInstanceOf(new_inst,
@@ -180,34 +171,14 @@ TEST_P(InstanceOfInstructionSimplifierTestGroup, ExactClassInstanceOfOther) {
   if (target_klass->GetLoadedClassRTI().IsValid()) {
     instance_of->SetValidTargetClassRTI();
   }
-  HInstruction* if_inst = new (GetAllocator()) HIf(instance_of);
-  entry->AddInstruction(new_inst_klass);
-  if (new_inst_klass != target_klass) {
-    entry->AddInstruction(target_klass);
-  }
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(instance_of);
-  entry->AddInstruction(if_inst);
-  ManuallyBuildEnvFor(new_inst_klass, {});
-  if (new_inst_klass != target_klass) {
-    target_klass->CopyEnvironmentFrom(new_inst_klass->GetEnvironment());
-  }
-  new_inst->CopyEnvironmentFrom(new_inst_klass->GetEnvironment());
-
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  left->AddInstruction(goto_left);
+  if_block->AddInstruction(instance_of);
+  HIf* if_inst = MakeIf(if_block, instance_of);
 
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(goto_right);
+  HInstruction* read_bottom =
+      MakeIFieldGet(breturn, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(breturn, read_bottom);
 
-  HInstruction* read_bottom = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_bottom);
-  breturn->AddInstruction(read_bottom);
-  breturn->AddInstruction(return_exit);
-
-  SetupExit(exit);
-
-  PerformSimplification(blks);
+  PerformSimplification();
 
   if (!GetConstantResult() || GetParam() == InstanceOfKind::kSelf) {
     EXPECT_INS_RETAINED(target_klass);
@@ -227,16 +198,10 @@ TEST_P(InstanceOfInstructionSimplifierTestGroup, ExactClassInstanceOfOther) {
 TEST_P(InstanceOfInstructionSimplifierTestGroup, ExactClassCheckCastOther) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  InitGraph(/*handles=*/&vshs);
-
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry", "exit", {{"entry", "exit"}}));
-#define GET_BLOCK(name) HBasicBlock* name = blks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* main = InitEntryMainExitGraph(/*handles=*/&vshs);
 
-  auto [new_inst_klass, target_klass] = GetLoadClasses(&vshs);
-  HInstruction* new_inst = MakeNewInstance(new_inst_klass);
+  auto [new_inst_klass, target_klass] = GetLoadClasses(main, &vshs);
+  HInstruction* new_inst = MakeNewInstance(main, new_inst_klass);
   new_inst->SetReferenceTypeInfo(
       ReferenceTypeInfo::Create(new_inst_klass->GetClass(), /*is_exact=*/true));
   HCheckCast* check_cast = new (GetAllocator()) HCheckCast(new_inst,
@@ -250,23 +215,10 @@ TEST_P(InstanceOfInstructionSimplifierTestGroup, ExactClassCheckCastOther) {
   if (target_klass->GetLoadedClassRTI().IsValid()) {
     check_cast->SetValidTargetClassRTI();
   }
-  HInstruction* entry_return = new (GetAllocator()) HReturn(new_inst);
-  entry->AddInstruction(new_inst_klass);
-  if (new_inst_klass != target_klass) {
-    entry->AddInstruction(target_klass);
-  }
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(check_cast);
-  entry->AddInstruction(entry_return);
-  ManuallyBuildEnvFor(new_inst_klass, {});
-  if (new_inst_klass != target_klass) {
-    target_klass->CopyEnvironmentFrom(new_inst_klass->GetEnvironment());
-  }
-  new_inst->CopyEnvironmentFrom(new_inst_klass->GetEnvironment());
-
-  SetupExit(exit);
+  main->AddInstruction(check_cast);
+  MakeReturn(main, new_inst);
 
-  PerformSimplification(blks);
+  PerformSimplification();
 
   if (!GetConstantResult() || GetParam() == InstanceOfKind::kSelf) {
     EXPECT_INS_RETAINED(target_klass);
diff --git a/compiler/optimizing/instruction_simplifier_x86.cc b/compiler/optimizing/instruction_simplifier_x86.cc
index 5a4345d589..e1c783e5b8 100644
--- a/compiler/optimizing/instruction_simplifier_x86.cc
+++ b/compiler/optimizing/instruction_simplifier_x86.cc
@@ -48,6 +48,7 @@ class InstructionSimplifierX86Visitor final : public HGraphVisitor {
   }
 
   void VisitAnd(HAnd * instruction) override;
+  void VisitRol(HRol* instruction) override;
   void VisitXor(HXor* instruction) override;
 
  private:
@@ -57,6 +58,10 @@ class InstructionSimplifierX86Visitor final : public HGraphVisitor {
 
 
 void InstructionSimplifierX86Visitor::VisitAnd(HAnd* instruction) {
+  if (!HasAVX2()) {
+    return;
+  }
+
   if (TryCombineAndNot(instruction)) {
     RecordSimplification();
   } else if (instruction->GetResultType() == DataType::Type::kInt32) {
@@ -66,7 +71,26 @@ void InstructionSimplifierX86Visitor::VisitAnd(HAnd* instruction) {
   }
 }
 
+void InstructionSimplifierX86Visitor::VisitRol(HRol* rol) {
+  if (rol->GetType() != DataType::Type::kInt64) {
+    return;
+  }
+
+  HBasicBlock* block = rol->GetBlock();
+  HGraph* graph = block->GetGraph();
+  ArenaAllocator* allocator = graph->GetAllocator();
+
+  HNeg* neg = new (allocator) HNeg(DataType::Type::kInt32, rol->GetRight());
+  block->InsertInstructionBefore(neg, rol);
+  HRor* ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), neg);
+  block->ReplaceAndRemoveInstructionWith(rol, ror);
+}
+
 void InstructionSimplifierX86Visitor::VisitXor(HXor* instruction) {
+  if (!HasAVX2()) {
+    return;
+  }
+
   if (instruction->GetResultType() == DataType::Type::kInt32) {
     if (TryGenerateMaskUptoLeastSetBit(instruction)) {
       RecordSimplification();
@@ -76,11 +100,8 @@ void InstructionSimplifierX86Visitor::VisitXor(HXor* instruction) {
 
 bool InstructionSimplifierX86::Run() {
   InstructionSimplifierX86Visitor visitor(graph_, codegen_, stats_);
-  if (visitor.HasAVX2()) {
-    visitor.VisitReversePostOrder();
-    return true;
-  }
-  return false;
+  visitor.VisitReversePostOrder();
+  return true;
 }
 
 }  // namespace x86
diff --git a/compiler/optimizing/intrinsics_arm64.cc b/compiler/optimizing/intrinsics_arm64.cc
index d8c7a6531e..71ef84e1aa 100644
--- a/compiler/optimizing/intrinsics_arm64.cc
+++ b/compiler/optimizing/intrinsics_arm64.cc
@@ -41,9 +41,10 @@
 
 using namespace vixl::aarch64;  // NOLINT(build/namespaces)
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/disasm-aarch64.h"
 #include "aarch64/macro-assembler-aarch64.h"
 #pragma GCC diagnostic pop
@@ -56,6 +57,7 @@ using helpers::CPURegisterFrom;
 using helpers::DRegisterFrom;
 using helpers::HeapOperand;
 using helpers::LocationFrom;
+using helpers::Int64FromLocation;
 using helpers::InputCPURegisterAt;
 using helpers::InputCPURegisterOrZeroRegAt;
 using helpers::OperandFrom;
@@ -698,6 +700,13 @@ void IntrinsicCodeGeneratorARM64::VisitThreadCurrentThread(HInvoke* invoke) {
                  MemOperand(tr, Thread::PeerOffset<kArm64PointerSize>().Int32Value()));
 }
 
+static bool ReadBarrierNeedsTemp(bool is_volatile, HInvoke* invoke) {
+  return is_volatile ||
+      !invoke->InputAt(2)->IsLongConstant() ||
+      invoke->InputAt(2)->AsLongConstant()->GetValue() >= kReferenceLoadMinFarOffset;
+}
+
+
 static void GenUnsafeGet(HInvoke* invoke,
                          DataType::Type type,
                          bool is_volatile,
@@ -710,7 +719,6 @@ static void GenUnsafeGet(HInvoke* invoke,
   Location base_loc = locations->InAt(1);
   Register base = WRegisterFrom(base_loc);      // Object pointer.
   Location offset_loc = locations->InAt(2);
-  Register offset = XRegisterFrom(offset_loc);  // Long offset.
   Location trg_loc = locations->Out();
   Register trg = RegisterFrom(trg_loc, type);
 
@@ -719,16 +727,35 @@ static void GenUnsafeGet(HInvoke* invoke,
     Register temp = WRegisterFrom(locations->GetTemp(0));
     MacroAssembler* masm = codegen->GetVIXLAssembler();
     // Piggy-back on the field load path using introspection for the Baker read barrier.
-    __ Add(temp, base, offset.W());  // Offset should not exceed 32 bits.
-    codegen->GenerateFieldLoadWithBakerReadBarrier(invoke,
-                                                   trg_loc,
-                                                   base,
-                                                   MemOperand(temp.X()),
-                                                   /* needs_null_check= */ false,
-                                                   is_volatile);
+    if (offset_loc.IsConstant()) {
+      uint32_t offset = Int64FromLocation(offset_loc);
+      Location maybe_temp = ReadBarrierNeedsTemp(is_volatile, invoke)
+          ? locations->GetTemp(0) : Location::NoLocation();
+      DCHECK_EQ(locations->GetTempCount(), ReadBarrierNeedsTemp(is_volatile, invoke));
+      codegen->GenerateFieldLoadWithBakerReadBarrier(invoke,
+                                                     trg_loc,
+                                                     base.W(),
+                                                     offset,
+                                                     maybe_temp,
+                                                     /* needs_null_check= */ false,
+                                                     is_volatile);
+    } else {
+      __ Add(temp, base, WRegisterFrom(offset_loc));  // Offset should not exceed 32 bits.
+      codegen->GenerateFieldLoadWithBakerReadBarrier(invoke,
+                                                     trg_loc,
+                                                     base,
+                                                     MemOperand(temp.X()),
+                                                     /* needs_null_check= */ false,
+                                                     is_volatile);
+    }
   } else {
     // Other cases.
-    MemOperand mem_op(base.X(), offset);
+    MemOperand mem_op;
+    if (offset_loc.IsConstant()) {
+      mem_op = MemOperand(base.X(), Int64FromLocation(offset_loc));
+    } else {
+      mem_op = MemOperand(base.X(), XRegisterFrom(offset_loc));
+    }
     if (is_volatile) {
       codegen->LoadAcquire(invoke, type, trg, mem_op, /* needs_null_check= */ true);
     } else {
@@ -744,7 +771,8 @@ static void GenUnsafeGet(HInvoke* invoke,
 
 static void CreateUnsafeGetLocations(ArenaAllocator* allocator,
                                      HInvoke* invoke,
-                                     CodeGeneratorARM64* codegen) {
+                                     CodeGeneratorARM64* codegen,
+                                     bool is_volatile = false) {
   bool can_call = codegen->EmitReadBarrier() && IsUnsafeGetReference(invoke);
   LocationSummary* locations =
       new (allocator) LocationSummary(invoke,
@@ -754,13 +782,15 @@ static void CreateUnsafeGetLocations(ArenaAllocator* allocator,
                                       kIntrinsified);
   if (can_call && kUseBakerReadBarrier) {
     locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
-    // We need a temporary register for the read barrier load in order to use
-    // CodeGeneratorARM64::GenerateFieldLoadWithBakerReadBarrier().
-    locations->AddTemp(FixedTempLocation());
+    if (ReadBarrierNeedsTemp(is_volatile, invoke)) {
+      // We need a temporary register for the read barrier load in order to use
+      // CodeGeneratorARM64::GenerateFieldLoadWithBakerReadBarrier().
+      locations->AddTemp(FixedTempLocation());
+    }
   }
   locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
   locations->SetInAt(1, Location::RequiresRegister());
-  locations->SetInAt(2, Location::RequiresRegister());
+  locations->SetInAt(2, Location::RegisterOrConstant(invoke->InputAt(2)));
   locations->SetOut(Location::RequiresRegister(),
                     (can_call ? Location::kOutputOverlap : Location::kNoOutputOverlap));
 }
@@ -791,28 +821,28 @@ void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGet(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
-  CreateUnsafeGetLocations(allocator_, invoke, codegen_);
+  CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetAcquire(HInvoke* invoke) {
-  CreateUnsafeGetLocations(allocator_, invoke, codegen_);
+  CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetLong(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetLongVolatile(HInvoke* invoke) {
-  CreateUnsafeGetLocations(allocator_, invoke, codegen_);
+  CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetLongAcquire(HInvoke* invoke) {
-  CreateUnsafeGetLocations(allocator_, invoke, codegen_);
+  CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetReference(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetReferenceVolatile(HInvoke* invoke) {
-  CreateUnsafeGetLocations(allocator_, invoke, codegen_);
+  CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetReferenceAcquire(HInvoke* invoke) {
-  CreateUnsafeGetLocations(allocator_, invoke, codegen_);
+  CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetByte(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
@@ -874,10 +904,21 @@ void IntrinsicCodeGeneratorARM64::VisitJdkUnsafeGetByte(HInvoke* invoke) {
 static void CreateUnsafePutLocations(ArenaAllocator* allocator, HInvoke* invoke) {
   LocationSummary* locations =
       new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
-  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  static constexpr int kOffsetIndex = 2;
+  static constexpr int kValueIndex = 3;
+  // Unused receiver.
+  locations->SetInAt(0, Location::NoLocation());
+  // The object.
   locations->SetInAt(1, Location::RequiresRegister());
-  locations->SetInAt(2, Location::RequiresRegister());
-  locations->SetInAt(3, Location::RequiresRegister());
+  // The offset.
+  locations->SetInAt(
+      kOffsetIndex, Location::RegisterOrConstant(invoke->InputAt(kOffsetIndex)));
+  // The value.
+  if (IsZeroBitPattern(invoke->InputAt(kValueIndex))) {
+    locations->SetInAt(kValueIndex, Location::ConstantLocation(invoke->InputAt(kValueIndex)));
+  } else {
+    locations->SetInAt(kValueIndex, Location::RequiresRegister());
+  }
 }
 
 void IntrinsicLocationsBuilderARM64::VisitUnsafePut(HInvoke* invoke) {
@@ -959,18 +1000,27 @@ static void GenUnsafePut(HInvoke* invoke,
   LocationSummary* locations = invoke->GetLocations();
   MacroAssembler* masm = codegen->GetVIXLAssembler();
 
+  static constexpr int kOffsetIndex = 2;
+  static constexpr int kValueIndex = 3;
   Register base = WRegisterFrom(locations->InAt(1));    // Object pointer.
-  Register offset = XRegisterFrom(locations->InAt(2));  // Long offset.
-  Register value = RegisterFrom(locations->InAt(3), type);
-  Register source = value;
-  MemOperand mem_op(base.X(), offset);
+  Location offset = locations->InAt(kOffsetIndex);       // Long offset.
+  CPURegister value = InputCPURegisterOrZeroRegAt(invoke, kValueIndex);
+  CPURegister source = value;
+  MemOperand mem_op;
+  if (offset.IsConstant()) {
+    mem_op = MemOperand(base.X(), Int64FromLocation(offset));
+  } else {
+    mem_op = MemOperand(base.X(), XRegisterFrom(offset));
+  }
 
   {
     // We use a block to end the scratch scope before the write barrier, thus
     // freeing the temporary registers so they can be used in `MarkGCCard`.
     UseScratchRegisterScope temps(masm);
 
-    if (kPoisonHeapReferences && type == DataType::Type::kReference) {
+    if (kPoisonHeapReferences &&
+        type == DataType::Type::kReference &&
+        !IsZeroBitPattern(invoke->InputAt(kValueIndex))) {
       DCHECK(value.IsW());
       Register temp = temps.AcquireW();
       __ Mov(temp.W(), value.W());
@@ -985,9 +1035,9 @@ static void GenUnsafePut(HInvoke* invoke,
     }
   }
 
-  if (type == DataType::Type::kReference) {
+  if (type == DataType::Type::kReference && !IsZeroBitPattern(invoke->InputAt(kValueIndex))) {
     bool value_can_be_null = true;  // TODO: Worth finding out this information?
-    codegen->MaybeMarkGCCard(base, value, value_can_be_null);
+    codegen->MaybeMarkGCCard(base, Register(source), value_can_be_null);
   }
 }
 
@@ -1553,8 +1603,7 @@ void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeCompareAndSetReference(HInvok
     // We need two non-scratch temporary registers for read barrier.
     LocationSummary* locations = invoke->GetLocations();
     if (kUseBakerReadBarrier) {
-      locations->AddTemp(Location::RequiresRegister());
-      locations->AddTemp(Location::RequiresRegister());
+      locations->AddRegisterTemps(2);
     } else {
       // To preserve the old value across the non-Baker read barrier
       // slow path, use a fixed callee-save register.
@@ -1835,9 +1884,7 @@ void IntrinsicLocationsBuilderARM64::VisitStringCompareTo(HInvoke* invoke) {
                                        kIntrinsified);
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetInAt(1, Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
   // Need temporary registers for String compression's feature.
   if (mirror::kUseStringCompression) {
     locations->AddTemp(Location::RequiresRegister());
@@ -2601,9 +2648,7 @@ void IntrinsicLocationsBuilderARM64::VisitStringGetCharsNoCheck(HInvoke* invoke)
   locations->SetInAt(3, Location::RequiresRegister());
   locations->SetInAt(4, Location::RequiresRegister());
 
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
 }
 
 void IntrinsicCodeGeneratorARM64::VisitStringGetCharsNoCheck(HInvoke* invoke) {
@@ -2776,9 +2821,7 @@ void IntrinsicLocationsBuilderARM64::VisitSystemArrayCopyChar(HInvoke* invoke) {
   locations->SetInAt(3, LocationForSystemArrayCopyInput(invoke->InputAt(3)));
   locations->SetInAt(4, LocationForSystemArrayCopyInput(invoke->InputAt(4)));
 
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
 }
 
 static void CheckSystemArrayCopyPosition(MacroAssembler* masm,
diff --git a/compiler/optimizing/intrinsics_arm_vixl.cc b/compiler/optimizing/intrinsics_arm_vixl.cc
index ecc9732816..1b1711b9de 100644
--- a/compiler/optimizing/intrinsics_arm_vixl.cc
+++ b/compiler/optimizing/intrinsics_arm_vixl.cc
@@ -535,9 +535,7 @@ void IntrinsicLocationsBuilderARMVIXL::VisitStringCompareTo(HInvoke* invoke) {
                                        kIntrinsified);
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetInAt(1, Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
   // Need temporary registers for String compression's feature.
   if (mirror::kUseStringCompression) {
     locations->AddTemp(Location::RequiresRegister());
@@ -2120,9 +2118,7 @@ void IntrinsicLocationsBuilderARMVIXL::VisitStringGetCharsNoCheck(HInvoke* invok
   locations->SetInAt(4, Location::RequiresRegister());
 
   // Temporary registers to store lengths of strings and for calculations.
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
 }
 
 void IntrinsicCodeGeneratorARMVIXL::VisitStringGetCharsNoCheck(HInvoke* invoke) {
diff --git a/compiler/optimizing/intrinsics_riscv64.cc b/compiler/optimizing/intrinsics_riscv64.cc
index b71232b4e4..2bc8cad71a 100644
--- a/compiler/optimizing/intrinsics_riscv64.cc
+++ b/compiler/optimizing/intrinsics_riscv64.cc
@@ -1569,8 +1569,9 @@ static void GenSystemArrayCopyAddresses(CodeGeneratorRISCV64* codegen,
                                         XRegister src_base,
                                         XRegister dst_base,
                                         XRegister src_end) {
-  // This routine is used by the SystemArrayCopy and the SystemArrayCopyChar intrinsics.
-  DCHECK(type == DataType::Type::kReference || type == DataType::Type::kUint16)
+  // This routine is used by the SystemArrayCopyX intrinsics.
+  DCHECK(type == DataType::Type::kReference || type == DataType::Type::kInt8 ||
+         type == DataType::Type::kUint16 || type == DataType::Type::kInt32)
       << "Unexpected element type: " << type;
   const int32_t element_size = DataType::Size(type);
   const uint32_t data_offset = mirror::Array::DataOffset(element_size).Uint32Value();
@@ -1921,6 +1922,284 @@ void IntrinsicCodeGeneratorRISCV64::VisitSystemArrayCopy(HInvoke* invoke) {
   __ Bind(intrinsic_slow_path->GetExitLabel());
 }
 
+// This value is in bytes and greater than ARRAYCOPY_SHORT_XXX_ARRAY_THRESHOLD
+// in libcore, so if we choose to jump to the slow path we will end up
+// in the native implementation.
+static constexpr int32_t kSystemArrayCopyPrimThreshold = 384;
+
+static void CreateSystemArrayCopyLocations(HInvoke* invoke, DataType::Type type) {
+  int32_t copy_threshold = kSystemArrayCopyPrimThreshold / DataType::Size(type);
+
+  // Check to see if we have known failures that will cause us to have to bail out
+  // to the runtime, and just generate the runtime call directly.
+  HIntConstant* src_pos = invoke->InputAt(1)->AsIntConstantOrNull();
+  HIntConstant* dst_pos = invoke->InputAt(3)->AsIntConstantOrNull();
+
+  // The positions must be non-negative.
+  if ((src_pos != nullptr && src_pos->GetValue() < 0) ||
+      (dst_pos != nullptr && dst_pos->GetValue() < 0)) {
+    // We will have to fail anyways.
+    return;
+  }
+
+  // The length must be >= 0 and not so long that we would (currently) prefer libcore's
+  // native implementation.
+  HIntConstant* length = invoke->InputAt(4)->AsIntConstantOrNull();
+  if (length != nullptr) {
+    int32_t len = length->GetValue();
+    if (len < 0 || len > copy_threshold) {
+      // Just call as normal.
+      return;
+    }
+  }
+
+  ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kCallOnSlowPath, kIntrinsified);
+  // arraycopy(char[] src, int src_pos, char[] dst, int dst_pos, int length).
+  locations->SetInAt(0, Location::RequiresRegister());
+  locations->SetInAt(1, LocationForSystemArrayCopyInput(invoke->InputAt(1)));
+  locations->SetInAt(2, Location::RequiresRegister());
+  locations->SetInAt(3, LocationForSystemArrayCopyInput(invoke->InputAt(3)));
+  locations->SetInAt(4, LocationForSystemArrayCopyInput(invoke->InputAt(4)));
+
+  locations->AddRegisterTemps(3);
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitSystemArrayCopyByte(HInvoke* invoke) {
+  CreateSystemArrayCopyLocations(invoke, DataType::Type::kInt8);
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitSystemArrayCopyChar(HInvoke* invoke) {
+  CreateSystemArrayCopyLocations(invoke, DataType::Type::kUint16);
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitSystemArrayCopyInt(HInvoke* invoke) {
+  CreateSystemArrayCopyLocations(invoke, DataType::Type::kInt32);
+}
+
+static void GenerateUnsignedLoad(
+    Riscv64Assembler* assembler, XRegister rd, XRegister rs1, int32_t offset, size_t type_size) {
+  switch (type_size) {
+    case 1:
+      __ Lbu(rd, rs1, offset);
+      break;
+    case 2:
+      __ Lhu(rd, rs1, offset);
+      break;
+    case 4:
+      __ Lwu(rd, rs1, offset);
+      break;
+    case 8:
+      __ Ld(rd, rs1, offset);
+      break;
+    default:
+      LOG(FATAL) << "Unexpected data type";
+  }
+}
+
+static void GenerateStore(
+    Riscv64Assembler* assembler, XRegister rs2, XRegister rs1, int32_t offset, size_t type_size) {
+  switch (type_size) {
+    case 1:
+      __ Sb(rs2, rs1, offset);
+      break;
+    case 2:
+      __ Sh(rs2, rs1, offset);
+      break;
+    case 4:
+      __ Sw(rs2, rs1, offset);
+      break;
+    case 8:
+      __ Sd(rs2, rs1, offset);
+      break;
+    default:
+      LOG(FATAL) << "Unexpected data type";
+  }
+}
+
+static void SystemArrayCopyPrimitive(HInvoke* invoke,
+                                     CodeGeneratorRISCV64* codegen,
+                                     DataType::Type type) {
+  Riscv64Assembler* assembler = codegen->GetAssembler();
+  LocationSummary* locations = invoke->GetLocations();
+  XRegister src = locations->InAt(0).AsRegister<XRegister>();
+  Location src_pos = locations->InAt(1);
+  XRegister dst = locations->InAt(2).AsRegister<XRegister>();
+  Location dst_pos = locations->InAt(3);
+  Location length = locations->InAt(4);
+
+  SlowPathCodeRISCV64* slow_path =
+      new (codegen->GetScopedAllocator()) IntrinsicSlowPathRISCV64(invoke);
+  codegen->AddSlowPath(slow_path);
+
+  SystemArrayCopyOptimizations optimizations(invoke);
+
+  // If source and destination are the same, take the slow path. Overlapping copy regions must be
+  // copied in reverse and we can't know in all cases if it's needed.
+  __ Beq(src, dst, slow_path->GetEntryLabel());
+
+  if (!optimizations.GetSourceIsNotNull()) {
+    // Bail out if the source is null.
+    __ Beqz(src, slow_path->GetEntryLabel());
+  }
+
+  if (!optimizations.GetDestinationIsNotNull() && !optimizations.GetDestinationIsSource()) {
+    // Bail out if the destination is null.
+    __ Beqz(dst, slow_path->GetEntryLabel());
+  }
+
+  int32_t copy_threshold = kSystemArrayCopyPrimThreshold / DataType::Size(type);
+  XRegister tmp = locations->GetTemp(0).AsRegister<XRegister>();
+  if (!length.IsConstant()) {
+    // Merge the following two comparisons into one:
+    //   If the length is negative, bail out (delegate to libcore's native implementation).
+    //   If the length >= kSystemArrayCopyPrimThreshold then (currently) prefer libcore's
+    //   native implementation.
+    __ Li(tmp, copy_threshold);
+    __ Bgeu(length.AsRegister<XRegister>(), tmp, slow_path->GetEntryLabel());
+  } else {
+    // We have already checked in the LocationsBuilder for the constant case.
+    DCHECK_GE(length.GetConstant()->AsIntConstant()->GetValue(), 0);
+    DCHECK_LE(length.GetConstant()->AsIntConstant()->GetValue(), copy_threshold);
+  }
+
+  XRegister src_curr_addr = locations->GetTemp(1).AsRegister<XRegister>();
+  XRegister dst_curr_addr = locations->GetTemp(2).AsRegister<XRegister>();
+
+  CheckSystemArrayCopyPosition(assembler,
+                               src,
+                               src_pos,
+                               length,
+                               slow_path,
+                               src_curr_addr,
+                               dst_curr_addr,
+                               /*length_is_array_length=*/ false,
+                               /*position_sign_checked=*/ false);
+
+  CheckSystemArrayCopyPosition(assembler,
+                               dst,
+                               dst_pos,
+                               length,
+                               slow_path,
+                               src_curr_addr,
+                               dst_curr_addr,
+                               /*length_is_array_length=*/ false,
+                               /*position_sign_checked=*/ false);
+
+  const int32_t element_size = DataType::Size(type);
+  const uint32_t data_offset = mirror::Array::DataOffset(element_size).Uint32Value();
+
+  GenArrayAddress(codegen, src_curr_addr, src, src_pos, type, data_offset);
+  GenArrayAddress(codegen, dst_curr_addr, dst, dst_pos, type, data_offset);
+
+  // We split processing of the array in two parts: head and tail.
+  // A first loop handles the head by copying a block of elements per
+  // iteration (see: elements_per_block).
+  // A second loop handles the tail by copying the remaining elements.
+  // If the copy length is not constant, we copy them one-by-one.
+  //
+  // Both loops are inverted for better performance, meaning they are
+  // implemented as conditional do-while loops.
+  // Here, the loop condition is first checked to determine if there are
+  // sufficient elements to run an iteration, then we enter the do-while: an
+  // iteration is performed followed by a conditional branch only if another
+  // iteration is necessary. As opposed to a standard while-loop, this inversion
+  // can save some branching (e.g. we don't branch back to the initial condition
+  // at the end of every iteration only to potentially immediately branch
+  // again).
+  //
+  // A full block of elements is subtracted and added before and after the head
+  // loop, respectively. This ensures that any remaining length after each
+  // head loop iteration means there is a full block remaining, reducing the
+  // number of conditional checks required on every iteration.
+  ScratchRegisterScope temps(assembler);
+  constexpr int32_t bytes_copied_per_iteration = 16;
+  DCHECK_EQ(bytes_copied_per_iteration % element_size, 0);
+  int32_t elements_per_block = bytes_copied_per_iteration / element_size;
+  Riscv64Label done;
+
+  XRegister length_tmp = temps.AllocateXRegister();
+
+  auto emit_head_loop = [&]() {
+    ScratchRegisterScope local_temps(assembler);
+    XRegister tmp2 = local_temps.AllocateXRegister();
+
+    Riscv64Label loop;
+    __ Bind(&loop);
+    __ Ld(tmp, src_curr_addr, 0);
+    __ Ld(tmp2, src_curr_addr, 8);
+    __ Sd(tmp, dst_curr_addr, 0);
+    __ Sd(tmp2, dst_curr_addr, 8);
+    __ Addi(length_tmp, length_tmp, -elements_per_block);
+    __ Addi(src_curr_addr, src_curr_addr, bytes_copied_per_iteration);
+    __ Addi(dst_curr_addr, dst_curr_addr, bytes_copied_per_iteration);
+    __ Bgez(length_tmp, &loop);
+  };
+
+  auto emit_tail_loop = [&]() {
+    Riscv64Label loop;
+    __ Bind(&loop);
+    GenerateUnsignedLoad(assembler, tmp, src_curr_addr, 0, element_size);
+    GenerateStore(assembler, tmp, dst_curr_addr, 0, element_size);
+    __ Addi(length_tmp, length_tmp, -1);
+    __ Addi(src_curr_addr, src_curr_addr, element_size);
+    __ Addi(dst_curr_addr, dst_curr_addr, element_size);
+    __ Bgtz(length_tmp, &loop);
+  };
+
+  auto emit_unrolled_tail_loop = [&](int32_t tail_length) {
+    DCHECK_LT(tail_length, elements_per_block);
+
+    int32_t length_in_bytes = tail_length * element_size;
+    size_t offset = 0;
+    for (size_t operation_size = 8; operation_size > 0; operation_size >>= 1) {
+      if ((length_in_bytes & operation_size) != 0) {
+        GenerateUnsignedLoad(assembler, tmp, src_curr_addr, offset, operation_size);
+        GenerateStore(assembler, tmp, dst_curr_addr, offset, operation_size);
+        offset += operation_size;
+      }
+    }
+  };
+
+  if (length.IsConstant()) {
+    const int32_t constant_length = length.GetConstant()->AsIntConstant()->GetValue();
+    if (constant_length >= elements_per_block) {
+      __ Li(length_tmp, constant_length - elements_per_block);
+      emit_head_loop();
+    }
+    emit_unrolled_tail_loop(constant_length % elements_per_block);
+  } else {
+    Riscv64Label tail_loop;
+    XRegister length_reg = length.AsRegister<XRegister>();
+    __ Addi(length_tmp, length_reg, -elements_per_block);
+    __ Bltz(length_tmp, &tail_loop);
+
+    emit_head_loop();
+
+    __ Bind(&tail_loop);
+    __ Addi(length_tmp, length_tmp, elements_per_block);
+    __ Beqz(length_tmp, &done);
+
+    emit_tail_loop();
+  }
+
+  __ Bind(&done);
+  __ Bind(slow_path->GetExitLabel());
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitSystemArrayCopyByte(HInvoke* invoke) {
+  SystemArrayCopyPrimitive(invoke, codegen_, DataType::Type::kInt8);
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitSystemArrayCopyChar(HInvoke* invoke) {
+  SystemArrayCopyPrimitive(invoke, codegen_, DataType::Type::kUint16);
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitSystemArrayCopyInt(HInvoke* invoke) {
+  SystemArrayCopyPrimitive(invoke, codegen_, DataType::Type::kInt32);
+}
+
 enum class GetAndUpdateOp {
   kSet,
   kAdd,
@@ -2829,9 +3108,7 @@ void IntrinsicLocationsBuilderRISCV64::VisitStringCompareTo(HInvoke* invoke) {
                                        kIntrinsified);
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetInAt(1, Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
   // Need temporary registers for String compression's feature.
   if (mirror::kUseStringCompression) {
     locations->AddTemp(Location::RequiresRegister());
@@ -5076,9 +5353,7 @@ void IntrinsicLocationsBuilderRISCV64::VisitStringGetCharsNoCheck(HInvoke* invok
   locations->SetInAt(3, Location::RequiresRegister());
   locations->SetInAt(4, Location::RequiresRegister());
 
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(3);
 }
 
 void IntrinsicCodeGeneratorRISCV64::VisitStringGetCharsNoCheck(HInvoke* invoke) {
@@ -5245,6 +5520,92 @@ void IntrinsicCodeGeneratorRISCV64::VisitStringGetCharsNoCheck(HInvoke* invoke)
   __ Bind(&done);
 }
 
+void GenMathSignum(CodeGeneratorRISCV64* codegen, HInvoke* invoke, DataType::Type type) {
+  LocationSummary* locations = invoke->GetLocations();
+  DCHECK(locations->InAt(0).Equals(locations->Out()));
+  FRegister in = locations->InAt(0).AsFpuRegister<FRegister>();
+  Riscv64Assembler* assembler = codegen->GetAssembler();
+  ScratchRegisterScope srs(assembler);
+  XRegister tmp = srs.AllocateXRegister();
+  FRegister ftmp = srs.AllocateFRegister();
+  Riscv64Label done;
+
+  if (type == DataType::Type::kFloat64) {
+    // 0x3FF0000000000000L = 1.0
+    __ Li(tmp, 0x3FF0000000000000L);
+    __ FMvDX(ftmp, tmp);
+    __ FClassD(tmp, in);
+  } else {
+    // 0x3f800000 = 1.0f
+    __ Li(tmp, 0x3F800000);
+    __ FMvWX(ftmp, tmp);
+    __ FClassS(tmp, in);
+  }
+
+  __ Andi(tmp, tmp, kPositiveZero | kNegativeZero | kSignalingNaN | kQuietNaN);
+  __ Bnez(tmp, &done);
+
+  if (type == DataType::Type::kFloat64) {
+    __ FSgnjD(in, ftmp, in);
+  } else {
+    __ FSgnjS(in, ftmp, in);
+  }
+
+  __ Bind(&done);
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitMathSignumDouble(HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator_) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::RequiresFpuRegister());
+  locations->SetOut(Location::SameAsFirstInput());
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitMathSignumDouble(HInvoke* invoke) {
+  GenMathSignum(codegen_, invoke, DataType::Type::kFloat64);
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitMathSignumFloat(HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator_) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::RequiresFpuRegister());
+  locations->SetOut(Location::SameAsFirstInput());
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitMathSignumFloat(HInvoke* invoke) {
+  GenMathSignum(codegen_, invoke, DataType::Type::kFloat32);
+}
+
+void GenMathCopySign(CodeGeneratorRISCV64* codegen, HInvoke* invoke, DataType::Type type) {
+  Riscv64Assembler* assembler = codegen->GetAssembler();
+  LocationSummary* locations = invoke->GetLocations();
+  FRegister in0 = locations->InAt(0).AsFpuRegister<FRegister>();
+  FRegister in1 = locations->InAt(1).AsFpuRegister<FRegister>();
+  FRegister out = locations->Out().AsFpuRegister<FRegister>();
+
+  if (type == DataType::Type::kFloat64) {
+    __ FSgnjD(out, in0, in1);
+  } else {
+    __ FSgnjS(out, in0, in1);
+  }
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitMathCopySignDouble(HInvoke* invoke) {
+  CreateFPFPToFPCallLocations(allocator_, invoke);
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitMathCopySignDouble(HInvoke* invoke) {
+  GenMathCopySign(codegen_, invoke, DataType::Type::kFloat64);
+}
+
+void IntrinsicLocationsBuilderRISCV64::VisitMathCopySignFloat(HInvoke* invoke) {
+  CreateFPFPToFPCallLocations(allocator_, invoke);
+}
+
+void IntrinsicCodeGeneratorRISCV64::VisitMathCopySignFloat(HInvoke* invoke) {
+  GenMathCopySign(codegen_, invoke, DataType::Type::kFloat32);
+}
+
 #define MARK_UNIMPLEMENTED(Name) UNIMPLEMENTED_INTRINSIC(RISCV64, Name)
 UNIMPLEMENTED_INTRINSIC_LIST_RISCV64(MARK_UNIMPLEMENTED);
 #undef MARK_UNIMPLEMENTED
diff --git a/compiler/optimizing/intrinsics_x86.cc b/compiler/optimizing/intrinsics_x86.cc
index 63dd963a9f..2b83ba8349 100644
--- a/compiler/optimizing/intrinsics_x86.cc
+++ b/compiler/optimizing/intrinsics_x86.cc
@@ -1887,7 +1887,12 @@ static void CreateIntIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator
   locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
   locations->SetInAt(1, Location::RequiresRegister());
   locations->SetInAt(2, Location::RequiresRegister());
-  locations->SetInAt(3, Location::RequiresRegister());
+  if (type == DataType::Type::kInt8 || type == DataType::Type::kUint8) {
+    // Ensure the value is in a byte register
+    locations->SetInAt(3, Location::ByteRegisterOrConstant(EAX, invoke->InputAt(3)));
+  } else {
+    locations->SetInAt(3, Location::RequiresRegister());
+  }
   if (type == DataType::Type::kReference) {
     // Need temp registers for card-marking.
     locations->AddTemp(Location::RequiresRegister());  // Possibly used for reference poisoning too.
@@ -2013,8 +2018,16 @@ static void GenUnsafePut(LocationSummary* locations,
     __ movl(temp, value_loc.AsRegister<Register>());
     __ PoisonHeapReference(temp);
     __ movl(Address(base, offset, ScaleFactor::TIMES_1, 0), temp);
-  } else {
+  } else if (type == DataType::Type::kInt32 || type == DataType::Type::kReference) {
     __ movl(Address(base, offset, ScaleFactor::TIMES_1, 0), value_loc.AsRegister<Register>());
+  } else {
+    CHECK_EQ(type, DataType::Type::kInt8) << "Unimplemented GenUnsafePut data type";
+    if (value_loc.IsRegister()) {
+      __ movb(Address(base, offset, ScaleFactor::TIMES_1, 0), value_loc.AsRegister<ByteRegister>());
+    } else {
+      __ movb(Address(base, offset, ScaleFactor::TIMES_1, 0),
+              Immediate(CodeGenerator::GetInt8ValueOf(value_loc.GetConstant())));
+    }
   }
 
   if (is_volatile) {
@@ -4239,8 +4252,7 @@ static void CreateVarHandleGetAndSetLocations(HInvoke* invoke, CodeGeneratorX86*
   ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
   LocationSummary* locations = new (allocator) LocationSummary(
       invoke, LocationSummary::kCallOnSlowPath, kIntrinsified);
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(2);
   // We use this temporary for the card, so we need a byte register
   locations->AddTemp(Location::RegisterLocation(EBX));
   locations->SetInAt(0, Location::RequiresRegister());
@@ -4413,8 +4425,7 @@ static void CreateVarHandleCompareAndSetOrExchangeLocations(HInvoke* invoke,
   ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
   LocationSummary* locations = new (allocator) LocationSummary(
       invoke, LocationSummary::kCallOnSlowPath, kIntrinsified);
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(2);
   // We use this temporary for the card, so we need a byte register
   locations->AddTemp(Location::RegisterLocation(EBX));
   locations->SetInAt(0, Location::RequiresRegister());
@@ -4593,8 +4604,7 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86*
   ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
   LocationSummary* locations = new (allocator) LocationSummary(
       invoke, LocationSummary::kCallOnSlowPath, kIntrinsified);
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(2);
   locations->SetInAt(0, Location::RequiresRegister());
   size_t expected_coordinates_count = GetExpectedVarHandleCoordinatesCount(invoke);
   if (expected_coordinates_count == 1u) {
diff --git a/compiler/optimizing/intrinsics_x86_64.cc b/compiler/optimizing/intrinsics_x86_64.cc
index 131460d605..bd6d6d1889 100644
--- a/compiler/optimizing/intrinsics_x86_64.cc
+++ b/compiler/optimizing/intrinsics_x86_64.cc
@@ -19,10 +19,13 @@
 #include <limits>
 
 #include "arch/x86_64/instruction_set_features_x86_64.h"
+#include "arch/x86_64/registers_x86_64.h"
 #include "art_method.h"
 #include "base/bit_utils.h"
 #include "code_generator_x86_64.h"
+#include "dex/modifiers.h"
 #include "entrypoints/quick/quick_entrypoints.h"
+#include "entrypoints/quick/quick_entrypoints_enum.h"
 #include "heap_poisoning.h"
 #include "intrinsics.h"
 #include "intrinsic_objects.h"
@@ -32,6 +35,7 @@
 #include "mirror/object_array-inl.h"
 #include "mirror/reference.h"
 #include "mirror/string.h"
+#include "optimizing/code_generator.h"
 #include "scoped_thread_state_change-inl.h"
 #include "thread-current-inl.h"
 #include "utils/x86_64/assembler_x86_64.h"
@@ -141,6 +145,39 @@ class ReadBarrierSystemArrayCopySlowPathX86_64 : public SlowPathCode {
   DISALLOW_COPY_AND_ASSIGN(ReadBarrierSystemArrayCopySlowPathX86_64);
 };
 
+// The MethodHandle.invokeExact intrinsic sets up arguments to match the target method call. If we
+// need to go to the slow path, we call art_quick_invoke_polymorphic_with_hidden_receiver, which
+// expects the MethodHandle object in RDI (in place of the actual ArtMethod).
+class InvokePolymorphicSlowPathX86_64 : public SlowPathCode {
+ public:
+  InvokePolymorphicSlowPathX86_64(HInstruction* instruction, CpuRegister method_handle)
+      : SlowPathCode(instruction), method_handle_(method_handle) {
+    DCHECK(instruction->IsInvokePolymorphic());
+  }
+
+  void EmitNativeCode(CodeGenerator* codegen) override {
+    CodeGeneratorX86_64* x86_64_codegen = down_cast<CodeGeneratorX86_64*>(codegen);
+    X86_64Assembler* assembler = x86_64_codegen->GetAssembler();
+    __ Bind(GetEntryLabel());
+    SaveLiveRegisters(codegen, instruction_->GetLocations());
+
+    // Passing `MethodHandle` object as hidden argument.
+    __ movq(CpuRegister(RDI), method_handle_);
+    x86_64_codegen->InvokeRuntime(QuickEntrypointEnum::kQuickInvokePolymorphicWithHiddenReceiver,
+                                  instruction_,
+                                  instruction_->GetDexPc());
+
+    RestoreLiveRegisters(codegen, instruction_->GetLocations());
+    __ jmp(GetExitLabel());
+  }
+
+  const char* GetDescription() const override { return "InvokePolymorphicSlowPathX86_64"; }
+
+ private:
+  const CpuRegister method_handle_;
+  DISALLOW_COPY_AND_ASSIGN(InvokePolymorphicSlowPathX86_64);
+};
+
 static void CreateFPToIntLocations(ArenaAllocator* allocator, HInvoke* invoke) {
   LocationSummary* locations =
       new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
@@ -2080,8 +2117,11 @@ static void GenUnsafePut(LocationSummary* locations, DataType::Type type, bool i
     __ movl(temp, value);
     __ PoisonHeapReference(temp);
     __ movl(Address(base, offset, ScaleFactor::TIMES_1, 0), temp);
-  } else {
+  } else if (type == DataType::Type::kInt32 || type == DataType::Type::kReference) {
     __ movl(Address(base, offset, ScaleFactor::TIMES_1, 0), value);
+  } else {
+    CHECK_EQ(type, DataType::Type::kInt8) << "Unimplemented GenUnsafePut data type";
+    __ movb(Address(base, offset, ScaleFactor::TIMES_1, 0), value);
   }
 
   if (is_volatile) {
@@ -2803,8 +2843,7 @@ void IntrinsicLocationsBuilderX86_64::VisitLongReverse(HInvoke* invoke) {
       new (allocator_) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetOut(Location::SameAsFirstInput());
-  locations->AddTemp(Location::RequiresRegister());
-  locations->AddTemp(Location::RequiresRegister());
+  locations->AddRegisterTemps(2);
 }
 
 static void SwapBits64(CpuRegister reg, CpuRegister temp, CpuRegister temp_mask,
@@ -3603,7 +3642,7 @@ void IntrinsicLocationsBuilderX86_64::VisitMathFmaFloat(HInvoke* invoke) {
 
 // Generate subtype check without read barriers.
 static void GenerateSubTypeObjectCheckNoReadBarrier(CodeGeneratorX86_64* codegen,
-                                                    VarHandleSlowPathX86_64* slow_path,
+                                                    SlowPathCode* slow_path,
                                                     CpuRegister object,
                                                     CpuRegister temp,
                                                     Address type_address,
@@ -4059,6 +4098,107 @@ static void GenerateVarHandleGet(HInvoke* invoke,
   }
 }
 
+void IntrinsicLocationsBuilderX86_64::VisitMethodHandleInvokeExact(HInvoke* invoke) {
+  // Don't emit intrinsic code for MethodHandle.invokeExact when it certainly does not target
+  // invoke-virtual: if invokeExact is called w/o arguments or if the first argument in that
+  // call is not a reference.
+  if (!invoke->AsInvokePolymorphic()->CanHaveFastPath()) {
+    return;
+  }
+  ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
+  LocationSummary* locations = new (allocator)
+      LocationSummary(invoke, LocationSummary::kCallOnMainAndSlowPath, kIntrinsified);
+
+  InvokeDexCallingConventionVisitorX86_64 calling_convention;
+  locations->SetOut(calling_convention.GetReturnLocation(invoke->GetType()));
+
+  locations->SetInAt(0, Location::RequiresRegister());
+
+  // Accomodating LocationSummary for underlying invoke-* call.
+  uint32_t number_of_args = invoke->GetNumberOfArguments();
+  for (uint32_t i = 1; i < number_of_args; ++i) {
+    locations->SetInAt(i, calling_convention.GetNextLocation(invoke->InputAt(i)->GetType()));
+  }
+
+  // The last input is MethodType object corresponding to the call-site.
+  locations->SetInAt(number_of_args, Location::RequiresRegister());
+
+  locations->AddTemp(Location::RequiresRegister());
+}
+
+void IntrinsicCodeGeneratorX86_64::VisitMethodHandleInvokeExact(HInvoke* invoke) {
+  DCHECK(invoke->AsInvokePolymorphic()->CanHaveFastPath());
+  LocationSummary* locations = invoke->GetLocations();
+
+  CpuRegister method_handle = locations->InAt(0).AsRegister<CpuRegister>();
+
+  SlowPathCode* slow_path =
+      new (codegen_->GetScopedAllocator()) InvokePolymorphicSlowPathX86_64(invoke, method_handle);
+  codegen_->AddSlowPath(slow_path);
+  X86_64Assembler* assembler = codegen_->GetAssembler();
+
+  Address method_handle_kind = Address(method_handle, mirror::MethodHandle::HandleKindOffset());
+
+  // If it is not InvokeVirtual then go to slow path.
+  // Even if MethodHandle's kind is kInvokeVirtual, the underlying method can still be an interface
+  // or a direct method (that's what current `MethodHandles$Lookup.findVirtual` is doing). We don't
+  // check whether `method` is an interface method explicitly: in that case the subtype check below
+  // will fail.
+  // TODO(b/297147201): check whether it can be more precise and what d8/r8 can produce.
+  __ cmpl(method_handle_kind, Immediate(mirror::MethodHandle::Kind::kInvokeVirtual));
+  __ j(kNotEqual, slow_path->GetEntryLabel());
+
+  CpuRegister call_site_type =
+      locations->InAt(invoke->GetNumberOfArguments()).AsRegister<CpuRegister>();
+
+  // Call site should match with MethodHandle's type.
+  __ cmpl(call_site_type, Address(method_handle, mirror::MethodHandle::MethodTypeOffset()));
+  __ j(kNotEqual, slow_path->GetEntryLabel());
+
+  CpuRegister method = CpuRegister(kMethodRegisterArgument);
+
+  // Get method to call.
+  __ movq(method, Address(method_handle, mirror::MethodHandle::ArtFieldOrMethodOffset()));
+
+  CpuRegister receiver = locations->InAt(1).AsRegister<CpuRegister>();
+
+  __ testl(receiver, receiver);
+  __ j(kEqual, slow_path->GetEntryLabel());
+
+  // Using vtable_index register as temporary in subtype check. It will be overridden later.
+  // If `method` is an interface method this check will fail.
+  CpuRegister vtable_index = locations->GetTemp(0).AsRegister<CpuRegister>();
+  // We deliberately avoid the read barrier, letting the slow path handle the false negatives.
+  GenerateSubTypeObjectCheckNoReadBarrier(codegen_,
+                                          slow_path,
+                                          receiver,
+                                          vtable_index,
+                                          Address(method, ArtMethod::DeclaringClassOffset()));
+
+  NearLabel execute_target_method;
+  // Skip virtual dispatch if `method` is private.
+  __ testl(Address(method, ArtMethod::AccessFlagsOffset()), Immediate(kAccPrivate));
+  __ j(kNotZero, &execute_target_method);
+
+  // MethodIndex is uint16_t.
+  __ movzxw(vtable_index, Address(method, ArtMethod::MethodIndexOffset()));
+
+  constexpr uint32_t class_offset = mirror::Object::ClassOffset().Int32Value();
+  // Re-using method register for receiver class.
+  __ movl(method, Address(receiver, class_offset));
+
+  constexpr uint32_t vtable_offset =
+      mirror::Class::EmbeddedVTableOffset(art::PointerSize::k64).Int32Value();
+  __ movq(method, Address(method, vtable_index, TIMES_8, vtable_offset));
+
+  __ Bind(&execute_target_method);
+  __ call(Address(
+      method,
+      ArtMethod::EntryPointFromQuickCompiledCodeOffset(art::PointerSize::k64).SizeValue()));
+  codegen_->RecordPcInfo(invoke, invoke->GetDexPc(), slow_path);
+  __ Bind(slow_path->GetExitLabel());
+}
+
 void IntrinsicLocationsBuilderX86_64::VisitVarHandleGet(HInvoke* invoke) {
   CreateVarHandleGetLocations(invoke, codegen_);
 }
@@ -4233,8 +4373,7 @@ static void CreateVarHandleCompareAndSetOrExchangeLocations(HInvoke* invoke,
     locations->SetInAt(new_value_index, Location::RequiresRegister());
     if (expected_type == DataType::Type::kReference) {
       // Need two temporaries for MarkGCCard.
-      locations->AddTemp(Location::RequiresRegister());
-      locations->AddTemp(Location::RequiresRegister());
+      locations->AddRegisterTemps(2);
       if (codegen->EmitReadBarrier()) {
         // Need three temporaries for GenerateReferenceLoadWithBakerReadBarrier.
         DCHECK(kUseBakerReadBarrier);
@@ -4381,8 +4520,7 @@ static void CreateVarHandleGetAndSetLocations(HInvoke* invoke, CodeGeneratorX86_
     locations->SetInAt(new_value_index, Location::RegisterLocation(RAX));
     if (type == DataType::Type::kReference) {
       // Need two temporaries for MarkGCCard.
-      locations->AddTemp(Location::RequiresRegister());
-      locations->AddTemp(Location::RequiresRegister());
+      locations->AddRegisterTemps(2);
       if (codegen->EmitReadBarrier()) {
         // Need a third temporary for GenerateReferenceLoadWithBakerReadBarrier.
         DCHECK(kUseBakerReadBarrier);
@@ -4675,8 +4813,7 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86_
       // case we need two temporary registers: one to hold value instead of RAX (which may get
       // clobbered by repeated CMPXCHG) and one for performing the operation. At compile time we
       // cannot distinguish this case from arrays or native-endian byte array views.
-      locations->AddTemp(Location::RequiresRegister());
-      locations->AddTemp(Location::RequiresRegister());
+      locations->AddRegisterTemps(2);
     }
   }
 }
diff --git a/compiler/optimizing/jit_patches_arm64.h b/compiler/optimizing/jit_patches_arm64.h
index f928723f58..f5d92804ac 100644
--- a/compiler/optimizing/jit_patches_arm64.h
+++ b/compiler/optimizing/jit_patches_arm64.h
@@ -27,9 +27,10 @@
 #include "mirror/string.h"
 #include "utils/arm64/assembler_arm64.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/disasm-aarch64.h"
 #include "aarch64/macro-assembler-aarch64.h"
 #pragma GCC diagnostic pop
diff --git a/compiler/optimizing/licm_test.cc b/compiler/optimizing/licm_test.cc
index f8481099f4..08a2dcc179 100644
--- a/compiler/optimizing/licm_test.cc
+++ b/compiler/optimizing/licm_test.cc
@@ -31,12 +31,9 @@ namespace art HIDDEN {
 class LICMTest : public OptimizingUnitTest {
  public:
   LICMTest()
-      : entry_(nullptr),
-        loop_preheader_(nullptr),
+      : loop_preheader_(nullptr),
         loop_header_(nullptr),
         loop_body_(nullptr),
-        return_(nullptr),
-        exit_(nullptr),
         parameter_(nullptr),
         int_constant_(nullptr),
         float_constant_(nullptr) {
@@ -48,44 +45,15 @@ class LICMTest : public OptimizingUnitTest {
   // Builds a singly-nested loop structure in CFG. Tests can further populate
   // the basic blocks with instructions to set up interesting scenarios.
   void BuildLoop() {
-    entry_ = new (GetAllocator()) HBasicBlock(graph_);
-    loop_preheader_ = new (GetAllocator()) HBasicBlock(graph_);
-    loop_header_ = new (GetAllocator()) HBasicBlock(graph_);
-    loop_body_ = new (GetAllocator()) HBasicBlock(graph_);
-    return_ = new (GetAllocator()) HBasicBlock(graph_);
-    exit_ = new (GetAllocator()) HBasicBlock(graph_);
-
-    graph_->AddBlock(entry_);
-    graph_->AddBlock(loop_preheader_);
-    graph_->AddBlock(loop_header_);
-    graph_->AddBlock(loop_body_);
-    graph_->AddBlock(return_);
-    graph_->AddBlock(exit_);
-
-    graph_->SetEntryBlock(entry_);
-    graph_->SetExitBlock(exit_);
-
-    // Set up loop flow in CFG.
-    entry_->AddSuccessor(loop_preheader_);
-    loop_preheader_->AddSuccessor(loop_header_);
-    loop_header_->AddSuccessor(loop_body_);
-    loop_header_->AddSuccessor(return_);
-    loop_body_->AddSuccessor(loop_header_);
-    return_->AddSuccessor(exit_);
+    HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+    std::tie(loop_preheader_, loop_header_, loop_body_) = CreateWhileLoop(return_block);
+    loop_header_->SwapSuccessors();  // Move the loop exit to the "else" successor.
 
     // Provide boiler-plate instructions.
-    parameter_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                      dex::TypeIndex(0),
-                                                      0,
-                                                      DataType::Type::kReference);
-    entry_->AddInstruction(parameter_);
+    parameter_ = MakeParam(DataType::Type::kReference);
     int_constant_ = graph_->GetIntConstant(42);
     float_constant_ = graph_->GetFloatConstant(42.0f);
-    loop_preheader_->AddInstruction(new (GetAllocator()) HGoto());
-    loop_header_->AddInstruction(new (GetAllocator()) HIf(parameter_));
-    loop_body_->AddInstruction(new (GetAllocator()) HGoto());
-    return_->AddInstruction(new (GetAllocator()) HReturnVoid());
-    exit_->AddInstruction(new (GetAllocator()) HExit());
+    MakeIf(loop_header_, parameter_);
   }
 
   // Performs LICM optimizations (after proper set up).
@@ -96,16 +64,10 @@ class LICMTest : public OptimizingUnitTest {
     LICM(graph_, side_effects, nullptr).Run();
   }
 
-  // General building fields.
-  HGraph* graph_;
-
   // Specific basic blocks.
-  HBasicBlock* entry_;
   HBasicBlock* loop_preheader_;
   HBasicBlock* loop_header_;
   HBasicBlock* loop_body_;
-  HBasicBlock* return_;
-  HBasicBlock* exit_;
 
   HInstruction* parameter_;  // "this"
   HInstruction* int_constant_;
@@ -120,20 +82,10 @@ TEST_F(LICMTest, FieldHoisting) {
   BuildLoop();
 
   // Populate the loop with instructions: set/get field with different types.
-  HInstruction* get_field = new (GetAllocator()) HInstanceFieldGet(parameter_,
-                                                                   nullptr,
-                                                                   DataType::Type::kInt64,
-                                                                   MemberOffset(10),
-                                                                   false,
-                                                                   kUnknownFieldIndex,
-                                                                   kUnknownClassDefIndex,
-                                                                   graph_->GetDexFile(),
-                                                                   0);
-  loop_body_->InsertInstructionBefore(get_field, loop_body_->GetLastInstruction());
-  HInstruction* set_field = new (GetAllocator()) HInstanceFieldSet(
-      parameter_, int_constant_, nullptr, DataType::Type::kInt32, MemberOffset(20),
-      false, kUnknownFieldIndex, kUnknownClassDefIndex, graph_->GetDexFile(), 0);
-  loop_body_->InsertInstructionBefore(set_field, loop_body_->GetLastInstruction());
+  HInstruction* get_field =
+      MakeIFieldGet(loop_body_, parameter_, DataType::Type::kInt64, MemberOffset(10));
+  HInstruction* set_field =
+     MakeIFieldSet(loop_body_, parameter_, int_constant_, DataType::Type::kInt32, MemberOffset(20));
 
   EXPECT_EQ(get_field->GetBlock(), loop_body_);
   EXPECT_EQ(set_field->GetBlock(), loop_body_);
@@ -147,27 +99,9 @@ TEST_F(LICMTest, NoFieldHoisting) {
 
   // Populate the loop with instructions: set/get field with same types.
   ScopedNullHandle<mirror::DexCache> dex_cache;
-  HInstruction* get_field = new (GetAllocator()) HInstanceFieldGet(parameter_,
-                                                                   nullptr,
-                                                                   DataType::Type::kInt64,
-                                                                   MemberOffset(10),
-                                                                   false,
-                                                                   kUnknownFieldIndex,
-                                                                   kUnknownClassDefIndex,
-                                                                   graph_->GetDexFile(),
-                                                                   0);
-  loop_body_->InsertInstructionBefore(get_field, loop_body_->GetLastInstruction());
-  HInstruction* set_field = new (GetAllocator()) HInstanceFieldSet(parameter_,
-                                                                   get_field,
-                                                                   nullptr,
-                                                                   DataType::Type::kInt64,
-                                                                   MemberOffset(10),
-                                                                   false,
-                                                                   kUnknownFieldIndex,
-                                                                   kUnknownClassDefIndex,
-                                                                   graph_->GetDexFile(),
-                                                                   0);
-  loop_body_->InsertInstructionBefore(set_field, loop_body_->GetLastInstruction());
+  HInstruction* get_field =
+      MakeIFieldGet(loop_body_, parameter_, DataType::Type::kInt64, MemberOffset(10));
+  HInstruction* set_field = MakeIFieldSet(loop_body_, parameter_, get_field, MemberOffset(10));
 
   EXPECT_EQ(get_field->GetBlock(), loop_body_);
   EXPECT_EQ(set_field->GetBlock(), loop_body_);
@@ -180,12 +114,10 @@ TEST_F(LICMTest, ArrayHoisting) {
   BuildLoop();
 
   // Populate the loop with instructions: set/get array with different types.
-  HInstruction* get_array = new (GetAllocator()) HArrayGet(
-      parameter_, int_constant_, DataType::Type::kInt32, 0);
-  loop_body_->InsertInstructionBefore(get_array, loop_body_->GetLastInstruction());
-  HInstruction* set_array = new (GetAllocator()) HArraySet(
-      parameter_, int_constant_, float_constant_, DataType::Type::kFloat32, 0);
-  loop_body_->InsertInstructionBefore(set_array, loop_body_->GetLastInstruction());
+  HInstruction* get_array =
+      MakeArrayGet(loop_body_, parameter_, int_constant_, DataType::Type::kInt32);
+  HInstruction* set_array = MakeArraySet(
+      loop_body_, parameter_, int_constant_, float_constant_, DataType::Type::kFloat32);
 
   EXPECT_EQ(get_array->GetBlock(), loop_body_);
   EXPECT_EQ(set_array->GetBlock(), loop_body_);
@@ -198,12 +130,10 @@ TEST_F(LICMTest, NoArrayHoisting) {
   BuildLoop();
 
   // Populate the loop with instructions: set/get array with same types.
-  HInstruction* get_array = new (GetAllocator()) HArrayGet(
-      parameter_, int_constant_, DataType::Type::kFloat32, 0);
-  loop_body_->InsertInstructionBefore(get_array, loop_body_->GetLastInstruction());
-  HInstruction* set_array = new (GetAllocator()) HArraySet(
-      parameter_, get_array, float_constant_, DataType::Type::kFloat32, 0);
-  loop_body_->InsertInstructionBefore(set_array, loop_body_->GetLastInstruction());
+  HInstruction* get_array =
+      MakeArrayGet(loop_body_, parameter_, int_constant_, DataType::Type::kFloat32);
+  HInstruction* set_array =
+      MakeArraySet(loop_body_, parameter_, get_array, float_constant_, DataType::Type::kFloat32);
 
   EXPECT_EQ(get_array->GetBlock(), loop_body_);
   EXPECT_EQ(set_array->GetBlock(), loop_body_);
diff --git a/compiler/optimizing/load_store_analysis_test.cc b/compiler/optimizing/load_store_analysis_test.cc
index 90185579e3..b6a7cd9c76 100644
--- a/compiler/optimizing/load_store_analysis_test.cc
+++ b/compiler/optimizing/load_store_analysis_test.cc
@@ -42,50 +42,23 @@ class LoadStoreAnalysisTest : public CommonCompilerTest, public OptimizingUnitTe
   LoadStoreAnalysisTest() {
     use_boot_image_ = true;  // Make the Runtime creation cheaper.
   }
-
-  AdjacencyListGraph SetupFromAdjacencyList(
-      const std::string_view entry_name,
-      const std::string_view exit_name,
-      const std::vector<AdjacencyListGraph::Edge>& adj) {
-    return AdjacencyListGraph(graph_, GetAllocator(), entry_name, exit_name, adj);
-  }
 };
 
 TEST_F(LoadStoreAnalysisTest, ArrayHeapLocations) {
-  CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-
-  // entry:
-  // array         ParameterValue
-  // index         ParameterValue
-  // c1            IntConstant
-  // c2            IntConstant
-  // c3            IntConstant
-  // array_get1    ArrayGet [array, c1]
-  // array_get2    ArrayGet [array, c2]
-  // array_set1    ArraySet [array, c1, c3]
-  // array_set2    ArraySet [array, index, c3]
-  HInstruction* array = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* index = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32);
+  HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
+
+  // entry
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+  HInstruction* index = MakeParam(DataType::Type::kInt32);
   HInstruction* c1 = graph_->GetIntConstant(1);
   HInstruction* c2 = graph_->GetIntConstant(2);
   HInstruction* c3 = graph_->GetIntConstant(3);
-  HInstruction* array_get1 = new (GetAllocator()) HArrayGet(array, c1, DataType::Type::kInt32, 0);
-  HInstruction* array_get2 = new (GetAllocator()) HArrayGet(array, c2, DataType::Type::kInt32, 0);
-  HInstruction* array_set1 =
-      new (GetAllocator()) HArraySet(array, c1, c3, DataType::Type::kInt32, 0);
-  HInstruction* array_set2 =
-      new (GetAllocator()) HArraySet(array, index, c3, DataType::Type::kInt32, 0);
-  entry->AddInstruction(array);
-  entry->AddInstruction(index);
-  entry->AddInstruction(array_get1);
-  entry->AddInstruction(array_get2);
-  entry->AddInstruction(array_set1);
-  entry->AddInstruction(array_set2);
+
+  // main
+  HInstruction* array_get1 = MakeArrayGet(main, array, c1, DataType::Type::kInt32);
+  HInstruction* array_get2 = MakeArrayGet(main, array, c2, DataType::Type::kInt32);
+  HInstruction* array_set1 = MakeArraySet(main, array, c1, c3, DataType::Type::kInt32);
+  HInstruction* array_set2 = MakeArraySet(main, array, index, c3, DataType::Type::kInt32);
 
   // Test HeapLocationCollector initialization.
   // Should be no heap locations, no operations on the heap.
@@ -96,7 +69,7 @@ TEST_F(LoadStoreAnalysisTest, ArrayHeapLocations) {
 
   // Test that after visiting the graph_, it must see following heap locations
   // array[c1], array[c2], array[index]; and it should see heap stores.
-  heap_location_collector.VisitBasicBlock(entry);
+  heap_location_collector.VisitBasicBlock(main);
   ASSERT_EQ(heap_location_collector.GetNumberOfHeapLocations(), 3U);
   ASSERT_TRUE(heap_location_collector.HasHeapStores());
 
@@ -136,55 +109,18 @@ TEST_F(LoadStoreAnalysisTest, ArrayHeapLocations) {
 }
 
 TEST_F(LoadStoreAnalysisTest, FieldHeapLocations) {
-  CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-
-  // entry:
-  // object              ParameterValue
-  // c1                  IntConstant
-  // set_field10         InstanceFieldSet [object, c1, 10]
-  // get_field10         InstanceFieldGet [object, 10]
-  // get_field20         InstanceFieldGet [object, 20]
+  HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
 
+  // entry
+  HInstruction* object = MakeParam(DataType::Type::kReference);
   HInstruction* c1 = graph_->GetIntConstant(1);
-  HInstruction* object = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                              dex::TypeIndex(0),
-                                                              0,
-                                                              DataType::Type::kReference);
-  HInstanceFieldSet* set_field10 = new (GetAllocator()) HInstanceFieldSet(object,
-                                                                          c1,
-                                                                          nullptr,
-                                                                          DataType::Type::kInt32,
-                                                                          MemberOffset(32),
-                                                                          false,
-                                                                          kUnknownFieldIndex,
-                                                                          kUnknownClassDefIndex,
-                                                                          graph_->GetDexFile(),
-                                                                          0);
-  HInstanceFieldGet* get_field10 = new (GetAllocator()) HInstanceFieldGet(object,
-                                                                          nullptr,
-                                                                          DataType::Type::kInt32,
-                                                                          MemberOffset(32),
-                                                                          false,
-                                                                          kUnknownFieldIndex,
-                                                                          kUnknownClassDefIndex,
-                                                                          graph_->GetDexFile(),
-                                                                          0);
-  HInstanceFieldGet* get_field20 = new (GetAllocator()) HInstanceFieldGet(object,
-                                                                          nullptr,
-                                                                          DataType::Type::kInt32,
-                                                                          MemberOffset(20),
-                                                                          false,
-                                                                          kUnknownFieldIndex,
-                                                                          kUnknownClassDefIndex,
-                                                                          graph_->GetDexFile(),
-                                                                          0);
-  entry->AddInstruction(object);
-  entry->AddInstruction(set_field10);
-  entry->AddInstruction(get_field10);
-  entry->AddInstruction(get_field20);
+
+  // main
+  HInstanceFieldSet* set_field10 = MakeIFieldSet(main, object, c1, MemberOffset(10));
+  HInstanceFieldGet* get_field10 =
+      MakeIFieldGet(main, object, DataType::Type::kInt32, MemberOffset(10));
+  HInstanceFieldGet* get_field20 =
+      MakeIFieldGet(main, object, DataType::Type::kInt32, MemberOffset(20));
 
   // Test HeapLocationCollector initialization.
   // Should be no heap locations, no operations on the heap.
@@ -195,7 +131,7 @@ TEST_F(LoadStoreAnalysisTest, FieldHeapLocations) {
 
   // Test that after visiting the graph, it must see following heap locations
   // object.field10, object.field20 and it should see heap stores.
-  heap_location_collector.VisitBasicBlock(entry);
+  heap_location_collector.VisitBasicBlock(main);
   ASSERT_EQ(heap_location_collector.GetNumberOfHeapLocations(), 2U);
   ASSERT_TRUE(heap_location_collector.HasHeapStores());
 
@@ -217,59 +153,37 @@ TEST_F(LoadStoreAnalysisTest, FieldHeapLocations) {
 }
 
 TEST_F(LoadStoreAnalysisTest, ArrayIndexAliasingTest) {
-  CreateGraph();
-  AdjacencyListGraph blks(
-      SetupFromAdjacencyList("entry", "exit", {{"entry", "body"}, {"body", "exit"}}));
-  HBasicBlock* body = blks.Get("body");
-
-  HInstruction* array = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* index = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32);
+  HBasicBlock* body = InitEntryMainExitGraphWithReturnVoid();
+
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+  HInstruction* index = MakeParam(DataType::Type::kInt32);
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c1 = graph_->GetIntConstant(1);
   HInstruction* c_neg1 = graph_->GetIntConstant(-1);
-  HInstruction* add0 = new (GetAllocator()) HAdd(DataType::Type::kInt32, index, c0);
-  HInstruction* add1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, index, c1);
-  HInstruction* sub0 = new (GetAllocator()) HSub(DataType::Type::kInt32, index, c0);
-  HInstruction* sub1 = new (GetAllocator()) HSub(DataType::Type::kInt32, index, c1);
-  HInstruction* sub_neg1 = new (GetAllocator()) HSub(DataType::Type::kInt32, index, c_neg1);
-  HInstruction* rev_sub1 = new (GetAllocator()) HSub(DataType::Type::kInt32, c1, index);
-  HInstruction* arr_set1 = new (GetAllocator()) HArraySet(array, c0, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set2 = new (GetAllocator()) HArraySet(array, c1, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set3 =
-      new (GetAllocator()) HArraySet(array, add0, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set4 =
-      new (GetAllocator()) HArraySet(array, add1, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set5 =
-      new (GetAllocator()) HArraySet(array, sub0, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set6 =
-      new (GetAllocator()) HArraySet(array, sub1, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set7 =
-      new (GetAllocator()) HArraySet(array, rev_sub1, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set8 =
-      new (GetAllocator()) HArraySet(array, sub_neg1, c0, DataType::Type::kInt32, 0);
-
-  body->AddInstruction(array);
-  body->AddInstruction(index);
-  body->AddInstruction(add0);
-  body->AddInstruction(add1);
-  body->AddInstruction(sub0);
-  body->AddInstruction(sub1);
-  body->AddInstruction(sub_neg1);
-  body->AddInstruction(rev_sub1);
-
-  body->AddInstruction(arr_set1);  // array[0] = c0
-  body->AddInstruction(arr_set2);  // array[1] = c0
-  body->AddInstruction(arr_set3);  // array[i+0] = c0
-  body->AddInstruction(arr_set4);  // array[i+1] = c0
-  body->AddInstruction(arr_set5);  // array[i-0] = c0
-  body->AddInstruction(arr_set6);  // array[i-1] = c0
-  body->AddInstruction(arr_set7);  // array[1-i] = c0
-  body->AddInstruction(arr_set8);  // array[i-(-1)] = c0
-
-  body->AddInstruction(new (GetAllocator()) HReturnVoid());
-
+  HInstruction* add0 = MakeBinOp<HAdd>(body, DataType::Type::kInt32, index, c0);
+  HInstruction* add1 = MakeBinOp<HAdd>(body, DataType::Type::kInt32, index, c1);
+  HInstruction* sub0 = MakeBinOp<HSub>(body, DataType::Type::kInt32, index, c0);
+  HInstruction* sub1 = MakeBinOp<HSub>(body, DataType::Type::kInt32, index, c1);
+  HInstruction* sub_neg1 = MakeBinOp<HSub>(body, DataType::Type::kInt32, index, c_neg1);
+  HInstruction* rev_sub1 = MakeBinOp<HSub>(body, DataType::Type::kInt32, c1, index);
+  // array[0] = c0
+  HInstruction* arr_set1 = MakeArraySet(body, array, c0, c0, DataType::Type::kInt32);
+  // array[1] = c0
+  HInstruction* arr_set2 = MakeArraySet(body, array, c1, c0, DataType::Type::kInt32);
+  // array[i+0] = c0
+  HInstruction* arr_set3 = MakeArraySet(body, array, add0, c0, DataType::Type::kInt32);
+  // array[i+1] = c0
+  HInstruction* arr_set4 = MakeArraySet(body, array, add1, c0, DataType::Type::kInt32);
+  // array[i-0] = c0
+  HInstruction* arr_set5 = MakeArraySet(body, array, sub0, c0, DataType::Type::kInt32);
+  // array[i-1] = c0
+  HInstruction* arr_set6 = MakeArraySet(body, array, sub1, c0, DataType::Type::kInt32);
+  // array[1-i] = c0
+  HInstruction* arr_set7 = MakeArraySet(body, array, rev_sub1, c0, DataType::Type::kInt32);
+  // array[i-(-1)] = c0
+  HInstruction* arr_set8 = MakeArraySet(body, array, sub_neg1, c0, DataType::Type::kInt32);
+
+  graph_->ComputeDominanceInformation();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   LoadStoreAnalysis lsa(graph_, nullptr, &allocator);
   lsa.Run();
@@ -312,132 +226,44 @@ TEST_F(LoadStoreAnalysisTest, ArrayIndexAliasingTest) {
 }
 
 TEST_F(LoadStoreAnalysisTest, ArrayAliasingTest) {
-  CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-  graph_->BuildDominatorTree();
+  HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
 
-  HInstruction* array = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* index = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32);
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+  HInstruction* index = MakeParam(DataType::Type::kInt32);
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c1 = graph_->GetIntConstant(1);
   HInstruction* c6 = graph_->GetIntConstant(6);
   HInstruction* c8 = graph_->GetIntConstant(8);
 
-  HInstruction* arr_set_0 = new (GetAllocator()) HArraySet(array,
-                                                           c0,
-                                                           c0,
-                                                           DataType::Type::kInt32,
-                                                           0);
-  HInstruction* arr_set_1 = new (GetAllocator()) HArraySet(array,
-                                                           c1,
-                                                           c0,
-                                                           DataType::Type::kInt32,
-                                                           0);
-  HInstruction* arr_set_i = new (GetAllocator()) HArraySet(array,
-                                                           index,
-                                                           c0,
-                                                           DataType::Type::kInt32,
-                                                           0);
+  HInstruction* arr_set_0 = MakeArraySet(main, array, c0, c0, DataType::Type::kInt32);
+  HInstruction* arr_set_1 = MakeArraySet(main, array, c1, c0, DataType::Type::kInt32);
+  HInstruction* arr_set_i = MakeArraySet(main, array, index, c0, DataType::Type::kInt32);
 
   HVecOperation* v1 = new (GetAllocator()) HVecReplicateScalar(GetAllocator(),
                                                                c1,
                                                                DataType::Type::kInt32,
                                                                4,
                                                                kNoDexPc);
+  AddOrInsertInstruction(main, v1);
   HVecOperation* v2 = new (GetAllocator()) HVecReplicateScalar(GetAllocator(),
                                                                c1,
                                                                DataType::Type::kInt32,
                                                                2,
                                                                kNoDexPc);
-  HInstruction* i_add6 = new (GetAllocator()) HAdd(DataType::Type::kInt32, index, c6);
-  HInstruction* i_add8 = new (GetAllocator()) HAdd(DataType::Type::kInt32, index, c8);
-
-  HInstruction* vstore_0 = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      c0,
-      v1,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      4,
-      kNoDexPc);
-  HInstruction* vstore_1 = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      c1,
-      v1,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      4,
-      kNoDexPc);
-  HInstruction* vstore_8 = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      c8,
-      v1,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      4,
-      kNoDexPc);
-  HInstruction* vstore_i = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      index,
-      v1,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      4,
-      kNoDexPc);
-  HInstruction* vstore_i_add6 = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      i_add6,
-      v1,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      4,
-      kNoDexPc);
-  HInstruction* vstore_i_add8 = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      i_add8,
-      v1,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      4,
-      kNoDexPc);
-  HInstruction* vstore_i_add6_vlen2 = new (GetAllocator()) HVecStore(
-      GetAllocator(),
-      array,
-      i_add6,
-      v2,
-      DataType::Type::kInt32,
-      SideEffects::ArrayWriteOfType(DataType::Type::kInt32),
-      2,
-      kNoDexPc);
-
-  entry->AddInstruction(array);
-  entry->AddInstruction(index);
-
-  entry->AddInstruction(arr_set_0);
-  entry->AddInstruction(arr_set_1);
-  entry->AddInstruction(arr_set_i);
-  entry->AddInstruction(v1);
-  entry->AddInstruction(v2);
-  entry->AddInstruction(i_add6);
-  entry->AddInstruction(i_add8);
-  entry->AddInstruction(vstore_0);
-  entry->AddInstruction(vstore_1);
-  entry->AddInstruction(vstore_8);
-  entry->AddInstruction(vstore_i);
-  entry->AddInstruction(vstore_i_add6);
-  entry->AddInstruction(vstore_i_add8);
-  entry->AddInstruction(vstore_i_add6_vlen2);
+  AddOrInsertInstruction(main, v2);
+  HInstruction* i_add6 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c6);
+  HInstruction* i_add8 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c8);
+
+  HInstruction* vstore_0 = MakeVecStore(main, array, c0, v1, DataType::Type::kInt32);
+  HInstruction* vstore_1 = MakeVecStore(main, array, c1, v1, DataType::Type::kInt32);
+  HInstruction* vstore_8 = MakeVecStore(main, array, c8, v1, DataType::Type::kInt32);
+  HInstruction* vstore_i = MakeVecStore(main, array, index, v1, DataType::Type::kInt32);
+  HInstruction* vstore_i_add6 = MakeVecStore(main, array, i_add6, v1, DataType::Type::kInt32);
+  HInstruction* vstore_i_add8 = MakeVecStore(main, array, i_add8, v1, DataType::Type::kInt32);
+  HInstruction* vstore_i_add6_vlen2 =
+      MakeVecStore(main, array, i_add6, v2, DataType::Type::kInt32, /*vector_lengt=*/ 2);
 
+  graph_->BuildDominatorTree();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   LoadStoreAnalysis lsa(graph_, nullptr, &allocator);
   lsa.Run();
@@ -524,16 +350,10 @@ TEST_F(LoadStoreAnalysisTest, ArrayAliasingTest) {
 }
 
 TEST_F(LoadStoreAnalysisTest, ArrayIndexCalculationOverflowTest) {
-  CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
-  graph_->BuildDominatorTree();
+  HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
 
-  HInstruction* array = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* index = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32);
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+  HInstruction* index = MakeParam(DataType::Type::kInt32);
 
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c_0x80000000 = graph_->GetIntConstant(0x80000000);
@@ -543,61 +363,30 @@ TEST_F(LoadStoreAnalysisTest, ArrayIndexCalculationOverflowTest) {
   HInstruction* c_0x80000001 = graph_->GetIntConstant(0x80000001);
 
   // `index+0x80000000` and `index-0x80000000` array indices MAY alias.
-  HInstruction* add_0x80000000 = new (GetAllocator()) HAdd(
-      DataType::Type::kInt32, index, c_0x80000000);
-  HInstruction* sub_0x80000000 = new (GetAllocator()) HSub(
-      DataType::Type::kInt32, index, c_0x80000000);
-  HInstruction* arr_set_1 = new (GetAllocator()) HArraySet(
-      array, add_0x80000000, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set_2 = new (GetAllocator()) HArraySet(
-      array, sub_0x80000000, c0, DataType::Type::kInt32, 0);
+  HInstruction* add_0x80000000 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c_0x80000000);
+  HInstruction* sub_0x80000000 = MakeBinOp<HSub>(main, DataType::Type::kInt32, index, c_0x80000000);
+  HInstruction* arr_set_1 = MakeArraySet(main, array, add_0x80000000, c0, DataType::Type::kInt32);
+  HInstruction* arr_set_2 = MakeArraySet(main, array, sub_0x80000000, c0, DataType::Type::kInt32);
 
   // `index+0x10` and `index-0xFFFFFFF0` array indices MAY alias.
-  HInstruction* add_0x10 = new (GetAllocator()) HAdd(DataType::Type::kInt32, index, c_0x10);
-  HInstruction* sub_0xFFFFFFF0 = new (GetAllocator()) HSub(
-      DataType::Type::kInt32, index, c_0xFFFFFFF0);
-  HInstruction* arr_set_3 = new (GetAllocator()) HArraySet(
-      array, add_0x10, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set_4 = new (GetAllocator()) HArraySet(
-      array, sub_0xFFFFFFF0, c0, DataType::Type::kInt32, 0);
+  HInstruction* add_0x10 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c_0x10);
+  HInstruction* sub_0xFFFFFFF0 = MakeBinOp<HSub>(main, DataType::Type::kInt32, index, c_0xFFFFFFF0);
+  HInstruction* arr_set_3 = MakeArraySet(main, array, add_0x10, c0, DataType::Type::kInt32);
+  HInstruction* arr_set_4 = MakeArraySet(main, array, sub_0xFFFFFFF0, c0, DataType::Type::kInt32);
 
   // `index+0x7FFFFFFF` and `index-0x80000001` array indices MAY alias.
-  HInstruction* add_0x7FFFFFFF = new (GetAllocator()) HAdd(
-      DataType::Type::kInt32, index, c_0x7FFFFFFF);
-  HInstruction* sub_0x80000001 = new (GetAllocator()) HSub(
-      DataType::Type::kInt32, index, c_0x80000001);
-  HInstruction* arr_set_5 = new (GetAllocator()) HArraySet(
-      array, add_0x7FFFFFFF, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set_6 = new (GetAllocator()) HArraySet(
-      array, sub_0x80000001, c0, DataType::Type::kInt32, 0);
+  HInstruction* add_0x7FFFFFFF = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c_0x7FFFFFFF);
+  HInstruction* sub_0x80000001 = MakeBinOp<HSub>(main, DataType::Type::kInt32, index, c_0x80000001);
+  HInstruction* arr_set_5 = MakeArraySet(main, array, add_0x7FFFFFFF, c0, DataType::Type::kInt32);
+  HInstruction* arr_set_6 = MakeArraySet(main, array, sub_0x80000001, c0, DataType::Type::kInt32);
 
   // `index+0` and `index-0` array indices MAY alias.
-  HInstruction* add_0 = new (GetAllocator()) HAdd(DataType::Type::kInt32, index, c0);
-  HInstruction* sub_0 = new (GetAllocator()) HSub(DataType::Type::kInt32, index, c0);
-  HInstruction* arr_set_7 = new (GetAllocator()) HArraySet(
-      array, add_0, c0, DataType::Type::kInt32, 0);
-  HInstruction* arr_set_8 = new (GetAllocator()) HArraySet(
-      array, sub_0, c0, DataType::Type::kInt32, 0);
-
-  entry->AddInstruction(array);
-  entry->AddInstruction(index);
-  entry->AddInstruction(add_0x80000000);
-  entry->AddInstruction(sub_0x80000000);
-  entry->AddInstruction(add_0x10);
-  entry->AddInstruction(sub_0xFFFFFFF0);
-  entry->AddInstruction(add_0x7FFFFFFF);
-  entry->AddInstruction(sub_0x80000001);
-  entry->AddInstruction(add_0);
-  entry->AddInstruction(sub_0);
-  entry->AddInstruction(arr_set_1);
-  entry->AddInstruction(arr_set_2);
-  entry->AddInstruction(arr_set_3);
-  entry->AddInstruction(arr_set_4);
-  entry->AddInstruction(arr_set_5);
-  entry->AddInstruction(arr_set_6);
-  entry->AddInstruction(arr_set_7);
-  entry->AddInstruction(arr_set_8);
+  HInstruction* add_0 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c0);
+  HInstruction* sub_0 = MakeBinOp<HSub>(main, DataType::Type::kInt32, index, c0);
+  HInstruction* arr_set_7 = MakeArraySet(main, array, add_0, c0, DataType::Type::kInt32);
+  HInstruction* arr_set_8 = MakeArraySet(main, array, sub_0, c0, DataType::Type::kInt32);
 
+  graph_->BuildDominatorTree();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   LoadStoreAnalysis lsa(graph_, nullptr, &allocator);
   lsa.Run();
@@ -643,10 +432,7 @@ TEST_F(LoadStoreAnalysisTest, ArrayIndexCalculationOverflowTest) {
 }
 
 TEST_F(LoadStoreAnalysisTest, TestHuntOriginalRef) {
-  CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
-  graph_->AddBlock(entry);
-  graph_->SetEntryBlock(entry);
+  HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
 
   // Different ways where orignal array reference are transformed & passed to ArrayGet.
   // ParameterValue --> ArrayGet
@@ -654,44 +440,24 @@ TEST_F(LoadStoreAnalysisTest, TestHuntOriginalRef) {
   // ParameterValue --> BoundType --> NullCheck --> ArrayGet
   // ParameterValue --> BoundType --> NullCheck --> IntermediateAddress --> ArrayGet
   HInstruction* c1 = graph_->GetIntConstant(1);
-  HInstruction* array = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                             dex::TypeIndex(0),
-                                                             0,
-                                                             DataType::Type::kReference);
-  HInstruction* array_get1 = new (GetAllocator()) HArrayGet(array,
-                                                            c1,
-                                                            DataType::Type::kInt32,
-                                                            0);
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+
+  HInstruction* array_get1 = MakeArrayGet(main, array, c1, DataType::Type::kInt32);
 
   HInstruction* bound_type = new (GetAllocator()) HBoundType(array);
-  HInstruction* array_get2 = new (GetAllocator()) HArrayGet(bound_type,
-                                                            c1,
-                                                            DataType::Type::kInt32,
-                                                            0);
+  AddOrInsertInstruction(main, bound_type);
+  HInstruction* array_get2 = MakeArrayGet(main, bound_type, c1, DataType::Type::kInt32);
 
-  HInstruction* null_check = new (GetAllocator()) HNullCheck(bound_type, 0);
-  HInstruction* array_get3 = new (GetAllocator()) HArrayGet(null_check,
-                                                            c1,
-                                                            DataType::Type::kInt32,
-                                                            0);
+  HInstruction* null_check = MakeNullCheck(main, bound_type);
+  HInstruction* array_get3 = MakeArrayGet(main, null_check, c1, DataType::Type::kInt32);
 
   HInstruction* inter_addr = new (GetAllocator()) HIntermediateAddress(null_check, c1, 0);
-  HInstruction* array_get4 = new (GetAllocator()) HArrayGet(inter_addr,
-                                                            c1,
-                                                            DataType::Type::kInt32,
-                                                            0);
-  entry->AddInstruction(array);
-  entry->AddInstruction(array_get1);
-  entry->AddInstruction(bound_type);
-  entry->AddInstruction(array_get2);
-  entry->AddInstruction(null_check);
-  entry->AddInstruction(array_get3);
-  entry->AddInstruction(inter_addr);
-  entry->AddInstruction(array_get4);
+  AddOrInsertInstruction(main, inter_addr);
+  HInstruction* array_get4 = MakeArrayGet(main, inter_addr, c1, DataType::Type::kInt32);
 
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   HeapLocationCollector heap_location_collector(graph_, &allocator);
-  heap_location_collector.VisitBasicBlock(entry);
+  heap_location_collector.VisitBasicBlock(main);
 
   // Test that the HeapLocationCollector should be able to tell
   // that there is only ONE array location, no matter how many
@@ -708,7 +474,7 @@ TEST_F(LoadStoreAnalysisTest, TestHuntOriginalRef) {
   ASSERT_EQ(loc1, loc4);
 }
 
-// // ENTRY
+// // IF_BLOCK
 // obj = new Obj();
 // if (parameter_value) {
 //   // LEFT
@@ -718,98 +484,28 @@ TEST_F(LoadStoreAnalysisTest, TestHuntOriginalRef) {
 //   obj.f0 = 0;
 //   call_func2(obj);
 // }
-// // EXIT
+// // RETURN_BLOCK
 // obj.f0;
 TEST_F(LoadStoreAnalysisTest, TotalEscape) {
-  CreateGraph();
-  AdjacencyListGraph blks(SetupFromAdjacencyList(
-      "entry",
-      "exit",
-      { { "entry", "left" }, { "entry", "right" }, { "left", "exit" }, { "right", "exit" } }));
-  HBasicBlock* entry = blks.Get("entry");
-  HBasicBlock* left = blks.Get("left");
-  HBasicBlock* right = blks.Get("right");
-  HBasicBlock* exit = blks.Get("exit");
-
-  HInstruction* bool_value = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kBool);
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  auto [if_block, left, right] = CreateDiamondPattern(return_block);
+
+  HInstruction* bool_value = MakeParam(DataType::Type::kBool);
   HInstruction* c0 = graph_->GetIntConstant(0);
-  HInstruction* cls = new (GetAllocator()) HLoadClass(graph_->GetCurrentMethod(),
-                                                      dex::TypeIndex(10),
-                                                      graph_->GetDexFile(),
-                                                      ScopedNullHandle<mirror::Class>(),
-                                                      false,
-                                                      0,
-                                                      false);
-  HInstruction* new_inst =
-      new (GetAllocator()) HNewInstance(cls,
-                                        0,
-                                        dex::TypeIndex(10),
-                                        graph_->GetDexFile(),
-                                        false,
-                                        QuickEntrypointEnum::kQuickAllocObjectInitialized);
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry->AddInstruction(bool_value);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(if_inst);
-
-  HInstruction* call_left = new (GetAllocator())
-      HInvokeStaticOrDirect(GetAllocator(),
-                            1,
-                            DataType::Type::kVoid,
-                            0,
-                            { nullptr, 0 },
-                            nullptr,
-                            {},
-                            InvokeType::kStatic,
-                            { nullptr, 0 },
-                            HInvokeStaticOrDirect::ClinitCheckRequirement::kNone,
-                            !graph_->IsDebuggable());
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  call_left->SetRawInputAt(0, new_inst);
-  left->AddInstruction(call_left);
-  left->AddInstruction(goto_left);
-
-  HInstruction* call_right = new (GetAllocator())
-      HInvokeStaticOrDirect(GetAllocator(),
-                            1,
-                            DataType::Type::kVoid,
-                            0,
-                            { nullptr, 0 },
-                            nullptr,
-                            {},
-                            InvokeType::kStatic,
-                            { nullptr, 0 },
-                            HInvokeStaticOrDirect::ClinitCheckRequirement::kNone,
-                            !graph_->IsDebuggable());
-  HInstruction* write_right = new (GetAllocator()) HInstanceFieldSet(new_inst,
-                                                                     c0,
-                                                                     nullptr,
-                                                                     DataType::Type::kInt32,
-                                                                     MemberOffset(32),
-                                                                     false,
-                                                                     0,
-                                                                     0,
-                                                                     graph_->GetDexFile(),
-                                                                     0);
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  call_right->SetRawInputAt(0, new_inst);
-  right->AddInstruction(write_right);
-  right->AddInstruction(call_right);
-  right->AddInstruction(goto_right);
-
-  HInstruction* read_final = new (GetAllocator()) HInstanceFieldGet(new_inst,
-                                                                    nullptr,
-                                                                    DataType::Type::kInt32,
-                                                                    MemberOffset(32),
-                                                                    false,
-                                                                    0,
-                                                                    0,
-                                                                    graph_->GetDexFile(),
-                                                                    0);
-  exit->AddInstruction(read_final);
 
+  HInstruction* cls = MakeLoadClass(if_block);
+  HInstruction* new_inst = MakeNewInstance(if_block, cls);
+  MakeIf(if_block, bool_value);
+
+  HInstruction* call_left = MakeInvokeStatic(left, DataType::Type::kVoid, {new_inst});
+
+  HInstruction* call_right = MakeInvokeStatic(right, DataType::Type::kVoid, {new_inst});
+  HInstruction* write_right = MakeIFieldSet(right, new_inst, c0, MemberOffset(32));
+
+  HInstruction* read_final =
+      MakeIFieldGet(return_block, new_inst, DataType::Type::kInt32, MemberOffset(32));
+
+  graph_->ComputeDominanceInformation();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   LoadStoreAnalysis lsa(graph_, nullptr, &allocator);
   lsa.Run();
@@ -819,52 +515,21 @@ TEST_F(LoadStoreAnalysisTest, TotalEscape) {
   ASSERT_FALSE(info->IsSingleton());
 }
 
-// // ENTRY
+// // MAIN
 // obj = new Obj();
 // obj.foo = 0;
-// // EXIT
 // return obj;
 TEST_F(LoadStoreAnalysisTest, TotalEscape2) {
-  CreateGraph();
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry", "exit", { { "entry", "exit" } }));
-  HBasicBlock* entry = blks.Get("entry");
-  HBasicBlock* exit = blks.Get("exit");
+  HBasicBlock* main = InitEntryMainExitGraph();
 
   HInstruction* c0 = graph_->GetIntConstant(0);
-  HInstruction* cls = new (GetAllocator()) HLoadClass(graph_->GetCurrentMethod(),
-                                                      dex::TypeIndex(10),
-                                                      graph_->GetDexFile(),
-                                                      ScopedNullHandle<mirror::Class>(),
-                                                      false,
-                                                      0,
-                                                      false);
-  HInstruction* new_inst =
-      new (GetAllocator()) HNewInstance(cls,
-                                        0,
-                                        dex::TypeIndex(10),
-                                        graph_->GetDexFile(),
-                                        false,
-                                        QuickEntrypointEnum::kQuickAllocObjectInitialized);
-
-  HInstruction* write_start = new (GetAllocator()) HInstanceFieldSet(new_inst,
-                                                                     c0,
-                                                                     nullptr,
-                                                                     DataType::Type::kInt32,
-                                                                     MemberOffset(32),
-                                                                     false,
-                                                                     0,
-                                                                     0,
-                                                                     graph_->GetDexFile(),
-                                                                     0);
-  HInstruction* goto_inst = new (GetAllocator()) HGoto();
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(write_start);
-  entry->AddInstruction(goto_inst);
-
-  HInstruction* return_final = new (GetAllocator()) HReturn(new_inst);
-  exit->AddInstruction(return_final);
 
+  HInstruction* cls = MakeLoadClass(main);
+  HInstruction* new_inst = MakeNewInstance(main, cls);
+  HInstruction* write_start = MakeIFieldSet(main, new_inst, c0, MemberOffset(32));
+  MakeReturn(main, new_inst);
+
+  graph_->ComputeDominanceInformation();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   LoadStoreAnalysis lsa(graph_, nullptr, &allocator);
   lsa.Run();
@@ -874,7 +539,7 @@ TEST_F(LoadStoreAnalysisTest, TotalEscape2) {
   ASSERT_TRUE(info->IsSingletonAndNonRemovable());
 }
 
-// // ENTRY
+// // TOP
 // obj = new Obj();
 // if (parameter_value) {
 //   // HIGH_LEFT
@@ -892,154 +557,39 @@ TEST_F(LoadStoreAnalysisTest, TotalEscape2) {
 //   // LOW_RIGHT
 //   obj.f0 = 1;
 // }
-// // EXIT
+// // BOTTOM
 // obj.f0
 TEST_F(LoadStoreAnalysisTest, DoubleDiamondEscape) {
-  CreateGraph();
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry",
-                                                 "exit",
-                                                 { { "entry", "high_left" },
-                                                   { "entry", "high_right" },
-                                                   { "low_left", "exit" },
-                                                   { "low_right", "exit" },
-                                                   { "high_right", "mid" },
-                                                   { "high_left", "mid" },
-                                                   { "mid", "low_left" },
-                                                   { "mid", "low_right" } }));
-  HBasicBlock* entry = blks.Get("entry");
-  HBasicBlock* high_left = blks.Get("high_left");
-  HBasicBlock* high_right = blks.Get("high_right");
-  HBasicBlock* mid = blks.Get("mid");
-  HBasicBlock* low_left = blks.Get("low_left");
-  HBasicBlock* low_right = blks.Get("low_right");
-  HBasicBlock* exit = blks.Get("exit");
-
-  HInstruction* bool_value1 = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kBool);
-  HInstruction* bool_value2 = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(1), 2, DataType::Type::kBool);
+  HBasicBlock* bottom = InitEntryMainExitGraphWithReturnVoid();
+  auto [mid, low_left, low_right] = CreateDiamondPattern(bottom);
+  auto [top, high_left, high_right] = CreateDiamondPattern(mid);
+
+  HInstruction* bool_value1 = MakeParam(DataType::Type::kBool);
+  HInstruction* bool_value2 = MakeParam(DataType::Type::kBool);
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c2 = graph_->GetIntConstant(2);
-  HInstruction* cls = new (GetAllocator()) HLoadClass(graph_->GetCurrentMethod(),
-                                                      dex::TypeIndex(10),
-                                                      graph_->GetDexFile(),
-                                                      ScopedNullHandle<mirror::Class>(),
-                                                      false,
-                                                      0,
-                                                      false);
-  HInstruction* new_inst =
-      new (GetAllocator()) HNewInstance(cls,
-                                        0,
-                                        dex::TypeIndex(10),
-                                        graph_->GetDexFile(),
-                                        false,
-                                        QuickEntrypointEnum::kQuickAllocObjectInitialized);
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value1);
-  entry->AddInstruction(bool_value1);
-  entry->AddInstruction(bool_value2);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(if_inst);
-
-  HInstruction* call_left = new (GetAllocator())
-      HInvokeStaticOrDirect(GetAllocator(),
-                            1,
-                            DataType::Type::kVoid,
-                            0,
-                            { nullptr, 0 },
-                            nullptr,
-                            {},
-                            InvokeType::kStatic,
-                            { nullptr, 0 },
-                            HInvokeStaticOrDirect::ClinitCheckRequirement::kNone,
-                            !graph_->IsDebuggable());
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  call_left->SetRawInputAt(0, new_inst);
-  high_left->AddInstruction(call_left);
-  high_left->AddInstruction(goto_left);
-
-  HInstruction* write_right = new (GetAllocator()) HInstanceFieldSet(new_inst,
-                                                                     c0,
-                                                                     nullptr,
-                                                                     DataType::Type::kInt32,
-                                                                     MemberOffset(32),
-                                                                     false,
-                                                                     0,
-                                                                     0,
-                                                                     graph_->GetDexFile(),
-                                                                     0);
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  high_right->AddInstruction(write_right);
-  high_right->AddInstruction(goto_right);
-
-  HInstruction* read_mid = new (GetAllocator()) HInstanceFieldGet(new_inst,
-                                                                  nullptr,
-                                                                  DataType::Type::kInt32,
-                                                                  MemberOffset(32),
-                                                                  false,
-                                                                  0,
-                                                                  0,
-                                                                  graph_->GetDexFile(),
-                                                                  0);
-  HInstruction* mul_mid = new (GetAllocator()) HMul(DataType::Type::kInt32, read_mid, c2);
-  HInstruction* write_mid = new (GetAllocator()) HInstanceFieldSet(new_inst,
-                                                                   mul_mid,
-                                                                   nullptr,
-                                                                   DataType::Type::kInt32,
-                                                                   MemberOffset(32),
-                                                                   false,
-                                                                   0,
-                                                                   0,
-                                                                   graph_->GetDexFile(),
-                                                                   0);
-  HInstruction* if_mid = new (GetAllocator()) HIf(bool_value2);
-  mid->AddInstruction(read_mid);
-  mid->AddInstruction(mul_mid);
-  mid->AddInstruction(write_mid);
-  mid->AddInstruction(if_mid);
-
-  HInstruction* call_low_left = new (GetAllocator())
-      HInvokeStaticOrDirect(GetAllocator(),
-                            1,
-                            DataType::Type::kVoid,
-                            0,
-                            { nullptr, 0 },
-                            nullptr,
-                            {},
-                            InvokeType::kStatic,
-                            { nullptr, 0 },
-                            HInvokeStaticOrDirect::ClinitCheckRequirement::kNone,
-                            !graph_->IsDebuggable());
-  HInstruction* goto_low_left = new (GetAllocator()) HGoto();
-  call_low_left->SetRawInputAt(0, new_inst);
-  low_left->AddInstruction(call_low_left);
-  low_left->AddInstruction(goto_low_left);
-
-  HInstruction* write_low_right = new (GetAllocator()) HInstanceFieldSet(new_inst,
-                                                                         c0,
-                                                                         nullptr,
-                                                                         DataType::Type::kInt32,
-                                                                         MemberOffset(32),
-                                                                         false,
-                                                                         0,
-                                                                         0,
-                                                                         graph_->GetDexFile(),
-                                                                         0);
-  HInstruction* goto_low_right = new (GetAllocator()) HGoto();
-  low_right->AddInstruction(write_low_right);
-  low_right->AddInstruction(goto_low_right);
-
-  HInstruction* read_final = new (GetAllocator()) HInstanceFieldGet(new_inst,
-                                                                    nullptr,
-                                                                    DataType::Type::kInt32,
-                                                                    MemberOffset(32),
-                                                                    false,
-                                                                    0,
-                                                                    0,
-                                                                    graph_->GetDexFile(),
-                                                                    0);
-  exit->AddInstruction(read_final);
 
+  HInstruction* cls = MakeLoadClass(top);
+  HInstruction* new_inst = MakeNewInstance(top, cls);
+  MakeIf(top, bool_value1);
+
+  HInstruction* call_left = MakeInvokeStatic(high_left, DataType::Type::kVoid, {new_inst});
+
+  HInstruction* write_right = MakeIFieldSet(high_right, new_inst, c0, MemberOffset(32));
+
+  HInstruction* read_mid = MakeIFieldGet(mid, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  HInstruction* mul_mid = MakeBinOp<HMul>(mid, DataType::Type::kInt32, read_mid, c2);
+  HInstruction* write_mid = MakeIFieldSet(mid, new_inst, mul_mid, MemberOffset(32));
+  MakeIf(mid, bool_value2);
+
+  HInstruction* call_low_left = MakeInvokeStatic(low_left, DataType::Type::kVoid, {new_inst});
+
+  HInstruction* write_low_right = MakeIFieldSet(low_right, new_inst, c0, MemberOffset(32));
+
+  HInstruction* read_final =
+      MakeIFieldGet(bottom, new_inst, DataType::Type::kInt32, MemberOffset(32));
+
+  graph_->ComputeDominanceInformation();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
   LoadStoreAnalysis lsa(graph_, nullptr, &allocator);
   lsa.Run();
@@ -1049,7 +599,7 @@ TEST_F(LoadStoreAnalysisTest, DoubleDiamondEscape) {
   ASSERT_FALSE(info->IsSingleton());
 }
 
-// // ENTRY
+// // START
 // Obj new_inst = new Obj();
 // new_inst.foo = 12;
 // Obj obj;
@@ -1073,134 +623,37 @@ TEST_F(LoadStoreAnalysisTest, DoubleDiamondEscape) {
 //   // RIGHT
 //   out = obj_param;
 // }
-// // EXIT
+// // BRETURN
 // // Can't do anything with this since we don't have good tracking for the heap-locations
 // // out = phi[param, phi[new_inst, param]]
 // return out.foo
 TEST_F(LoadStoreAnalysisTest, PartialPhiPropagation1) {
-  CreateGraph();
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry",
-                                                 "exit",
-                                                 {{"entry", "left"},
-                                                  {"entry", "right"},
-                                                  {"left", "left_left"},
-                                                  {"left", "left_right"},
-                                                  {"left_left", "left_merge"},
-                                                  {"left_right", "left_merge"},
-                                                  {"left_merge", "breturn"},
-                                                  {"right", "breturn"},
-                                                  {"breturn", "exit"}}));
-#define GET_BLOCK(name) HBasicBlock* name = blks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(exit);
-  GET_BLOCK(breturn);
-  GET_BLOCK(left);
-  GET_BLOCK(right);
-  GET_BLOCK(left_left);
-  GET_BLOCK(left_right);
-  GET_BLOCK(left_merge);
-#undef GET_BLOCK
+  HBasicBlock* breturn = InitEntryMainExitGraph();
+  auto [start, left_merge, right] = CreateDiamondPattern(breturn);
+  auto [left, left_left, left_right] = CreateDiamondPattern(left_merge);
   EnsurePredecessorOrder(breturn, {left_merge, right});
   EnsurePredecessorOrder(left_merge, {left_left, left_right});
-  HInstruction* param1 = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kBool);
-  HInstruction* param2 = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(1), 2, DataType::Type::kBool);
-  HInstruction* obj_param = new (GetAllocator())
-      HParameterValue(graph_->GetDexFile(), dex::TypeIndex(10), 3, DataType::Type::kReference);
+  HInstruction* param1 = MakeParam(DataType::Type::kBool);
+  HInstruction* param2 = MakeParam(DataType::Type::kBool);
+  HInstruction* obj_param = MakeParam(DataType::Type::kReference);
   HInstruction* c12 = graph_->GetIntConstant(12);
-  HInstruction* cls = new (GetAllocator()) HLoadClass(graph_->GetCurrentMethod(),
-                                                      dex::TypeIndex(10),
-                                                      graph_->GetDexFile(),
-                                                      ScopedNullHandle<mirror::Class>(),
-                                                      false,
-                                                      0,
-                                                      false);
-  HInstruction* new_inst =
-      new (GetAllocator()) HNewInstance(cls,
-                                        0,
-                                        dex::TypeIndex(10),
-                                        graph_->GetDexFile(),
-                                        false,
-                                        QuickEntrypointEnum::kQuickAllocObjectInitialized);
-  HInstruction* store = new (GetAllocator()) HInstanceFieldSet(new_inst,
-                                                               c12,
-                                                               nullptr,
-                                                               DataType::Type::kInt32,
-                                                               MemberOffset(32),
-                                                               false,
-                                                               0,
-                                                               0,
-                                                               graph_->GetDexFile(),
-                                                               0);
-  HInstruction* if_param1 = new (GetAllocator()) HIf(param1);
-  entry->AddInstruction(param1);
-  entry->AddInstruction(param2);
-  entry->AddInstruction(obj_param);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(store);
-  entry->AddInstruction(if_param1);
-  ArenaVector<HInstruction*> current_locals({}, GetAllocator()->Adapter(kArenaAllocInstruction));
-  ManuallyBuildEnvFor(cls, &current_locals);
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* if_left = new (GetAllocator()) HIf(param2);
-  left->AddInstruction(if_left);
-
-  HInstruction* goto_left_left = new (GetAllocator()) HGoto();
-  left_left->AddInstruction(goto_left_left);
-
-  HInstruction* goto_left_right = new (GetAllocator()) HGoto();
-  left_right->AddInstruction(goto_left_right);
-
-  HPhi* left_phi =
-      new (GetAllocator()) HPhi(GetAllocator(), kNoRegNumber, 2, DataType::Type::kReference);
-  HInstruction* call_left = new (GetAllocator())
-      HInvokeStaticOrDirect(GetAllocator(),
-                            1,
-                            DataType::Type::kVoid,
-                            0,
-                            {nullptr, 0},
-                            nullptr,
-                            {},
-                            InvokeType::kStatic,
-                            {nullptr, 0},
-                            HInvokeStaticOrDirect::ClinitCheckRequirement::kNone,
-                            !graph_->IsDebuggable());
-  HInstruction* goto_left_merge = new (GetAllocator()) HGoto();
-  left_phi->SetRawInputAt(0, obj_param);
-  left_phi->SetRawInputAt(1, new_inst);
-  call_left->SetRawInputAt(0, left_phi);
-  left_merge->AddPhi(left_phi);
-  left_merge->AddInstruction(call_left);
-  left_merge->AddInstruction(goto_left_merge);
+
+  HInstruction* cls = MakeLoadClass(start);
+  HInstruction* new_inst = MakeNewInstance(start, cls);
+  HInstruction* store = MakeIFieldSet(start, new_inst, c12, MemberOffset(32));
+  MakeIf(start, param1);
+
+  MakeIf(left, param2);
+
+  HPhi* left_phi = MakePhi(left_merge, {obj_param, new_inst});
+  HInstruction* call_left = MakeInvokeStatic(left_merge, DataType::Type::kVoid, {left_phi});
+  MakeGoto(left_merge);
   left_phi->SetCanBeNull(true);
-  call_left->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(goto_right);
-
-  HPhi* return_phi =
-      new (GetAllocator()) HPhi(GetAllocator(), kNoRegNumber, 2, DataType::Type::kReference);
-  HInstruction* read_exit = new (GetAllocator()) HInstanceFieldGet(return_phi,
-                                                                   nullptr,
-                                                                   DataType::Type::kReference,
-                                                                   MemberOffset(32),
-                                                                   false,
-                                                                   0,
-                                                                   0,
-                                                                   graph_->GetDexFile(),
-                                                                   0);
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_exit);
-  return_phi->SetRawInputAt(0, left_phi);
-  return_phi->SetRawInputAt(1, obj_param);
-  breturn->AddPhi(return_phi);
-  breturn->AddInstruction(read_exit);
-  breturn->AddInstruction(return_exit);
-
-  HInstruction* exit_instruction = new (GetAllocator()) HExit();
-  exit->AddInstruction(exit_instruction);
+
+  HPhi* return_phi = MakePhi(breturn, {left_phi, obj_param});
+  HInstruction* read_exit =
+      MakeIFieldGet(breturn, return_phi, DataType::Type::kReference, MemberOffset(32));
+  MakeReturn(breturn, read_exit);
 
   graph_->ClearDominanceInformation();
   graph_->BuildDominatorTree();
diff --git a/compiler/optimizing/load_store_elimination.cc b/compiler/optimizing/load_store_elimination.cc
index bd38d8265c..c4b68e41c9 100644
--- a/compiler/optimizing/load_store_elimination.cc
+++ b/compiler/optimizing/load_store_elimination.cc
@@ -291,45 +291,6 @@ class LSEVisitor final : private HGraphDelegateVisitor {
     uint32_t heap_location_;
   };
 
-  struct Marker {};
-
-  class Value;
-
-  class PriorValueHolder {
-   public:
-    constexpr explicit PriorValueHolder(Value prior);
-
-    constexpr bool IsInstruction() const {
-      return std::holds_alternative<HInstruction*>(value_);
-    }
-    constexpr bool IsPhi() const {
-      return std::holds_alternative<PhiPlaceholder>(value_);
-    }
-    constexpr bool IsDefault() const {
-      return std::holds_alternative<Marker>(value_);
-    }
-    constexpr PhiPlaceholder GetPhiPlaceholder() const {
-      DCHECK(IsPhi());
-      return std::get<PhiPlaceholder>(value_);
-    }
-    constexpr HInstruction* GetInstruction() const {
-      DCHECK(IsInstruction());
-      return std::get<HInstruction*>(value_);
-    }
-
-    Value ToValue() const;
-    void Dump(std::ostream& oss) const;
-
-    constexpr bool Equals(PriorValueHolder other) const {
-      return value_ == other.value_;
-    }
-
-   private:
-    std::variant<Marker, HInstruction*, PhiPlaceholder> value_;
-  };
-
-  friend constexpr bool operator==(const Marker&, const Marker&);
-  friend constexpr bool operator==(const PriorValueHolder& p1, const PriorValueHolder& p2);
   friend constexpr bool operator==(const PhiPlaceholder& p1, const PhiPlaceholder& p2);
   friend std::ostream& operator<<(std::ostream& oss, const PhiPlaceholder& p2);
 
@@ -337,12 +298,9 @@ class LSEVisitor final : private HGraphDelegateVisitor {
    public:
     enum class ValuelessType {
       kInvalid,
-      kPureUnknown,
+      kUnknown,
       kDefault,
     };
-    struct MergedUnknownMarker {
-      PhiPlaceholder phi_;
-    };
     struct NeedsNonLoopPhiMarker {
       PhiPlaceholder phi_;
     };
@@ -358,20 +316,8 @@ class LSEVisitor final : private HGraphDelegateVisitor {
     // A heap location can be set to an unknown heap value when:
     // - it is coming from outside the method,
     // - it is killed due to aliasing, or side effects, or merging with an unknown value.
-    static constexpr Value PureUnknown() {
-      return Value(ValuelessType::kPureUnknown);
-    }
-
-    static constexpr Value PartialUnknown(Value old_value) {
-      if (old_value.IsInvalid() || old_value.IsPureUnknown()) {
-        return PureUnknown();
-      } else {
-        return Value(PriorValueHolder(old_value));
-      }
-    }
-
-    static constexpr Value MergedUnknown(PhiPlaceholder phi_placeholder) {
-      return Value(MergedUnknownMarker{phi_placeholder});
+    static constexpr Value Unknown() {
+      return Value(ValuelessType::kUnknown);
     }
 
     // Default heap value after an allocation.
@@ -406,21 +352,9 @@ class LSEVisitor final : private HGraphDelegateVisitor {
              GetValuelessType() == ValuelessType::kInvalid;
     }
 
-    bool IsPartialUnknown() const {
-      return std::holds_alternative<PriorValueHolder>(value_);
-    }
-
-    bool IsMergedUnknown() const {
-      return std::holds_alternative<MergedUnknownMarker>(value_);
-    }
-
-    bool IsPureUnknown() const {
-      return std::holds_alternative<ValuelessType>(value_) &&
-             GetValuelessType() == ValuelessType::kPureUnknown;
-    }
-
     bool IsUnknown() const {
-      return IsPureUnknown() || IsMergedUnknown() || IsPartialUnknown();
+      return std::holds_alternative<ValuelessType>(value_) &&
+             GetValuelessType() == ValuelessType::kUnknown;
     }
 
     bool IsDefault() const {
@@ -449,34 +383,17 @@ class LSEVisitor final : private HGraphDelegateVisitor {
       return std::get<HInstruction*>(value_);
     }
 
-    PriorValueHolder GetPriorValue() const {
-      DCHECK(IsPartialUnknown());
-      return std::get<PriorValueHolder>(value_);
-    }
-
     PhiPlaceholder GetPhiPlaceholder() const {
-      DCHECK(NeedsPhi() || IsMergedUnknown());
+      DCHECK(NeedsPhi());
       if (NeedsNonLoopPhi()) {
         return std::get<NeedsNonLoopPhiMarker>(value_).phi_;
-      } else if (NeedsLoopPhi()) {
-        return std::get<NeedsLoopPhiMarker>(value_).phi_;
       } else {
-        return std::get<MergedUnknownMarker>(value_).phi_;
+        return std::get<NeedsLoopPhiMarker>(value_).phi_;
       }
     }
 
-    uint32_t GetMergeBlockId() const {
-      DCHECK(IsMergedUnknown()) << this;
-      return std::get<MergedUnknownMarker>(value_).phi_.GetBlockId();
-    }
-
-    HBasicBlock* GetMergeBlock(const HGraph* graph) const {
-      DCHECK(IsMergedUnknown()) << *this;
-      return graph->GetBlocks()[GetMergeBlockId()];
-    }
-
     size_t GetHeapLocation() const {
-      DCHECK(IsMergedUnknown() || NeedsPhi()) << this;
+      DCHECK(NeedsPhi()) << this;
       return GetPhiPlaceholder().GetHeapLocation();
     }
 
@@ -496,10 +413,8 @@ class LSEVisitor final : private HGraphDelegateVisitor {
    private:
     using ValueHolder = std::variant<ValuelessType,
                                      HInstruction*,
-                                     MergedUnknownMarker,
                                      NeedsNonLoopPhiMarker,
-                                     NeedsLoopPhiMarker,
-                                     PriorValueHolder>;
+                                     NeedsLoopPhiMarker>;
     constexpr ValuelessType GetValuelessType() const {
       return std::get<ValuelessType>(value_);
     }
@@ -517,8 +432,6 @@ class LSEVisitor final : private HGraphDelegateVisitor {
                                    const Value::NeedsLoopPhiMarker& p2);
   friend constexpr bool operator==(const Value::NeedsNonLoopPhiMarker& p1,
                                    const Value::NeedsNonLoopPhiMarker& p2);
-  friend constexpr bool operator==(const Value::MergedUnknownMarker& p1,
-                                   const Value::MergedUnknownMarker& p2);
 
   // Get Phi placeholder index for access to `phi_placeholder_replacements_`
   // and "visited" bit vectors during depth-first searches.
@@ -684,10 +597,10 @@ class LSEVisitor final : private HGraphDelegateVisitor {
   // Keep the store referenced by the instruction, or all stores that feed a Phi placeholder.
   // This is necessary if the stored heap value can be observed.
   void KeepStores(Value value) {
-    if (value.IsPureUnknown() || value.IsPartialUnknown()) {
+    if (value.IsUnknown()) {
       return;
     }
-    if (value.IsMergedUnknown() || value.NeedsPhi()) {
+    if (value.NeedsPhi()) {
       phi_placeholders_to_search_for_kept_stores_.SetBit(PhiPlaceholderIndex(value));
     } else {
       HInstruction* instruction = value.GetInstruction();
@@ -709,10 +622,10 @@ class LSEVisitor final : private HGraphDelegateVisitor {
         // But we can have a phi placeholder here marking multiple stores to keep.
         DCHECK(!heap_values[i].stored_by.IsInstruction());
         KeepStores(heap_values[i].stored_by);
-        heap_values[i].stored_by = Value::PureUnknown();
+        heap_values[i].stored_by = Value::Unknown();
       } else if (heap_location_collector_.MayAlias(i, loc_index)) {
         KeepStores(heap_values[i].stored_by);
-        heap_values[i].stored_by = Value::PureUnknown();
+        heap_values[i].stored_by = Value::Unknown();
       }
     }
   }
@@ -832,8 +745,8 @@ class LSEVisitor final : private HGraphDelegateVisitor {
         heap_values_for_[instruction->GetBlock()->GetBlockId()];
     for (size_t i = 0u, size = heap_values.size(); i != size; ++i) {
       KeepStores(heap_values[i].stored_by);
-      heap_values[i].stored_by = Value::PureUnknown();
-      heap_values[i].value = Value::PartialUnknown(heap_values[i].value);
+      heap_values[i].stored_by = Value::Unknown();
+      heap_values[i].value = Value::Unknown();
     }
 
     // Note that there's no need to record the load as subsequent acquire loads shouldn't be
@@ -853,7 +766,7 @@ class LSEVisitor final : private HGraphDelegateVisitor {
         heap_values_for_[instruction->GetBlock()->GetBlockId()];
     for (size_t i = 0u, size = heap_values.size(); i != size; ++i) {
       KeepStores(heap_values[i].stored_by);
-      heap_values[i].stored_by = Value::PureUnknown();
+      heap_values[i].stored_by = Value::Unknown();
     }
 
     // Note that there's no need to record the store as subsequent release store shouldn't be
@@ -995,7 +908,7 @@ class LSEVisitor final : private HGraphDelegateVisitor {
       }
       if (observable) {
         KeepStores(*stored_by);
-        *stored_by = Value::PureUnknown();
+        *stored_by = Value::Unknown();
       }
     }
   }
@@ -1007,7 +920,7 @@ class LSEVisitor final : private HGraphDelegateVisitor {
       ReferenceInfo* ref_info = heap_location_collector_.GetHeapLocation(i)->GetReferenceInfo();
       if (must_keep_stores || IsEscapingObject(ref_info)) {
         KeepStores(heap_values[i].stored_by);
-        heap_values[i].stored_by = Value::PureUnknown();
+        heap_values[i].stored_by = Value::Unknown();
       }
     }
   }
@@ -1096,11 +1009,11 @@ class LSEVisitor final : private HGraphDelegateVisitor {
         if (can_throw || side_effects.DoesAnyRead() || side_effects.DoesAnyWrite()) {
           // Previous stores may become visible (read) and/or impossible for LSE to track (write).
           KeepStores(heap_values[i].stored_by);
-          heap_values[i].stored_by = Value::PureUnknown();
+          heap_values[i].stored_by = Value::Unknown();
         }
         if (side_effects.DoesAnyWrite()) {
           // The value may be clobbered.
-          heap_values[i].value = Value::PartialUnknown(heap_values[i].value);
+          heap_values[i].value = Value::Unknown();
         }
       }
     }
@@ -1160,16 +1073,16 @@ class LSEVisitor final : private HGraphDelegateVisitor {
           // Instance fields except the header fields are set to default heap values.
           // The shadow$_monitor_ field is set to the default value however.
           heap_values[i].value = Value::Default();
-          heap_values[i].stored_by = Value::PureUnknown();
+          heap_values[i].stored_by = Value::Unknown();
         } else if (MemberOffset(offset) == mirror::Object::ClassOffset()) {
           // The shadow$_klass_ field is special and has an actual value however.
           heap_values[i].value = Value::ForInstruction(new_instance->GetLoadClass());
-          heap_values[i].stored_by = Value::PureUnknown();
+          heap_values[i].stored_by = Value::Unknown();
         }
       } else if (inside_a_try || IsEscapingObject(info)) {
         // Since NewInstance can throw, we presume all previous stores could be visible.
         KeepStores(heap_values[i].stored_by);
-        heap_values[i].stored_by = Value::PureUnknown();
+        heap_values[i].stored_by = Value::Unknown();
       }
     }
   }
@@ -1200,11 +1113,11 @@ class LSEVisitor final : private HGraphDelegateVisitor {
       if (ref == new_array && location->GetIndex() != nullptr) {
         // Array elements are set to default heap values.
         heap_values[i].value = Value::Default();
-        heap_values[i].stored_by = Value::PureUnknown();
+        heap_values[i].stored_by = Value::Unknown();
       } else if (inside_a_try || IsEscapingObject(info)) {
         // Since NewArray can throw, we presume all previous stores could be visible.
         KeepStores(heap_values[i].stored_by);
-        heap_values[i].stored_by = Value::PureUnknown();
+        heap_values[i].stored_by = Value::Unknown();
       }
     }
   }
@@ -1272,20 +1185,12 @@ class LSEVisitor final : private HGraphDelegateVisitor {
 
   Phase current_phase_;
 
-  friend struct ScopedRestoreHeapValues;
-
   friend std::ostream& operator<<(std::ostream& os, const Value& v);
-  friend std::ostream& operator<<(std::ostream& os, const PriorValueHolder& v);
   friend std::ostream& operator<<(std::ostream& oss, const LSEVisitor::Phase& phase);
 
   DISALLOW_COPY_AND_ASSIGN(LSEVisitor);
 };
 
-std::ostream& operator<<(std::ostream& oss, const LSEVisitor::PriorValueHolder& p) {
-  p.Dump(oss);
-  return oss;
-}
-
 std::ostream& operator<<(std::ostream& oss, const LSEVisitor::Phase& phase) {
   switch (phase) {
     case LSEVisitor::Phase::kLoadElimination:
@@ -1295,39 +1200,6 @@ std::ostream& operator<<(std::ostream& oss, const LSEVisitor::Phase& phase) {
   }
 }
 
-void LSEVisitor::PriorValueHolder::Dump(std::ostream& oss) const {
-  if (IsDefault()) {
-    oss << "Default";
-  } else if (IsPhi()) {
-    oss << "Phi: " << GetPhiPlaceholder();
-  } else {
-    oss << "Instruction: " << *GetInstruction();
-  }
-}
-
-constexpr LSEVisitor::PriorValueHolder::PriorValueHolder(Value val)
-    : value_(Marker{}) {
-  DCHECK(!val.IsInvalid() && !val.IsPureUnknown());
-  if (val.IsPartialUnknown()) {
-    value_ = val.GetPriorValue().value_;
-  } else if (val.IsMergedUnknown() || val.NeedsPhi()) {
-    value_ = val.GetPhiPlaceholder();
-  } else if (val.IsInstruction()) {
-    value_ = val.GetInstruction();
-  } else {
-    DCHECK(val.IsDefault());
-  }
-}
-
-constexpr bool operator==(const LSEVisitor::Marker&, const LSEVisitor::Marker&) {
-  return true;
-}
-
-constexpr bool operator==(const LSEVisitor::PriorValueHolder& p1,
-                          const LSEVisitor::PriorValueHolder& p2) {
-  return p1.Equals(p2);
-}
-
 constexpr bool operator==(const LSEVisitor::PhiPlaceholder& p1,
                           const LSEVisitor::PhiPlaceholder& p2) {
   return p1.Equals(p2);
@@ -1343,26 +1215,11 @@ constexpr bool operator==(const LSEVisitor::Value::NeedsNonLoopPhiMarker& p1,
   return p1.phi_ == p2.phi_;
 }
 
-constexpr bool operator==(const LSEVisitor::Value::MergedUnknownMarker& p1,
-                          const LSEVisitor::Value::MergedUnknownMarker& p2) {
-  return p1.phi_ == p2.phi_;
-}
-
 std::ostream& operator<<(std::ostream& oss, const LSEVisitor::PhiPlaceholder& p) {
   p.Dump(oss);
   return oss;
 }
 
-LSEVisitor::Value LSEVisitor::PriorValueHolder::ToValue() const {
-  if (IsDefault()) {
-    return Value::Default();
-  } else if (IsPhi()) {
-    return Value::ForLoopPhiPlaceholder(GetPhiPlaceholder());
-  } else {
-    return Value::ForInstruction(GetInstruction());
-  }
-}
-
 constexpr bool LSEVisitor::Value::ExactEquals(LSEVisitor::Value other) const {
   return value_ == other.value_;
 }
@@ -1386,20 +1243,14 @@ std::ostream& LSEVisitor::Value::Dump(std::ostream& os) const {
     switch (GetValuelessType()) {
       case ValuelessType::kDefault:
         return os << "Default";
-      case ValuelessType::kPureUnknown:
-        return os << "PureUnknown";
+      case ValuelessType::kUnknown:
+        return os << "Unknown";
       case ValuelessType::kInvalid:
         return os << "Invalid";
     }
-  } else if (IsPartialUnknown()) {
-    return os << "PartialUnknown[" << GetPriorValue() << "]";
   } else if (IsInstruction()) {
     return os << "Instruction[id: " << GetInstruction()->GetId()
               << ", block: " << GetInstruction()->GetBlock()->GetBlockId() << "]";
-  } else if (IsMergedUnknown()) {
-    return os << "MergedUnknown[block: " << GetPhiPlaceholder().GetBlockId()
-              << ", heap_loc: " << GetPhiPlaceholder().GetHeapLocation() << "]";
-
   } else if (NeedsLoopPhi()) {
     return os << "NeedsLoopPhi[block: " << GetPhiPlaceholder().GetBlockId()
               << ", heap_loc: " << GetPhiPlaceholder().GetHeapLocation() << "]";
@@ -1490,7 +1341,7 @@ LSEVisitor::Value LSEVisitor::PrepareLoopStoredBy(HBasicBlock* block, size_t idx
   if (ref_info->IsSingleton() &&
       block->GetLoopInformation()->Contains(*reference->GetBlock()) &&
       !is_finalizable) {
-    return Value::PureUnknown();
+    return Value::Unknown();
   }
   PhiPlaceholder phi_placeholder = GetPhiPlaceholder(block->GetBlockId(), idx);
   return Value::ForLoopPhiPlaceholder(phi_placeholder);
@@ -1510,13 +1361,9 @@ void LSEVisitor::PrepareLoopRecords(HBasicBlock* block) {
   // Don't eliminate loads in irreducible loops.
   if (block->GetLoopInformation()->IsIrreducible()) {
     heap_values.resize(num_heap_locations,
-                       {/*value=*/Value::Invalid(), /*stored_by=*/Value::PureUnknown()});
+                       {/*value=*/Value::Unknown(), /*stored_by=*/Value::Unknown()});
     // Also keep the stores before the loop header, including in blocks that were not visited yet.
-    bool is_osr = GetGraph()->IsCompilingOsr();
     for (size_t idx = 0u; idx != num_heap_locations; ++idx) {
-      heap_values[idx].value =
-          is_osr ? Value::PureUnknown()
-                 : Value::MergedUnknown(GetPhiPlaceholder(block->GetBlockId(), idx));
       KeepStores(Value::ForLoopPhiPlaceholder(GetPhiPlaceholder(block->GetBlockId(), idx)));
     }
     return;
@@ -1541,12 +1388,8 @@ LSEVisitor::Value LSEVisitor::MergePredecessorValues(HBasicBlock* block, size_t
       // Value is the same. No need to update our merged value.
       continue;
     } else if (pred_value.IsUnknown() || merged_value.IsUnknown()) {
-      // If one is unknown and the other is a different type of unknown
-      PhiPlaceholder phi_placeholder = GetPhiPlaceholder(block->GetBlockId(), idx);
-      merged_value = Value::MergedUnknown(phi_placeholder);
-      // We know that at least one of the merge points is unknown (and both are
-      // not pure-unknowns since that's captured above). This means that the
-      // overall value needs to be a MergedUnknown. Just return that.
+      // If one is unknown and the other is not, the merged value is unknown.
+      merged_value = Value::Unknown();
       break;
     } else {
       // There are conflicting known values. We may still be able to replace loads with a Phi.
@@ -1556,8 +1399,6 @@ LSEVisitor::Value LSEVisitor::MergePredecessorValues(HBasicBlock* block, size_t
       merged_value = ReplacementOrValue(Value::ForPhiPlaceholder(phi_placeholder, needs_loop_phi));
     }
   }
-  DCHECK_IMPLIES(merged_value.IsPureUnknown(), block->GetPredecessors().size() <= 1)
-      << merged_value << " in " << GetGraph()->PrettyMethod();
   return merged_value;
 }
 
@@ -1575,7 +1416,7 @@ void LSEVisitor::MergePredecessorRecords(HBasicBlock* block) {
   if (block->GetPredecessors().empty() || block->IsCatchBlock()) {
     DCHECK_IMPLIES(block->GetPredecessors().empty(), block->IsEntryBlock());
     heap_values.resize(num_heap_locations,
-                       {/*value=*/Value::PureUnknown(), /*stored_by=*/Value::PureUnknown()});
+                       {/*value=*/Value::Unknown(), /*stored_by=*/Value::Unknown()});
     return;
   }
 
@@ -1674,8 +1515,8 @@ void LSEVisitor::MaterializeNonLoopPhis(PhiPlaceholder phi_placeholder, DataType
     phi_inputs.clear();
     for (HBasicBlock* predecessor : current_block->GetPredecessors()) {
       Value pred_value = ReplacementOrValue(heap_values_for_[predecessor->GetBlockId()][idx].value);
-      DCHECK(!pred_value.IsPureUnknown()) << pred_value << " block " << current_block->GetBlockId()
-                                          << " pred: " << predecessor->GetBlockId();
+      DCHECK(!pred_value.IsUnknown()) << pred_value << " block " << current_block->GetBlockId()
+                                      << " pred: " << predecessor->GetBlockId();
       if (pred_value.NeedsNonLoopPhi()) {
         // We need to process the Phi placeholder first.
         work_queue.push_back(pred_value.GetPhiPlaceholder());
@@ -1710,7 +1551,7 @@ void LSEVisitor::VisitGetLocation(HInstruction* instruction, size_t idx) {
   loads_and_stores_.push_back({ instruction, idx });
   if ((record.value.IsDefault() || record.value.NeedsNonLoopPhi()) &&
       !IsDefaultOrPhiAllowedForLoad(instruction)) {
-    record.value = Value::PureUnknown();
+    record.value = Value::Unknown();
   }
   if (record.value.IsDefault()) {
     KeepStores(record.stored_by);
@@ -1815,8 +1656,8 @@ void LSEVisitor::VisitSetLocation(HInstruction* instruction, size_t idx, HInstru
     }
     // Kill heap locations that may alias and keep previous stores to these locations.
     KeepStores(heap_values[i].stored_by);
-    heap_values[i].stored_by = Value::PureUnknown();
-    heap_values[i].value = Value::PartialUnknown(heap_values[i].value);
+    heap_values[i].stored_by = Value::Unknown();
+    heap_values[i].value = Value::Unknown();
   }
 }
 
@@ -2167,7 +2008,7 @@ bool LSEVisitor::MaterializeLoopPhis(ArrayRef<const size_t> phi_placeholder_inde
       HInstruction* phi = phi_it.Current();
       DCHECK_EQ(phi->InputCount(), predecessors.size());
       ArrayRef<HUserRecord<HInstruction*>> phi_inputs = phi->GetInputRecords();
-      auto cmp = [=](const HUserRecord<HInstruction*>& lhs, HBasicBlock* rhs) {
+      auto cmp = [=, this](const HUserRecord<HInstruction*>& lhs, HBasicBlock* rhs) {
         Value value = ReplacementOrValue(heap_values_for_[rhs->GetBlockId()][idx].value);
         if (value.NeedsPhi()) {
           DCHECK(value.GetPhiPlaceholder() == phi_placeholder);
@@ -2327,8 +2168,7 @@ bool LSEVisitor::MaterializeLoopPhis(const ArenaBitVector& phi_placeholders_to_m
       for (uint32_t matrix_index = 0; matrix_index != num_phi_placeholders; ++matrix_index) {
         if (dependencies[matrix_index]->IsBitSet(current_matrix_index)) {
           DCHECK(phi_placeholder_replacements_[phi_placeholder_indexes[matrix_index]].IsInvalid());
-          phi_placeholder_replacements_[phi_placeholder_indexes[matrix_index]] =
-              Value::PureUnknown();
+          phi_placeholder_replacements_[phi_placeholder_indexes[matrix_index]] = Value::Unknown();
         }
       }
       return false;
@@ -2398,8 +2238,7 @@ void LSEVisitor::ProcessLoopPhiWithUnknownInput(PhiPlaceholder loop_phi_with_unk
   DCHECK(!loads_requiring_loop_phi_.empty());
   size_t loop_phi_with_unknown_input_index = PhiPlaceholderIndex(loop_phi_with_unknown_input);
   DCHECK(phi_placeholder_replacements_[loop_phi_with_unknown_input_index].IsInvalid());
-  phi_placeholder_replacements_[loop_phi_with_unknown_input_index] =
-      Value::MergedUnknown(loop_phi_with_unknown_input);
+  phi_placeholder_replacements_[loop_phi_with_unknown_input_index] = Value::Unknown();
 
   uint32_t block_id = loop_phi_with_unknown_input.GetBlockId();
   const ArenaVector<HBasicBlock*> reverse_post_order = GetGraph()->GetReversePostOrder();
@@ -2430,8 +2269,7 @@ void LSEVisitor::ProcessLoopPhiWithUnknownInput(PhiPlaceholder loop_phi_with_unk
     Value value;
     if (block->IsLoopHeader()) {
       if (block->GetLoopInformation()->IsIrreducible()) {
-        PhiPlaceholder placeholder = GetPhiPlaceholder(block->GetBlockId(), idx);
-        value = Value::MergedUnknown(placeholder);
+        value = Value::Unknown();
       } else {
         value = PrepareLoopValue(block, idx);
       }
@@ -2506,7 +2344,7 @@ void LSEVisitor::ProcessLoopPhiWithUnknownInput(PhiPlaceholder loop_phi_with_unk
             // propagated as a value to this load) and store the load as the new heap value.
             found_unreplaceable_load = true;
             KeepStores(record->value);
-            record->value = Value::MergedUnknown(record->value.GetPhiPlaceholder());
+            record->value = Value::Unknown();
             local_heap_values[idx] = Value::ForInstruction(load_or_store);
           } else if (local_heap_values[idx].NeedsLoopPhi()) {
             // The load may still be replaced with a Phi later.
@@ -2684,9 +2522,9 @@ void LSEVisitor::FindOldValueForPhiPlaceholder(PhiPlaceholder phi_placeholder,
                   .size(),
               2u);
     // Mark the unreplacable placeholder as well as the input Phi placeholder as unreplaceable.
-    phi_placeholder_replacements_[PhiPlaceholderIndex(phi_placeholder)] = Value::PureUnknown();
+    phi_placeholder_replacements_[PhiPlaceholderIndex(phi_placeholder)] = Value::Unknown();
     phi_placeholder_replacements_[PhiPlaceholderIndex(*loop_phi_with_unknown_input)] =
-        Value::PureUnknown();
+        Value::Unknown();
     return;
   }
 
@@ -2697,57 +2535,7 @@ void LSEVisitor::FindOldValueForPhiPlaceholder(PhiPlaceholder phi_placeholder,
             !success);
 }
 
-struct ScopedRestoreHeapValues {
- public:
-  ScopedRestoreHeapValues(ArenaStack* alloc,
-                          size_t num_heap_locs,
-                          ScopedArenaVector<ScopedArenaVector<LSEVisitor::ValueRecord>>& to_restore)
-      : alloc_(alloc),
-        updated_values_(alloc_.Adapter(kArenaAllocLSE)),
-        to_restore_(to_restore) {
-    updated_values_.reserve(num_heap_locs * to_restore_.size());
-  }
-
-  ~ScopedRestoreHeapValues() {
-    for (const auto& rec : updated_values_) {
-      to_restore_[rec.blk_id][rec.heap_loc].value = rec.val_;
-    }
-  }
-
-  template<typename Func>
-  void ForEachRecord(Func&& func) {
-    for (size_t blk_id : Range(to_restore_.size())) {
-      for (size_t heap_loc : Range(to_restore_[blk_id].size())) {
-        LSEVisitor::ValueRecord* vr = &to_restore_[blk_id][heap_loc];
-        LSEVisitor::Value initial = vr->value;
-        func(vr);
-        if (!vr->value.ExactEquals(initial)) {
-          updated_values_.push_back({blk_id, heap_loc, initial});
-        }
-      }
-    }
-  }
-
- private:
-  struct UpdateRecord {
-    size_t blk_id;
-    size_t heap_loc;
-    LSEVisitor::Value val_;
-  };
-  ScopedArenaAllocator alloc_;
-  ScopedArenaVector<UpdateRecord> updated_values_;
-  ScopedArenaVector<ScopedArenaVector<LSEVisitor::ValueRecord>>& to_restore_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedRestoreHeapValues);
-};
-
 void LSEVisitor::FindStoresWritingOldValues() {
-  // Partial LSE relies on knowing the real heap-values not the
-  // store-replacement versions so we need to restore the map after removing
-  // stores.
-  ScopedRestoreHeapValues heap_vals(allocator_.GetArenaStack(),
-                                    heap_location_collector_.GetNumberOfHeapLocations(),
-                                    heap_values_for_);
   // The Phi placeholder replacements have so far been used for eliminating loads,
   // tracking values that would be stored if all stores were kept. As we want to
   // compare actual old values after removing unmarked stores, prune the Phi
@@ -2762,14 +2550,10 @@ void LSEVisitor::FindStoresWritingOldValues() {
   }
 
   // Update heap values at end of blocks.
-  heap_vals.ForEachRecord([&](ValueRecord* rec) {
-    UpdateValueRecordForStoreElimination(rec);
-  });
-
-  if (kIsDebugBuild) {
-    heap_vals.ForEachRecord([](ValueRecord* rec) {
-      DCHECK(!rec->value.NeedsNonLoopPhi()) << rec->value;
-    });
+  for (HBasicBlock* block : GetGraph()->GetReversePostOrder()) {
+    for (ValueRecord& value_record : heap_values_for_[block->GetBlockId()]) {
+      UpdateValueRecordForStoreElimination(&value_record);
+    }
   }
 
   // Use local allocator to reduce peak memory usage.
diff --git a/compiler/optimizing/load_store_elimination_test.cc b/compiler/optimizing/load_store_elimination_test.cc
index 0775051eb4..1e5c7082a4 100644
--- a/compiler/optimizing/load_store_elimination_test.cc
+++ b/compiler/optimizing/load_store_elimination_test.cc
@@ -93,11 +93,51 @@ class LoadStoreEliminationTestBase : public SuperTest, public OptimizingUnitTest
   void CreateEntryBlockInstructions() {
     HInstruction* c1 = graph_->GetIntConstant(1);
     HInstruction* c4 = graph_->GetIntConstant(4);
-    i_add1_ = new (GetAllocator()) HAdd(DataType::Type::kInt32, i_, c1);
-    i_add4_ = new (GetAllocator()) HAdd(DataType::Type::kInt32, i_, c4);
-    entry_block_->AddInstruction(i_add1_);
-    entry_block_->AddInstruction(i_add4_);
-    entry_block_->AddInstruction(new (GetAllocator()) HGoto());
+    i_add1_ = MakeBinOp<HAdd>(entry_block_, DataType::Type::kInt32, i_, c1);
+    i_add4_ = MakeBinOp<HAdd>(entry_block_, DataType::Type::kInt32, i_, c4);
+    MakeGoto(entry_block_);
+  }
+
+  // Create suspend check, linear loop variable and loop condition.
+  // The `HPhi` for the loop variable can be easily retrieved as the only `HPhi` in the loop block.
+  // The `HSuspendCheck` can be retrieved as the first non-Phi instruction from the loop block.
+  void MakeSimpleLoopInstructions(HBasicBlock* loop,
+                                  HBasicBlock* body,
+                                  std::initializer_list<HInstruction*> suspend_check_env = {}) {
+    CHECK(loop->GetInstructions().IsEmpty());
+    CHECK_IMPLIES(loop != body, body->IsSingleGoto());
+    HInstruction* c128 = graph_->GetIntConstant(128);
+    MakeSuspendCheck(loop, suspend_check_env);
+    auto [phi, increment] = MakeLinearLoopVar(loop, body, /*initial=*/ 0, /*increment=*/ 1);
+    HInstruction* cmp = MakeCondition(loop, kCondGE, phi, c128);
+    MakeIf(loop, cmp);
+  }
+
+  // Create a do-while loop with instructions:
+  //   i = 0;
+  //   do {
+  //     HSuspendCheck;
+  //     cmp = i < 128;
+  //     ++i;
+  //   } while (cmp);
+  // Return the pre-header and loop block.
+  std::tuple<HBasicBlock*, HBasicBlock*> CreateDoWhileLoopWithInstructions(
+      HBasicBlock* loop_exit, std::initializer_list<HInstruction*> suspend_check_env = {}) {
+    auto [pre_header, loop] = CreateDoWhileLoop(loop_exit);
+    MakeSimpleLoopInstructions(loop, loop, suspend_check_env);
+    return {pre_header, loop};
+  }
+
+  // Create a for loop with instructions:
+  //   for (int i = 0; i < 128; ++i) {
+  //     HSuspendCheck;
+  //   }
+  // Return the pre-header, header and body blocks.
+  std::tuple<HBasicBlock*, HBasicBlock*, HBasicBlock*> CreateForLoopWithInstructions(
+      HBasicBlock* loop_exit, std::initializer_list<HInstruction*> suspend_check_env = {}) {
+    auto [pre_header, loop_header, loop_body] = CreateWhileLoop(loop_exit);
+    MakeSimpleLoopInstructions(loop_header, loop_body, suspend_check_env);
+    return {pre_header, loop_header, loop_body};
   }
 
   // Create the major CFG used by tests:
@@ -112,46 +152,11 @@ class LoadStoreEliminationTestBase : public SuperTest, public OptimizingUnitTest
   //     exit
   void CreateTestControlFlowGraph() {
     InitGraphAndParameters();
-    pre_header_ = AddNewBlock();
-    loop_ = AddNewBlock();
-
-    entry_block_->ReplaceSuccessor(return_block_, pre_header_);
-    pre_header_->AddSuccessor(loop_);
-    loop_->AddSuccessor(loop_);
-    loop_->AddSuccessor(return_block_);
-
-    HInstruction* c0 = graph_->GetIntConstant(0);
-    HInstruction* c1 = graph_->GetIntConstant(1);
-    HInstruction* c128 = graph_->GetIntConstant(128);
-
     CreateEntryBlockInstructions();
-
-    // pre_header block
-    //   phi = 0;
-    phi_ = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-    loop_->AddPhi(phi_);
-    pre_header_->AddInstruction(new (GetAllocator()) HGoto());
-    phi_->AddInput(c0);
-
-    // loop block:
-    //   suspend_check
-    //   phi++;
-    //   if (phi >= 128)
-    suspend_check_ = new (GetAllocator()) HSuspendCheck();
-    HInstruction* inc_phi = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi_, c1);
-    HInstruction* cmp = new (GetAllocator()) HGreaterThanOrEqual(phi_, c128);
-    HInstruction* hif = new (GetAllocator()) HIf(cmp);
-    loop_->AddInstruction(suspend_check_);
-    loop_->AddInstruction(inc_phi);
-    loop_->AddInstruction(cmp);
-    loop_->AddInstruction(hif);
-    phi_->AddInput(inc_phi);
-
-    CreateEnvForSuspendCheck();
-  }
-
-  void CreateEnvForSuspendCheck() {
-    ManuallyBuildEnvFor(suspend_check_, {array_, i_, j_});
+    std::tie(pre_header_, loop_) =
+        CreateDoWhileLoopWithInstructions(return_block_, /*suspend_check_env=*/ {array_, i_, j_});
+    phi_ = loop_->GetFirstPhi()->AsPhi();
+    suspend_check_ = loop_->GetFirstInstruction()->AsSuspendCheck();
   }
 
   // Create the diamond-shaped CFG:
@@ -166,23 +171,10 @@ class LoadStoreEliminationTestBase : public SuperTest, public OptimizingUnitTest
     InitGraphAndParameters();
     CreateEntryBlockInstructions();
 
-    HBasicBlock* upper = AddNewBlock();
-    HBasicBlock* left = AddNewBlock();
-    HBasicBlock* right = AddNewBlock();
-
-    entry_block_->ReplaceSuccessor(return_block_, upper);
-    upper->AddSuccessor(left);
-    upper->AddSuccessor(right);
-    left->AddSuccessor(return_block_);
-    right->AddSuccessor(return_block_);
-
-    HInstruction* cmp = new (GetAllocator()) HGreaterThanOrEqual(i_, j_);
-    HInstruction* hif = new (GetAllocator()) HIf(cmp);
-    upper->AddInstruction(cmp);
-    upper->AddInstruction(hif);
+    auto [upper, left, right] = CreateDiamondPattern(return_block_);
 
-    left->AddInstruction(new (GetAllocator()) HGoto());
-    right->AddInstruction(new (GetAllocator()) HGoto());
+    HInstruction* cmp = MakeCondition(upper, kCondGE, i_, j_);
+    MakeIf(upper, cmp);
 
     return std::make_tuple(upper, left, right, return_block_);
   }
@@ -237,51 +229,14 @@ class LoadStoreEliminationTestBase : public SuperTest, public OptimizingUnitTest
     return vstore;
   }
 
-  // Add a HArrayGet instruction to the end of the provided basic block.
-  //
-  // Return: the created HArrayGet instruction.
-  HInstruction* AddArrayGet(HBasicBlock* block, HInstruction* array, HInstruction* index) {
-    DCHECK(block != nullptr);
-    DCHECK(array != nullptr);
-    DCHECK(index != nullptr);
-    HInstruction* get = new (GetAllocator()) HArrayGet(array, index, DataType::Type::kInt32, 0);
-    block->InsertInstructionBefore(get, block->GetLastInstruction());
-    return get;
-  }
-
-  // Add a HArraySet instruction to the end of the provided basic block.
-  // If no data is specified, generate HArraySet: array[index] = 1.
-  //
-  // Return: the created HArraySet instruction.
-  HInstruction* AddArraySet(HBasicBlock* block,
-                            HInstruction* array,
-                            HInstruction* index,
-                            HInstruction* data = nullptr) {
-    DCHECK(block != nullptr);
-    DCHECK(array != nullptr);
-    DCHECK(index != nullptr);
-    if (data == nullptr) {
-      data = graph_->GetIntConstant(1);
-    }
-    HInstruction* store =
-        new (GetAllocator()) HArraySet(array, index, data, DataType::Type::kInt32, 0);
-    block->InsertInstructionBefore(store, block->GetLastInstruction());
-    return store;
-  }
-
   void InitGraphAndParameters() {
-    InitGraph();
-    AddParameter(new (GetAllocator()) HParameterValue(
-        graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32));
-    array_ = parameters_.back();
-    AddParameter(new (GetAllocator()) HParameterValue(
-        graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32));
-    i_ = parameters_.back();
-    AddParameter(new (GetAllocator()) HParameterValue(
-        graph_->GetDexFile(), dex::TypeIndex(1), 2, DataType::Type::kInt32));
-    j_ = parameters_.back();
+    return_block_ = InitEntryMainExitGraphWithReturnVoid();
+    array_ = MakeParam(DataType::Type::kInt32);
+    i_ = MakeParam(DataType::Type::kInt32);
+    j_ = MakeParam(DataType::Type::kInt32);
   }
 
+  HBasicBlock* return_block_;
   HBasicBlock* pre_header_;
   HBasicBlock* loop_;
 
@@ -297,16 +252,6 @@ class LoadStoreEliminationTestBase : public SuperTest, public OptimizingUnitTest
 
 class LoadStoreEliminationTest : public LoadStoreEliminationTestBase<CommonCompilerTest> {};
 
-enum class TestOrder { kSameAsAlloc, kReverseOfAlloc };
-std::ostream& operator<<(std::ostream& os, const TestOrder& ord) {
-  switch (ord) {
-    case TestOrder::kSameAsAlloc:
-      return os << "SameAsAlloc";
-    case TestOrder::kReverseOfAlloc:
-      return os << "ReverseOfAlloc";
-  }
-}
-
 TEST_F(LoadStoreEliminationTest, ArrayGetSetElimination) {
   CreateTestControlFlowGraph();
 
@@ -320,12 +265,12 @@ TEST_F(LoadStoreEliminationTest, ArrayGetSetElimination) {
   // array[1] = 1;  <--- Remove, since it stores same value.
   // array[i] = 3;  <--- MAY alias.
   // array[1] = 1;  <--- Cannot remove, even if it stores the same value.
-  AddArraySet(entry_block_, array_, c1, c1);
-  HInstruction* load1 = AddArrayGet(entry_block_, array_, c1);
-  HInstruction* load2 = AddArrayGet(entry_block_, array_, c2);
-  HInstruction* store1 = AddArraySet(entry_block_, array_, c1, c1);
-  AddArraySet(entry_block_, array_, i_, c3);
-  HInstruction* store2 = AddArraySet(entry_block_, array_, c1, c1);
+  MakeArraySet(entry_block_, array_, c1, c1);
+  HInstruction* load1 = MakeArrayGet(entry_block_, array_, c1, DataType::Type::kInt32);
+  HInstruction* load2 = MakeArrayGet(entry_block_, array_, c2, DataType::Type::kInt32);
+  HInstruction* store1 = MakeArraySet(entry_block_, array_, c1, c1);
+  MakeArraySet(entry_block_, array_, i_, c3);
+  HInstruction* store2 = MakeArraySet(entry_block_, array_, c1, c1);
 
   PerformLSE();
 
@@ -346,10 +291,10 @@ TEST_F(LoadStoreEliminationTest, SameHeapValue1) {
   // array[2] = 1;
   // array[1] = 1;  <--- Can remove.
   // array[1] = 2;  <--- Can NOT remove.
-  AddArraySet(entry_block_, array_, c1, c1);
-  AddArraySet(entry_block_, array_, c2, c1);
-  HInstruction* store1 = AddArraySet(entry_block_, array_, c1, c1);
-  HInstruction* store2 = AddArraySet(entry_block_, array_, c1, c2);
+  MakeArraySet(entry_block_, array_, c1, c1);
+  MakeArraySet(entry_block_, array_, c2, c1);
+  HInstruction* store1 = MakeArraySet(entry_block_, array_, c1, c1);
+  HInstruction* store2 = MakeArraySet(entry_block_, array_, c1, c2);
 
   PerformLSE();
 
@@ -403,10 +348,10 @@ TEST_F(LoadStoreEliminationTest, OverlappingLoadStore) {
   // .. = a[i];                <-- Remove.
   // a[i,i+1,i+2,i+3] = data;  <-- PARTIAL OVERLAP !
   // .. = a[i];                <-- Cannot remove.
-  AddArraySet(entry_block_, array_, i_, c1);
-  HInstruction* load1 = AddArrayGet(entry_block_, array_, i_);
+  MakeArraySet(entry_block_, array_, i_, c1);
+  HInstruction* load1 = MakeArrayGet(entry_block_, array_, i_, DataType::Type::kInt32);
   AddVecStore(entry_block_, array_, i_);
-  HInstruction* load2 = AddArrayGet(entry_block_, array_, i_);
+  HInstruction* load2 = MakeArrayGet(entry_block_, array_, i_, DataType::Type::kInt32);
 
   // Test LSE handling vector load/store partial overlap.
   // a[i,i+1,i+2,i+3] = data;
@@ -429,7 +374,7 @@ TEST_F(LoadStoreEliminationTest, OverlappingLoadStore) {
   // a[i+1] = 1;                 <-- PARTIAL OVERLAP !
   // .. = a[i,i+1,i+2,i+3];
   AddVecStore(entry_block_, array_, i_);
-  AddArraySet(entry_block_, array_, i_, c1);
+  MakeArraySet(entry_block_, array_, i_, c1);
   HInstruction* vload5 = AddVecLoad(entry_block_, array_, i_);
 
   // TODO: enable LSE for graphs with predicated SIMD.
@@ -458,14 +403,14 @@ TEST_F(LoadStoreEliminationTest, StoreAfterLoopWithoutSideEffects) {
   HInstruction* c1 = graph_->GetIntConstant(1);
 
   // a[j] = 1
-  AddArraySet(pre_header_, array_, j_, c1);
+  MakeArraySet(pre_header_, array_, j_, c1);
 
   // LOOP BODY:
   // .. = a[i,i+1,i+2,i+3];
   AddVecLoad(loop_, array_, phi_);
 
   // a[j] = 1;
-  HInstruction* array_set = AddArraySet(return_block_, array_, j_, c1);
+  HInstruction* array_set = MakeArraySet(return_block_, array_, j_, c1);
 
   // TODO: enable LSE for graphs with predicated SIMD.
   graph_->SetHasTraditionalSIMD(true);
@@ -494,7 +439,7 @@ TEST_F(LoadStoreEliminationTest, StoreAfterSIMDLoopWithSideEffects) {
   array_b->CopyEnvironmentFrom(suspend_check_->GetEnvironment());
 
   // a[j] = 0;
-  AddArraySet(pre_header_, array_, j_, c0);
+  MakeArraySet(pre_header_, array_, j_, c0);
 
   // LOOP BODY:
   // a[phi,phi+1,phi+2,phi+3] = [1,1,1,1];
@@ -504,7 +449,7 @@ TEST_F(LoadStoreEliminationTest, StoreAfterSIMDLoopWithSideEffects) {
   AddVecStore(loop_, array_b, phi_, vload);
 
   // a[j] = 0;
-  HInstruction* a_set = AddArraySet(return_block_, array_, j_, c0);
+  HInstruction* a_set = MakeArraySet(return_block_, array_, j_, c0);
 
   // TODO: enable LSE for graphs with predicated SIMD.
   graph_->SetHasTraditionalSIMD(true);
@@ -534,7 +479,7 @@ TEST_F(LoadStoreEliminationTest, LoadAfterSIMDLoopWithSideEffects) {
   array_b->CopyEnvironmentFrom(suspend_check_->GetEnvironment());
 
   // a[j] = 0;
-  AddArraySet(pre_header_, array_, j_, c0);
+  MakeArraySet(pre_header_, array_, j_, c0);
 
   // LOOP BODY:
   // a[phi,phi+1,phi+2,phi+3] = [1,1,1,1];
@@ -544,7 +489,7 @@ TEST_F(LoadStoreEliminationTest, LoadAfterSIMDLoopWithSideEffects) {
   AddVecStore(loop_, array_b, phi_, vload);
 
   // x = a[j];
-  HInstruction* load = AddArrayGet(return_block_, array_, j_);
+  HInstruction* load = MakeArrayGet(return_block_, array_, j_, DataType::Type::kInt32);
 
   // TODO: enable LSE for graphs with predicated SIMD.
   graph_->SetHasTraditionalSIMD(true);
@@ -569,11 +514,7 @@ TEST_F(LoadStoreEliminationTest, LoadAfterSIMDLoopWithSideEffects) {
 //   'vstore3' is not removed.
 //   'vstore4' is not removed. Such cases are not supported at the moment.
 TEST_F(LoadStoreEliminationTest, MergePredecessorVecStores) {
-  HBasicBlock* upper;
-  HBasicBlock* left;
-  HBasicBlock* right;
-  HBasicBlock* down;
-  std::tie(upper, left, right, down) = CreateDiamondShapedCFG();
+  auto [upper, left, right, down] = CreateDiamondShapedCFG();
 
   // upper: a[i,... i + 3] = [1,...1]
   HInstruction* vstore1 = AddVecStore(upper, array_, i_);
@@ -612,23 +553,21 @@ TEST_F(LoadStoreEliminationTest, MergePredecessorVecStores) {
 //   'store2' is not removed.
 //   'store3' is removed.
 TEST_F(LoadStoreEliminationTest, MergePredecessorStores) {
-  HBasicBlock* upper;
-  HBasicBlock* left;
-  HBasicBlock* right;
-  HBasicBlock* down;
-  std::tie(upper, left, right, down) = CreateDiamondShapedCFG();
+  auto [upper, left, right, down] = CreateDiamondShapedCFG();
 
-  // upper: a[i,... i + 3] = [1,...1]
-  AddArraySet(upper, array_, i_);
+  HInstruction* c1 = graph_->GetIntConstant(1);
 
-  // left: a[i,... i + 3] = [1,...1]
-  HInstruction* store1 = AddArraySet(left, array_, i_);
+  // upper: a[i] = 1
+  MakeArraySet(upper, array_, i_, c1);
 
-  // right: a[i+1, ... i + 4] = [1, ... 1]
-  HInstruction* store2 = AddArraySet(right, array_, i_add1_);
+  // left: a[i] = 1
+  HInstruction* store1 = MakeArraySet(left, array_, i_, c1);
 
-  // down: a[i,... i + 3] = [1,...1]
-  HInstruction* store3 = AddArraySet(down, array_, i_);
+  // right: a[i+1] = 1
+  HInstruction* store2 = MakeArraySet(right, array_, i_add1_, c1);
+
+  // down: a[i] = 1
+  HInstruction* store3 = MakeArraySet(down, array_, i_, c1);
 
   PerformLSE();
 
@@ -702,16 +641,16 @@ TEST_F(LoadStoreEliminationTest, StoreAfterLoopWithSideEffects) {
   // loop:
   //   b[i] = array[i]
   // array[0] = 2
-  HInstruction* store1 = AddArraySet(entry_block_, array_, c0, c2);
+  HInstruction* store1 = MakeArraySet(entry_block_, array_, c0, c2);
 
   HInstruction* array_b = new (GetAllocator()) HNewArray(c0, c128, 0, 0);
   pre_header_->InsertInstructionBefore(array_b, pre_header_->GetLastInstruction());
   array_b->CopyEnvironmentFrom(suspend_check_->GetEnvironment());
 
-  HInstruction* load = AddArrayGet(loop_, array_, phi_);
-  HInstruction* store2 = AddArraySet(loop_, array_b, phi_, load);
+  HInstruction* load = MakeArrayGet(loop_, array_, phi_, DataType::Type::kInt32);
+  HInstruction* store2 = MakeArraySet(loop_, array_b, phi_, load);
 
-  HInstruction* store3 = AddArraySet(return_block_, array_, c0, c2);
+  HInstruction* store3 = MakeArraySet(return_block_, array_, c0, c2);
 
   PerformLSE();
 
@@ -726,9 +665,7 @@ TEST_F(LoadStoreEliminationTest, StoreAfterLoopWithSideEffects2) {
 
   // Add another array parameter that may alias with `array_`.
   // Note: We're not adding it to the suspend check environment.
-  AddParameter(new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 3, DataType::Type::kInt32));
-  HInstruction* array2 = parameters_.back();
+  HInstruction* array2 = MakeParam(DataType::Type::kInt32);
 
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c2 = graph_->GetIntConstant(2);
@@ -737,12 +674,12 @@ TEST_F(LoadStoreEliminationTest, StoreAfterLoopWithSideEffects2) {
   // loop:
   //   array2[i] = array[i]
   // array[0] = 2
-  HInstruction* store1 = AddArraySet(pre_header_, array_, c0, c2);
+  HInstruction* store1 = MakeArraySet(pre_header_, array_, c0, c2);
 
-  HInstruction* load = AddArrayGet(loop_, array_, phi_);
-  HInstruction* store2 = AddArraySet(loop_, array2, phi_, load);
+  HInstruction* load = MakeArrayGet(loop_, array_, phi_, DataType::Type::kInt32);
+  HInstruction* store2 = MakeArraySet(loop_, array2, phi_, load);
 
-  HInstruction* store3 = AddArraySet(return_block_, array_, c0, c2);
+  HInstruction* store3 = MakeArraySet(return_block_, array_, c0, c2);
 
   PerformLSE();
 
@@ -817,8 +754,8 @@ TEST_F(LoadStoreEliminationTest, LoadDefaultValueInLoopWithoutWriteSideEffects)
   // LOOP BODY:
   //    v = a[i]
   // array[0] = v
-  HInstruction* load = AddArrayGet(loop_, array_a, phi_);
-  HInstruction* store = AddArraySet(return_block_, array_, c0, load);
+  HInstruction* load = MakeArrayGet(loop_, array_a, phi_, DataType::Type::kInt32);
+  HInstruction* store = MakeArraySet(return_block_, array_, c0, load);
 
   PerformLSE();
 
@@ -840,8 +777,8 @@ TEST_F(LoadStoreEliminationTest, LoadDefaultValue) {
 
   // v = a[0]
   // array[0] = v
-  HInstruction* load = AddArrayGet(pre_header_, array_a, c0);
-  HInstruction* store = AddArraySet(return_block_, array_, c0, load);
+  HInstruction* load = MakeArrayGet(pre_header_, array_a, c0, DataType::Type::kInt32);
+  HInstruction* store = MakeArraySet(return_block_, array_, c0, load);
 
   PerformLSE();
 
@@ -868,9 +805,9 @@ TEST_F(LoadStoreEliminationTest, VLoadAndLoadDefaultValueInLoopWithoutWriteSideE
   // array[0,... 3] = v
   // array[0] = v1
   HInstruction* vload = AddVecLoad(loop_, array_a, phi_);
-  HInstruction* load = AddArrayGet(loop_, array_a, phi_);
+  HInstruction* load = MakeArrayGet(loop_, array_a, phi_, DataType::Type::kInt32);
   HInstruction* vstore = AddVecStore(return_block_, array_, c0, vload);
-  HInstruction* store = AddArraySet(return_block_, array_, c0, load);
+  HInstruction* store = MakeArraySet(return_block_, array_, c0, load);
 
   // TODO: enable LSE for graphs with predicated SIMD.
   graph_->SetHasTraditionalSIMD(true);
@@ -900,9 +837,9 @@ TEST_F(LoadStoreEliminationTest, VLoadAndLoadDefaultValue) {
   // array[0,... 3] = v
   // array[0] = v1
   HInstruction* vload = AddVecLoad(pre_header_, array_a, c0);
-  HInstruction* load = AddArrayGet(pre_header_, array_a, c0);
+  HInstruction* load = MakeArrayGet(pre_header_, array_a, c0, DataType::Type::kInt32);
   HInstruction* vstore = AddVecStore(return_block_, array_, c0, vload);
-  HInstruction* store = AddArraySet(return_block_, array_, c0, load);
+  HInstruction* store = MakeArraySet(return_block_, array_, c0, load);
 
   // TODO: enable LSE for graphs with predicated SIMD.
   graph_->SetHasTraditionalSIMD(true);
@@ -986,39 +923,20 @@ TEST_F(LoadStoreEliminationTest, VLoadDefaultValueAndVLoad) {
 // o.foo = 3;
 // return o.shadow$_klass_;
 TEST_F(LoadStoreEliminationTest, DefaultShadowClass) {
-  CreateGraph();
-  AdjacencyListGraph blocks(
-      graph_, GetAllocator(), "entry", "exit", {{"entry", "main"}, {"main", "exit"}});
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(main);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* main = InitEntryMainExitGraph();
 
-  HInstruction* suspend_check = new (GetAllocator()) HSuspendCheck();
-  entry->AddInstruction(suspend_check);
-  entry->AddInstruction(new (GetAllocator()) HGoto());
-  ManuallyBuildEnvFor(suspend_check, {});
+  HInstruction* suspend_check = MakeSuspendCheck(entry_block_);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
+  HInstruction* cls = MakeLoadClass(main);
+  HInstruction* new_inst = MakeNewInstance(main, cls);
   HInstruction* const_fence = new (GetAllocator()) HConstructorFence(new_inst, 0, GetAllocator());
-  HInstruction* set_field = MakeIFieldSet(new_inst, graph_->GetIntConstant(33), MemberOffset(32));
-  HInstruction* get_field =
-      MakeIFieldGet(new_inst, DataType::Type::kReference, mirror::Object::ClassOffset());
-  HInstruction* return_val = new (GetAllocator()) HReturn(get_field);
-  main->AddInstruction(cls);
-  main->AddInstruction(new_inst);
   main->AddInstruction(const_fence);
-  main->AddInstruction(set_field);
-  main->AddInstruction(get_field);
-  main->AddInstruction(return_val);
-  cls->CopyEnvironmentFrom(suspend_check->GetEnvironment());
-  new_inst->CopyEnvironmentFrom(suspend_check->GetEnvironment());
-
-  SetupExit(exit);
+  HInstruction* set_field =
+      MakeIFieldSet(main, new_inst, graph_->GetIntConstant(33), MemberOffset(32));
+  HInstruction* get_field =
+      MakeIFieldGet(main, new_inst, DataType::Type::kReference, mirror::Object::ClassOffset());
+  HReturn* return_val = MakeReturn(main, get_field);
 
-  graph_->ClearDominanceInformation();
   PerformLSE();
 
   EXPECT_INS_REMOVED(new_inst);
@@ -1037,39 +955,20 @@ TEST_F(LoadStoreEliminationTest, DefaultShadowClass) {
 // o.foo = 3;
 // return o.shadow$_monitor_;
 TEST_F(LoadStoreEliminationTest, DefaultShadowMonitor) {
-  CreateGraph();
-  AdjacencyListGraph blocks(
-      graph_, GetAllocator(), "entry", "exit", {{"entry", "main"}, {"main", "exit"}});
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(main);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* main = InitEntryMainExitGraph();
 
-  HInstruction* suspend_check = new (GetAllocator()) HSuspendCheck();
-  entry->AddInstruction(suspend_check);
-  entry->AddInstruction(new (GetAllocator()) HGoto());
-  ManuallyBuildEnvFor(suspend_check, {});
+  HInstruction* suspend_check = MakeSuspendCheck(entry_block_);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
+  HInstruction* cls = MakeLoadClass(main);
+  HInstruction* new_inst = MakeNewInstance(main, cls);
   HInstruction* const_fence = new (GetAllocator()) HConstructorFence(new_inst, 0, GetAllocator());
-  HInstruction* set_field = MakeIFieldSet(new_inst, graph_->GetIntConstant(33), MemberOffset(32));
-  HInstruction* get_field =
-      MakeIFieldGet(new_inst, DataType::Type::kInt32, mirror::Object::MonitorOffset());
-  HInstruction* return_val = new (GetAllocator()) HReturn(get_field);
-  main->AddInstruction(cls);
-  main->AddInstruction(new_inst);
   main->AddInstruction(const_fence);
-  main->AddInstruction(set_field);
-  main->AddInstruction(get_field);
-  main->AddInstruction(return_val);
-  cls->CopyEnvironmentFrom(suspend_check->GetEnvironment());
-  new_inst->CopyEnvironmentFrom(suspend_check->GetEnvironment());
-
-  SetupExit(exit);
+  HInstruction* set_field =
+      MakeIFieldSet(main, new_inst, graph_->GetIntConstant(33), MemberOffset(32));
+  HInstruction* get_field =
+      MakeIFieldGet(main, new_inst, DataType::Type::kInt32, mirror::Object::MonitorOffset());
+  HReturn* return_val = MakeReturn(main, get_field);
 
-  graph_->ClearDominanceInformation();
   PerformLSE();
 
   EXPECT_INS_REMOVED(new_inst);
@@ -1094,99 +993,39 @@ TEST_F(LoadStoreEliminationTest, DefaultShadowMonitor) {
 TEST_F(LoadStoreEliminationTest, ArrayLoopOverlap) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blocks(graph_,
-                            GetAllocator(),
-                            "entry",
-                            "exit",
-                            { { "entry", "loop_pre_header" },
-                              { "loop_pre_header", "loop_entry" },
-                              { "loop_entry", "loop_body" },
-                              { "loop_entry", "loop_post" },
-                              { "loop_body", "loop_entry" },
-                              { "loop_post", "exit" } });
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(loop_pre_header);
-  GET_BLOCK(loop_entry);
-  GET_BLOCK(loop_body);
-  GET_BLOCK(loop_post);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
+  auto [preheader, loop, body] = CreateWhileLoop(ret);
 
-  HInstruction* zero_const = graph_->GetConstant(DataType::Type::kInt32, 0);
-  HInstruction* one_const = graph_->GetConstant(DataType::Type::kInt32, 1);
-  HInstruction* eighty_const = graph_->GetConstant(DataType::Type::kInt32, 80);
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
-  entry->AddInstruction(entry_goto);
+  HInstruction* zero_const = graph_->GetIntConstant(0);
+  HInstruction* one_const = graph_->GetIntConstant(1);
+  HInstruction* eighty_const = graph_->GetIntConstant(80);
 
-  HInstruction* alloc_w = new (GetAllocator()) HNewArray(zero_const, eighty_const, 0, 0);
-  HInstruction* pre_header_goto = new (GetAllocator()) HGoto();
-  loop_pre_header->AddInstruction(alloc_w);
-  loop_pre_header->AddInstruction(pre_header_goto);
-  // environment
-  ManuallyBuildEnvFor(alloc_w, {});
+  // preheader
+  HInstruction* alloc_w = MakeNewArray(preheader, zero_const, eighty_const);
 
   // loop-start
-  HPhi* i_phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HPhi* t_phi = new (GetAllocator()) HPhi(GetAllocator(), 1, 0, DataType::Type::kInt32);
-  HInstruction* suspend = new (GetAllocator()) HSuspendCheck();
-  HInstruction* i_cmp_top = new (GetAllocator()) HGreaterThanOrEqual(i_phi, eighty_const);
-  HInstruction* loop_start_branch = new (GetAllocator()) HIf(i_cmp_top);
-  loop_entry->AddPhi(i_phi);
-  loop_entry->AddPhi(t_phi);
-  loop_entry->AddInstruction(suspend);
-  loop_entry->AddInstruction(i_cmp_top);
-  loop_entry->AddInstruction(loop_start_branch);
-  CHECK_EQ(loop_entry->GetSuccessors().size(), 2u);
-  if (loop_entry->GetNormalSuccessors()[1] != loop_body) {
-    loop_entry->SwapSuccessors();
-  }
-  CHECK_EQ(loop_entry->GetPredecessors().size(), 2u);
-  if (loop_entry->GetPredecessors()[0] != loop_pre_header) {
-    loop_entry->SwapPredecessors();
-  }
-  i_phi->AddInput(one_const);
-  t_phi->AddInput(zero_const);
-
-  // environment
-  ManuallyBuildEnvFor(suspend, { alloc_w, i_phi, t_phi });
+  auto [i_phi, i_add] = MakeLinearLoopVar(loop, body, one_const, one_const);
+  HPhi* t_phi = MakePhi(loop, {zero_const, /* placeholder */ zero_const});
+  std::initializer_list<HInstruction*> common_env{alloc_w, i_phi, t_phi};
+  HInstruction* suspend = MakeSuspendCheck(loop, common_env);
+  HInstruction* i_cmp_top = MakeCondition(loop, kCondGE, i_phi, eighty_const);
+  HIf* loop_if = MakeIf(loop, i_cmp_top);
+  CHECK(loop_if->IfTrueSuccessor() == ret);
 
   // BODY
-  HInstruction* last_i = new (GetAllocator()) HSub(DataType::Type::kInt32, i_phi, one_const);
-  HInstruction* last_get =
-      new (GetAllocator()) HArrayGet(alloc_w, last_i, DataType::Type::kInt32, 0);
-  HInvoke* body_value = MakeInvoke(DataType::Type::kInt32, { last_get, one_const });
-  HInstruction* body_set =
-      new (GetAllocator()) HArraySet(alloc_w, i_phi, body_value, DataType::Type::kInt32, 0);
-  HInstruction* body_get =
-      new (GetAllocator()) HArrayGet(alloc_w, i_phi, DataType::Type::kInt32, 0);
-  HInvoke* t_next = MakeInvoke(DataType::Type::kInt32, { body_get, t_phi });
-  HInstruction* i_next = new (GetAllocator()) HAdd(DataType::Type::kInt32, i_phi, one_const);
-  HInstruction* body_goto = new (GetAllocator()) HGoto();
-  loop_body->AddInstruction(last_i);
-  loop_body->AddInstruction(last_get);
-  loop_body->AddInstruction(body_value);
-  loop_body->AddInstruction(body_set);
-  loop_body->AddInstruction(body_get);
-  loop_body->AddInstruction(t_next);
-  loop_body->AddInstruction(i_next);
-  loop_body->AddInstruction(body_goto);
-  body_value->CopyEnvironmentFrom(suspend->GetEnvironment());
-
-  i_phi->AddInput(i_next);
-  t_phi->AddInput(t_next);
-  t_next->CopyEnvironmentFrom(suspend->GetEnvironment());
-
-  // loop-post
-  HInstruction* return_inst = new (GetAllocator()) HReturn(t_phi);
-  loop_post->AddInstruction(return_inst);
-
-  // exit
-  SetupExit(exit);
-
-  graph_->ClearDominanceInformation();
-  graph_->ClearLoopInformation();
+  HInstruction* last_i = MakeBinOp<HSub>(body, DataType::Type::kInt32, i_phi, one_const);
+  HInstruction* last_get = MakeArrayGet(body, alloc_w, last_i, DataType::Type::kInt32);
+  HInvoke* body_value =
+      MakeInvokeStatic(body, DataType::Type::kInt32, { last_get, one_const }, common_env);
+  HInstruction* body_set = MakeArraySet(body, alloc_w, i_phi, body_value, DataType::Type::kInt32);
+  HInstruction* body_get = MakeArrayGet(body, alloc_w, i_phi, DataType::Type::kInt32);
+  HInvoke* t_next = MakeInvokeStatic(body, DataType::Type::kInt32, { body_get, t_phi }, common_env);
+
+  t_phi->ReplaceInput(t_next, 1u);  // Update back-edge input.
+
+  // ret
+  MakeReturn(ret, t_phi);
+
   PerformLSE();
 
   // TODO Technically this is optimizable. LSE just needs to add phis to keep
@@ -1223,116 +1062,46 @@ TEST_F(LoadStoreEliminationTest, ArrayLoopOverlap) {
 TEST_F(LoadStoreEliminationTest, ArrayLoopOverlap2) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blocks(graph_,
-                            GetAllocator(),
-                            "entry",
-                            "exit",
-                            { { "entry", "loop_pre_header" },
-                              { "loop_pre_header", "loop_entry" },
-                              { "loop_entry", "loop_body" },
-                              { "loop_entry", "loop_post" },
-                              { "loop_body", "loop_entry" },
-                              { "loop_post", "exit" } });
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(loop_pre_header);
-  GET_BLOCK(loop_entry);
-  GET_BLOCK(loop_body);
-  GET_BLOCK(loop_post);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
+  auto [preheader, loop, body] = CreateWhileLoop(ret);
 
-  HInstruction* zero_const = graph_->GetConstant(DataType::Type::kInt32, 0);
-  HInstruction* one_const = graph_->GetConstant(DataType::Type::kInt32, 1);
-  HInstruction* eighty_const = graph_->GetConstant(DataType::Type::kInt32, 80);
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
-  entry->AddInstruction(entry_goto);
+  HInstruction* zero_const = graph_->GetIntConstant(0);
+  HInstruction* one_const = graph_->GetIntConstant(1);
+  HInstruction* eighty_const = graph_->GetIntConstant(80);
 
-  HInstruction* alloc_w = new (GetAllocator()) HNewArray(zero_const, eighty_const, 0, 0);
-  HInstruction* pre_header_goto = new (GetAllocator()) HGoto();
-  loop_pre_header->AddInstruction(alloc_w);
-  loop_pre_header->AddInstruction(pre_header_goto);
-  // environment
-  ManuallyBuildEnvFor(alloc_w, {});
+  // preheader
+  HInstruction* alloc_w = MakeNewArray(preheader, zero_const, eighty_const);
 
   // loop-start
-  HPhi* i_phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HPhi* t_phi = new (GetAllocator()) HPhi(GetAllocator(), 1, 0, DataType::Type::kInt32);
-  HInstruction* suspend = new (GetAllocator()) HSuspendCheck();
-  HInstruction* i_cmp_top = new (GetAllocator()) HGreaterThanOrEqual(i_phi, eighty_const);
-  HInstruction* loop_start_branch = new (GetAllocator()) HIf(i_cmp_top);
-  loop_entry->AddPhi(i_phi);
-  loop_entry->AddPhi(t_phi);
-  loop_entry->AddInstruction(suspend);
-  loop_entry->AddInstruction(i_cmp_top);
-  loop_entry->AddInstruction(loop_start_branch);
-  CHECK_EQ(loop_entry->GetSuccessors().size(), 2u);
-  if (loop_entry->GetNormalSuccessors()[1] != loop_body) {
-    loop_entry->SwapSuccessors();
-  }
-  CHECK_EQ(loop_entry->GetPredecessors().size(), 2u);
-  if (loop_entry->GetPredecessors()[0] != loop_pre_header) {
-    loop_entry->SwapPredecessors();
-  }
-  i_phi->AddInput(one_const);
-  t_phi->AddInput(zero_const);
-
-  // environment
-  ManuallyBuildEnvFor(suspend, { alloc_w, i_phi, t_phi });
+  auto [i_phi, i_add] = MakeLinearLoopVar(loop, body, one_const, one_const);
+  HPhi* t_phi = MakePhi(loop, {zero_const, /* placeholder */ zero_const});
+  std::initializer_list<HInstruction*> common_env{alloc_w, i_phi, t_phi};
+  HInstruction* suspend = MakeSuspendCheck(loop, common_env);
+  HInstruction* i_cmp_top = MakeCondition(loop, kCondGE, i_phi, eighty_const);
+  HIf* loop_if = MakeIf(loop, i_cmp_top);
+  CHECK(loop_if->IfTrueSuccessor() == ret);
 
   // BODY
-  HInstruction* last_i = new (GetAllocator()) HSub(DataType::Type::kInt32, i_phi, one_const);
-  HInstruction *last_get_1, *last_get_2, *last_get_3;
-  HInstruction *body_value_1, *body_value_2, *body_value_3;
-  HInstruction *body_set_1, *body_set_2, *body_set_3;
-  HInstruction *body_get_1, *body_get_2, *body_get_3;
-  HInstruction *t_next_1, *t_next_2, *t_next_3;
+  HInstruction* last_i = MakeBinOp<HSub>(body, DataType::Type::kInt32, i_phi, one_const);
   auto make_instructions = [&](HInstruction* last_t_value) {
-    HInstruction* last_get =
-        new (GetAllocator()) HArrayGet(alloc_w, last_i, DataType::Type::kInt32, 0);
-    HInvoke* body_value = MakeInvoke(DataType::Type::kInt32, { last_get, one_const });
-    HInstruction* body_set =
-        new (GetAllocator()) HArraySet(alloc_w, i_phi, body_value, DataType::Type::kInt32, 0);
-    HInstruction* body_get =
-        new (GetAllocator()) HArrayGet(alloc_w, i_phi, DataType::Type::kInt32, 0);
-    HInvoke* t_next = MakeInvoke(DataType::Type::kInt32, { body_get, last_t_value });
-    loop_body->AddInstruction(last_get);
-    loop_body->AddInstruction(body_value);
-    loop_body->AddInstruction(body_set);
-    loop_body->AddInstruction(body_get);
-    loop_body->AddInstruction(t_next);
+    HInstruction* last_get = MakeArrayGet(body, alloc_w, last_i, DataType::Type::kInt32);
+    HInvoke* body_value =
+        MakeInvokeStatic(body, DataType::Type::kInt32, { last_get, one_const }, common_env);
+    HInstruction* body_set = MakeArraySet(body, alloc_w, i_phi, body_value, DataType::Type::kInt32);
+    HInstruction* body_get = MakeArrayGet(body, alloc_w, i_phi, DataType::Type::kInt32);
+    HInvoke* t_next =
+        MakeInvokeStatic(body, DataType::Type::kInt32, { body_get, last_t_value }, common_env);
     return std::make_tuple(last_get, body_value, body_set, body_get, t_next);
   };
-  std::tie(last_get_1, body_value_1, body_set_1, body_get_1, t_next_1) = make_instructions(t_phi);
-  std::tie(last_get_2, body_value_2, body_set_2, body_get_2, t_next_2) =
-      make_instructions(t_next_1);
-  std::tie(last_get_3, body_value_3, body_set_3, body_get_3, t_next_3) =
-      make_instructions(t_next_2);
-  HInstruction* i_next = new (GetAllocator()) HAdd(DataType::Type::kInt32, i_phi, one_const);
-  HInstruction* body_goto = new (GetAllocator()) HGoto();
-  loop_body->InsertInstructionBefore(last_i, last_get_1);
-  loop_body->AddInstruction(i_next);
-  loop_body->AddInstruction(body_goto);
-  body_value_1->CopyEnvironmentFrom(suspend->GetEnvironment());
-  body_value_2->CopyEnvironmentFrom(suspend->GetEnvironment());
-  body_value_3->CopyEnvironmentFrom(suspend->GetEnvironment());
-
-  i_phi->AddInput(i_next);
-  t_phi->AddInput(t_next_3);
-  t_next_1->CopyEnvironmentFrom(suspend->GetEnvironment());
-  t_next_2->CopyEnvironmentFrom(suspend->GetEnvironment());
-  t_next_3->CopyEnvironmentFrom(suspend->GetEnvironment());
-
-  // loop-post
-  HInstruction* return_inst = new (GetAllocator()) HReturn(t_phi);
-  loop_post->AddInstruction(return_inst);
-
-  // exit
-  SetupExit(exit);
-
-  graph_->ClearDominanceInformation();
-  graph_->ClearLoopInformation();
+  auto [last_get_1, body_value_1, body_set_1, body_get_1, t_next_1] = make_instructions(t_phi);
+  auto [last_get_2, body_value_2, body_set_2, body_get_2, t_next_2] = make_instructions(t_next_1);
+  auto [last_get_3, body_value_3, body_set_3, body_get_3, t_next_3] = make_instructions(t_next_2);
+
+  t_phi->ReplaceInput(t_next_3, 1u);  // Update back-edge input.
+
+  // ret
+  MakeReturn(ret, t_phi);
+
   PerformLSE();
 
   // TODO Technically this is optimizable. LSE just needs to add phis to keep
@@ -1363,84 +1132,40 @@ TEST_F(LoadStoreEliminationTest, ArrayLoopOverlap2) {
 TEST_F(LoadStoreEliminationTest, ArrayNonLoopPhi) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blocks(graph_,
-                            GetAllocator(),
-                            "entry",
-                            "exit",
-                            { { "entry", "start" },
-                              { "start", "left" },
-                              { "start", "right" },
-                              { "left", "ret" },
-                              { "right", "ret" },
-                              { "ret", "exit" } });
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(start);
-  GET_BLOCK(left);
-  GET_BLOCK(right);
-  GET_BLOCK(ret);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
 
-  HInstruction* zero_const = graph_->GetConstant(DataType::Type::kInt32, 0);
-  HInstruction* one_const = graph_->GetConstant(DataType::Type::kInt32, 1);
-  HInstruction* two_const = graph_->GetConstant(DataType::Type::kInt32, 2);
   HInstruction* param = MakeParam(DataType::Type::kBool);
+  HInstruction* zero_const = graph_->GetIntConstant(0);
+  HInstruction* one_const = graph_->GetIntConstant(1);
+  HInstruction* two_const = graph_->GetIntConstant(2);
 
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
-  entry->AddInstruction(entry_goto);
+  auto [start, left, right] = CreateDiamondPattern(ret, param);
 
-  HInstruction* alloc_w = new (GetAllocator()) HNewArray(zero_const, two_const, 0, 0);
-  HInstruction* branch = new (GetAllocator()) HIf(param);
-  start->AddInstruction(alloc_w);
-  start->AddInstruction(branch);
-  // environment
-  ManuallyBuildEnvFor(alloc_w, {});
+  // start
+  HInstruction* alloc_w = MakeNewArray(start, zero_const, two_const);
 
   // left
-  HInvoke* left_value = MakeInvoke(DataType::Type::kInt32, { zero_const });
+  HInvoke* left_value =
+      MakeInvokeStatic(left, DataType::Type::kInt32, { zero_const }, /*env=*/ { alloc_w });
   HInstruction* left_set_1 =
-      new (GetAllocator()) HArraySet(alloc_w, zero_const, left_value, DataType::Type::kInt32, 0);
+      MakeArraySet(left, alloc_w, zero_const, left_value, DataType::Type::kInt32);
   HInstruction* left_set_2 =
-      new (GetAllocator()) HArraySet(alloc_w, one_const, zero_const, DataType::Type::kInt32, 0);
-  HInstruction* left_goto = new (GetAllocator()) HGoto();
-  left->AddInstruction(left_value);
-  left->AddInstruction(left_set_1);
-  left->AddInstruction(left_set_2);
-  left->AddInstruction(left_goto);
-  ManuallyBuildEnvFor(left_value, { alloc_w });
+      MakeArraySet(left, alloc_w, one_const, zero_const, DataType::Type::kInt32);
 
   // right
-  HInvoke* right_value = MakeInvoke(DataType::Type::kInt32, { one_const });
+  HInvoke* right_value =
+      MakeInvokeStatic(right, DataType::Type::kInt32, { one_const }, /*env=*/ { alloc_w });
   HInstruction* right_set_1 =
-      new (GetAllocator()) HArraySet(alloc_w, zero_const, right_value, DataType::Type::kInt32, 0);
+      MakeArraySet(right, alloc_w, zero_const, right_value, DataType::Type::kInt32);
   HInstruction* right_set_2 =
-      new (GetAllocator()) HArraySet(alloc_w, one_const, zero_const, DataType::Type::kInt32, 0);
-  HInstruction* right_goto = new (GetAllocator()) HGoto();
-  right->AddInstruction(right_value);
-  right->AddInstruction(right_set_1);
-  right->AddInstruction(right_set_2);
-  right->AddInstruction(right_goto);
-  ManuallyBuildEnvFor(right_value, { alloc_w });
+      MakeArraySet(right, alloc_w, one_const, zero_const, DataType::Type::kInt32);
 
   // ret
-  HInstruction* read_1 =
-      new (GetAllocator()) HArrayGet(alloc_w, zero_const, DataType::Type::kInt32, 0);
-  HInstruction* read_2 =
-      new (GetAllocator()) HArrayGet(alloc_w, one_const, DataType::Type::kInt32, 0);
-  HInstruction* add = new (GetAllocator()) HAdd(DataType::Type::kInt32, read_1, read_2);
-  HInstruction* return_inst = new (GetAllocator()) HReturn(add);
-  ret->AddInstruction(read_1);
-  ret->AddInstruction(read_2);
-  ret->AddInstruction(add);
-  ret->AddInstruction(return_inst);
-
-  // exit
-  SetupExit(exit);
-
-  graph_->ClearDominanceInformation();
-  graph_->ClearLoopInformation();
+  HInstruction* read_1 = MakeArrayGet(ret, alloc_w, zero_const, DataType::Type::kInt32);
+  HInstruction* read_2 = MakeArrayGet(ret, alloc_w, one_const, DataType::Type::kInt32);
+  HInstruction* add = MakeBinOp<HAdd>(ret, DataType::Type::kInt32, read_1, read_2);
+  MakeReturn(ret, add);
+
   PerformLSE();
 
   EXPECT_INS_REMOVED(read_1);
@@ -1458,79 +1183,37 @@ TEST_F(LoadStoreEliminationTest, ArrayNonLoopPhi) {
 TEST_F(LoadStoreEliminationTest, ArrayMergeDefault) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blocks(graph_,
-                            GetAllocator(),
-                            "entry",
-                            "exit",
-                            { { "entry", "start" },
-                              { "start", "left" },
-                              { "start", "right" },
-                              { "left", "ret" },
-                              { "right", "ret" },
-                              { "ret", "exit" } });
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(start);
-  GET_BLOCK(left);
-  GET_BLOCK(right);
-  GET_BLOCK(ret);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
 
-  HInstruction* zero_const = graph_->GetConstant(DataType::Type::kInt32, 0);
-  HInstruction* one_const = graph_->GetConstant(DataType::Type::kInt32, 1);
-  HInstruction* two_const = graph_->GetConstant(DataType::Type::kInt32, 2);
   HInstruction* param = MakeParam(DataType::Type::kBool);
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
+  HInstruction* zero_const = graph_->GetIntConstant(0);
+  HInstruction* one_const = graph_->GetIntConstant(1);
+  HInstruction* two_const = graph_->GetIntConstant(2);
 
-  entry->AddInstruction(entry_goto);
+  auto [start, left, right] = CreateDiamondPattern(ret, param);
 
-  HInstruction* alloc_w = new (GetAllocator()) HNewArray(zero_const, two_const, 0, 0);
-  HInstruction* branch = new (GetAllocator()) HIf(param);
-  start->AddInstruction(alloc_w);
-  start->AddInstruction(branch);
-  // environment
+  // start
+  HInstruction* alloc_w = MakeNewArray(start, zero_const, two_const);
   ArenaVector<HInstruction*> alloc_locals({}, GetAllocator()->Adapter(kArenaAllocInstruction));
-  ManuallyBuildEnvFor(alloc_w, {});
 
   // left
   HInstruction* left_set_1 =
-      new (GetAllocator()) HArraySet(alloc_w, zero_const, one_const, DataType::Type::kInt32, 0);
+      MakeArraySet(left, alloc_w, zero_const, one_const, DataType::Type::kInt32);
   HInstruction* left_set_2 =
-      new (GetAllocator()) HArraySet(alloc_w, zero_const, zero_const, DataType::Type::kInt32, 0);
-  HInstruction* left_goto = new (GetAllocator()) HGoto();
-  left->AddInstruction(left_set_1);
-  left->AddInstruction(left_set_2);
-  left->AddInstruction(left_goto);
+      MakeArraySet(left, alloc_w, zero_const, zero_const, DataType::Type::kInt32);
 
   // right
   HInstruction* right_set_1 =
-      new (GetAllocator()) HArraySet(alloc_w, one_const, one_const, DataType::Type::kInt32, 0);
+      MakeArraySet(right, alloc_w, one_const, one_const, DataType::Type::kInt32);
   HInstruction* right_set_2 =
-      new (GetAllocator()) HArraySet(alloc_w, one_const, zero_const, DataType::Type::kInt32, 0);
-  HInstruction* right_goto = new (GetAllocator()) HGoto();
-  right->AddInstruction(right_set_1);
-  right->AddInstruction(right_set_2);
-  right->AddInstruction(right_goto);
+      MakeArraySet(right, alloc_w, one_const, zero_const, DataType::Type::kInt32);
 
   // ret
-  HInstruction* read_1 =
-      new (GetAllocator()) HArrayGet(alloc_w, zero_const, DataType::Type::kInt32, 0);
-  HInstruction* read_2 =
-      new (GetAllocator()) HArrayGet(alloc_w, one_const, DataType::Type::kInt32, 0);
-  HInstruction* add = new (GetAllocator()) HAdd(DataType::Type::kInt32, read_1, read_2);
-  HInstruction* return_inst = new (GetAllocator()) HReturn(add);
-  ret->AddInstruction(read_1);
-  ret->AddInstruction(read_2);
-  ret->AddInstruction(add);
-  ret->AddInstruction(return_inst);
-
-  // exit
-  SetupExit(exit);
-
-  graph_->ClearDominanceInformation();
-  graph_->ClearLoopInformation();
+  HInstruction* read_1 = MakeArrayGet(ret, alloc_w, zero_const, DataType::Type::kInt32);
+  HInstruction* read_2 = MakeArrayGet(ret, alloc_w, one_const, DataType::Type::kInt32);
+  HInstruction* add = MakeBinOp<HAdd>(ret, DataType::Type::kInt32, read_1, read_2);
+  MakeReturn(ret, add);
+
   PerformLSE();
 
   EXPECT_INS_REMOVED(read_1);
@@ -1550,82 +1233,33 @@ TEST_F(LoadStoreEliminationTest, ArrayMergeDefault) {
 TEST_F(LoadStoreEliminationTest, ArrayLoopAliasing1) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blocks(graph_,
-                            GetAllocator(),
-                            "entry",
-                            "exit",
-                            { { "entry", "preheader" },
-                              { "preheader", "loop" },
-                              { "loop", "body" },
-                              { "body", "loop" },
-                              { "loop", "ret" },
-                              { "ret", "exit" } });
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(preheader);
-  GET_BLOCK(loop);
-  GET_BLOCK(body);
-  GET_BLOCK(ret);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
+  auto [preheader, loop, body] = CreateWhileLoop(ret);
+  loop->SwapSuccessors();  // Move the loop exit to the "else" successor.
+
   HInstruction* n = MakeParam(DataType::Type::kInt32);
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c1 = graph_->GetIntConstant(1);
 
-  // entry
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* array = new (GetAllocator()) HNewArray(
-      cls, n, /*dex_pc=*/ 0u, DataType::SizeShift(DataType::Type::kInt32));
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
-  entry->AddInstruction(cls);
-  entry->AddInstruction(array);
-  entry->AddInstruction(entry_goto);
-  ManuallyBuildEnvFor(cls, {});
-  ManuallyBuildEnvFor(array, {});
-
-  HInstruction* preheader_goto = new (GetAllocator()) HGoto();
-  preheader->AddInstruction(preheader_goto);
+  // preheader
+  HInstruction* cls = MakeLoadClass(preheader);
+  HInstruction* array = MakeNewArray(preheader, cls, n);
 
   // loop
-  HPhi* i_phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HInstruction* loop_suspend_check = new (GetAllocator()) HSuspendCheck();
-  HInstruction* loop_cond = new (GetAllocator()) HLessThan(i_phi, n);
-  HIf* loop_if = new (GetAllocator()) HIf(loop_cond);
-  loop->AddPhi(i_phi);
-  loop->AddInstruction(loop_suspend_check);
-  loop->AddInstruction(loop_cond);
-  loop->AddInstruction(loop_if);
+  auto [i_phi, i_add] = MakeLinearLoopVar(loop, body, c0, c1);
+  HInstruction* loop_suspend_check = MakeSuspendCheck(loop);
+  HInstruction* loop_cond = MakeCondition(loop, kCondLT, i_phi, n);
+  HIf* loop_if = MakeIf(loop, loop_cond);
   CHECK(loop_if->IfTrueSuccessor() == body);
-  ManuallyBuildEnvFor(loop_suspend_check, {});
 
   // body
-  HInstruction* body_set =
-      new (GetAllocator()) HArraySet(array, i_phi, i_phi, DataType::Type::kInt32, /*dex_pc=*/ 0u);
-  HInstruction* body_add = new (GetAllocator()) HAdd(DataType::Type::kInt32, i_phi, c1);
-  HInstruction* body_goto = new (GetAllocator()) HGoto();
-  body->AddInstruction(body_set);
-  body->AddInstruction(body_add);
-  body->AddInstruction(body_goto);
-
-  // i_phi inputs
-  i_phi->AddInput(c0);
-  i_phi->AddInput(body_add);
+  HInstruction* body_set = MakeArraySet(body, array, i_phi, i_phi, DataType::Type::kInt32);
 
   // ret
-  HInstruction* ret_sub = new (GetAllocator()) HSub(DataType::Type::kInt32, i_phi, c1);
-  HInstruction* ret_get =
-      new (GetAllocator()) HArrayGet(array, ret_sub, DataType::Type::kInt32, /*dex_pc=*/ 0);
-  HInstruction* ret_return = new (GetAllocator()) HReturn(ret_get);
-  ret->AddInstruction(ret_sub);
-  ret->AddInstruction(ret_get);
-  ret->AddInstruction(ret_return);
-
-  // exit
-  SetupExit(exit);
-
-  graph_->ClearDominanceInformation();
-  graph_->ClearLoopInformation();
+  HInstruction* ret_sub = MakeBinOp<HSub>(ret, DataType::Type::kInt32, i_phi, c1);
+  HInstruction* ret_get = MakeArrayGet(ret, array, ret_sub, DataType::Type::kInt32);
+  MakeReturn(ret, ret_get);
+
   PerformLSE();
 
   EXPECT_INS_RETAINED(cls);
@@ -1644,87 +1278,35 @@ TEST_F(LoadStoreEliminationTest, ArrayLoopAliasing1) {
 TEST_F(LoadStoreEliminationTest, ArrayLoopAliasing2) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blocks(graph_,
-                            GetAllocator(),
-                            "entry",
-                            "exit",
-                            { { "entry", "preheader" },
-                              { "preheader", "loop" },
-                              { "loop", "body" },
-                              { "body", "loop" },
-                              { "loop", "ret" },
-                              { "ret", "exit" } });
-#define GET_BLOCK(name) HBasicBlock* name = blocks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(preheader);
-  GET_BLOCK(loop);
-  GET_BLOCK(body);
-  GET_BLOCK(ret);
-  GET_BLOCK(exit);
-#undef GET_BLOCK
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
+  auto [preheader, loop, body] = CreateWhileLoop(ret);
+  loop->SwapSuccessors();  // Move the loop exit to the "else" successor.
+
   HInstruction* n = MakeParam(DataType::Type::kInt32);
   HInstruction* c0 = graph_->GetIntConstant(0);
   HInstruction* c1 = graph_->GetIntConstant(1);
 
-  // entry
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* array = new (GetAllocator()) HNewArray(
-      cls, n, /*dex_pc=*/ 0u, DataType::SizeShift(DataType::Type::kInt32));
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
-  entry->AddInstruction(cls);
-  entry->AddInstruction(array);
-  entry->AddInstruction(entry_goto);
-  ManuallyBuildEnvFor(cls, {});
-  ManuallyBuildEnvFor(array, {});
-
-  HInstruction* preheader_goto = new (GetAllocator()) HGoto();
-  preheader->AddInstruction(preheader_goto);
+  // preheader
+  HInstruction* cls = MakeLoadClass(preheader);
+  HInstruction* array = MakeNewArray(preheader, cls, n);
 
   // loop
-  HPhi* i_phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HInstruction* loop_suspend_check = new (GetAllocator()) HSuspendCheck();
-  HInstruction* loop_cond = new (GetAllocator()) HLessThan(i_phi, n);
-  HIf* loop_if = new (GetAllocator()) HIf(loop_cond);
-  loop->AddPhi(i_phi);
-  loop->AddInstruction(loop_suspend_check);
-  loop->AddInstruction(loop_cond);
-  loop->AddInstruction(loop_if);
+  auto [i_phi, i_add] = MakeLinearLoopVar(loop, body, c0, c1);
+  HInstruction* loop_suspend_check = MakeSuspendCheck(loop);
+  HInstruction* loop_cond = MakeCondition(loop, kCondLT, i_phi, n);
+  HIf* loop_if = MakeIf(loop, loop_cond);
   CHECK(loop_if->IfTrueSuccessor() == body);
-  ManuallyBuildEnvFor(loop_suspend_check, {});
 
   // body
-  HInstruction* body_set =
-      new (GetAllocator()) HArraySet(array, i_phi, i_phi, DataType::Type::kInt32, /*dex_pc=*/ 0u);
-  HInstruction* body_add = new (GetAllocator()) HAdd(DataType::Type::kInt32, i_phi, c1);
-  HInstruction* body_goto = new (GetAllocator()) HGoto();
-  body->AddInstruction(body_set);
-  body->AddInstruction(body_add);
-  body->AddInstruction(body_goto);
-
-  // i_phi inputs
-  i_phi->AddInput(c0);
-  i_phi->AddInput(body_add);
+  HInstruction* body_set = MakeArraySet(body, array, i_phi, i_phi, DataType::Type::kInt32);
 
   // ret
-  HInstruction* ret_sub = new (GetAllocator()) HSub(DataType::Type::kInt32, i_phi, c1);
-  HInstruction* ret_get1 =
-      new (GetAllocator()) HArrayGet(array, ret_sub, DataType::Type::kInt32, /*dex_pc=*/ 0);
-  HInstruction* ret_get2 =
-      new (GetAllocator()) HArrayGet(array, i_phi, DataType::Type::kInt32, /*dex_pc=*/ 0);
-  HInstruction* ret_add = new (GetAllocator()) HAdd(DataType::Type::kInt32, ret_get1, ret_get2);
-  HInstruction* ret_return = new (GetAllocator()) HReturn(ret_add);
-  ret->AddInstruction(ret_sub);
-  ret->AddInstruction(ret_get1);
-  ret->AddInstruction(ret_get2);
-  ret->AddInstruction(ret_add);
-  ret->AddInstruction(ret_return);
-
-  // exit
-  SetupExit(exit);
-
-  graph_->ClearDominanceInformation();
-  graph_->ClearLoopInformation();
+  HInstruction* ret_sub = MakeBinOp<HSub>(ret, DataType::Type::kInt32, i_phi, c1);
+  HInstruction* ret_get1 = MakeArrayGet(ret, array, ret_sub, DataType::Type::kInt32);
+  HInstruction* ret_get2 = MakeArrayGet(ret, array, i_phi, DataType::Type::kInt32);
+  HInstruction* ret_add = MakeBinOp<HAdd>(ret, DataType::Type::kInt32, ret_get1, ret_get2);
+  MakeReturn(ret, ret_add);
+
   PerformLSE();
 
   EXPECT_INS_RETAINED(cls);
@@ -1734,6 +1316,381 @@ TEST_F(LoadStoreEliminationTest, ArrayLoopAliasing2) {
   EXPECT_INS_RETAINED(ret_get2);
 }
 
+class TwoTypesConversionsTestGroup : public LoadStoreEliminationTestBase<
+    CommonCompilerTestWithParam<std::tuple<DataType::Type, DataType::Type>>> {
+ protected:
+  DataType::Type FieldTypeForLoadType(DataType::Type load_type) {
+    // `Uint8` is not a valid field type but it's a valid load type we can set for
+    // a `HInstanceFieldGet` after constructing it.
+    return (load_type == DataType::Type::kUint8) ? DataType::Type::kInt8 : load_type;
+  }
+};
+
+TEST_P(TwoTypesConversionsTestGroup, StoreLoad) {
+  auto [param_type, load_type] = GetParam();
+  DataType::Type field_type = FieldTypeForLoadType(load_type);
+
+  HBasicBlock* main = InitEntryMainExitGraph();
+  HInstruction* param = MakeParam(param_type);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  HInstruction* write = MakeIFieldSet(main, object, param, field_type, MemberOffset(32));
+  HInstanceFieldGet* read = MakeIFieldGet(main, object, field_type, MemberOffset(32));
+  read->SetType(load_type);
+  HInstruction* ret = MakeReturn(main, read);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(write);
+  EXPECT_INS_REMOVED(read);
+
+  HInstruction* ret_input = ret->InputAt(0);
+  if (DataType::IsTypeConversionImplicit(param_type, load_type)) {
+    ASSERT_EQ(param, ret_input) << ret_input->DebugName();
+  } else {
+    ASSERT_TRUE(ret_input->IsTypeConversion()) << ret_input->DebugName();
+    ASSERT_EQ(load_type, ret_input->GetType());
+    ASSERT_EQ(param, ret_input->InputAt(0)) << ret_input->InputAt(0)->DebugName();
+  }
+}
+
+TEST_P(TwoTypesConversionsTestGroup, StoreLoadStoreLoad) {
+  auto [load_type1, load_type2] = GetParam();
+  DataType::Type field_type1 = FieldTypeForLoadType(load_type1);
+  DataType::Type field_type2 = FieldTypeForLoadType(load_type2);
+
+  HBasicBlock* main = InitEntryMainExitGraph();
+  HInstruction* param = MakeParam(DataType::Type::kInt32);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  HInstruction* write1 = MakeIFieldSet(main, object, param, field_type1, MemberOffset(32));
+  HInstanceFieldGet* read1 = MakeIFieldGet(main, object, field_type1, MemberOffset(32));
+  read1->SetType(load_type1);
+  HInstruction* write2 = MakeIFieldSet(main, object, read1, field_type2, MemberOffset(40));
+  HInstanceFieldGet* read2 = MakeIFieldGet(main, object, field_type2, MemberOffset(40));
+  read2->SetType(load_type2);
+  HInstruction* ret = MakeReturn(main, read2);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(write1);
+  EXPECT_INS_RETAINED(write2);
+  EXPECT_INS_REMOVED(read1);
+  EXPECT_INS_REMOVED(read2);
+
+  // Note: Sometimes we create two type conversions when one is enough (Int32->Int16->Int8).
+  // We currently rely on the instruction simplifier to remove the intermediate conversion.
+  HInstruction* current = ret->InputAt(0);
+  if (!DataType::IsTypeConversionImplicit(load_type1, load_type2)) {
+    ASSERT_TRUE(current->IsTypeConversion()) << current->DebugName();
+    ASSERT_EQ(load_type2, current->GetType());
+    current = current->InputAt(0);
+  }
+  if (!DataType::IsTypeConversionImplicit(DataType::Type::kInt32, load_type1)) {
+    ASSERT_TRUE(current->IsTypeConversion()) << current->DebugName();
+    ASSERT_EQ(load_type1, current->GetType());
+    current = current->InputAt(0);
+  }
+  ASSERT_EQ(param, current) << current->DebugName();
+}
+
+TEST_P(TwoTypesConversionsTestGroup, DefaultValueStores_LoadAfterLoop) {
+  auto [default_load_type, load_type] = GetParam();
+  DataType::Type default_field_type = FieldTypeForLoadType(default_load_type);
+  DataType::Type field_type = FieldTypeForLoadType(load_type);
+
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  auto [pre_header, loop] = CreateDoWhileLoopWithInstructions(return_block);
+
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+  HInstruction* cls = MakeLoadClass(pre_header);
+  HInstruction* default_object = MakeNewInstance(pre_header, cls);
+  HInstanceFieldGet* default_value =
+      MakeIFieldGet(pre_header, default_object, default_field_type, MemberOffset(40));
+  default_value->SetType(default_load_type);
+  // Make the `default_object` escape to avoid write elimination (test only load elimination).
+  HInstruction* invoke = MakeInvokeStatic(return_block, DataType::Type::kVoid, {default_object});
+
+  HInstruction* write =
+      MakeIFieldSet(return_block, object, default_value, field_type, MemberOffset(32));
+  HInstanceFieldGet* read = MakeIFieldGet(return_block, object, field_type, MemberOffset(32));
+  read->SetType(load_type);
+  HInstruction* ret = MakeReturn(return_block, read);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(default_object);
+  EXPECT_INS_REMOVED(default_value);
+  EXPECT_INS_RETAINED(write);
+  EXPECT_INS_REMOVED(read);
+
+  HInstruction* ret_input = ret->InputAt(0);
+  ASSERT_TRUE(ret_input->IsIntConstant()) << ret_input->DebugName();
+  ASSERT_EQ(ret_input->AsIntConstant()->GetValue(), 0);
+}
+
+TEST_P(TwoTypesConversionsTestGroup, SingleValueStores_LoadAfterLoop) {
+  auto [param_type, load_type] = GetParam();
+  DataType::Type field_type = FieldTypeForLoadType(load_type);
+
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  auto [pre_header, loop_header, loop_body] = CreateForLoopWithInstructions(return_block);
+
+  HInstruction* param = MakeParam(param_type);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  // Write the value in pre-header.
+  HInstruction* write1 =
+      MakeIFieldSet(pre_header, object, param, field_type, MemberOffset(32));
+
+  // In the body, make a call to clobber all fields, then write the same value as in pre-header.
+  MakeInvokeStatic(loop_body, DataType::Type::kVoid, {object});
+  HInstruction* write2 =
+      MakeIFieldSet(loop_body, object, param, field_type, MemberOffset(32));
+
+  HInstanceFieldGet* read = MakeIFieldGet(return_block, object, field_type, MemberOffset(32));
+  read->SetType(load_type);
+  HInstruction* ret = MakeReturn(return_block, read);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(write1);
+  EXPECT_INS_RETAINED(write2);
+  EXPECT_INS_REMOVED(read);
+
+  HInstruction* ret_input = ret->InputAt(0);
+  if (DataType::IsTypeConversionImplicit(param_type, load_type)) {
+    ASSERT_EQ(param, ret_input) << ret_input->DebugName();
+  } else {
+    ASSERT_TRUE(ret_input->IsTypeConversion()) << ret_input->DebugName();
+    ASSERT_EQ(load_type, ret_input->GetType());
+    ASSERT_EQ(param, ret_input->InputAt(0)) << ret_input->InputAt(0)->DebugName();
+  }
+}
+
+TEST_P(TwoTypesConversionsTestGroup, StoreLoopLoad) {
+  auto [param_type, load_type] = GetParam();
+  DataType::Type field_type = FieldTypeForLoadType(load_type);
+
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  auto [pre_header, loop] = CreateDoWhileLoopWithInstructions(return_block);
+
+  HInstruction* param = MakeParam(param_type);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  HInstruction* write = MakeIFieldSet(pre_header, object, param, field_type, MemberOffset(32));
+
+  HInstanceFieldGet* read = MakeIFieldGet(return_block, object, field_type, MemberOffset(32));
+  read->SetType(load_type);
+  HInstruction* ret = MakeReturn(return_block, read);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(write);
+  EXPECT_INS_REMOVED(read);
+
+  HInstruction* ret_input = ret->InputAt(0);
+  if (DataType::IsTypeConversionImplicit(param_type, load_type)) {
+    ASSERT_EQ(param, ret_input) << ret_input->DebugName();
+  } else {
+    ASSERT_TRUE(ret_input->IsTypeConversion()) << ret_input->DebugName();
+    ASSERT_EQ(load_type, ret_input->GetType());
+    ASSERT_EQ(param, ret_input->InputAt(0)) << ret_input->InputAt(0)->DebugName();
+  }
+}
+
+TEST_P(TwoTypesConversionsTestGroup, StoreLoopLoadStoreLoad) {
+  auto [load_type1, load_type2] = GetParam();
+  DataType::Type field_type1 = FieldTypeForLoadType(load_type1);
+  DataType::Type field_type2 = FieldTypeForLoadType(load_type2);
+
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  auto [pre_header, loop] = CreateDoWhileLoopWithInstructions(return_block);
+  HInstruction* param = MakeParam(DataType::Type::kInt32);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  HInstruction* write1 = MakeIFieldSet(pre_header, object, param, field_type1, MemberOffset(32));
+
+  HInstanceFieldGet* read1 = MakeIFieldGet(return_block, object, field_type1, MemberOffset(32));
+  read1->SetType(load_type1);
+  HInstruction* write2 = MakeIFieldSet(return_block, object, read1, field_type2, MemberOffset(40));
+  HInstanceFieldGet* read2 = MakeIFieldGet(return_block, object, field_type2, MemberOffset(40));
+  read2->SetType(load_type2);
+  HInstruction* ret = MakeReturn(return_block, read2);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(write1);
+  EXPECT_INS_RETAINED(write2);
+  EXPECT_INS_REMOVED(read1);
+  EXPECT_INS_REMOVED(read2);
+
+  if (load_type1 != DataType::Type::kInt32 && load_type2 != load_type1) {
+    GTEST_SKIP() << "FIXME: Missing type conversions. Bug: 341476044";
+  }
+  // Note: Sometimes we create two type conversions when one is enough (Int32->Int16->Int8).
+  // We currently rely on the instruction simplifier to remove the intermediate conversion.
+  HInstruction* current = ret->InputAt(0);
+  if (!DataType::IsTypeConversionImplicit(load_type1, load_type2)) {
+    ASSERT_TRUE(current->IsTypeConversion()) << current->DebugName();
+    ASSERT_EQ(load_type2, current->GetType());
+    current = current->InputAt(0);
+  }
+  if (!DataType::IsTypeConversionImplicit(DataType::Type::kInt32, load_type1)) {
+    ASSERT_TRUE(current->IsTypeConversion()) << current->DebugName();
+    ASSERT_EQ(load_type1, current->GetType()) << load_type2;
+    current = current->InputAt(0);
+  }
+  ASSERT_EQ(param, current) << current->DebugName();
+}
+
+TEST_P(TwoTypesConversionsTestGroup, MergingConvertedValueStore) {
+  auto [param_type, load_type] = GetParam();
+  DataType::Type field_type = FieldTypeForLoadType(load_type);
+  DataType::Type phi_field_type = DataType::Type::kInt32;  // "phi field" can hold the full value.
+  CHECK(DataType::IsTypeConversionImplicit(param_type, phi_field_type));
+  CHECK(DataType::IsTypeConversionImplicit(load_type, phi_field_type));
+
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  auto [pre_header, loop_header, loop_body] = CreateForLoopWithInstructions(return_block);
+
+  HInstruction* param = MakeParam(param_type);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  // Initialize the "phi field".
+  HInstruction* pre_header_write =
+      MakeIFieldSet(pre_header, object, param, phi_field_type, MemberOffset(40));
+
+  // In the body, we read the "phi field", store and load the value to a different field
+  // to force type conversion, and store back to the "phi field".
+  HInstanceFieldGet* phi_read = MakeIFieldGet(loop_body, object, phi_field_type, MemberOffset(40));
+  HInstruction* conversion_write =
+      MakeIFieldSet(loop_body, object, phi_read, field_type, MemberOffset(32));
+  HInstanceFieldGet* conversion_read =
+      MakeIFieldGet(loop_body, object, field_type, MemberOffset(32));
+  conversion_read->SetType(load_type);
+  HInstruction* phi_write =
+      MakeIFieldSet(loop_body, object, conversion_read, phi_field_type, MemberOffset(40));
+
+  HInstanceFieldGet* final_read =
+      MakeIFieldGet(return_block, object, phi_field_type, MemberOffset(40));
+  HInstruction* ret = MakeReturn(return_block, final_read);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(pre_header_write);
+  EXPECT_INS_RETAINED(conversion_write);
+  EXPECT_INS_REMOVED(phi_read);
+  EXPECT_INS_REMOVED(conversion_read);
+  EXPECT_INS_REMOVED(final_read);
+
+  HInstruction* ret_input = ret->InputAt(0);
+  if (DataType::IsTypeConversionImplicit(param_type, load_type)) {
+    EXPECT_INS_REMOVED(phi_write) << "\n" << param_type << "/" << load_type;
+    ASSERT_EQ(param, ret_input) << ret_input->DebugName();
+  } else {
+    GTEST_SKIP() << "FIXME: Missing type conversions. Bug: 341476044";
+    EXPECT_INS_RETAINED(phi_write) << "\n" << param_type << "/" << load_type;
+    ASSERT_TRUE(ret_input->IsPhi()) << ret_input->DebugName();
+    HInstruction* pre_header_input = ret_input->InputAt(0);
+    HInstruction* loop_body_input = ret_input->InputAt(1);
+    ASSERT_EQ(param, pre_header_input) << pre_header_input->DebugName();
+    ASSERT_TRUE(loop_body_input->IsTypeConversion());
+    ASSERT_EQ(load_type, loop_body_input->GetType());
+    ASSERT_EQ(ret_input, loop_body_input->InputAt(0));
+  }
+}
+
+TEST_P(TwoTypesConversionsTestGroup, MergingTwiceConvertedValueStore) {
+  auto [load_type1, load_type2] = GetParam();
+  DataType::Type field_type1 = FieldTypeForLoadType(load_type1);
+  DataType::Type field_type2 = FieldTypeForLoadType(load_type2);
+  DataType::Type phi_field_type = DataType::Type::kInt32;  // "phi field" can hold the full value.
+  CHECK(DataType::IsTypeConversionImplicit(load_type1, phi_field_type));
+  CHECK(DataType::IsTypeConversionImplicit(load_type2, phi_field_type));
+
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  auto [pre_header, loop_header, loop_body] = CreateForLoopWithInstructions(return_block);
+
+  HInstruction* param = MakeParam(DataType::Type::kInt32);
+  HInstruction* object = MakeParam(DataType::Type::kReference);
+
+  // Initialize the "phi field".
+  HInstruction* pre_header_write =
+      MakeIFieldSet(pre_header, object, param, phi_field_type, MemberOffset(40));
+
+  // In the body, we read the "phi field", store and load the value to a different field
+  // to force type conversion - twice, and store back to the "phi field".
+  HInstanceFieldGet* phi_read = MakeIFieldGet(loop_body, object, phi_field_type, MemberOffset(40));
+  HInstruction* conversion_write1 =
+      MakeIFieldSet(loop_body, object, phi_read, field_type1, MemberOffset(32));
+  HInstanceFieldGet* conversion_read1 =
+      MakeIFieldGet(loop_body, object, field_type1, MemberOffset(32));
+  conversion_read1->SetType(load_type1);
+  HInstruction* conversion_write2 =
+      MakeIFieldSet(loop_body, object, conversion_read1, field_type2, MemberOffset(36));
+  HInstanceFieldGet* conversion_read2 =
+      MakeIFieldGet(loop_body, object, field_type2, MemberOffset(36));
+  conversion_read2->SetType(load_type2);
+  HInstruction* phi_write =
+      MakeIFieldSet(loop_body, object, conversion_read2, phi_field_type, MemberOffset(40));
+
+  HInstanceFieldGet* final_read =
+      MakeIFieldGet(return_block, object, phi_field_type, MemberOffset(40));
+  HInstruction* ret = MakeReturn(return_block, final_read);
+
+  PerformLSE();
+
+  EXPECT_INS_RETAINED(pre_header_write);
+  EXPECT_INS_RETAINED(conversion_write1);
+  EXPECT_INS_RETAINED(conversion_write2);
+  EXPECT_INS_REMOVED(phi_read);
+  EXPECT_INS_REMOVED(conversion_read1);
+  EXPECT_INS_REMOVED(conversion_read2);
+  EXPECT_INS_REMOVED(final_read);
+
+  HInstruction* ret_input = ret->InputAt(0);
+  if (load_type1 == DataType::Type::kInt32 && load_type2 == DataType::Type::kInt32) {
+    EXPECT_INS_REMOVED(phi_write) << "\n" << load_type1 << "/" << load_type2;
+    ASSERT_EQ(param, ret_input) << ret_input->DebugName();
+  } else {
+    GTEST_SKIP() << "FIXME: Missing type conversions. Bug: 341476044";
+    EXPECT_INS_RETAINED(phi_write) << "\n" << load_type1 << "/" << load_type2;
+    ASSERT_TRUE(ret_input->IsPhi()) << ret_input->DebugName();
+    HInstruction* pre_header_input = ret_input->InputAt(0);
+    HInstruction* loop_body_input = ret_input->InputAt(1);
+    ASSERT_EQ(param, pre_header_input) << pre_header_input->DebugName();
+    ASSERT_TRUE(loop_body_input->IsTypeConversion());
+    // Note: Sometimes we create two type conversions when one is enough (Int32->Int16->Int8).
+    // We currently rely on the instruction simplifier to remove the intermediate conversion.
+    HInstruction* current = loop_body_input;
+    if (!DataType::IsTypeConversionImplicit(load_type1, load_type2)) {
+      ASSERT_TRUE(current->IsTypeConversion()) << current->DebugName();
+      ASSERT_EQ(load_type2, current->GetType());
+      current = current->InputAt(0);
+    }
+    if (!DataType::IsTypeConversionImplicit(DataType::Type::kInt32, load_type1)) {
+      ASSERT_TRUE(current->IsTypeConversion()) << current->DebugName();
+      ASSERT_EQ(load_type1, current->GetType()) << load_type2;
+      current = current->InputAt(0);
+    }
+    ASSERT_EQ(current, ret_input);
+  }
+}
+
+auto Int32AndSmallerTypesGenerator() {
+  return testing::Values(DataType::Type::kInt32,
+                         DataType::Type::kInt16,
+                         DataType::Type::kInt8,
+                         DataType::Type::kUint16,
+                         DataType::Type::kUint8);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    LoadStoreEliminationTest,
+    TwoTypesConversionsTestGroup,
+    testing::Combine(Int32AndSmallerTypesGenerator(), Int32AndSmallerTypesGenerator()));
+
 // // ENTRY
 // obj = new Obj();
 // // ALL should be kept
@@ -1810,74 +1767,45 @@ TEST_F(LoadStoreEliminationTest, PartialUnknownMerge) {
   HInstruction* c3 = graph_->GetIntConstant(3);
   HInstruction* c5 = graph_->GetIntConstant(5);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* entry_goto = new (GetAllocator()) HGoto();
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(entry_goto);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
+  HInstruction* cls = MakeLoadClass(entry);
+  HInstruction* new_inst = MakeNewInstance(entry, cls);
+  MakeGoto(entry);
 
   HInstruction* switch_inst = new (GetAllocator()) HPackedSwitch(0, 2, switch_val);
   bswitch->AddInstruction(switch_inst);
 
-  HInstruction* write_c1 = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* call_c1 = MakeInvoke(DataType::Type::kVoid, { new_inst });
-  HInstruction* goto_c1 = new (GetAllocator()) HGoto();
-  case1->AddInstruction(write_c1);
-  case1->AddInstruction(call_c1);
-  case1->AddInstruction(goto_c1);
-  call_c1->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_c2 = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* call_c2 = MakeInvoke(DataType::Type::kVoid, { new_inst });
-  HInstruction* goto_c2 = new (GetAllocator()) HGoto();
-  case2->AddInstruction(write_c2);
-  case2->AddInstruction(call_c2);
-  case2->AddInstruction(goto_c2);
-  call_c2->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_c3 = MakeIFieldSet(new_inst, c3, MemberOffset(32));
-  HInstruction* goto_c3 = new (GetAllocator()) HGoto();
-  case3->AddInstruction(write_c3);
-  case3->AddInstruction(goto_c3);
-
-  HInstruction* goto_preheader = new (GetAllocator()) HGoto();
-  loop_pre_header->AddInstruction(goto_preheader);
-
-  HInstruction* suspend_check_header = new (GetAllocator()) HSuspendCheck();
-  HInstruction* call_loop_header = MakeInvoke(DataType::Type::kBool, {});
-  HInstruction* if_loop_header = new (GetAllocator()) HIf(call_loop_header);
-  loop_header->AddInstruction(suspend_check_header);
-  loop_header->AddInstruction(call_loop_header);
-  loop_header->AddInstruction(if_loop_header);
-  call_loop_header->CopyEnvironmentFrom(cls->GetEnvironment());
-  suspend_check_header->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* call_loop_body = MakeInvoke(DataType::Type::kBool, {});
-  HInstruction* if_loop_body = new (GetAllocator()) HIf(call_loop_body);
-  loop_body->AddInstruction(call_loop_body);
-  loop_body->AddInstruction(if_loop_body);
-  call_loop_body->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* goto_loop_left = new (GetAllocator()) HGoto();
-  loop_if_left->AddInstruction(goto_loop_left);
-
-  HInstruction* write_loop_right = MakeIFieldSet(new_inst, c5, MemberOffset(32));
-  HInstruction* goto_loop_right = new (GetAllocator()) HGoto();
-  loop_if_right->AddInstruction(write_loop_right);
-  loop_if_right->AddInstruction(goto_loop_right);
-
-  HInstruction* goto_loop_end = new (GetAllocator()) HGoto();
-  loop_end->AddInstruction(goto_loop_end);
-
-  HInstruction* read_bottom = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_bottom);
-  breturn->AddInstruction(read_bottom);
-  breturn->AddInstruction(return_exit);
-
-  SetupExit(exit);
+  HInstruction* write_c1 = MakeIFieldSet(case1, new_inst, c1, MemberOffset(32));
+  HInstruction* call_c1 = MakeInvokeStatic(case1, DataType::Type::kVoid, { new_inst });
+  MakeGoto(case1);
+
+  HInstruction* write_c2 = MakeIFieldSet(case2, new_inst, c2, MemberOffset(32));
+  HInstruction* call_c2 = MakeInvokeStatic(case2, DataType::Type::kVoid, { new_inst });
+  MakeGoto(case2);
+
+  HInstruction* write_c3 = MakeIFieldSet(case3, new_inst, c3, MemberOffset(32));
+  MakeGoto(case3);
+
+  MakeGoto(loop_pre_header);
+
+  HInstruction* suspend_check_header = MakeSuspendCheck(loop_header);
+  HInstruction* call_loop_header = MakeInvokeStatic(loop_header, DataType::Type::kBool, {});
+  MakeIf(loop_header, call_loop_header);
+
+  HInstruction* call_loop_body = MakeInvokeStatic(loop_body, DataType::Type::kBool, {});
+  MakeIf(loop_body, call_loop_body);
+
+  MakeGoto(loop_if_left);
+
+  HInstruction* write_loop_right = MakeIFieldSet(loop_if_right, new_inst, c5, MemberOffset(32));
+  MakeGoto(loop_if_right);
+
+  MakeGoto(loop_end);
+
+  HInstruction* read_bottom =
+      MakeIFieldGet(breturn, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(breturn, read_bottom);
+
+  MakeExit(exit);
 
   PerformLSE(blks);
 
@@ -1906,50 +1834,27 @@ TEST_F(LoadStoreEliminationTest, PartialUnknownMerge) {
 TEST_F(LoadStoreEliminationTest, PartialLoadPreserved) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry",
-                                                 "exit_REAL",
-                                                 { { "entry", "left" },
-                                                   { "entry", "right" },
-                                                   { "left", "exit" },
-                                                   { "right", "exit" },
-                                                   { "exit", "exit_REAL" } }));
-  HBasicBlock* entry = blks.Get("entry");
-  HBasicBlock* left = blks.Get("left");
-  HBasicBlock* right = blks.Get("right");
-  HBasicBlock* exit = blks.Get("exit");
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
+
   HInstruction* bool_value = MakeParam(DataType::Type::kBool);
   HInstruction* c1 = graph_->GetIntConstant(1);
   HInstruction* c2 = graph_->GetIntConstant(2);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(if_inst);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_left = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* call_left = MakeInvoke(DataType::Type::kVoid, { new_inst });
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  left->AddInstruction(write_left);
-  left->AddInstruction(call_left);
-  left->AddInstruction(goto_left);
-  call_left->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_right = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(write_right);
-  right->AddInstruction(goto_right);
-
-  HInstruction* read_bottom = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_bottom);
-  exit->AddInstruction(read_bottom);
-  exit->AddInstruction(return_exit);
+  auto [start, left, right] = CreateDiamondPattern(ret, bool_value);
 
-  PerformLSE(blks);
+  HInstruction* cls = MakeLoadClass(start);
+  HInstruction* new_inst = MakeNewInstance(start, cls);
+
+  HInstruction* write_left = MakeIFieldSet(left, new_inst, c1, MemberOffset(32));
+  HInstruction* call_left = MakeInvokeStatic(left, DataType::Type::kVoid, { new_inst });
+
+  HInstruction* write_right = MakeIFieldSet(right, new_inst, c2, MemberOffset(32));
+
+  HInstruction* read_bottom =
+      MakeIFieldGet(ret, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(ret, read_bottom);
+
+  PerformLSE();
 
   EXPECT_INS_RETAINED(read_bottom) << *read_bottom;
   EXPECT_INS_RETAINED(write_right) << *write_right;
@@ -1977,70 +1882,32 @@ TEST_F(LoadStoreEliminationTest, PartialLoadPreserved) {
 TEST_F(LoadStoreEliminationTest, PartialLoadPreserved2) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry",
-                                                 "exit_REAL",
-                                                 { { "entry", "left" },
-                                                   { "entry", "right_start" },
-                                                   { "left", "exit" },
-                                                   { "right_start", "right_first" },
-                                                   { "right_start", "right_second" },
-                                                   { "right_first", "right_end" },
-                                                   { "right_second", "right_end" },
-                                                   { "right_end", "exit" },
-                                                   { "exit", "exit_REAL" } }));
-  HBasicBlock* entry = blks.Get("entry");
-  HBasicBlock* left = blks.Get("left");
-  HBasicBlock* right_start = blks.Get("right_start");
-  HBasicBlock* right_first = blks.Get("right_first");
-  HBasicBlock* right_second = blks.Get("right_second");
-  HBasicBlock* right_end = blks.Get("right_end");
-  HBasicBlock* exit = blks.Get("exit");
+  HBasicBlock* ret = InitEntryMainExitGraph(&vshs);
+
   HInstruction* bool_value = MakeParam(DataType::Type::kBool);
   HInstruction* bool_value_2 = MakeParam(DataType::Type::kBool);
   HInstruction* c1 = graph_->GetIntConstant(1);
   HInstruction* c2 = graph_->GetIntConstant(2);
   HInstruction* c3 = graph_->GetIntConstant(3);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(if_inst);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_left = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* call_left = MakeInvoke(DataType::Type::kVoid, { new_inst });
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  left->AddInstruction(write_left);
-  left->AddInstruction(call_left);
-  left->AddInstruction(goto_left);
-  call_left->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* right_if = new (GetAllocator()) HIf(bool_value_2);
-  right_start->AddInstruction(right_if);
-
-  HInstruction* write_right_first = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* goto_right_first = new (GetAllocator()) HGoto();
-  right_first->AddInstruction(write_right_first);
-  right_first->AddInstruction(goto_right_first);
-
-  HInstruction* write_right_second = MakeIFieldSet(new_inst, c3, MemberOffset(32));
-  HInstruction* goto_right_second = new (GetAllocator()) HGoto();
-  right_second->AddInstruction(write_right_second);
-  right_second->AddInstruction(goto_right_second);
-
-  HInstruction* goto_right_end = new (GetAllocator()) HGoto();
-  right_end->AddInstruction(goto_right_end);
-
-  HInstruction* read_bottom = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_bottom);
-  exit->AddInstruction(read_bottom);
-  exit->AddInstruction(return_exit);
+  auto [start, left, right_end] = CreateDiamondPattern(ret, bool_value);
+  auto [right_start, right_first, right_second] = CreateDiamondPattern(right_end, bool_value_2);
 
-  PerformLSE(blks);
+  HInstruction* cls = MakeLoadClass(start);
+  HInstruction* new_inst = MakeNewInstance(start, cls);
+
+  HInstruction* write_left = MakeIFieldSet(left, new_inst, c1, MemberOffset(32));
+  HInstruction* call_left = MakeInvokeStatic(left, DataType::Type::kVoid, { new_inst });
+
+  HInstruction* write_right_first = MakeIFieldSet(right_first, new_inst, c2, MemberOffset(32));
+
+  HInstruction* write_right_second = MakeIFieldSet(right_second, new_inst, c3, MemberOffset(32));
+
+  HInstruction* read_bottom =
+      MakeIFieldGet(ret, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(ret, read_bottom);
+
+  PerformLSE();
 
   EXPECT_INS_RETAINED(read_bottom);
   EXPECT_INS_RETAINED(write_right_first);
@@ -2101,48 +1968,30 @@ TEST_F(LoadStoreEliminationTest, PartialLoadPreserved3) {
   HInstruction* c2 = graph_->GetIntConstant(2);
   HInstruction* c3 = graph_->GetIntConstant(3);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* goto_entry = new (GetAllocator()) HGoto();
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(goto_entry);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry_post->AddInstruction(if_inst);
-
-  HInstruction* write_left_pre = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* goto_left_pre = new (GetAllocator()) HGoto();
-  left_pre->AddInstruction(write_left_pre);
-  left_pre->AddInstruction(goto_left_pre);
-
-  HInstruction* suspend_left_loop = new (GetAllocator()) HSuspendCheck();
-  HInstruction* call_left_loop = MakeInvoke(DataType::Type::kBool, {new_inst});
-  HInstruction* if_left_loop = new (GetAllocator()) HIf(call_left_loop);
-  left_loop->AddInstruction(suspend_left_loop);
-  left_loop->AddInstruction(call_left_loop);
-  left_loop->AddInstruction(if_left_loop);
-  suspend_left_loop->CopyEnvironmentFrom(cls->GetEnvironment());
-  call_left_loop->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_left_loop = MakeIFieldSet(new_inst, c3, MemberOffset(32));
-  HInstruction* goto_left_loop = new (GetAllocator()) HGoto();
-  left_loop_post->AddInstruction(write_left_loop);
-  left_loop_post->AddInstruction(goto_left_loop);
-
-  HInstruction* write_right = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(write_right);
-  right->AddInstruction(goto_right);
-
-  HInstruction* read_return = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_final = new (GetAllocator()) HReturn(read_return);
-  return_block->AddInstruction(read_return);
-  return_block->AddInstruction(return_final);
-
-  SetupExit(exit);
+  HInstruction* cls = MakeLoadClass(entry);
+  HInstruction* new_inst = MakeNewInstance(entry, cls);
+  MakeGoto(entry);
+
+  MakeIf(entry_post, bool_value);
+
+  HInstruction* write_left_pre = MakeIFieldSet(left_pre, new_inst, c1, MemberOffset(32));
+  MakeGoto(left_pre);
+
+  HInstruction* suspend_left_loop = MakeSuspendCheck(left_loop);
+  HInstruction* call_left_loop = MakeInvokeStatic(left_loop, DataType::Type::kBool, {new_inst});
+  MakeIf(left_loop, call_left_loop);
+
+  HInstruction* write_left_loop = MakeIFieldSet(left_loop_post, new_inst, c3, MemberOffset(32));
+  MakeGoto(left_loop_post);
+
+  HInstruction* write_right = MakeIFieldSet(right, new_inst, c2, MemberOffset(32));
+  MakeGoto(right);
+
+  HInstruction* read_return =
+      MakeIFieldGet(return_block, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(return_block, read_return);
+
+  MakeExit(exit);
 
   PerformLSE(blks);
 
@@ -2207,48 +2056,29 @@ TEST_F(LoadStoreEliminationTest, DISABLED_PartialLoadPreserved4) {
   HInstruction* c2 = graph_->GetIntConstant(2);
   HInstruction* c3 = graph_->GetIntConstant(3);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* goto_entry = new (GetAllocator()) HGoto();
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(goto_entry);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry_post->AddInstruction(if_inst);
-
-  HInstruction* write_left_pre = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* goto_left_pre = new (GetAllocator()) HGoto();
-  left_pre->AddInstruction(write_left_pre);
-  left_pre->AddInstruction(goto_left_pre);
-
-  HInstruction* suspend_left_loop = new (GetAllocator()) HSuspendCheck();
-  HInstruction* call_left_loop = MakeInvoke(DataType::Type::kBool, {});
-  HInstruction* write_left_loop = MakeIFieldSet(new_inst, c3, MemberOffset(32));
-  HInstruction* if_left_loop = new (GetAllocator()) HIf(call_left_loop);
-  left_loop->AddInstruction(suspend_left_loop);
-  left_loop->AddInstruction(call_left_loop);
-  left_loop->AddInstruction(write_left_loop);
-  left_loop->AddInstruction(if_left_loop);
-  suspend_left_loop->CopyEnvironmentFrom(cls->GetEnvironment());
-  call_left_loop->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_right = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* call_right = MakeInvoke(DataType::Type::kBool, {new_inst});
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(write_right);
-  right->AddInstruction(call_right);
-  right->AddInstruction(goto_right);
-  call_right->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* read_return = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_final = new (GetAllocator()) HReturn(read_return);
-  return_block->AddInstruction(read_return);
-  return_block->AddInstruction(return_final);
-
-  SetupExit(exit);
+  HInstruction* cls = MakeLoadClass(entry);
+  HInstruction* new_inst = MakeNewInstance(entry, cls);
+  MakeGoto(entry);
+
+  MakeIf(entry_post, bool_value);
+
+  HInstruction* write_left_pre = MakeIFieldSet(left_pre, new_inst, c1, MemberOffset(32));
+  MakeGoto(left_pre);
+
+  HInstruction* suspend_left_loop = MakeSuspendCheck(left_loop);
+  HInstruction* call_left_loop = MakeInvokeStatic(left_loop, DataType::Type::kBool, {});
+  HInstruction* write_left_loop = MakeIFieldSet(left_loop, new_inst, c3, MemberOffset(32));
+  MakeIf(left_loop, call_left_loop);
+
+  HInstruction* write_right = MakeIFieldSet(right, new_inst, c2, MemberOffset(32));
+  HInstruction* call_right = MakeInvokeStatic(right, DataType::Type::kBool, {new_inst});
+  MakeGoto(right);
+
+  HInstruction* read_return =
+      MakeIFieldGet(return_block, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(return_block, read_return);
+
+  MakeExit(exit);
 
   PerformLSE(blks);
 
@@ -2282,61 +2112,30 @@ TEST_F(LoadStoreEliminationTest, DISABLED_PartialLoadPreserved4) {
 TEST_F(LoadStoreEliminationTest, PartialLoadPreserved5) {
   ScopedObjectAccess soa(Thread::Current());
   VariableSizedHandleScope vshs(soa.Self());
-  CreateGraph(&vshs);
-  AdjacencyListGraph blks(SetupFromAdjacencyList("entry",
-                                                 "exit",
-                                                 {{"entry", "left"},
-                                                  {"entry", "right"},
-                                                  {"left", "breturn"},
-                                                  {"right", "breturn"},
-                                                  {"breturn", "exit"}}));
-#define GET_BLOCK(name) HBasicBlock* name = blks.Get(#name)
-  GET_BLOCK(entry);
-  GET_BLOCK(exit);
-  GET_BLOCK(breturn);
-  GET_BLOCK(left);
-  GET_BLOCK(right);
-#undef GET_BLOCK
+  HBasicBlock* breturn = InitEntryMainExitGraph(&vshs);
+
   HInstruction* bool_value = MakeParam(DataType::Type::kBool);
   HInstruction* c1 = graph_->GetIntConstant(1);
   HInstruction* c2 = graph_->GetIntConstant(2);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(if_inst);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* call_left = MakeInvoke(DataType::Type::kVoid, { new_inst });
-  HInstruction* write_left = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* call2_left = MakeInvoke(DataType::Type::kVoid, {});
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  left->AddInstruction(call_left);
-  left->AddInstruction(write_left);
-  left->AddInstruction(call2_left);
-  left->AddInstruction(goto_left);
-  call_left->CopyEnvironmentFrom(cls->GetEnvironment());
-  call2_left->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_right = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* call_right = MakeInvoke(DataType::Type::kVoid, {});
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(write_right);
-  right->AddInstruction(call_right);
-  right->AddInstruction(goto_right);
-  call_right->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* read_bottom = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_bottom);
-  breturn->AddInstruction(read_bottom);
-  breturn->AddInstruction(return_exit);
-
-  SetupExit(exit);
+  auto [start, left, right] = CreateDiamondPattern(breturn, bool_value);
 
-  PerformLSE(blks);
+  // start
+  HInstruction* cls = MakeLoadClass(start);
+  HInstruction* new_inst = MakeNewInstance(start, cls);
+
+  HInstruction* call_left = MakeInvokeStatic(left, DataType::Type::kVoid, { new_inst });
+  HInstruction* write_left = MakeIFieldSet(left, new_inst, c1, MemberOffset(32));
+  HInstruction* call2_left = MakeInvokeStatic(left, DataType::Type::kVoid, {});
+
+  HInstruction* write_right = MakeIFieldSet(right, new_inst, c2, MemberOffset(32));
+  HInstruction* call_right = MakeInvokeStatic(right, DataType::Type::kVoid, {});
+
+  HInstruction* read_bottom =
+      MakeIFieldGet(breturn, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(breturn, read_bottom);
+
+  PerformLSE();
 
   EXPECT_INS_RETAINED(read_bottom);
   EXPECT_INS_RETAINED(write_right);
@@ -2385,39 +2184,24 @@ TEST_F(LoadStoreEliminationTest, DISABLED_PartialLoadPreserved6) {
   HInstruction* c2 = graph_->GetIntConstant(2);
   HInstruction* c3 = graph_->GetIntConstant(3);
 
-  HInstruction* cls = MakeClassLoad();
-  HInstruction* new_inst = MakeNewInstance(cls);
-  HInstruction* write_entry = MakeIFieldSet(new_inst, c3, MemberOffset(32));
-  HInstruction* call_entry = MakeInvoke(DataType::Type::kVoid, {});
-  HInstruction* if_inst = new (GetAllocator()) HIf(bool_value);
-  entry->AddInstruction(cls);
-  entry->AddInstruction(new_inst);
-  entry->AddInstruction(write_entry);
-  entry->AddInstruction(call_entry);
-  entry->AddInstruction(if_inst);
-  ManuallyBuildEnvFor(cls, {});
-  new_inst->CopyEnvironmentFrom(cls->GetEnvironment());
-  call_entry->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* call_left = MakeInvoke(DataType::Type::kVoid, { new_inst });
-  HInstruction* write_left = MakeIFieldSet(new_inst, c1, MemberOffset(32));
-  HInstruction* goto_left = new (GetAllocator()) HGoto();
-  left->AddInstruction(call_left);
-  left->AddInstruction(write_left);
-  left->AddInstruction(goto_left);
-  call_left->CopyEnvironmentFrom(cls->GetEnvironment());
-
-  HInstruction* write_right = MakeIFieldSet(new_inst, c2, MemberOffset(32));
-  HInstruction* goto_right = new (GetAllocator()) HGoto();
-  right->AddInstruction(write_right);
-  right->AddInstruction(goto_right);
-
-  HInstruction* read_bottom = MakeIFieldGet(new_inst, DataType::Type::kInt32, MemberOffset(32));
-  HInstruction* return_exit = new (GetAllocator()) HReturn(read_bottom);
-  breturn->AddInstruction(read_bottom);
-  breturn->AddInstruction(return_exit);
-
-  SetupExit(exit);
+  HInstruction* cls = MakeLoadClass(entry);
+  HInstruction* new_inst = MakeNewInstance(entry, cls);
+  HInstruction* write_entry = MakeIFieldSet(entry, new_inst, c3, MemberOffset(32));
+  HInstruction* call_entry = MakeInvokeStatic(entry, DataType::Type::kVoid, {});
+  MakeIf(entry, bool_value);
+
+  HInstruction* call_left = MakeInvokeStatic(left, DataType::Type::kVoid, { new_inst });
+  HInstruction* write_left = MakeIFieldSet(left, new_inst, c1, MemberOffset(32));
+  MakeGoto(left);
+
+  HInstruction* write_right = MakeIFieldSet(right, new_inst, c2, MemberOffset(32));
+  MakeGoto(right);
+
+  HInstruction* read_bottom =
+      MakeIFieldGet(breturn, new_inst, DataType::Type::kInt32, MemberOffset(32));
+  MakeReturn(breturn, read_bottom);
+
+  MakeExit(exit);
 
   PerformLSE(blks);
 
diff --git a/compiler/optimizing/loop_optimization.cc b/compiler/optimizing/loop_optimization.cc
index 8d698d6c82..215986910b 100644
--- a/compiler/optimizing/loop_optimization.cc
+++ b/compiler/optimizing/loop_optimization.cc
@@ -1094,9 +1094,16 @@ bool HLoopOptimization::TryFullUnrolling(LoopAnalysisInfo* analysis_info, bool g
 bool HLoopOptimization::TryLoopScalarOpts(LoopNode* node) {
   HLoopInformation* loop_info = node->loop_info;
   int64_t trip_count = LoopAnalysis::GetLoopTripCount(loop_info, &induction_range_);
+  if (trip_count == 0) {
+    // Mark the loop as dead.
+    HIf* loop_hif = loop_info->GetHeader()->GetLastInstruction()->AsIf();
+    int32_t constant = loop_info->Contains(*loop_hif->IfTrueSuccessor()) ? 0 : 1;
+    loop_hif->ReplaceInput(graph_->GetIntConstant(constant), 0u);
+    return true;
+  }
+
   LoopAnalysisInfo analysis_info(loop_info);
   LoopAnalysis::CalculateLoopBasicProperties(loop_info, &analysis_info, trip_count);
-
   if (analysis_info.HasInstructionsPreventingScalarOpts() ||
       arch_loop_helper_->IsLoopNonBeneficialForScalarOpts(&analysis_info)) {
     return false;
diff --git a/compiler/optimizing/loop_optimization_test.cc b/compiler/optimizing/loop_optimization_test.cc
index 7f694fb655..81867beb4b 100644
--- a/compiler/optimizing/loop_optimization_test.cc
+++ b/compiler/optimizing/loop_optimization_test.cc
@@ -64,13 +64,9 @@ class LoopOptimizationTest : public OptimizingUnitTest {
     graph_->AddBlock(exit_block_);
     graph_->SetEntryBlock(entry_block_);
     graph_->SetExitBlock(exit_block_);
-    parameter_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                      dex::TypeIndex(0),
-                                                      0,
-                                                      DataType::Type::kInt32);
-    entry_block_->AddInstruction(parameter_);
-    return_block_->AddInstruction(new (GetAllocator()) HReturnVoid());
-    exit_block_->AddInstruction(new (GetAllocator()) HExit());
+    parameter_ = MakeParam(DataType::Type::kInt32);
+    MakeReturnVoid(return_block_);
+    MakeExit(exit_block_);
     entry_block_->AddSuccessor(return_block_);
     return_block_->AddSuccessor(exit_block_);
   }
@@ -85,9 +81,9 @@ class LoopOptimizationTest : public OptimizingUnitTest {
     position->ReplaceSuccessor(successor, header);
     header->AddSuccessor(body);
     header->AddSuccessor(successor);
-    header->AddInstruction(new (GetAllocator()) HIf(parameter_));
+    MakeIf(header, parameter_);
     body->AddSuccessor(header);
-    body->AddInstruction(new (GetAllocator()) HGoto());
+    MakeGoto(body);
     return header;
   }
 
@@ -230,13 +226,12 @@ TEST_F(LoopOptimizationTest, SimplifyLoopReoderPredecessors) {
   DCHECK(header->GetSuccessors()[1] == return_block_);
 
   // Data flow.
-  header->AddInstruction(new (GetAllocator()) HIf(parameter_));
-  body->AddInstruction(new (GetAllocator()) HGoto());
+  MakeIf(header, parameter_);
+  MakeGoto(body);
 
   HPhi* phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  HInstruction* add = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi, parameter_);
   header->AddPhi(phi);
-  body->AddInstruction(add);
+  HInstruction* add = MakeBinOp<HAdd>(body, DataType::Type::kInt32, phi, parameter_);
 
   phi->AddInput(add);
   phi->AddInput(parameter_);
@@ -281,9 +276,9 @@ TEST_F(LoopOptimizationTest, SimplifyLoopSinglePreheader) {
   preheader0->AddSuccessor(header);
   preheader1->AddSuccessor(header);
 
-  if_block->AddInstruction(new (GetAllocator()) HIf(parameter_));
-  preheader0->AddInstruction(new (GetAllocator()) HGoto());
-  preheader1->AddInstruction(new (GetAllocator()) HGoto());
+  MakeIf(if_block, parameter_);
+  MakeGoto(preheader0);
+  MakeGoto(preheader1);
 
   HBasicBlock* body = header->GetSuccessors()[0];
   DCHECK(body != return_block_);
@@ -293,16 +288,13 @@ TEST_F(LoopOptimizationTest, SimplifyLoopSinglePreheader) {
   HIntConstant* const_1 = graph_->GetIntConstant(1);
   HIntConstant* const_2 = graph_->GetIntConstant(2);
 
-  HAdd* preheader0_add = new (GetAllocator()) HAdd(DataType::Type::kInt32, parameter_, const_0);
-  preheader0->AddInstruction(preheader0_add);
-  HAdd* preheader1_add = new (GetAllocator()) HAdd(DataType::Type::kInt32, parameter_, const_1);
-  preheader1->AddInstruction(preheader1_add);
+  HAdd* preheader0_add = MakeBinOp<HAdd>(preheader0, DataType::Type::kInt32, parameter_, const_0);
+  HAdd* preheader1_add = MakeBinOp<HAdd>(preheader1, DataType::Type::kInt32, parameter_, const_1);
 
   HPhi* header_phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
   header->AddPhi(header_phi);
 
-  HAdd* body_add = new (GetAllocator()) HAdd(DataType::Type::kInt32, parameter_, const_2);
-  body->AddInstruction(body_add);
+  HAdd* body_add = MakeBinOp<HAdd>(body, DataType::Type::kInt32, parameter_, const_2);
 
   DCHECK(header->GetPredecessors()[0] == body);
   DCHECK(header->GetPredecessors()[1] == preheader0);
diff --git a/compiler/optimizing/nodes.cc b/compiler/optimizing/nodes.cc
index f2cac19786..32ae89eeea 100644
--- a/compiler/optimizing/nodes.cc
+++ b/compiler/optimizing/nodes.cc
@@ -1829,7 +1829,7 @@ HConstant* HBinaryOperation::TryStaticEvaluation(HInstruction* left, HInstructio
   } else if (left->IsLongConstant()) {
     if (right->IsIntConstant()) {
       // The binop(long, int) case is only valid for shifts and rotations.
-      DCHECK(IsShl() || IsShr() || IsUShr() || IsRor()) << DebugName();
+      DCHECK(IsShl() || IsShr() || IsUShr() || IsRol() || IsRor()) << DebugName();
       return Evaluate(left->AsLongConstant(), right->AsIntConstant());
     } else if (right->IsLongConstant()) {
       return Evaluate(left->AsLongConstant(), right->AsLongConstant());
@@ -3340,45 +3340,25 @@ HInstruction* ReplaceInstrOrPhiByClone(HInstruction* instr) {
   return clone;
 }
 
-// Returns an instruction with the opposite Boolean value from 'cond'.
-HInstruction* HGraph::InsertOppositeCondition(HInstruction* cond, HInstruction* cursor) {
+HCondition* HGraph::CreateCondition(IfCondition cond,
+                                    HInstruction* lhs,
+                                    HInstruction* rhs,
+                                    uint32_t dex_pc) {
   ArenaAllocator* allocator = GetAllocator();
-
-  if (cond->IsCondition() &&
-      !DataType::IsFloatingPointType(cond->InputAt(0)->GetType())) {
-    // Can't reverse floating point conditions.  We have to use HBooleanNot in that case.
-    HInstruction* lhs = cond->InputAt(0);
-    HInstruction* rhs = cond->InputAt(1);
-    HInstruction* replacement = nullptr;
-    switch (cond->AsCondition()->GetOppositeCondition()) {  // get *opposite*
-      case kCondEQ: replacement = new (allocator) HEqual(lhs, rhs); break;
-      case kCondNE: replacement = new (allocator) HNotEqual(lhs, rhs); break;
-      case kCondLT: replacement = new (allocator) HLessThan(lhs, rhs); break;
-      case kCondLE: replacement = new (allocator) HLessThanOrEqual(lhs, rhs); break;
-      case kCondGT: replacement = new (allocator) HGreaterThan(lhs, rhs); break;
-      case kCondGE: replacement = new (allocator) HGreaterThanOrEqual(lhs, rhs); break;
-      case kCondB:  replacement = new (allocator) HBelow(lhs, rhs); break;
-      case kCondBE: replacement = new (allocator) HBelowOrEqual(lhs, rhs); break;
-      case kCondA:  replacement = new (allocator) HAbove(lhs, rhs); break;
-      case kCondAE: replacement = new (allocator) HAboveOrEqual(lhs, rhs); break;
-      default:
-        LOG(FATAL) << "Unexpected condition";
-        UNREACHABLE();
-    }
-    cursor->GetBlock()->InsertInstructionBefore(replacement, cursor);
-    return replacement;
-  } else if (cond->IsIntConstant()) {
-    HIntConstant* int_const = cond->AsIntConstant();
-    if (int_const->IsFalse()) {
-      return GetIntConstant(1);
-    } else {
-      DCHECK(int_const->IsTrue()) << int_const->GetValue();
-      return GetIntConstant(0);
-    }
-  } else {
-    HInstruction* replacement = new (allocator) HBooleanNot(cond);
-    cursor->GetBlock()->InsertInstructionBefore(replacement, cursor);
-    return replacement;
+  switch (cond) {
+    case kCondEQ: return new (allocator) HEqual(lhs, rhs, dex_pc);
+    case kCondNE: return new (allocator) HNotEqual(lhs, rhs, dex_pc);
+    case kCondLT: return new (allocator) HLessThan(lhs, rhs, dex_pc);
+    case kCondLE: return new (allocator) HLessThanOrEqual(lhs, rhs, dex_pc);
+    case kCondGT: return new (allocator) HGreaterThan(lhs, rhs, dex_pc);
+    case kCondGE: return new (allocator) HGreaterThanOrEqual(lhs, rhs, dex_pc);
+    case kCondB:  return new (allocator) HBelow(lhs, rhs, dex_pc);
+    case kCondBE: return new (allocator) HBelowOrEqual(lhs, rhs, dex_pc);
+    case kCondA:  return new (allocator) HAbove(lhs, rhs, dex_pc);
+    case kCondAE: return new (allocator) HAboveOrEqual(lhs, rhs, dex_pc);
+    default:
+      LOG(FATAL) << "Unexpected condition " << cond;
+      UNREACHABLE();
   }
 }
 
@@ -3422,7 +3402,7 @@ std::ostream& operator<<(std::ostream& os, TypeCheckKind rhs) {
 #define CHECK_INTRINSICS_ENUM_VALUES(Name, InvokeType, _, SideEffects, Exceptions, ...) \
   static_assert( \
     static_cast<uint32_t>(Intrinsics::k ## Name) <= (kAccIntrinsicBits >> CTZ(kAccIntrinsicBits)), \
-    "Instrinsics enumeration space overflow.");
+    "Intrinsics enumeration space overflow.");
   ART_INTRINSICS_LIST(CHECK_INTRINSICS_ENUM_VALUES)
 #undef CHECK_INTRINSICS_ENUM_VALUES
 
@@ -3470,7 +3450,7 @@ static inline IntrinsicExceptions GetExceptionsIntrinsic(Intrinsics i) {
 
 void HInvoke::SetResolvedMethod(ArtMethod* method, bool enable_intrinsic_opt) {
   if (method != nullptr && method->IsIntrinsic() && enable_intrinsic_opt) {
-    Intrinsics intrinsic = static_cast<Intrinsics>(method->GetIntrinsic());
+    Intrinsics intrinsic = method->GetIntrinsic();
     SetIntrinsic(intrinsic,
                  NeedsEnvironmentIntrinsic(intrinsic),
                  GetSideEffectsIntrinsic(intrinsic),
diff --git a/compiler/optimizing/nodes.h b/compiler/optimizing/nodes.h
index 1e3aca64db..2477c9fe51 100644
--- a/compiler/optimizing/nodes.h
+++ b/compiler/optimizing/nodes.h
@@ -58,6 +58,7 @@ class ArenaStack;
 class CodeGenerator;
 class GraphChecker;
 class HBasicBlock;
+class HCondition;
 class HConstructorFence;
 class HCurrentMethod;
 class HDoubleConstant;
@@ -732,10 +733,10 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
   void SetProfilingInfo(ProfilingInfo* info) { profiling_info_ = info; }
   ProfilingInfo* GetProfilingInfo() const { return profiling_info_; }
 
-  // Returns an instruction with the opposite Boolean value from 'cond'.
-  // The instruction has been inserted into the graph, either as a constant, or
-  // before cursor.
-  HInstruction* InsertOppositeCondition(HInstruction* cond, HInstruction* cursor);
+  HCondition* CreateCondition(IfCondition cond,
+                              HInstruction* lhs,
+                              HInstruction* rhs,
+                              uint32_t dex_pc = kNoDexPc);
 
   ReferenceTypeInfo GetInexactObjectRti() {
     return ReferenceTypeInfo::Create(handle_cache_.GetObjectClassHandle(), /* is_exact= */ false);
@@ -1592,6 +1593,7 @@ class HLoopInformationOutwardIterator : public ValueObject {
   M(Rem, BinaryOperation)                                               \
   M(Return, Instruction)                                                \
   M(ReturnVoid, Instruction)                                            \
+  M(Rol, BinaryOperation)                                               \
   M(Ror, BinaryOperation)                                               \
   M(Shl, BinaryOperation)                                               \
   M(Shr, BinaryOperation)                                               \
@@ -4522,6 +4524,7 @@ class HCompare final : public HBinaryOperation {
                          SideEffectsForArchRuntimeCalls(comparison_type),
                          dex_pc) {
     SetPackedField<ComparisonBiasField>(bias);
+    SetPackedField<ComparisonTypeField>(comparison_type);
   }
 
   template <typename T>
@@ -4541,10 +4544,16 @@ class HCompare final : public HBinaryOperation {
     // graph. However HCompare integer instructions can be synthesized
     // by the instruction simplifier to implement IntegerCompare and
     // IntegerSignum intrinsics, so we have to handle this case.
-    return MakeConstantComparison(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    const int32_t value = DataType::IsUnsignedType(GetComparisonType()) ?
+        Compute(x->GetValueAsUint64(), y->GetValueAsUint64()) :
+        Compute(x->GetValue(), y->GetValue());
+    return MakeConstantComparison(value, GetDexPc());
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantComparison(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    const int32_t value = DataType::IsUnsignedType(GetComparisonType()) ?
+        Compute(x->GetValueAsUint64(), y->GetValueAsUint64()) :
+        Compute(x->GetValue(), y->GetValue());
+    return MakeConstantComparison(value, GetDexPc());
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
     return MakeConstantComparison(ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
@@ -4559,6 +4568,10 @@ class HCompare final : public HBinaryOperation {
 
   ComparisonBias GetBias() const { return GetPackedField<ComparisonBiasField>(); }
 
+  DataType::Type GetComparisonType() const { return GetPackedField<ComparisonTypeField>(); }
+
+  void SetComparisonType(DataType::Type newType) { SetPackedField<ComparisonTypeField>(newType); }
+
   // Does this compare instruction have a "gt bias" (vs an "lt bias")?
   // Only meaningful for floating-point comparisons.
   bool IsGtBias() const {
@@ -4577,11 +4590,16 @@ class HCompare final : public HBinaryOperation {
   static constexpr size_t kFieldComparisonBias = kNumberOfGenericPackedBits;
   static constexpr size_t kFieldComparisonBiasSize =
       MinimumBitsToStore(static_cast<size_t>(ComparisonBias::kLast));
+  static constexpr size_t kFieldComparisonType = kFieldComparisonBias + kFieldComparisonBiasSize;
+  static constexpr size_t kFieldComparisonTypeSize =
+      MinimumBitsToStore(static_cast<size_t>(DataType::Type::kLast));
   static constexpr size_t kNumberOfComparePackedBits =
-      kFieldComparisonBias + kFieldComparisonBiasSize;
+      kFieldComparisonType + kFieldComparisonTypeSize;
   static_assert(kNumberOfComparePackedBits <= kMaxNumberOfPackedBits, "Too many packed fields.");
   using ComparisonBiasField =
       BitField<ComparisonBias, kFieldComparisonBias, kFieldComparisonBiasSize>;
+  using ComparisonTypeField =
+      BitField<DataType::Type, kFieldComparisonType, kFieldComparisonTypeSize>;
 
   // Return an integer constant containing the result of a comparison evaluated at compile time.
   HIntConstant* MakeConstantComparison(int32_t value, uint32_t dex_pc) const {
@@ -4895,6 +4913,7 @@ class HInvokePolymorphic final : public HInvoke {
  public:
   HInvokePolymorphic(ArenaAllocator* allocator,
                      uint32_t number_of_arguments,
+                     uint32_t number_of_other_inputs,
                      DataType::Type return_type,
                      uint32_t dex_pc,
                      MethodReference method_reference,
@@ -4907,7 +4926,7 @@ class HInvokePolymorphic final : public HInvoke {
       : HInvoke(kInvokePolymorphic,
                 allocator,
                 number_of_arguments,
-                /* number_of_other_inputs= */ 0u,
+                number_of_other_inputs,
                 return_type,
                 dex_pc,
                 method_reference,
@@ -4921,6 +4940,13 @@ class HInvokePolymorphic final : public HInvoke {
 
   dex::ProtoIndex GetProtoIndex() { return proto_idx_; }
 
+  // Whether we can do direct invocation of the method handle.
+  bool CanHaveFastPath() const {
+    return GetIntrinsic() == Intrinsics::kMethodHandleInvokeExact &&
+        GetNumberOfArguments() >= 2 &&
+        InputAt(1)->GetType() == DataType::Type::kReference;
+  }
+
   DECLARE_INSTRUCTION(InvokePolymorphic);
 
  protected:
@@ -5973,6 +5999,31 @@ class HRor final : public HBinaryOperation {
   DEFAULT_COPY_CONSTRUCTOR(Ror);
 };
 
+class HRol final : public HBinaryOperation {
+ public:
+  HRol(DataType::Type result_type, HInstruction* value, HInstruction* distance)
+      : HBinaryOperation(kRol, result_type, value, distance) {}
+
+  template <typename T>
+  static T Compute(T value, int32_t distance, int32_t max_shift_value) {
+    return HRor::Compute(value, -distance, max_shift_value);
+  }
+
+  HConstant* Evaluate(HIntConstant* value, HIntConstant* distance) const override {
+    return GetBlock()->GetGraph()->GetIntConstant(
+        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance), GetDexPc());
+  }
+  HConstant* Evaluate(HLongConstant* value, HIntConstant* distance) const override {
+    return GetBlock()->GetGraph()->GetLongConstant(
+        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance), GetDexPc());
+  }
+
+  DECLARE_INSTRUCTION(Rol);
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(Rol);
+};
+
 // The value of a parameter in this method. Its location depends on
 // the calling convention.
 class HParameterValue final : public HExpression<0> {
@@ -6201,7 +6252,7 @@ inline std::ostream& operator<<(std::ostream& os, const FieldInfo& a) {
 
 class HInstanceFieldGet final : public HExpression<1> {
  public:
-  HInstanceFieldGet(HInstruction* value,
+  HInstanceFieldGet(HInstruction* object,
                     ArtField* field,
                     DataType::Type field_type,
                     MemberOffset field_offset,
@@ -6221,7 +6272,7 @@ class HInstanceFieldGet final : public HExpression<1> {
                     field_idx,
                     declaring_class_def_index,
                     dex_file) {
-    SetRawInputAt(0, value);
+    SetRawInputAt(0, object);
   }
 
   bool IsClonable() const override { return true; }
@@ -7218,6 +7269,8 @@ class HLoadMethodType final : public HInstruction {
   enum class LoadKind {
     // Load from an entry in the .bss section using a PC-relative load.
     kBssEntry,
+    // Load from the root table associated with the JIT compiled method.
+    kJitTableAddress,
     // Load using a single runtime call.
     kRuntimeCall,
 
@@ -7254,6 +7307,10 @@ class HLoadMethodType final : public HInstruction {
 
   dex::ProtoIndex GetProtoIndex() const { return proto_index_; }
 
+  Handle<mirror::MethodType> GetMethodType() const { return method_type_; }
+
+  void SetMethodType(Handle<mirror::MethodType> method_type) { method_type_ = method_type; }
+
   const DexFile& GetDexFile() const { return dex_file_; }
 
   static SideEffects SideEffectsForArchRuntimeCalls() {
@@ -7283,6 +7340,8 @@ class HLoadMethodType final : public HInstruction {
 
   const dex::ProtoIndex proto_index_;
   const DexFile& dex_file_;
+
+  Handle<mirror::MethodType> method_type_;
 };
 
 std::ostream& operator<<(std::ostream& os, HLoadMethodType::LoadKind rhs);
@@ -7293,6 +7352,7 @@ inline void HLoadMethodType::SetLoadKind(LoadKind load_kind) {
   DCHECK(GetBlock() == nullptr);
   DCHECK(GetEnvironment() == nullptr);
   DCHECK_EQ(GetLoadKind(), LoadKind::kRuntimeCall);
+  DCHECK_IMPLIES(GetLoadKind() == LoadKind::kJitTableAddress, GetMethodType() != nullptr);
   SetPackedField<LoadKindField>(load_kind);
 }
 
diff --git a/compiler/optimizing/nodes_test.cc b/compiler/optimizing/nodes_test.cc
index 29210fe10f..1a1d9ac7da 100644
--- a/compiler/optimizing/nodes_test.cc
+++ b/compiler/optimizing/nodes_test.cc
@@ -143,37 +143,16 @@ TEST_F(NodeTest, ClearDominanceThenLoopInformation) {
  * and environment lists.
  */
 TEST_F(NodeTest, RemoveInstruction) {
-  HGraph* graph = CreateGraph();
-  HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(entry);
-  graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
-  entry->AddInstruction(new (GetAllocator()) HGoto());
-
-  HBasicBlock* first_block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(first_block);
-  entry->AddSuccessor(first_block);
-  HInstruction* null_check = new (GetAllocator()) HNullCheck(parameter, 0);
-  first_block->AddInstruction(null_check);
-  first_block->AddInstruction(new (GetAllocator()) HReturnVoid());
-
-  HBasicBlock* exit_block = new (GetAllocator()) HBasicBlock(graph);
-  graph->AddBlock(exit_block);
-  first_block->AddSuccessor(exit_block);
-  exit_block->AddInstruction(new (GetAllocator()) HExit());
-
-  HEnvironment* environment = new (GetAllocator()) HEnvironment(
-      GetAllocator(), 1, graph->GetArtMethod(), 0, null_check);
-  null_check->SetRawEnvironment(environment);
-  environment->SetRawEnvAt(0, parameter);
-  parameter->AddEnvUseAt(null_check->GetEnvironment(), 0);
+  HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
+
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
+
+  HInstruction* null_check = MakeNullCheck(main, parameter, /*env=*/ {parameter});
 
   ASSERT_TRUE(parameter->HasEnvironmentUses());
   ASSERT_TRUE(parameter->HasUses());
 
-  first_block->RemoveInstruction(null_check);
+  main->RemoveInstruction(null_check);
 
   ASSERT_FALSE(parameter->HasEnvironmentUses());
   ASSERT_FALSE(parameter->HasUses());
@@ -187,13 +166,9 @@ TEST_F(NodeTest, InsertInstruction) {
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* parameter1 = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* parameter2 = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter1);
-  entry->AddInstruction(parameter2);
-  entry->AddInstruction(new (GetAllocator()) HExit());
+  HInstruction* parameter1 = MakeParam(DataType::Type::kReference);
+  HInstruction* parameter2 = MakeParam(DataType::Type::kReference);
+  MakeExit(entry);
 
   ASSERT_FALSE(parameter1->HasUses());
 
@@ -212,14 +187,11 @@ TEST_F(NodeTest, AddInstruction) {
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
 
   ASSERT_FALSE(parameter->HasUses());
 
-  HInstruction* to_add = new (GetAllocator()) HNullCheck(parameter, 0);
-  entry->AddInstruction(to_add);
+  MakeNullCheck(entry, parameter);
 
   ASSERT_TRUE(parameter->HasUses());
   ASSERT_TRUE(parameter->GetUses().HasExactlyOneElement());
@@ -230,42 +202,32 @@ TEST_F(NodeTest, ParentEnvironment) {
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* parameter1 = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* with_environment = new (GetAllocator()) HNullCheck(parameter1, 0);
-  entry->AddInstruction(parameter1);
-  entry->AddInstruction(with_environment);
-  entry->AddInstruction(new (GetAllocator()) HExit());
+  HInstruction* parameter1 = MakeParam(DataType::Type::kReference);
+  HInstruction* with_environment = MakeNullCheck(entry, parameter1, /*env=*/ {parameter1});
+  MakeExit(entry);
 
   ASSERT_TRUE(parameter1->HasUses());
   ASSERT_TRUE(parameter1->GetUses().HasExactlyOneElement());
 
-  HEnvironment* environment = new (GetAllocator()) HEnvironment(
-      GetAllocator(), 1, graph->GetArtMethod(), 0, with_environment);
-  HInstruction* const array[] = { parameter1 };
-
-  environment->CopyFrom(ArrayRef<HInstruction* const>(array));
-  with_environment->SetRawEnvironment(environment);
-
   ASSERT_TRUE(parameter1->HasEnvironmentUses());
   ASSERT_TRUE(parameter1->GetEnvUses().HasExactlyOneElement());
 
   HEnvironment* parent1 = new (GetAllocator()) HEnvironment(
       GetAllocator(), 1, graph->GetArtMethod(), 0, nullptr);
-  parent1->CopyFrom(ArrayRef<HInstruction* const>(array));
+  parent1->CopyFrom(ArrayRef<HInstruction* const>(&parameter1, 1u));
 
   ASSERT_EQ(parameter1->GetEnvUses().SizeSlow(), 2u);
 
   HEnvironment* parent2 = new (GetAllocator()) HEnvironment(
       GetAllocator(), 1, graph->GetArtMethod(), 0, nullptr);
-  parent2->CopyFrom(ArrayRef<HInstruction* const>(array));
+  parent2->CopyFrom(ArrayRef<HInstruction* const>(&parameter1, 1u));
   parent1->SetAndCopyParentChain(GetAllocator(), parent2);
 
   // One use for parent2, and one other use for the new parent of parent1.
   ASSERT_EQ(parameter1->GetEnvUses().SizeSlow(), 4u);
 
   // We have copied the parent chain. So we now have two more uses.
-  environment->SetAndCopyParentChain(GetAllocator(), parent1);
+  with_environment->GetEnvironment()->SetAndCopyParentChain(GetAllocator(), parent1);
   ASSERT_EQ(parameter1->GetEnvUses().SizeSlow(), 6u);
 }
 
diff --git a/compiler/optimizing/nodes_vector_test.cc b/compiler/optimizing/nodes_vector_test.cc
index e0a48db84f..6120c11d45 100644
--- a/compiler/optimizing/nodes_vector_test.cc
+++ b/compiler/optimizing/nodes_vector_test.cc
@@ -41,21 +41,9 @@ class NodesVectorTest : public OptimizingUnitTest {
     graph_->AddBlock(exit_block_);
     graph_->SetEntryBlock(entry_block_);
     graph_->SetExitBlock(exit_block_);
-    int8_parameter_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                           dex::TypeIndex(1),
-                                                           0,
-                                                           DataType::Type::kInt8);
-    entry_block_->AddInstruction(int8_parameter_);
-    int16_parameter_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                            dex::TypeIndex(2),
-                                                            0,
-                                                            DataType::Type::kInt16);
-    entry_block_->AddInstruction(int16_parameter_);
-    int32_parameter_ = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                            dex::TypeIndex(0),
-                                                            0,
-                                                            DataType::Type::kInt32);
-    entry_block_->AddInstruction(int32_parameter_);
+    int8_parameter_ = MakeParam(DataType::Type::kInt8);
+    int16_parameter_ = MakeParam(DataType::Type::kInt16);
+    int32_parameter_ = MakeParam(DataType::Type::kInt32);
   }
 
   // General building fields.
diff --git a/compiler/optimizing/optimizing_compiler.cc b/compiler/optimizing/optimizing_compiler.cc
index 3f73459a00..89edbed54d 100644
--- a/compiler/optimizing/optimizing_compiler.cc
+++ b/compiler/optimizing/optimizing_compiler.cc
@@ -868,6 +868,11 @@ CodeGenerator* OptimizingCompiler::TryCompile(ArenaAllocator* allocator,
                           compilation_stats_.get());
     GraphAnalysisResult result = builder.BuildGraph();
     if (result != kAnalysisSuccess) {
+      // Don't try recompiling this method again.
+      if (method != nullptr) {
+        ScopedObjectAccess soa(Thread::Current());
+        method->SetDontCompile();
+      }
       SCOPED_TRACE << "Not compiling because of " << result;
       switch (result) {
         case kAnalysisSkipped: {
diff --git a/compiler/optimizing/optimizing_unit_test.h b/compiler/optimizing/optimizing_unit_test.h
index e1d8969b2b..2fe11299fc 100644
--- a/compiler/optimizing/optimizing_unit_test.h
+++ b/compiler/optimizing/optimizing_unit_test.h
@@ -219,7 +219,6 @@ class OptimizingUnitTestHelper {
       : pool_and_allocator_(new ArenaPoolAndAllocator()),
         graph_(nullptr),
         entry_block_(nullptr),
-        return_block_(nullptr),
         exit_block_(nullptr) { }
 
   ArenaAllocator* GetAllocator() { return pool_and_allocator_->GetAllocator(); }
@@ -290,25 +289,104 @@ class OptimizingUnitTestHelper {
     }
   }
 
-  void InitGraph(VariableSizedHandleScope* handles = nullptr) {
+  // Create simple graph with "entry", "main" and "exit" blocks, return the "main" block.
+  // Adds `HGoto` to the "entry" block and `HExit` to the "exit block. Leaves "main" block empty.
+  HBasicBlock* InitEntryMainExitGraph(VariableSizedHandleScope* handles = nullptr) {
     CreateGraph(handles);
     entry_block_ = AddNewBlock();
-    return_block_ = AddNewBlock();
+    HBasicBlock* main_block = AddNewBlock();
     exit_block_ = AddNewBlock();
 
     graph_->SetEntryBlock(entry_block_);
     graph_->SetExitBlock(exit_block_);
 
-    entry_block_->AddSuccessor(return_block_);
-    return_block_->AddSuccessor(exit_block_);
+    entry_block_->AddSuccessor(main_block);
+    main_block->AddSuccessor(exit_block_);
 
-    return_block_->AddInstruction(new (GetAllocator()) HReturnVoid());
-    exit_block_->AddInstruction(new (GetAllocator()) HExit());
+    MakeGoto(entry_block_);
+    MakeExit(exit_block_);
+
+    return main_block;
+  }
+
+  // Creates a graph identical to `InitEntryMainExitGraph()` and adds `HReturnVoid`.
+  HBasicBlock* InitEntryMainExitGraphWithReturnVoid(VariableSizedHandleScope* handles = nullptr) {
+    HBasicBlock* return_block = InitEntryMainExitGraph(handles);
+    MakeReturnVoid(return_block);
+    return return_block;
+  }
+
+  // Insert "if_block", "then_block" and "else_block" before a given `merge_block`. Return the
+  // new blocks. Adds `HGoto` to "then_block" and "else_block". Adds `HIf` to the "if_block"
+  // if the caller provides a `condition`.
+  std::tuple<HBasicBlock*, HBasicBlock*, HBasicBlock*> CreateDiamondPattern(
+      HBasicBlock* merge_block, HInstruction* condition = nullptr) {
+    HBasicBlock* if_block = AddNewBlock();
+    HBasicBlock* then_block = AddNewBlock();
+    HBasicBlock* else_block = AddNewBlock();
+
+    HBasicBlock* predecessor = merge_block->GetSinglePredecessor();
+    predecessor->ReplaceSuccessor(merge_block, if_block);
+
+    if_block->AddSuccessor(then_block);
+    if_block->AddSuccessor(else_block);
+    then_block->AddSuccessor(merge_block);
+    else_block->AddSuccessor(merge_block);
+
+    if (condition != nullptr) {
+      MakeIf(if_block, condition);
+    }
+    MakeGoto(then_block);
+    MakeGoto(else_block);
+
+    return {if_block, then_block, else_block};
   }
 
-  void AddParameter(HInstruction* parameter) {
-    entry_block_->AddInstruction(parameter);
-    parameters_.push_back(parameter);
+  // Insert "pre-header", "loop-header" and "loop-body" blocks before a given `loop_exit` block
+  // and connect them in a `while (...) { ... }` loop pattern. Return the new blocks.
+  // Adds `HGoto` to the "pre-header" and "loop-body" blocks but leaves the "loop-header" block
+  // empty, leaving the construction of an appropriate condition and `HIf` to the caller.
+  // Note: The `loop_exit` shall be the "then" successor of the "loop-header". If the `loop_exit`
+  // is needed as the "else" successor, use `HBlock::SwapSuccessors()` to adjust the order.
+  std::tuple<HBasicBlock*, HBasicBlock*, HBasicBlock*> CreateWhileLoop(HBasicBlock* loop_exit) {
+    HBasicBlock* pre_header = AddNewBlock();
+    HBasicBlock* loop_header = AddNewBlock();
+    HBasicBlock* loop_body = AddNewBlock();
+
+    HBasicBlock* predecessor = loop_exit->GetSinglePredecessor();
+    predecessor->ReplaceSuccessor(loop_exit, pre_header);
+
+    pre_header->AddSuccessor(loop_header);
+    loop_header->AddSuccessor(loop_exit);  // true successor
+    loop_header->AddSuccessor(loop_body);  // false successor
+    loop_body->AddSuccessor(loop_header);
+
+    MakeGoto(pre_header);
+    MakeGoto(loop_body);
+
+    return {pre_header, loop_header, loop_body};
+  }
+
+  // Insert "pre-header" and "loop" blocks before a given `loop_exit` block and connect them in a
+  // `do { ... } while (...);` loop pattern. Return the new blocks. Adds `HGoto` to the "pre-header"
+  // block but leaves the "loop" block empty, leaving the construction of an appropriate condition
+  // and `HIf` to the caller.
+  // Note: The `loop_exit` shall be the "then" successor of the "loop". If the `loop_exit`
+  // is needed as the "else" successor, use `HBlock::SwapSuccessors()` to adjust the order.
+  std::tuple<HBasicBlock*, HBasicBlock*> CreateDoWhileLoop(HBasicBlock* loop_exit) {
+    HBasicBlock* pre_header = AddNewBlock();
+    HBasicBlock* loop = AddNewBlock();
+
+    HBasicBlock* predecessor = loop_exit->GetSinglePredecessor();
+    predecessor->ReplaceSuccessor(loop_exit, pre_header);
+
+    pre_header->AddSuccessor(loop);
+    loop->AddSuccessor(loop_exit);  // true successor
+    loop->AddSuccessor(loop);  // fakse successor
+
+    MakeGoto(pre_header);
+
+    return {pre_header, loop};
   }
 
   HBasicBlock* AddNewBlock() {
@@ -391,68 +469,189 @@ class OptimizingUnitTestHelper {
     OptimizingUnitTestHelper::ManuallyBuildEnvFor(ins, &current_locals);
   }
 
-  HLoadClass* MakeClassLoad(std::optional<dex::TypeIndex> ti = std::nullopt,
-                            std::optional<Handle<mirror::Class>> klass = std::nullopt) {
-    return new (GetAllocator()) HLoadClass(graph_->GetCurrentMethod(),
-                                           ti ? *ti : dex::TypeIndex(class_idx_++),
-                                           graph_->GetDexFile(),
-                                           /* klass= */ klass ? *klass : null_klass_,
-                                           /* is_referrers_class= */ false,
-                                           /* dex_pc= */ 0,
-                                           /* needs_access_check= */ false);
-  }
-
-  HNewInstance* MakeNewInstance(HInstruction* cls, uint32_t dex_pc = 0u) {
+  HLoadClass* MakeLoadClass(HBasicBlock* block,
+                            std::optional<dex::TypeIndex> ti = std::nullopt,
+                            std::optional<Handle<mirror::Class>> klass = std::nullopt,
+                            std::initializer_list<HInstruction*> env = {},
+                            uint32_t dex_pc = kNoDexPc) {
+    HLoadClass* load_class = new (GetAllocator()) HLoadClass(
+        graph_->GetCurrentMethod(),
+        ti ? *ti : dex::TypeIndex(class_idx_++),
+        graph_->GetDexFile(),
+        /* klass= */ klass ? *klass : null_klass_,
+        /* is_referrers_class= */ false,
+        dex_pc,
+        /* needs_access_check= */ false);
+    AddOrInsertInstruction(block, load_class);
+    ManuallyBuildEnvFor(load_class, env);
+    return load_class;
+  }
+
+  HNewInstance* MakeNewInstance(HBasicBlock* block,
+                                HInstruction* cls,
+                                std::initializer_list<HInstruction*> env = {},
+                                uint32_t dex_pc = kNoDexPc) {
     EXPECT_TRUE(cls->IsLoadClass() || cls->IsClinitCheck()) << *cls;
     HLoadClass* load =
         cls->IsLoadClass() ? cls->AsLoadClass() : cls->AsClinitCheck()->GetLoadClass();
-    return new (GetAllocator()) HNewInstance(cls,
-                                             dex_pc,
-                                             load->GetTypeIndex(),
-                                             graph_->GetDexFile(),
-                                             /* finalizable= */ false,
-                                             QuickEntrypointEnum::kQuickAllocObjectInitialized);
+    HNewInstance* new_instance = new (GetAllocator()) HNewInstance(
+        cls,
+        dex_pc,
+        load->GetTypeIndex(),
+        graph_->GetDexFile(),
+        /* finalizable= */ false,
+        QuickEntrypointEnum::kQuickAllocObjectInitialized);
+    AddOrInsertInstruction(block, new_instance);
+    ManuallyBuildEnvFor(new_instance, env);
+    return new_instance;
+  }
+
+  HInstanceFieldSet* MakeIFieldSet(HBasicBlock* block,
+                                   HInstruction* object,
+                                   HInstruction* data,
+                                   MemberOffset off,
+                                   uint32_t dex_pc = kNoDexPc) {
+    CHECK(data != nullptr);
+    return MakeIFieldSet(block, object, data, data->GetType(), off, dex_pc);
   }
 
-  HInstanceFieldSet* MakeIFieldSet(HInstruction* inst,
+  HInstanceFieldSet* MakeIFieldSet(HBasicBlock* block,
+                                   HInstruction* object,
                                    HInstruction* data,
+                                   DataType::Type field_type,
                                    MemberOffset off,
-                                   uint32_t dex_pc = 0u) {
-    return new (GetAllocator()) HInstanceFieldSet(inst,
-                                                  data,
-                                                  /* field= */ nullptr,
-                                                  /* field_type= */ data->GetType(),
-                                                  /* field_offset= */ off,
-                                                  /* is_volatile= */ false,
-                                                  /* field_idx= */ 0,
-                                                  /* declaring_class_def_index= */ 0,
-                                                  graph_->GetDexFile(),
-                                                  dex_pc);
-  }
-
-  HInstanceFieldGet* MakeIFieldGet(HInstruction* inst,
+                                   uint32_t dex_pc = kNoDexPc) {
+    HInstanceFieldSet* ifield_set = new (GetAllocator()) HInstanceFieldSet(
+        object,
+        data,
+        /* field= */ nullptr,
+        field_type,
+        /* field_offset= */ off,
+        /* is_volatile= */ false,
+        kUnknownFieldIndex,
+        kUnknownClassDefIndex,
+        graph_->GetDexFile(),
+        dex_pc);
+    AddOrInsertInstruction(block, ifield_set);
+    return ifield_set;
+  }
+
+  HInstanceFieldGet* MakeIFieldGet(HBasicBlock* block,
+                                   HInstruction* object,
                                    DataType::Type type,
                                    MemberOffset off,
-                                   uint32_t dex_pc = 0u) {
-    return new (GetAllocator()) HInstanceFieldGet(inst,
-                                                  /* field= */ nullptr,
-                                                  /* field_type= */ type,
-                                                  /* field_offset= */ off,
-                                                  /* is_volatile= */ false,
-                                                  /* field_idx= */ 0,
-                                                  /* declaring_class_def_index= */ 0,
-                                                  graph_->GetDexFile(),
-                                                  dex_pc);
-  }
-
-  HInvokeStaticOrDirect* MakeInvoke(DataType::Type return_type,
-                                    const std::vector<HInstruction*>& args) {
+                                   uint32_t dex_pc = kNoDexPc) {
+    HInstanceFieldGet* ifield_get = new (GetAllocator()) HInstanceFieldGet(
+        object,
+        /* field= */ nullptr,
+        /* field_type= */ type,
+        /* field_offset= */ off,
+        /* is_volatile= */ false,
+        kUnknownFieldIndex,
+        kUnknownClassDefIndex,
+        graph_->GetDexFile(),
+        dex_pc);
+    AddOrInsertInstruction(block, ifield_get);
+    return ifield_get;
+  }
+
+  HNewArray* MakeNewArray(HBasicBlock* block,
+                          HInstruction* cls,
+                          HInstruction* length,
+                          size_t component_size_shift = DataType::SizeShift(DataType::Type::kInt32),
+                          std::initializer_list<HInstruction*> env = {},
+                          uint32_t dex_pc = kNoDexPc) {
+    HNewArray* new_array =
+        new (GetAllocator()) HNewArray(cls, length, dex_pc, component_size_shift);
+    AddOrInsertInstruction(block, new_array);
+    ManuallyBuildEnvFor(new_array, env);
+    return new_array;
+  }
+
+  HArraySet* MakeArraySet(HBasicBlock* block,
+                          HInstruction* array,
+                          HInstruction* index,
+                          HInstruction* value,
+                          uint32_t dex_pc = kNoDexPc) {
+    CHECK(value != nullptr);
+    return MakeArraySet(block, array, index, value, value->GetType(), dex_pc);
+  }
+
+  HArraySet* MakeArraySet(HBasicBlock* block,
+                          HInstruction* array,
+                          HInstruction* index,
+                          HInstruction* value,
+                          DataType::Type type,
+                          uint32_t dex_pc = kNoDexPc) {
+    HArraySet* array_set = new (GetAllocator()) HArraySet(array, index, value, type, dex_pc);
+    AddOrInsertInstruction(block, array_set);
+    return array_set;
+  }
+
+  HArrayGet* MakeArrayGet(HBasicBlock* block,
+                          HInstruction* array,
+                          HInstruction* index,
+                          DataType::Type type,
+                          uint32_t dex_pc = kNoDexPc) {
+    HArrayGet* array_get = new (GetAllocator()) HArrayGet(array, index, type, dex_pc);
+    AddOrInsertInstruction(block, array_get);
+    return array_get;
+  }
+
+  HArrayLength* MakeArrayLength(HBasicBlock* block,
+                                HInstruction* array,
+                                uint32_t dex_pc = kNoDexPc) {
+    HArrayLength* array_length = new (GetAllocator()) HArrayLength(array, dex_pc);
+    AddOrInsertInstruction(block, array_length);
+    return array_length;
+  }
+
+  HNullCheck* MakeNullCheck(HBasicBlock* block,
+                            HInstruction* value,
+                            std::initializer_list<HInstruction*> env = {},
+                            uint32_t dex_pc = kNoDexPc) {
+    HNullCheck* null_check = new (GetAllocator()) HNullCheck(value, dex_pc);
+    AddOrInsertInstruction(block, null_check);
+    ManuallyBuildEnvFor(null_check, env);
+    return null_check;
+  }
+
+  HBoundsCheck* MakeBoundsCheck(HBasicBlock* block,
+                                HInstruction* index,
+                                HInstruction* length,
+                                std::initializer_list<HInstruction*> env = {},
+                                uint32_t dex_pc = kNoDexPc) {
+    HBoundsCheck* bounds_check = new (GetAllocator()) HBoundsCheck(index, length, dex_pc);
+    AddOrInsertInstruction(block, bounds_check);
+    ManuallyBuildEnvFor(bounds_check, env);
+    return bounds_check;
+  }
+
+  HVecStore* MakeVecStore(HBasicBlock* block,
+                          HInstruction* base,
+                          HInstruction* index,
+                          HInstruction* value,
+                          DataType::Type packed_type,
+                          size_t vector_length = 4,
+                          uint32_t dex_pc = kNoDexPc) {
+    SideEffects side_effects = SideEffects::ArrayWriteOfType(packed_type);
+    HVecStore* vec_store = new (GetAllocator()) HVecStore(
+        GetAllocator(), base, index, value, packed_type, side_effects, vector_length, dex_pc);
+    AddOrInsertInstruction(block, vec_store);
+    return vec_store;
+  }
+
+  HInvokeStaticOrDirect* MakeInvokeStatic(HBasicBlock* block,
+                                          DataType::Type return_type,
+                                          const std::vector<HInstruction*>& args,
+                                          std::initializer_list<HInstruction*> env = {},
+                                          uint32_t dex_pc = kNoDexPc) {
     MethodReference method_reference{/* file= */ &graph_->GetDexFile(), /* index= */ method_idx_++};
-    HInvokeStaticOrDirect* res = new (GetAllocator())
+    HInvokeStaticOrDirect* invoke = new (GetAllocator())
         HInvokeStaticOrDirect(GetAllocator(),
                               args.size(),
                               return_type,
-                              /* dex_pc= */ 0,
+                              dex_pc,
                               method_reference,
                               /* resolved_method= */ nullptr,
                               HInvokeStaticOrDirect::DispatchInfo{},
@@ -461,23 +660,121 @@ class OptimizingUnitTestHelper {
                               HInvokeStaticOrDirect::ClinitCheckRequirement::kNone,
                               !graph_->IsDebuggable());
     for (auto [ins, idx] : ZipCount(MakeIterationRange(args))) {
-      res->SetRawInputAt(idx, ins);
+      invoke->SetRawInputAt(idx, ins);
     }
-    return res;
+    AddOrInsertInstruction(block, invoke);
+    ManuallyBuildEnvFor(invoke, env);
+    return invoke;
+  }
+
+  template <typename Type>
+  Type* MakeBinOp(HBasicBlock* block,
+                  DataType::Type result_type,
+                  HInstruction* left,
+                  HInstruction* right,
+                  uint32_t dex_pc = kNoDexPc) {
+    static_assert(std::is_base_of_v<HBinaryOperation, Type>);
+    Type* insn = new (GetAllocator()) Type(result_type, left, right, dex_pc);
+    AddOrInsertInstruction(block, insn);
+    return insn;
+  }
+
+  HCondition* MakeCondition(HBasicBlock* block,
+                            IfCondition cond,
+                            HInstruction* first,
+                            HInstruction* second,
+                            uint32_t dex_pc = kNoDexPc) {
+    HCondition* condition = graph_->CreateCondition(cond, first, second, dex_pc);
+    AddOrInsertInstruction(block, condition);
+    return condition;
+  }
+
+  HSelect* MakeSelect(HBasicBlock* block,
+                      HInstruction* condition,
+                      HInstruction* true_value,
+                      HInstruction* false_value,
+                      uint32_t dex_pc = kNoDexPc) {
+    HSelect* select = new (GetAllocator()) HSelect(condition, true_value, false_value, dex_pc);
+    AddOrInsertInstruction(block, select);
+    return select;
+  }
+
+  HSuspendCheck* MakeSuspendCheck(HBasicBlock* block,
+                                  std::initializer_list<HInstruction*> env = {},
+                                  uint32_t dex_pc = kNoDexPc) {
+    HSuspendCheck* suspend_check = new (GetAllocator()) HSuspendCheck(dex_pc);
+    AddOrInsertInstruction(block, suspend_check);
+    ManuallyBuildEnvFor(suspend_check, env);
+    return suspend_check;
+  }
+
+  void AddOrInsertInstruction(HBasicBlock* block, HInstruction* instruction) {
+    CHECK(!instruction->IsControlFlow());
+    if (block->GetLastInstruction() != nullptr && block->GetLastInstruction()->IsControlFlow()) {
+      block->InsertInstructionBefore(instruction, block->GetLastInstruction());
+    } else {
+      block->AddInstruction(instruction);
+    }
+  }
+
+  HIf* MakeIf(HBasicBlock* block, HInstruction* cond, uint32_t dex_pc = kNoDexPc) {
+    HIf* if_insn = new (GetAllocator()) HIf(cond, dex_pc);
+    block->AddInstruction(if_insn);
+    return if_insn;
+  }
+
+  HGoto* MakeGoto(HBasicBlock* block, uint32_t dex_pc = kNoDexPc) {
+    HGoto* goto_insn = new (GetAllocator()) HGoto(dex_pc);
+    block->AddInstruction(goto_insn);
+    return goto_insn;
   }
 
-  HPhi* MakePhi(const std::vector<HInstruction*>& ins) {
+  HReturnVoid* MakeReturnVoid(HBasicBlock* block, uint32_t dex_pc = kNoDexPc) {
+    HReturnVoid* return_void = new (GetAllocator()) HReturnVoid(dex_pc);
+    block->AddInstruction(return_void);
+    return return_void;
+  }
+
+  HReturn* MakeReturn(HBasicBlock* block, HInstruction* value, uint32_t dex_pc = kNoDexPc) {
+    HReturn* return_insn = new (GetAllocator()) HReturn(value, dex_pc);
+    block->AddInstruction(return_insn);
+    return return_insn;
+  }
+
+  HExit* MakeExit(HBasicBlock* exit_block) {
+    HExit* exit = new (GetAllocator()) HExit();
+    exit_block->AddInstruction(exit);
+    return exit;
+  }
+
+  HPhi* MakePhi(HBasicBlock* block, const std::vector<HInstruction*>& ins) {
     EXPECT_GE(ins.size(), 2u) << "Phi requires at least 2 inputs";
-    HPhi* phi =
-        new (GetAllocator()) HPhi(GetAllocator(), kNoRegNumber, ins.size(), ins[0]->GetType());
+    DataType::Type type = DataType::Kind(ins[0]->GetType());
+    HPhi* phi = new (GetAllocator()) HPhi(GetAllocator(), kNoRegNumber, ins.size(), type);
     for (auto [i, idx] : ZipCount(MakeIterationRange(ins))) {
       phi->SetRawInputAt(idx, i);
     }
+    block->AddPhi(phi);
     return phi;
   }
 
-  void SetupExit(HBasicBlock* exit) {
-    exit->AddInstruction(new (GetAllocator()) HExit());
+  std::tuple<HPhi*, HAdd*> MakeLinearLoopVar(HBasicBlock* header,
+                                             HBasicBlock* body,
+                                             int32_t initial,
+                                             int32_t increment) {
+    HInstruction* initial_const = graph_->GetIntConstant(initial);
+    HInstruction* increment_const = graph_->GetIntConstant(increment);
+    return MakeLinearLoopVar(header, body, initial_const, increment_const);
+  }
+
+  std::tuple<HPhi*, HAdd*> MakeLinearLoopVar(HBasicBlock* header,
+                                             HBasicBlock* body,
+                                             HInstruction* initial,
+                                             HInstruction* increment) {
+    HPhi* phi = MakePhi(header, {initial, /* placeholder */ initial});
+    HAdd* add = MakeBinOp<HAdd>(body, phi->GetType(), phi, increment);
+    phi->ReplaceInput(add, 1u);  // Update back-edge input.
+    return {phi, add};
   }
 
   dex::TypeIndex DefaultTypeIndexForType(DataType::Type type) {
@@ -508,11 +805,11 @@ class OptimizingUnitTestHelper {
     }
   }
 
-  // Creates a parameter. The instruction is automatically added to the entry-block
+  // Creates a parameter. The instruction is automatically added to the entry-block.
   HParameterValue* MakeParam(DataType::Type type, std::optional<dex::TypeIndex> ti = std::nullopt) {
     HParameterValue* val = new (GetAllocator()) HParameterValue(
         graph_->GetDexFile(), ti ? *ti : DefaultTypeIndexForType(type), param_count_++, type);
-    graph_->GetEntryBlock()->AddInstruction(val);
+    AddOrInsertInstruction(graph_->GetEntryBlock(), val);
     return val;
   }
 
@@ -529,11 +826,8 @@ class OptimizingUnitTestHelper {
 
   HGraph* graph_;
   HBasicBlock* entry_block_;
-  HBasicBlock* return_block_;
   HBasicBlock* exit_block_;
 
-  std::vector<HInstruction*> parameters_;
-
   size_t param_count_ = 0;
   size_t class_idx_ = 42;
   uint32_t method_idx_ = 100;
diff --git a/compiler/optimizing/register_allocator_test.cc b/compiler/optimizing/register_allocator_test.cc
index 8f1e724569..e5eb54c2c2 100644
--- a/compiler/optimizing/register_allocator_test.cc
+++ b/compiler/optimizing/register_allocator_test.cc
@@ -461,25 +461,15 @@ HGraph* RegisterAllocatorTest::BuildIfElseWithPhi(HPhi** phi,
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
 
   HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(block);
   entry->AddSuccessor(block);
 
-  HInstruction* test = new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                              nullptr,
-                                                              DataType::Type::kBool,
-                                                              MemberOffset(22),
-                                                              false,
-                                                              kUnknownFieldIndex,
-                                                              kUnknownClassDefIndex,
-                                                              graph->GetDexFile(),
-                                                              0);
-  block->AddInstruction(test);
-  block->AddInstruction(new (GetAllocator()) HIf(test));
+  HInstruction* test = MakeIFieldGet(block, parameter, DataType::Type::kBool, MemberOffset(22));
+  MakeIf(block, test);
+
   HBasicBlock* then = new (GetAllocator()) HBasicBlock(graph);
   HBasicBlock* else_ = new (GetAllocator()) HBasicBlock(graph);
   HBasicBlock* join = new (GetAllocator()) HBasicBlock(graph);
@@ -491,34 +481,14 @@ HGraph* RegisterAllocatorTest::BuildIfElseWithPhi(HPhi** phi,
   block->AddSuccessor(else_);
   then->AddSuccessor(join);
   else_->AddSuccessor(join);
-  then->AddInstruction(new (GetAllocator()) HGoto());
-  else_->AddInstruction(new (GetAllocator()) HGoto());
-
-  *phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-  join->AddPhi(*phi);
-  *input1 = new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                   nullptr,
-                                                   DataType::Type::kInt32,
-                                                   MemberOffset(42),
-                                                   false,
-                                                   kUnknownFieldIndex,
-                                                   kUnknownClassDefIndex,
-                                                   graph->GetDexFile(),
-                                                   0);
-  *input2 = new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                   nullptr,
-                                                   DataType::Type::kInt32,
-                                                   MemberOffset(42),
-                                                   false,
-                                                   kUnknownFieldIndex,
-                                                   kUnknownClassDefIndex,
-                                                   graph->GetDexFile(),
-                                                   0);
-  then->AddInstruction(*input1);
-  else_->AddInstruction(*input2);
-  join->AddInstruction(new (GetAllocator()) HExit());
-  (*phi)->AddInput(*input1);
-  (*phi)->AddInput(*input2);
+  MakeGoto(then);
+  MakeGoto(else_);
+
+  *input1 = MakeIFieldGet(then, parameter, DataType::Type::kInt32, MemberOffset(42));
+  *input2 = MakeIFieldGet(else_, parameter, DataType::Type::kInt32, MemberOffset(42));
+
+  *phi = MakePhi(join, {*input1, *input2});
+  MakeExit(join);
 
   graph->BuildDominatorTree();
   graph->AnalyzeLoops();
@@ -605,31 +575,19 @@ HGraph* RegisterAllocatorTest::BuildFieldReturn(HInstruction** field, HInstructi
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  entry->AddInstruction(parameter);
+  HInstruction* parameter = MakeParam(DataType::Type::kReference);
 
   HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(block);
   entry->AddSuccessor(block);
 
-  *field = new (GetAllocator()) HInstanceFieldGet(parameter,
-                                                  nullptr,
-                                                  DataType::Type::kInt32,
-                                                  MemberOffset(42),
-                                                  false,
-                                                  kUnknownFieldIndex,
-                                                  kUnknownClassDefIndex,
-                                                  graph->GetDexFile(),
-                                                  0);
-  block->AddInstruction(*field);
-  *ret = new (GetAllocator()) HReturn(*field);
-  block->AddInstruction(*ret);
+  *field = MakeIFieldGet(block, parameter, DataType::Type::kInt32, MemberOffset(42));
+  *ret = MakeReturn(block, *field);
 
   HBasicBlock* exit = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(exit);
   block->AddSuccessor(exit);
-  exit->AddInstruction(new (GetAllocator()) HExit());
+  MakeExit(exit);
 
   graph->BuildDominatorTree();
   return graph;
@@ -675,9 +633,7 @@ HGraph* RegisterAllocatorTest::BuildTwoSubs(HInstruction** first_sub, HInstructi
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* parameter = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  entry->AddInstruction(parameter);
+  HInstruction* parameter = MakeParam(DataType::Type::kInt32);
 
   HInstruction* constant1 = graph->GetIntConstant(1);
   HInstruction* constant2 = graph->GetIntConstant(2);
@@ -691,7 +647,7 @@ HGraph* RegisterAllocatorTest::BuildTwoSubs(HInstruction** first_sub, HInstructi
   *second_sub = new (GetAllocator()) HSub(DataType::Type::kInt32, *first_sub, constant2);
   block->AddInstruction(*second_sub);
 
-  block->AddInstruction(new (GetAllocator()) HExit());
+  MakeExit(block);
 
   graph->BuildDominatorTree();
   return graph;
@@ -741,12 +697,8 @@ HGraph* RegisterAllocatorTest::BuildDiv(HInstruction** div) {
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* first = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  HInstruction* second = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  entry->AddInstruction(first);
-  entry->AddInstruction(second);
+  HInstruction* first = MakeParam(DataType::Type::kInt32);
+  HInstruction* second = MakeParam(DataType::Type::kInt32);
 
   HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(block);
@@ -756,7 +708,7 @@ HGraph* RegisterAllocatorTest::BuildDiv(HInstruction** div) {
       DataType::Type::kInt32, first, second, 0);  // don't care about dex_pc.
   block->AddInstruction(*div);
 
-  block->AddInstruction(new (GetAllocator()) HExit());
+  MakeExit(block);
 
   graph->BuildDominatorTree();
   return graph;
@@ -788,23 +740,15 @@ TEST_F(RegisterAllocatorTest, SpillInactive) {
   HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(entry);
   graph->SetEntryBlock(entry);
-  HInstruction* one = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  HInstruction* two = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  HInstruction* three = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  HInstruction* four = new (GetAllocator()) HParameterValue(
-      graph->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  entry->AddInstruction(one);
-  entry->AddInstruction(two);
-  entry->AddInstruction(three);
-  entry->AddInstruction(four);
+  HInstruction* one = MakeParam(DataType::Type::kInt32);
+  HInstruction* two = MakeParam(DataType::Type::kInt32);
+  HInstruction* three = MakeParam(DataType::Type::kInt32);
+  HInstruction* four = MakeParam(DataType::Type::kInt32);
 
   HBasicBlock* block = new (GetAllocator()) HBasicBlock(graph);
   graph->AddBlock(block);
   entry->AddSuccessor(block);
-  block->AddInstruction(new (GetAllocator()) HExit());
+  MakeExit(block);
 
   // We create a synthesized user requesting a register, to avoid just spilling the
   // intervals.
diff --git a/compiler/optimizing/scheduler_test.cc b/compiler/optimizing/scheduler_test.cc
index 0b020f1460..f613e0a9e2 100644
--- a/compiler/optimizing/scheduler_test.cc
+++ b/compiler/optimizing/scheduler_test.cc
@@ -93,43 +93,24 @@ class SchedulerTest : public CommonCompilerTest, public OptimizingUnitTestHelper
     // array_get2    ArrayGet [array, add1]
     // array_set2    ArraySet [array, add1, add2]
 
-    HInstruction* array = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                           dex::TypeIndex(0),
-                                                           0,
-                                                           DataType::Type::kReference);
+    HInstruction* array = MakeParam(DataType::Type::kReference);
     HInstruction* c1 = graph_->GetIntConstant(1);
     HInstruction* c2 = graph_->GetIntConstant(10);
-    HInstruction* add1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, c1, c2);
-    HInstruction* add2 = new (GetAllocator()) HAdd(DataType::Type::kInt32, add1, c2);
-    HInstruction* mul = new (GetAllocator()) HMul(DataType::Type::kInt32, add1, add2);
+
+    HInstruction* add1 = MakeBinOp<HAdd>(block1, DataType::Type::kInt32, c1, c2);
+    HInstruction* add2 = MakeBinOp<HAdd>(block1, DataType::Type::kInt32, add1, c2);
+    HInstruction* mul = MakeBinOp<HMul>(block1, DataType::Type::kInt32, add1, add2);
     HInstruction* div_check = new (GetAllocator()) HDivZeroCheck(add2, 0);
+    block1->AddInstruction(div_check);
     HInstruction* div = new (GetAllocator()) HDiv(DataType::Type::kInt32, add1, div_check, 0);
-    HInstruction* array_get1 =
-        new (GetAllocator()) HArrayGet(array, add1, DataType::Type::kInt32, 0);
-    HInstruction* array_set1 =
-        new (GetAllocator()) HArraySet(array, add1, add2, DataType::Type::kInt32, 0);
-    HInstruction* array_get2 =
-        new (GetAllocator()) HArrayGet(array, add1, DataType::Type::kInt32, 0);
-    HInstruction* array_set2 =
-        new (GetAllocator()) HArraySet(array, add1, add2, DataType::Type::kInt32, 0);
+    block1->AddInstruction(div);
+    HInstruction* array_get1 = MakeArrayGet(block1, array, add1, DataType::Type::kInt32);
+    HInstruction* array_set1 = MakeArraySet(block1, array, add1, add2, DataType::Type::kInt32);
+    HInstruction* array_get2 = MakeArrayGet(block1, array, add1, DataType::Type::kInt32);
+    HInstruction* array_set2 = MakeArraySet(block1, array, add1, add2, DataType::Type::kInt32);
 
     DCHECK(div_check->CanThrow());
 
-    entry->AddInstruction(array);
-
-    HInstruction* block_instructions[] = {add1,
-                                          add2,
-                                          mul,
-                                          div_check,
-                                          div,
-                                          array_get1,
-                                          array_set1,
-                                          array_get2,
-                                          array_set2};
-    for (HInstruction* instr : block_instructions) {
-      block1->AddInstruction(instr);
-    }
-
     HEnvironment* environment = new (GetAllocator()) HEnvironment(GetAllocator(),
                                                                   2,
                                                                   graph_->GetArtMethod(),
@@ -143,8 +124,8 @@ class SchedulerTest : public CommonCompilerTest, public OptimizingUnitTestHelper
 
     TestSchedulingGraph scheduling_graph(GetScopedAllocator());
     // Instructions must be inserted in reverse order into the scheduling graph.
-    for (HInstruction* instr : ReverseRange(block_instructions)) {
-      scheduling_graph.AddNode(instr);
+    for (HBackwardInstructionIterator it(block1->GetInstructions()); !it.Done(); it.Advance()) {
+      scheduling_graph.AddNode(it.Current());
     }
 
     // Should not have dependencies cross basic blocks.
@@ -201,88 +182,41 @@ class SchedulerTest : public CommonCompilerTest, public OptimizingUnitTestHelper
 
   void TestDependencyGraphOnAliasingArrayAccesses(HScheduler* scheduler) {
     HBasicBlock* entry = new (GetAllocator()) HBasicBlock(graph_);
+    HBasicBlock* block1 = new (GetAllocator()) HBasicBlock(graph_);
     graph_->AddBlock(entry);
+    graph_->AddBlock(block1);
     graph_->SetEntryBlock(entry);
-    graph_->BuildDominatorTree();
-
-    HInstruction* arr = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                             dex::TypeIndex(0),
-                                                             0,
-                                                             DataType::Type::kReference);
-    HInstruction* i = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                           dex::TypeIndex(1),
-                                                           1,
-                                                           DataType::Type::kInt32);
-    HInstruction* j = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                           dex::TypeIndex(1),
-                                                           1,
-                                                           DataType::Type::kInt32);
-    HInstruction* object = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                                dex::TypeIndex(0),
-                                                                0,
-                                                                DataType::Type::kReference);
+
+    HInstruction* arr = MakeParam(DataType::Type::kReference);
+    HInstruction* i = MakeParam(DataType::Type::kInt32);
+    HInstruction* j = MakeParam(DataType::Type::kInt32);
+    HInstruction* object = MakeParam(DataType::Type::kReference);
     HInstruction* c0 = graph_->GetIntConstant(0);
     HInstruction* c1 = graph_->GetIntConstant(1);
-    HInstruction* add0 = new (GetAllocator()) HAdd(DataType::Type::kInt32, i, c0);
-    HInstruction* add1 = new (GetAllocator()) HAdd(DataType::Type::kInt32, i, c1);
-    HInstruction* sub0 = new (GetAllocator()) HSub(DataType::Type::kInt32, i, c0);
-    HInstruction* sub1 = new (GetAllocator()) HSub(DataType::Type::kInt32, i, c1);
-    HInstruction* arr_set_0 =
-        new (GetAllocator()) HArraySet(arr, c0, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_1 =
-        new (GetAllocator()) HArraySet(arr, c1, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_i = new (GetAllocator()) HArraySet(arr, i, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_add0 =
-        new (GetAllocator()) HArraySet(arr, add0, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_add1 =
-        new (GetAllocator()) HArraySet(arr, add1, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_sub0 =
-        new (GetAllocator()) HArraySet(arr, sub0, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_sub1 =
-        new (GetAllocator()) HArraySet(arr, sub1, c0, DataType::Type::kInt32, 0);
-    HInstruction* arr_set_j = new (GetAllocator()) HArraySet(arr, j, c0, DataType::Type::kInt32, 0);
-    HInstanceFieldSet* set_field10 = new (GetAllocator()) HInstanceFieldSet(object,
-                                                                            c1,
-                                                                            nullptr,
-                                                                            DataType::Type::kInt32,
-                                                                            MemberOffset(10),
-                                                                            false,
-                                                                            kUnknownFieldIndex,
-                                                                            kUnknownClassDefIndex,
-                                                                            graph_->GetDexFile(),
-                                                                            0);
-
-    HInstruction* block_instructions[] = {arr,
-                                          i,
-                                          j,
-                                          object,
-                                          add0,
-                                          add1,
-                                          sub0,
-                                          sub1,
-                                          arr_set_0,
-                                          arr_set_1,
-                                          arr_set_i,
-                                          arr_set_add0,
-                                          arr_set_add1,
-                                          arr_set_sub0,
-                                          arr_set_sub1,
-                                          arr_set_j,
-                                          set_field10};
-
-    for (HInstruction* instr : block_instructions) {
-      entry->AddInstruction(instr);
-    }
+
+    HInstruction* add0 = MakeBinOp<HAdd>(block1, DataType::Type::kInt32, i, c0);
+    HInstruction* add1 = MakeBinOp<HAdd>(block1, DataType::Type::kInt32, i, c1);
+    HInstruction* sub0 = MakeBinOp<HSub>(block1, DataType::Type::kInt32, i, c0);
+    HInstruction* sub1 = MakeBinOp<HSub>(block1, DataType::Type::kInt32, i, c1);
+    HInstruction* arr_set_0 = MakeArraySet(block1, arr, c0, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_1 = MakeArraySet(block1, arr, c1, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_i = MakeArraySet(block1, arr, i, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_add0 = MakeArraySet(block1, arr, add0, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_add1 = MakeArraySet(block1, arr, add1, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_sub0 = MakeArraySet(block1, arr, sub0, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_sub1 = MakeArraySet(block1, arr, sub1, c0, DataType::Type::kInt32);
+    HInstruction* arr_set_j = MakeArraySet(block1, arr, j, c0, DataType::Type::kInt32);
+    HInstanceFieldSet* set_field10 = MakeIFieldSet(block1, object, c1, MemberOffset(10));
 
     HeapLocationCollector heap_location_collector(graph_, GetScopedAllocator());
-    heap_location_collector.VisitBasicBlock(entry);
+    heap_location_collector.VisitBasicBlock(block1);
     heap_location_collector.BuildAliasingMatrix();
     TestSchedulingGraph scheduling_graph(GetScopedAllocator(), &heap_location_collector);
 
-    for (HInstruction* instr : ReverseRange(block_instructions)) {
+    for (HBackwardInstructionIterator it(block1->GetInstructions()); !it.Done(); it.Advance()) {
       // Build scheduling graph with memory access aliasing information
       // from LSA/heap_location_collector.
-      scheduling_graph.AddNode(instr);
+      scheduling_graph.AddNode(it.Current());
     }
 
     // LSA/HeapLocationCollector should see those ArraySet instructions.
diff --git a/compiler/optimizing/select_generator_test.cc b/compiler/optimizing/select_generator_test.cc
index fc9e150d92..9cd6604d34 100644
--- a/compiler/optimizing/select_generator_test.cc
+++ b/compiler/optimizing/select_generator_test.cc
@@ -27,44 +27,15 @@ namespace art HIDDEN {
 
 class SelectGeneratorTest : public OptimizingUnitTest {
  protected:
-  void InitGraphAndParameters() {
-    InitGraph();
-    AddParameter(new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                      dex::TypeIndex(0),
-                                                      0,
-                                                      DataType::Type::kInt32));
-  }
-
-  void ConstructBasicGraphForSelect(HInstruction* instr) {
-    HBasicBlock* if_block = AddNewBlock();
-    HBasicBlock* then_block = AddNewBlock();
-    HBasicBlock* else_block = AddNewBlock();
-
-    entry_block_->ReplaceSuccessor(return_block_, if_block);
-
-    if_block->AddSuccessor(then_block);
-    if_block->AddSuccessor(else_block);
-    then_block->AddSuccessor(return_block_);
-    else_block->AddSuccessor(return_block_);
-
-    HParameterValue* bool_param = new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                                       dex::TypeIndex(0),
-                                                                       1,
-                                                                       DataType::Type::kBool);
-    entry_block_->AddInstruction(bool_param);
+  HPhi* ConstructBasicGraphForSelect(HBasicBlock* return_block, HInstruction* instr) {
+    HParameterValue* bool_param = MakeParam(DataType::Type::kBool);
     HIntConstant* const1 =  graph_->GetIntConstant(1);
 
-    if_block->AddInstruction(new (GetAllocator()) HIf(bool_param));
-
-    then_block->AddInstruction(instr);
-    then_block->AddInstruction(new (GetAllocator()) HGoto());
-
-    else_block->AddInstruction(new (GetAllocator()) HGoto());
+    auto [if_block, then_block, else_block] = CreateDiamondPattern(return_block, bool_param);
 
-    HPhi* phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-    return_block_->AddPhi(phi);
-    phi->AddInput(instr);
-    phi->AddInput(const1);
+    AddOrInsertInstruction(then_block, instr);
+    HPhi* phi = MakePhi(return_block, {instr, const1});
+    return phi;
   }
 
   bool CheckGraphAndTrySelectGenerator() {
@@ -79,25 +50,25 @@ class SelectGeneratorTest : public OptimizingUnitTest {
 
 // HDivZeroCheck might throw and should not be hoisted from the conditional to an unconditional.
 TEST_F(SelectGeneratorTest, testZeroCheck) {
-  InitGraphAndParameters();
-  HDivZeroCheck* instr = new (GetAllocator()) HDivZeroCheck(parameters_[0], 0);
-  ConstructBasicGraphForSelect(instr);
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  HParameterValue* param = MakeParam(DataType::Type::kInt32);
+  HDivZeroCheck* instr = new (GetAllocator()) HDivZeroCheck(param, 0);
+  HPhi* phi = ConstructBasicGraphForSelect(return_block, instr);
 
-  ArenaVector<HInstruction*> current_locals({parameters_[0], graph_->GetIntConstant(1)},
-                                            GetAllocator()->Adapter(kArenaAllocInstruction));
-  ManuallyBuildEnvFor(instr, &current_locals);
+  ManuallyBuildEnvFor(instr, {param, graph_->GetIntConstant(1)});
 
   EXPECT_FALSE(CheckGraphAndTrySelectGenerator());
+  EXPECT_FALSE(phi->GetBlock() == nullptr);
 }
 
 // Test that SelectGenerator succeeds with HAdd.
 TEST_F(SelectGeneratorTest, testAdd) {
-  InitGraphAndParameters();
-  HAdd* instr = new (GetAllocator()) HAdd(DataType::Type::kInt32,
-                                          parameters_[0],
-                                          parameters_[0], 0);
-  ConstructBasicGraphForSelect(instr);
+  HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+  HParameterValue* param = MakeParam(DataType::Type::kInt32);
+  HAdd* instr = new (GetAllocator()) HAdd(DataType::Type::kInt32, param, param, /*dex_pc=*/ 0);
+  HPhi* phi = ConstructBasicGraphForSelect(return_block, instr);
   EXPECT_TRUE(CheckGraphAndTrySelectGenerator());
+  EXPECT_TRUE(phi->GetBlock() == nullptr);
 }
 
 }  // namespace art
diff --git a/compiler/optimizing/sharpening.cc b/compiler/optimizing/sharpening.cc
index cb94491b8e..1b6a9fb601 100644
--- a/compiler/optimizing/sharpening.cc
+++ b/compiler/optimizing/sharpening.cc
@@ -471,4 +471,45 @@ void HSharpening::ProcessLoadString(
   load_string->SetLoadKind(load_kind);
 }
 
+void HSharpening::ProcessLoadMethodType(
+    HLoadMethodType* load_method_type,
+    CodeGenerator* codegen,
+    const DexCompilationUnit& dex_compilation_unit,
+    VariableSizedHandleScope* handles) {
+  const CompilerOptions& compiler_options = codegen->GetCompilerOptions();
+
+  HLoadMethodType::LoadKind desired_load_kind = static_cast<HLoadMethodType::LoadKind>(-1);
+
+  if (compiler_options.IsJitCompiler()) {
+    DCHECK(!compiler_options.GetCompilePic());
+    Runtime* runtime = Runtime::Current();
+    ClassLinker* class_linker = runtime->GetClassLinker();
+    ScopedObjectAccess soa(Thread::Current());
+    ObjPtr<mirror::MethodType> method_type =
+        class_linker->ResolveMethodType(Thread::Current(),
+                                        load_method_type->GetProtoIndex(),
+                                        dex_compilation_unit.GetDexCache(),
+                                        dex_compilation_unit.GetClassLoader());
+
+    if (method_type != nullptr) {
+      load_method_type->SetMethodType(handles->NewHandle(method_type));
+      desired_load_kind = HLoadMethodType::LoadKind::kJitTableAddress;
+    } else {
+      DCHECK_EQ(load_method_type->GetLoadKind(), HLoadMethodType::LoadKind::kRuntimeCall);
+      desired_load_kind = HLoadMethodType::LoadKind::kRuntimeCall;
+      Thread::Current()->ClearException();
+    }
+  } else {
+    if (compiler_options.GetCompilePic()) {
+      desired_load_kind = HLoadMethodType::LoadKind::kBssEntry;
+    } else {
+      // Test configuration, do not sharpen.
+      desired_load_kind = HLoadMethodType::LoadKind::kRuntimeCall;
+    }
+  }
+
+  DCHECK_NE(desired_load_kind, static_cast<HLoadMethodType::LoadKind>(-1));
+  load_method_type->SetLoadKind(desired_load_kind);
+}
+
 }  // namespace art
diff --git a/compiler/optimizing/sharpening.h b/compiler/optimizing/sharpening.h
index 6dfe904f27..88d3b2f604 100644
--- a/compiler/optimizing/sharpening.h
+++ b/compiler/optimizing/sharpening.h
@@ -27,7 +27,7 @@ class CodeGenerator;
 class DexCompilationUnit;
 
 // Utility methods that try to improve the way we dispatch methods, and access
-// types and strings.
+// types, strings and method types.
 class HSharpening {
  public:
   // Used by the builder and InstructionSimplifier.
@@ -54,6 +54,12 @@ class HSharpening {
                                 CodeGenerator* codegen,
                                 const DexCompilationUnit& dex_compilation_unit,
                                 VariableSizedHandleScope* handles);
+
+  // Used by the builder.
+  static void ProcessLoadMethodType(HLoadMethodType* load_method_type,
+                                    CodeGenerator* codegen,
+                                    const DexCompilationUnit& dex_compilation_unit,
+                                    VariableSizedHandleScope* handles);
 };
 
 }  // namespace art
diff --git a/compiler/optimizing/ssa_liveness_analysis_test.cc b/compiler/optimizing/ssa_liveness_analysis_test.cc
index 2df0f34c7d..d896aa88f4 100644
--- a/compiler/optimizing/ssa_liveness_analysis_test.cc
+++ b/compiler/optimizing/ssa_liveness_analysis_test.cc
@@ -58,14 +58,11 @@ class SsaLivenessAnalysisTest : public OptimizingUnitTest {
 };
 
 TEST_F(SsaLivenessAnalysisTest, TestReturnArg) {
-  HInstruction* arg = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kInt32);
-  entry_->AddInstruction(arg);
+  HInstruction* arg = MakeParam(DataType::Type::kInt32);
 
   HBasicBlock* block = CreateSuccessor(entry_);
-  HInstruction* ret = new (GetAllocator()) HReturn(arg);
-  block->AddInstruction(ret);
-  block->AddInstruction(new (GetAllocator()) HExit());
+  MakeReturn(block, arg);
+  MakeExit(block);
 
   graph_->BuildDominatorTree();
   SsaLivenessAnalysis ssa_analysis(graph_, codegen_.get(), GetScopedAllocator());
@@ -78,45 +75,18 @@ TEST_F(SsaLivenessAnalysisTest, TestReturnArg) {
 }
 
 TEST_F(SsaLivenessAnalysisTest, TestAput) {
-  HInstruction* array = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* index = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32);
-  HInstruction* value = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(2), 2, DataType::Type::kInt32);
-  HInstruction* extra_arg1 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(3), 3, DataType::Type::kInt32);
-  HInstruction* extra_arg2 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(4), 4, DataType::Type::kReference);
-  HInstruction* const args[] = { array, index, value, extra_arg1, extra_arg2 };
-  for (HInstruction* insn : args) {
-    entry_->AddInstruction(insn);
-  }
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+  HInstruction* index = MakeParam(DataType::Type::kInt32);
+  HInstruction* value = MakeParam(DataType::Type::kInt32);
+  HInstruction* extra_arg1 = MakeParam(DataType::Type::kInt32);
+  HInstruction* extra_arg2 = MakeParam(DataType::Type::kReference);
+  std::initializer_list<HInstruction*> args{array, index, value, extra_arg1, extra_arg2};
 
   HBasicBlock* block = CreateSuccessor(entry_);
-  HInstruction* null_check = new (GetAllocator()) HNullCheck(array, 0);
-  block->AddInstruction(null_check);
-  HEnvironment* null_check_env = new (GetAllocator()) HEnvironment(GetAllocator(),
-                                                                   /* number_of_vregs= */ 5,
-                                                                   /* method= */ nullptr,
-                                                                   /* dex_pc= */ 0u,
-                                                                   null_check);
-  null_check_env->CopyFrom(ArrayRef<HInstruction* const>(args));
-  null_check->SetRawEnvironment(null_check_env);
-  HInstruction* length = new (GetAllocator()) HArrayLength(array, 0);
-  block->AddInstruction(length);
-  HInstruction* bounds_check = new (GetAllocator()) HBoundsCheck(index, length, /* dex_pc= */ 0u);
-  block->AddInstruction(bounds_check);
-  HEnvironment* bounds_check_env = new (GetAllocator()) HEnvironment(GetAllocator(),
-                                                                     /* number_of_vregs= */ 5,
-                                                                     /* method= */ nullptr,
-                                                                     /* dex_pc= */ 0u,
-                                                                     bounds_check);
-  bounds_check_env->CopyFrom(ArrayRef<HInstruction* const>(args));
-  bounds_check->SetRawEnvironment(bounds_check_env);
-  HInstruction* array_set =
-      new (GetAllocator()) HArraySet(array, index, value, DataType::Type::kInt32, /* dex_pc= */ 0);
-  block->AddInstruction(array_set);
+  HInstruction* null_check = MakeNullCheck(block, array, /*env=*/ args);
+  HInstruction* length = MakeArrayLength(block, array);
+  HInstruction* bounds_check = MakeBoundsCheck(block, index, length, /*env=*/ args);
+  MakeArraySet(block, array, index, value, DataType::Type::kInt32);
 
   graph_->BuildDominatorTree();
   SsaLivenessAnalysis ssa_analysis(graph_, codegen_.get(), GetScopedAllocator());
@@ -136,7 +106,7 @@ TEST_F(SsaLivenessAnalysisTest, TestAput) {
       // Environment uses keep the reference argument alive.
       "ranges: { [10,19) }, uses: { }, { 15 19 } is_fixed: 0, is_split: 0 is_low: 0 is_high: 0",
   };
-  static_assert(arraysize(expected) == arraysize(args), "Array size check.");
+  CHECK_EQ(arraysize(expected), args.size());
   size_t arg_index = 0u;
   for (HInstruction* arg : args) {
     std::ostringstream arg_dump;
@@ -147,49 +117,23 @@ TEST_F(SsaLivenessAnalysisTest, TestAput) {
 }
 
 TEST_F(SsaLivenessAnalysisTest, TestDeoptimize) {
-  HInstruction* array = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(0), 0, DataType::Type::kReference);
-  HInstruction* index = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(1), 1, DataType::Type::kInt32);
-  HInstruction* value = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(2), 2, DataType::Type::kInt32);
-  HInstruction* extra_arg1 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(3), 3, DataType::Type::kInt32);
-  HInstruction* extra_arg2 = new (GetAllocator()) HParameterValue(
-      graph_->GetDexFile(), dex::TypeIndex(4), 4, DataType::Type::kReference);
-  HInstruction* const args[] = { array, index, value, extra_arg1, extra_arg2 };
-  for (HInstruction* insn : args) {
-    entry_->AddInstruction(insn);
-  }
+  HInstruction* array = MakeParam(DataType::Type::kReference);
+  HInstruction* index = MakeParam(DataType::Type::kInt32);
+  HInstruction* value = MakeParam(DataType::Type::kInt32);
+  HInstruction* extra_arg1 = MakeParam(DataType::Type::kInt32);
+  HInstruction* extra_arg2 = MakeParam(DataType::Type::kReference);
+  std::initializer_list<HInstruction*> args{array, index, value, extra_arg1, extra_arg2};
 
   HBasicBlock* block = CreateSuccessor(entry_);
-  HInstruction* null_check = new (GetAllocator()) HNullCheck(array, 0);
-  block->AddInstruction(null_check);
-  HEnvironment* null_check_env = new (GetAllocator()) HEnvironment(GetAllocator(),
-                                                                   /* number_of_vregs= */ 5,
-                                                                   /* method= */ nullptr,
-                                                                   /* dex_pc= */ 0u,
-                                                                   null_check);
-  null_check_env->CopyFrom(ArrayRef<HInstruction* const>(args));
-  null_check->SetRawEnvironment(null_check_env);
-  HInstruction* length = new (GetAllocator()) HArrayLength(array, 0);
-  block->AddInstruction(length);
+  HInstruction* null_check = MakeNullCheck(block, array, /*env=*/ args);
+  HInstruction* length = MakeArrayLength(block, array);
   // Use HAboveOrEqual+HDeoptimize as the bounds check.
-  HInstruction* ae = new (GetAllocator()) HAboveOrEqual(index, length);
-  block->AddInstruction(ae);
+  HInstruction* ae = MakeCondition(block, kCondAE, index, length);
   HInstruction* deoptimize = new(GetAllocator()) HDeoptimize(
       GetAllocator(), ae, DeoptimizationKind::kBlockBCE, /* dex_pc= */ 0u);
   block->AddInstruction(deoptimize);
-  HEnvironment* deoptimize_env = new (GetAllocator()) HEnvironment(GetAllocator(),
-                                                                   /* number_of_vregs= */ 5,
-                                                                   /* method= */ nullptr,
-                                                                   /* dex_pc= */ 0u,
-                                                                   deoptimize);
-  deoptimize_env->CopyFrom(ArrayRef<HInstruction* const>(args));
-  deoptimize->SetRawEnvironment(deoptimize_env);
-  HInstruction* array_set =
-      new (GetAllocator()) HArraySet(array, index, value, DataType::Type::kInt32, /* dex_pc= */ 0);
-  block->AddInstruction(array_set);
+  ManuallyBuildEnvFor(deoptimize, /*env=*/ args);
+  MakeArraySet(block, array, index, value, DataType::Type::kInt32);
 
   graph_->BuildDominatorTree();
   SsaLivenessAnalysis ssa_analysis(graph_, codegen_.get(), GetScopedAllocator());
@@ -208,7 +152,7 @@ TEST_F(SsaLivenessAnalysisTest, TestDeoptimize) {
       // Environment uses keep the reference argument alive.
       "ranges: { [10,21) }, uses: { }, { 15 21 } is_fixed: 0, is_split: 0 is_low: 0 is_high: 0",
   };
-  static_assert(arraysize(expected) == arraysize(args), "Array size check.");
+  CHECK_EQ(arraysize(expected), args.size());
   size_t arg_index = 0u;
   for (HInstruction* arg : args) {
     std::ostringstream arg_dump;
diff --git a/compiler/optimizing/stack_map_stream.cc b/compiler/optimizing/stack_map_stream.cc
index 83551a9750..10d8c91265 100644
--- a/compiler/optimizing/stack_map_stream.cc
+++ b/compiler/optimizing/stack_map_stream.cc
@@ -153,7 +153,7 @@ void StackMapStream::BeginStackMapEntry(
     size_t stack_map_index = stack_maps_.size();
     // Create lambda method, which will be executed at the very end to verify data.
     // Parameters and local variables will be captured(stored) by the lambda "[=]".
-    dchecks_.emplace_back([=](const CodeInfo& code_info) {
+    dchecks_.emplace_back([=, this](const CodeInfo& code_info) {
       // The `native_pc_offset` may have been overridden using `SetStackMapNativePcOffset(.)`.
       uint32_t final_native_pc_offset = GetStackMapNativePcOffset(stack_map_index);
       if (kind == StackMap::Kind::Default || kind == StackMap::Kind::OSR) {
diff --git a/compiler/optimizing/superblock_cloner_test.cc b/compiler/optimizing/superblock_cloner_test.cc
index ea2563ea7d..5190dae033 100644
--- a/compiler/optimizing/superblock_cloner_test.cc
+++ b/compiler/optimizing/superblock_cloner_test.cc
@@ -33,32 +33,10 @@ using HEdgeSet = SuperblockCloner::HEdgeSet;
 // individual instruction cloning and cloning of the more coarse-grain structures.
 class SuperblockClonerTest : public OptimizingUnitTest {
  protected:
-  void InitGraphAndParameters() {
-    InitGraph();
-    AddParameter(new (GetAllocator()) HParameterValue(graph_->GetDexFile(),
-                                                      dex::TypeIndex(0),
-                                                      0,
-                                                      DataType::Type::kInt32));
-  }
-
-  void CreateBasicLoopControlFlow(HBasicBlock* position,
-                                  HBasicBlock* successor,
-                                  /* out */ HBasicBlock** header_p,
-                                  /* out */ HBasicBlock** body_p) {
-    HBasicBlock* loop_preheader = AddNewBlock();
-    HBasicBlock* loop_header = AddNewBlock();
-    HBasicBlock* loop_body = AddNewBlock();
-
-    position->ReplaceSuccessor(successor, loop_preheader);
-
-    loop_preheader->AddSuccessor(loop_header);
-    // Loop exit first to have a proper exit condition/target for HIf.
-    loop_header->AddSuccessor(successor);
-    loop_header->AddSuccessor(loop_body);
-    loop_body->AddSuccessor(loop_header);
-
-    *header_p = loop_header;
-    *body_p = loop_body;
+  HBasicBlock* InitGraphAndParameters() {
+    HBasicBlock* return_block = InitEntryMainExitGraphWithReturnVoid();
+    param_ = MakeParam(DataType::Type::kInt32);
+    return return_block;
   }
 
   void CreateBasicLoopDataFlow(HBasicBlock* loop_header, HBasicBlock* loop_body) {
@@ -70,56 +48,31 @@ class SuperblockClonerTest : public OptimizingUnitTest {
     HIntConstant* const_128 = graph_->GetIntConstant(128);
 
     // Header block.
-    HPhi* phi = new (GetAllocator()) HPhi(GetAllocator(), 0, 0, DataType::Type::kInt32);
-    HInstruction* suspend_check = new (GetAllocator()) HSuspendCheck();
-    HInstruction* loop_check = new (GetAllocator()) HGreaterThanOrEqual(phi, const_128);
-
-    loop_header->AddPhi(phi);
-    loop_header->AddInstruction(suspend_check);
-    loop_header->AddInstruction(loop_check);
-    loop_header->AddInstruction(new (GetAllocator()) HIf(loop_check));
+    auto [phi, induction_inc] = MakeLinearLoopVar(loop_header, loop_body, const_0, const_1);
+    std::initializer_list<HInstruction*> common_env{phi, const_128, param_};
+    HInstruction* suspend_check = MakeSuspendCheck(loop_header, common_env);
+    HInstruction* loop_check = MakeCondition(loop_header, kCondGE, phi, const_128);
+    MakeIf(loop_header, loop_check);
 
     // Loop body block.
-    HInstruction* null_check = new (GetAllocator()) HNullCheck(parameters_[0], dex_pc);
-    HInstruction* array_length = new (GetAllocator()) HArrayLength(null_check, dex_pc);
-    HInstruction* bounds_check = new (GetAllocator()) HBoundsCheck(phi, array_length, dex_pc);
+    HInstruction* null_check = MakeNullCheck(loop_body, param_, common_env, dex_pc);
+    HInstruction* array_length = MakeArrayLength(loop_body, null_check, dex_pc);
+    HInstruction* bounds_check = MakeBoundsCheck(loop_body, phi, array_length, common_env, dex_pc);
     HInstruction* array_get =
-        new (GetAllocator()) HArrayGet(null_check, bounds_check, DataType::Type::kInt32, dex_pc);
-    HInstruction* add =  new (GetAllocator()) HAdd(DataType::Type::kInt32, array_get, const_1);
-    HInstruction* array_set = new (GetAllocator()) HArraySet(
-        null_check, bounds_check, add, DataType::Type::kInt32, dex_pc);
-    HInstruction* induction_inc = new (GetAllocator()) HAdd(DataType::Type::kInt32, phi, const_1);
-
-    loop_body->AddInstruction(null_check);
-    loop_body->AddInstruction(array_length);
-    loop_body->AddInstruction(bounds_check);
-    loop_body->AddInstruction(array_get);
-    loop_body->AddInstruction(add);
-    loop_body->AddInstruction(array_set);
-    loop_body->AddInstruction(induction_inc);
-    loop_body->AddInstruction(new (GetAllocator()) HGoto());
-
-    phi->AddInput(const_0);
-    phi->AddInput(induction_inc);
+        MakeArrayGet(loop_body, null_check, bounds_check, DataType::Type::kInt32, dex_pc);
+    HInstruction* add =  MakeBinOp<HAdd>(loop_body, DataType::Type::kInt32, array_get, const_1);
+    HInstruction* array_set =
+        MakeArraySet(loop_body, null_check, bounds_check, add, DataType::Type::kInt32, dex_pc);
 
     graph_->SetHasBoundsChecks(true);
-
-    // Adjust HEnvironment for each instruction which require that.
-    ArenaVector<HInstruction*> current_locals({phi, const_128, parameters_[0]},
-                                              GetAllocator()->Adapter(kArenaAllocInstruction));
-
-    HEnvironment* env = ManuallyBuildEnvFor(suspend_check, &current_locals);
-    null_check->CopyEnvironmentFrom(env);
-    bounds_check->CopyEnvironmentFrom(env);
   }
+
+  HParameterValue* param_ = nullptr;
 };
 
 TEST_F(SuperblockClonerTest, IndividualInstrCloner) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
@@ -130,12 +83,12 @@ TEST_F(SuperblockClonerTest, IndividualInstrCloner) {
 
   visitor.VisitInsertionOrder();
   size_t instr_replaced_by_clones_count = visitor.GetInstrReplacedByClonesCount();
-  EXPECT_EQ(instr_replaced_by_clones_count, 12u);
+  EXPECT_EQ(instr_replaced_by_clones_count, 14u);
   EXPECT_TRUE(CheckGraph());
 
   visitor.VisitReversePostOrder();
   instr_replaced_by_clones_count = visitor.GetInstrReplacedByClonesCount();
-  EXPECT_EQ(instr_replaced_by_clones_count, 24u);
+  EXPECT_EQ(instr_replaced_by_clones_count, 28u);
   EXPECT_TRUE(CheckGraph());
 
   HSuspendCheck* new_suspend_check = header->GetLoopInformation()->GetSuspendCheck();
@@ -146,12 +99,10 @@ TEST_F(SuperblockClonerTest, IndividualInstrCloner) {
 // Tests SuperblockCloner::CloneBasicBlocks - check instruction cloning and initial remapping of
 // instructions' inputs.
 TEST_F(SuperblockClonerTest, CloneBasicBlocks) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
   ArenaAllocator* arena = GetAllocator();
 
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
   ASSERT_TRUE(CheckGraph());
@@ -227,12 +178,10 @@ TEST_F(SuperblockClonerTest, CloneBasicBlocks) {
 // SuperblockCloner::CleanUpControlFlow - checks algorithms of local adjustments of the control
 // flow.
 TEST_F(SuperblockClonerTest, AdjustControlFlowInfo) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
   ArenaAllocator* arena = GetAllocator();
 
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
   ASSERT_TRUE(CheckGraph());
@@ -266,12 +215,10 @@ TEST_F(SuperblockClonerTest, AdjustControlFlowInfo) {
 
 // Tests IsSubgraphConnected function for negative case.
 TEST_F(SuperblockClonerTest, IsGraphConnected) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
   ArenaAllocator* arena = GetAllocator();
 
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   HBasicBlock* unreachable_block = AddNewBlock();
 
@@ -290,11 +237,8 @@ TEST_F(SuperblockClonerTest, IsGraphConnected) {
 //
 // See an ASCII graphics example near LoopClonerHelper::DoPeeling.
 TEST_F(SuperblockClonerTest, LoopPeeling) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
@@ -327,11 +271,8 @@ TEST_F(SuperblockClonerTest, LoopPeeling) {
 //
 // See an ASCII graphics example near LoopClonerHelper::DoUnrolling.
 TEST_F(SuperblockClonerTest, LoopUnrolling) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
@@ -364,11 +305,8 @@ TEST_F(SuperblockClonerTest, LoopUnrolling) {
 //
 // See an ASCII graphics example near LoopClonerHelper::DoVersioning.
 TEST_F(SuperblockClonerTest, LoopVersioning) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
@@ -412,11 +350,8 @@ TEST_F(SuperblockClonerTest, LoopVersioning) {
 // Checks that loop unrolling works fine for a loop with multiple back edges. Tests that after
 // the transformation the loop has a single preheader.
 TEST_F(SuperblockClonerTest, LoopPeelingMultipleBackEdges) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
 
   // Transform a basic loop to have multiple back edges.
@@ -428,16 +363,14 @@ TEST_F(SuperblockClonerTest, LoopPeelingMultipleBackEdges) {
   if_block->AddSuccessor(temp1);
   temp1->AddSuccessor(header);
 
-  if_block->AddInstruction(new (GetAllocator()) HIf(parameters_[0]));
+  MakeIf(if_block, param_);
 
   HInstructionIterator it(header->GetPhis());
   DCHECK(!it.Done());
   HPhi* loop_phi = it.Current()->AsPhi();
-  HInstruction* temp_add = new (GetAllocator()) HAdd(DataType::Type::kInt32,
-                                                     loop_phi,
-                                                     graph_->GetIntConstant(2));
-  temp1->AddInstruction(temp_add);
-  temp1->AddInstruction(new (GetAllocator()) HGoto());
+  HInstruction* temp_add =
+      MakeBinOp<HAdd>(temp1, DataType::Type::kInt32, loop_phi, graph_->GetIntConstant(2));
+  MakeGoto(temp1);
   loop_phi->AddInput(temp_add);
 
   graph_->BuildDominatorTree();
@@ -465,42 +398,36 @@ static void CheckLoopStructureForLoopPeelingNested(HBasicBlock* loop1_header,
 }
 
 TEST_F(SuperblockClonerTest, LoopPeelingNested) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
+  HBasicBlock* return_block = InitGraphAndParameters();
 
   // Create the following nested structure of loops
   //   Headers:  1    2 3
   //             [ ], [ [ ] ]
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop1_header = header;
+  auto [preheader1, header1, body1] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header1, body1);
 
-  CreateBasicLoopControlFlow(header, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop2_header = header;
+  auto [preheader2, header2, body2_end] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header2, body2_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop3_header = header;
+  auto [preheader3, header3, body3] = CreateWhileLoop(body2_end);
+  CreateBasicLoopDataFlow(header3, body3);
 
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
 
-  HLoopInformation* loop2_info_before = loop2_header->GetLoopInformation();
-  HLoopInformation* loop3_info_before = loop3_header->GetLoopInformation();
+  HLoopInformation* loop2_info_before = header2->GetLoopInformation();
+  HLoopInformation* loop3_info_before = header3->GetLoopInformation();
 
   // Check nested loops structure.
-  CheckLoopStructureForLoopPeelingNested(loop1_header, loop2_header, loop3_header);
-  LoopClonerSimpleHelper helper(loop1_header->GetLoopInformation(), /* induction_range= */ nullptr);
+  CheckLoopStructureForLoopPeelingNested(header1, header2, header3);
+  LoopClonerSimpleHelper helper(header1->GetLoopInformation(), /* induction_range= */ nullptr);
   helper.DoPeeling();
   // Check that nested loops structure has not changed after the transformation.
-  CheckLoopStructureForLoopPeelingNested(loop1_header, loop2_header, loop3_header);
+  CheckLoopStructureForLoopPeelingNested(header1, header2, header3);
 
   // Test that the loop info is preserved.
-  EXPECT_EQ(loop2_info_before, loop2_header->GetLoopInformation());
-  EXPECT_EQ(loop3_info_before, loop3_header->GetLoopInformation());
+  EXPECT_EQ(loop2_info_before, header2->GetLoopInformation());
+  EXPECT_EQ(loop3_info_before, header3->GetLoopInformation());
 
   EXPECT_EQ(loop3_info_before->GetPreHeader()->GetLoopInformation(), loop2_info_before);
   EXPECT_EQ(loop2_info_before->GetPreHeader()->GetLoopInformation(), nullptr);
@@ -512,46 +439,39 @@ TEST_F(SuperblockClonerTest, LoopPeelingNested) {
 
 // Checks that the loop population is correctly propagated after an inner loop is peeled.
 TEST_F(SuperblockClonerTest, OuterLoopPopulationAfterInnerPeeled) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
+  HBasicBlock* return_block = InitGraphAndParameters();
 
   // Create the following nested structure of loops
   //   Headers:  1 2 3        4
   //             [ [ [ ] ] ], [ ]
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop1_header = header;
+  auto [preheader1, header1, body1_end] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header1, body1_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop2_header = header;
+  auto [preheader2, header2, body2_end] = CreateWhileLoop(body1_end);
+  CreateBasicLoopDataFlow(header2, body2_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop3_header = header;
+  auto [preheader3, header3, body3] = CreateWhileLoop(body2_end);
+  CreateBasicLoopDataFlow(header3, body3);
 
-  CreateBasicLoopControlFlow(loop1_header, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop4_header = header;
+  auto [preheader4, header4, body4] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header4, body4);
 
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
 
-  LoopClonerSimpleHelper helper(loop3_header->GetLoopInformation(), /* induction_range= */ nullptr);
+  LoopClonerSimpleHelper helper(header3->GetLoopInformation(), /* induction_range= */ nullptr);
   helper.DoPeeling();
-  HLoopInformation* loop1 = loop1_header->GetLoopInformation();
-  HLoopInformation* loop2 = loop2_header->GetLoopInformation();
-  HLoopInformation* loop3 = loop3_header->GetLoopInformation();
-  HLoopInformation* loop4 = loop4_header->GetLoopInformation();
+  HLoopInformation* loop1 = header1->GetLoopInformation();
+  HLoopInformation* loop2 = header2->GetLoopInformation();
+  HLoopInformation* loop3 = header3->GetLoopInformation();
+  HLoopInformation* loop4 = header4->GetLoopInformation();
 
-  EXPECT_TRUE(loop1->Contains(*loop2_header));
-  EXPECT_TRUE(loop1->Contains(*loop3_header));
-  EXPECT_TRUE(loop1->Contains(*loop3_header->GetLoopInformation()->GetPreHeader()));
+  EXPECT_TRUE(loop1->Contains(*header2));
+  EXPECT_TRUE(loop1->Contains(*header3));
+  EXPECT_TRUE(loop1->Contains(*header3->GetLoopInformation()->GetPreHeader()));
 
   // Check that loop4 info has not been touched after local run of AnalyzeLoops.
-  EXPECT_EQ(loop4, loop4_header->GetLoopInformation());
+  EXPECT_EQ(loop4, header4->GetLoopInformation());
 
   EXPECT_TRUE(loop1->IsIn(*loop1));
   EXPECT_TRUE(loop2->IsIn(*loop1));
@@ -569,45 +489,39 @@ TEST_F(SuperblockClonerTest, OuterLoopPopulationAfterInnerPeeled) {
 // Checks the case when inner loop have an exit not to its immediate outer_loop but some other loop
 // in the hierarchy. Loop population information must be valid after loop peeling.
 TEST_F(SuperblockClonerTest, NestedCaseExitToOutermost) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
-
-  InitGraphAndParameters();
+  HBasicBlock* return_block = InitGraphAndParameters();
 
   // Create the following nested structure of loops then peel loop3.
   //   Headers:  1 2 3
   //             [ [ [ ] ] ]
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop1_header = header;
-  HBasicBlock* loop_body1 = loop_body;
+  auto [preheader1, header1, body1_end] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header1, body1_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
+  auto [preheader2, header2, body2_end] = CreateWhileLoop(body1_end);
+  CreateBasicLoopDataFlow(header2, body2_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop3_header = header;
-  HBasicBlock* loop_body3 = loop_body;
+  auto [preheader3, header3, body3] = CreateWhileLoop(body2_end);
+  CreateBasicLoopDataFlow(header3, body3);
 
   // Change the loop3 - insert an exit which leads to loop1.
   HBasicBlock* loop3_extra_if_block = AddNewBlock();
-  loop3_extra_if_block->AddInstruction(new (GetAllocator()) HIf(parameters_[0]));
+  MakeIf(loop3_extra_if_block, param_);
 
-  loop3_header->ReplaceSuccessor(loop_body3, loop3_extra_if_block);
-  loop3_extra_if_block->AddSuccessor(loop_body1);  // Long exit.
-  loop3_extra_if_block->AddSuccessor(loop_body3);
+  header3->ReplaceSuccessor(body3, loop3_extra_if_block);
+  // Note: After this, both edges to `body1_end` shall be critical edges.
+  loop3_extra_if_block->AddSuccessor(body1_end);  // Long exit.
+  loop3_extra_if_block->AddSuccessor(body3);
 
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
 
   HBasicBlock* loop3_long_exit = loop3_extra_if_block->GetSuccessors()[0];
-  EXPECT_TRUE(loop1_header->GetLoopInformation()->Contains(*loop3_long_exit));
+  EXPECT_TRUE(header1->GetLoopInformation()->Contains(*loop3_long_exit));
 
-  LoopClonerSimpleHelper helper(loop3_header->GetLoopInformation(), /* induction_range= */ nullptr);
+  LoopClonerSimpleHelper helper(header3->GetLoopInformation(), /* induction_range= */ nullptr);
   helper.DoPeeling();
 
-  HLoopInformation* loop1 = loop1_header->GetLoopInformation();
+  HLoopInformation* loop1 = header1->GetLoopInformation();
   // Check that after the transformation the local area for CF adjustments has been chosen
   // correctly and loop population has been updated.
   loop3_long_exit = loop3_extra_if_block->GetSuccessors()[0];
@@ -615,19 +529,17 @@ TEST_F(SuperblockClonerTest, NestedCaseExitToOutermost) {
 
   EXPECT_EQ(helper.GetRegionToBeAdjusted(), loop1);
 
-  EXPECT_TRUE(loop1->Contains(*loop3_header));
-  EXPECT_TRUE(loop1->Contains(*loop3_header->GetLoopInformation()->GetPreHeader()));
+  EXPECT_TRUE(loop1->Contains(*header3));
+  EXPECT_TRUE(loop1->Contains(*header3->GetLoopInformation()->GetPreHeader()));
 
   EXPECT_TRUE(CheckGraph());
 }
 
 TEST_F(SuperblockClonerTest, FastCaseCheck) {
-  HBasicBlock* header = nullptr;
-  HBasicBlock* loop_body = nullptr;
   ArenaAllocator* arena = GetAllocator();
 
-  InitGraphAndParameters();
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
+  HBasicBlock* return_block = InitGraphAndParameters();
+  auto [preheader, header, loop_body] = CreateWhileLoop(return_block);
   CreateBasicLoopDataFlow(header, loop_body);
   graph_->BuildDominatorTree();
 
@@ -648,7 +560,7 @@ TEST_F(SuperblockClonerTest, FastCaseCheck) {
                                     &remap_incoming);
 
   // Insert some extra nodes and edges.
-  HBasicBlock* preheader = loop_info->GetPreHeader();
+  ASSERT_EQ(preheader, loop_info->GetPreHeader());
   orig_bb_set.SetBit(preheader->GetBlockId());
 
   // Adjust incoming edges.
@@ -681,39 +593,34 @@ TEST_F(SuperblockClonerTest, FindCommonLoop) {
   HBasicBlock* header = nullptr;
   HBasicBlock* loop_body = nullptr;
 
-  InitGraphAndParameters();
+  HBasicBlock* return_block = InitGraphAndParameters();
 
   // Create the following nested structure of loops
   //   Headers:  1 2 3      4      5
   //             [ [ [ ] ], [ ] ], [ ]
-  CreateBasicLoopControlFlow(entry_block_, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop1_header = header;
+  auto [preheader1, header1, body1_end] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header1, body1_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop2_header = header;
+  auto [preheader2, header2, body2_end] = CreateWhileLoop(body1_end);
+  CreateBasicLoopDataFlow(header2, body2_end);
 
-  CreateBasicLoopControlFlow(header, header->GetSuccessors()[1], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop3_header = header;
+  auto [preheader3, header3, body3] = CreateWhileLoop(body2_end);
+  CreateBasicLoopDataFlow(header3, body3);
 
-  CreateBasicLoopControlFlow(loop2_header, loop2_header->GetSuccessors()[0], &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop4_header = header;
+  auto [preheader4, header4, body4] = CreateWhileLoop(body1_end);
+  CreateBasicLoopDataFlow(header4, body4);
 
-  CreateBasicLoopControlFlow(loop1_header, return_block_, &header, &loop_body);
-  CreateBasicLoopDataFlow(header, loop_body);
-  HBasicBlock* loop5_header = header;
+  auto [preheader5, header5, body5] = CreateWhileLoop(return_block);
+  CreateBasicLoopDataFlow(header5, body5);
 
   graph_->BuildDominatorTree();
   EXPECT_TRUE(CheckGraph());
 
-  HLoopInformation* loop1 = loop1_header->GetLoopInformation();
-  HLoopInformation* loop2 = loop2_header->GetLoopInformation();
-  HLoopInformation* loop3 = loop3_header->GetLoopInformation();
-  HLoopInformation* loop4 = loop4_header->GetLoopInformation();
-  HLoopInformation* loop5 = loop5_header->GetLoopInformation();
+  HLoopInformation* loop1 = header1->GetLoopInformation();
+  HLoopInformation* loop2 = header2->GetLoopInformation();
+  HLoopInformation* loop3 = header3->GetLoopInformation();
+  HLoopInformation* loop4 = header4->GetLoopInformation();
+  HLoopInformation* loop5 = header5->GetLoopInformation();
 
   EXPECT_TRUE(loop1->IsIn(*loop1));
   EXPECT_TRUE(loop2->IsIn(*loop1));
diff --git a/compiler/utils/arm/assembler_arm_vixl.h b/compiler/utils/arm/assembler_arm_vixl.h
index 50dc06fefc..259b07d44f 100644
--- a/compiler/utils/arm/assembler_arm_vixl.h
+++ b/compiler/utils/arm/assembler_arm_vixl.h
@@ -26,9 +26,10 @@
 #include "utils/arm/managed_register_arm.h"
 #include "utils/assembler.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow and remove pragmas.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch32/macro-assembler-aarch32.h"
 #pragma GCC diagnostic pop
 
diff --git a/compiler/utils/arm64/assembler_arm64.h b/compiler/utils/arm64/assembler_arm64.h
index ad6a8edadf..03724633b9 100644
--- a/compiler/utils/arm64/assembler_arm64.h
+++ b/compiler/utils/arm64/assembler_arm64.h
@@ -30,9 +30,10 @@
 #include "utils/arm64/managed_register_arm64.h"
 #include "utils/assembler.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/disasm-aarch64.h"
 #include "aarch64/macro-assembler-aarch64.h"
 #pragma GCC diagnostic pop
diff --git a/compiler/utils/arm64/jni_macro_assembler_arm64.h b/compiler/utils/arm64/jni_macro_assembler_arm64.h
index b861472218..01cabd4e11 100644
--- a/compiler/utils/arm64/jni_macro_assembler_arm64.h
+++ b/compiler/utils/arm64/jni_macro_assembler_arm64.h
@@ -31,9 +31,10 @@
 #include "utils/assembler.h"
 #include "utils/jni_macro_assembler.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/macro-assembler-aarch64.h"
 #pragma GCC diagnostic pop
 
diff --git a/compiler/utils/assembler_test_base.h b/compiler/utils/assembler_test_base.h
index d41928af9e..0a89ad1299 100644
--- a/compiler/utils/assembler_test_base.h
+++ b/compiler/utils/assembler_test_base.h
@@ -150,7 +150,7 @@ class AssemblerTestBase : public testing::Test {
                 "--compile",
                 "-target",
                 "riscv64-linux-gnu",
-                "-march=rv64imafdcv_zba_zbb_zca_zcd_zcb",
+                "-march=rv64imafdcv_zba_zbb_zbs_zca_zcd_zcb",
                 // Force the assembler to fully emit branch instructions instead of leaving
                 // offsets unresolved with relocation information for the linker.
                 "-mno-relax"};
diff --git a/compiler/utils/assembler_thumb_test_expected.cc.inc b/compiler/utils/assembler_thumb_test_expected.cc.inc
index 6e0048eb20..5184b2c897 100644
--- a/compiler/utils/assembler_thumb_test_expected.cc.inc
+++ b/compiler/utils/assembler_thumb_test_expected.cc.inc
@@ -154,7 +154,7 @@ const char* const VixlJniHelpersResults = {
   "     210: f8d9 8020     ldr.w r8, [r9, #32]\n"
   "     214: 4770          bx lr\n"
   "     216: f8d9 0094     ldr.w r0, [r9, #148]\n"
-  "     21a: f8d9 e2c4     ldr.w lr, [r9, #708]\n"
+  "     21a: f8d9 e2c0     ldr.w lr, [r9, #704]\n"
   "     21e: 47f0          blx lr\n"
 };
 
diff --git a/compiler/utils/riscv64/assembler_riscv64.cc b/compiler/utils/riscv64/assembler_riscv64.cc
index a0832bc3a8..3a776648e1 100644
--- a/compiler/utils/riscv64/assembler_riscv64.cc
+++ b/compiler/utils/riscv64/assembler_riscv64.cc
@@ -69,7 +69,6 @@ void Riscv64Assembler::FinalizeCode() {
 
 void Riscv64Assembler::Lui(XRegister rd, uint32_t imm20) {
   if (IsExtensionEnabled(Riscv64Extension::kZca)) {
-    int32_t simm = static_cast<int32_t>(imm20);
     if (rd != Zero && rd != SP && IsImmCLuiEncodable(imm20)) {
       CLui(rd, imm20);
       return;
@@ -1725,6 +1724,54 @@ void Riscv64Assembler::ZbbZextH(XRegister rd, XRegister rs1) {
 
 /////////////////////////////// RV64 "Zbb" Instructions  END //////////////////////////////
 
+////////////////////////////// RV64 "Zbs" Instructions  START /////////////////////////////
+
+void Riscv64Assembler::Bclr(XRegister rd, XRegister rs1, XRegister rs2) {
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitR(0x24, rs2, rs1, 0x1, rd, 0x33);
+}
+
+void Riscv64Assembler::Bclri(XRegister rd, XRegister rs1, int32_t shamt) {
+  CHECK_LT(static_cast<uint32_t>(shamt), 64u);
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitI6(0x12, shamt, rs1, 0x1, rd, 0x13);
+}
+
+void Riscv64Assembler::Bext(XRegister rd, XRegister rs1, XRegister rs2) {
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitR(0x24, rs2, rs1, 0x5, rd, 0x33);
+}
+
+void Riscv64Assembler::Bexti(XRegister rd, XRegister rs1, int32_t shamt) {
+  CHECK_LT(static_cast<uint32_t>(shamt), 64u);
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitI6(0x12, shamt, rs1, 0x5, rd, 0x13);
+}
+
+void Riscv64Assembler::Binv(XRegister rd, XRegister rs1, XRegister rs2) {
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitR(0x34, rs2, rs1, 0x1, rd, 0x33);
+}
+
+void Riscv64Assembler::Binvi(XRegister rd, XRegister rs1, int32_t shamt) {
+  CHECK_LT(static_cast<uint32_t>(shamt), 64u);
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitI6(0x1A, shamt, rs1, 0x1, rd, 0x13);
+}
+
+void Riscv64Assembler::Bset(XRegister rd, XRegister rs1, XRegister rs2) {
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitR(0x14, rs2, rs1, 0x1, rd, 0x33);
+}
+
+void Riscv64Assembler::Bseti(XRegister rd, XRegister rs1, int32_t shamt) {
+  CHECK_LT(static_cast<uint32_t>(shamt), 64u);
+  AssertExtensionsEnabled(Riscv64Extension::kZbs);
+  EmitI6(0xA, shamt, rs1, 0x1, rd, 0x13);
+}
+
+/////////////////////////////// RV64 "Zbs" Instructions  END //////////////////////////////
+
 /////////////////////////////// RVV "VSet" Instructions  START ////////////////////////////
 
 void Riscv64Assembler::VSetvli(XRegister rd, XRegister rs1, uint32_t vtypei) {
@@ -6574,6 +6621,7 @@ const Riscv64Assembler::Branch::BranchInfo Riscv64Assembler::Branch::branch_info
     {8, 4, Riscv64Assembler::Branch::kOffset21},  // kCondBranch21
 
     // Long branches.
+    {10, 2, Riscv64Assembler::Branch::kOffset32},  // kLongCondCBranch
     {12, 4, Riscv64Assembler::Branch::kOffset32},  // kLongCondBranch
     {8, 0, Riscv64Assembler::Branch::kOffset32},   // kLongUncondBranch
     {8, 0, Riscv64Assembler::Branch::kOffset32},   // kLongCall
@@ -6589,36 +6637,15 @@ const Riscv64Assembler::Branch::BranchInfo Riscv64Assembler::Branch::branch_info
     {8, 0, Riscv64Assembler::Branch::kOffset32},  // kLiteralDouble
 };
 
-void Riscv64Assembler::Branch::InitShortOrLong(Riscv64Assembler::Branch::OffsetBits offset_size,
-                                               Riscv64Assembler::Branch::Type short_type,
-                                               Riscv64Assembler::Branch::Type long_type,
-                                               Riscv64Assembler::Branch::Type longest_type) {
-  Riscv64Assembler::Branch::Type type = short_type;
-  if (offset_size > branch_info_[type].offset_size) {
-    type = long_type;
-    if (offset_size > branch_info_[type].offset_size) {
-      type = longest_type;
-    }
-  }
-  type_ = type;
-}
-
-void Riscv64Assembler::Branch::InitShortOrLong(Riscv64Assembler::Branch::OffsetBits offset_size,
-                                               Riscv64Assembler::Branch::Type compressed_type,
-                                               Riscv64Assembler::Branch::Type short_type,
-                                               Riscv64Assembler::Branch::Type long_type,
-                                               Riscv64Assembler::Branch::Type longest_type) {
-  Riscv64Assembler::Branch::Type type = compressed_type;
-  if (offset_size > branch_info_[type].offset_size) {
-    type = short_type;
-    if (offset_size > branch_info_[type].offset_size) {
-      type = long_type;
-      if (offset_size > branch_info_[type].offset_size) {
-        type = longest_type;
-      }
-    }
+void Riscv64Assembler::Branch::InitShortOrLong(OffsetBits offset_size,
+                                               std::initializer_list<Type> types) {
+  auto it = types.begin();
+  DCHECK(it != types.end());
+  while (offset_size > branch_info_[*it].offset_size) {
+    ++it;
+    DCHECK(it != types.end());
   }
-  type_ = type;
+  type_ = *it;
 }
 
 void Riscv64Assembler::Branch::InitializeType(Type initial_type) {
@@ -6629,12 +6656,12 @@ void Riscv64Assembler::Branch::InitializeType(Type initial_type) {
       CHECK(IsCompressableCondition());
       if (condition_ != kUncond) {
         InitShortOrLong(
-            offset_size_needed, kCondCBranch, kCondBranch, kCondCBranch21, kLongCondBranch);
+            offset_size_needed, {kCondCBranch, kCondBranch, kCondCBranch21, kLongCondCBranch});
         break;
       }
       FALLTHROUGH_INTENDED;
     case kUncondCBranch:
-      InitShortOrLong(offset_size_needed, kUncondCBranch, kUncondBranch, kLongUncondBranch);
+      InitShortOrLong(offset_size_needed, {kUncondCBranch, kUncondBranch, kLongUncondBranch});
       break;
     case kBareCondCBranch:
       if (condition_ != kUncond) {
@@ -6649,15 +6676,15 @@ void Riscv64Assembler::Branch::InitializeType(Type initial_type) {
       break;
     case kCondBranch:
       if (condition_ != kUncond) {
-        InitShortOrLong(offset_size_needed, kCondBranch, kCondBranch21, kLongCondBranch);
+        InitShortOrLong(offset_size_needed, {kCondBranch, kCondBranch21, kLongCondBranch});
         break;
       }
       FALLTHROUGH_INTENDED;
     case kUncondBranch:
-      InitShortOrLong(offset_size_needed, kUncondBranch, kLongUncondBranch, kLongUncondBranch);
+      InitShortOrLong(offset_size_needed, {kUncondBranch, kLongUncondBranch, kLongUncondBranch});
       break;
     case kCall:
-      InitShortOrLong(offset_size_needed, kCall, kLongCall, kLongCall);
+      InitShortOrLong(offset_size_needed, {kCall, kLongCall, kLongCall});
       break;
     case kBareCondBranch:
       if (condition_ != kUncond) {
@@ -6728,6 +6755,7 @@ bool Riscv64Assembler::Branch::IsCompressed(Type type) {
     case kBareCondCBranch:
     case kBareUncondCBranch:
     case kCondCBranch21:
+    case kLongCondCBranch:
       return true;
     default:
       return false;
@@ -6743,8 +6771,8 @@ Riscv64Assembler::Branch::Branch(
       rhs_reg_(Zero),
       freg_(kNoFRegister),
       condition_(kUncond),
-      next_branch_id_(0u),
-      compression_allowed_(compression_allowed) {
+      compression_allowed_(compression_allowed),
+      next_branch_id_(0u) {
   InitializeType((rd != Zero ?
                       (is_bare ? kBareCall : kCall) :
                       (is_bare ? (compression_allowed ? kBareUncondCBranch : kBareUncondBranch) :
@@ -6765,16 +6793,13 @@ Riscv64Assembler::Branch::Branch(uint32_t location,
       rhs_reg_(rhs_reg),
       freg_(kNoFRegister),
       condition_(condition),
+      compression_allowed_(compression_allowed && IsCompressableCondition()),
       next_branch_id_(0u) {
   DCHECK_NE(condition, kUncond);
   DCHECK(!IsNop(condition, lhs_reg, rhs_reg));
   DCHECK(!IsUncond(condition, lhs_reg, rhs_reg));
-  if (!IsCompressableCondition()) {
-    compression_allowed = false;
-  }
-  compression_allowed_ = compression_allowed;
-  InitializeType(is_bare ? (compression_allowed ? kBareCondCBranch : kBareCondBranch) :
-                           (compression_allowed ? kCondCBranch : kCondBranch));
+  InitializeType(is_bare ? (compression_allowed_ ? kBareCondCBranch : kBareCondBranch) :
+                           (compression_allowed_ ? kCondCBranch : kCondBranch));
 }
 
 Riscv64Assembler::Branch::Branch(uint32_t location,
@@ -6788,8 +6813,8 @@ Riscv64Assembler::Branch::Branch(uint32_t location,
       rhs_reg_(Zero),
       freg_(kNoFRegister),
       condition_(kUncond),
-      next_branch_id_(0u),
-      compression_allowed_(false) {
+      compression_allowed_(false),
+      next_branch_id_(0u) {
   CHECK_NE(rd , Zero);
   InitializeType(label_or_literal_type);
 }
@@ -6805,8 +6830,8 @@ Riscv64Assembler::Branch::Branch(uint32_t location,
       rhs_reg_(Zero),
       freg_(rd),
       condition_(kUncond),
-      next_branch_id_(0u),
-      compression_allowed_(false) {
+      compression_allowed_(false),
+      next_branch_id_(0u) {
   InitializeType(literal_type);
 }
 
@@ -6881,6 +6906,8 @@ uint32_t Riscv64Assembler::Branch::NextBranchId() const { return next_branch_id_
 
 bool Riscv64Assembler::Branch::IsBare() const {
   switch (type_) {
+    case kBareCondCBranch:
+    case kBareUncondCBranch:
     case kBareUncondBranch:
     case kBareCondBranch:
     case kBareCall:
@@ -6972,12 +6999,10 @@ uint32_t Riscv64Assembler::Branch::PromoteIfNeeded() {
         return 0u;
       }
 
-      Type cond21Type = old_type == kCondCBranch ? kCondCBranch21 : kCondBranch21;
-      if (compression_allowed_ && cond21Type == kCondBranch21 && IsCompressableCondition()) {
-        // If this branch was promoted from compressed one on initialization stage
-        // it could be promoted back to compressed if possible
-        cond21Type = kCondCBranch21;
-      }
+      Type cond21Type =
+          (compression_allowed_ && IsCompressableCondition()) ? kCondCBranch21 : kCondBranch21;
+      Type longCondType =
+          (compression_allowed_ && IsCompressableCondition()) ? kLongCondCBranch : kLongCondBranch;
 
       // The offset remains the same for `kCond[C]Branch21` for forward branches.
       DCHECK_EQ(branch_info_[cond21Type].length - branch_info_[cond21Type].pc_offset,
@@ -6986,7 +7011,7 @@ uint32_t Riscv64Assembler::Branch::PromoteIfNeeded() {
         // Calculate the needed size for kCond[C]Branch21.
         needed_size = GetOffsetSizeNeeded(location_ + branch_info_[cond21Type].pc_offset, target_);
       }
-      type_ = (needed_size <= branch_info_[cond21Type].offset_size) ? cond21Type : kLongCondBranch;
+      type_ = (needed_size <= branch_info_[cond21Type].offset_size) ? cond21Type : longCondType;
       break;
     }
     case kUncondBranch:
@@ -7001,10 +7026,15 @@ uint32_t Riscv64Assembler::Branch::PromoteIfNeeded() {
       }
       type_ = kLongCall;
       break;
-    // Medium branch (can be promoted to long).
-    case kCondCBranch21:
-      DCHECK(IsCompressableCondition());
-      FALLTHROUGH_INTENDED;
+    // Medium branches (can be promoted to long).
+    case kCondCBranch21: {
+      OffsetBits needed_size = GetOffsetSizeNeeded(GetOffsetLocation(), target_);
+      if (needed_size <= GetOffsetSize()) {
+        return 0u;
+      }
+      type_ = kLongCondCBranch;
+      break;
+    }
     case kCondBranch21: {
       OffsetBits needed_size = GetOffsetSizeNeeded(GetOffsetLocation(), target_);
       if (needed_size <= GetOffsetSize()) {
@@ -7085,6 +7115,18 @@ void Riscv64Assembler::EmitBranch(Riscv64Assembler::Branch* branch) {
     next(short_offset);
   };
 
+  auto emit_cbcondz_opposite = [&]() {
+    DCHECK(branch->IsCompressableCondition());
+    ScopedUseCInstructions use_compression(this);
+    if (condition == kCondNE) {
+      DCHECK_EQ(Branch::OppositeCondition(condition), kCondEQ);
+      CBeqz(branch->GetNonZeroRegister(), branch->GetLength());
+    } else {
+      DCHECK_EQ(Branch::OppositeCondition(condition), kCondNE);
+      CBnez(branch->GetNonZeroRegister(), branch->GetLength());
+    }
+  };
+
   switch (branch->GetType()) {
     // Compressed branches
     case Branch::kCondCBranch:
@@ -7131,22 +7173,16 @@ void Riscv64Assembler::EmitBranch(Riscv64Assembler::Branch* branch) {
       J(offset);
       break;
     case Branch::kCondCBranch21: {
-      DCHECK(branch->IsCompressableCondition());
-      {
-        ScopedUseCInstructions use_compression(this);
-        if (condition == kCondNE) {
-          DCHECK_EQ(Branch::OppositeCondition(condition), kCondEQ);
-          CBeqz(branch->GetNonZeroRegister(), branch->GetLength());
-        } else {
-          DCHECK_EQ(Branch::OppositeCondition(condition), kCondNE);
-          CBnez(branch->GetNonZeroRegister(), branch->GetLength());
-        }
-      }
+      emit_cbcondz_opposite();
       CHECK_EQ(overwrite_location_, branch->GetOffsetLocation());
       J(offset);
       break;
     }
     // Long branches.
+    case Branch::kLongCondCBranch:
+      emit_cbcondz_opposite();
+      emit_auipc_and_next(TMP, [&](int32_t short_offset) { Jalr(Zero, TMP, short_offset); });
+      break;
     case Branch::kLongCondBranch:
       EmitBcond(Branch::OppositeCondition(condition), lhs, rhs, branch->GetLength());
       FALLTHROUGH_INTENDED;
diff --git a/compiler/utils/riscv64/assembler_riscv64.h b/compiler/utils/riscv64/assembler_riscv64.h
index 667d09dc74..7586064a91 100644
--- a/compiler/utils/riscv64/assembler_riscv64.h
+++ b/compiler/utils/riscv64/assembler_riscv64.h
@@ -57,7 +57,7 @@ enum class Riscv64Extension : uint32_t {
   kD,
   kZba,
   kZbb,
-  kZbs,  // TODO(riscv64): Implement "Zbs" instructions.
+  kZbs,
   kV,
   kZca,  // "C" extension instructions except floating point loads/stores.
   kZcd,  // "C" extension double loads/stores.
@@ -637,6 +637,16 @@ class Riscv64Assembler final : public Assembler {
   void ZbbSextH(XRegister rd, XRegister rs1);
   void ZbbZextH(XRegister rd, XRegister rs1);
 
+  // "Zbs" Standard Extension, opcode = 0x13, or 0x33, funct3 and funct7 varies.
+  void Bclr(XRegister rd, XRegister rs1, XRegister rs2);
+  void Bclri(XRegister rd, XRegister rs1, int32_t shamt);
+  void Bext(XRegister rd, XRegister rs1, XRegister rs2);
+  void Bexti(XRegister rd, XRegister rs1, int32_t shamt);
+  void Binv(XRegister rd, XRegister rs1, XRegister rs2);
+  void Binvi(XRegister rd, XRegister rs1, int32_t shamt);
+  void Bset(XRegister rd, XRegister rs1, XRegister rs2);
+  void Bseti(XRegister rd, XRegister rs1, int32_t shamt);
+
   ////////////////////////////// RISC-V Vector Instructions  START ///////////////////////////////
   enum class LengthMultiplier : uint32_t {
     kM1Over8 = 0b101,
@@ -1965,6 +1975,7 @@ class Riscv64Assembler final : public Assembler {
       kCondBranch21,
 
       // Long branches.
+      kLongCondCBranch,
       kLongCondBranch,
       kLongUncondBranch,
       kLongCall,
@@ -2083,12 +2094,7 @@ class Riscv64Assembler final : public Assembler {
     // Completes branch construction by determining and recording its type.
     void InitializeType(Type initial_type);
     // Helper for the above.
-    void InitShortOrLong(OffsetBits ofs_size, Type short_type, Type long_type, Type longest_type);
-    void InitShortOrLong(OffsetBits ofs_size,
-                         Type compressed_type,
-                         Type short_type,
-                         Type long_type,
-                         Type longest_type);
+    void InitShortOrLong(OffsetBits ofs_size, std::initializer_list<Type> types);
 
     uint32_t old_location_;  // Offset into assembler buffer in bytes.
     uint32_t location_;      // Offset into assembler buffer in bytes.
@@ -2103,12 +2109,12 @@ class Riscv64Assembler final : public Assembler {
     Type type_;      // Current type of the branch.
     Type old_type_;  // Initial type of the branch.
 
+    bool compression_allowed_;
+
     // Id of the next branch bound to the same label in singly-linked zero-terminated list
     // NOTE: encoded the same way as a position in a linked Label (id + sizeof(void*))
     // Label itself is used to hold the 'head' of this list
     uint32_t next_branch_id_;
-
-    bool compression_allowed_;
   };
 
   // Branch and literal fixup.
diff --git a/compiler/utils/riscv64/assembler_riscv64_test.cc b/compiler/utils/riscv64/assembler_riscv64_test.cc
index 960584070a..aebb8f6b17 100644
--- a/compiler/utils/riscv64/assembler_riscv64_test.cc
+++ b/compiler/utils/riscv64/assembler_riscv64_test.cc
@@ -468,6 +468,12 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
     DriverStr(expected, test_name);
   }
 
+  static std::string StripZeroArg(const std::string& args) {
+    static constexpr char kZeroSuffix[] = ", zero";
+    CHECK(args.ends_with(kZeroSuffix));
+    return args.substr(0u, args.size() - strlen(kZeroSuffix));
+  }
+
   auto GetPrintBcond() {
     return [](const std::string& cond,
               [[maybe_unused]] const std::string& opposite_cond,
@@ -477,31 +483,32 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
     };
   }
 
-  auto GetPrintBcondOpposite() {
-    return [=]([[maybe_unused]] const std::string& cond,
-               const std::string& opposite_cond,
-               const std::string& args,
-               const std::string& target) {
-      return "b" + opposite_cond + args + ", " + target + "\n";
+  auto GetPrintCBcond() {
+    return [](const std::string& cond,
+              [[maybe_unused]] const std::string& opposite_cond,
+              const std::string& args,
+              const std::string& target) {
+      return "c.b" + cond + "z" + StripZeroArg(args) + ", " + target + "\n";
     };
   }
 
-  auto GetPrintBcondAndJ(const std::string& skip_label) {
-    return [=](const std::string& cond,
-               [[maybe_unused]] const std::string& opposite_cond,
+  auto GetPrintBcondOppositeAndJ(const std::string& skip_label) {
+    return [=]([[maybe_unused]] const std::string& cond,
+               const std::string& opposite_cond,
                const std::string& args,
                const std::string& target) {
-      return "b" + cond + args + ", " + skip_label + "f\n" + "j " + target + "\n" + skip_label +
-             ":\n";
+      return "b" + opposite_cond + args + ", " + skip_label + "f\n" +
+             "j " + target + "\n" +
+             skip_label + ":\n";
     };
   }
 
-  auto GetPrintBcondOppositeAndJ(const std::string& skip_label) {
+  auto GetPrintCBcondOppositeAndJ(const std::string& skip_label) {
     return [=]([[maybe_unused]] const std::string& cond,
                const std::string& opposite_cond,
                const std::string& args,
                const std::string& target) {
-      return "b" + opposite_cond + args + ", " + skip_label + "f\n" +
+      return "c.b" + opposite_cond + "z" + StripZeroArg(args) + ", " + skip_label + "f\n" +
              "j " + target + "\n" +
              skip_label + ":\n";
     };
@@ -603,6 +610,9 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
   size_t MaxOffset9BackwardDistance() const { return KB / 4; }
   size_t MaxOffset9ForwardDistance() const { return KB / 4 - 2; }
 
+  size_t MaxOffset12BackwardDistance() const { return 2 * KB; }
+  size_t MaxOffset12ForwardDistance() const { return 2 * KB - 2; }
+
   size_t MaxOffset13BackwardDistance() const { return 4 * KB; }
   size_t MaxOffset13ForwardDistance() const { return 4 * KB - 2; }
 
@@ -618,31 +628,86 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
   template <typename PrintBcond>
   void TestBcondA0RegForward(const std::string& test_name,
                              void (Riscv64Assembler::*f)(XRegister, XRegister, Riscv64Label*, bool),
+                             XRegister reg,
                              size_t nops_size,
-                             const std::string& target_label,
                              PrintBcond&& print_bcond,
-                             XRegister reg,
-                             bool is_bare = false) {
+                             const std::string& cond,
+                             const std::string& opposite_cond,
+                             const std::string& target_label,
+                             bool is_bare) {
     std::string expected;
     Riscv64Label label;
     (GetAssembler()->*f)(A0, reg, &label, is_bare);
     std::string args = " a0, " + GetRegisterName(reg);
-    expected += print_bcond("eq", "ne", args, target_label + "f");
+    expected += print_bcond(cond, opposite_cond, args, target_label + "f");
     expected += EmitNops(nops_size);
     __ Bind(&label);
     expected += target_label + ":\n";
     DriverStr(expected, test_name);
   }
 
+  template <typename PrintBcond>
+  void TestBeqzA0Forward(const std::string& test_name,
+                         size_t nops_size,
+                         PrintBcond&& print_bcond,
+                         const std::string& target_label,
+                         bool is_bare = false) {
+    TestBcondA0RegForward(test_name,
+                          &Riscv64Assembler::Beq,
+                          Zero,
+                          nops_size,
+                          std::move(print_bcond),
+                          "eq",
+                          "ne",
+                          target_label,
+                          is_bare);
+  }
+
+  template <typename PrintBcond>
+  void TestBnezA0Forward(const std::string& test_name,
+                         size_t nops_size,
+                         PrintBcond&& print_bcond,
+                         const std::string& target_label,
+                         bool is_bare = false) {
+    TestBcondA0RegForward(test_name,
+                          &Riscv64Assembler::Bne,
+                          Zero,
+                          nops_size,
+                          std::move(print_bcond),
+                          "ne",
+                          "eq",
+                          target_label,
+                          is_bare);
+  }
+
+  template <typename PrintBcond>
+  void TestBeqA0A1Forward(const std::string& test_name,
+                          size_t nops_size,
+                          PrintBcond&& print_bcond,
+                          const std::string& target_label,
+                          bool is_bare = false) {
+    TestBcondA0RegForward(test_name,
+                          &Riscv64Assembler::Beq,
+                          A1,
+                          nops_size,
+                          std::move(print_bcond),
+                          "eq",
+                          "ne",
+                          target_label,
+                          is_bare);
+  }
+
   template <typename PrintBcond>
   void TestBcondA0RegBackward(
       const std::string& test_name,
       void (Riscv64Assembler::*f)(XRegister, XRegister, Riscv64Label*, bool),
+      XRegister reg,
       size_t nops_size,
-      const std::string& target_label,
       PrintBcond&& print_bcond,
-      XRegister reg,
-      bool is_bare = false) {
+      const std::string& cond,
+      const std::string& opposite_cond,
+      const std::string& target_label,
+      bool is_bare) {
     std::string expected;
     Riscv64Label label;
     __ Bind(&label);
@@ -650,10 +715,61 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
     expected += EmitNops(nops_size);
     (GetAssembler()->*f)(A0, reg, &label, is_bare);
     std::string args = " a0, " + GetRegisterName(reg);
-    expected += print_bcond("eq", "ne", args, target_label + "b");
+    expected += print_bcond(cond, opposite_cond, args, target_label + "b");
     DriverStr(expected, test_name);
   }
 
+  template <typename PrintBcond>
+  void TestBeqzA0Backward(const std::string& test_name,
+                          size_t nops_size,
+                          PrintBcond&& print_bcond,
+                          const std::string& target_label,
+                          bool is_bare = false) {
+    TestBcondA0RegBackward(test_name,
+                           &Riscv64Assembler::Beq,
+                           Zero,
+                           nops_size,
+                           std::move(print_bcond),
+                           "eq",
+                           "ne",
+                           target_label,
+                           is_bare);
+  }
+
+  template <typename PrintBcond>
+  void TestBnezA0Backward(const std::string& test_name,
+                          size_t nops_size,
+                          PrintBcond&& print_bcond,
+                          const std::string& target_label,
+                          bool is_bare = false) {
+    TestBcondA0RegBackward(test_name,
+                           &Riscv64Assembler::Bne,
+                           Zero,
+                           nops_size,
+                           std::move(print_bcond),
+                           "ne",
+                           "eq",
+                           target_label,
+                           is_bare);
+  }
+
+  template <typename PrintBcond>
+  void TestBeqA0A1Backward(const std::string& test_name,
+                           size_t nops_size,
+                           PrintBcond&& print_bcond,
+                           const std::string& target_label,
+                           bool is_bare = false) {
+    TestBcondA0RegBackward(test_name,
+                           &Riscv64Assembler::Beq,
+                           A1,
+                           nops_size,
+                           std::move(print_bcond),
+                           "eq",
+                           "ne",
+                           target_label,
+                           is_bare);
+  }
+
   // Test a branch setup where expanding one branch causes expanding another branch
   // which causes expanding another branch, etc. The argument `cascade` determines
   // whether we push the first branch to expand, or not.
@@ -681,6 +797,38 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
     DriverStr(expected, test_name);
   }
 
+  void TestBcondElimination(const std::string& test_name, const std::string& nop) {
+    Riscv64Label label;
+    __ Bind(&label);
+    __ Nop();
+    for (XRegister reg : GetRegisters()) {
+      __ Bne(reg, reg, &label);
+      __ Blt(reg, reg, &label);
+      __ Bgt(reg, reg, &label);
+      __ Bltu(reg, reg, &label);
+      __ Bgtu(reg, reg, &label);
+    }
+    DriverStr(nop + "\n", test_name);
+  }
+
+  void TestBcondUnconditional(const std::string& test_name, const std::string& j) {
+    Riscv64Label label;
+    __ Bind(&label);
+    __ Nop();
+    for (XRegister reg : GetRegisters()) {
+      __ Beq(reg, reg, &label);
+      __ Bge(reg, reg, &label);
+      __ Ble(reg, reg, &label);
+      __ Bleu(reg, reg, &label);
+      __ Bgeu(reg, reg, &label);
+    }
+    std::string expected =
+        "1:\n"
+        "nop\n" +
+        RepeatInsn(5u * GetRegisters().size(), j + " 1b\n", []() {});
+    DriverStr(expected, test_name);
+  }
+
   auto GetPrintJalRd() {
     return [=](XRegister rd, const std::string& target) {
       std::string rd_name = GetRegisterName(rd);
@@ -748,6 +896,12 @@ class AssemblerRISCV64Test : public AssemblerTest<Riscv64Assembler,
     };
   }
 
+  auto GetPrintCJ() {
+    return [=](const std::string& target) {
+      return "c.j " + target + "\n";
+    };
+  }
+
   auto GetPrintJal() {
     return [=](const std::string& target) {
       return "jal " + target + "\n";
@@ -2326,10 +2480,7 @@ TEST_F(AssemblerRISCV64Test, Jalr_WithoutC) {
             "Jalr_WithoutC");
 }
 
-// The clang assembler we're currently using for testing (clang 18.0.0) does not auto-forward
-// `beq zero, rs2, offset` to `c.beqz` but newer clang assembler versions (clang 18.0.1) do.
-// TODO (riscv64): Enable this test when we're using a clang assembler that auto-forwards.
-TEST_F(AssemblerRISCV64Test, DISABLED_Beq) {
+TEST_F(AssemblerRISCV64Test, Beq) {
   DriverStr(
       RepeatRRIbS(
           &Riscv64Assembler::Beq, /*imm_bits=*/-12, /*shift=*/1, "beq {reg1}, {reg2}, {imm}\n"),
@@ -2344,10 +2495,7 @@ TEST_F(AssemblerRISCV64Test, Beq_WithoutC) {
       "Beq_WithoutC");
 }
 
-// The clang assembler we're currently using for testing (clang 18.0.0) does not auto-forward
-// `bne zero, rs2, offset` to `c.bnez` but newer clang assembler versions (clang 18.0.1) do.
-// TODO (riscv64): Enable this test when we're using a clang assembler that auto-forwards.
-TEST_F(AssemblerRISCV64Test, DISABLED_Bne) {
+TEST_F(AssemblerRISCV64Test, Bne) {
   DriverStr(
       RepeatRRIbS(
           &Riscv64Assembler::Bne, /*imm_bits=*/-12, /*shift=*/1, "bne {reg1}, {reg2}, {imm}\n"),
@@ -3900,6 +4048,42 @@ TEST_F(AssemblerRISCV64Test, ZbbZextH) {
   DriverStr(RepeatRR(&Riscv64Assembler::ZbbZextH, "zext.h {reg1}, {reg2}"), "ZbbZextH");
 }
 
+TEST_F(AssemblerRISCV64Test, Bclr) {
+  DriverStr(RepeatRRR(&Riscv64Assembler::Bclr, "bclr {reg1}, {reg2}, {reg3}"), "Bclr");
+}
+
+TEST_F(AssemblerRISCV64Test, Bclri) {
+  DriverStr(RepeatRRIb(&Riscv64Assembler::Bclri, /*imm_bits=*/6, "bclri {reg1}, {reg2}, {imm}"),
+            "Bclri");
+}
+
+TEST_F(AssemblerRISCV64Test, Bext) {
+  DriverStr(RepeatRRR(&Riscv64Assembler::Bext, "bext {reg1}, {reg2}, {reg3}"), "Bext");
+}
+
+TEST_F(AssemblerRISCV64Test, Bexti) {
+  DriverStr(RepeatRRIb(&Riscv64Assembler::Bexti, /*imm_bits=*/6, "bexti {reg1}, {reg2}, {imm}"),
+            "Bexti");
+}
+
+TEST_F(AssemblerRISCV64Test, Binv) {
+  DriverStr(RepeatRRR(&Riscv64Assembler::Binv, "binv {reg1}, {reg2}, {reg3}"), "Binv");
+}
+
+TEST_F(AssemblerRISCV64Test, Binvi) {
+  DriverStr(RepeatRRIb(&Riscv64Assembler::Binvi, /*imm_bits=*/6, "binvi {reg1}, {reg2}, {imm}"),
+            "Binvi");
+}
+
+TEST_F(AssemblerRISCV64Test, Bset) {
+  DriverStr(RepeatRRR(&Riscv64Assembler::Bset, "bset {reg1}, {reg2}, {reg3}"), "Bset");
+}
+
+TEST_F(AssemblerRISCV64Test, Bseti) {
+  DriverStr(RepeatRRIb(&Riscv64Assembler::Bseti, /*imm_bits=*/6, "bseti {reg1}, {reg2}, {imm}"),
+            "Bseti");
+}
+
 // Vector Instructions
 
 TEST_F(AssemblerRISCV64Test, VSetvl) {
@@ -8517,334 +8701,705 @@ TEST_F(AssemblerRISCV64Test, AddConst64) {
   TestAddConst("AddConst64", /*bits=*/64, /*suffix=*/ "", emit_op);
 }
 
-TEST_F(AssemblerRISCV64Test, BcondForward3KiB) {
+TEST_F(AssemblerRISCV64Test, BcondForward128B) {
+  TestBcondForward("BcondForward128B", 128, "1", GetPrintBcond());
+}
+
+TEST_F(AssemblerRISCV64Test, BcondForward128B_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBcondForward("BcondForward128B_WithoutC", 128, "1", GetPrintBcond());
+}
+
+TEST_F(AssemblerRISCV64Test, BcondForward128BBare) {
+  TestBcondForward("BcondForward128BBare", 128, "1", GetPrintBcond(), /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BcondForward128BBare_WithoutC) {
   ScopedCSuppression scs(this);
+  TestBcondForward(
+      "BcondForward128BBare_WithoutC", 128, "1", GetPrintBcond(), /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward128B) {
+  TestBcondBackward("BcondBackward128B", 128, "1", GetPrintBcond());
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward128B_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBcondBackward("BcondBackward128B_WithoutC", 128, "1", GetPrintBcond());
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward128BBare) {
+  TestBcondBackward("BcondBackward128BBare", 128, "1", GetPrintBcond(), /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward128BBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBcondBackward("BcondBackward128Bare_WithoutC", 128, "1", GetPrintBcond(), /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BcondForward3KiB) {
   TestBcondForward("BcondForward3KiB", 3 * KB, "1", GetPrintBcond());
 }
 
-TEST_F(AssemblerRISCV64Test, BcondForward3KiBBare) {
+TEST_F(AssemblerRISCV64Test, BcondForward3KiB_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondForward("BcondForward3KiB", 3 * KB, "1", GetPrintBcond(), /*is_bare=*/ true);
+  TestBcondForward("BcondForward3KiB_WithoutC", 3 * KB, "1", GetPrintBcond());
 }
 
-TEST_F(AssemblerRISCV64Test, BcondBackward3KiB) {
+TEST_F(AssemblerRISCV64Test, BcondForward3KiBBare_WithoutC) {
   ScopedCSuppression scs(this);
+  TestBcondForward(
+      "BcondForward3KiBBare_WithoutC", 3 * KB, "1", GetPrintBcond(), /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward3KiB) {
   TestBcondBackward("BcondBackward3KiB", 3 * KB, "1", GetPrintBcond());
 }
 
-TEST_F(AssemblerRISCV64Test, BcondBackward3KiBBare) {
+TEST_F(AssemblerRISCV64Test, BcondBackward3KiB_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondBackward("BcondBackward3KiB", 3 * KB, "1", GetPrintBcond(), /*is_bare=*/ true);
+  TestBcondBackward("BcondBackward3KiB_WithoutC", 3 * KB, "1", GetPrintBcond());
 }
 
-TEST_F(AssemblerRISCV64Test, BcondForward5KiB) {
+TEST_F(AssemblerRISCV64Test, BcondBackward3KiBBare_WithoutC) {
   ScopedCSuppression scs(this);
+  TestBcondBackward(
+      "BcondBackward3KiBare_WithoutC", 3 * KB, "1", GetPrintBcond(), /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BcondForward5KiB) {
   TestBcondForward("BcondForward5KiB", 5 * KB, "1", GetPrintBcondOppositeAndJ("2"));
 }
 
-TEST_F(AssemblerRISCV64Test, BcondBackward5KiB) {
+TEST_F(AssemblerRISCV64Test, BcondForward5KiB_WithoutC) {
   ScopedCSuppression scs(this);
+  TestBcondForward("BcondForward5KiB_WithoutC", 5 * KB, "1", GetPrintBcondOppositeAndJ("2"));
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward5KiB) {
   TestBcondBackward("BcondBackward5KiB", 5 * KB, "1", GetPrintBcondOppositeAndJ("2"));
 }
 
-TEST_F(AssemblerRISCV64Test, BcondForward2MiB) {
+TEST_F(AssemblerRISCV64Test, BcondBackward5KiB_WithoutC) {
   ScopedCSuppression scs(this);
+  TestBcondBackward("BcondBackward5KiB_WithoutC", 5 * KB, "1", GetPrintBcondOppositeAndJ("2"));
+}
+
+TEST_F(AssemblerRISCV64Test, BcondForward2MiB) {
   TestBcondForward("BcondForward2MiB", 2 * MB, "1", GetPrintBcondOppositeAndTail("2", "3"));
 }
 
-TEST_F(AssemblerRISCV64Test, BcondBackward2MiB) {
+TEST_F(AssemblerRISCV64Test, BcondForward2MiB_WithoutC) {
   ScopedCSuppression scs(this);
+  TestBcondForward(
+      "BcondForward2MiB_WithoutC", 2 * MB, "1", GetPrintBcondOppositeAndTail("2", "3"));
+}
+
+TEST_F(AssemblerRISCV64Test, BcondBackward2MiB) {
   TestBcondBackward("BcondBackward2MiB", 2 * MB, "1", GetPrintBcondOppositeAndTail("2", "3"));
 }
 
+TEST_F(AssemblerRISCV64Test, BcondBackward2MiB_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBcondBackward(
+      "BcondBackward2MiB_WithoutC", 2 * MB, "1", GetPrintBcondOppositeAndTail("2", "3"));
+}
+
 TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset9Forward) {
-  TestBcondA0RegForward("BeqA0ZeroMaxOffset9Forward",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset9ForwardDistance() - /*C.BEQZ*/ 2u,
-                        "1",
-                        GetPrintBcond(),
-                        Zero);
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset9Forward",
+                    MaxOffset9ForwardDistance() - /*C.BEQZ*/ 2u,
+                    GetPrintCBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset9ForwardBare) {
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset9ForwardBare",
+                    MaxOffset9ForwardDistance() - /*C.BEQZ*/ 2u,
+                    GetPrintCBcond(),
+                    "1",
+                    /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset9Forward) {
+  TestBnezA0Forward("BneA0ZeroMaxOffset9Forward",
+                    MaxOffset9ForwardDistance() - /*C.BNEZ*/ 2u,
+                    GetPrintCBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset9ForwardBare) {
+  TestBnezA0Forward("BneA0ZeroMaxOffset9ForwardBare",
+                    MaxOffset9ForwardDistance() - /*C.BNEZ*/ 2u,
+                    GetPrintCBcond(),
+                    "1",
+                    /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset9Backward) {
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset9Backward",
+                     MaxOffset9BackwardDistance(),
+                     GetPrintCBcond(),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset9BackwardBare) {
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset9BackwardBare",
+                     MaxOffset9BackwardDistance(),
+                     GetPrintCBcond(),
+                     "1",
+                     /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset9Backward) {
+  TestBnezA0Backward("BneA0ZeroMaxOffset9Backward",
+                     MaxOffset9BackwardDistance(),
+                     GetPrintCBcond(),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset9BackwardBare) {
+  TestBnezA0Backward("BneA0ZeroMaxOffset9BackwardBare",
+                     MaxOffset9BackwardDistance(),
+                     GetPrintCBcond(),
+                     "1",
+                     /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset9Forward) {
+  TestBeqzA0Forward("BeqA0ZeroOverMaxOffset9Forward",
+                    MaxOffset9ForwardDistance() - /*C.BEQZ*/ 2u + /*Exceed max*/ 2u,
+                    GetPrintBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset9Forward) {
+  TestBnezA0Forward("BneA0ZeroOverMaxOffset9Forward",
+                    MaxOffset9ForwardDistance() - /*C.BNEZ*/ 2u + /*Exceed max*/ 2u,
+                    GetPrintBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset9Backward) {
+  TestBeqzA0Backward("BeqA0ZeroOverMaxOffset9Backward",
+                       MaxOffset9BackwardDistance() + /*Exceed max*/ 2u,
+                       GetPrintBcond(),
+                       "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset9Backward) {
+  TestBnezA0Backward("BneA0ZeroOverMaxOffset9Backward",
+                     MaxOffset9BackwardDistance() + /*Exceed max*/ 2u,
+                     GetPrintBcond(),
+                     "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13Forward) {
-  TestBcondA0RegForward("BeqA0ZeroMaxOffset13Forward",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset13ForwardDistance() - /*C.BEQZ*/ 2u,
-                        "1",
-                        GetPrintBcond(),
-                        Zero);
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset13Forward",
+                    MaxOffset13ForwardDistance() - /*C.BEQZ*/ 2u,
+                    GetPrintBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset13Forward_WithoutC",
+                    MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u,
+                    GetPrintBcond(),
+                    "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset9ForwardOpposite) {
-  TestBcondA0RegForward("BeqA0ZeroMaxOffset9ForwardOpposite",
-                        &Riscv64Assembler::Bne,
-                        MaxOffset9ForwardDistance() - /*C.BNEZ*/ 2u,
-                        "1",
-                        GetPrintBcondOpposite(),
-                        Zero);
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13ForwardBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset13ForwardBare_WithoutC",
+                    MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u,
+                    GetPrintBcond(),
+                    "1",
+                    /*is_bare=*/ true);
 }
 
 TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset13Forward) {
-  TestBcondA0RegForward("BneA0ZeroMaxOffset13Forward",
-                        &Riscv64Assembler::Bne,
-                        MaxOffset13ForwardDistance() - /*C.BbeZ*/ 2u,
-                        "1",
-                        GetPrintBcondOpposite(),
-                        Zero);
+  TestBnezA0Forward("BneA0ZeroMaxOffset13Forward",
+                    MaxOffset13ForwardDistance() - /*C.BNEZ*/ 2u,
+                    GetPrintBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset13Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Forward("BneA0ZeroMaxOffset13Forward_WithoutC",
+                    MaxOffset13ForwardDistance_WithoutC() - /*BNE*/ 4u,
+                    GetPrintBcond(),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset13ForwardBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Forward("BneA0ZeroMaxOffset13ForwardBare_WithoutC",
+                    MaxOffset13ForwardDistance_WithoutC() - /*BNE*/ 4u,
+                    GetPrintBcond(),
+                    "1",
+                    /*is_bare=*/ true);
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13Forward) {
+  TestBeqA0A1Forward("BeqA0A1MaxOffset13Forward",
+                     MaxOffset13ForwardDistance() - /*BEQ*/ 4u,
+                     GetPrintBcond(),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13Forward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegForward("BeqA0A1MaxOffset13Forward",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u,
-                        "1",
-                        GetPrintBcond(),
-                        A1);
+  TestBeqA0A1Forward("BeqA0A1MaxOffset13Forward_WithoutC",
+                     MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u,
+                     GetPrintBcond(),
+                     "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13ForwardBare) {
-  ScopedCSuppression scs(this);
-  TestBcondA0RegForward("BeqA0A1MaxOffset13ForwardBare",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u,
-                        "1",
-                        GetPrintBcond(),
-                        A1,
-                        /*is_bare=*/true);
+  TestBeqA0A1Forward("BeqA0A1MaxOffset13ForwardBare",
+                     MaxOffset13ForwardDistance() - /*BEQ*/ 4u,
+                     GetPrintBcond(),
+                     "1",
+                     /*is_bare=*/true);
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset9Backward) {
-  TestBcondA0RegBackward("BeqA0ZeroMaxOffset9Backward",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset9BackwardDistance() - /*C.BEQZ*/ 2u,
-                         "1",
-                         GetPrintBcond(),
-                         Zero);
+TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13ForwardBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqA0A1Forward("BeqA0A1MaxOffset13ForwardBare_WithoutC",
+                     MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u,
+                     GetPrintBcond(),
+                     "1",
+                     /*is_bare=*/true);
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13Backward) {
-  TestBcondA0RegBackward("BeqA0ZeroMaxOffset13Backward",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset13ForwardDistance() - /*BEQ*/ 4u,
-                         "1",
-                         GetPrintBcond(),
-                         Zero);
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset13Backward",
+                     MaxOffset13BackwardDistance(),
+                     GetPrintBcond(),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset13Backward_WithoutC",
+                     MaxOffset13BackwardDistance_WithoutC(),
+                     GetPrintBcond(),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13BackwardBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset13BackwardBare_WithoutC",
+                     MaxOffset13BackwardDistance_WithoutC(),
+                     GetPrintBcond(),
+                     "1",
+                     /*is_bare=*/ true);
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset9BackwardOpposite) {
-  TestBcondA0RegBackward("BeqA0ZeroMaxOffset9BackwardOpposite",
-                         &Riscv64Assembler::Bne,
-                         MaxOffset9BackwardDistance() - /*C.BNEZ*/ 2u,
-                         "1",
-                         GetPrintBcondOpposite(),
-                         Zero);
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset13Backward) {
+  TestBnezA0Backward("BneA0ZeroMaxOffset13Backward",
+                     MaxOffset13BackwardDistance(),
+                     GetPrintBcond(),
+                     "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset13BackwardOpposite) {
-  TestBcondA0RegBackward("BeqA0ZeroMaxOffset13BackwardOpposite",
-                         &Riscv64Assembler::Bne,
-                         MaxOffset13ForwardDistance() - /*BNE*/ 4u,
-                         "1",
-                         GetPrintBcondOpposite(),
-                         Zero);
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset13Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Backward("BneA0ZeroMaxOffset13Backward_WithoutC",
+                     MaxOffset13BackwardDistance_WithoutC(),
+                     GetPrintBcond(),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset13BackwardBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Backward("BneA0ZeroMaxOffset13BackwardBare_WithoutC",
+                     MaxOffset13BackwardDistance_WithoutC(),
+                     GetPrintBcond(),
+                     "1",
+                     /*is_bare=*/ true);
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13Backward) {
+  TestBeqA0A1Backward("BeqA0A1MaxOffset13Backward",
+                      MaxOffset13BackwardDistance(),
+                      GetPrintBcond(),
+                      "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13Backward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegBackward("BeqA0A1MaxOffset13Forward_WithoutC",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset13BackwardDistance_WithoutC(),
-                         "1",
-                         GetPrintBcond(),
-                         A1);
+  TestBeqA0A1Backward("BeqA0A1MaxOffset13Backward_WithoutC",
+                      MaxOffset13BackwardDistance_WithoutC(),
+                      GetPrintBcond(),
+                      "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13BackwardBare) {
+  TestBeqA0A1Backward("BeqA0A1MaxOffset13BackwardBare",
+                      MaxOffset13BackwardDistance(),
+                      GetPrintBcond(),
+                      "1",
+                      /*is_bare=*/true);
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset13BackwardBare_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegBackward("BeqA0A1MaxOffset13ForwardBare_WithoutC",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset13BackwardDistance_WithoutC(),
-                         "1",
-                         GetPrintBcond(),
-                         A1,
-                         /*is_bare=*/true);
+  TestBeqA0A1Backward("BeqA0A1MaxOffset13BackwardBare_WithoutC",
+                      MaxOffset13BackwardDistance_WithoutC(),
+                      GetPrintBcond(),
+                      "1",
+                      /*is_bare=*/true);
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset9Forward) {
-  TestBcondA0RegForward("BeqA0ZeroOverMaxOffset9Forward",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset9ForwardDistance() - /*C.BEQZ*/ 2u + /*Exceed max*/ 2u,
-                        "1",
-                        GetPrintBcond(),
-                        Zero);
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset13Forward) {
+  TestBeqzA0Forward("BeqA0ZeroOverMaxOffset13Forward",
+                    MaxOffset13ForwardDistance() - /*BEQ*/ 4u + /*Exceed max*/ 2u,
+                    GetPrintCBcondOppositeAndJ("2"),
+                    "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset9Backward) {
-  TestBcondA0RegBackward("BeqA0ZeroOverMaxOffset9Backward",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset9BackwardDistance() - /*C.BEQZ*/ 2u + /*Exceed max*/ 2u,
-                         "1",
-                         GetPrintBcond(),
-                         Zero);
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset13Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Forward("BeqA0ZeroOverMaxOffset13Forward_WithoutC",
+                    MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u + /*Exceed max*/ 4u,
+                    GetPrintBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset13Forward) {
+  TestBnezA0Forward("BneA0ZeroOverMaxOffset13Forward",
+                    MaxOffset13ForwardDistance() - /*BNE*/ 4u + /*Exceed max*/ 2u,
+                    GetPrintCBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset13Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Forward("BneA0ZeroOverMaxOffset13Forward_WithoutC",
+                    MaxOffset13ForwardDistance_WithoutC() - /*BNE*/ 4u + /*Exceed max*/ 4u,
+                    GetPrintBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset13Forward) {
+  TestBeqA0A1Forward("BeqA0A1OverMaxOffset13Forward",
+                     MaxOffset13ForwardDistance() - /*BEQ*/ 4u + /*Exceed max*/ 2u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset13Forward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegForward("BeqA0A1OverMaxOffset13Forward_WithoutC",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u + /*Exceed max*/ 4u,
-                        "1",
-                        GetPrintBcondOppositeAndJ("2"),
-                        A1);
+  TestBeqA0A1Forward("BeqA0A1OverMaxOffset13Forward_WithoutC",
+                     MaxOffset13ForwardDistance_WithoutC() - /*BEQ*/ 4u + /*Exceed max*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset13Backward) {
+  TestBeqzA0Backward("BeqA0ZeroOverMaxOffset13Backward",
+                     MaxOffset13BackwardDistance() + /*Exceed max*/ 2u,
+                     GetPrintCBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset13Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Backward("BeqA0ZeroOverMaxOffset13Backward_WithoutC",
+                     MaxOffset13BackwardDistance_WithoutC() + /*Exceed max*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset13Backward) {
+  TestBnezA0Backward("BneA0ZeroOverMaxOffset13Backward",
+                     MaxOffset13BackwardDistance() + /*Exceed max*/ 2u,
+                     GetPrintCBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset13Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Backward("BneA0ZeroOverMaxOffset13Backward_WithoutC",
+                     MaxOffset13BackwardDistance_WithoutC() + /*Exceed max*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset13Backward) {
+  TestBeqA0A1Backward("BeqA0A1OverMaxOffset13Backward",
+                      MaxOffset13BackwardDistance() + /*Exceed max*/ 2u,
+                      GetPrintBcondOppositeAndJ("2"),
+                      "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset13Backward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegBackward("BeqA0A1OverMaxOffset13Forward_WithoutC",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset13BackwardDistance_WithoutC() + /*Exceed max*/ 4u,
-                         "1",
-                         GetPrintBcondOppositeAndJ("2"),
-                         A1);
+  TestBeqA0A1Backward("BeqA0A1OverMaxOffset13Backward_WithoutC",
+                      MaxOffset13BackwardDistance_WithoutC() + /*Exceed max*/ 4u,
+                      GetPrintBcondOppositeAndJ("2"),
+                      "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21Forward) {
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset21Forward",
+                    MaxOffset21ForwardDistance() - /*J*/ 4u,
+                    GetPrintCBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Forward("BeqA0ZeroMaxOffset21Forward_WithoutC",
+                    MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u,
+                    GetPrintBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset21Forward) {
+  TestBnezA0Forward("BneA0ZeroMaxOffset21Forward",
+                    MaxOffset21ForwardDistance() - /*J*/ 4u,
+                    GetPrintCBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset21Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Forward("BneA0ZeroMaxOffset21Forward_WithoutC",
+                    MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u,
+                    GetPrintBcondOppositeAndJ("2"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset21Forward) {
+  TestBeqA0A1Forward("BeqA0A1MaxOffset21Forward",
+                     MaxOffset21ForwardDistance() - /*J*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset21Forward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegForward("BeqA0A1MaxOffset21Forward_WithoutC",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u,
-                        "1",
-                        GetPrintBcondOppositeAndJ("2"),
-                        A1);
+  TestBeqA0A1Forward("BeqA0A1MaxOffset21Forward_WithoutC",
+                     MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21Backward) {
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset21Backward",
+                     MaxOffset21BackwardDistance() - /*C.BNEZ*/ 2u,
+                     GetPrintCBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Backward("BeqA0ZeroMaxOffset21Backward_WithoutC",
+                     MaxOffset21BackwardDistance_WithoutC() - /*BNE*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset21Backward) {
+  TestBnezA0Backward("BneA0ZeroMaxOffset21Backward",
+                     MaxOffset21BackwardDistance() - /*C.BEQZ*/ 2u,
+                     GetPrintCBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroMaxOffset21Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Backward("BneA0ZeroMaxOffset21Backward_WithoutC",
+                     MaxOffset21BackwardDistance_WithoutC() - /*BEQ*/ 4u,
+                     GetPrintBcondOppositeAndJ("2"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset21Backward) {
+  TestBeqA0A1Backward("BeqA0A1MaxOffset21Backward",
+                      MaxOffset21BackwardDistance() - /*BNE*/ 4u,
+                      GetPrintBcondOppositeAndJ("2"),
+                      "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1MaxOffset21Backward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegBackward("BeqA0A1MaxOffset21Backward_WithoutC",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset21BackwardDistance_WithoutC() - /*BNE*/ 4u,
-                         "1",
-                         GetPrintBcondOppositeAndJ("2"),
-                         A1);
+  TestBeqA0A1Backward("BeqA0A1MaxOffset21Backward_WithoutC",
+                      MaxOffset21BackwardDistance_WithoutC() - /*BNE*/ 4u,
+                      GetPrintBcondOppositeAndJ("2"),
+                      "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21Backward) {
-  TestBcondA0RegBackward("BeqA0ZeroMaxOffset21Backward",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset21BackwardDistance() - /*BNE*/ 4u,
-                         "1",
-                         GetPrintBcondOppositeAndJ("2"),
-                         Zero);
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset21Forward) {
+  TestBeqzA0Forward("BeqA0ZeroOverMaxOffset21Forward",
+                    MaxOffset21ForwardDistance() - /*J*/ 4u + /*Exceed max*/ 2u,
+                    GetPrintBcondOppositeAndTail("2", "3"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset21Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqzA0Forward("BeqA0ZeroOverMaxOffset21Forward_WithoutC",
+                    MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u + /*Exceed max*/ 4u,
+                    GetPrintBcondOppositeAndTail("2", "3"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset21Forward) {
+  TestBnezA0Forward("BneA0ZeroOverMaxOffset21Forward",
+                    MaxOffset21ForwardDistance() - /*J*/ 4u + /*Exceed max*/ 2u,
+                    GetPrintBcondOppositeAndTail("2", "3"),
+                    "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21BackwardNe) {
-  TestBcondA0RegBackward("BeqA0ZeroMaxOffset21BackwardNe",
-                         &Riscv64Assembler::Bne,
-                         MaxOffset21BackwardDistance() - /*BNE*/ 4u,
-                         "1",
-                         GetPrintBcondAndJ("2"),
-                         Zero);
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset21Forward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Forward("BneA0ZeroOverMaxOffset21Forward_WithoutC",
+                    MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u + /*Exceed max*/ 4u,
+                    GetPrintBcondOppositeAndTail("2", "3"),
+                    "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset21Forward) {
+  TestBeqA0A1Forward("BeqA0A1OverMaxOffset21Forward",
+                     MaxOffset21ForwardDistance() - /*J*/ 4u + /*Exceed max*/ 2u,
+                     GetPrintBcondOppositeAndTail("2", "3"),
+                     "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset21Forward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegForward("BeqA0A1OverMaxOffset21Forward_WithoutC",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u + /*Exceed max*/ 4u,
-                        "1",
-                        GetPrintBcondOppositeAndTail("2", "3"),
-                        A1);
+  TestBeqA0A1Forward("BeqA0A1OverMaxOffset21Forward_WithoutC",
+                     MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u + /*Exceed max*/ 4u,
+                     GetPrintBcondOppositeAndTail("2", "3"),
+                     "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset21Backward_WithoutC) {
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset21Backward) {
+  TestBeqzA0Backward("BeqA0ZeroOverMaxOffset21Backward",
+                     MaxOffset21BackwardDistance() - /*C.BNEZ*/ 2u + /*Exceed max*/ 2u,
+                     GetPrintBcondOppositeAndTail("2", "3"),
+                     "1");
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0ZeroOverMaxOffset21Backward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBcondA0RegBackward("BeqA0A1OverMaxOffset21Backward_WithoutC",
-                         &Riscv64Assembler::Beq,
-                         MaxOffset21BackwardDistance_WithoutC() - /*BNE*/ 4u + /*Exceed max*/ 4u,
-                         "1",
-                         GetPrintBcondOppositeAndTail("2", "3"),
-                         A1);
+  TestBeqzA0Backward("BeqA0ZeroOverMaxOffset21Backward_WithoutC",
+                     MaxOffset21BackwardDistance_WithoutC() - /*BNE*/ 4u + /*Exceed max*/ 4u,
+                     GetPrintBcondOppositeAndTail("2", "3"),
+                     "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21Forward) {
-  TestBcondA0RegForward("BeqA0ZeroMaxOffset21Forward",
-                        &Riscv64Assembler::Beq,
-                        MaxOffset21ForwardDistance() - /*J*/ 4u,
-                        "1",
-                        GetPrintBcondOppositeAndJ("2"),
-                        Zero);
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset21Backward) {
+  TestBnezA0Backward("BneA0ZeroOverMaxOffset21Backward",
+                     MaxOffset21BackwardDistance() - /*C.BEQZ*/ 2u + /*Exceed max*/ 2u,
+                     GetPrintBcondOppositeAndTail("2", "3"),
+                     "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21ForwardNe) {
-  TestBcondA0RegForward("BeqA0ZeroMaxOffset21ForwardNe",
-                        &Riscv64Assembler::Bne,
-                        MaxOffset21ForwardDistance() - /*J*/ 4u,
-                        "1",
-                        GetPrintBcondAndJ("2"),
-                        Zero);
+TEST_F(AssemblerRISCV64Test, BneA0ZeroOverMaxOffset21Backward_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBnezA0Backward("BneA0ZeroOverMaxOffset21Backward_WithoutC",
+                     MaxOffset21BackwardDistance_WithoutC() - /*BEQ*/ 4u + /*Exceed max*/ 4u,
+                     GetPrintBcondOppositeAndTail("2", "3"),
+                     "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0ZeroMaxOffset21ForwardNeNotCompressable) {
-  TestBcondA0RegForward("BeqA0ZeroMaxOffset21ForwardNeNotCompressable",
-                        &Riscv64Assembler::Bne,
-                        MaxOffset21ForwardDistance() - /*BNE*/ 50u,
-                        "1",
-                        GetPrintBcondAndJ("2"),
-                        A2);
+TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset21Backward) {
+  TestBeqA0A1Backward("BeqA0A1OverMaxOffset21Backward",
+                      MaxOffset21BackwardDistance() - /*BNE*/ 4u + /*Exceed max*/ 2u,
+                      GetPrintBcondOppositeAndTail("2", "3"),
+                      "1");
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0A1AlmostCascade_WithoutC) {
+TEST_F(AssemblerRISCV64Test, BeqA0A1OverMaxOffset21Backward_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBeqA0A1MaybeCascade("BeqA0A1AlmostCascade_WithoutC", /*cascade=*/false, GetPrintBcond());
+  TestBeqA0A1Backward("BeqA0A1OverMaxOffset21Backward_WithoutC",
+                      MaxOffset21BackwardDistance_WithoutC() - /*BNE*/ 4u + /*Exceed max*/ 4u,
+                      GetPrintBcondOppositeAndTail("2", "3"),
+                      "1");
 }
 
 TEST_F(AssemblerRISCV64Test, BeqA0A1AlmostCascade) {
   TestBeqA0A1MaybeCascade("BeqA0A1AlmostCascade", /*cascade=*/false, GetPrintBcond());
 }
 
+TEST_F(AssemblerRISCV64Test, BeqA0A1AlmostCascade_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBeqA0A1MaybeCascade("BeqA0A1AlmostCascade_WithoutC", /*cascade=*/false, GetPrintBcond());
+}
+
+TEST_F(AssemblerRISCV64Test, BeqA0A1Cascade) {
+  TestBeqA0A1MaybeCascade("BeqA0A1Cascade", /*cascade=*/true, GetPrintBcondOppositeAndJ("1"));
+}
+
 TEST_F(AssemblerRISCV64Test, BeqA0A1Cascade_WithoutC) {
   ScopedCSuppression scs(this);
   TestBeqA0A1MaybeCascade(
-      "BeqA0A1AlmostCascade_WithoutC", /*cascade=*/true, GetPrintBcondOppositeAndJ("1"));
+      "BeqA0A1Cascade_WithoutC", /*cascade=*/true, GetPrintBcondOppositeAndJ("1"));
 }
 
-TEST_F(AssemblerRISCV64Test, BeqA0A1Cascade) {
-  TestBeqA0A1MaybeCascade("BeqA0A1AlmostCascade", /*cascade=*/true, GetPrintBcondOppositeAndJ("1"));
+TEST_F(AssemblerRISCV64Test, BcondElimination) {
+  TestBcondElimination("BcondElimination", "c.nop");
 }
 
 TEST_F(AssemblerRISCV64Test, BcondElimination_WithoutC) {
   ScopedCSuppression scs(this);
-  Riscv64Label label;
-  __ Bind(&label);
-  __ Nop();
-  for (XRegister reg : GetRegisters()) {
-    __ Bne(reg, reg, &label);
-    __ Blt(reg, reg, &label);
-    __ Bgt(reg, reg, &label);
-    __ Bltu(reg, reg, &label);
-    __ Bgtu(reg, reg, &label);
-  }
-  DriverStr("nop\n", "BcondElimination_WithoutC");
+  TestBcondElimination("BcondElimination_WithoutC", "nop");
+}
+
+TEST_F(AssemblerRISCV64Test, BcondUnconditional) {
+  TestBcondUnconditional("BcondUnconditional", "c.j");
 }
 
 TEST_F(AssemblerRISCV64Test, BcondUnconditional_WithoutC) {
   ScopedCSuppression scs(this);
-  Riscv64Label label;
-  __ Bind(&label);
-  __ Nop();
-  for (XRegister reg : GetRegisters()) {
-    __ Beq(reg, reg, &label);
-    __ Bge(reg, reg, &label);
-    __ Ble(reg, reg, &label);
-    __ Bleu(reg, reg, &label);
-    __ Bgeu(reg, reg, &label);
-  }
-  std::string expected =
-      "1:\n"
-      "nop\n" +
-      RepeatInsn(5u * GetRegisters().size(), "j 1b\n", []() {});
-  DriverStr(expected, "BcondUnconditional_WithoutC");
+  TestBcondUnconditional("BcondUnconditional_WithoutC", "j");
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdForward1KiB) {
+  TestJalRdForward("JalRdForward1KiB", 1 * KB, "1", GetPrintJalRd());
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdForward1KiB_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestJalRdForward("JalRdForward1KiB_WithoutC", 1 * KB, "1", GetPrintJalRd());
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdForward1KiBBare) {
+  TestJalRdForward("JalRdForward1KiBBare", 1 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdForward1KiBBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestJalRdForward("JalRdForward1KiBBare_WithoutC", 1 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdBackward1KiB) {
+  TestJalRdBackward("JalRdBackward1KiB", 1 * KB, "1", GetPrintJalRd());
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdBackward1KiB_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestJalRdBackward("JalRdBackward1KiB_WithoutC", 1 * KB, "1", GetPrintJalRd());
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdBackward1KiBBare) {
+  TestJalRdBackward("JalRdBackward1KiBBare", 1 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdBackward1KiBBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestJalRdBackward(
+      "JalRdBackward1KiBBare_WithoutC", 1 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdForward3KiB) {
+  TestJalRdForward("JalRdForward3KiB", 3 * KB, "1", GetPrintJalRd());
 }
 
 TEST_F(AssemblerRISCV64Test, JalRdForward3KiB_WithoutC) {
@@ -8854,7 +9409,11 @@ TEST_F(AssemblerRISCV64Test, JalRdForward3KiB_WithoutC) {
 
 TEST_F(AssemblerRISCV64Test, JalRdForward3KiBBare_WithoutC) {
   ScopedCSuppression scs(this);
-  TestJalRdForward("JalRdForward3KiB_WithoutC", 3 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+  TestJalRdForward("JalRdForward3KiBBare_WithoutC", 3 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdBackward3KiB) {
+  TestJalRdBackward("JalRdBackward3KiB", 3 * KB, "1", GetPrintJalRd());
 }
 
 TEST_F(AssemblerRISCV64Test, JalRdBackward3KiB_WithoutC) {
@@ -8864,7 +9423,12 @@ TEST_F(AssemblerRISCV64Test, JalRdBackward3KiB_WithoutC) {
 
 TEST_F(AssemblerRISCV64Test, JalRdBackward3KiBBare_WithoutC) {
   ScopedCSuppression scs(this);
-  TestJalRdBackward("JalRdBackward3KiB_WithoutC", 3 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+  TestJalRdBackward(
+      "JalRdBackward3KiBBare_WithoutC", 3 * KB, "1", GetPrintJalRd(), /*is_bare=*/true);
+}
+
+TEST_F(AssemblerRISCV64Test, JalRdForward2MiB) {
+  TestJalRdForward("JalRdForward2MiB", 2 * MB, "1", GetPrintCallRd("2"));
 }
 
 TEST_F(AssemblerRISCV64Test, JalRdForward2MiB_WithoutC) {
@@ -8872,54 +9436,85 @@ TEST_F(AssemblerRISCV64Test, JalRdForward2MiB_WithoutC) {
   TestJalRdForward("JalRdForward2MiB_WithoutC", 2 * MB, "1", GetPrintCallRd("2"));
 }
 
+TEST_F(AssemblerRISCV64Test, JalRdBackward2MiB) {
+  TestJalRdBackward("JalRdBackward2MiB", 2 * MB, "1", GetPrintCallRd("2"));
+}
+
 TEST_F(AssemblerRISCV64Test, JalRdBackward2MiB_WithoutC) {
   ScopedCSuppression scs(this);
   TestJalRdBackward("JalRdBackward2MiB_WithoutC", 2 * MB, "1", GetPrintCallRd("2"));
 }
 
-TEST_F(AssemblerRISCV64Test, JForward3KiB_WithoutC) {
+TEST_F(AssemblerRISCV64Test, JForward1KiB) {
+  TestBuncondForward("JForward1KiB", 1 * KB, "1", GetEmitJ(), GetPrintCJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JForward1KiB_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBuncondForward("JForward3KiB_WithoutC", 3 * KB, "1", GetEmitJ(), GetPrintJ());
+  TestBuncondForward("JForward1KiB_WithoutC", 1 * KB, "1", GetEmitJ(), GetPrintJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JForward3KiBWithCompression) {
-  TestBuncondForward("JForward3KiBWithCompression", 3 * KB, "1", GetEmitJ(), GetPrintJ());
+TEST_F(AssemblerRISCV64Test, JForward1KiBBare) {
+  TestBuncondForward("JForward1KiBBare", 1 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintCJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JForward2KiB) {
-  TestBuncondForward("JForward2KiB", 2 * KB - 4, "1", GetEmitJ(), GetPrintJ());
+TEST_F(AssemblerRISCV64Test, JForward1KiBBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBuncondForward(
+      "JForward1KiBBare_WithoutC", 1 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JForward3KiBBare_WithoutC) {
+TEST_F(AssemblerRISCV64Test, JBackward1KiB) {
+  TestBuncondBackward("JBackward1KiB", 1 * KB, "1", GetEmitJ(), GetPrintCJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JBackward1KiB_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBuncondForward("JForward3KiB_WithoutC", 3 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
+  TestBuncondBackward("JBackward1KiB_WithoutC", 1 * KB, "1", GetEmitJ(), GetPrintJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JForward2KiBBare) {
-  TestBuncondForward("JForward2KiBBare", 2 * KB - 4, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
+TEST_F(AssemblerRISCV64Test, JBackward1KiBBare) {
+  TestBuncondBackward("JBackward1KiBBare", 1 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintCJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JBackward3KiB_WithoutC) {
+TEST_F(AssemblerRISCV64Test, JBackward1KiBBare_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBuncondBackward("JBackward3KiB_WithoutC", 3 * KB, "1", GetEmitJ(), GetPrintJ());
+  TestBuncondBackward(
+      "JBackward1KiBBare_WithoutC", 1 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JForward3KiB) {
+  TestBuncondForward("JForward3KiB", 3 * KB, "1", GetEmitJ(), GetPrintJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JForward3KiB_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBuncondForward("JForward3KiB_WithoutC", 3 * KB, "1", GetEmitJ(), GetPrintJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JForward3KiBBare_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBuncondForward(
+      "JForward3KiBBare_WithoutC", 3 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JBackward3KiBWithCompression) {
-  TestBuncondBackward("JBackward3KiBWithCompression", 3 * KB, "1", GetEmitJ(), GetPrintJ());
+TEST_F(AssemblerRISCV64Test, JBackward3KiB) {
+  TestBuncondBackward("JBackward3KiB", 3 * KB, "1", GetEmitJ(), GetPrintJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JBackward2KiB) {
-  TestBuncondBackward("JBackward2KiB", 2 * KB, "1", GetEmitJ(), GetPrintJ());
+TEST_F(AssemblerRISCV64Test, JBackward3KiB_WithoutC) {
+  ScopedCSuppression scs(this);
+  TestBuncondBackward("JBackward3KiB_WithoutC", 3 * KB, "1", GetEmitJ(), GetPrintJ());
 }
 
 TEST_F(AssemblerRISCV64Test, JBackward3KiBBare_WithoutC) {
   ScopedCSuppression scs(this);
   TestBuncondBackward(
-      "JBackward3KiB_WithoutC", 3 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
+      "JBackward3KiBBare_WithoutC", 3 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
 }
 
-TEST_F(AssemblerRISCV64Test, JBackward2KiBBare) {
-  TestBuncondBackward("JBackward2KiBBare", 2 * KB, "1", GetEmitJ(/*is_bare=*/true), GetPrintJ());
+TEST_F(AssemblerRISCV64Test, JForward2MiB) {
+  TestBuncondForward("JForward2MiB", 2 * MB, "1", GetEmitJ(), GetPrintTail("2"));
 }
 
 TEST_F(AssemblerRISCV64Test, JForward2MiB_WithoutC) {
@@ -8927,11 +9522,71 @@ TEST_F(AssemblerRISCV64Test, JForward2MiB_WithoutC) {
   TestBuncondForward("JForward2MiB_WithoutC", 2 * MB, "1", GetEmitJ(), GetPrintTail("2"));
 }
 
+TEST_F(AssemblerRISCV64Test, JBackward2MiB) {
+  TestBuncondBackward("JBackward2MiB", 2 * MB, "1", GetEmitJ(), GetPrintTail("2"));
+}
+
 TEST_F(AssemblerRISCV64Test, JBackward2MiB_WithoutC) {
   ScopedCSuppression scs(this);
   TestBuncondBackward("JBackward2MiB_WithoutC", 2 * MB, "1", GetEmitJ(), GetPrintTail("2"));
 }
 
+TEST_F(AssemblerRISCV64Test, JMaxOffset12Forward) {
+  TestBuncondForward("JMaxOffset12Forward",
+                     MaxOffset12ForwardDistance() - /*C.J*/ 2u,
+                     "1",
+                     GetEmitJ(),
+                     GetPrintCJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JMaxOffset12ForwardBare) {
+  TestBuncondForward("JMaxOffset12ForwardBare",
+                     MaxOffset12ForwardDistance() - /*C.J*/ 2u,
+                     "1",
+                     GetEmitJ(/*is_bare=*/true),
+                     GetPrintCJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JMaxOffset12Backward) {
+  TestBuncondBackward("JMaxOffset12Backward",
+                      MaxOffset12BackwardDistance(),
+                      "1",
+                      GetEmitJ(),
+                      GetPrintCJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JMaxOffset12BackwardBare) {
+  TestBuncondBackward("JMaxOffset12BackwardBare",
+                      MaxOffset12BackwardDistance(),
+                      "1",
+                      GetEmitJ(/*is_bare=*/true),
+                      GetPrintCJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JOverMaxOffset12Forward) {
+  TestBuncondForward("JOverMaxOffset12Forward",
+                     MaxOffset12ForwardDistance() - /*C.J*/ 2u + /*Exceed max*/ 2u,
+                     "1",
+                     GetEmitJ(),
+                     GetPrintJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JOverMaxOffset12Backward) {
+  TestBuncondBackward("JMaxOffset12Backward",
+                      MaxOffset12BackwardDistance() + /*Exceed max*/ 2u,
+                      "1",
+                      GetEmitJ(),
+                      GetPrintJ());
+}
+
+TEST_F(AssemblerRISCV64Test, JMaxOffset21Forward) {
+  TestBuncondForward("JMaxOffset21Forward",
+                     MaxOffset21ForwardDistance() - /*J*/ 4u,
+                     "1",
+                     GetEmitJ(),
+                     GetPrintJ());
+}
+
 TEST_F(AssemblerRISCV64Test, JMaxOffset21Forward_WithoutC) {
   ScopedCSuppression scs(this);
   TestBuncondForward("JMaxOffset21Forward_WithoutC",
@@ -8943,13 +9598,21 @@ TEST_F(AssemblerRISCV64Test, JMaxOffset21Forward_WithoutC) {
 
 TEST_F(AssemblerRISCV64Test, JMaxOffset21ForwardBare_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBuncondForward("JMaxOffset21Forward_WithoutC",
+  TestBuncondForward("JMaxOffset21ForwardBare_WithoutC",
                      MaxOffset21ForwardDistance_WithoutC() - /*J*/ 4u,
                      "1",
                      GetEmitJ(/*is_bare=*/true),
                      GetPrintJ());
 }
 
+TEST_F(AssemblerRISCV64Test, JMaxOffset21Backward) {
+  TestBuncondBackward("JMaxOffset21Backward",
+                      MaxOffset21BackwardDistance(),
+                      "1",
+                      GetEmitJ(),
+                      GetPrintJ());
+}
+
 TEST_F(AssemblerRISCV64Test, JMaxOffset21Backward_WithoutC) {
   ScopedCSuppression scs(this);
   TestBuncondBackward("JMaxOffset21Backward_WithoutC",
@@ -8961,13 +9624,21 @@ TEST_F(AssemblerRISCV64Test, JMaxOffset21Backward_WithoutC) {
 
 TEST_F(AssemblerRISCV64Test, JMaxOffset21BackwardBare_WithoutC) {
   ScopedCSuppression scs(this);
-  TestBuncondBackward("JMaxOffset21Backward_WithoutC",
+  TestBuncondBackward("JMaxOffset21BackwardBare_WithoutC",
                       MaxOffset21BackwardDistance_WithoutC(),
                       "1",
                       GetEmitJ(/*is_bare=*/true),
                       GetPrintJ());
 }
 
+TEST_F(AssemblerRISCV64Test, JOverMaxOffset21Forward) {
+  TestBuncondForward("JOverMaxOffset21Forward",
+                     MaxOffset21ForwardDistance() - /*J*/ 4u + /*Exceed max*/ 2u,
+                     "1",
+                     GetEmitJ(),
+                     GetPrintTail("2"));
+}
+
 TEST_F(AssemblerRISCV64Test, JOverMaxOffset21Forward_WithoutC) {
   ScopedCSuppression scs(this);
   TestBuncondForward("JOverMaxOffset21Forward_WithoutC",
@@ -8977,6 +9648,14 @@ TEST_F(AssemblerRISCV64Test, JOverMaxOffset21Forward_WithoutC) {
                      GetPrintTail("2"));
 }
 
+TEST_F(AssemblerRISCV64Test, JOverMaxOffset21Backward) {
+  TestBuncondBackward("JMaxOffset21Backward",
+                      MaxOffset21BackwardDistance() + /*Exceed max*/ 2u,
+                      "1",
+                      GetEmitJ(),
+                      GetPrintTail("2"));
+}
+
 TEST_F(AssemblerRISCV64Test, JOverMaxOffset21Backward_WithoutC) {
   ScopedCSuppression scs(this);
   TestBuncondBackward("JMaxOffset21Backward_WithoutC",
diff --git a/dex2oat/Android.bp b/dex2oat/Android.bp
index 9e1f21c930..ab68831890 100644
--- a/dex2oat/Android.bp
+++ b/dex2oat/Android.bp
@@ -29,11 +29,13 @@ art_cc_defaults {
     defaults: ["art_defaults"],
     host_supported: true,
     srcs: [
+        "aot_class_linker.cc",
         "dex/quick_compiler_callbacks.cc",
         "dex/verification_results.cc",
         "driver/compiled_method.cc",
         "driver/compiled_method_storage.cc",
         "driver/compiler_driver.cc",
+        "interpreter/interpreter_switch_impl1.cc",
         "linker/code_info_table_deduper.cc",
         "linker/elf_writer.cc",
         "linker/elf_writer_quick.cc",
@@ -41,6 +43,8 @@ art_cc_defaults {
         "linker/multi_oat_relative_patcher.cc",
         "linker/oat_writer.cc",
         "linker/relative_patcher.cc",
+        "sdk_checker.cc",
+        "transaction.cc",
         "utils/swap_space.cc",
     ],
 
@@ -87,25 +91,29 @@ art_cc_defaults {
     export_include_dirs: ["."],
 }
 
+gensrcs {
+    name: "art_dex2oat_operator_srcs",
+    cmd: "$(location generate_operator_out) art/dex2oat $(in) > $(out)",
+    tools: ["generate_operator_out"],
+    srcs: [
+        "linker/image_writer.h",
+    ],
+    output_extension: "operator_out.cc",
+}
+
 cc_defaults {
     name: "libart-dex2oat_static_base_defaults",
     whole_static_libs: [
         "libbase",
-        "libcrypto_for_art",
         "liblog",
         "liblz4",
         "libz",
     ],
-}
-
-gensrcs {
-    name: "art_dex2oat_operator_srcs",
-    cmd: "$(location generate_operator_out) art/dex2oat $(in) > $(out)",
-    tools: ["generate_operator_out"],
-    srcs: [
-        "linker/image_writer.h",
+    static_libs: [
+        // Cannot use whole_static_libs for libcrypto_for_art since it's a
+        // subset that contains unused functions that depend on missing symbols.
+        "libcrypto_for_art",
     ],
-    output_extension: "operator_out.cc",
 }
 
 art_cc_library_static {
@@ -265,9 +273,16 @@ art_cc_binary {
             },
         },
         host: {
-            // Make the host binary static, except for system libraries. This
-            // avoids having to bundle host dynamic libs in prebuilts.
-            static_libs: ["libdex2oat_static"],
+            static_libs: [
+                // Since libcrypto_for_art cannot be a whole_static_libs in
+                // libart-dex2oat_static_base_defaults, and we cannot use a
+                // defaults directly only for host here, we have to repeat this
+                // dependency.
+                "libcrypto_for_art",
+                // Make the host binary static, except for system libraries.
+                // This avoids having to bundle host dynamic libs in prebuilts.
+                "libdex2oat_static",
+            ],
             stl: "c++_static",
             // Override the prefer32 added by art_cc_binary when
             // HOST_PREFER_32_BIT is in use. Necessary because the logic in
@@ -321,17 +336,12 @@ art_cc_binary {
             ],
         },
         host: {
-            // Make the host binary static, except for system libraries. This
-            // avoids having to bundle host dynamic libs in prebuilts.
-            static_libs: ["libdex2oatd_static"],
+            // Comments for host in dex2oat apply here too.
+            static_libs: [
+                "libcrypto_for_art",
+                "libdex2oatd_static",
+            ],
             stl: "c++_static",
-            // Override the prefer32 added by art_cc_binary when
-            // HOST_PREFER_32_BIT is in use. Necessary because the logic in
-            // Soong for setting ctx.Config().BuildOSTarget (used in
-            // dexpreopt.RegisterToolDeps) doesn't take host prefer32 into
-            // account. Note that this override cannot be in cc_defaults because
-            // it'd get overridden by the load hook even when it uses
-            // PrependProperties.
             compile_multilib: "64",
         },
     },
@@ -366,7 +376,11 @@ cc_defaults {
 art_cc_binary {
     name: "dex2oats",
     defaults: ["dex2oats-defaults"],
-    static_libs: ["libdex2oat_static"],
+    static_libs: [
+        "libcrypto_for_art",
+        "libdex2oat_static",
+    ],
+    visibility: ["//tools/vendor/google_prebuilts/arc"],
 }
 
 art_cc_binary {
@@ -375,7 +389,10 @@ art_cc_binary {
         "art_debug_defaults",
         "dex2oats-defaults",
     ],
-    static_libs: ["libdex2oatd_static"],
+    static_libs: [
+        "libcrypto_for_art",
+        "libdex2oatd_static",
+    ],
 }
 
 art_cc_library_static {
@@ -383,6 +400,7 @@ art_cc_library_static {
     defaults: ["libart-gtest-defaults"],
     srcs: [
         "common_compiler_driver_test.cc",
+        "common_transaction_test.cc",
     ],
     static_libs: [
         "libart-dex2oat",
@@ -398,6 +416,7 @@ art_cc_library_static {
     ],
     srcs: [
         "common_compiler_driver_test.cc",
+        "common_transaction_test.cc",
     ],
     static_libs: [
         "libartd-dex2oat",
@@ -432,12 +451,14 @@ art_cc_defaults {
         ":art-gtest-jars-Statics",
         ":art-gtest-jars-StringLiterals",
         ":art-gtest-jars-SuperWithAccessChecks",
+        ":art-gtest-jars-Transaction",
         ":art-gtest-jars-VerifierDeps",
         ":art-gtest-jars-VerifierDepsMulti",
         ":art-gtest-jars-VerifySoftFailDuringClinit",
     ],
     tidy_timeout_srcs: [
         "dex2oat_test.cc",
+        "transaction_test.cc",
         "verifier_deps_test.cc",
         "linker/arm/relative_patcher_thumb2_test.cc",
         "linker/arm64/relative_patcher_arm64_test.cc",
@@ -448,6 +469,7 @@ art_cc_defaults {
         "dex2oat_image_test.cc",
         "driver/compiled_method_storage_test.cc",
         "driver/compiler_driver_test.cc",
+        "interpreter/unstarted_runtime_transaction_test.cc",
         "linker/code_info_table_deduper_test.cc",
         "linker/elf_writer_test.cc",
         "linker/image_test.cc",
@@ -455,6 +477,7 @@ art_cc_defaults {
         "linker/index_bss_mapping_encoder_test.cc",
         "linker/multi_oat_relative_patcher_test.cc",
         "linker/oat_writer_test.cc",
+        "transaction_test.cc",
         "verifier_deps_test.cc",
         "utils/swap_space_test.cc",
     ],
@@ -497,6 +520,7 @@ art_cc_defaults {
     ],
     static_libs: [
         "libcrypto_for_art",
+        "libgmock",
         "liblz4", // libart(d)-dex2oat dependency; must be repeated here since it's a static lib.
     ],
 }
@@ -532,23 +556,19 @@ art_cc_test {
     test_config: "art_standalone_dex2oat_tests.xml",
 }
 
-// Counterpart to art_standalone_dex2oat_tests for tests that go into CTS.
+// Counterpart to art_standalone_dex2oat_tests for tests that go into CTS/MCTS.
 art_cc_test {
     name: "art_standalone_dex2oat_cts_tests",
     defaults: ["art_standalone_gtest_defaults"],
     srcs: ["dex2oat_cts_test.cc"],
     data: [
         ":art-gtest-jars-Main",
-        ":art-gtest-jars-MainStripped",
-        ":art-gtest-jars-MultiDex",
-        ":art-gtest-jars-MultiDexModifiedSecondary",
-        ":art-gtest-jars-MultiDexUncompressedAligned",
-        ":art-gtest-jars-Nested",
         ":generate-boot-image",
     ],
     test_config: "art_standalone_dex2oat_cts_tests.xml",
     test_suites: [
         "cts",
+        "mts-art",
         "mcts-art",
     ],
 }
diff --git a/runtime/oat/aot_class_linker.cc b/dex2oat/aot_class_linker.cc
similarity index 98%
rename from runtime/oat/aot_class_linker.cc
rename to dex2oat/aot_class_linker.cc
index 0a85fa094b..6efddb2f42 100644
--- a/runtime/oat/aot_class_linker.cc
+++ b/dex2oat/aot_class_linker.cc
@@ -22,6 +22,7 @@
 #include "dex/class_reference.h"
 #include "gc/heap.h"
 #include "handle_scope-inl.h"
+#include "interpreter/interpreter_switch_impl.h"
 #include "mirror/class-inl.h"
 #include "runtime.h"
 #include "scoped_thread_state_change-inl.h"
@@ -511,4 +512,9 @@ void AotClassLinker::VisitTransactionRoots(RootVisitor* visitor) {
   }
 }
 
+const void* AotClassLinker::GetTransactionalInterpreter() {
+  return reinterpret_cast<const void*>(
+      &interpreter::ExecuteSwitchImplCpp</*transaction_active=*/ true>);
+}
+
 }  // namespace art
diff --git a/runtime/oat/aot_class_linker.h b/dex2oat/aot_class_linker.h
similarity index 96%
rename from runtime/oat/aot_class_linker.h
rename to dex2oat/aot_class_linker.h
index 0ee2fe1b42..0321fff0e2 100644
--- a/runtime/oat/aot_class_linker.h
+++ b/dex2oat/aot_class_linker.h
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef ART_RUNTIME_OAT_AOT_CLASS_LINKER_H_
-#define ART_RUNTIME_OAT_AOT_CLASS_LINKER_H_
+#ifndef ART_DEX2OAT_AOT_CLASS_LINKER_H_
+#define ART_DEX2OAT_AOT_CLASS_LINKER_H_
 
 #include <forward_list>
 
@@ -31,7 +31,6 @@ namespace gc {
 class Heap;
 }  // namespace gc
 
-// TODO: move to dex2oat/.
 // AotClassLinker is only used for AOT compiler, which includes some logic for class initialization
 // which will only be used in pre-compilation.
 class AotClassLinker : public ClassLinker {
@@ -138,9 +137,13 @@ class AotClassLinker : public ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_);
   bool IsTransactionAborted() const override;
 
+  // Visit transaction roots for AOT compilation.
   void VisitTransactionRoots(RootVisitor* visitor) override
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  // Get transactional switch interpreter entrypoint for AOT compilation.
+  const void* GetTransactionalInterpreter() override;
+
  protected:
   // Overridden version of PerformClassVerification allows skipping verification if the class was
   // previously verified but unloaded.
@@ -179,4 +182,4 @@ class AotClassLinker : public ClassLinker {
 
 }  // namespace art
 
-#endif  // ART_RUNTIME_OAT_AOT_CLASS_LINKER_H_
+#endif  // ART_DEX2OAT_AOT_CLASS_LINKER_H_
diff --git a/dex2oat/art_standalone_dex2oat_cts_tests.xml b/dex2oat/art_standalone_dex2oat_cts_tests.xml
index b6f4a3d5f2..9b833690ee 100644
--- a/dex2oat/art_standalone_dex2oat_cts_tests.xml
+++ b/dex2oat/art_standalone_dex2oat_cts_tests.xml
@@ -31,11 +31,6 @@
     <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
         <option name="cleanup" value="true" />
         <option name="push" value="art-gtest-jars-Main.jar->/data/local/tmp/art_standalone_dex2oat_cts_tests/art-gtest-jars-Main.jar" />
-        <option name="push" value="art-gtest-jars-MainStripped.jar->/data/local/tmp/art_standalone_dex2oat_cts_tests/art-gtest-jars-MainStripped.jar" />
-        <option name="push" value="art-gtest-jars-MultiDex.jar->/data/local/tmp/art_standalone_dex2oat_cts_tests/art-gtest-jars-MultiDex.jar" />
-        <option name="push" value="art-gtest-jars-MultiDexModifiedSecondary.jar->/data/local/tmp/art_standalone_dex2oat_cts_tests/art-gtest-jars-MultiDexModifiedSecondary.jar" />
-        <option name="push" value="art-gtest-jars-MultiDexUncompressedAligned.jar->/data/local/tmp/art_standalone_dex2oat_cts_tests/art-gtest-jars-MultiDexUncompressedAligned.jar" />
-        <option name="push" value="art-gtest-jars-Nested.jar->/data/local/tmp/art_standalone_dex2oat_cts_tests/art-gtest-jars-Nested.jar" />
     </target_preparer>
 
     <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
diff --git a/dex2oat/art_standalone_dex2oat_tests.xml b/dex2oat/art_standalone_dex2oat_tests.xml
index d0c3f40738..d86eb154bb 100644
--- a/dex2oat/art_standalone_dex2oat_tests.xml
+++ b/dex2oat/art_standalone_dex2oat_tests.xml
@@ -49,6 +49,7 @@
         <option name="push" value="art-gtest-jars-StaticLeafMethods.jar->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-StaticLeafMethods.jar" />
         <option name="push" value="art-gtest-jars-Statics.jar->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-Statics.jar" />
         <option name="push" value="art-gtest-jars-StringLiterals.jar->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-StringLiterals.jar" />
+        <option name="push" value="art-gtest-jars-Transaction.jar->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-Transaction.jar" />
         <option name="push" value="art-gtest-jars-VerifierDeps.dex->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-VerifierDeps.dex" />
         <option name="push" value="art-gtest-jars-VerifierDepsMulti.dex->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-VerifierDepsMulti.dex" />
         <option name="push" value="art-gtest-jars-VerifySoftFailDuringClinit.dex->/data/local/tmp/art_standalone_dex2oat_tests/art-gtest-jars-VerifySoftFailDuringClinit.dex" />
diff --git a/runtime/common_transaction_test.cc b/dex2oat/common_transaction_test.cc
similarity index 67%
rename from runtime/common_transaction_test.cc
rename to dex2oat/common_transaction_test.cc
index 85f176944a..d24acd575d 100644
--- a/runtime/common_transaction_test.cc
+++ b/dex2oat/common_transaction_test.cc
@@ -16,11 +16,34 @@
 
 #include "common_transaction_test.h"
 
-#include "oat/aot_class_linker.h"
+#include "aot_class_linker.h"
 #include "runtime.h"
 
 namespace art HIDDEN {
 
+class CommonTransactionTestCompilerCallbacks : public CompilerCallbacks {
+ public:
+  CommonTransactionTestCompilerCallbacks()
+      : CompilerCallbacks(CompilerCallbacks::CallbackMode::kCompileApp) {}
+
+  ClassLinker* CreateAotClassLinker(InternTable* intern_table) override {
+    return new AotClassLinker(intern_table);
+  }
+
+  void AddUncompilableMethod([[maybe_unused]] MethodReference ref) override {}
+  void AddUncompilableClass([[maybe_unused]] ClassReference ref) override {}
+  void ClassRejected([[maybe_unused]] ClassReference ref) override {}
+
+  verifier::VerifierDeps* GetVerifierDeps() const override { return nullptr; }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(CommonTransactionTestCompilerCallbacks);
+};
+
+CompilerCallbacks* CommonTransactionTestImpl::CreateCompilerCallbacks() {
+  return new CommonTransactionTestCompilerCallbacks();
+}
+
 void CommonTransactionTestImpl::EnterTransactionMode() {
   CHECK(!Runtime::Current()->IsActiveTransaction());
   AotClassLinker* class_linker = down_cast<AotClassLinker*>(Runtime::Current()->GetClassLinker());
diff --git a/runtime/common_transaction_test.h b/dex2oat/common_transaction_test.h
similarity index 71%
rename from runtime/common_transaction_test.h
rename to dex2oat/common_transaction_test.h
index 937662009f..6580822a61 100644
--- a/runtime/common_transaction_test.h
+++ b/dex2oat/common_transaction_test.h
@@ -14,15 +14,19 @@
  * limitations under the License.
  */
 
-#ifndef ART_RUNTIME_COMMON_TRANSACTION_TEST_H_
-#define ART_RUNTIME_COMMON_TRANSACTION_TEST_H_
+#ifndef ART_DEX2OAT_COMMON_TRANSACTION_TEST_H_
+#define ART_DEX2OAT_COMMON_TRANSACTION_TEST_H_
 
 #include "common_runtime_test.h"
 
+#include "compiler_callbacks.h"
+
 namespace art HIDDEN {
 
 class CommonTransactionTestImpl {
  protected:
+  static CompilerCallbacks* CreateCompilerCallbacks();
+
   static void EnterTransactionMode() REQUIRES_SHARED(Locks::mutator_lock_);
   static void ExitTransactionMode();
   static void RollbackAndExitTransactionMode() REQUIRES_SHARED(Locks::mutator_lock_);
@@ -30,10 +34,16 @@ class CommonTransactionTestImpl {
 };
 
 template <typename TestType>
-class CommonTransactionTestBase : public TestType, public CommonTransactionTestImpl {};
+class CommonTransactionTestBase : public TestType, public CommonTransactionTestImpl {
+ public:
+  void SetUpRuntimeOptions(RuntimeOptions* options) override {
+    TestType::SetUpRuntimeOptions(options);
+    this->callbacks_.reset(CommonTransactionTestImpl::CreateCompilerCallbacks());
+  }
+};
 
 using CommonTransactionTest = CommonTransactionTestBase<CommonRuntimeTest>;
 
 }  // namespace art
 
-#endif  // ART_RUNTIME_COMMON_TRANSACTION_TEST_H_
+#endif  // ART_DEX2OAT_COMMON_TRANSACTION_TEST_H_
diff --git a/dex2oat/dex/quick_compiler_callbacks.cc b/dex2oat/dex/quick_compiler_callbacks.cc
index c3b1c9b530..6261cc27c5 100644
--- a/dex2oat/dex/quick_compiler_callbacks.cc
+++ b/dex2oat/dex/quick_compiler_callbacks.cc
@@ -16,12 +16,17 @@
 
 #include "quick_compiler_callbacks.h"
 
+#include "aot_class_linker.h"
 #include "dex/verification_results.h"
 #include "driver/compiler_driver.h"
 #include "mirror/class-inl.h"
 
 namespace art {
 
+ClassLinker* QuickCompilerCallbacks::CreateAotClassLinker(InternTable* intern_table) {
+  return new AotClassLinker(intern_table);
+}
+
 void QuickCompilerCallbacks::AddUncompilableMethod(MethodReference ref) {
   if (verification_results_ != nullptr) {
     verification_results_->AddUncompilableMethod(ref);
diff --git a/dex2oat/dex/quick_compiler_callbacks.h b/dex2oat/dex/quick_compiler_callbacks.h
index a7a482b4ca..bb5bed38a2 100644
--- a/dex2oat/dex/quick_compiler_callbacks.h
+++ b/dex2oat/dex/quick_compiler_callbacks.h
@@ -33,6 +33,8 @@ class QuickCompilerCallbacks final : public CompilerCallbacks {
 
   ~QuickCompilerCallbacks() { }
 
+  ClassLinker* CreateAotClassLinker(InternTable* intern_table) override;
+
   void AddUncompilableMethod(MethodReference ref) override;
   void AddUncompilableClass(ClassReference ref) override;
 
diff --git a/dex2oat/dex2oat.cc b/dex2oat/dex2oat.cc
index 31a83bd198..06d3770abd 100644
--- a/dex2oat/dex2oat.cc
+++ b/dex2oat/dex2oat.cc
@@ -39,12 +39,14 @@
 #endif  // __arm__
 #endif
 
-#include "android-base/parseint.h"
-#include "android-base/properties.h"
-#include "android-base/scopeguard.h"
-#include "android-base/stringprintf.h"
-#include "android-base/strings.h"
-#include "android-base/unique_fd.h"
+#include <android-base/parseint.h>
+#include <android-base/properties.h>
+#include <android-base/scopeguard.h>
+#include <android-base/stringprintf.h>
+#include <android-base/strings.h>
+#include <android-base/unique_fd.h>
+
+#include "aot_class_linker.h"
 #include "arch/instruction_set_features.h"
 #include "art_method-inl.h"
 #include "base/callee_save_type.h"
@@ -95,7 +97,6 @@
 #include "mirror/class_loader.h"
 #include "mirror/object-inl.h"
 #include "mirror/object_array-inl.h"
-#include "oat/aot_class_linker.h"
 #include "oat/elf_file.h"
 #include "oat/oat.h"
 #include "oat/oat_file.h"
@@ -378,7 +379,7 @@ class WatchDog {
                                    false);
       runtime->DumpForSigQuit(std::cerr);
     }
-    exit(1);
+    exit(static_cast<int>(dex2oat::ReturnCode::kOther));
   }
 
   void Wait() {
@@ -529,8 +530,6 @@ class Dex2Oat final {
         image_base_(0U),
         image_storage_mode_(ImageHeader::kStorageModeUncompressed),
         passes_to_run_filename_(nullptr),
-        dirty_image_objects_filename_(nullptr),
-        dirty_image_objects_fd_(-1),
         is_host_(false),
         elf_writers_(),
         oat_writers_(),
@@ -668,6 +667,11 @@ class Dex2Oat final {
       if (compiler_options_->IsBootImage() || compiler_options_->IsBootImageExtension()) {
         Usage("Can't have both (--image or --image-fd) and (--app-image-fd or --app-image-file)");
       }
+      if (profile_files_.empty() && profile_file_fds_.empty()) {
+        LOG(WARNING) << "Generating an app image without a profile. This will result in an app "
+                        "image with no classes. Did you forget to add the profile with either "
+                        "--profile-file-fd or --profile-file?";
+      }
       compiler_options_->image_type_ = CompilerOptions::ImageType::kAppImage;
     }
 
@@ -838,7 +842,7 @@ class Dex2Oat final {
       }
     }
 
-    if (dirty_image_objects_filename_ != nullptr && dirty_image_objects_fd_ != -1) {
+    if (!dirty_image_objects_filenames_.empty() && !dirty_image_objects_fds_.empty()) {
       Usage("--dirty-image-objects and --dirty-image-objects-fd should not be both specified");
     }
 
@@ -1104,8 +1108,8 @@ class Dex2Oat final {
     AssignIfExists(args, M::AppImageFileFd, &app_image_fd_);
     AssignIfExists(args, M::NoInlineFrom, &no_inline_from_string_);
     AssignIfExists(args, M::ClasspathDir, &classpath_dir_);
-    AssignIfExists(args, M::DirtyImageObjects, &dirty_image_objects_filename_);
-    AssignIfExists(args, M::DirtyImageObjectsFd, &dirty_image_objects_fd_);
+    AssignIfExists(args, M::DirtyImageObjects, &dirty_image_objects_filenames_);
+    AssignIfExists(args, M::DirtyImageObjectsFd, &dirty_image_objects_fds_);
     AssignIfExists(args, M::ImageFormat, &image_storage_mode_);
     AssignIfExists(args, M::CompilationReason, &compilation_reason_);
     AssignTrueIfExists(args, M::CheckLinkageConditions, &check_linkage_conditions_);
@@ -2523,23 +2527,26 @@ class Dex2Oat final {
   }
 
   bool PrepareDirtyObjects() {
-    if (dirty_image_objects_fd_ != -1) {
-      dirty_image_objects_ =
-          ReadCommentedInputFromFd<std::vector<std::string>>(dirty_image_objects_fd_, nullptr);
-      // Close since we won't need it again.
-      close(dirty_image_objects_fd_);
-      dirty_image_objects_fd_ = -1;
-      if (dirty_image_objects_ == nullptr) {
-        LOG(ERROR) << "Failed to create list of dirty objects from fd " << dirty_image_objects_fd_;
-        return false;
+    if (!dirty_image_objects_fds_.empty()) {
+      dirty_image_objects_ = std::make_unique<std::vector<std::string>>();
+      for (int fd : dirty_image_objects_fds_) {
+        if (!ReadCommentedInputFromFd(fd, nullptr, dirty_image_objects_.get())) {
+          LOG(ERROR) << "Failed to create list of dirty objects from fd " << fd;
+          return false;
+        }
       }
-    } else if (dirty_image_objects_filename_ != nullptr) {
-      dirty_image_objects_ = ReadCommentedInputFromFile<std::vector<std::string>>(
-          dirty_image_objects_filename_, nullptr);
-      if (dirty_image_objects_ == nullptr) {
-        LOG(ERROR) << "Failed to create list of dirty objects from '"
-            << dirty_image_objects_filename_ << "'";
-        return false;
+      // Close since we won't need it again.
+      for (int fd : dirty_image_objects_fds_) {
+        close(fd);
+      }
+      dirty_image_objects_fds_.clear();
+    } else if (!dirty_image_objects_filenames_.empty()) {
+      dirty_image_objects_ = std::make_unique<std::vector<std::string>>();
+      for (const std::string& file : dirty_image_objects_filenames_) {
+        if (!ReadCommentedInputFromFile(file.c_str(), nullptr, dirty_image_objects_.get())) {
+          LOG(ERROR) << "Failed to create list of dirty objects from '" << file << "'";
+          return false;
+        }
       }
     }
     return true;
@@ -2941,8 +2948,8 @@ class Dex2Oat final {
   uintptr_t image_base_;
   ImageHeader::StorageMode image_storage_mode_;
   const char* passes_to_run_filename_;
-  const char* dirty_image_objects_filename_;
-  int dirty_image_objects_fd_;
+  std::vector<std::string> dirty_image_objects_filenames_;
+  std::vector<int> dirty_image_objects_fds_;
   std::unique_ptr<std::vector<std::string>> dirty_image_objects_;
   std::unique_ptr<std::vector<std::string>> passes_to_run_;
   bool is_host_;
diff --git a/dex2oat/dex2oat_cts_test.cc b/dex2oat/dex2oat_cts_test.cc
index 0b5ee5be7d..63a7fea59e 100644
--- a/dex2oat/dex2oat_cts_test.cc
+++ b/dex2oat/dex2oat_cts_test.cc
@@ -14,11 +14,28 @@
  * limitations under the License.
  */
 
+#include <sys/wait.h>
+
+#include "android-base/result-gmock.h"
+#include "android-base/result.h"
+#include "android-base/strings.h"
 #include "base/file_utils.h"
 #include "dex2oat_environment_test.h"
 
 namespace art {
 
+using ::android::base::Result;
+using ::android::base::testing::HasValue;
+
+// Test the binary with the same bitness as the test. This is also done to avoid
+// the symlink /apex/com.android.art/bin/dex2oat, which we don't have selinux
+// permission to read on S.
+#if defined(__LP64__)
+constexpr const char* kDex2oatBinary = "dex2oat64";
+#else
+constexpr const char* kDex2oatBinary = "dex2oat32";
+#endif
+
 class Dex2oatCtsTest : public CommonArtTest, public Dex2oatScratchDirs {
  public:
   void SetUp() override {
@@ -34,11 +51,9 @@ class Dex2oatCtsTest : public CommonArtTest, public Dex2oatScratchDirs {
  protected:
   // Stripped down counterpart to Dex2oatEnvironmentTest::Dex2Oat that only adds
   // enough arguments for our purposes.
-  int Dex2Oat(const std::vector<std::string>& dex2oat_args,
-              std::string* output,
-              std::string* error_msg) {
-    // This command line should work regardless of bitness, ISA, etc.
-    std::vector<std::string> argv = {std::string(kAndroidArtApexDefaultPath) + "/bin/dex2oat"};
+  Result<int> Dex2Oat(const std::vector<std::string>& dex2oat_args, std::string* output) {
+    std::vector<std::string> argv = {std::string(kAndroidArtApexDefaultPath) + "/bin/" +
+                                     kDex2oatBinary};
     argv.insert(argv.end(), dex2oat_args.begin(), dex2oat_args.end());
 
     // We must set --android-root.
@@ -48,18 +63,20 @@ class Dex2oatCtsTest : public CommonArtTest, public Dex2oatScratchDirs {
 
     // We need dex2oat to actually log things.
     auto post_fork_fn = []() { return setenv("ANDROID_LOG_TAGS", "*:d", 1) == 0; };
+
     ForkAndExecResult res = ForkAndExec(argv, post_fork_fn, output);
     if (res.stage != ForkAndExecResult::kFinished) {
-      *error_msg = strerror(errno);
-      ::testing::AssertionFailure() << "Failed to finish dex2oat invocation: " << *error_msg;
+      return ErrnoErrorf("Failed to finish dex2oat invocation '{}'",
+                         android::base::Join(argv, ' '));
     }
 
-    if (!res.StandardSuccess()) {
-      // We cannot use ASSERT_TRUE since the method returns an int and not void.
-      ::testing::AssertionFailure() << "dex2oat fork/exec failed: " << *error_msg;
+    if (!WIFEXITED(res.status_code)) {
+      return Errorf("dex2oat didn't terminate normally (status_code={:#x}): {}",
+                    res.status_code,
+                    android::base::Join(argv, ' '));
     }
 
-    return res.status_code;
+    return WEXITSTATUS(res.status_code);
   }
 };
 
@@ -85,9 +102,7 @@ TEST_F(Dex2oatCtsTest, CompilationHooks) {
   args.emplace_back("--force-palette-compilation-hooks");
 
   std::string output = "";
-  std::string error_msg;
-  int res = Dex2Oat(args, &output, &error_msg);
-  EXPECT_EQ(res, 0) << error_msg;
+  EXPECT_THAT(Dex2Oat(args, &output), HasValue(0));
   EXPECT_EQ(oat_file->FlushCloseOrErase(), 0);
   EXPECT_EQ(vdex_file->FlushCloseOrErase(), 0);
 }
diff --git a/dex2oat/dex2oat_image_test.cc b/dex2oat/dex2oat_image_test.cc
index b62dd832fc..34ca3e4d84 100644
--- a/dex2oat/dex2oat_image_test.cc
+++ b/dex2oat/dex2oat_image_test.cc
@@ -246,6 +246,28 @@ TEST_F(Dex2oatImageTest, TestModesAndFilters) {
     classes.Close();
     std::cout << "Dirty image object sizes " << image_classes_sizes << std::endl;
   }
+  // Test multiple dirty image objects.
+  {
+    std::array<ScratchFile, 2> files;
+    int idx = 0;
+    VisitDexes(
+        libcore_dexes_array,
+        VoidFunctor(),
+        [&](TypeReference ref) {
+          WriteLine(files[idx].GetFile(), ref.dex_file->PrettyType(ref.TypeIndex()));
+          idx = (idx + 1) % files.size();
+        },
+        /*method_frequency=*/1u,
+        /*class_frequency=*/1u);
+    ImageSizes image_classes_sizes =
+        CompileImageAndGetSizes(dex_files,
+                                {"--dirty-image-objects=" + files[0].GetFilename(),
+                                 "--dirty-image-objects=" + files[1].GetFilename()});
+    for (ScratchFile& file : files) {
+      file.Close();
+    }
+    std::cout << "Dirty image object sizes " << image_classes_sizes << std::endl;
+  }
 }
 
 TEST_F(Dex2oatImageTest, TestExtension) {
diff --git a/dex2oat/dex2oat_options.cc b/dex2oat/dex2oat_options.cc
index 34a72f084e..635961e5f8 100644
--- a/dex2oat/dex2oat_options.cc
+++ b/dex2oat/dex2oat_options.cc
@@ -194,12 +194,12 @@ static void AddImageMappings(Builder& builder) {
                     "images.")
           .IntoKey(M::MultiImage)
       .Define("--dirty-image-objects=_")
-          .WithType<std::string>()
+          .WithType<std::vector<std::string>>().AppendValues()
           .WithHelp("list of known dirty objects in the image. The image writer will group them"
                     " together")
           .IntoKey(M::DirtyImageObjects)
       .Define("--dirty-image-objects-fd=_")
-          .WithType<int>()
+          .WithType<std::vector<int>>().AppendValues()
           .WithHelp("Specify a file descriptor for reading the list of known dirty objects in\n"
                     "the image. The image writer will group them together")
           .IntoKey(M::DirtyImageObjectsFd)
diff --git a/dex2oat/dex2oat_options.def b/dex2oat/dex2oat_options.def
index 7cf9d023b7..10c4eccfa0 100644
--- a/dex2oat/dex2oat_options.def
+++ b/dex2oat/dex2oat_options.def
@@ -89,8 +89,8 @@ DEX2OAT_OPTIONS_KEY (std::string,                    InvocationFile)
 DEX2OAT_OPTIONS_KEY (std::string,                    ClassLoaderContext)
 DEX2OAT_OPTIONS_KEY (std::string,                    ClassLoaderContextFds)
 DEX2OAT_OPTIONS_KEY (std::string,                    StoredClassLoaderContext)
-DEX2OAT_OPTIONS_KEY (std::string,                    DirtyImageObjects)
-DEX2OAT_OPTIONS_KEY (int,                            DirtyImageObjectsFd)
+DEX2OAT_OPTIONS_KEY (std::vector<std::string>,       DirtyImageObjects)
+DEX2OAT_OPTIONS_KEY (std::vector<int>,               DirtyImageObjectsFd)
 DEX2OAT_OPTIONS_KEY (std::string,                    UpdatableBcpPackagesFile)
 DEX2OAT_OPTIONS_KEY (int,                            UpdatableBcpPackagesFd)
 DEX2OAT_OPTIONS_KEY (std::vector<std::string>,       RuntimeOptions)
diff --git a/dex2oat/dex2oat_test.cc b/dex2oat/dex2oat_test.cc
index fdb6d4178b..26216fd719 100644
--- a/dex2oat/dex2oat_test.cc
+++ b/dex2oat/dex2oat_test.cc
@@ -27,6 +27,8 @@
 
 #include "android-base/logging.h"
 #include "android-base/macros.h"
+#include "android-base/result-gmock.h"
+#include "android-base/result.h"
 #include "android-base/stringprintf.h"
 #include "arch/instruction_set_features.h"
 #include "base/macros.h"
@@ -54,7 +56,15 @@
 
 namespace art {
 
-using android::base::StringPrintf;
+using ::android::base::Result;
+using ::android::base::StringPrintf;
+using ::android::base::testing::HasValue;
+using ::android::base::testing::Ok;
+using ::testing::AssertionFailure;
+using ::testing::AssertionResult;
+using ::testing::AssertionSuccess;
+using ::testing::Ne;
+using ::testing::Not;
 
 class Dex2oatTest : public Dex2oatEnvironmentTest {
  public:
@@ -62,16 +72,14 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
     Dex2oatEnvironmentTest::TearDown();
 
     output_ = "";
-    error_msg_ = "";
   }
 
  protected:
-  int GenerateOdexForTestWithStatus(const std::vector<std::string>& dex_locations,
-                                    const std::string& odex_location,
-                                    CompilerFilter::Filter filter,
-                                    std::string* error_msg,
-                                    const std::vector<std::string>& extra_args = {},
-                                    bool use_fd = false) {
+  Result<int> GenerateOdexForTestWithStatus(const std::vector<std::string>& dex_locations,
+                                            const std::string& odex_location,
+                                            CompilerFilter::Filter filter,
+                                            const std::vector<std::string>& extra_args = {},
+                                            bool use_fd = false) {
     std::unique_ptr<File> oat_file;
     std::vector<std::string> args;
     args.reserve(dex_locations.size() + extra_args.size() + 6);
@@ -81,7 +89,9 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
     }
     if (use_fd) {
       oat_file.reset(OS::CreateEmptyFile(odex_location.c_str()));
-      CHECK(oat_file != nullptr) << odex_location;
+      if (oat_file == nullptr) {
+        return ErrnoErrorf("CreateEmptyFile failed on {}", odex_location);
+      }
       args.push_back("--oat-fd=" + std::to_string(oat_file->Fd()));
       args.push_back("--oat-location=" + odex_location);
     } else {
@@ -97,20 +107,24 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
 
     args.insert(args.end(), extra_args.begin(), extra_args.end());
 
-    int status = Dex2Oat(args, &output_, error_msg);
+    int status = OR_RETURN(Dex2Oat(args, &output_));
     if (oat_file != nullptr) {
-      CHECK_EQ(oat_file->FlushClose(), 0) << "Could not flush and close oat file";
+      int fc_errno = oat_file->FlushClose();
+      if (fc_errno != 0) {
+        return Errorf(
+            "Could not flush and close oat file {}: {}", odex_location, strerror(-fc_errno));
+      }
     }
     return status;
   }
 
-  ::testing::AssertionResult GenerateOdexForTest(const std::string& dex_location,
-                                                 const std::string& odex_location,
-                                                 CompilerFilter::Filter filter,
-                                                 const std::vector<std::string>& extra_args = {},
-                                                 bool expect_success = true,
-                                                 bool use_fd = false,
-                                                 bool use_zip_fd = false) WARN_UNUSED {
+  AssertionResult GenerateOdexForTest(const std::string& dex_location,
+                                      const std::string& odex_location,
+                                      CompilerFilter::Filter filter,
+                                      const std::vector<std::string>& extra_args = {},
+                                      bool expect_success = true,
+                                      bool use_fd = false,
+                                      bool use_zip_fd = false) WARN_UNUSED {
     return GenerateOdexForTest(dex_location,
                                odex_location,
                                filter,
@@ -124,14 +138,14 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
   bool test_accepts_odex_file_on_failure = false;
 
   template <typename T>
-  ::testing::AssertionResult GenerateOdexForTest(const std::string& dex_location,
-                                                 const std::string& odex_location,
-                                                 CompilerFilter::Filter filter,
-                                                 const std::vector<std::string>& extra_args,
-                                                 bool expect_success,
-                                                 bool use_fd,
-                                                 bool use_zip_fd,
-                                                 T check_oat) WARN_UNUSED {
+  AssertionResult GenerateOdexForTest(const std::string& dex_location,
+                                      const std::string& odex_location,
+                                      CompilerFilter::Filter filter,
+                                      const std::vector<std::string>& extra_args,
+                                      bool expect_success,
+                                      bool use_fd,
+                                      bool use_zip_fd,
+                                      T check_oat) WARN_UNUSED {
     std::vector<std::string> dex_locations;
     if (use_zip_fd) {
       std::string loc_arg = "--zip-location=" + dex_location;
@@ -144,17 +158,21 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
     } else {
       dex_locations.push_back(dex_location);
     }
-    std::string error_msg;
-    int status = GenerateOdexForTestWithStatus(
-        dex_locations, odex_location, filter, &error_msg, extra_args, use_fd);
-    bool success = (WIFEXITED(status) && WEXITSTATUS(status) == 0);
+
+    Result<int> status =
+        GenerateOdexForTestWithStatus(dex_locations, odex_location, filter, extra_args, use_fd);
+
+    bool success = status.ok() && status.value() == 0;
     if (expect_success) {
       if (!success) {
-        return ::testing::AssertionFailure() << "Failed to compile odex: " << error_msg << std::endl
-                                             << output_;
+        return AssertionFailure() << "Failed to compile odex ("
+                                  << (status.ok() ? StringPrintf("status=%d", status.value()) :
+                                                    status.error().message())
+                                  << "): " << output_;
       }
 
       // Verify the odex file was generated as expected.
+      std::string error_msg;
       std::unique_ptr<OatFile> odex_file(OatFile::Open(/*zip_fd=*/-1,
                                                        odex_location,
                                                        odex_location,
@@ -163,20 +181,19 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
                                                        dex_location,
                                                        &error_msg));
       if (odex_file == nullptr) {
-        return ::testing::AssertionFailure() << "Could not open odex file: " << error_msg;
+        return AssertionFailure() << "Could not open odex file: " << error_msg;
       }
 
       CheckFilter(filter, odex_file->GetCompilerFilter());
       check_oat(*(odex_file.get()));
     } else {
       if (success) {
-        return ::testing::AssertionFailure() << "Succeeded to compile odex: " << output_;
+        return AssertionFailure() << "Succeeded to compile odex: " << output_;
       }
 
-      error_msg_ = error_msg;
-
       if (!test_accepts_odex_file_on_failure) {
         // Verify there's no loadable odex file.
+        std::string error_msg;
         std::unique_ptr<OatFile> odex_file(OatFile::Open(/*zip_fd=*/-1,
                                                          odex_location,
                                                          odex_location,
@@ -185,11 +202,11 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
                                                          dex_location,
                                                          &error_msg));
         if (odex_file != nullptr) {
-          return ::testing::AssertionFailure() << "Could open odex file: " << error_msg;
+          return AssertionFailure() << "Could open odex file: " << error_msg;
         }
       }
     }
-    return ::testing::AssertionSuccess();
+    return AssertionSuccess();
   }
 
   // Check the input compiler filter against the generated oat file's filter. May be overridden
@@ -199,7 +216,6 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
   }
 
   std::string output_ = "";
-  std::string error_msg_ = "";
 };
 
 // This test class provides an easy way to validate an expected filter which is different
@@ -991,10 +1007,10 @@ class Dex2oatWatchdogTest : public Dex2oatTest {
 
 TEST_F(Dex2oatWatchdogTest, TestWatchdogOK) {
   // Check with default.
-  RunTest(true);
+  RunTest(/*expect_success=*/true);
 
   // Check with ten minutes.
-  RunTest(true, {"--watchdog-timeout=600000"});
+  RunTest(/*expect_success=*/true, {"--watchdog-timeout=600000"});
 }
 
 TEST_F(Dex2oatWatchdogTest, TestWatchdogTrigger) {
@@ -1008,30 +1024,14 @@ TEST_F(Dex2oatWatchdogTest, TestWatchdogTrigger) {
   test_accepts_odex_file_on_failure = true;
 
   // Check with ten milliseconds.
-  RunTest(false, {"--watchdog-timeout=10"});
+  RunTest(/*expect_success=*/false, {"--watchdog-timeout=10"});
 }
 
-class Dex2oatReturnCodeTest : public Dex2oatTest {
- protected:
-  int RunTest(const std::vector<std::string>& extra_args = {}) {
-    std::string dex_location = GetScratchDir() + "/Dex2OatSwapTest.jar";
-    std::string odex_location = GetOdexDir() + "/Dex2OatSwapTest.odex";
-
-    Copy(GetTestDexFileName(), dex_location);
-
-    std::string error_msg;
-    return GenerateOdexForTestWithStatus(
-        {dex_location}, odex_location, CompilerFilter::kSpeed, &error_msg, extra_args);
-  }
-
-  std::string GetTestDexFileName() { return GetDexSrc1(); }
-};
-
 class Dex2oatClassLoaderContextTest : public Dex2oatTest {
  protected:
   void RunTest(const char* class_loader_context,
                const char* expected_classpath_key,
-               bool expected_success,
+               bool expect_success,
                bool use_second_source = false,
                bool generate_image = false) {
     std::string dex_location = GetUsedDexLocation();
@@ -1039,7 +1039,6 @@ class Dex2oatClassLoaderContextTest : public Dex2oatTest {
 
     Copy(use_second_source ? GetDexSrc2() : GetDexSrc1(), dex_location);
 
-    std::string error_msg;
     std::vector<std::string> extra_args;
     if (class_loader_context != nullptr) {
       extra_args.push_back(std::string("--class-loader-context=") + class_loader_context);
@@ -1058,7 +1057,7 @@ class Dex2oatClassLoaderContextTest : public Dex2oatTest {
                                     odex_location,
                                     CompilerFilter::kVerify,
                                     extra_args,
-                                    expected_success,
+                                    expect_success,
                                     /*use_fd=*/false,
                                     /*use_zip_fd=*/false,
                                     check_oat));
@@ -1074,16 +1073,16 @@ class Dex2oatClassLoaderContextTest : public Dex2oatTest {
 };
 
 TEST_F(Dex2oatClassLoaderContextTest, InvalidContext) {
-  RunTest("Invalid[]", /*expected_classpath_key*/ nullptr, /*expected_success*/ false);
+  RunTest("Invalid[]", /*expected_classpath_key=*/nullptr, /*expect_success=*/false);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, EmptyContext) {
-  RunTest("PCL[]", kEmptyClassPathKey, /*expected_success*/ true);
+  RunTest("PCL[]", kEmptyClassPathKey, /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithTheSourceDexFiles) {
   std::string context = "PCL[" + GetUsedDexLocation() + "]";
-  RunTest(context.c_str(), kEmptyClassPathKey, /*expected_success*/ true);
+  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithOtherDexFiles) {
@@ -1094,7 +1093,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithOtherDexFiles) {
   std::string context = "PCL[" + dex_files[0]->GetLocation() + "]";
   std::string expected_classpath_key =
       "PCL[" + dex_files[0]->GetLocation() + "*" + std::to_string(expected_checksum) + "]";
-  RunTest(context.c_str(), expected_classpath_key.c_str(), true);
+  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithResourceOnlyDexFiles) {
@@ -1103,13 +1102,13 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithResourceOnlyDexFiles) {
 
   std::string context = "PCL[" + resource_only_classpath + "]";
   // Expect an empty context because resource only dex files cannot be open.
-  RunTest(context.c_str(), kEmptyClassPathKey, /*expected_success*/ true);
+  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithNotExistentDexFiles) {
   std::string context = "PCL[does_not_exists.dex]";
   // Expect an empty context because stripped dex files cannot be open.
-  RunTest(context.c_str(), kEmptyClassPathKey, /*expected_success*/ true);
+  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ChainContext) {
@@ -1121,7 +1120,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ChainContext) {
   std::string expected_classpath_key = "PCL[" + CreateClassPathWithChecksums(dex_files1) + "];" +
                                        "DLC[" + CreateClassPathWithChecksums(dex_files2) + "]";
 
-  RunTest(context.c_str(), expected_classpath_key.c_str(), true);
+  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibrary) {
@@ -1132,7 +1131,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibrary) {
       "PCL[" + GetTestDexFileName("Nested") + "]" + "{PCL[" + GetTestDexFileName("MultiDex") + "]}";
   std::string expected_classpath_key = "PCL[" + CreateClassPathWithChecksums(dex_files1) + "]" +
                                        "{PCL[" + CreateClassPathWithChecksums(dex_files2) + "]}";
-  RunTest(context.c_str(), expected_classpath_key.c_str(), true);
+  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_success=*/true);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibraryAndImage) {
@@ -1145,7 +1144,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibraryAndImage) {
                                        "{PCL[" + CreateClassPathWithChecksums(dex_files2) + "]}";
   RunTest(context.c_str(),
           expected_classpath_key.c_str(),
-          /*expected_success=*/true,
+          /*expect_success=*/true,
           /*use_second_source=*/false,
           /*generate_image=*/true);
 }
@@ -1162,7 +1161,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSameSharedLibrariesAndImage) {
                                        "#PCL[" + CreateClassPathWithChecksums(dex_files2) + "]}";
   RunTest(context.c_str(),
           expected_classpath_key.c_str(),
-          /*expected_success=*/true,
+          /*expect_success=*/true,
           /*use_second_source=*/false,
           /*generate_image=*/true);
 }
@@ -1179,7 +1178,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibrariesDependenciesAndI
                                        "{PCL[" + CreateClassPathWithChecksums(dex_files1) + "]}}";
   RunTest(context.c_str(),
           expected_classpath_key.c_str(),
-          /*expected_success=*/true,
+          /*expect_success=*/true,
           /*use_second_source=*/false,
           /*generate_image=*/true);
 }
@@ -1195,18 +1194,15 @@ TEST_F(Dex2oatDeterminism, UnloadCompile) {
   const std::string unload_vdex_name = out_dir + "/unload.vdex";
   const std::string no_unload_oat_name = out_dir + "/nounload.oat";
   const std::string no_unload_vdex_name = out_dir + "/nounload.vdex";
-  std::string error_msg;
   const std::vector<gc::space::ImageSpace*>& spaces = runtime->GetHeap()->GetBootImageSpaces();
   ASSERT_GT(spaces.size(), 0u);
   const std::string image_location = spaces[0]->GetImageLocation();
   // Without passing in an app image, it will unload in between compilations.
-  const int res =
-      GenerateOdexForTestWithStatus(GetLibCoreDexFileNames(),
-                                    base_oat_name,
-                                    CompilerFilter::Filter::kVerify,
-                                    &error_msg,
-                                    {"--force-determinism", "--avoid-storing-invocation"});
-  ASSERT_EQ(res, 0);
+  ASSERT_THAT(GenerateOdexForTestWithStatus(GetLibCoreDexFileNames(),
+                                            base_oat_name,
+                                            CompilerFilter::Filter::kVerify,
+                                            {"--force-determinism", "--avoid-storing-invocation"}),
+              HasValue(0));
   Copy(base_oat_name, unload_oat_name);
   Copy(base_vdex_name, unload_vdex_name);
   std::unique_ptr<File> unload_oat(OS::OpenFileForReading(unload_oat_name.c_str()));
@@ -1217,13 +1213,12 @@ TEST_F(Dex2oatDeterminism, UnloadCompile) {
   EXPECT_GT(unload_vdex->GetLength(), 0u);
   // Regenerate with an app image to disable the dex2oat unloading and verify that the output is
   // the same.
-  const int res2 = GenerateOdexForTestWithStatus(
-      GetLibCoreDexFileNames(),
-      base_oat_name,
-      CompilerFilter::Filter::kVerify,
-      &error_msg,
-      {"--force-determinism", "--avoid-storing-invocation", "--compile-individually"});
-  ASSERT_EQ(res2, 0);
+  ASSERT_THAT(GenerateOdexForTestWithStatus(
+                  GetLibCoreDexFileNames(),
+                  base_oat_name,
+                  CompilerFilter::Filter::kVerify,
+                  {"--force-determinism", "--avoid-storing-invocation", "--compile-individually"}),
+              HasValue(0));
   Copy(base_oat_name, no_unload_oat_name);
   Copy(base_vdex_name, no_unload_vdex_name);
   std::unique_ptr<File> no_unload_oat(OS::OpenFileForReading(no_unload_oat_name.c_str()));
@@ -1248,20 +1243,18 @@ TEST_F(Dex2oatVerifierAbort, HardFail) {
   std::unique_ptr<const DexFile> dex(OpenTestDexFile("VerifierDeps"));
   std::string out_dir = GetScratchDir();
   const std::string base_oat_name = out_dir + "/base.oat";
-  std::string error_msg;
-  const int res_fail = GenerateOdexForTestWithStatus({dex->GetLocation()},
-                                                     base_oat_name,
-                                                     CompilerFilter::Filter::kVerify,
-                                                     &error_msg,
-                                                     {"--abort-on-hard-verifier-error"});
-  EXPECT_NE(0, res_fail);
-
-  const int res_no_fail = GenerateOdexForTestWithStatus({dex->GetLocation()},
-                                                        base_oat_name,
-                                                        CompilerFilter::Filter::kVerify,
-                                                        &error_msg,
-                                                        {"--no-abort-on-hard-verifier-error"});
-  EXPECT_EQ(0, res_no_fail);
+
+  EXPECT_THAT(GenerateOdexForTestWithStatus({dex->GetLocation()},
+                                            base_oat_name,
+                                            CompilerFilter::Filter::kVerify,
+                                            {"--abort-on-hard-verifier-error"}),
+              HasValue(Ne(0)));
+
+  EXPECT_THAT(GenerateOdexForTestWithStatus({dex->GetLocation()},
+                                            base_oat_name,
+                                            CompilerFilter::Filter::kVerify,
+                                            {"--no-abort-on-hard-verifier-error"}),
+              HasValue(0));
 }
 
 class Dex2oatDedupeCode : public Dex2oatTest {};
@@ -1324,31 +1317,25 @@ TEST_F(Dex2oatTest, MissingBootImageTest) {
 TEST_F(Dex2oatTest, EmptyUncompressedDexTest) {
   std::string out_dir = GetScratchDir();
   const std::string base_oat_name = out_dir + "/base.oat";
-  std::string error_msg;
-  int status = GenerateOdexForTestWithStatus({GetTestDexFileName("MainEmptyUncompressed")},
-                                             base_oat_name,
-                                             CompilerFilter::Filter::kVerify,
-                                             &error_msg,
-                                             {},
-                                             /*use_fd*/ false);
   // Expect to fail with code 1 and not SIGSEGV or SIGABRT.
-  ASSERT_TRUE(WIFEXITED(status));
-  ASSERT_EQ(WEXITSTATUS(status), 1) << error_msg;
+  EXPECT_THAT(GenerateOdexForTestWithStatus({GetTestDexFileName("MainEmptyUncompressed")},
+                                            base_oat_name,
+                                            CompilerFilter::Filter::kVerify,
+                                            /*extra_args*/ {},
+                                            /*use_fd*/ false),
+              HasValue(1));
 }
 
 TEST_F(Dex2oatTest, EmptyUncompressedAlignedDexTest) {
   std::string out_dir = GetScratchDir();
   const std::string base_oat_name = out_dir + "/base.oat";
-  std::string error_msg;
-  int status = GenerateOdexForTestWithStatus({GetTestDexFileName("MainEmptyUncompressedAligned")},
-                                             base_oat_name,
-                                             CompilerFilter::Filter::kVerify,
-                                             &error_msg,
-                                             {},
-                                             /*use_fd*/ false);
   // Expect to fail with code 1 and not SIGSEGV or SIGABRT.
-  ASSERT_TRUE(WIFEXITED(status));
-  ASSERT_EQ(WEXITSTATUS(status), 1) << error_msg;
+  EXPECT_THAT(GenerateOdexForTestWithStatus({GetTestDexFileName("MainEmptyUncompressedAligned")},
+                                            base_oat_name,
+                                            CompilerFilter::Filter::kVerify,
+                                            /*extra_args*/ {},
+                                            /*use_fd*/ false),
+              HasValue(1));
 }
 
 TEST_F(Dex2oatTest, StderrLoggerOutput) {
@@ -1362,7 +1349,7 @@ TEST_F(Dex2oatTest, StderrLoggerOutput) {
                                   odex_location,
                                   CompilerFilter::kVerify,
                                   {"--runtime-arg", "-Xuse-stderr-logger"},
-                                  true));
+                                  /*expect_success=*/true));
   // Look for some random part of dex2oat logging. With the stderr logger this should be captured,
   // even on device.
   EXPECT_NE(std::string::npos, output_.find("dex2oat took"));
@@ -1379,7 +1366,7 @@ TEST_F(Dex2oatTest, VerifyCompilationReason) {
                                   odex_location,
                                   CompilerFilter::kVerify,
                                   {"--compilation-reason=install"},
-                                  true));
+                                  /*expect_success=*/true));
   std::string error_msg;
   std::unique_ptr<OatFile> odex_file(OatFile::Open(/*zip_fd=*/-1,
                                                    odex_location,
@@ -1399,7 +1386,11 @@ TEST_F(Dex2oatTest, VerifyNoCompilationReason) {
   // Test file doesn't matter.
   Copy(GetDexSrc1(), dex_location);
 
-  ASSERT_TRUE(GenerateOdexForTest(dex_location, odex_location, CompilerFilter::kVerify, {}, true));
+  ASSERT_TRUE(GenerateOdexForTest(dex_location,
+                                  odex_location,
+                                  CompilerFilter::kVerify,
+                                  /*extra_args=*/{},
+                                  /*expect_success=*/true));
   std::string error_msg;
   std::unique_ptr<OatFile> odex_file(OatFile::Open(/*zip_fd=*/-1,
                                                    odex_location,
@@ -1526,10 +1517,10 @@ TEST_F(Dex2oatTest, CompactDexInvalidSource) {
   }
   const std::string& dex_location = invalid_dex.GetFilename();
   const std::string odex_location = GetOdexDir() + "/output.odex";
-  std::string error_msg;
-  int status = GenerateOdexForTestWithStatus(
-      {dex_location}, odex_location, CompilerFilter::kVerify, &error_msg, {});
-  ASSERT_TRUE(WIFEXITED(status) && WEXITSTATUS(status) != 0) << status << " " << output_;
+  EXPECT_THAT(GenerateOdexForTestWithStatus(
+                  {dex_location}, odex_location, CompilerFilter::kVerify, /*extra_args*/ {}),
+              HasValue(Ne(0)))
+      << " " << output_;
 }
 
 // Retain the header magic for the now removed compact dex files.
@@ -1573,22 +1564,20 @@ TEST_F(Dex2oatTest, CompactDexInZip) {
     ASSERT_GE(invalid_dex.GetFile()->WriteFully(&header, sizeof(header)), 0);
     ASSERT_EQ(invalid_dex.GetFile()->Flush(), 0);
   }
-  std::string error_msg;
-  int status = 0u;
-
-  status = GenerateOdexForTestWithStatus({invalid_dex_zip.GetFilename()},
-                                         GetOdexDir() + "/output_apk.odex",
-                                         CompilerFilter::kVerify,
-                                         &error_msg,
-                                         {});
-  ASSERT_TRUE(WIFEXITED(status) && WEXITSTATUS(status) != 0) << status << " " << output_;
-
-  status = GenerateOdexForTestWithStatus({invalid_dex.GetFilename()},
-                                         GetOdexDir() + "/output.odex",
-                                         CompilerFilter::kVerify,
-                                         &error_msg,
-                                         {});
-  ASSERT_TRUE(WIFEXITED(status) && WEXITSTATUS(status) != 0) << status << " " << output_;
+
+  EXPECT_THAT(GenerateOdexForTestWithStatus({invalid_dex_zip.GetFilename()},
+                                            GetOdexDir() + "/output_apk.odex",
+                                            CompilerFilter::kVerify,
+                                            /*extra_args*/ {}),
+              HasValue(Ne(0)))
+      << " " << output_;
+
+  EXPECT_THAT(GenerateOdexForTestWithStatus({invalid_dex.GetFilename()},
+                                            GetOdexDir() + "/output.odex",
+                                            CompilerFilter::kVerify,
+                                            /*extra_args*/ {}),
+              HasValue(Ne(0)))
+      << " " << output_;
 }
 
 TEST_F(Dex2oatWithExpectedFilterTest, AppImageNoProfile) {
@@ -1756,7 +1745,7 @@ TEST_F(Dex2oatTest, DontCopyPlainDex) {
   ASSERT_TRUE(GenerateOdexForTest(dex_location,
                                   odex_location,
                                   CompilerFilter::Filter::kVerify,
-                                  {},
+                                  /*extra_args=*/{},
                                   /*expect_success=*/true,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
@@ -1978,21 +1967,18 @@ TEST_F(LinkageTest, LinkageEnabled) {
   std::unique_ptr<const DexFile> dex(OpenTestDexFile("LinkageTest"));
   std::string out_dir = GetScratchDir();
   const std::string base_oat_name = out_dir + "/base.oat";
-  std::string error_msg;
-  const int res_fail =
+  EXPECT_THAT(
       GenerateOdexForTestWithStatus({dex->GetLocation()},
                                     base_oat_name,
                                     CompilerFilter::Filter::kSpeed,
-                                    &error_msg,
-                                    {"--check-linkage-conditions", "--crash-on-linkage-violation"});
-  EXPECT_NE(0, res_fail);
-
-  const int res_no_fail = GenerateOdexForTestWithStatus({dex->GetLocation()},
-                                                        base_oat_name,
-                                                        CompilerFilter::Filter::kSpeed,
-                                                        &error_msg,
-                                                        {"--check-linkage-conditions"});
-  EXPECT_EQ(0, res_no_fail);
+                                    {"--check-linkage-conditions", "--crash-on-linkage-violation"}),
+      Not(Ok()));
+
+  EXPECT_THAT(GenerateOdexForTestWithStatus({dex->GetLocation()},
+                                            base_oat_name,
+                                            CompilerFilter::Filter::kSpeed,
+                                            {"--check-linkage-conditions"}),
+              HasValue(0));
 }
 
 // Regression test for bug 179221298.
diff --git a/dex2oat/dex2oat_vdex_test.cc b/dex2oat/dex2oat_vdex_test.cc
index 27fcc180a5..afea20cadf 100644
--- a/dex2oat/dex2oat_vdex_test.cc
+++ b/dex2oat/dex2oat_vdex_test.cc
@@ -17,6 +17,8 @@
 #include <string>
 #include <vector>
 
+#include "android-base/result-gmock.h"
+#include "android-base/result.h"
 #include "common_runtime_test.h"
 #include "dex2oat_environment_test.h"
 #include "vdex_file.h"
@@ -24,6 +26,8 @@
 
 namespace art {
 
+using ::android::base::Result;
+using ::android::base::testing::HasValue;
 using verifier::VerifierDeps;
 
 class Dex2oatVdexTest : public Dex2oatEnvironmentTest {
@@ -32,16 +36,15 @@ class Dex2oatVdexTest : public Dex2oatEnvironmentTest {
     Dex2oatEnvironmentTest::TearDown();
 
     output_ = "";
-    error_msg_ = "";
     opened_vdex_files_.clear();
   }
 
  protected:
-  bool RunDex2oat(const std::string& dex_location,
-                  const std::string& odex_location,
-                  const std::string* public_sdk,
-                  bool copy_dex_files = false,
-                  const std::vector<std::string>& extra_args = {}) {
+  Result<bool> RunDex2oat(const std::string& dex_location,
+                          const std::string& odex_location,
+                          const std::string* public_sdk,
+                          bool copy_dex_files = false,
+                          const std::vector<std::string>& extra_args = {}) {
     std::vector<std::string> args;
     args.push_back("--dex-file=" + dex_location);
     args.push_back("--oat-file=" + odex_location);
@@ -62,25 +65,27 @@ class Dex2oatVdexTest : public Dex2oatEnvironmentTest {
 
     args.insert(args.end(), extra_args.begin(), extra_args.end());
 
-    return Dex2Oat(args, &output_, &error_msg_) == 0;
+    int status = OR_RETURN(Dex2Oat(args, &output_));
+    return status == 0;
   }
 
-  std::unique_ptr<VerifierDeps> GetVerifierDeps(const std::string& vdex_location,
-                                                const DexFile* dex_file) {
+  Result<std::unique_ptr<VerifierDeps>> GetVerifierDeps(const std::string& vdex_location,
+                                                        const DexFile* dex_file) {
     // Verify the vdex file content: only the classes using public APIs should be verified.
+    std::string error_msg;
     std::unique_ptr<VdexFile> vdex(VdexFile::Open(vdex_location,
                                                   /*writable=*/false,
                                                   /*low_4gb=*/false,
-                                                  &error_msg_));
+                                                  &error_msg));
     // Check the vdex doesn't have dex.
     if (vdex->HasDexSection()) {
-      ::testing::AssertionFailure() << "The vdex should not contain dex code";
+      return Errorf("The vdex {} should not contain dex code", vdex_location);
     }
 
     // Verify the deps.
     VdexFile::VdexFileHeader vdex_header = vdex->GetVdexFileHeader();
     if (!vdex_header.IsValid()) {
-      ::testing::AssertionFailure() << "Invalid vdex header";
+      return Errorf("Invalid vdex header in {}", vdex_location);
     }
 
     std::vector<const DexFile*> dex_files;
@@ -88,7 +93,7 @@ class Dex2oatVdexTest : public Dex2oatEnvironmentTest {
     std::unique_ptr<VerifierDeps> deps(new VerifierDeps(dex_files, /*output_only=*/false));
 
     if (!deps->ParseStoredData(dex_files, vdex->GetVerifierDepsData())) {
-      ::testing::AssertionFailure() << error_msg_;
+      return Errorf("{}", error_msg);
     }
 
     opened_vdex_files_.push_back(std::move(vdex));
@@ -131,7 +136,6 @@ class Dex2oatVdexTest : public Dex2oatEnvironmentTest {
   }
 
   std::string output_;
-  std::string error_msg_;
   std::vector<std::unique_ptr<VdexFile>> opened_vdex_files_;
 };
 
@@ -139,17 +143,17 @@ class Dex2oatVdexTest : public Dex2oatEnvironmentTest {
 // - create a vdex file contraints by a predefined list of public API (passed as separate dex)
 // - compile with the above vdex file as input to validate the compilation flow
 TEST_F(Dex2oatVdexTest, VerifyPublicSdkStubs) {
-  std::string error_msg;
-
   // Dex2oatVdexTestDex is the subject app using normal APIs found in the boot classpath.
   std::unique_ptr<const DexFile> dex_file(OpenTestDexFile("Dex2oatVdexTestDex"));
   // Dex2oatVdexPublicSdkDex serves as the public API-stubs, restricting what can be verified.
   const std::string api_dex_location = GetTestDexFileName("Dex2oatVdexPublicSdkDex");
 
   // Compile the subject app using the predefined API-stubs
-  ASSERT_TRUE(RunDex2oat(dex_file->GetLocation(), GetOdex(dex_file), &api_dex_location));
+  ASSERT_THAT(RunDex2oat(dex_file->GetLocation(), GetOdex(dex_file), &api_dex_location),
+              HasValue(true));
 
-  std::unique_ptr<VerifierDeps> deps = GetVerifierDeps(GetVdex(dex_file), dex_file.get());
+  std::unique_ptr<VerifierDeps> deps =
+      OR_ASSERT_FAIL(GetVerifierDeps(GetVdex(dex_file), dex_file.get()));
 
   // Verify public API usage. The classes should be verified.
   ASSERT_TRUE(HasVerifiedClass(deps, "LAccessPublicCtor;", *dex_file));
@@ -175,9 +179,11 @@ TEST_F(Dex2oatVdexTest, VerifyPublicSdkStubs) {
   std::vector<std::string> extra_args;
   extra_args.push_back("--dm-file=" + dm_file);
   output_ = "";
-  ASSERT_TRUE(RunDex2oat(dex_file->GetLocation(), GetOdex(dex_file), nullptr, false, extra_args));
+  ASSERT_THAT(RunDex2oat(dex_file->GetLocation(), GetOdex(dex_file), nullptr, false, extra_args),
+              HasValue(true));
 
-  std::unique_ptr<VerifierDeps> deps2 = GetVerifierDeps(GetVdex(dex_file), dex_file.get());
+  std::unique_ptr<VerifierDeps> deps2 =
+      OR_ASSERT_FAIL(GetVerifierDeps(GetVdex(dex_file), dex_file.get()));
 
   ASSERT_TRUE(HasVerifiedClass(deps2, "LAccessPublicCtor;", *dex_file));
   ASSERT_TRUE(HasVerifiedClass(deps2, "LAccessPublicMethod;", *dex_file));
@@ -194,16 +200,15 @@ TEST_F(Dex2oatVdexTest, VerifyPublicSdkStubs) {
 
 // Check that if the input dm does contain dex files then the compilation fails
 TEST_F(Dex2oatVdexTest, VerifyPublicSdkStubsWithDexFiles) {
-  std::string error_msg;
-
   // Dex2oatVdexTestDex is the subject app using normal APIs found in the boot classpath.
   std::unique_ptr<const DexFile> dex_file(OpenTestDexFile("Dex2oatVdexTestDex"));
 
   // Compile the subject app using the predefined API-stubs
-  ASSERT_TRUE(RunDex2oat(dex_file->GetLocation(),
+  ASSERT_THAT(RunDex2oat(dex_file->GetLocation(),
                          GetOdex(dex_file),
                          /*public_sdk=*/nullptr,
-                         /*copy_dex_files=*/true));
+                         /*copy_dex_files=*/true),
+              HasValue(true));
 
   // Create the .dm file with the output.
   std::string dm_file = GetScratchDir() + "/base.dm";
@@ -213,17 +218,16 @@ TEST_F(Dex2oatVdexTest, VerifyPublicSdkStubsWithDexFiles) {
 
   // Recompile again with the .dm file which contains a vdex with code.
   // The compilation will pass, but dex2oat will not use the vdex file.
-  ASSERT_TRUE(RunDex2oat(dex_file->GetLocation(),
+  ASSERT_THAT(RunDex2oat(dex_file->GetLocation(),
                          GetOdex(dex_file, "v2"),
                          /*public_sdk=*/nullptr,
                          /*copy_dex_files=*/true,
-                         extra_args));
+                         extra_args),
+              HasValue(true));
 }
 
 // Check that corrupt vdex files from .dm archives are ignored.
 TEST_F(Dex2oatVdexTest, VerifyCorruptVdexFile) {
-  std::string error_msg;
-
   // Dex2oatVdexTestDex is the subject app using normal APIs found in the boot classpath.
   std::unique_ptr<const DexFile> dex_file(OpenTestDexFile("Dex2oatVdexTestDex"));
 
@@ -236,25 +240,25 @@ TEST_F(Dex2oatVdexTest, VerifyCorruptVdexFile) {
   extra_args.push_back("--dm-file=" + dm_file);
 
   // Compile the dex file. Despite having a corrupt input .vdex, we should not crash.
-  ASSERT_TRUE(RunDex2oat(dex_file->GetLocation(),
+  ASSERT_THAT(RunDex2oat(dex_file->GetLocation(),
                          GetOdex(dex_file),
                          /*public_sdk=*/nullptr,
                          /*copy_dex_files=*/true,
-                         extra_args))
+                         extra_args),
+              HasValue(true))
       << output_;
 }
 
 // Check that if the input dm a vdex with mismatching checksums the compilation fails
 TEST_F(Dex2oatVdexTest, VerifyInputDmWithMismatchedChecksums) {
-  std::string error_msg;
-
   // Generate a vdex file for Dex2oatVdexTestDex.
   std::unique_ptr<const DexFile> dex_file(OpenTestDexFile("Dex2oatVdexTestDex"));
 
-  ASSERT_TRUE(RunDex2oat(dex_file->GetLocation(),
+  ASSERT_THAT(RunDex2oat(dex_file->GetLocation(),
                          GetOdex(dex_file),
                          /*public_sdk=*/nullptr,
-                         /*copy_dex_files=*/false));
+                         /*copy_dex_files=*/false),
+              HasValue(true));
 
   // Create the .dm file with the output.
   std::string dm_file = GetScratchDir() + "/base.dm";
@@ -265,11 +269,12 @@ TEST_F(Dex2oatVdexTest, VerifyInputDmWithMismatchedChecksums) {
   // Try to compile Main using an input dm which contains the vdex for
   // Dex2oatVdexTestDex. It should fail.
   std::unique_ptr<const DexFile> dex_file2(OpenTestDexFile("Main"));
-  ASSERT_FALSE(RunDex2oat(dex_file2->GetLocation(),
-                          GetOdex(dex_file2, "v2"),
-                          /*public_sdk=*/nullptr,
-                          /*copy_dex_files=*/false,
-                          extra_args))
+  ASSERT_THAT(RunDex2oat(dex_file2->GetLocation(),
+                         GetOdex(dex_file2, "v2"),
+                         /*public_sdk=*/nullptr,
+                         /*copy_dex_files=*/false,
+                         extra_args),
+              HasValue(false))
       << output_;
 }
 
diff --git a/dex2oat/driver/compiler_driver.cc b/dex2oat/driver/compiler_driver.cc
index b01e9af495..5399f1cd7e 100644
--- a/dex2oat/driver/compiler_driver.cc
+++ b/dex2oat/driver/compiler_driver.cc
@@ -25,9 +25,10 @@
 #include <string_view>
 #include <vector>
 
-#include "android-base/logging.h"
-#include "android-base/strings.h"
+#include <android-base/logging.h>
+#include <android-base/strings.h>
 
+#include "aot_class_linker.h"
 #include "art_field-inl.h"
 #include "art_method-inl.h"
 #include "base/arena_allocator.h"
@@ -72,7 +73,6 @@
 #include "mirror/object-refvisitor-inl.h"
 #include "mirror/object_array-inl.h"
 #include "mirror/throwable.h"
-#include "oat/aot_class_linker.h"
 #include "object_lock.h"
 #include "profile/profile_compilation_info.h"
 #include "runtime.h"
@@ -437,7 +437,7 @@ static bool ShouldCompileBasedOnProfile(const CompilerOptions& compiler_options,
 
     // On non-low RAM devices, compile startup methods to potentially speed up
     // startup.
-    if (!result && Runtime::Current()->GetHeap()->IsLowMemoryMode()) {
+    if (!result && !Runtime::Current()->GetHeap()->IsLowMemoryMode()) {
       result = profile_compilation_info->IsStartupMethod(profile_index, method_ref.index);
     }
 
diff --git a/runtime/interpreter/interpreter_switch_impl1.cc b/dex2oat/interpreter/interpreter_switch_impl1.cc
similarity index 98%
rename from runtime/interpreter/interpreter_switch_impl1.cc
rename to dex2oat/interpreter/interpreter_switch_impl1.cc
index 9c5b5b3266..c7e2ed1ad3 100644
--- a/runtime/interpreter/interpreter_switch_impl1.cc
+++ b/dex2oat/interpreter/interpreter_switch_impl1.cc
@@ -17,9 +17,9 @@
 // The interpreter function takes considerable time to compile and link.
 // We compile the explicit definitions separately to speed up the build.
 
-#include "interpreter_switch_impl-inl.h"
+#include "interpreter/interpreter_switch_impl-inl.h"
 
-#include "oat/aot_class_linker.h"
+#include "aot_class_linker.h"
 #include "transaction.h"
 
 namespace art HIDDEN {
diff --git a/runtime/interpreter/unstarted_runtime_transaction_test.cc b/dex2oat/interpreter/unstarted_runtime_transaction_test.cc
similarity index 99%
rename from runtime/interpreter/unstarted_runtime_transaction_test.cc
rename to dex2oat/interpreter/unstarted_runtime_transaction_test.cc
index abbcbbb12e..ec308c2c18 100644
--- a/runtime/interpreter/unstarted_runtime_transaction_test.cc
+++ b/dex2oat/interpreter/unstarted_runtime_transaction_test.cc
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "unstarted_runtime_test.h"
+#include "interpreter/unstarted_runtime_test.h"
 
 #include "class_root-inl.h"
 #include "common_transaction_test.h"
diff --git a/dex2oat/linker/image_writer.cc b/dex2oat/linker/image_writer.cc
index b3399fed0c..41cf1edaf8 100644
--- a/dex2oat/linker/image_writer.cc
+++ b/dex2oat/linker/image_writer.cc
@@ -78,6 +78,7 @@
 #include "nterp_helpers.h"
 #include "oat/elf_file.h"
 #include "oat/image-inl.h"
+#include "oat/jni_stub_hash_map-inl.h"
 #include "oat/oat.h"
 #include "oat/oat_file.h"
 #include "oat/oat_file_manager.h"
diff --git a/dex2oat/linker/oat_writer.cc b/dex2oat/linker/oat_writer.cc
index 78b3f972f1..0ea446a0a2 100644
--- a/dex2oat/linker/oat_writer.cc
+++ b/dex2oat/linker/oat_writer.cc
@@ -359,7 +359,6 @@ OatWriter::OatWriter(const CompilerOptions& compiler_options,
       primary_oat_file_(false),
       vdex_size_(0u),
       vdex_dex_files_offset_(0u),
-      vdex_dex_shared_data_offset_(0u),
       vdex_verifier_deps_offset_(0u),
       vdex_lookup_tables_offset_(0u),
       oat_checksum_(adler32(0L, Z_NULL, 0)),
@@ -431,10 +430,6 @@ bool OatWriter::AddDexFileSource(File&& dex_file_fd, const char* location) {
     return false;
   }
   for (auto& dex_file : dex_files) {
-    if (dex_file->IsCompactDexFile()) {
-      LOG(ERROR) << "Compact dex is only supported from vdex: " << location;
-      return false;
-    }
     oat_dex_files_.emplace_back(std::move(dex_file));
   }
   return true;
@@ -2172,7 +2167,7 @@ size_t OatWriter::InitIndexBssMappingsHelper(size_t offset,
     offset += CalculateIndexBssMappingSize(dex_file->NumMethodIds(),
                                            static_cast<size_t>(pointer_size),
                                            method_indexes,
-                                           [=](uint32_t index) {
+                                           [this, dex_file](uint32_t index) {
                                              return bss_method_entries_.Get({dex_file, index});
                                            });
   }
@@ -2210,7 +2205,7 @@ size_t OatWriter::InitIndexBssMappingsHelper(size_t offset,
         dex_file->NumStringIds(),
         sizeof(GcRoot<mirror::String>),
         string_indexes,
-        [=](uint32_t index) {
+        [this, dex_file](uint32_t index) {
           return bss_string_entries_.Get({dex_file, dex::StringIndex(index)});
         });
   }
@@ -2224,7 +2219,7 @@ size_t OatWriter::InitIndexBssMappingsHelper(size_t offset,
         dex_file->NumProtoIds(),
         sizeof(GcRoot<mirror::MethodType>),
         proto_indexes,
-        [=](uint32_t index) {
+        [this, dex_file](uint32_t index) {
           return bss_method_type_entries_.Get({dex_file, dex::ProtoIndex(index)});
         });
   }
@@ -2358,7 +2353,7 @@ size_t OatWriter::InitOatCodeDexFiles(size_t offset) {
 
   if (HasImage()) {
     ScopedObjectAccess soa(Thread::Current());
-    ScopedAssertNoThreadSuspension sants("Init image method visitor", Thread::Current());
+    ScopedAssertNoThreadSuspension sants("Init image method visitor");
     InitImageMethodVisitor image_visitor(this, offset, dex_files_);
     success = VisitDexMethods(&image_visitor);
     image_visitor.Postprocess();
@@ -2894,7 +2889,7 @@ size_t OatWriter::WriteIndexBssMappingsHelper(OutputStream* out,
                              dex_file->NumMethodIds(),
                              static_cast<size_t>(pointer_size),
                              method_indexes,
-                             [=](uint32_t index) {
+                             [this, dex_file](uint32_t index) {
                                return bss_method_entries_.Get({dex_file, index});
                              });
     if (method_mappings_size == 0u) {
@@ -2964,7 +2959,7 @@ size_t OatWriter::WriteIndexBssMappingsHelper(OutputStream* out,
                              dex_file->NumStringIds(),
                              sizeof(GcRoot<mirror::String>),
                              string_indexes,
-                             [=](uint32_t index) {
+                             [this, dex_file](uint32_t index) {
                                return bss_string_entries_.Get({dex_file, dex::StringIndex(index)});
                              });
     if (string_mappings_size == 0u) {
@@ -2986,7 +2981,7 @@ size_t OatWriter::WriteIndexBssMappingsHelper(OutputStream* out,
                              dex_file->NumProtoIds(),
                              sizeof(GcRoot<mirror::MethodType>),
                              method_type_indexes,
-                             [=](uint32_t index) {
+                             [this, dex_file](uint32_t index) {
                                return bss_method_type_entries_
                                    .Get({dex_file, dex::ProtoIndex(index)});
                              });
@@ -3275,9 +3270,6 @@ bool OatWriter::WriteDexFiles(File* file,
     TimingLogger::ScopedTiming split2("Verify input Dex files", timings_);
     for (OatDexFile& oat_dex_file : oat_dex_files_) {
       const DexFile* dex_file = oat_dex_file.GetDexFile();
-      if (dex_file->IsCompactDexFile()) {
-        continue;  // Compact dex files can not be verified.
-      }
       std::string error_msg;
       if (!dex::Verify(dex_file,
                        dex_file->GetLocation().c_str(),
@@ -3307,37 +3299,6 @@ bool OatWriter::WriteDexFiles(File* file,
       }
       vdex_size_with_dex_files += oat_dex_file.dex_file_size_;
     }
-    // Add the shared data section size.
-    const uint8_t* raw_dex_file_shared_data_begin = nullptr;
-    uint32_t shared_data_size = 0u;
-    // Dex files from input vdex are represented as raw dex files and they can be
-    // compact dex files. These need to specify the same shared data section if any.
-    for (const OatDexFile& oat_dex_file : oat_dex_files_) {
-      const DexFile* dex_file = oat_dex_file.GetDexFile();
-      auto& header = dex_file->GetHeader();
-      if (!dex_file->IsCompactDexFile() || header.data_size_ == 0u) {
-        // Non compact dex does not have shared data section.
-        continue;
-      }
-      const uint8_t* cur_data_begin = dex_file->Begin() + header.data_off_;
-      if (raw_dex_file_shared_data_begin == nullptr) {
-        raw_dex_file_shared_data_begin = cur_data_begin;
-      } else if (raw_dex_file_shared_data_begin != cur_data_begin) {
-        LOG(ERROR) << "Mismatched shared data sections in raw dex files: "
-                   << static_cast<const void*>(raw_dex_file_shared_data_begin)
-                   << " != " << static_cast<const void*>(cur_data_begin);
-        return false;
-      }
-      // The different dex files currently can have different data sizes since
-      // the dex writer writes them one at a time into the shared section.:w
-      shared_data_size = std::max(shared_data_size, header.data_size_);
-    }
-    if (shared_data_size != 0u) {
-      // Shared data section is required to be 4 byte aligned.
-      vdex_size_with_dex_files = RoundUp(vdex_size_with_dex_files, 4u);
-    }
-    vdex_dex_shared_data_offset_ = vdex_size_with_dex_files;
-    vdex_size_with_dex_files += shared_data_size;
 
     // Extend the file and include the full page at the end as we need to write
     // additional data there and do not want to mmap that page twice.
@@ -3393,40 +3354,7 @@ bool OatWriter::WriteDexFiles(File* file,
       size_dex_file_ += oat_dex_file.dex_file_size_;
     }
 
-    // Write shared dex file data section and fix up the dex file headers.
-    if (shared_data_size != 0u) {
-      DCHECK_EQ(RoundUp(vdex_size_, 4u), vdex_dex_shared_data_offset_);
-      if (!use_existing_vdex) {
-        memset(vdex_begin_ + vdex_size_, 0, vdex_dex_shared_data_offset_ - vdex_size_);
-      }
-      size_dex_file_alignment_ += vdex_dex_shared_data_offset_ - vdex_size_;
-      vdex_size_ = vdex_dex_shared_data_offset_;
-
-      if (!use_existing_vdex) {
-        memcpy(vdex_begin_ + vdex_size_, raw_dex_file_shared_data_begin, shared_data_size);
-      }
-      vdex_size_ += shared_data_size;
-      size_dex_file_ += shared_data_size;
-      if (!use_existing_vdex) {
-        // Fix up the dex headers to have correct offsets to the data section.
-        for (OatDexFile& oat_dex_file : oat_dex_files_) {
-          DexFile::Header* header =
-              reinterpret_cast<DexFile::Header*>(vdex_begin_ + oat_dex_file.dex_file_offset_);
-          if (!CompactDexFile::IsMagicValid(header->magic_)) {
-            // Non-compact dex file, probably failed to convert due to duplicate methods.
-            continue;
-          }
-          CHECK_GT(vdex_dex_shared_data_offset_, oat_dex_file.dex_file_offset_);
-          // Offset is from the dex file base.
-          header->data_off_ = vdex_dex_shared_data_offset_ - oat_dex_file.dex_file_offset_;
-          // The size should already be what part of the data buffer may be used by the dex.
-          CHECK_LE(header->data_size_, shared_data_size);
-        }
-      }
-    }
     opened_dex_files_map->push_back(std::move(dex_files_map));
-  } else {
-    vdex_dex_shared_data_offset_ = vdex_size_;
   }
 
   if (use_existing_vdex) {
diff --git a/dex2oat/linker/oat_writer.h b/dex2oat/linker/oat_writer.h
index 6cd9a7f71c..f2b239252c 100644
--- a/dex2oat/linker/oat_writer.h
+++ b/dex2oat/linker/oat_writer.h
@@ -395,9 +395,6 @@ class OatWriter {
   // Offset of section holding Dex files inside Vdex.
   size_t vdex_dex_files_offset_;
 
-  // Offset of section holding shared dex data section in the Vdex.
-  size_t vdex_dex_shared_data_offset_;
-
   // Offset of section holding VerifierDeps inside Vdex.
   size_t vdex_verifier_deps_offset_;
 
diff --git a/dex2oat/linker/oat_writer_test.cc b/dex2oat/linker/oat_writer_test.cc
index 4bcf29804c..8486bff0d3 100644
--- a/dex2oat/linker/oat_writer_test.cc
+++ b/dex2oat/linker/oat_writer_test.cc
@@ -502,7 +502,7 @@ TEST_F(OatTest, OatHeaderSizeCheck) {
   EXPECT_EQ(68U, sizeof(OatHeader));
   EXPECT_EQ(4U, sizeof(OatMethodOffsets));
   EXPECT_EQ(4U, sizeof(OatQuickMethodHeader));
-  EXPECT_EQ(170 * static_cast<size_t>(GetInstructionSetPointerSize(kRuntimeISA)),
+  EXPECT_EQ(173 * static_cast<size_t>(GetInstructionSetPointerSize(kRuntimeISA)),
             sizeof(QuickEntryPoints));
 }
 
diff --git a/runtime/sdk_checker.cc b/dex2oat/sdk_checker.cc
similarity index 100%
rename from runtime/sdk_checker.cc
rename to dex2oat/sdk_checker.cc
diff --git a/runtime/sdk_checker.h b/dex2oat/sdk_checker.h
similarity index 96%
rename from runtime/sdk_checker.h
rename to dex2oat/sdk_checker.h
index 08e4479846..a409d59981 100644
--- a/runtime/sdk_checker.h
+++ b/dex2oat/sdk_checker.h
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef ART_RUNTIME_SDK_CHECKER_H_
-#define ART_RUNTIME_SDK_CHECKER_H_
+#ifndef ART_DEX2OAT_SDK_CHECKER_H_
+#define ART_DEX2OAT_SDK_CHECKER_H_
 
 #include "art_field.h"
 #include "art_method.h"
@@ -74,4 +74,4 @@ class SdkChecker {
 
 }  // namespace art
 
-#endif  // ART_RUNTIME_SDK_CHECKER_H_
+#endif  // ART_DEX2OAT_SDK_CHECKER_H_
diff --git a/runtime/transaction.cc b/dex2oat/transaction.cc
similarity index 93%
rename from runtime/transaction.cc
rename to dex2oat/transaction.cc
index 9b3985503a..eb7eea31bb 100644
--- a/runtime/transaction.cc
+++ b/dex2oat/transaction.cc
@@ -18,6 +18,7 @@
 
 #include <android-base/logging.h>
 
+#include "aot_class_linker.h"
 #include "base/mutex-inl.h"
 #include "base/stl_util.h"
 #include "common_throws.h"
@@ -30,7 +31,6 @@
 #include "mirror/dex_cache-inl.h"
 #include "mirror/object-inl.h"
 #include "mirror/object_array-inl.h"
-#include "oat/aot_class_linker.h"
 #include "obj_ptr-inl.h"
 #include "runtime.h"
 
@@ -57,8 +57,7 @@ Transaction::Transaction(bool strict,
       heap_(Runtime::Current()->GetHeap()),
       strict_(strict),
       root_(root),
-      last_allocated_object_(nullptr),
-      assert_no_new_records_reason_(nullptr) {
+      last_allocated_object_(nullptr) {
   DCHECK(Runtime::Current()->IsAotCompiler());
   DCHECK_NE(arena_stack != nullptr, arena_pool != nullptr);
 }
@@ -210,7 +209,6 @@ void Transaction::RecordWriteFieldBoolean(mirror::Object* obj,
                                           uint8_t value,
                                           bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.LogBooleanValue(field_offset, value, is_volatile);
@@ -222,7 +220,6 @@ void Transaction::RecordWriteFieldByte(mirror::Object* obj,
                                        int8_t value,
                                        bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.LogByteValue(field_offset, value, is_volatile);
@@ -234,7 +231,6 @@ void Transaction::RecordWriteFieldChar(mirror::Object* obj,
                                        uint16_t value,
                                        bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.LogCharValue(field_offset, value, is_volatile);
@@ -247,7 +243,6 @@ void Transaction::RecordWriteFieldShort(mirror::Object* obj,
                                         int16_t value,
                                         bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.LogShortValue(field_offset, value, is_volatile);
@@ -260,7 +255,6 @@ void Transaction::RecordWriteField32(mirror::Object* obj,
                                      uint32_t value,
                                      bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.Log32BitsValue(field_offset, value, is_volatile);
@@ -272,7 +266,6 @@ void Transaction::RecordWriteField64(mirror::Object* obj,
                                      uint64_t value,
                                      bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.Log64BitsValue(field_offset, value, is_volatile);
@@ -284,7 +277,6 @@ void Transaction::RecordWriteFieldReference(mirror::Object* obj,
                                             mirror::Object* value,
                                             bool is_volatile) {
   DCHECK(obj != nullptr);
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (obj != last_allocated_object_) {
     ObjectLog& object_log = GetOrCreateObjectLog(obj);
     object_log.LogReferenceValue(field_offset, value, is_volatile);
@@ -295,7 +287,6 @@ void Transaction::RecordWriteArray(mirror::Array* array, size_t index, uint64_t
   DCHECK(array != nullptr);
   DCHECK(array->IsArrayInstance());
   DCHECK(!array->IsObjectArray());
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   if (array != last_allocated_object_) {
     ArrayLog& array_log = array_logs_.GetOrCreate(array, [&]() { return ArrayLog(&allocator_); });
     array_log.LogValue(index, value);
@@ -306,7 +297,6 @@ void Transaction::RecordResolveString(ObjPtr<mirror::DexCache> dex_cache,
                                       dex::StringIndex string_idx) {
   DCHECK(dex_cache != nullptr);
   DCHECK_LT(string_idx.index_, dex_cache->GetDexFile()->NumStringIds());
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   resolve_string_logs_.emplace_front(dex_cache, string_idx);
 }
 
@@ -314,7 +304,6 @@ void Transaction::RecordResolveMethodType(ObjPtr<mirror::DexCache> dex_cache,
                                           dex::ProtoIndex proto_idx) {
   DCHECK(dex_cache != nullptr);
   DCHECK_LT(proto_idx.index_, dex_cache->GetDexFile()->NumProtoIds());
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   resolve_method_type_logs_.emplace_front(dex_cache, proto_idx);
 }
 
@@ -340,7 +329,6 @@ void Transaction::RecordWeakStringRemoval(ObjPtr<mirror::String> s) {
 
 void Transaction::LogInternedString(InternStringLog&& log) {
   Locks::intern_table_lock_->AssertExclusiveHeld(Thread::Current());
-  DCHECK(assert_no_new_records_reason_ == nullptr) << assert_no_new_records_reason_;
   intern_string_logs_.push_front(std::move(log));
 }
 
@@ -801,27 +789,4 @@ void Transaction::ArrayLog::UndoArrayWrite(mirror::Array* array,
   }
 }
 
-Transaction* ScopedAssertNoNewTransactionRecords::InstallAssertion(const char* reason) {
-  Transaction* transaction = nullptr;
-  if (kIsDebugBuild && Runtime::Current()->IsActiveTransaction()) {
-    AotClassLinker* class_linker = down_cast<AotClassLinker*>(Runtime::Current()->GetClassLinker());
-    transaction = class_linker->GetTransaction();
-    if (transaction != nullptr) {
-      CHECK(transaction->assert_no_new_records_reason_ == nullptr)
-          << "old: " << transaction->assert_no_new_records_reason_ << " new: " << reason;
-      transaction->assert_no_new_records_reason_ = reason;
-    }
-  }
-  return transaction;
-}
-
-void ScopedAssertNoNewTransactionRecords::RemoveAssertion(Transaction* transaction) {
-  if (kIsDebugBuild) {
-    AotClassLinker* class_linker = down_cast<AotClassLinker*>(Runtime::Current()->GetClassLinker());
-    CHECK(class_linker->GetTransaction() == transaction);
-    CHECK(transaction->assert_no_new_records_reason_ != nullptr);
-    transaction->assert_no_new_records_reason_ = nullptr;
-  }
-}
-
 }  // namespace art
diff --git a/runtime/transaction.h b/dex2oat/transaction.h
similarity index 95%
rename from runtime/transaction.h
rename to dex2oat/transaction.h
index 60d1b3e3fd..79041e321f 100644
--- a/runtime/transaction.h
+++ b/dex2oat/transaction.h
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef ART_RUNTIME_TRANSACTION_H_
-#define ART_RUNTIME_TRANSACTION_H_
+#ifndef ART_DEX2OAT_TRANSACTION_H_
+#define ART_DEX2OAT_TRANSACTION_H_
 
 #include "base/scoped_arena_containers.h"
 #include "base/macros.h"
@@ -380,31 +380,10 @@ class Transaction final {
   std::string abort_message_;
   mirror::Class* root_;
   mirror::Object* last_allocated_object_;
-  const char* assert_no_new_records_reason_;
-
-  friend class ScopedAssertNoNewTransactionRecords;
 
   DISALLOW_COPY_AND_ASSIGN(Transaction);
 };
 
-class ScopedAssertNoNewTransactionRecords {
- public:
-  explicit ScopedAssertNoNewTransactionRecords(const char* reason)
-    : transaction_(kIsDebugBuild ? InstallAssertion(reason) : nullptr) {}
-
-  ~ScopedAssertNoNewTransactionRecords() {
-    if (kIsDebugBuild && transaction_ != nullptr) {
-      RemoveAssertion(transaction_);
-    }
-  }
-
- private:
-  static Transaction* InstallAssertion(const char* reason);
-  static void RemoveAssertion(Transaction* transaction);
-
-  Transaction* transaction_;
-};
-
 }  // namespace art
 
-#endif  // ART_RUNTIME_TRANSACTION_H_
+#endif  // ART_DEX2OAT_TRANSACTION_H_
diff --git a/runtime/transaction_test.cc b/dex2oat/transaction_test.cc
similarity index 100%
rename from runtime/transaction_test.cc
rename to dex2oat/transaction_test.cc
diff --git a/dex2oat/verifier_deps_test.cc b/dex2oat/verifier_deps_test.cc
index 1ede9e07bc..2cddcedcfa 100644
--- a/dex2oat/verifier_deps_test.cc
+++ b/dex2oat/verifier_deps_test.cc
@@ -17,6 +17,7 @@
 // Test is in compiler, as it uses compiler related code.
 #include "verifier/verifier_deps.h"
 
+#include "aot_class_linker.h"
 #include "art_method-inl.h"
 #include "base/indenter.h"
 #include "class_linker.h"
@@ -46,6 +47,10 @@ class VerifierDepsCompilerCallbacks : public CompilerCallbacks {
       : CompilerCallbacks(CompilerCallbacks::CallbackMode::kCompileApp),
         deps_(nullptr) {}
 
+  ClassLinker* CreateAotClassLinker(InternTable* intern_table) override {
+    return new AotClassLinker(intern_table);
+  }
+
   void AddUncompilableMethod([[maybe_unused]] MethodReference ref) override {}
   void AddUncompilableClass([[maybe_unused]] ClassReference ref) override {}
   void ClassRejected([[maybe_unused]] ClassReference ref) override {}
diff --git a/dexdump/dexdump.cc b/dexdump/dexdump.cc
index fd42454007..ce0eb130fb 100644
--- a/dexdump/dexdump.cc
+++ b/dexdump/dexdump.cc
@@ -47,13 +47,13 @@
 #include "android-base/file.h"
 #include "android-base/logging.h"
 #include "android-base/stringprintf.h"
-
 #include "base/bit_utils.h"
 #include "dex/class_accessor-inl.h"
 #include "dex/code_item_accessors-inl.h"
 #include "dex/dex_file-inl.h"
 #include "dex/dex_file_exception_helpers.h"
 #include "dex/dex_file_loader.h"
+#include "dex/dex_file_structs.h"
 #include "dex/dex_file_types.h"
 #include "dex/dex_instruction-inl.h"
 #include "dexdump_cfg.h"
@@ -94,10 +94,13 @@ struct FieldMethodInfo {
 /*
  * Flags for use with createAccessFlagStr().
  */
-enum AccessFor {
-  kAccessForClass = 0, kAccessForMethod = 1, kAccessForField = 2, kAccessForMAX
+enum class AccessFor {
+  kClass = 0,
+  kMethod = 1,
+  kField = 2,
+  kCount
 };
-const int kNumFlags = 18;
+static constexpr int kNumFlags = 18;
 
 /*
  * Gets 2 little-endian bytes.
@@ -240,7 +243,7 @@ static int countOnes(u4 val) {
  * they're u4.
  */
 static char* createAccessFlagStr(u4 flags, AccessFor forWhat) {
-  static const char* kAccessStrings[kAccessForMAX][kNumFlags] = {
+  static constexpr const char* kAccessStrings[static_cast<int>(AccessFor::kCount)][kNumFlags] = {
     {
       "PUBLIC",                /* 0x00001 */
       "PRIVATE",               /* 0x00002 */
@@ -304,7 +307,7 @@ static char* createAccessFlagStr(u4 flags, AccessFor forWhat) {
   // Allocate enough storage to hold the expected number of strings,
   // plus a space between each.  We over-allocate, using the longest
   // string above as the base metric.
-  const int kLongest = 21;  // The strlen of longest string above.
+  static constexpr int kLongest = 21;  // The strlen of longest string above.
   const int count = countOnes(flags);
   char* str;
   char* cp;
@@ -312,7 +315,7 @@ static char* createAccessFlagStr(u4 flags, AccessFor forWhat) {
 
   for (int i = 0; i < kNumFlags; i++) {
     if (flags & 0x01) {
-      const char* accessStr = kAccessStrings[forWhat][i];
+      const char* accessStr = kAccessStrings[static_cast<int>(forWhat)][i];
       const int len = strlen(accessStr);
       if (cp != str) {
         *cp++ = ' ';
@@ -575,6 +578,17 @@ static void dumpEncodedValue(const DexFile* pDexFile, const u1** data, u1 type,
       fprintf(gOutFile, "%g", conv.d);
       break;
     }
+    case DexFile::kDexAnnotationMethodType: {
+      const u4 proto_idx = static_cast<u4>(readVarWidth(data, arg, false));
+      const dex::ProtoId& pProtoId = pDexFile->GetProtoId(dex::ProtoIndex(proto_idx));
+      fputs(pDexFile->GetProtoSignature(pProtoId).ToString().c_str(), gOutFile);
+      break;
+    }
+    case DexFile::kDexAnnotationMethodHandle: {
+      const u4 method_handle_idx = static_cast<u4>(readVarWidth(data, arg, false));
+      fprintf(gOutFile, "method_handle@%u", method_handle_idx);
+      break;
+    }
     case DexFile::kDexAnnotationString: {
       const u4 idx = static_cast<u4>(readVarWidth(data, arg, false));
       if (gOptions.outputFormat == OUTPUT_PLAIN) {
@@ -1357,7 +1371,7 @@ static void dumpMethod(const ClassAccessor::Method& method, int i) {
   const Signature signature = dex_file.GetMethodSignature(pMethodId);
   char* typeDescriptor = strdup(signature.ToString().c_str());
   const char* backDescriptor = dex_file.GetTypeDescriptor(pMethodId.class_idx_);
-  char* accessStr = createAccessFlagStr(flags, kAccessForMethod);
+  char* accessStr = createAccessFlagStr(flags, AccessFor::kMethod);
   const uint32_t hiddenapiFlags = method.GetHiddenapiFlags();
 
   if (gOptions.outputFormat == OUTPUT_PLAIN) {
@@ -1477,7 +1491,7 @@ static void dumpField(const ClassAccessor::Field& field, int i, const u1** data
   const char* name = dex_file.GetStringData(field_id.name_idx_);
   const char* typeDescriptor = dex_file.GetTypeDescriptor(field_id.type_idx_);
   const char* backDescriptor = dex_file.GetTypeDescriptor(field_id.class_idx_);
-  char* accessStr = createAccessFlagStr(flags, kAccessForField);
+  char* accessStr = createAccessFlagStr(flags, AccessFor::kField);
   const uint32_t hiddenapiFlags = field.GetHiddenapiFlags();
 
   if (gOptions.outputFormat == OUTPUT_PLAIN) {
@@ -1602,7 +1616,7 @@ static void dumpClass(const DexFile* pDexFile, int idx, char** pLastPackage) {
   }
 
   // General class information.
-  char* accessStr = createAccessFlagStr(pClassDef.access_flags_, kAccessForClass);
+  char* accessStr = createAccessFlagStr(pClassDef.access_flags_, AccessFor::kClass);
   const char* superclassDescriptor;
   if (!pClassDef.superclass_idx_.IsValid()) {
     superclassDescriptor = nullptr;
diff --git a/dexopt_chroot_setup/Android.bp b/dexopt_chroot_setup/Android.bp
index eb511f99d8..0b4ce9669d 100644
--- a/dexopt_chroot_setup/Android.bp
+++ b/dexopt_chroot_setup/Android.bp
@@ -39,6 +39,11 @@ cc_defaults {
         "dexopt_chroot_setup-aidl-ndk",
         "libfstab",
     ],
+    target: {
+        android: {
+            compile_multilib: "first",
+        },
+    },
 }
 
 art_cc_binary {
diff --git a/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml b/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml
index a89221f4ae..e4ba301579 100644
--- a/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml
+++ b/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml
@@ -15,6 +15,7 @@
 -->
 <!-- Note: This test config file for {MODULE} is generated from a template. -->
 <configuration description="Runs {MODULE}.">
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.art.apex" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.android.art.apex" />
 
@@ -23,19 +24,13 @@
     <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer" />
     <target_preparer class="com.android.tradefed.targetprep.DisableSELinuxTargetPreparer" />
 
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
         <option name="cleanup" value="true" />
-        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}/{MODULE}" />
-        <option name="append-bitness" value="true" />
-    </target_preparer>
-
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-        <option name="cleanup" value="true" />
-        <option name="push" value="art-gtest-jars-Main.jar->/data/local/tmp/{MODULE}/art-gtest-jars-Main.jar" />
+        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
     </target_preparer>
 
     <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/{MODULE}" />
+        <option name="native-test-device-path" value="/data/local/tmp" />
         <option name="module-name" value="{MODULE}" />
     </test>
 
diff --git a/dexopt_chroot_setup/binder/com/android/server/art/IDexoptChrootSetup.aidl b/dexopt_chroot_setup/binder/com/android/server/art/IDexoptChrootSetup.aidl
index f8770147fc..867fdf9e38 100644
--- a/dexopt_chroot_setup/binder/com/android/server/art/IDexoptChrootSetup.aidl
+++ b/dexopt_chroot_setup/binder/com/android/server/art/IDexoptChrootSetup.aidl
@@ -38,6 +38,12 @@ interface IDexoptChrootSetup {
      */
     void init();
 
-    /** Tears down the chroot environment. */
-    void tearDown();
+    /**
+     * Tears down the chroot environment.
+     *
+     * @param allowConcurrent If true, allows this method to be called concurrently when another
+     * call to the service is still being processed. Note that the service does not process this
+     * call concurrently but waits until the other call is done.
+     */
+    void tearDown(boolean allowConcurrent);
 }
diff --git a/dexopt_chroot_setup/dexopt_chroot_setup.cc b/dexopt_chroot_setup/dexopt_chroot_setup.cc
index 3d9c6e3b9c..7a1467a149 100644
--- a/dexopt_chroot_setup/dexopt_chroot_setup.cc
+++ b/dexopt_chroot_setup/dexopt_chroot_setup.cc
@@ -22,14 +22,19 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
+#include <algorithm>
+#include <cerrno>
 #include <chrono>
 #include <cstring>
 #include <filesystem>
+#include <iterator>
 #include <mutex>
 #include <optional>
+#include <regex>
 #include <string>
 #include <string_view>
 #include <system_error>
+#include <tuple>
 #include <vector>
 
 #include "aidl/com/android/server/art/BnDexoptChrootSetup.h"
@@ -39,6 +44,7 @@
 #include "android-base/no_destructor.h"
 #include "android-base/properties.h"
 #include "android-base/result.h"
+#include "android-base/scopeguard.h"
 #include "android-base/strings.h"
 #include "android/binder_auto_utils.h"
 #include "android/binder_manager.h"
@@ -46,6 +52,8 @@
 #include "base/file_utils.h"
 #include "base/macros.h"
 #include "base/os.h"
+#include "base/stl_util.h"
+#include "base/utils.h"
 #include "exec_utils.h"
 #include "fstab/fstab.h"
 #include "tools/binder_utils.h"
@@ -59,7 +67,9 @@ namespace {
 
 using ::android::base::ConsumePrefix;
 using ::android::base::Error;
+using ::android::base::GetProperty;
 using ::android::base::Join;
+using ::android::base::make_scope_guard;
 using ::android::base::NoDestructor;
 using ::android::base::ReadFileToString;
 using ::android::base::Result;
@@ -85,6 +95,8 @@ const NoDestructor<std::string> kSnapshotMappedFile(
     std::string(DexoptChrootSetup::PRE_REBOOT_DEXOPT_DIR) + "/snapshot_mapped");
 constexpr mode_t kChrootDefaultMode = 0755;
 constexpr std::chrono::milliseconds kSnapshotCtlTimeout = std::chrono::seconds(60);
+constexpr std::array<const char*, 4> kExternalLibDirs = {
+    "/system/lib", "/system/lib64", "/system_ext/lib", "/system_ext/lib64"};
 
 bool IsOtaUpdate(const std::optional<std::string>& ota_slot) { return ota_slot.has_value(); }
 
@@ -122,18 +134,38 @@ Result<void> CreateDir(const std::string& path) {
   return {};
 }
 
-Result<void> Unmount(const std::string& target) {
+Result<void> Unmount(const std::string& target, bool logging = true) {
   if (umount2(target.c_str(), UMOUNT_NOFOLLOW) == 0) {
+    LOG_IF(INFO, logging) << ART_FORMAT("Unmounted '{}'", target);
     return {};
   }
   LOG(WARNING) << ART_FORMAT(
       "Failed to umount2 '{}': {}. Retrying with MNT_DETACH", target, strerror(errno));
   if (umount2(target.c_str(), UMOUNT_NOFOLLOW | MNT_DETACH) == 0) {
+    LOG_IF(INFO, logging) << ART_FORMAT("Unmounted '{}' with MNT_DETACH", target);
     return {};
   }
   return ErrnoErrorf("Failed to umount2 '{}'", target);
 }
 
+// Bind-mounts `source` at `target` with the mount propagation type being "shared". You generally
+// want to use `BindMount` instead.
+//
+// `BindMountDirect` is safe to use only if there is no child mount points under `target`. DO NOT
+// mount or unmount under `target` because mount events propagate to `source`.
+Result<void> BindMountDirect(const std::string& source, const std::string& target) {
+  if (mount(source.c_str(),
+            target.c_str(),
+            /*fs_type=*/nullptr,
+            MS_BIND,
+            /*data=*/nullptr) != 0) {
+    return ErrnoErrorf("Failed to bind-mount '{}' at '{}'", source, target);
+  }
+  LOG(INFO) << ART_FORMAT("Bind-mounted '{}' at '{}'", source, target);
+  return {};
+}
+
+// Bind-mounts `source` at `target` with the mount propagation type being "slave+shared".
 Result<void> BindMount(const std::string& source, const std::string& target) {
   // Don't bind-mount repeatedly.
   CHECK(!PathStartsWith(source, DexoptChrootSetup::CHROOT_DIR));
@@ -197,23 +229,37 @@ Result<void> BindMount(const std::string& source, const std::string& target) {
             /*fs_type=*/nullptr,
             MS_BIND,
             /*data=*/nullptr) != 0) {
-    return ErrnoErrorf("Failed to bind-mount '{}' at '{}'", source, *kBindMountTmpDir);
-  }
+    return ErrnoErrorf("Failed to bind-mount '{}' at '{}' ('{}' -> '{}')",
+                       source,
+                       *kBindMountTmpDir,
+                       source,
+                       target);
+  }
+  auto cleanup = make_scope_guard([&]() {
+    Result<void> result = Unmount(*kBindMountTmpDir, /*logging=*/false);
+    if (!result.ok()) {
+      LOG(ERROR) << result.error().message();
+    }
+  });
   if (mount(/*source=*/nullptr,
             kBindMountTmpDir->c_str(),
             /*fs_type=*/nullptr,
             MS_SLAVE,
             /*data=*/nullptr) != 0) {
-    return ErrnoErrorf("Failed to make mount slave for '{}'", *kBindMountTmpDir);
+    return ErrnoErrorf(
+        "Failed to make mount slave for '{}' ('{}' -> '{}')", *kBindMountTmpDir, source, target);
   }
   if (mount(kBindMountTmpDir->c_str(),
             target.c_str(),
             /*fs_type=*/nullptr,
             MS_BIND,
             /*data=*/nullptr) != 0) {
-    return ErrnoErrorf("Failed to bind-mount '{}' at '{}'", *kBindMountTmpDir, target);
+    return ErrnoErrorf("Failed to bind-mount '{}' at '{}' ('{}' -> '{}')",
+                       *kBindMountTmpDir,
+                       target,
+                       source,
+                       target);
   }
-  OR_RETURN(Unmount(*kBindMountTmpDir));
   LOG(INFO) << ART_FORMAT("Bind-mounted '{}' at '{}'", source, target);
   return {};
 }
@@ -335,6 +381,86 @@ Result<std::optional<std::string>> LoadOtaSlotFile() {
   return Errorf("Invalid content of '{}': '{}'", *kOtaSlotFile, content);
 }
 
+Result<void> PatchLinkerConfigForCompatEnv() {
+  std::string art_linker_config_content;
+  if (!ReadFileToString(PathInChroot("/linkerconfig/com.android.art/ld.config.txt"),
+                        &art_linker_config_content)) {
+    return ErrnoErrorf("Failed to read ART linker config");
+  }
+
+  std::string compat_section =
+      OR_RETURN(ConstructLinkerConfigCompatEnvSection(art_linker_config_content));
+
+  // Append the patched section to the global linker config. Because the compat env path doesn't
+  // start with "/apex", the global linker config is the one that takes effect.
+  std::string global_linker_config_path = PathInChroot("/linkerconfig/ld.config.txt");
+  std::string global_linker_config_content;
+  if (!ReadFileToString(global_linker_config_path, &global_linker_config_content)) {
+    return ErrnoErrorf("Failed to read global linker config");
+  }
+
+  if (!WriteStringToFile("dir.com.android.art.compat = /mnt/compat_env/apex/com.android.art/bin\n" +
+                             global_linker_config_content + compat_section,
+                         global_linker_config_path)) {
+    return ErrnoErrorf("Failed to write global linker config");
+  }
+
+  LOG(INFO) << "Patched " << global_linker_config_path;
+  return {};
+}
+
+// Platform libraries communicate with things outside of chroot through unstable APIs. Examples are
+// `libbinder_ndk.so` talking to `servicemanager` and `libcgrouprc.so` reading
+// `/dev/cgroup_info/cgroup.rc`. To work around incompatibility issues, we bind-mount the old
+// platform library directories into chroot so that both sides of a communication are old and
+// therefore align with each other.
+// After bind-mounting old platform libraries, the chroot environment has a combination of new
+// modules and old platform libraries. We currently use the new linker config in such an
+// environment, which is potentially problematic. If we start to see problems, we should consider
+// generating a more correct linker config in a more complex way.
+Result<void> PrepareExternalLibDirs() {
+  std::vector<const char*> existing_lib_dirs;
+  std::copy_if(kExternalLibDirs.begin(),
+               kExternalLibDirs.end(),
+               std::back_inserter(existing_lib_dirs),
+               OS::DirectoryExists);
+  if (existing_lib_dirs.empty()) {
+    return Errorf("Unexpectedly missing platform library directories. Tried '{}'",
+                  android::base::Join(kExternalLibDirs, "', '"));
+  }
+
+  // We should bind-mount all existing lib dirs or none of them. Try the first one to decide what
+  // to do next.
+  Result<void> result = BindMount(existing_lib_dirs[0], PathInChroot(existing_lib_dirs[0]));
+  if (result.ok()) {
+    for (size_t i = 1; i < existing_lib_dirs.size(); i++) {
+      OR_RETURN(BindMount(existing_lib_dirs[i], PathInChroot(existing_lib_dirs[i])));
+    }
+  } else if (result.error().code() == EACCES) {
+    // We don't have the permission to do so on V. Fall back to bind-mounting elsewhere.
+    LOG(WARNING) << result.error().message();
+
+    OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env")));
+    OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env/system")));
+    OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env/system_ext")));
+    OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env/apex")));
+    OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env/apex/com.android.art")));
+    OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env/apex/com.android.art/bin")));
+    OR_RETURN(BindMountDirect(PathInChroot("/apex/com.android.art/bin"),
+                              PathInChroot("/mnt/compat_env/apex/com.android.art/bin")));
+    for (const char* lib_dir : existing_lib_dirs) {
+      OR_RETURN(CreateDir(PathInChroot("/mnt/compat_env") + lib_dir));
+      OR_RETURN(BindMountDirect(lib_dir, PathInChroot("/mnt/compat_env") + lib_dir));
+    }
+
+    OR_RETURN(PatchLinkerConfigForCompatEnv());
+  } else {
+    return result;
+  }
+
+  return {};
+}
+
 }  // namespace
 
 ScopedAStatus DexoptChrootSetup::setUp(const std::optional<std::string>& in_otaSlot,
@@ -357,13 +483,24 @@ ScopedAStatus DexoptChrootSetup::init() {
   }
   std::lock_guard<std::mutex> lock(mu_, std::adopt_lock);
 
+  if (OS::FileExists(PathInChroot("/linkerconfig/ld.config.txt").c_str())) {
+    return Fatal("init must not be repeatedly called");
+  }
+
   OR_RETURN_NON_FATAL(InitChroot());
   return ScopedAStatus::ok();
 }
 
-ScopedAStatus DexoptChrootSetup::tearDown() {
-  if (!mu_.try_lock()) {
-    return Fatal("Unexpected concurrent calls");
+ScopedAStatus DexoptChrootSetup::tearDown(bool in_allowConcurrent) {
+  if (in_allowConcurrent) {
+    // Normally, we don't expect concurrent calls, but this method may be called upon system server
+    // restart when another call initiated by the previous system_server instance is still being
+    // processed.
+    mu_.lock();
+  } else {
+    if (!mu_.try_lock()) {
+      return Fatal("Unexpected concurrent calls");
+    }
   }
   std::lock_guard<std::mutex> lock(mu_, std::adopt_lock);
 
@@ -395,19 +532,37 @@ Result<void> DexoptChrootSetup::SetUpChroot(const std::optional<std::string>& ot
   OR_RETURN(CreateDir(CHROOT_DIR));
   LOG(INFO) << ART_FORMAT("Created '{}'", CHROOT_DIR);
 
-  std::vector<std::string> additional_system_partitions = {
-      "system_ext",
-      "vendor",
-      "product",
+  std::vector<std::tuple<std::string, std::string>> additional_system_partitions = {
+      {"system_ext", "/system_ext"},
+      {"vendor", "/vendor"},
+      {"product", "/product"},
   };
 
+  std::string partitions_from_sysprop =
+      GetProperty(kAdditionalPartitionsSysprop, /*default_value=*/"");
+  std::vector<std::string_view> partitions_from_sysprop_entries;
+  art::Split(partitions_from_sysprop, ',', &partitions_from_sysprop_entries);
+  for (std::string_view entry : partitions_from_sysprop_entries) {
+    std::vector<std::string_view> pair;
+    art::Split(entry, ':', &pair);
+    if (pair.size() != 2 || pair[0].empty() || pair[1].empty() || !pair[1].starts_with('/')) {
+      return Errorf("Malformed entry in '{}': '{}'", kAdditionalPartitionsSysprop, entry);
+    }
+    additional_system_partitions.emplace_back(std::string(pair[0]), std::string(pair[1]));
+  }
+
   if (!IsOtaUpdate(ota_slot)) {  // Mainline update
     OR_RETURN(BindMount("/", CHROOT_DIR));
-    for (const std::string& partition : additional_system_partitions) {
+    // Normally, we don't need to bind-mount "/system" because it's a part of the image mounted at
+    // "/". However, when readonly partitions are remounted read-write, an overlay is created at
+    // "/system", so we need to bind-mount "/system" to handle this case. On devices where readonly
+    // partitions are not remounted, bind-mounting "/system" doesn't hurt.
+    OR_RETURN(BindMount("/system", PathInChroot("/system")));
+    for (const auto& [partition, mount_point] : additional_system_partitions) {
       // Some additional partitions are optional, but that's okay. The root filesystem (mounted at
       // `/`) has empty directories for additional partitions. If additional partitions don't exist,
       // we'll just be bind-mounting empty directories.
-      OR_RETURN(BindMount("/" + partition, PathInChroot("/" + partition)));
+      OR_RETURN(BindMount(mount_point, PathInChroot(mount_point)));
     }
   } else {
     CHECK(ota_slot.value() == "_a" || ota_slot.value() == "_b");
@@ -437,9 +592,9 @@ Result<void> DexoptChrootSetup::SetUpChroot(const std::optional<std::string>& ot
       OR_RETURN(BindMount("/postinstall", CHROOT_DIR));
     }
 
-    for (const std::string& partition : additional_system_partitions) {
+    for (const auto& [partition, mount_point] : additional_system_partitions) {
       OR_RETURN(Mount(GetBlockDeviceName(partition, ota_slot.value()),
-                      PathInChroot("/" + partition),
+                      PathInChroot(mount_point),
                       /*is_optional=*/true));
     }
   }
@@ -497,10 +652,31 @@ Result<void> DexoptChrootSetup::InitChroot() const {
       .Add("/linkerconfig");
   OR_RETURN(Run("linkerconfig", args.Get()));
 
+  if (IsOtaUpdate(ota_slot)) {
+    OR_RETURN(PrepareExternalLibDirs());
+  }
+
   return {};
 }
 
 Result<void> DexoptChrootSetup::TearDownChroot() const {
+  // For mount points in `kExternalLibDirs`, make sure we have unmounted them before running apexd,
+  // as apexd expects new libraries.
+  // For mount points under "/mnt/compat_env", make sure we have unmounted them before running
+  // apexd, as apexd doesn't expect apexes to be in-use.
+  std::vector<FstabEntry> entries = OR_RETURN(GetProcMountsDescendantsOfPath(CHROOT_DIR));
+  for (const FstabEntry entry : entries) {
+    std::string_view mount_point_in_chroot = entry.mount_point;
+    CHECK(ConsumePrefix(&mount_point_in_chroot, CHROOT_DIR));
+    if (mount_point_in_chroot.empty()) {
+      continue;  // The root mount.
+    }
+    if (ContainsElement(kExternalLibDirs, mount_point_in_chroot) ||
+        PathStartsWith(mount_point_in_chroot, "/mnt/compat_env")) {
+      OR_RETURN(Unmount(entry.mount_point));
+    }
+  }
+
   std::vector<FstabEntry> apex_entries =
       OR_RETURN(GetProcMountsDescendantsOfPath(PathInChroot("/apex")));
   // If there is only one entry, it's /apex itself.
@@ -526,10 +702,9 @@ Result<void> DexoptChrootSetup::TearDownChroot() const {
   }
 
   // The list is in mount order.
-  std::vector<FstabEntry> entries = OR_RETURN(GetProcMountsDescendantsOfPath(CHROOT_DIR));
+  entries = OR_RETURN(GetProcMountsDescendantsOfPath(CHROOT_DIR));
   for (auto it = entries.rbegin(); it != entries.rend(); it++) {
     OR_RETURN(Unmount(it->mount_point));
-    LOG(INFO) << ART_FORMAT("Unmounted '{}'", it->mount_point);
   }
 
   std::error_code ec;
@@ -575,5 +750,44 @@ std::string PathInChroot(std::string_view path) {
   return std::string(DexoptChrootSetup::CHROOT_DIR).append(path);
 }
 
+Result<std::string> ConstructLinkerConfigCompatEnvSection(
+    const std::string& art_linker_config_content) {
+  std::regex system_lib_re(R"re((=\s*|:)/(system(?:_ext)?/\$\{LIB\}))re");
+  constexpr const char* kSystemLibFmt = "$1/mnt/compat_env/$2";
+
+  // Make a copy of the [com.android.art] section and patch particular lines.
+  std::string compat_section;
+  bool is_in_art_section = false;
+  bool replaced = false;
+  std::vector<std::string_view> art_linker_config_lines;
+  art::Split(art_linker_config_content, '\n', &art_linker_config_lines);
+  for (std::string_view line : art_linker_config_lines) {
+    if (!is_in_art_section && line == "[com.android.art]") {
+      is_in_art_section = true;
+    } else if (is_in_art_section && line.starts_with('[')) {
+      is_in_art_section = false;
+    }
+
+    if (is_in_art_section) {
+      if (line == "[com.android.art]") {
+        compat_section += "[com.android.art.compat]\n";
+      } else {
+        std::string patched_line =
+            std::regex_replace(std::string(line), system_lib_re, kSystemLibFmt);
+        if (line != patched_line) {
+          LOG(DEBUG) << ART_FORMAT("Replacing '{}' with '{}'", line, patched_line);
+          replaced = true;
+        }
+        compat_section += patched_line;
+        compat_section += '\n';
+      }
+    }
+  }
+  if (!replaced) {
+    return Errorf("No matching lines to patch in ART linker config");
+  }
+  return compat_section;
+}
+
 }  // namespace dexopt_chroot_setup
 }  // namespace art
diff --git a/dexopt_chroot_setup/dexopt_chroot_setup.h b/dexopt_chroot_setup/dexopt_chroot_setup.h
index de0e35fa4d..a80b1f7a16 100644
--- a/dexopt_chroot_setup/dexopt_chroot_setup.h
+++ b/dexopt_chroot_setup/dexopt_chroot_setup.h
@@ -27,6 +27,12 @@
 namespace art {
 namespace dexopt_chroot_setup {
 
+// A comma-separated list, where each entry is a colon-separated pair of a partition name in the
+// super image and a mount point. E.g.,
+// some_partition_1:/some_mount_point_1,some_partition_2:/some_mount_point_2
+constexpr const char* kAdditionalPartitionsSysprop =
+    "dalvik.vm.pr_dexopt_additional_system_partitions";
+
 // A service that sets up the chroot environment for Pre-reboot Dexopt.
 class DexoptChrootSetup : public aidl::com::android::server::art::BnDexoptChrootSetup {
  public:
@@ -35,7 +41,7 @@ class DexoptChrootSetup : public aidl::com::android::server::art::BnDexoptChroot
 
   ndk::ScopedAStatus init() override;
 
-  ndk::ScopedAStatus tearDown() override;
+  ndk::ScopedAStatus tearDown(bool in_allowConcurrent) override;
 
   android::base::Result<void> Start();
 
@@ -52,6 +58,9 @@ class DexoptChrootSetup : public aidl::com::android::server::art::BnDexoptChroot
 
 std::string PathInChroot(std::string_view path);
 
+android::base::Result<std::string> ConstructLinkerConfigCompatEnvSection(
+    const std::string& art_linker_config_content);
+
 }  // namespace dexopt_chroot_setup
 }  // namespace art
 
diff --git a/dexopt_chroot_setup/dexopt_chroot_setup_test.cc b/dexopt_chroot_setup/dexopt_chroot_setup_test.cc
index 8e8cfef754..bbe0da352c 100644
--- a/dexopt_chroot_setup/dexopt_chroot_setup_test.cc
+++ b/dexopt_chroot_setup/dexopt_chroot_setup_test.cc
@@ -22,9 +22,12 @@
 #include <filesystem>
 #include <string>
 #include <string_view>
+#include <utility>
 
 #include "aidl/com/android/server/art/BnDexoptChrootSetup.h"
+#include "android-base/file.h"
 #include "android-base/properties.h"
+#include "android-base/result-gmock.h"
 #include "android-base/scopeguard.h"
 #include "android/binder_auto_utils.h"
 #include "base/common_art_test.h"
@@ -40,8 +43,13 @@ namespace art {
 namespace dexopt_chroot_setup {
 namespace {
 
+using ::android::base::GetProperty;
 using ::android::base::ScopeGuard;
+using ::android::base::SetProperty;
 using ::android::base::WaitForProperty;
+using ::android::base::testing::HasError;
+using ::android::base::testing::HasValue;
+using ::android::base::testing::WithMessage;
 using ::art::tools::CmdlineBuilder;
 
 class DexoptChrootSetupTest : public CommonArtTest {
@@ -74,29 +82,40 @@ class DexoptChrootSetupTest : public CommonArtTest {
       GTEST_SKIP() << "A real Pre-reboot Dexopt is running";
     }
 
-    ASSERT_TRUE(WaitForProperty("dev.bootcomplete", "1", /*relative_timeout=*/std::chrono::minutes(3)));
+    ASSERT_TRUE(
+        WaitForProperty("dev.bootcomplete", "1", /*relative_timeout=*/std::chrono::minutes(3)));
 
-    test_skipped = false;
+    test_skipped_ = false;
 
     scratch_dir_ = std::make_unique<ScratchDir>();
     scratch_path_ = scratch_dir_->GetPath();
     // Remove the trailing '/';
     scratch_path_.resize(scratch_path_.length() - 1);
+
+    partitions_sysprop_value_ = GetProperty(kAdditionalPartitionsSysprop, /*default_value=*/"");
+    ASSERT_TRUE(SetProperty(kAdditionalPartitionsSysprop, "odm:/odm,system_dlkm:/system_dlkm"));
+    partitions_sysprop_set_ = true;
   }
 
   void TearDown() override {
-    if (test_skipped) {
+    if (test_skipped_) {
       return;
     }
+    if (partitions_sysprop_set_ &&
+        !SetProperty(kAdditionalPartitionsSysprop, partitions_sysprop_value_)) {
+      LOG(ERROR) << ART_FORMAT("Failed to recover sysprop '{}'", kAdditionalPartitionsSysprop);
+    }
     scratch_dir_.reset();
-    dexopt_chroot_setup_->tearDown();
+    dexopt_chroot_setup_->tearDown(/*in_allowConcurrent=*/false);
     CommonArtTest::TearDown();
   }
 
   std::shared_ptr<DexoptChrootSetup> dexopt_chroot_setup_;
   std::unique_ptr<ScratchDir> scratch_dir_;
   std::string scratch_path_;
-  bool test_skipped = true;
+  bool test_skipped_ = true;
+  std::string partitions_sysprop_value_;
+  bool partitions_sysprop_set_ = false;
 };
 
 TEST_F(DexoptChrootSetupTest, Run) {
@@ -106,6 +125,9 @@ TEST_F(DexoptChrootSetupTest, Run) {
       dexopt_chroot_setup_->setUp(/*in_otaSlot=*/std::nullopt, /*in_mapSnapshotsForOta=*/false));
   ASSERT_STATUS_OK(dexopt_chroot_setup_->init());
 
+  std::string mounts;
+  ASSERT_TRUE(android::base::ReadFileToString("/proc/mounts", &mounts, /*follow_symlinks=*/true));
+
   // Some important dirs that should be the same as outside.
   std::vector<const char*> same_dirs = {
       "/",
@@ -123,6 +145,8 @@ TEST_F(DexoptChrootSetupTest, Run) {
       "/sys/fs/cgroup",
       "/sys/fs/selinux",
       "/metadata",
+      "/odm",
+      "/system_dlkm",
   };
 
   for (const std::string& dir : same_dirs) {
@@ -130,8 +154,9 @@ TEST_F(DexoptChrootSetupTest, Run) {
     ASSERT_EQ(stat(dir.c_str(), &st_outside), 0);
     struct stat st_inside;
     ASSERT_EQ(stat(PathInChroot(dir).c_str(), &st_inside), 0);
-    EXPECT_EQ(st_outside.st_dev, st_inside.st_dev);
-    EXPECT_EQ(st_outside.st_ino, st_inside.st_ino);
+    EXPECT_EQ(std::make_pair(st_outside.st_dev, st_outside.st_ino),
+              std::make_pair(st_inside.st_dev, st_inside.st_ino))
+        << ART_FORMAT("Unexpected different directory in chroot: '{}'\n", dir) << mounts;
   }
 
   // Some important dirs that are expected to be writable.
@@ -171,27 +196,137 @@ TEST_F(DexoptChrootSetupTest, Run) {
   std::string error_msg;
   EXPECT_TRUE(Exec(args.Get(), &error_msg)) << error_msg;
 
-  // Check that `setUp` can be repetitively called, to simulate the case where an instance of the
+  // Check that `setUp` can be repeatedly called, to simulate the case where an instance of the
   // caller (typically system_server) called `setUp` and crashed later, and a new instance called
   // `setUp` again.
   ASSERT_STATUS_OK(
       dexopt_chroot_setup_->setUp(/*in_otaSlot=*/std::nullopt, /*in_mapSnapshotsForOta=*/false));
   ASSERT_STATUS_OK(dexopt_chroot_setup_->init());
 
-  ASSERT_STATUS_OK(dexopt_chroot_setup_->tearDown());
+  // Check that `init` cannot be repeatedly called.
+  ndk::ScopedAStatus status = dexopt_chroot_setup_->init();
+  EXPECT_FALSE(status.isOk());
+  EXPECT_EQ(status.getExceptionCode(), EX_ILLEGAL_STATE);
+  EXPECT_STREQ(status.getMessage(), "init must not be repeatedly called");
+
+  ASSERT_STATUS_OK(dexopt_chroot_setup_->tearDown(/*in_allowConcurrent=*/false));
 
   EXPECT_FALSE(std::filesystem::exists(DexoptChrootSetup::CHROOT_DIR));
 
-  // Check that `tearDown` can be repetitively called too.
-  ASSERT_STATUS_OK(dexopt_chroot_setup_->tearDown());
+  // Check that `tearDown` can be repeatedly called too.
+  ASSERT_STATUS_OK(dexopt_chroot_setup_->tearDown(/*in_allowConcurrent=*/false));
 
   // Check that `setUp` can be followed directly by a `tearDown`.
   ASSERT_STATUS_OK(
       dexopt_chroot_setup_->setUp(/*in_otaSlot=*/std::nullopt, /*in_mapSnapshotsForOta=*/false));
-  ASSERT_STATUS_OK(dexopt_chroot_setup_->tearDown());
+  ASSERT_STATUS_OK(dexopt_chroot_setup_->tearDown(/*in_allowConcurrent=*/false));
   EXPECT_FALSE(std::filesystem::exists(DexoptChrootSetup::CHROOT_DIR));
 }
 
+TEST(DexoptChrootSetupUnitTest, ConstructLinkerConfigCompatEnvSection) {
+  std::string art_linker_config_content = R"(dir.com.android.art = /apex/com.android.art/bin
+[com.android.art]
+additional.namespaces = com_android_art,system
+namespace.default.isolated = true
+namespace.default.links = com_android_art,system
+namespace.default.link.com_android_art.allow_all_shared_libs = true
+namespace.default.link.system.shared_libs = libartpalette-system.so:libbinder_ndk.so:libc.so:libdl.so:libdl_android.so:liblog.so:libm.so
+namespace.com_android_art.isolated = true
+namespace.com_android_art.visible = true
+namespace.com_android_art.search.paths = /apex/com.android.art/${LIB}
+namespace.com_android_art.permitted.paths = /apex/com.android.art/${LIB}
+namespace.com_android_art.permitted.paths += /system/${LIB}
+namespace.com_android_art.permitted.paths += /system_ext/${LIB}
+namespace.com_android_art.permitted.paths += /data
+namespace.com_android_art.permitted.paths += /apex/com.android.art/javalib
+namespace.com_android_art.links = system
+namespace.com_android_art.link.system.shared_libs = libartpalette-system.so:libbinder_ndk.so:libc.so:libdl.so:libdl_android.so:liblog.so:libm.so
+namespace.system.isolated = true
+namespace.system.visible = true
+namespace.system.search.paths = /system/${LIB}
+namespace.system.search.paths += /system_ext/${LIB}
+namespace.system.permitted.paths = /system/${LIB}/drm:/system/${LIB}/extractors:/system/${LIB}/hw
+namespace.system.permitted.paths += /system_ext/${LIB}
+namespace.system.permitted.paths += /system/framework
+namespace.system.permitted.paths += /data
+namespace.system.permitted.paths += /apex/com.android.runtime/${LIB}/bionic
+namespace.system.permitted.paths += /system/${LIB}/bootstrap
+namespace.system.links = com_android_art
+namespace.system.link.com_android_art.shared_libs = libdexfile.so:libjdwp.so:libnativebridge.so:libnativehelper.so:libnativeloader.so:libsigchain.so
+[some_other_section]
+)";
+
+  std::string expected_compat_env_section = R"([com.android.art.compat]
+additional.namespaces = com_android_art,system
+namespace.default.isolated = true
+namespace.default.links = com_android_art,system
+namespace.default.link.com_android_art.allow_all_shared_libs = true
+namespace.default.link.system.shared_libs = libartpalette-system.so:libbinder_ndk.so:libc.so:libdl.so:libdl_android.so:liblog.so:libm.so
+namespace.com_android_art.isolated = true
+namespace.com_android_art.visible = true
+namespace.com_android_art.search.paths = /apex/com.android.art/${LIB}
+namespace.com_android_art.permitted.paths = /apex/com.android.art/${LIB}
+namespace.com_android_art.permitted.paths += /mnt/compat_env/system/${LIB}
+namespace.com_android_art.permitted.paths += /mnt/compat_env/system_ext/${LIB}
+namespace.com_android_art.permitted.paths += /data
+namespace.com_android_art.permitted.paths += /apex/com.android.art/javalib
+namespace.com_android_art.links = system
+namespace.com_android_art.link.system.shared_libs = libartpalette-system.so:libbinder_ndk.so:libc.so:libdl.so:libdl_android.so:liblog.so:libm.so
+namespace.system.isolated = true
+namespace.system.visible = true
+namespace.system.search.paths = /mnt/compat_env/system/${LIB}
+namespace.system.search.paths += /mnt/compat_env/system_ext/${LIB}
+namespace.system.permitted.paths = /mnt/compat_env/system/${LIB}/drm:/mnt/compat_env/system/${LIB}/extractors:/mnt/compat_env/system/${LIB}/hw
+namespace.system.permitted.paths += /mnt/compat_env/system_ext/${LIB}
+namespace.system.permitted.paths += /system/framework
+namespace.system.permitted.paths += /data
+namespace.system.permitted.paths += /apex/com.android.runtime/${LIB}/bionic
+namespace.system.permitted.paths += /mnt/compat_env/system/${LIB}/bootstrap
+namespace.system.links = com_android_art
+namespace.system.link.com_android_art.shared_libs = libdexfile.so:libjdwp.so:libnativebridge.so:libnativehelper.so:libnativeloader.so:libsigchain.so
+)";
+
+  EXPECT_THAT(ConstructLinkerConfigCompatEnvSection(art_linker_config_content),
+              HasValue(expected_compat_env_section));
+}
+
+TEST(DexoptChrootSetupUnitTest, ConstructLinkerConfigCompatEnvSectionNoMatch) {
+  std::string art_linker_config_content = R"(dir.com.android.art = /apex/com.android.art/bin
+[com.android.art]
+additional.namespaces = com_android_art,system
+namespace.default.isolated = true
+namespace.default.links = com_android_art,system
+namespace.default.link.com_android_art.allow_all_shared_libs = true
+namespace.default.link.system.shared_libs = libartpalette-system.so:libbinder_ndk.so:libc.so:libdl.so:libdl_android.so:liblog.so:libm.so
+namespace.com_android_art.isolated = true
+namespace.com_android_art.visible = true
+namespace.com_android_art.search.paths = /apex/com.android.art/${LIB}
+namespace.com_android_art.permitted.paths = /apex/com.android.art/${LIB}
+namespace.com_android_art.permitted.paths += /foo/${LIB}
+namespace.com_android_art.permitted.paths += /foo_ext/${LIB}
+namespace.com_android_art.permitted.paths += /data
+namespace.com_android_art.permitted.paths += /apex/com.android.art/javalib
+namespace.com_android_art.links = system
+namespace.com_android_art.link.system.shared_libs = libartpalette-system.so:libbinder_ndk.so:libc.so:libdl.so:libdl_android.so:liblog.so:libm.so
+namespace.system.isolated = true
+namespace.system.visible = true
+namespace.system.search.paths = /foo/${LIB}
+namespace.system.search.paths += /foo_ext/${LIB}
+namespace.system.permitted.paths = /foo/${LIB}/drm:/foo/${LIB}/extractors:/foo/${LIB}/hw
+namespace.system.permitted.paths += /foo_ext/${LIB}
+namespace.system.permitted.paths += /system/framework
+namespace.system.permitted.paths += /data
+namespace.system.permitted.paths += /apex/com.android.runtime/${LIB}/bionic
+namespace.system.permitted.paths += /foo/${LIB}/bootstrap
+namespace.system.links = com_android_art
+namespace.system.link.com_android_art.shared_libs = libdexfile.so:libjdwp.so:libnativebridge.so:libnativehelper.so:libnativeloader.so:libsigchain.so
+[some_other_section]
+)";
+
+  EXPECT_THAT(ConstructLinkerConfigCompatEnvSection(art_linker_config_content),
+              HasError(WithMessage("No matching lines to patch in ART linker config")));
+}
+
 }  // namespace
 }  // namespace dexopt_chroot_setup
 }  // namespace art
diff --git a/disassembler/disassembler_arm64.cc b/disassembler/disassembler_arm64.cc
index 23472a8dca..ef27e75c8c 100644
--- a/disassembler/disassembler_arm64.cc
+++ b/disassembler/disassembler_arm64.cc
@@ -60,6 +60,17 @@ void CustomDisassembler::AppendRegisterNameToOutput(const Instruction* instr,
   Disassembler::AppendRegisterNameToOutput(instr, reg);
 }
 
+void CustomDisassembler::AppendCodeRelativeAddressToOutput(const Instruction* instr,
+                                                           const void* addr) {
+  USE(instr);
+  int64_t rel_addr = CodeRelativeAddress(addr);
+  if (rel_addr >= 0) {
+    AppendToOutput("(addr 0x%08" PRIx64 ")", rel_addr);
+  } else {
+    AppendToOutput("(addr -0x%08" PRIx64 ")", -rel_addr);
+  }
+}
+
 void CustomDisassembler::Visit(vixl::aarch64::Metadata* metadata, const Instruction* instr) {
   vixl::aarch64::Disassembler::Visit(metadata, instr);
   const std::string& form = (*metadata)["form"];
diff --git a/disassembler/disassembler_arm64.h b/disassembler/disassembler_arm64.h
index d0443d2b39..d1b509127c 100644
--- a/disassembler/disassembler_arm64.h
+++ b/disassembler/disassembler_arm64.h
@@ -19,9 +19,10 @@
 
 #include "disassembler.h"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/decoder-aarch64.h"
 #include "aarch64/disasm-aarch64.h"
 #pragma GCC diagnostic pop
@@ -47,6 +48,10 @@ class CustomDisassembler final : public vixl::aarch64::Disassembler {
   void AppendRegisterNameToOutput(const vixl::aarch64::Instruction* instr,
                                   const vixl::aarch64::CPURegister& reg) override;
 
+  // Overriding to print the address with trailing zeroes e.g. 0x00004074 instead of 0x4074.
+  void AppendCodeRelativeAddressToOutput(const vixl::aarch64::Instruction* instr,
+                                         const void* addr) override;
+
   // Intercepts the instruction flow captured by the parent method,
   // to specially instrument for particular instruction types.
   void Visit(vixl::aarch64::Metadata* metadata, const vixl::aarch64::Instruction* instr) override;
diff --git a/disassembler/disassembler_riscv64.cc b/disassembler/disassembler_riscv64.cc
index 992fe31637..c0c5986160 100644
--- a/disassembler/disassembler_riscv64.cc
+++ b/disassembler/disassembler_riscv64.cc
@@ -708,6 +708,7 @@ void DisassemblerRiscv64::Printer::Print32BinOpImm(uint32_t insn32) {
   DCHECK_EQ(insn32 & 0x77u, 0x13u);  // Note: Bit 0x8 selects narrow binop.
   bool narrow = (insn32 & 0x8u) != 0u;
   uint32_t funct3 = (insn32 >> 12) & 7u;
+  uint32_t funct6 = (insn32 >> 26) & 0x3Fu;
   uint32_t rd = GetRd(insn32);
   uint32_t rs1 = GetRs1(insn32);
   int32_t imm = Decode32Imm12(insn32);
@@ -740,6 +741,12 @@ void DisassemblerRiscv64::Printer::Print32BinOpImm(uint32_t insn32) {
     os_ << "orc.b " << XRegName(rd) << ", " << XRegName(rs1);
   } else if (imm == 0x6b8u && !narrow && funct3 == 5u) {
     os_ << "rev8 " << XRegName(rd) << ", " << XRegName(rs1);
+  } else if (!narrow && funct6 == 0x12u && (funct3 == /*BCLRI*/ 1u || funct3 == /*BEXTI*/ 5u)) {
+    os_ << ((funct3 == /*BCLRI*/ 1u) ? "bclri" : "bexti");
+  } else if (!narrow && funct6 == 0x1Au && funct3 == 0x1u /*BINVI*/) {
+    os_ << "binvi";
+  } else if (!narrow && funct6 == 0xAu && funct3 == 0x1u /*BSETI*/) {
+    os_ << "bseti";
   } else {
     bool bad_high_bits = false;
     if (funct3 == /*SLLI*/ 1u || funct3 == /*SRLI/SRAI*/ 5u) {
@@ -788,6 +795,13 @@ void DisassemblerRiscv64::Printer::Print32BinOp(uint32_t insn32) {
     os_ << "snez " << XRegName(rd) << ", " << XRegName(rs2);
   } else if (narrow && high_bits == 0x08000000u && funct3 == /*ADD.UW*/ 0u && rs2 == Zero) {
     os_ << "zext.w " << XRegName(rd) << ", " << XRegName(rs1);
+  } else if (!narrow && high_bits == 0x48000000u &&
+             (funct3 == /*BCLR*/ 1u || funct3 == /*BEXT*/ 5u)) {
+    os_ << ((funct3 == /*BCLR*/ 1u) ? "bclr" : "bext");
+  } else if (!narrow && high_bits == 0x68000000u && funct3 == /*BINV*/ 1u) {
+    os_ << "binv";
+  } else if (!narrow && high_bits == 0x28000000u && funct3 == /*BSET*/ 1u) {
+    os_ << "bset";
   } else {
     bool bad_high_bits = false;
     if (high_bits == 0x40000000u && (funct3 == /*SUB*/ 0u || funct3 == /*SRA*/ 5u)) {
diff --git a/imgdiag/dirty_image_objects.md b/imgdiag/dirty_image_objects.md
index 1b5ab62900..5d28b04ee6 100644
--- a/imgdiag/dirty_image_objects.md
+++ b/imgdiag/dirty_image_objects.md
@@ -1,25 +1,16 @@
 # How to update dirty-image-objects
 
-1. Add `imgdiag` to ART APEX.
-
-The easiest way is to modify `art/build/apex/Android.bp` like this:
-```
- art_runtime_binaries_both = [
-     "dalvikvm",
-     "dex2oat",
-+    "imgdiag",
- ]
-```
-
-2. Install ART APEX and reboot, e.g.:
+1. Install ART APEX with imgdiag and reboot, e.g.:
 
 ```
+. ./build/envsetup.sh
+banchan test_imgdiag_com.android.art module_arm64
 m apps_only dist
-adb install out/dist/com.android.art.apex
+adb install out/dist/test_imgdiag_com.android.art.apex
 adb reboot
 ```
 
-3. Collect imgdiag output.
+2. Collect imgdiag output.
 
 ```
 # To see all options check: art/imgdiag/run_imgdiag.py -h
@@ -27,7 +18,7 @@ adb reboot
 art/imgdiag/run_imgdiag.py
 ```
 
-4. Create new dirty-image-objects.
+3. Create new dirty-image-objects.
 
 ```
 # To see all options check: art/imgdiag/create_dirty_image_objects.py -h
@@ -63,13 +54,13 @@ All dirty objects will be placed in the dirty bin of the boot image and sorted
 by the sort\_key values. I.e., dirty entries with sort\_key==N will have lower
 address than entries with sort\_key==N+1.
 
-5. Push new dirty-image-objects to the device.
+4. Push new dirty-image-objects to the device.
 
 ```
 adb push dirty-image-objects.txt /etc/dirty-image-objects
 ```
 
-6. Reinstall ART APEX to update the boot image.
+5. Reinstall ART APEX to update the boot image.
 
 ```
 adb install out/dist/com.android.art.apex
diff --git a/libartbase/Android.bp b/libartbase/Android.bp
index 16c8625061..d608272906 100644
--- a/libartbase/Android.bp
+++ b/libartbase/Android.bp
@@ -136,6 +136,28 @@ cc_defaults {
         },
         darwin: {
             enabled: true, // for libdexfile.
+            // TODO(b/350967139): Move art-aconfig-flags-lib to the top level
+            // when aconfig supports windows. Until then it's harder to use
+            // flags in code that needs to build for them, e.g. libartbase,
+            // libdexfile, and dexdump.
+            static_libs: [
+                "art-aconfig-flags-lib",
+            ],
+            export_static_lib_headers: [
+                "art-aconfig-flags-lib",
+            ],
+        },
+        linux: {
+            // TODO(b/350967139): Move art-aconfig-flags-lib to the top level
+            // when aconfig supports windows. Until then it's harder to use
+            // flags in code that needs to build for them, e.g. libartbase,
+            // libdexfile, and dexdump.
+            static_libs: [
+                "art-aconfig-flags-lib",
+            ],
+            export_static_lib_headers: [
+                "art-aconfig-flags-lib",
+            ],
         },
     },
     generated_sources: ["art_libartbase_operator_srcs"],
diff --git a/libartbase/arch/instruction_set.cc b/libartbase/arch/instruction_set.cc
index e28b6ca291..12a2c36784 100644
--- a/libartbase/arch/instruction_set.cc
+++ b/libartbase/arch/instruction_set.cc
@@ -36,8 +36,6 @@ void InstructionSetAbort(InstructionSet isa) {
       LOG(FATAL) << "Unsupported instruction set " << isa;
       UNREACHABLE();
   }
-  LOG(FATAL) << "Unknown ISA " << isa;
-  UNREACHABLE();
 }
 
 const char* GetInstructionSetString(InstructionSet isa) {
@@ -56,8 +54,6 @@ const char* GetInstructionSetString(InstructionSet isa) {
     case InstructionSet::kNone:
       return "none";
   }
-  LOG(FATAL) << "Unknown ISA " << isa;
-  UNREACHABLE();
 }
 
 InstructionSet GetInstructionSetFromString(const char* isa_str) {
diff --git a/libartbase/arch/instruction_set.h b/libartbase/arch/instruction_set.h
index c0d27c324f..69b01dbfee 100644
--- a/libartbase/arch/instruction_set.h
+++ b/libartbase/arch/instruction_set.h
@@ -92,7 +92,6 @@ NO_RETURN void InstructionSetAbort(InstructionSet isa);
 constexpr PointerSize GetInstructionSetPointerSize(InstructionSet isa) {
   switch (isa) {
     case InstructionSet::kArm:
-      // Fall-through.
     case InstructionSet::kThumb2:
       return kArmPointerSize;
     case InstructionSet::kArm64:
@@ -103,11 +102,9 @@ constexpr PointerSize GetInstructionSetPointerSize(InstructionSet isa) {
       return kX86PointerSize;
     case InstructionSet::kX86_64:
       return kX86_64PointerSize;
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 constexpr bool IsValidInstructionSet(InstructionSet isa) {
@@ -119,17 +116,14 @@ constexpr bool IsValidInstructionSet(InstructionSet isa) {
     case InstructionSet::kX86:
     case InstructionSet::kX86_64:
       return true;
-
     case InstructionSet::kNone:
       return false;
   }
-  return false;
 }
 
 constexpr size_t GetInstructionSetInstructionAlignment(InstructionSet isa) {
   switch (isa) {
     case InstructionSet::kArm:
-      // Fall-through.
     case InstructionSet::kThumb2:
       return kThumb2InstructionAlignment;
     case InstructionSet::kArm64:
@@ -140,17 +134,14 @@ constexpr size_t GetInstructionSetInstructionAlignment(InstructionSet isa) {
       return kX86InstructionAlignment;
     case InstructionSet::kX86_64:
       return kX86_64InstructionAlignment;
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 constexpr size_t GetInstructionSetCodeAlignment(InstructionSet isa) {
   switch (isa) {
     case InstructionSet::kArm:
-      // Fall-through.
     case InstructionSet::kThumb2:
       return kArmCodeAlignment;
     case InstructionSet::kArm64:
@@ -158,14 +149,11 @@ constexpr size_t GetInstructionSetCodeAlignment(InstructionSet isa) {
     case InstructionSet::kRiscv64:
       return kRiscv64CodeAlignment;
     case InstructionSet::kX86:
-      // Fall-through.
     case InstructionSet::kX86_64:
       return kX86CodeAlignment;
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 // Returns the difference between the code address and a usable PC.
@@ -178,15 +166,12 @@ constexpr size_t GetInstructionSetEntryPointAdjustment(InstructionSet isa) {
     case InstructionSet::kX86:
     case InstructionSet::kX86_64:
       return 0;
-    case InstructionSet::kThumb2: {
+    case InstructionSet::kThumb2:
       // +1 to set the low-order bit so a BLX will switch to Thumb mode
       return 1;
-    }
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 constexpr bool Is64BitInstructionSet(InstructionSet isa) {
@@ -195,16 +180,13 @@ constexpr bool Is64BitInstructionSet(InstructionSet isa) {
     case InstructionSet::kThumb2:
     case InstructionSet::kX86:
       return false;
-
     case InstructionSet::kArm64:
     case InstructionSet::kRiscv64:
     case InstructionSet::kX86_64:
       return true;
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 constexpr PointerSize InstructionSetPointerSize(InstructionSet isa) {
@@ -214,43 +196,31 @@ constexpr PointerSize InstructionSetPointerSize(InstructionSet isa) {
 constexpr size_t GetBytesPerGprSpillLocation(InstructionSet isa) {
   switch (isa) {
     case InstructionSet::kArm:
-      // Fall-through.
     case InstructionSet::kThumb2:
+    case InstructionSet::kX86:
       return 4;
     case InstructionSet::kArm64:
-      return 8;
     case InstructionSet::kRiscv64:
-      return 8;
-    case InstructionSet::kX86:
-      return 4;
     case InstructionSet::kX86_64:
       return 8;
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 constexpr size_t GetBytesPerFprSpillLocation(InstructionSet isa) {
   switch (isa) {
     case InstructionSet::kArm:
-      // Fall-through.
     case InstructionSet::kThumb2:
       return 4;
     case InstructionSet::kArm64:
-      return 8;
     case InstructionSet::kRiscv64:
-      return 8;
     case InstructionSet::kX86:
-      return 8;
     case InstructionSet::kX86_64:
       return 8;
-
     case InstructionSet::kNone:
-      break;
+      InstructionSetAbort(isa);
   }
-  InstructionSetAbort(isa);
 }
 
 // Returns the instruction sets supported by the device, or an empty list on failure.
@@ -297,7 +267,6 @@ constexpr size_t GetStackOverflowReservedBytes(InstructionSet isa) {
       instruction_set_details::GetStackOverflowReservedBytesFailure(
           "kNone has no stack overflow size");
   }
-  instruction_set_details::GetStackOverflowReservedBytesFailure("Unknown instruction set");
 }
 
 // The following definitions create return types for two word-sized entities that will be passed
diff --git a/libartbase/base/common_art_test.cc b/libartbase/base/common_art_test.cc
index 4fc8533fa0..29cc88a8f5 100644
--- a/libartbase/base/common_art_test.cc
+++ b/libartbase/base/common_art_test.cc
@@ -633,10 +633,14 @@ CommonArtTestImpl::ForkAndExecResult CommonArtTestImpl::ForkAndExec(
     return result;
   }
 
+  // Special return code for failures between fork and exec. Pick something that
+  // the command is unlikely to use.
+  constexpr int kPostForkFailure = 134;
+
   if (pid == 0) {
     if (!post_fork()) {
       LOG(ERROR) << "Failed post-fork function";
-      exit(1);
+      exit(kPostForkFailure);
       UNREACHABLE();
     }
 
@@ -648,7 +652,8 @@ CommonArtTestImpl::ForkAndExecResult CommonArtTestImpl::ForkAndExec(
     link[1].reset();
 
     execv(c_args[0], const_cast<char* const*>(c_args.data()));
-    exit(1);
+    PLOG(ERROR) << "Failed to execv " << c_args[0];
+    exit(kPostForkFailure);
     UNREACHABLE();
   }
 
@@ -669,6 +674,11 @@ CommonArtTestImpl::ForkAndExecResult CommonArtTestImpl::ForkAndExec(
   }
 
   result.stage = ForkAndExecResult::kFinished;
+
+  if (WIFEXITED(result.status_code) && WEXITSTATUS(result.status_code) == kPostForkFailure) {
+    LOG(WARNING) << "ForkAndExec likely failed between fork and exec";
+  }
+
   return result;
 }
 
diff --git a/libartbase/base/common_art_test.h b/libartbase/base/common_art_test.h
index f07f1bfc89..ef26e70c7b 100644
--- a/libartbase/base/common_art_test.h
+++ b/libartbase/base/common_art_test.h
@@ -25,6 +25,7 @@
 #include <vector>
 
 #include "android-base/logging.h"
+#include "android-base/properties.h"
 #include "android-base/scopeguard.h"
 #include "base/file_utils.h"
 #include "base/globals.h"
@@ -345,4 +346,10 @@ std::vector<pid_t> GetPidByName(const std::string& process_name);
     GTEST_SKIP() << "WARNING: TEST DISABLED FOR MEMORY TOOL WITH HEAP POISONING"; \
   }
 
+#define TEST_DISABLED_FOR_USER_BUILD()                                          \
+  if (std::string build_type = android::base::GetProperty("ro.build.type", ""); \
+      kIsTargetBuild && build_type != "userdebug" && build_type != "eng") {     \
+    GTEST_SKIP() << "WARNING: TEST DISABLED FOR USER BUILD";                    \
+  }
+
 #endif  // ART_LIBARTBASE_BASE_COMMON_ART_TEST_H_
diff --git a/libartbase/base/flags.h b/libartbase/base/flags.h
index 4734a60568..cec6c584ff 100644
--- a/libartbase/base/flags.h
+++ b/libartbase/base/flags.h
@@ -311,6 +311,9 @@ struct Flags {
   // to logcat will be in human-readable text format.
   // Supported values are "text" and "xml".
   Flag<std::string> MetricsFormat{"metrics.format", "text", FlagType::kCmdlineOnly};
+
+  // Whether or not to force the metrics initialization.
+  Flag<bool> MetricsForceEnable{"metrics.force-enable", false, FlagType::kCmdlineOnly};
 };
 
 // This is the actual instance of all the flags.
diff --git a/libartbase/base/hiddenapi_flags.h b/libartbase/base/hiddenapi_flags.h
index 9d0a18e78f..0d7938aca1 100644
--- a/libartbase/base/hiddenapi_flags.h
+++ b/libartbase/base/hiddenapi_flags.h
@@ -263,11 +263,37 @@ class ApiList {
   bool operator<(const ApiList& other) const { return dex_flags_ < other.dex_flags_; }
   bool operator>(const ApiList& other) const { return dex_flags_ > other.dex_flags_; }
 
+  // In order to correctly handle flagged changes from Unsupported to the Sdk, where both will be
+  // set when the flag is enabled, consider Sdk to take precedence over any form of unsupported.
+  // Note, this is not necessary in the inverse direction, because API flagging does not currently
+  // support API removal. Moving from the blocklist to unsupported is also a case we don't have to
+  // consider.
+  // If this is true, the conflict resolves to Value::kSdk.
+  static bool is_conflicting_flags_acceptable(Value x, Value y) {
+    const auto predicate_non_symmetric = [] (auto l, auto r) {
+      if (l != Value::kSdk) return false;
+      switch (r) {
+        case Value::kSdk:
+        case Value::kUnsupported:
+        case Value::kMaxTargetO:
+        case Value::kMaxTargetP:
+        case Value::kMaxTargetQ:
+        case Value::kMaxTargetR:
+        case Value::kMaxTargetS:
+          return true;
+        default:
+          return false;
+      }
+    };
+    return predicate_non_symmetric(x, y) || predicate_non_symmetric(y, x);
+  }
+
   // Returns true if combining this ApiList with `other` will succeed.
   bool CanCombineWith(const ApiList& other) const {
     const Value val1 = GetValue();
     const Value val2 = other.GetValue();
-    return (val1 == val2) || (val1 == Value::kInvalid) || (val2 == Value::kInvalid);
+    return (val1 == val2) || (val1 == Value::kInvalid) || (val2 == Value::kInvalid) ||
+           is_conflicting_flags_acceptable(val1, val2);
   }
 
   // Combine two ApiList instances.
@@ -285,6 +311,8 @@ class ApiList {
       return ApiList(val2, domain_apis);
     } else if (val2 == Value::kInvalid) {
       return ApiList(val1, domain_apis);
+    } else if (is_conflicting_flags_acceptable(val1, val2)) {
+      return ApiList(Value::kSdk, domain_apis);
     } else {
       LOG(FATAL) << "Invalid combination of values " << Dumpable(ApiList(val1))
           << " and " << Dumpable(ApiList(val2));
diff --git a/libartbase/base/intrusive_forward_list_test.cc b/libartbase/base/intrusive_forward_list_test.cc
index 180c3d6667..f96fc9d516 100644
--- a/libartbase/base/intrusive_forward_list_test.cc
+++ b/libartbase/base/intrusive_forward_list_test.cc
@@ -16,6 +16,7 @@
 
 #include <algorithm>
 #include <forward_list>
+#include <type_traits>
 #include <vector>
 
 #include "gtest/gtest.h"
@@ -167,7 +168,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::ConstructRange() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 1, 2, 7 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
 }
@@ -182,12 +183,12 @@ template <typename ListType>
 void IntrusiveForwardListTest::Assign() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref1({ 2, 8, 5 });
-  std::vector<ValueType> storage1(ref1.begin(), ref1.end());
+  std::vector<std::remove_const_t<ValueType>> storage1(ref1.begin(), ref1.end());
   ListType ifl;
   ifl.assign(storage1.begin(), storage1.end());
   ASSERT_LISTS_EQUAL(ref1, ifl);
   std::forward_list<int> ref2({ 7, 1, 3 });
-  std::vector<ValueType> storage2(ref2.begin(), ref2.end());
+  std::vector<std::remove_const_t<ValueType>> storage2(ref2.begin(), ref2.end());
   ifl.assign(storage2.begin(), storage2.end());
   ASSERT_LISTS_EQUAL(ref2, ifl);
 }
@@ -279,18 +280,18 @@ void IntrusiveForwardListTest::InsertAfter2() {
   ListType ifl;
 
   auto ref_it = ref.insert_after(ref.before_begin(), { 2, 8, 5 });
-  std::vector<ValueType> storage1({ { 2 }, { 8 }, { 5 } });
+  std::vector<std::remove_const_t<ValueType>> storage1({ { 2 }, { 8 }, { 5 } });
   auto ifl_it = ifl.insert_after(ifl.before_begin(), storage1.begin(), storage1.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   ASSERT_EQ(*ref_it, *ifl_it);
 
-  std::vector<ValueType> storage2({ { 7 }, { 2 } });
+  std::vector<std::remove_const_t<ValueType>> storage2({ { 7 }, { 2 } });
   ref_it = ref.insert_after(ref.begin(), { 7, 2 });
   ifl_it = ifl.insert_after(ifl.begin(), storage2.begin(), storage2.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   ASSERT_EQ(*ref_it, *ifl_it);
 
-  std::vector<ValueType> storage3({ { 1 }, { 3 }, { 4 }, { 9 } });
+  std::vector<std::remove_const_t<ValueType>> storage3({ { 1 }, { 3 }, { 4 }, { 9 } });
   ref_it = ref.begin();
   ifl_it = ifl.begin();
   std::advance(ref_it, std::distance(ref.begin(), ref.end()) - 1);
@@ -310,7 +311,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::EraseAfter1() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 1, 2, 7, 4, 5 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   CHECK_EQ(std::distance(ref.begin(), ref.end()), 5);
@@ -373,7 +374,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::EraseAfter2() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 1, 2, 7, 4, 5, 3, 2, 8, 9 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   CHECK_EQ(std::distance(ref.begin(), ref.end()), 9);
@@ -413,10 +414,10 @@ template <typename ListType>
 void IntrusiveForwardListTest::SwapClear() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref1({ 1, 2, 7 });
-  std::vector<ValueType> storage1(ref1.begin(), ref1.end());
+  std::vector<std::remove_const_t<ValueType>> storage1(ref1.begin(), ref1.end());
   ListType ifl1(storage1.begin(), storage1.end());
   std::forward_list<int> ref2({ 3, 8, 6 });
-  std::vector<ValueType> storage2(ref2.begin(), ref2.end());
+  std::vector<std::remove_const_t<ValueType>> storage2(ref2.begin(), ref2.end());
   ListType ifl2(storage2.begin(), storage2.end());
   ASSERT_LISTS_EQUAL(ref1, ifl1);
   ASSERT_LISTS_EQUAL(ref2, ifl2);
@@ -449,7 +450,7 @@ void IntrusiveForwardListTest::SpliceAfter() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref1({ 3, 1, 2, 7, 4, 5, 4, 8, 7 });
   std::forward_list<int> ref2;
-  std::vector<ValueType> storage(ref1.begin(), ref1.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref1.begin(), ref1.end());
   ListType ifl1(storage.begin(), storage.end());
   ListType ifl2;
   ASSERT_LISTS_EQUAL(ref1, ifl1);
@@ -565,7 +566,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::Remove() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 3, 1, 2, 7, 4, 5, 4, 8, 7 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   ref.remove(1);
@@ -594,7 +595,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::Unique() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 3, 1, 1, 2, 3, 3, 7, 7, 4, 4, 5, 7 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   ref.unique();
@@ -623,10 +624,10 @@ template <typename ListType>
 void IntrusiveForwardListTest::Merge() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref1({ 1, 4, 8, 8, 12 });
-  std::vector<ValueType> storage1(ref1.begin(), ref1.end());
+  std::vector<std::remove_const_t<ValueType>> storage1(ref1.begin(), ref1.end());
   ListType ifl1(storage1.begin(), storage1.end());
   std::forward_list<int> ref2({ 3, 5, 6, 7, 9 });
-  std::vector<ValueType> storage2(ref2.begin(), ref2.end());
+  std::vector<std::remove_const_t<ValueType>> storage2(ref2.begin(), ref2.end());
   ListType ifl2(storage2.begin(), storage2.end());
   ASSERT_LISTS_EQUAL(ref1, ifl1);
   ASSERT_LISTS_EQUAL(ref2, ifl2);
@@ -651,7 +652,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::Sort1() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 2, 9, 8, 3, 7, 4, 1, 5, 3, 0 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   CHECK(!std::is_sorted(ref.begin(), ref.end()));
@@ -672,7 +673,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::Sort2() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 2, 9, 8, 3, 7, 4, 1, 5, 3, 0 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   auto cmp = [](const ValueType& lhs, const ValueType& rhs) {
@@ -696,7 +697,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::Reverse() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 8, 3, 5, 4, 1, 3 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
   CHECK(!std::is_sorted(ref.begin(), ref.end()));
@@ -717,7 +718,7 @@ template <typename ListType>
 void IntrusiveForwardListTest::ModifyValue() {
   using ValueType = typename ListType::value_type;
   std::forward_list<int> ref({ 3, 7, 42 });
-  std::vector<ValueType> storage(ref.begin(), ref.end());
+  std::vector<std::remove_const_t<ValueType>> storage(ref.begin(), ref.end());
   ListType ifl(storage.begin(), storage.end());
   ASSERT_LISTS_EQUAL(ref, ifl);
 
diff --git a/libartbase/base/mem_map.cc b/libartbase/base/mem_map.cc
index 0ab47f2384..08d452b5ff 100644
--- a/libartbase/base/mem_map.cc
+++ b/libartbase/base/mem_map.cc
@@ -344,13 +344,20 @@ MemMap MemMap::MapAnonymous(const char* name,
   // We need to store and potentially set an error number for pretty printing of errors
   int saved_errno = 0;
 
-  void* actual = MapInternal(addr,
-                             page_aligned_byte_count,
-                             prot,
-                             flags,
-                             fd.get(),
-                             0,
-                             low_4gb);
+  void* actual = nullptr;
+
+  // New Ubuntu linux kerners seem to ignore the address hint, so make it a firm request.
+  // Whereas old kernels allocated at 'addr' if provided, newer kernels seem to ignore it.
+  // However, MAP_FIXED_NOREPLACE tells the kernel it must allocate at the address or fail.
+  // Do this only on host since android kernels still obey the hint without flag (for now).
+  if (!kIsTargetBuild && (flags & MAP_FIXED) == 0 && addr != nullptr) {
+    actual = MapInternal(
+        addr, page_aligned_byte_count, prot, flags | MAP_FIXED_NOREPLACE, fd.get(), 0, low_4gb);
+    // If the fixed-address allocation failed, fallback to the default path (random address).
+  }
+  if (actual == nullptr || actual == MAP_FAILED) {
+    actual = MapInternal(addr, page_aligned_byte_count, prot, flags, fd.get(), 0, low_4gb);
+  }
   saved_errno = errno;
 
   if (actual == MAP_FAILED) {
diff --git a/libartbase/base/mem_map.h b/libartbase/base/mem_map.h
index 90e2031cf9..a3af44fadb 100644
--- a/libartbase/base/mem_map.h
+++ b/libartbase/base/mem_map.h
@@ -29,6 +29,12 @@
 #include "globals.h"
 #include "macros.h"
 
+#ifndef __BIONIC__
+#ifndef MAP_FIXED_NOREPLACE
+#define MAP_FIXED_NOREPLACE 0x100000
+#endif
+#endif  // __BIONIC__
+
 namespace art {
 
 #if defined(__LP64__) && !defined(__Fuchsia__) && \
diff --git a/libartbase/base/metrics/metrics.h b/libartbase/base/metrics/metrics.h
index d2ecd4d751..0fe090fdbc 100644
--- a/libartbase/base/metrics/metrics.h
+++ b/libartbase/base/metrics/metrics.h
@@ -31,6 +31,7 @@
 #include "base/bit_utils.h"
 #include "base/macros.h"
 #include "base/time_utils.h"
+#include "jni.h"
 #include "tinyxml2.h"
 
 #pragma clang diagnostic push
@@ -107,6 +108,8 @@ namespace art {
 class Runtime;
 struct RuntimeArgumentMap;
 
+[[maybe_unused]] static jlong VMRuntime_getFullGcCount(JNIEnv* env, jclass klass);
+
 namespace metrics {
 template <typename value_t>
 class MetricsBase;
@@ -340,6 +343,7 @@ class MetricsCounter : public MetricsBase<T> {
   static_assert(std::atomic<value_t>::is_always_lock_free);
 
   friend class ArtMetrics;
+  friend jlong art::VMRuntime_getFullGcCount(JNIEnv* env, jclass klass);
 };
 
 template <DatumId datum_id, typename T = uint64_t>
diff --git a/libartbase/base/utils.cc b/libartbase/base/utils.cc
index 0ec262e696..da53d0b99f 100644
--- a/libartbase/base/utils.cc
+++ b/libartbase/base/utils.cc
@@ -261,6 +261,9 @@ template void Split(const std::string_view& s,
 template void Split(const std::string_view& s,
                     char separator,
                     std::vector<std::string>* out_result);
+template void Split(const std::string& s,
+                    char separator,
+                    std::vector<std::string_view>* out_result);
 
 template <typename Str>
 void Split(const Str& s, char separator, size_t len, Str* out_result) {
@@ -283,7 +286,7 @@ template void Split(const std::string_view& s,
                     size_t len,
                     std::string_view* out_result);
 
-void SetThreadName(const char* thread_name) {
+void SetThreadName(pthread_t thr, const char* thread_name) {
   bool hasAt = false;
   bool hasDot = false;
   const char* s = thread_name;
@@ -306,15 +309,21 @@ void SetThreadName(const char* thread_name) {
   char buf[16];       // MAX_TASK_COMM_LEN=16 is hard-coded in the kernel.
   strncpy(buf, s, sizeof(buf)-1);
   buf[sizeof(buf)-1] = '\0';
-  errno = pthread_setname_np(pthread_self(), buf);
+  errno = pthread_setname_np(thr, buf);
   if (errno != 0) {
     PLOG(WARNING) << "Unable to set the name of current thread to '" << buf << "'";
   }
 #else  // __APPLE__
-  pthread_setname_np(thread_name);
+  if (pthread_equal(thr, pthread_self())) {
+    pthread_setname_np(thread_name);
+  } else {
+    PLOG(WARNING) << "Unable to set the name of another thread to '" << thread_name << "'";
+  }
 #endif
 }
 
+void SetThreadName(const char* thread_name) { SetThreadName(pthread_self(), thread_name); }
+
 void GetTaskStats(pid_t tid, char* state, int* utime, int* stime, int* task_cpu) {
   *utime = *stime = *task_cpu = 0;
 #ifdef _WIN32
@@ -368,9 +377,11 @@ std::string GetProcessStatus(const char* key) {
 
 size_t GetOsThreadStat(pid_t tid, char* buf, size_t len) {
 #if defined(__linux__)
-  static constexpr int NAME_BUF_SIZE = 50;
+  static constexpr int NAME_BUF_SIZE = 60;
   char file_name_buf[NAME_BUF_SIZE];
-  snprintf(file_name_buf, NAME_BUF_SIZE, "/proc/%d/stat", tid);
+  // We don't use just /proc/<pid>/stat since, in spite of some documentation to the contrary,
+  // those report utime and stime values for the whole process, not just the thread.
+  snprintf(file_name_buf, NAME_BUF_SIZE, "/proc/%d/task/%d/stat", getpid(), tid);
   int stat_fd = open(file_name_buf, O_RDONLY | O_CLOEXEC);
   if (stat_fd >= 0) {
     ssize_t bytes_read = TEMP_FAILURE_RETRY(read(stat_fd, buf, len));
@@ -389,7 +400,7 @@ size_t GetOsThreadStat(pid_t tid, char* buf, size_t len) {
 }
 
 std::string GetOsThreadStatQuick(pid_t tid) {
-  static constexpr int BUF_SIZE = 90;
+  static constexpr int BUF_SIZE = 100;
   char buf[BUF_SIZE];
 #if defined(__linux__)
   if (GetOsThreadStat(tid, buf, BUF_SIZE) == 0) {
diff --git a/libartbase/base/utils.h b/libartbase/base/utils.h
index b5e03dcdb8..32f8b87204 100644
--- a/libartbase/base/utils.h
+++ b/libartbase/base/utils.h
@@ -65,10 +65,14 @@ uint32_t GetTid();
 // Returns the given thread's name.
 std::string GetThreadName(pid_t tid);
 
-// Sets the name of the current thread. The name may be truncated to an
+// Sets the pthread name of the current thread. The name may be truncated to an
 // implementation-defined limit.
 void SetThreadName(const char* thread_name);
 
+// Sets the pthread name of the given thread. The name may be truncated to an
+// implementation-defined limit. Does nothing if not supported by the OS.
+void SetThreadName(pthread_t thr, const char* thread_name);
+
 // Reads data from "/proc/self/task/${tid}/stat".
 void GetTaskStats(pid_t tid, char* state, int* utime, int* stime, int* task_cpu);
 
diff --git a/libartpalette/Android.bp b/libartpalette/Android.bp
index f51809ec61..89607219cc 100644
--- a/libartpalette/Android.bp
+++ b/libartpalette/Android.bp
@@ -27,8 +27,10 @@ package {
 cc_defaults {
     name: "libartpalette_defaults",
     defaults: ["art_defaults"],
-    host_supported: true,
     export_include_dirs: ["include"],
+    header_libs: [
+        "jni_headers",
+    ],
 }
 
 cc_library_headers {
@@ -47,6 +49,7 @@ cc_library_headers {
 art_cc_library {
     name: "libartpalette",
     defaults: ["libartpalette_defaults"],
+    host_supported: true,
     visibility: [
         // TODO(b/183483755): Please visibility checks when the prebuilt
         // libartpalette is present but not preferred, and the prebuilt
@@ -57,7 +60,6 @@ art_cc_library {
     ],
     header_libs: [
         "libbase_headers",
-        "jni_headers",
     ],
     export_header_lib_headers: [
         "jni_headers",
@@ -112,6 +114,23 @@ art_cc_library {
     ],
 }
 
+art_cc_library {
+    name: "libartpalette_fake",
+    defaults: ["libartpalette_defaults"],
+    srcs: ["system/palette_fake.cc"],
+    stem: "libartpalette-system",
+    relative_install_path: "art_fake", // Avoid conflict with the real lib.
+    shared_libs: [
+        "libbase",
+        "liblog",
+    ],
+    compile_multilib: "both",
+    visibility: [
+        "//visibility:override",
+        "//visibility:private",
+    ],
+}
+
 art_cc_defaults {
     name: "art_libartpalette_tests_defaults",
     srcs: ["apex/palette_test.cc"],
@@ -122,7 +141,7 @@ art_cc_defaults {
     },
 }
 
-// Version of ART gtest `art_libartpalette_tests` bundled with the ART APEX on target.
+// Version of ART gtest `art_libartpalette_tests` for host.
 // TODO(b/192274705): Remove this module when the migration to standalone ART gtests is complete.
 art_cc_test {
     name: "art_libartpalette_tests",
@@ -131,13 +150,13 @@ art_cc_test {
         "art_libartpalette_tests_defaults",
     ],
     host_supported: true,
+    device_supported: false,
 }
 
 // Standalone version of ART gtest `art_libartpalette_tests`, not bundled with the ART APEX on
 // target.
 art_cc_test {
     name: "art_standalone_libartpalette_tests",
-    team: "trendy_team_art_performance",
     defaults: [
         "art_standalone_gtest_defaults",
         "art_libartpalette_tests_defaults",
diff --git a/libartpalette/apex/palette_test.cc b/libartpalette/apex/palette_test.cc
index cbdfafa733..47eec51df9 100644
--- a/libartpalette/apex/palette_test.cc
+++ b/libartpalette/apex/palette_test.cc
@@ -22,16 +22,15 @@
 #include <unistd.h>
 
 #include <cstring>
-#include <filesystem>
+
+#include "base/common_art_test.h"
+#include "gtest/gtest.h"
 
 #ifdef ART_TARGET_ANDROID
 #include "android-modules-utils/sdk_level.h"
 #include "android/api-level.h"
 #endif
 
-#include "base/common_art_test.h"
-#include "gtest/gtest.h"
-
 namespace {
 
 pid_t GetTid() {
@@ -130,11 +129,6 @@ TEST_F(PaletteClientTest, SetTaskProfiles) {
 #ifndef ART_TARGET_ANDROID
   GTEST_SKIP() << "SetTaskProfiles is only supported on Android";
 #else
-  if (!std::filesystem::exists("/sys/fs/cgroup/cgroup.controllers")) {
-    // This is intended to detect ART chroot setups, where SetTaskProfiles won't work.
-    GTEST_SKIP() << "Kernel cgroup support missing";
-  }
-
   const char* profiles[] = {"ProcessCapacityHigh", "TimerSlackNormal"};
   palette_status_t res = PaletteSetTaskProfiles(GetTid(), &profiles[0], 2);
   if (PaletteSetTaskProfilesIsSupported(res)) {
@@ -153,11 +147,6 @@ TEST_F(PaletteClientTest, SetTaskProfilesCpp) {
 #ifndef ART_TARGET_ANDROID
   GTEST_SKIP() << "SetTaskProfiles is only supported on Android";
 #else
-  if (!std::filesystem::exists("/sys/fs/cgroup/cgroup.controllers")) {
-    // This is intended to detect ART chroot setups, where SetTaskProfiles won't work.
-    GTEST_SKIP() << "Kernel cgroup support missing";
-  }
-
   std::vector<std::string> profiles = {"ProcessCapacityHigh", "TimerSlackNormal"};
   palette_status_t res = PaletteSetTaskProfiles(GetTid(), profiles);
   if (PaletteSetTaskProfilesIsSupported(res)) {
diff --git a/libartservice/service/Android.bp b/libartservice/service/Android.bp
index 8204d14672..62bdda9edd 100644
--- a/libartservice/service/Android.bp
+++ b/libartservice/service/Android.bp
@@ -35,6 +35,11 @@ cc_defaults {
         "liblog", // Used by "JNIHelp.h".
         "libnativehelper",
     ],
+    target: {
+        android: {
+            compile_multilib: "first",
+        },
+    },
 }
 
 cc_library {
@@ -82,6 +87,8 @@ java_defaults {
     ],
     libs: [
         "androidx.annotation_annotation",
+        "aconfig-annotations-lib",
+        "art-aconfig-flags-java-lib",
         "auto_value_annotations",
         "sdk_module-lib_current_framework-configinfrastructure",
         "sdk_module-lib_current_framework-permission-s",
@@ -128,7 +135,9 @@ java_sdk_library {
         "service-art-defaults",
         "framework-system-server-module-optimize-defaults",
     ],
-    permitted_packages: ["com.android.server.art"],
+    permitted_packages: [
+        "com.android.server.art",
+    ],
     dex_preopt: {
         profile: "art-profile",
     },
@@ -144,6 +153,9 @@ java_sdk_library {
     optimize: {
         proguard_flags_files: ["proguard.flags"],
     },
+    aconfig_declarations: [
+        "art-aconfig-flags",
+    ],
 }
 
 java_library {
@@ -196,10 +208,11 @@ art_cc_defaults {
     ],
 }
 
-// Version of ART gtest `art_libartservice_tests` bundled with the ART APEX on target.
+// Version of ART gtest `art_libartservice_tests` for host.
 // TODO(b/192274705): Remove this module when the migration to standalone ART gtests is complete.
 art_cc_test {
     name: "art_libartservice_tests",
+    device_supported: false,
     defaults: [
         "art_gtest_defaults",
         "art_libartservice_tests_defaults",
@@ -222,6 +235,7 @@ art_cc_test {
         "libarttools",
         "libbase",
     ],
+    test_config_template: ":art-gtests-target-standalone-non-multilib-template",
 }
 
 android_test {
@@ -258,7 +272,7 @@ android_test {
         "libdexmakerjvmtiagent",
         "libstaticjvmtiagent",
     ],
-    compile_multilib: "both",
+    compile_multilib: "first",
 
     // TODO: This module should move to sdk_version: "system_server_current" when possible,
     //   as this will restrict the APIs available to just that expected system API. For now,
diff --git a/libartservice/service/api/system-server-lint-baseline.txt b/libartservice/service/api/system-server-lint-baseline.txt
index 17628b2704..88abaf320d 100644
--- a/libartservice/service/api/system-server-lint-baseline.txt
+++ b/libartservice/service/api/system-server-lint-baseline.txt
@@ -1,15 +1,3 @@
 // Baseline format: 1.0
 DeprecationMismatch: com.android.server.art.ArtManagerLocal#ArtManagerLocal():
     Constructor com.android.server.art.ArtManagerLocal.ArtManagerLocal(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
-
-
-UnflaggedApi: com.android.server.art.model.DexoptResult#EXTENDED_BAD_EXTERNAL_PROFILE:
-    New API must be flagged with @FlaggedApi: field com.android.server.art.model.DexoptResult.EXTENDED_BAD_EXTERNAL_PROFILE
-UnflaggedApi: com.android.server.art.model.DexoptResult#EXTENDED_SKIPPED_NO_DEX_CODE:
-    New API must be flagged with @FlaggedApi: field com.android.server.art.model.DexoptResult.EXTENDED_SKIPPED_NO_DEX_CODE
-UnflaggedApi: com.android.server.art.model.DexoptResult#EXTENDED_SKIPPED_STORAGE_LOW:
-    New API must be flagged with @FlaggedApi: field com.android.server.art.model.DexoptResult.EXTENDED_SKIPPED_STORAGE_LOW
-UnflaggedApi: com.android.server.art.model.DexoptResult.DexContainerFileDexoptResult#getExtendedStatusFlags():
-    New API must be flagged with @FlaggedApi: method com.android.server.art.model.DexoptResult.DexContainerFileDexoptResult.getExtendedStatusFlags()
-UnflaggedApi: com.android.server.art.model.DexoptResult.DexContainerFileDexoptResult#getExternalProfileErrors():
-    New API must be flagged with @FlaggedApi: method com.android.server.art.model.DexoptResult.DexContainerFileDexoptResult.getExternalProfileErrors()
diff --git a/libartservice/service/java/com/android/server/art/ArtManagerLocal.java b/libartservice/service/java/com/android/server/art/ArtManagerLocal.java
index 63700648a0..8436fd1095 100644
--- a/libartservice/service/java/com/android/server/art/ArtManagerLocal.java
+++ b/libartservice/service/java/com/android/server/art/ArtManagerLocal.java
@@ -20,7 +20,6 @@ import static com.android.server.art.ArtFileManager.ProfileLists;
 import static com.android.server.art.ArtFileManager.UsableArtifactLists;
 import static com.android.server.art.ArtFileManager.WritableArtifactLists;
 import static com.android.server.art.DexMetadataHelper.DexMetadataInfo;
-import static com.android.server.art.DexUseManagerLocal.SecondaryDexInfo;
 import static com.android.server.art.PrimaryDexUtils.DetailedPrimaryDexInfo;
 import static com.android.server.art.PrimaryDexUtils.PrimaryDexInfo;
 import static com.android.server.art.ProfilePath.WritableProfilePath;
@@ -36,7 +35,6 @@ import static com.android.server.art.model.DexoptStatus.DexContainerFileDexoptSt
 import android.annotation.CallbackExecutor;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
-import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.app.job.JobInfo;
@@ -103,6 +101,8 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.Consumer;
@@ -940,7 +940,6 @@ public final class ArtManagerLocal {
      *         the directory beneath /apex, e.g., {@code com.android.art} (not the <b>package
      *         names</b>, e.g., {@code com.google.android.art}).
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
     public void onApexStaged(@NonNull String[] stagedApexModuleNames) {
         mInjector.getPreRebootDexoptJob().onUpdateReady(null /* otaSlot */);
@@ -987,7 +986,6 @@ public final class ArtManagerLocal {
      * @throws IllegalStateException if the operation encounters an error that should never happen
      *         (e.g., an internal logic error).
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     @NonNull
     public ArtManagedFileStats getArtManagedFileStats(
@@ -1038,7 +1036,6 @@ public final class ArtManagerLocal {
      * Overrides the compiler filter of a package. The callback is called whenever a package is
      * going to be dexopted. This method is thread-safe.
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     public void setAdjustCompilerFilterCallback(@NonNull @CallbackExecutor Executor executor,
             @NonNull AdjustCompilerFilterCallback callback) {
@@ -1050,7 +1047,6 @@ public final class ArtManagerLocal {
      * #setAdjustCompilerFilterCallback(Executor, AdjustCompilerFilterCallback)}. This
      * method is thread-safe.
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     public void clearAdjustCompilerFilterCallback() {
         mInjector.getConfig().clearAdjustCompilerFilterCallback();
@@ -1293,6 +1289,13 @@ public final class ArtManagerLocal {
                 packages = filterAndSortByLastActiveTime(
                         packages, false /* keepRecent */, false /* descending */);
                 break;
+            case ReasonMapping.REASON_FIRST_BOOT:
+                // Don't filter the default package list and no need to sort
+                // as in some cases the system time can advance during bootup
+                // after package installation and cause filtering to exclude
+                // all packages when pm.dexopt.downgrade_after_inactive_days
+                // is set. See aosp/3237478 for more details.
+                break;
             default:
                 // Actually, the sorting is only needed for background dexopt, but we do it for all
                 // cases for simplicity.
@@ -1441,7 +1444,6 @@ public final class ArtManagerLocal {
     }
 
     /** @hide */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     @SystemApi(client = SystemApi.Client.SYSTEM_SERVER)
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     public interface AdjustCompilerFilterCallback {
@@ -1485,7 +1487,6 @@ public final class ArtManagerLocal {
          * @return the compiler filter after adjustment. This will be the input to step 5 described
          *         above
          */
-        @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
         @NonNull
         String onAdjustCompilerFilter(@NonNull String packageName,
                 @NonNull String originalCompilerFilter, @NonNull String reason);
@@ -1521,6 +1522,7 @@ public final class ArtManagerLocal {
         @Nullable private final Context mContext;
         @Nullable private final PackageManagerLocal mPackageManagerLocal;
         @Nullable private final Config mConfig;
+        @Nullable private final ThreadPoolExecutor mReporterExecutor;
         @Nullable private BackgroundDexoptJob mBgDexoptJob = null;
         @Nullable private PreRebootDexoptJob mPrDexoptJob = null;
 
@@ -1531,6 +1533,7 @@ public final class ArtManagerLocal {
             mContext = null;
             mPackageManagerLocal = null;
             mConfig = null;
+            mReporterExecutor = null;
         }
 
         @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -1541,6 +1544,10 @@ public final class ArtManagerLocal {
             mPackageManagerLocal = Objects.requireNonNull(
                     LocalManagerRegistry.getManager(PackageManagerLocal.class));
             mConfig = new Config();
+            mReporterExecutor =
+                    new ThreadPoolExecutor(1 /* corePoolSize */, 1 /* maximumPoolSize */,
+                            60 /* keepTimeAlive */, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
+            mReporterExecutor.allowsCoreThreadTimeOut();
 
             // Call the getters for the dependencies that aren't optional, to ensure correct
             // initialization order.
@@ -1549,6 +1556,14 @@ public final class ArtManagerLocal {
             getDexUseManager();
             getStorageManager();
             GlobalInjector.getInstance().checkArtModuleServiceManager();
+
+            // `PreRebootDexoptJob` does not depend on external dependencies, so unlike the calls
+            // above, this call is not for checking the dependencies. Rather, we make this call here
+            // to trigger the construction of `PreRebootDexoptJob`, which may clean up leftover
+            // chroot if there is any.
+            if (SdkLevel.isAtLeastV()) {
+                getPreRebootDexoptJob();
+            }
         }
 
         @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -1579,7 +1594,7 @@ public final class ArtManagerLocal {
         @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
         @NonNull
         public DexoptHelper getDexoptHelper() {
-            return new DexoptHelper(getContext(), getConfig());
+            return new DexoptHelper(getContext(), getConfig(), getReporterExecutor());
         }
 
         @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -1588,6 +1603,12 @@ public final class ArtManagerLocal {
             return mConfig;
         }
 
+        @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+        @NonNull
+        public Executor getReporterExecutor() {
+            return mReporterExecutor;
+        }
+
         /** Returns the registered {@link AppHibernationManager} instance. */
         @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
         @NonNull
diff --git a/libartservice/service/java/com/android/server/art/ArtShellCommand.java b/libartservice/service/java/com/android/server/art/ArtShellCommand.java
index 8c59cad1b7..f7d26cb36f 100644
--- a/libartservice/service/java/com/android/server/art/ArtShellCommand.java
+++ b/libartservice/service/java/com/android/server/art/ArtShellCommand.java
@@ -731,7 +731,7 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
 
         switch (mode) {
             case "--version":
-                pw.println(2);
+                pw.println(3);
                 return 0;
             case "--test":
                 return handleTestPrDexoptJob(pw);
@@ -817,7 +817,7 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
 
     @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
     private int handleSchedulePrDexoptJob(@NonNull PrintWriter pw, @Nullable String otaSlot) {
-        int code = mArtManagerLocal.getPreRebootDexoptJob().onUpdateReady(otaSlot);
+        int code = mArtManagerLocal.getPreRebootDexoptJob().onUpdateReadyImpl(otaSlot);
         switch (code) {
             case ArtFlags.SCHEDULE_SUCCESS:
                 pw.println("Pre-reboot Dexopt job scheduled");
diff --git a/libartservice/service/java/com/android/server/art/Dex2OatStatsReporter.java b/libartservice/service/java/com/android/server/art/Dex2OatStatsReporter.java
new file mode 100644
index 0000000000..d553113301
--- /dev/null
+++ b/libartservice/service/java/com/android/server/art/Dex2OatStatsReporter.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.art;
+
+import android.os.Build;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+
+import com.android.server.art.model.DetailedDexInfo;
+import com.android.server.art.model.DexMetadata;
+
+/**
+ * A class to report dex2oat metrics to StatsD.
+ *
+ * @hide
+ */
+@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+public class Dex2OatStatsReporter {
+    public static void report(int appId, @NonNull String compilerFilter,
+            @NonNull String compilationReason, @DexMetadata.Type int dexMetadataType,
+            @NonNull DetailedDexInfo dexInfo, @NonNull String isa, @NonNull Dex2OatResult result,
+            long artifactsSize, long compilationTime) {
+        ArtStatsLog.write(ArtStatsLog.ART_DEX2OAT_REPORTED, appId,
+                translateCompilerFilter(compilerFilter),
+                translateCompilationReason(compilationReason),
+                translateDexMetadataType(dexMetadataType), getApkType(dexInfo), translateIsa(isa),
+                result.status, result.exitCode, result.signal, (int) (artifactsSize / 1024),
+                (int) compilationTime);
+    }
+
+    private static int translateCompilerFilter(String compilerFilter) {
+        return switch (compilerFilter) {
+            case "assume-verified" ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_ASSUMED_VERIFIED;
+            case "verify" ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_VERIFY;
+            case "space-profile" ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_SPACE_PROFILE;
+            case "space" ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_SPACE;
+            case "speed-profile" ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_SPEED_PROFILE;
+            case "speed" ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_SPEED;
+            case "everything-profile" ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_EVERYTHING_PROFILE;
+            case "everything" ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_EVERYTHING;
+            default ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__COMPILER_FILTER__ART_COMPILATION_FILTER_UNKNOWN;
+        };
+    }
+
+    private static int translateCompilationReason(String compilationReason) {
+        return switch (compilationReason) {
+            case ReasonMapping.REASON_FIRST_BOOT ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_FIRST_BOOT;
+            case ReasonMapping.REASON_BOOT_AFTER_OTA ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_BOOT_AFTER_OTA;
+            case ReasonMapping.REASON_BOOT_AFTER_MAINLINE_UPDATE ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_BOOT_AFTER_MAINLINE_UPDATE;
+            case ReasonMapping.REASON_INSTALL ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INSTALL;
+            case ReasonMapping.REASON_BG_DEXOPT ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_BG_DEXOPT;
+            case ReasonMapping.REASON_CMDLINE ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_CMDLINE;
+            case ReasonMapping.REASON_INACTIVE ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INACTIVE;
+            case ReasonMapping.REASON_PRE_REBOOT_DEXOPT ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_AB_OTA;
+            case ReasonMapping.REASON_INSTALL_FAST ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INSTALL_FAST;
+            case ReasonMapping.REASON_INSTALL_BULK ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INSTALL_BULK;
+            case ReasonMapping.REASON_INSTALL_BULK_SECONDARY ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INSTALL_BULK_SECONDARY;
+            case ReasonMapping.REASON_INSTALL_BULK_DOWNGRADED ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INSTALL_BULK_DOWNGRADED;
+            case ReasonMapping.REASON_INSTALL_BULK_SECONDARY_DOWNGRADED ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_INSTALL_BULK_SECONDARY_DOWNGRADED;
+            default ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__COMPILATION_REASON__ART_COMPILATION_REASON_UNKNOWN;
+        };
+    }
+
+    private static int translateIsa(String isa) {
+        return switch (isa) {
+            case "arm" -> ArtStatsLog.ART_DEX2_OAT_REPORTED__ISA__ART_ISA_ARM;
+            case "arm64" -> ArtStatsLog.ART_DEX2_OAT_REPORTED__ISA__ART_ISA_ARM64;
+            case "riscv64" -> ArtStatsLog.ART_DEX2_OAT_REPORTED__ISA__ART_ISA_RISCV64;
+            case "x86" -> ArtStatsLog.ART_DEX2_OAT_REPORTED__ISA__ART_ISA_X86;
+            case "x86_64" -> ArtStatsLog.ART_DATUM_DELTA_REPORTED__ISA__ART_ISA_X86_64;
+            default -> ArtStatsLog.ART_DEX2_OAT_REPORTED__ISA__ART_ISA_UNKNOWN;
+        };
+    }
+
+    private static int translateDexMetadataType(@DexMetadata.Type int dexMetadataType) {
+        return switch (dexMetadataType) {
+            case DexMetadata.TYPE_PROFILE ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_PROFILE;
+            case DexMetadata.TYPE_VDEX ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_VDEX;
+            case DexMetadata.TYPE_PROFILE_AND_VDEX ->
+                ArtStatsLog
+                        .ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_PROFILE_AND_VDEX;
+            case DexMetadata.TYPE_NONE ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_NONE;
+            case DexMetadata.TYPE_ERROR ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_ERROR;
+            case DexMetadata.TYPE_UNKNOWN ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_UNKNOWN;
+            default ->
+                ArtStatsLog.ART_DEX2_OAT_REPORTED__DEX_METADATA_TYPE__ART_DEX_METADATA_TYPE_UNKNOWN;
+        };
+    }
+
+    private static int getApkType(DetailedDexInfo dexInfo) {
+        if (dexInfo instanceof PrimaryDexUtils.PrimaryDexInfo primaryDexInfo) {
+            return primaryDexInfo.splitName() == null
+                    ? ArtStatsLog.ART_DEX2_OAT_REPORTED__APK_TYPE__ART_APK_TYPE_BASE
+                    : ArtStatsLog.ART_DEX2_OAT_REPORTED__APK_TYPE__ART_APK_TYPE_SPLIT;
+        } else if (dexInfo instanceof DexUseManagerLocal.CheckedSecondaryDexInfo) {
+            return ArtStatsLog.ART_DEX2_OAT_REPORTED__APK_TYPE__ART_APK_TYPE_SECONDARY;
+        }
+        return ArtStatsLog.ART_DEX2_OAT_REPORTED__APK_TYPE__ART_APK_TYPE_UNKNOWN;
+    }
+
+    public record Dex2OatResult(int status, int exitCode, int signal) {
+        public static Dex2OatResult notRun() {
+            return new Dex2OatResult(
+                    ArtStatsLog.ART_DEX2_OAT_REPORTED__RESULT_STATUS__EXEC_RESULT_STATUS_NOT_RUN,
+                    -1 /* exitCode */, 0 /* signal */);
+        }
+
+        public static Dex2OatResult exited(int exitCode) {
+            return new Dex2OatResult(
+                    ArtStatsLog.ART_DEX2_OAT_REPORTED__RESULT_STATUS__EXEC_RESULT_STATUS_EXITED,
+                    exitCode, 0 /* signal */);
+        }
+
+        public static Dex2OatResult cancelled() {
+            return new Dex2OatResult(
+                    ArtStatsLog.ART_DEX2_OAT_REPORTED__RESULT_STATUS__EXEC_RESULT_STATUS_CANCELLED,
+                    -1 /* exitCode */, 0 /* signal */);
+        }
+    }
+}
diff --git a/libartservice/service/java/com/android/server/art/DexMetadataHelper.java b/libartservice/service/java/com/android/server/art/DexMetadataHelper.java
index 99d92083d3..237bb1878e 100644
--- a/libartservice/service/java/com/android/server/art/DexMetadataHelper.java
+++ b/libartservice/service/java/com/android/server/art/DexMetadataHelper.java
@@ -23,6 +23,7 @@ import android.os.Build;
 import androidx.annotation.RequiresApi;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.art.model.DexMetadata;
 import com.android.server.art.proto.DexMetadataConfig;
 
 import java.io.FileNotFoundException;
@@ -44,6 +45,9 @@ import java.util.zip.ZipFile;
 public class DexMetadataHelper {
     @NonNull private final Injector mInjector;
 
+    private static final String PROFILE_DEX_METADATA = "primary.prof";
+    private static final String VDEX_DEX_METADATA = "primary.vdex";
+
     public DexMetadataHelper() {
         this(new Injector());
     }
@@ -56,29 +60,31 @@ public class DexMetadataHelper {
     @NonNull
     public DexMetadataInfo getDexMetadataInfo(@Nullable DexMetadataPath dmPath) {
         if (dmPath == null) {
-            return getDefaultDexMetadataInfo();
+            return getDefaultDexMetadataInfo(DexMetadata.TYPE_NONE);
         }
 
         String realDmPath = getDmPath(dmPath);
         try (var zipFile = mInjector.openZipFile(realDmPath)) {
             ZipEntry entry = zipFile.getEntry("config.pb");
             if (entry == null) {
-                return new DexMetadataInfo(dmPath, DexMetadataConfig.getDefaultInstance());
+                return new DexMetadataInfo(
+                        dmPath, DexMetadataConfig.getDefaultInstance(), getType(zipFile));
             }
             try (InputStream stream = zipFile.getInputStream(entry)) {
-                return new DexMetadataInfo(dmPath, DexMetadataConfig.parseFrom(stream));
+                return new DexMetadataInfo(
+                        dmPath, DexMetadataConfig.parseFrom(stream), getType(zipFile));
             }
         } catch (IOException e) {
             if (!(e instanceof FileNotFoundException || e instanceof NoSuchFileException)) {
                 AsLog.e(String.format("Failed to read dm file '%s'", realDmPath), e);
             }
-            return getDefaultDexMetadataInfo();
+            return getDefaultDexMetadataInfo(DexMetadata.TYPE_ERROR);
         }
     }
 
     @NonNull
-    private DexMetadataInfo getDefaultDexMetadataInfo() {
-        return new DexMetadataInfo(null /* dmPath */, DexMetadataConfig.getDefaultInstance());
+    private DexMetadataInfo getDefaultDexMetadataInfo(@DexMetadata.Type int type) {
+        return new DexMetadataInfo(null /* dmPath */, DexMetadataConfig.getDefaultInstance(), type);
     }
 
     @NonNull
@@ -88,14 +94,31 @@ public class DexMetadataHelper {
         return (pos != -1 ? dexPath.substring(0, pos) : dexPath) + ".dm";
     }
 
+    private static @DexMetadata.Type int getType(@NonNull ZipFile zipFile) {
+        var profile = zipFile.getEntry(PROFILE_DEX_METADATA);
+        var vdex = zipFile.getEntry(VDEX_DEX_METADATA);
+
+        if (profile != null && vdex != null) {
+            return DexMetadata.TYPE_PROFILE_AND_VDEX;
+        } else if (profile != null) {
+            return DexMetadata.TYPE_PROFILE;
+        } else if (vdex != null) {
+            return DexMetadata.TYPE_VDEX;
+        } else {
+            return DexMetadata.TYPE_NONE;
+        }
+    }
+
     /**
      * @param dmPath Represents the path to the dm file, if it exists. Or null if the file doesn't
      *         exist or an error occurred.
      * @param config The config deserialized from `config.pb`, if it exists. Or the default instance
      *         if the file doesn't exist or an error occurred.
+     * @param type An enum value representing whether the dm file contains a profile, a VDEX file,
+     *         none, or both.
      */
-    public record DexMetadataInfo(
-            @Nullable DexMetadataPath dmPath, @NonNull DexMetadataConfig config) {}
+    public record DexMetadataInfo(@Nullable DexMetadataPath dmPath,
+            @NonNull DexMetadataConfig config, @DexMetadata.Type int type) {}
 
     /**
      * Injector pattern for testing purpose.
diff --git a/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java b/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java
index 9ef804919a..7eb5a69165 100644
--- a/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java
+++ b/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java
@@ -16,13 +16,16 @@
 
 package com.android.server.art;
 
+import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.SharedLibraryInfo;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Environment;
@@ -30,6 +33,7 @@ import android.os.Process;
 import android.os.RemoteException;
 import android.os.ServiceSpecificException;
 import android.os.UserHandle;
+import android.util.LruCache;
 
 import androidx.annotation.RequiresApi;
 
@@ -50,6 +54,7 @@ import com.android.server.pm.PackageManagerLocal;
 import com.android.server.pm.pkg.AndroidPackage;
 import com.android.server.pm.pkg.AndroidPackageSplit;
 import com.android.server.pm.pkg.PackageState;
+import com.android.server.pm.pkg.SharedLibrary;
 
 import com.google.auto.value.AutoValue;
 
@@ -59,9 +64,9 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -72,6 +77,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.SequencedMap;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executors;
@@ -117,6 +123,13 @@ public class DexUseManagerLocal {
     @NonNull private final Injector mInjector;
     @NonNull private final Debouncer mDebouncer;
 
+    // The cache is motivated by the fact that only a handful of packages are commonly used by other
+    // packages. The cache size is arbitrarily decided.
+    /** A map from recently used dex files to their package names. */
+    @NonNull
+    private final LruCache<String, String> mRecentDexFilesToPackageNames =
+            new LruCache<>(50 /* maxSize */);
+
     private final Object mLock = new Object();
     @GuardedBy("mLock") @NonNull private DexUse mDexUse; // Initialized by `load`.
     @GuardedBy("mLock") private int mRevision = 0;
@@ -406,52 +419,157 @@ public class DexUseManagerLocal {
         for (var entry : classLoaderContextByDexContainerFile.entrySet()) {
             String dexPath = Utils.assertNonEmpty(entry.getKey());
             String classLoaderContext = Utils.assertNonEmpty(entry.getValue());
-            String owningPackageName = findOwningPackage(snapshot, loadingPackageName,
-                    (pkgState) -> isOwningPackageForPrimaryDex(pkgState, dexPath));
-            if (owningPackageName != null) {
-                addPrimaryDexUse(owningPackageName, dexPath, loadingPackageName, isolatedProcess,
-                        lastUsedAtMs);
+            FindResult findResult = findOwningPackage(snapshot, loadingPackageName, dexPath);
+            if (findResult == null) {
                 continue;
             }
-            Path path = Paths.get(dexPath);
-            synchronized (mLock) {
-                owningPackageName = findOwningPackage(snapshot, loadingPackageName,
-                        (pkgState) -> isOwningPackageForSecondaryDexLocked(pkgState, path));
-            }
-            if (owningPackageName != null) {
-                PackageState loadingPkgState =
-                        Utils.getPackageStateOrThrow(snapshot, loadingPackageName);
-                // An app is always launched with its primary ABI.
-                Utils.Abi abi = Utils.getPrimaryAbi(loadingPkgState);
-                addSecondaryDexUse(owningPackageName, dexPath, loadingPackageName, isolatedProcess,
-                        classLoaderContext, abi.name(), lastUsedAtMs);
-                continue;
+
+            switch (findResult.type()) {
+                case TYPE_PRIMARY:
+                    addPrimaryDexUse(findResult.owningPackageName(), dexPath, loadingPackageName,
+                            isolatedProcess, lastUsedAtMs);
+                    break;
+                case TYPE_SECONDARY:
+                    PackageState loadingPkgState =
+                            Utils.getPackageStateOrThrow(snapshot, loadingPackageName);
+                    // An app is always launched with its primary ABI.
+                    Utils.Abi abi = Utils.getPrimaryAbi(loadingPkgState);
+                    addSecondaryDexUse(findResult.owningPackageName(), dexPath, loadingPackageName,
+                            isolatedProcess, classLoaderContext, abi.name(), lastUsedAtMs);
+                    break;
+                default:
+                    // Intentionally ignore.
             }
-            // It is expected that a dex file isn't owned by any package. For example, the dex
-            // file could be a shared library jar.
         }
     }
 
     @Nullable
-    private static String findOwningPackage(@NonNull PackageManagerLocal.FilteredSnapshot snapshot,
-            @NonNull String loadingPackageName,
-            @NonNull Function<PackageState, Boolean> predicate) {
+    private FindResult findOwningPackage(@NonNull PackageManagerLocal.FilteredSnapshot snapshot,
+            @NonNull String loadingPackageName, @NonNull String dexPath) {
         // Most likely, the package is loading its own dex file, so we check this first as an
         // optimization.
         PackageState loadingPkgState = Utils.getPackageStateOrThrow(snapshot, loadingPackageName);
-        if (predicate.apply(loadingPkgState)) {
-            return loadingPkgState.getPackageName();
+        FindResult result =
+                checkForPackage(loadingPkgState, dexPath, true /* checkForSharedLibraries */);
+        if (result != null) {
+            return result;
+        }
+
+        // Check all packages.
+        result = checkForAllPackages(dexPath);
+        if (result != null && result.type() != TYPE_DONT_RECORD
+                && snapshot.getPackageState(result.owningPackageName()) != null) {
+            return result;
         }
 
-        for (PackageState pkgState : snapshot.getPackageStates().values()) {
-            if (predicate.apply(pkgState)) {
-                return pkgState.getPackageName();
+        // It is expected that there is no result. For example, the app could be loading a dex file
+        // from a non-canonical location, or it could be sending a bogus dex filename.
+        return null;
+    }
+
+    /**
+     * Returns the owner of the given dex file, found among all packages. The return value is
+     * unfiltered and must be checked whether it's visible to the calling app.
+     */
+    @SuppressLint("NewApi") // Using new Libcore APIs from the same module.
+    @Nullable
+    private FindResult checkForAllPackages(@NonNull String dexPath) {
+        // Iterating over the filtered snapshot is slow because it involves a
+        // `shouldFilterApplication` call on every iteration, which is considerably more expensive
+        // than a `checkForPackage` call. Therefore, we iterate over the unfiltered snapshot
+        // instead.
+        // There may be some inconsistencies between the filtered snapshot and the unfiltered
+        // snapshot, as they are not created atomically, but this is fine. If a package is in the
+        // filtered snapshot but not in the unfiltered snapshot, it means the package got removed,
+        // so we don't need to record it.
+        try (PackageManagerLocal.UnfilteredSnapshot unfilteredSnapshot =
+                        mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {
+            Map<String, PackageState> packageStates = unfilteredSnapshot.getPackageStates();
+            Set<String> visitedPackages = new HashSet<>();
+
+            Function<String, FindResult> visitPackage = (packageName) -> {
+                if (visitedPackages.contains(packageName)) {
+                    return null;
+                }
+                visitedPackages.add(packageName);
+                PackageState pkgState = packageStates.get(packageName);
+                if (pkgState == null) {
+                    mRecentDexFilesToPackageNames.remove(dexPath);
+                    return null;
+                }
+                FindResult result =
+                        checkForPackage(pkgState, dexPath, true /* checkForSharedLibraries */);
+                if (result != null) {
+                    mRecentDexFilesToPackageNames.put(dexPath, packageName);
+                    return result;
+                }
+                return null;
+            };
+
+            String cachedPackageName = mRecentDexFilesToPackageNames.get(dexPath);
+            if (cachedPackageName != null) {
+                FindResult result = visitPackage.apply(cachedPackageName);
+                if (result != null) {
+                    return result;
+                }
+            }
+
+            var recentDexFilesToPackageNamesSnapshot =
+                    (SequencedMap<String, String>) mRecentDexFilesToPackageNames.snapshot();
+
+            // Check recent packages first.
+            for (String packageName :
+                    recentDexFilesToPackageNamesSnapshot.sequencedValues().reversed()) {
+                FindResult result = visitPackage.apply(packageName);
+                if (result != null) {
+                    return result;
+                }
+            }
+
+            // Check remaining packages. Don't check for shared libraries because it might be too
+            // expansive to do so and the time complexity is O(n) no matter we do it or not.
+            for (PackageState pkgState : packageStates.values()) {
+                if (visitedPackages.contains(pkgState.getPackageName())) {
+                    continue;
+                }
+                FindResult result =
+                        checkForPackage(pkgState, dexPath, false /* checkForSharedLibraries */);
+                if (result != null) {
+                    mRecentDexFilesToPackageNames.put(dexPath, pkgState.getPackageName());
+                    return result;
+                }
             }
         }
 
         return null;
     }
 
+    @Nullable
+    private FindResult checkForPackage(@NonNull PackageState pkgState, @NonNull String dexPath,
+            boolean checkForSharedLibraries) {
+        if (isOwningPackageForPrimaryDex(pkgState, dexPath)) {
+            return new FindResult(TYPE_PRIMARY, pkgState.getPackageName());
+        }
+        if (checkForSharedLibraries) {
+            FindResult result =
+                    checkForSharedLibraries(pkgState.getSharedLibraryDependencies(), dexPath);
+            if (result != null) {
+                return result;
+            }
+        }
+        synchronized (mLock) {
+            if (isOwningPackageForSecondaryDexLocked(pkgState, dexPath)) {
+                return new FindResult(TYPE_SECONDARY, pkgState.getPackageName());
+            }
+        }
+        String packageCodeDir = getPackageCodeDir(pkgState);
+        if (packageCodeDir != null && Utils.pathStartsWith(dexPath, packageCodeDir)) {
+            // TODO(b/351761207): Support secondary dex files in package dir.
+            return new FindResult(TYPE_DONT_RECORD, null);
+        }
+        return null;
+    }
+
     private static boolean isOwningPackageForPrimaryDex(
             @NonNull PackageState pkgState, @NonNull String dexPath) {
         AndroidPackage pkg = pkgState.getAndroidPackage();
@@ -469,17 +587,56 @@ public class DexUseManagerLocal {
 
     @GuardedBy("mLock")
     private boolean isOwningPackageForSecondaryDexLocked(
-            @NonNull PackageState pkgState, @NonNull Path dexPath) {
+            @NonNull PackageState pkgState, @NonNull String dexPath) {
         UserHandle userHandle = Binder.getCallingUserHandle();
-        List<Path> locations = mSecondaryDexLocationManager.getLocations(pkgState, userHandle);
+        List<String> locations = mSecondaryDexLocationManager.getLocations(pkgState, userHandle);
         for (int i = 0; i < locations.size(); i++) {
-            if (dexPath.startsWith(locations.get(i))) {
+            if (Utils.pathStartsWith(dexPath, locations.get(i))) {
                 return true;
             }
         }
         return false;
     }
 
+    @Nullable
+    private static FindResult checkForSharedLibraries(
+            @NonNull List<SharedLibrary> libraries, @NonNull String dexPath) {
+        for (SharedLibrary library : libraries) {
+            if (library.isNative()) {
+                continue;
+            }
+            if (dexPath.equals(library.getPath())) {
+                if (library.getType() == SharedLibraryInfo.TYPE_BUILTIN) {
+                    // Shared libraries are considered used by other apps anyway. No need to record
+                    // them.
+                    return new FindResult(TYPE_DONT_RECORD, null);
+                }
+                return new FindResult(TYPE_PRIMARY, library.getPackageName());
+            }
+            FindResult result = checkForSharedLibraries(library.getDependencies(), dexPath);
+            if (result != null) {
+                return result;
+            }
+        }
+        return null;
+    }
+
+    @Nullable
+    private String getPackageCodeDir(@NonNull PackageState pkgState) {
+        AndroidPackage pkg = pkgState.getAndroidPackage();
+        if (pkg == null) {
+            return null;
+        }
+        List<AndroidPackageSplit> splits = pkg.getSplits();
+        if (splits.size() == 0) {
+            return null;
+        }
+        String path = splits.get(0).getPath();
+        int pos = path.lastIndexOf('/');
+        Utils.check(pos >= 0);
+        return path.substring(0, pos + 1);
+    }
+
     private void addPrimaryDexUse(@NonNull String owningPackageName, @NonNull String dexPath,
             @NonNull String loadingPackageName, boolean isolatedProcess, long lastUsedAtMs) {
         synchronized (mLock) {
@@ -1109,7 +1266,7 @@ public class DexUseManagerLocal {
     static class SecondaryDexLocationManager {
         private @NonNull Map<CacheKey, CacheValue> mCache = new HashMap<>();
 
-        public @NonNull List<Path> getLocations(
+        public @NonNull List<String> getLocations(
                 @NonNull PackageState pkgState, @NonNull UserHandle userHandle) {
             AndroidPackage pkg = pkgState.getAndroidPackage();
             if (pkg == null) {
@@ -1129,11 +1286,12 @@ public class DexUseManagerLocal {
                     storageUuid, userHandle, packageName);
             File deDir = Environment.getDataDePackageDirectoryForUser(
                     storageUuid, userHandle, packageName);
-            List<Path> locations = List.of(ceDir.toPath(), deDir.toPath());
-            mCache.put(cacheKey, CacheValue.create(locations, storageUuid));
+            List<String> locations = List.of(ceDir.getAbsolutePath(), deDir.getAbsolutePath());
+            mCache.put(cacheKey, new CacheValue(locations, storageUuid));
             return locations;
         }
 
+        // TODO(b/351994199): Don't replace this with record because the latter is too slow.
         @Immutable
         @AutoValue
         abstract static class CacheKey {
@@ -1147,19 +1305,28 @@ public class DexUseManagerLocal {
             abstract @NonNull UserHandle userHandle();
         }
 
-        @Immutable
-        @AutoValue
-        abstract static class CacheValue {
-            static CacheValue create(@NonNull List<Path> locations, @NonNull UUID storageUuid) {
-                return new AutoValue_DexUseManagerLocal_SecondaryDexLocationManager_CacheValue(
-                        locations, storageUuid);
-            }
+        private record CacheValue(@NonNull List<String> locations, @NonNull UUID storageUuid) {}
+    }
 
-            abstract @NonNull List<Path> locations();
+    /** Result found but don't record it. */
+    private static final int TYPE_DONT_RECORD = 0;
+    /** Primary dex file. */
+    private static final int TYPE_PRIMARY = 1;
+    /** Secondary dex file. */
+    private static final int TYPE_SECONDARY = 2;
 
-            abstract @NonNull UUID storageUuid();
-        }
-    }
+    /** @hide */
+    // clang-format off
+    @IntDef(prefix = "TYPE_", value = {
+        TYPE_DONT_RECORD,
+        TYPE_PRIMARY,
+        TYPE_SECONDARY,
+    })
+    // clang-format on
+    @Retention(RetentionPolicy.SOURCE)
+    private @interface DexType {}
+
+    private record FindResult(@DexType int type, @Nullable String owningPackageName) {}
 
     /**
      * Injector pattern for testing purpose.
@@ -1215,7 +1382,7 @@ public class DexUseManagerLocal {
         }
 
         @NonNull
-        private PackageManagerLocal getPackageManagerLocal() {
+        public PackageManagerLocal getPackageManagerLocal() {
             return Objects.requireNonNull(
                     LocalManagerRegistry.getManager(PackageManagerLocal.class));
         }
diff --git a/libartservice/service/java/com/android/server/art/DexoptHelper.java b/libartservice/service/java/com/android/server/art/DexoptHelper.java
index 1f7bd93235..828a05c656 100644
--- a/libartservice/service/java/com/android/server/art/DexoptHelper.java
+++ b/libartservice/service/java/com/android/server/art/DexoptHelper.java
@@ -29,7 +29,6 @@ import android.os.Binder;
 import android.os.Build;
 import android.os.CancellationSignal;
 import android.os.RemoteException;
-import android.os.WorkSource;
 
 import androidx.annotation.RequiresApi;
 
@@ -54,7 +53,6 @@ import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 import java.util.function.Function;
@@ -71,8 +69,9 @@ import java.util.stream.Collectors;
 public class DexoptHelper {
     @NonNull private final Injector mInjector;
 
-    public DexoptHelper(@NonNull Context context, @NonNull Config config) {
-        this(new Injector(context, config));
+    public DexoptHelper(
+            @NonNull Context context, @NonNull Config config, @NonNull Executor reporterExecutor) {
+        this(new Injector(context, config, reporterExecutor));
     }
 
     @VisibleForTesting
@@ -239,7 +238,8 @@ public class DexoptHelper {
                                 .dexopt());
             }
 
-            if ((params.getFlags() & ArtFlags.FLAG_FOR_SECONDARY_DEX) != 0) {
+            if (((params.getFlags() & ArtFlags.FLAG_FOR_SECONDARY_DEX) != 0)
+                    && pkgState.getAppId() > 0) {
                 if (cancellationSignal.isCanceled()) {
                     return createResult.apply(DexoptResult.DEXOPT_CANCELLED);
                 }
@@ -323,10 +323,13 @@ public class DexoptHelper {
     public static class Injector {
         @NonNull private final Context mContext;
         @NonNull private final Config mConfig;
+        @NonNull private final Executor mReporterExecutor;
 
-        Injector(@NonNull Context context, @NonNull Config config) {
+        Injector(@NonNull Context context, @NonNull Config config,
+                @NonNull Executor reporterExecutor) {
             mContext = context;
             mConfig = config;
+            mReporterExecutor = reporterExecutor;
 
             // Call the getters for the dependencies that aren't optional, to ensure correct
             // initialization order.
@@ -337,16 +340,16 @@ public class DexoptHelper {
         PrimaryDexopter getPrimaryDexopter(@NonNull PackageState pkgState,
                 @NonNull AndroidPackage pkg, @NonNull DexoptParams params,
                 @NonNull CancellationSignal cancellationSignal) {
-            return new PrimaryDexopter(
-                    mContext, mConfig, pkgState, pkg, params, cancellationSignal);
+            return new PrimaryDexopter(mContext, mConfig, mReporterExecutor, pkgState, pkg, params,
+                    cancellationSignal);
         }
 
         @NonNull
         SecondaryDexopter getSecondaryDexopter(@NonNull PackageState pkgState,
                 @NonNull AndroidPackage pkg, @NonNull DexoptParams params,
                 @NonNull CancellationSignal cancellationSignal) {
-            return new SecondaryDexopter(
-                    mContext, mConfig, pkgState, pkg, params, cancellationSignal);
+            return new SecondaryDexopter(mContext, mConfig, mReporterExecutor, pkgState, pkg,
+                    params, cancellationSignal);
         }
 
         @NonNull
diff --git a/libartservice/service/java/com/android/server/art/Dexopter.java b/libartservice/service/java/com/android/server/art/Dexopter.java
index 271dc6144f..b13ec66831 100644
--- a/libartservice/service/java/com/android/server/art/Dexopter.java
+++ b/libartservice/service/java/com/android/server/art/Dexopter.java
@@ -26,10 +26,8 @@ import static com.android.server.art.model.ArtFlags.DexoptFlags;
 import static com.android.server.art.model.Config.Callback;
 import static com.android.server.art.model.DexoptResult.DexContainerFileDexoptResult;
 
-import android.R;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
-import android.app.role.RoleManager;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.os.Build;
@@ -39,13 +37,12 @@ import android.os.ServiceSpecificException;
 import android.os.SystemProperties;
 import android.os.UserManager;
 import android.os.storage.StorageManager;
-import android.text.TextUtils;
-import android.util.Pair;
 
 import androidx.annotation.RequiresApi;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.LocalManagerRegistry;
+import com.android.server.art.Dex2OatStatsReporter.Dex2OatResult;
 import com.android.server.art.model.ArtFlags;
 import com.android.server.art.model.Config;
 import com.android.server.art.model.DetailedDexInfo;
@@ -64,6 +61,9 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.Executor;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /** @hide */
 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -193,6 +193,7 @@ public abstract class Dexopter<DexInfoType extends DetailedDexInfo> {
                     long cpuTimeMs = 0;
                     long sizeBytes = 0;
                     long sizeBeforeBytes = 0;
+                    Dex2OatResult dex2OatResult = Dex2OatResult.notRun();
                     @DexoptResult.DexoptResultExtendedStatusFlags int extendedStatusFlags = 0;
                     try {
                         var target = DexoptTarget.<DexInfoType>builder()
@@ -276,6 +277,8 @@ public abstract class Dexopter<DexInfoType extends DetailedDexInfo> {
                         cpuTimeMs = dexoptResult.cpuTimeMs;
                         sizeBytes = dexoptResult.sizeBytes;
                         sizeBeforeBytes = dexoptResult.sizeBeforeBytes;
+                        dex2OatResult = dexoptResult.cancelled ? Dex2OatResult.cancelled()
+                                                               : Dex2OatResult.exited(0);
 
                         if (status == DexoptResult.DEXOPT_CANCELLED) {
                             return results;
@@ -288,6 +291,16 @@ public abstract class Dexopter<DexInfoType extends DetailedDexInfo> {
                                         dexInfo.classLoaderContext()),
                                 e);
                         status = DexoptResult.DEXOPT_FAILED;
+
+                        // Parse status, exit code and signal from the dex2oat error message
+                        Pattern pattern = Pattern.compile(
+                                "\\[status=(-?\\d+),exit_code=(-?\\d+),signal=(-?\\d+)]");
+                        Matcher matcher = pattern.matcher(Objects.requireNonNull(e.getMessage()));
+                        if (matcher.matches()) {
+                            dex2OatResult = new Dex2OatResult(Integer.parseInt(matcher.group(1)),
+                                    Integer.parseInt(matcher.group(2)),
+                                    Integer.parseInt(matcher.group(3)));
+                        }
                     } finally {
                         if (!externalProfileErrors.isEmpty()) {
                             extendedStatusFlags |= DexoptResult.EXTENDED_BAD_EXTERNAL_PROFILE;
@@ -306,6 +319,17 @@ public abstract class Dexopter<DexInfoType extends DetailedDexInfo> {
                         // Make sure artd does not leak even if the caller holds
                         // `mCancellationSignal` forever.
                         mCancellationSignal.setOnCancelListener(null);
+
+                        // Variables used in lambda needs to be effectively final.
+                        Dex2OatResult finalDex2OatResult = dex2OatResult;
+                        mInjector.getReporterExecutor().execute(
+                                ()
+                                        -> Dex2OatStatsReporter.report(mPkgState.getAppId(),
+                                                result.getActualCompilerFilter(),
+                                                mParams.getReason(), dmInfo.type(), dexInfo,
+                                                abi.isa(), finalDex2OatResult,
+                                                result.getSizeBytes(),
+                                                result.getDex2oatWallTimeMillis()));
                     }
                 }
 
@@ -757,10 +781,13 @@ public abstract class Dexopter<DexInfoType extends DetailedDexInfo> {
     public static class Injector {
         @NonNull private final Context mContext;
         @NonNull private final Config mConfig;
+        @NonNull private final Executor mReporterExecutor;
 
-        public Injector(@NonNull Context context, @NonNull Config config) {
+        public Injector(@NonNull Context context, @NonNull Config config,
+                @NonNull Executor reporterExecutor) {
             mContext = context;
             mConfig = config;
+            mReporterExecutor = reporterExecutor;
 
             // Call the getters for various dependencies, to ensure correct initialization order.
             getUserManager();
@@ -822,6 +849,11 @@ public abstract class Dexopter<DexInfoType extends DetailedDexInfo> {
             return mConfig;
         }
 
+        @NonNull
+        public Executor getReporterExecutor() {
+            return mReporterExecutor;
+        }
+
         @NonNull
         public DexMetadataHelper getDexMetadataHelper() {
             return new DexMetadataHelper();
diff --git a/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java b/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java
index 5c4a9093ca..65062612a3 100644
--- a/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java
+++ b/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java
@@ -48,6 +48,11 @@ import java.time.Duration;
 import java.util.Objects;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 
 /**
  * The Pre-reboot Dexopt job.
@@ -69,6 +74,7 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
     @NonNull private final Injector mInjector;
 
     // Job state variables. The monitor of `this` is notified when `mRunningJob` is changed.
+    // `mRunningJob` and `mCancellationSignal` have the same nullness.
     @GuardedBy("this") @Nullable private CompletableFuture<Void> mRunningJob = null;
     @GuardedBy("this") @Nullable private CancellationSignal mCancellationSignal = null;
 
@@ -81,6 +87,28 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
     /** Whether to map/unmap snapshots. Only applicable to an OTA update. */
     @GuardedBy("this") private boolean mMapSnapshotsForOta = false;
 
+    /**
+     * Offloads `onStartJob` and `onStopJob` calls from the main thread while keeping the execution
+     * order as the main thread does.
+     * Also offloads `onUpdateReady` calls from the package manager thread. We reuse this executor
+     * just for simplicity. The execution order does not matter.
+     */
+    @NonNull
+    private final ThreadPoolExecutor mSerializedExecutor =
+            new ThreadPoolExecutor(1 /* corePoolSize */, 1 /* maximumPoolSize */,
+                    60 /* keepAliveTime */, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+
+    /**
+     * A separate thread for executing `mRunningJob`. We avoid using any known thread / thread pool
+     * such as {@link java.util.concurrent.ForkJoinPool} and {@link
+     * com.android.internal.os.BackgroundThread} because we don't want to block other things that
+     * use known threads / thread pools.
+     */
+    @NonNull
+    private final ThreadPoolExecutor mExecutor =
+            new ThreadPoolExecutor(1 /* corePoolSize */, 1 /* maximumPoolSize */,
+                    60 /* keepAliveTime */, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+
     // Mutations to the global state of Pre-reboot Dexopt, including mounts, staged files, and
     // stats, should only be done when there is no job running and the `this` lock is held, or by
     // the job itself.
@@ -92,17 +120,32 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
     @VisibleForTesting
     public PreRebootDexoptJob(@NonNull Injector injector) {
         mInjector = injector;
+        // Recycle the thread if it's not used for `keepAliveTime`.
+        mSerializedExecutor.allowsCoreThreadTimeOut();
+        mExecutor.allowsCoreThreadTimeOut();
+        if (hasStarted()) {
+            maybeCleanUpChrootAsyncForStartup();
+        }
     }
 
     @Override
-    public synchronized boolean onStartJob(
+    public boolean onStartJob(
+            @NonNull BackgroundDexoptJobService jobService, @NonNull JobParameters params) {
+        mSerializedExecutor.execute(() -> onStartJobImpl(jobService, params));
+        // "true" means the job will continue running until `jobFinished` is called.
+        return true;
+    }
+
+    @VisibleForTesting
+    public synchronized void onStartJobImpl(
             @NonNull BackgroundDexoptJobService jobService, @NonNull JobParameters params) {
         JobInfo pendingJob = mInjector.getJobScheduler().getPendingJob(JOB_ID);
         if (pendingJob == null
                 || !params.getExtras().getString("ticket").equals(
                         pendingJob.getExtras().getString("ticket"))) {
             // Job expired. We can only get here due to a race, and this should be very rare.
-            return false;
+            Utils.check(!mIsRunningJobKnownByJobScheduler);
+            return;
         }
 
         mIsRunningJobKnownByJobScheduler = true;
@@ -118,17 +161,20 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
         // No need to handle exceptions thrown by the future because exceptions are handled inside
         // the future itself.
         startLocked(onJobFinishedLocked);
-        // "true" means the job will continue running until `jobFinished` is called.
-        return true;
     }
 
     @Override
-    public synchronized boolean onStopJob(@NonNull JobParameters params) {
+    public boolean onStopJob(@NonNull JobParameters params) {
+        mSerializedExecutor.execute(() -> onStopJobImpl(params));
+        // "true" means to execute again with the default retry policy.
+        return true;
+    }
+
+    @VisibleForTesting
+    public synchronized void onStopJobImpl(@NonNull JobParameters params) {
         if (mIsRunningJobKnownByJobScheduler) {
             cancelGivenLocked(mRunningJob, false /* expectInterrupt */);
         }
-        // "true" means to execute again with the default retry policy.
-        return true;
     }
 
     /**
@@ -137,7 +183,14 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
      * @param otaSlot The slot that contains the OTA update, "_a" or "_b", or null for a Mainline
      *         update.
      */
-    public synchronized @ScheduleStatus int onUpdateReady(@Nullable String otaSlot) {
+    public synchronized void onUpdateReady(@Nullable String otaSlot) {
+        // `onUpdateReadyImpl` can take time, especially on `resetLocked` when there are staged
+        // files from a previous run to be cleaned up, so we put it on a separate thread.
+        mSerializedExecutor.execute(() -> onUpdateReadyImpl(otaSlot));
+    }
+
+    /** For internal and testing use only. */
+    public synchronized @ScheduleStatus int onUpdateReadyImpl(@Nullable String otaSlot) {
         cancelAnyLocked();
         resetLocked();
         updateOtaSlotLocked(otaSlot);
@@ -146,7 +199,8 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
     }
 
     /**
-     * Same as above, but starts the job immediately, instead of going through the job scheduler.
+     * Same as {@link #onUpdateReady}, but starts the job immediately, instead of going through the
+     * job scheduler.
      *
      * @param mapSnapshotsForOta whether to map/unmap snapshots. Only applicable to an OTA update.
      * @return The future of the job, or null if Pre-reboot Dexopt is not enabled.
@@ -183,6 +237,31 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
         cancelAnyLocked();
     }
 
+    /** Cleans up chroot if it exists. Only expected to be called on system server startup. */
+    private synchronized void maybeCleanUpChrootAsyncForStartup() {
+        // We only get here when there was a system server restart (probably due to a crash). In
+        // this case, it's possible that a previous Pre-reboot Dexopt job didn't end normally and
+        // left over a chroot, so we need to clean it up.
+        // We assign this operation to `mRunningJob` to block other operations on their calls to
+        // `cancelAnyLocked`.
+        // `mCancellationSignal` is a placeholder and the signal actually ignored. It's created just
+        // for keeping the invariant that `mRunningJob` and `mCancellationSignal` have the same
+        // nullness, to make other code simpler.
+        mCancellationSignal = new CancellationSignal();
+        mRunningJob = new CompletableFuture().runAsync(() -> {
+            try {
+                mInjector.getPreRebootDriver().maybeCleanUpChroot();
+            } finally {
+                synchronized (this) {
+                    mRunningJob = null;
+                    mCancellationSignal = null;
+                    this.notifyAll();
+                }
+            }
+        }, mExecutor);
+        this.notifyAll();
+    }
+
     @VisibleForTesting
     public synchronized void waitForRunningJob() {
         while (mRunningJob != null) {
@@ -194,6 +273,11 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
         }
     }
 
+    @VisibleForTesting
+    public synchronized boolean hasRunningJob() {
+        return mRunningJob != null;
+    }
+
     @GuardedBy("this")
     private @ScheduleStatus int scheduleLocked() {
         if (this != BackgroundDexoptJobService.getJob(JOB_ID)) {
@@ -291,7 +375,7 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
                     this.notifyAll();
                 }
             }
-        });
+        }, mExecutor);
         this.notifyAll();
         return mRunningJob;
     }
diff --git a/libartservice/service/java/com/android/server/art/PrimaryDexopter.java b/libartservice/service/java/com/android/server/art/PrimaryDexopter.java
index f8234c4df9..eb200592aa 100644
--- a/libartservice/service/java/com/android/server/art/PrimaryDexopter.java
+++ b/libartservice/service/java/com/android/server/art/PrimaryDexopter.java
@@ -30,7 +30,6 @@ import android.os.Process;
 import android.os.RemoteException;
 import android.os.ServiceSpecificException;
 import android.os.UserHandle;
-import android.text.TextUtils;
 
 import androidx.annotation.RequiresApi;
 
@@ -39,18 +38,12 @@ import com.android.modules.utils.pm.PackageStateModulesUtils;
 import com.android.server.art.model.ArtFlags;
 import com.android.server.art.model.Config;
 import com.android.server.art.model.DexoptParams;
-import com.android.server.art.model.DexoptResult;
-import com.android.server.pm.PackageManagerLocal;
 import com.android.server.pm.pkg.AndroidPackage;
 import com.android.server.pm.pkg.PackageState;
 
-import dalvik.system.DexFile;
-
-import com.google.auto.value.AutoValue;
-
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
+import java.util.concurrent.Executor;
 
 /** @hide */
 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -58,9 +51,10 @@ public class PrimaryDexopter extends Dexopter<DetailedPrimaryDexInfo> {
     private final int mSharedGid;
 
     public PrimaryDexopter(@NonNull Context context, @NonNull Config config,
-            @NonNull PackageState pkgState, @NonNull AndroidPackage pkg,
+            Executor reporterExecutor, @NonNull PackageState pkgState, @NonNull AndroidPackage pkg,
             @NonNull DexoptParams params, @NonNull CancellationSignal cancellationSignal) {
-        this(new Injector(context, config), pkgState, pkg, params, cancellationSignal);
+        this(new Injector(context, config, reporterExecutor), pkgState, pkg, params,
+                cancellationSignal);
     }
 
     @VisibleForTesting
diff --git a/libartservice/service/java/com/android/server/art/SecondaryDexopter.java b/libartservice/service/java/com/android/server/art/SecondaryDexopter.java
index 57fe174d6a..b8ee9d079d 100644
--- a/libartservice/service/java/com/android/server/art/SecondaryDexopter.java
+++ b/libartservice/service/java/com/android/server/art/SecondaryDexopter.java
@@ -36,14 +36,16 @@ import com.android.server.pm.pkg.AndroidPackage;
 import com.android.server.pm.pkg.PackageState;
 
 import java.util.List;
+import java.util.concurrent.Executor;
 
 /** @hide */
 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
 public class SecondaryDexopter extends Dexopter<CheckedSecondaryDexInfo> {
     public SecondaryDexopter(@NonNull Context context, @NonNull Config config,
-            @NonNull PackageState pkgState, @NonNull AndroidPackage pkg,
+            Executor reporterExecutor, @NonNull PackageState pkgState, @NonNull AndroidPackage pkg,
             @NonNull DexoptParams params, @NonNull CancellationSignal cancellationSignal) {
-        this(new Injector(context, config), pkgState, pkg, params, cancellationSignal);
+        this(new Injector(context, config, reporterExecutor), pkgState, pkg, params,
+                cancellationSignal);
     }
 
     @VisibleForTesting
diff --git a/libartservice/service/java/com/android/server/art/Utils.java b/libartservice/service/java/com/android/server/art/Utils.java
index 31e2fec4c0..600671fcb2 100644
--- a/libartservice/service/java/com/android/server/art/Utils.java
+++ b/libartservice/service/java/com/android/server/art/Utils.java
@@ -41,6 +41,7 @@ import android.util.SparseArray;
 
 import androidx.annotation.RequiresApi;
 
+import com.android.modules.utils.build.SdkLevel;
 import com.android.modules.utils.pm.PackageStateModulesUtils;
 import com.android.server.art.model.DexoptParams;
 import com.android.server.pm.PackageManagerLocal;
@@ -428,7 +429,7 @@ public final class Utils {
             profileInitializers.add(Pair.create(AidlUtils.toString(profile),
                     () -> artd.copyAndRewriteProfile(profile, output, dexPath)));
         }
-        if (enableEmbeddedProfile) {
+        if (enableEmbeddedProfile && SdkLevel.isAtLeastV()) {
             profileInitializers.add(Pair.create(
                     "embedded profile", () -> artd.copyAndRewriteEmbeddedProfile(output, dexPath)));
         }
@@ -482,6 +483,24 @@ public final class Utils {
         }
     }
 
+    public static boolean pathStartsWith(@NonNull String path, @NonNull String prefix) {
+        check(!prefix.isEmpty() && !path.isEmpty() && prefix.charAt(0) == '/'
+                && path.charAt(0) == '/');
+        int prefixLen = prefix.length();
+        if (prefix.charAt(prefixLen - 1) == '/') {
+            prefixLen--;
+        }
+        if (path.length() < prefixLen) {
+            return false;
+        }
+        for (int i = 0; i < prefixLen; i++) {
+            if (path.charAt(i) != prefix.charAt(i)) {
+                return false;
+            }
+        }
+        return path.length() == prefixLen || path.charAt(prefixLen) == '/';
+    }
+
     @AutoValue
     public abstract static class Abi {
         static @NonNull Abi create(
diff --git a/libartservice/service/java/com/android/server/art/model/ArtFlags.java b/libartservice/service/java/com/android/server/art/model/ArtFlags.java
index 0a1d52bcbc..0a79d74089 100644
--- a/libartservice/service/java/com/android/server/art/model/ArtFlags.java
+++ b/libartservice/service/java/com/android/server/art/model/ArtFlags.java
@@ -18,7 +18,6 @@ package com.android.server.art.model;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
-import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.app.job.JobScheduler;
 
@@ -86,7 +85,6 @@ public class ArtFlags {
      * useful when the compiler filter is not explicitly specified (i.e., is inferred from the
      * compilation reason).
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     public static final int FLAG_IGNORE_PROFILE = 1 << 7;
     /**
      * Whether to force merge profiles even if the difference between before and after the merge
diff --git a/libartservice/service/java/com/android/server/art/model/ArtManagedFileStats.java b/libartservice/service/java/com/android/server/art/model/ArtManagedFileStats.java
index 794ff796b5..e27d54d5c0 100644
--- a/libartservice/service/java/com/android/server/art/model/ArtManagedFileStats.java
+++ b/libartservice/service/java/com/android/server/art/model/ArtManagedFileStats.java
@@ -18,7 +18,6 @@ package com.android.server.art.model;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
-import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 
 import com.android.internal.annotations.Immutable;
@@ -33,7 +32,6 @@ import java.util.Map;
  *
  * @hide
  */
-@SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
 @SystemApi(client = SystemApi.Client.SYSTEM_SERVER)
 @Immutable
 public class ArtManagedFileStats {
@@ -47,21 +45,18 @@ public class ArtManagedFileStats {
      * For a preload app, this type includes dexopt artifacts on readonly partitions if they are
      * up-to-date.
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     public static final int TYPE_DEXOPT_ARTIFACT = 0;
     /**
      * Reference profiles.
      *
      * They are the ones used during the last profile-guided dexopt.
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     public static final int TYPE_REF_PROFILE = 1;
     /**
      * Current profiles.
      *
      * They may be used during the next profile-guided dexopt.
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     public static final int TYPE_CUR_PROFILE = 2;
 
     /** @hide */
@@ -88,7 +83,6 @@ public class ArtManagedFileStats {
      * @throws IllegalArgumentException if {@code fileType} is not one of those defined in {@link
      *         FileTypes}.
      */
-    @SuppressLint("UnflaggedApi") // Flag support for mainline is not available.
     public long getTotalSizeBytesByType(@FileTypes int fileType) {
         Long value = mTotalSizesBytes.get(fileType);
         if (value == null) {
diff --git a/libartservice/service/java/com/android/server/art/model/DexMetadata.java b/libartservice/service/java/com/android/server/art/model/DexMetadata.java
new file mode 100644
index 0000000000..5895b7be30
--- /dev/null
+++ b/libartservice/service/java/com/android/server/art/model/DexMetadata.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.art.model;
+
+import android.annotation.IntDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** @hide */
+public class DexMetadata {
+    /** An explicit private class to avoid exposing constructor.*/
+    private DexMetadata() {}
+
+    public static final int TYPE_UNKNOWN = 0;
+    public static final int TYPE_PROFILE = 1;
+    public static final int TYPE_VDEX = 2;
+    public static final int TYPE_PROFILE_AND_VDEX = 3;
+    public static final int TYPE_NONE = 4;
+    public static final int TYPE_ERROR = 5;
+
+    /** @hide */
+    // clang-format off
+    @IntDef(prefix = "TYPE_", value = {
+        TYPE_UNKNOWN,
+        TYPE_PROFILE,
+        TYPE_VDEX,
+        TYPE_PROFILE_AND_VDEX,
+        TYPE_NONE,
+        TYPE_ERROR,
+    })
+    // clang-format on
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface Type {}
+}
diff --git a/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java b/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java
index a30ca4ab74..abcaa488f1 100644
--- a/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java
+++ b/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java
@@ -55,6 +55,8 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 
 /**
  * Drives Pre-reboot Dexopt, through reflection.
@@ -158,6 +160,20 @@ public class PreRebootDriver {
         }
     }
 
+    public void maybeCleanUpChroot() {
+        if (!Files.exists(Paths.get(CHROOT_DIR))) {
+            return;
+        }
+        try {
+            ArtJni.ensureNoProcessInDir(CHROOT_DIR, 5000 /* timeoutMs */);
+            mInjector.getDexoptChrootSetup().tearDown(true /* allowConcurrent */);
+        } catch (RemoteException e) {
+            Utils.logArtdException(e);
+        } catch (ServiceSpecificException | IOException e) {
+            AsLog.e("Failed to clean up leftover chroot", e);
+        }
+    }
+
     private void setUp(@Nullable String otaSlot, boolean mapSnapshotsForOta)
             throws RemoteException, SystemRequirementException {
         mInjector.getDexoptChrootSetup().setUp(otaSlot, mapSnapshotsForOta);
@@ -182,7 +198,7 @@ public class PreRebootDriver {
         // blocks on `artd` calls, even upon cancellation, and `artd` in turn waits for child
         // processes to exit, even if they are killed due to the cancellation.
         ArtJni.ensureNoProcessInDir(CHROOT_DIR, 5000 /* timeoutMs */);
-        mInjector.getDexoptChrootSetup().tearDown();
+        mInjector.getDexoptChrootSetup().tearDown(false /* allowConcurrent */);
     }
 
     private void runFromChroot(@NonNull CancellationSignal cancellationSignal)
diff --git a/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java b/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java
index 01e706f0a4..9deb3f1055 100644
--- a/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java
+++ b/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java
@@ -35,7 +35,6 @@ import static org.mockito.ArgumentMatchers.matches;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
 import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.anyLong;
 import static org.mockito.Mockito.argThat;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.isNull;
@@ -691,6 +690,27 @@ public class ArtManagerLocalTest {
                         any(), any(), any(), any());
     }
 
+    @Test
+    public void testDexoptPackagesFirstBoot() throws Exception {
+        // On first-boot all packages haven't been used and first install time is
+        // 0 which simulates case of system time being advanced by
+        // AlarmManagerService after package installation
+        lenient().when(mDexUseManager.getPackageLastUsedAtMs(any())).thenReturn(0l);
+
+        var result = DexoptResult.create();
+        var cancellationSignal = new CancellationSignal();
+
+        // PKG_NAME_1 and PKG_NAME_2 should be dexopted.
+        doReturn(result)
+                .when(mDexoptHelper)
+                .dexopt(any(), inAnyOrder(PKG_NAME_1, PKG_NAME_2),
+                        argThat(params -> params.getReason().equals("first-boot")), any(), any(),
+                        any(), any());
+
+        mArtManagerLocal.dexoptPackages(mSnapshot, "first-boot", cancellationSignal,
+                null /* processCallbackExecutor */, null /* processCallback */);
+    }
+
     @Test
     public void testDexoptPackagesBootAfterMainlineUpdate() throws Exception {
         var result = DexoptResult.create();
diff --git a/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java b/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java
index ffc702f338..95d111774d 100644
--- a/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java
+++ b/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java
@@ -77,10 +77,15 @@ import java.util.UUID;
 @RunWith(AndroidJUnit4.class)
 public class DexUseManagerTest {
     private static final String LOADING_PKG_NAME = "com.example.loadingpackage";
+
     private static final String OWNING_PKG_NAME = "com.example.owningpackage";
     private static final String BASE_APK = "/somewhere/app/" + OWNING_PKG_NAME + "/base.apk";
     private static final String SPLIT_APK = "/somewhere/app/" + OWNING_PKG_NAME + "/split_0.apk";
 
+    private static final String INVISIBLE_PKG_NAME = "com.example.invisiblepackage";
+    private static final String INVISIBLE_BASE_APK =
+            "/somewhere/app/" + INVISIBLE_PKG_NAME + "/base.apk";
+
     @Rule
     public StaticMockitoRule mockitoRule = new StaticMockitoRule(
             SystemProperties.class, Constants.class, Process.class, ArtJni.class);
@@ -99,6 +104,8 @@ public class DexUseManagerTest {
     @Mock private IArtd mArtd;
     @Mock private Context mContext;
     @Mock private ArtManagerLocal mArtManagerLocal;
+    @Mock private PackageManagerLocal mPackageManagerLocal;
+    @Mock private PackageManagerLocal.UnfilteredSnapshot mUnfilteredSnapshot;
     private DexUseManagerLocal mDexUseManager;
     private String mCeDir;
     private String mDeDir;
@@ -126,18 +133,21 @@ public class DexUseManagerTest {
         // Put the null package in front of other packages to verify that it's properly skipped.
         PackageState nullPkgState =
                 createPackageState("com.example.null", "arm64-v8a", false /* hasPackage */);
-        addPackage("com.example.null", nullPkgState);
+        addPackage("com.example.null", nullPkgState, true /* isVisible */);
         PackageState loadingPkgState =
                 createPackageState(LOADING_PKG_NAME, "armeabi-v7a", true /* hasPackage */);
-        addPackage(LOADING_PKG_NAME, loadingPkgState);
+        addPackage(LOADING_PKG_NAME, loadingPkgState, true /* isVisible */);
         PackageState owningPkgState =
                 createPackageState(OWNING_PKG_NAME, "arm64-v8a", true /* hasPackage */);
-        addPackage(OWNING_PKG_NAME, owningPkgState);
+        addPackage(OWNING_PKG_NAME, owningPkgState, true /* isVisible */);
         PackageState platformPkgState =
                 createPackageState(Utils.PLATFORM_PACKAGE_NAME, "arm64-v8a", true /* hasPackage */);
-        addPackage(Utils.PLATFORM_PACKAGE_NAME, platformPkgState);
+        addPackage(Utils.PLATFORM_PACKAGE_NAME, platformPkgState, true /* isVisible */);
+        PackageState invisiblePkgState =
+                createPackageState(INVISIBLE_PKG_NAME, "arm64-v8a", true /* hasPackage */);
+        addPackage(INVISIBLE_PKG_NAME, invisiblePkgState, false /* isVisible */);
 
-        lenient().when(mSnapshot.getPackageStates()).thenReturn(mPackageStates);
+        lenient().when(mUnfilteredSnapshot.getPackageStates()).thenReturn(mPackageStates);
 
         mBroadcastReceiverCaptor = ArgumentCaptor.forClass(BroadcastReceiver.class);
         lenient()
@@ -160,6 +170,10 @@ public class DexUseManagerTest {
         lenient().when(ArtJni.validateDexPath(any())).thenReturn(null);
         lenient().when(ArtJni.validateClassLoaderContext(any(), any())).thenReturn(null);
 
+        lenient()
+                .when(mPackageManagerLocal.withUnfilteredSnapshot())
+                .thenReturn(mUnfilteredSnapshot);
+
         lenient().when(mInjector.getArtd()).thenReturn(mArtd);
         lenient().when(mInjector.getCurrentTimeMillis()).thenReturn(0l);
         lenient().when(mInjector.getFilename()).thenReturn(mTempFile.getPath());
@@ -170,6 +184,7 @@ public class DexUseManagerTest {
         lenient().when(mInjector.getAllPackageNames()).thenReturn(mPackageStates.keySet());
         lenient().when(mInjector.isPreReboot()).thenReturn(false);
         lenient().when(mInjector.getArtManagerLocal()).thenReturn(mArtManagerLocal);
+        lenient().when(mInjector.getPackageManagerLocal()).thenReturn(mPackageManagerLocal);
 
         mDexUseManager = new DexUseManagerLocal(mInjector);
         mDexUseManager.systemReady();
@@ -232,6 +247,18 @@ public class DexUseManagerTest {
                 .isFalse();
     }
 
+    @Test
+    public void testPrimaryDexInvisible() {
+        mDexUseManager.notifyDexContainersLoaded(
+                mSnapshot, LOADING_PKG_NAME, Map.of(INVISIBLE_BASE_APK, "CLC"));
+
+        assertThat(mDexUseManager.getPrimaryDexLoaders(INVISIBLE_PKG_NAME, INVISIBLE_BASE_APK))
+                .isEmpty();
+        assertThat(
+                mDexUseManager.isPrimaryDexUsedByOtherApps(INVISIBLE_PKG_NAME, INVISIBLE_BASE_APK))
+                .isFalse();
+    }
+
     /** Checks that it ignores and dedups things correctly. */
     @Test
     public void testPrimaryDexMultipleEntries() throws Exception {
@@ -650,7 +677,7 @@ public class DexUseManagerTest {
     public void testCleanupDeletedPackage() throws Exception {
         PackageState pkgState = createPackageState(
                 "com.example.deletedpackage", "arm64-v8a", true /* hasPackage */);
-        addPackage("com.example.deletedpackage", pkgState);
+        addPackage("com.example.deletedpackage", pkgState, true /* isVisible */);
         lenient()
                 .when(mArtd.getDexFileVisibility(
                         "/somewhere/app/com.example.deletedpackage/base.apk"))
@@ -879,8 +906,10 @@ public class DexUseManagerTest {
         return pkgState;
     }
 
-    private void addPackage(String packageName, PackageState pkgState) {
-        lenient().when(mSnapshot.getPackageState(packageName)).thenReturn(pkgState);
+    private void addPackage(String packageName, PackageState pkgState, boolean isVisible) {
+        if (isVisible) {
+            lenient().when(mSnapshot.getPackageState(packageName)).thenReturn(pkgState);
+        }
         mPackageStates.put(packageName, pkgState);
     }
 
diff --git a/libartservice/service/javatests/com/android/server/art/DexoptHelperTest.java b/libartservice/service/javatests/com/android/server/art/DexoptHelperTest.java
index 8fb46b6225..f6ed721157 100644
--- a/libartservice/service/javatests/com/android/server/art/DexoptHelperTest.java
+++ b/libartservice/service/javatests/com/android/server/art/DexoptHelperTest.java
@@ -25,7 +25,6 @@ import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertThrows;
 import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.anyLong;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.lenient;
@@ -34,7 +33,6 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.same;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.apphibernation.AppHibernationManager;
@@ -88,6 +86,7 @@ public class DexoptHelperTest {
     private static final String PKG_NAME_LIB3 = "com.example.lib3";
     private static final String PKG_NAME_LIB4 = "com.example.lib4";
     private static final String PKG_NAME_LIBBAZ = "com.example.libbaz";
+    private static final String PKG_NAME_SDK = "com.example.sdk";
 
     @Rule
     public StaticMockitoRule mockitoRule = new StaticMockitoRule(PackageStateModulesUtils.class);
@@ -282,6 +281,28 @@ public class DexoptHelperTest {
         verifyNoMoreDexopt(6 /* expectedPrimaryTimes */, 0 /* expectedSecondaryTimes */);
     }
 
+    @Test
+    public void testDexoptSdkPrimaryOnly() throws Exception {
+        mParams = new DexoptParams.Builder("bg-dexopt")
+                          .setCompilerFilter("speed-profile")
+                          .setFlags(ArtFlags.FLAG_FOR_PRIMARY_DEX | ArtFlags.FLAG_FOR_SECONDARY_DEX)
+                          .build();
+
+        PackageState sdkPackageState =
+                createPackageState(PKG_NAME_SDK, -1 /* appId */, List.of(), false);
+        lenient().when(mSnapshot.getPackageState(PKG_NAME_SDK)).thenReturn(sdkPackageState);
+        mRequestedPackages = List.of(PKG_NAME_SDK);
+
+        DexoptResult result = mDexoptHelper.dexopt(
+                mSnapshot, mRequestedPackages, mParams, mCancellationSignal, mExecutor);
+
+        assertThat(result.getPackageDexoptResults()).hasSize(1);
+        checkPackageResult(result, 0 /* index */, PKG_NAME_SDK, DexoptResult.DEXOPT_PERFORMED,
+                List.of(mPrimaryResults));
+
+        verifyNoMoreDexopt(1 /* expectedPrimaryTimes */, 0 /* expectedSecondaryTimes */);
+    }
+
     @Test
     public void testDexoptPrimaryOnlyNoDependencies() throws Exception {
         mParams = new DexoptParams.Builder("install")
@@ -712,9 +733,14 @@ public class DexoptHelperTest {
 
     private PackageState createPackageState(
             String packageName, List<SharedLibrary> deps, boolean multiSplit) {
+        return createPackageState(packageName, 12345, deps, multiSplit);
+    }
+
+    private PackageState createPackageState(
+            String packageName, int appId, List<SharedLibrary> deps, boolean multiSplit) {
         PackageState pkgState = mock(PackageState.class);
         lenient().when(pkgState.getPackageName()).thenReturn(packageName);
-        lenient().when(pkgState.getAppId()).thenReturn(12345);
+        lenient().when(pkgState.getAppId()).thenReturn(appId);
         lenient().when(pkgState.getSharedLibraryDependencies()).thenReturn(deps);
         AndroidPackage pkg = createPackage(multiSplit);
         lenient().when(pkgState.getAndroidPackage()).thenReturn(pkg);
diff --git a/libartservice/service/javatests/com/android/server/art/PreRebootDexoptJobTest.java b/libartservice/service/javatests/com/android/server/art/PreRebootDexoptJobTest.java
index 7103d4023b..4aaf1d5be9 100644
--- a/libartservice/service/javatests/com/android/server/art/PreRebootDexoptJobTest.java
+++ b/libartservice/service/javatests/com/android/server/art/PreRebootDexoptJobTest.java
@@ -134,7 +134,7 @@ public class PreRebootDexoptJobTest {
 
     @Test
     public void testSchedule() throws Exception {
-        assertThat(mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */))
+        assertThat(mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */))
                 .isEqualTo(ArtFlags.SCHEDULE_SUCCESS);
 
         assertThat(mJobInfo.isPeriodic()).isFalse();
@@ -148,7 +148,7 @@ public class PreRebootDexoptJobTest {
         when(SystemProperties.getBoolean(eq("pm.dexopt.disable_bg_dexopt"), anyBoolean()))
                 .thenReturn(true);
 
-        assertThat(mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */))
+        assertThat(mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */))
                 .isEqualTo(ArtFlags.SCHEDULE_DISABLED_BY_SYSPROP);
 
         verify(mJobScheduler, never()).schedule(any());
@@ -171,7 +171,7 @@ public class PreRebootDexoptJobTest {
         when(SystemProperties.getBoolean(eq("dalvik.vm.enable_pr_dexopt"), anyBoolean()))
                 .thenReturn(false);
 
-        assertThat(mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */))
+        assertThat(mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */))
                 .isEqualTo(ArtFlags.SCHEDULE_DISABLED_BY_SYSPROP);
 
         verify(mJobScheduler, never()).schedule(any());
@@ -199,7 +199,7 @@ public class PreRebootDexoptJobTest {
                         eq(DeviceConfig.NAMESPACE_RUNTIME), eq("enable_pr_dexopt"), anyBoolean()))
                 .thenReturn(true);
 
-        assertThat(mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */))
+        assertThat(mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */))
                 .isEqualTo(ArtFlags.SCHEDULE_SUCCESS);
 
         verify(mJobScheduler).schedule(any());
@@ -218,7 +218,7 @@ public class PreRebootDexoptJobTest {
                      eq("force_disable_pr_dexopt"), anyBoolean()))
                 .thenReturn(true);
 
-        assertThat(mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */))
+        assertThat(mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */))
                 .isEqualTo(ArtFlags.SCHEDULE_DISABLED_BY_SYSPROP);
 
         verify(mJobScheduler, never()).schedule(any());
@@ -226,7 +226,7 @@ public class PreRebootDexoptJobTest {
 
     @Test
     public void testUnschedule() {
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
         verify(mJobScheduler).cancel(JOB_ID);
     }
 
@@ -248,8 +248,8 @@ public class PreRebootDexoptJobTest {
                 });
 
         assertThat(mPreRebootDexoptJob.hasStarted()).isFalse();
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
         assertThat(jobStarted.tryAcquire(TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue();
         assertThat(mPreRebootDexoptJob.hasStarted()).isTrue();
 
@@ -279,9 +279,9 @@ public class PreRebootDexoptJobTest {
             return true;
         });
 
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
-        mPreRebootDexoptJob.onStopJob(mJobParameters);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStopJobImpl(mJobParameters);
 
         // Check that `onStopJob` is really blocking. If it wasn't, the check below might still pass
         // due to a race, but we would have a flaky test.
@@ -311,57 +311,57 @@ public class PreRebootDexoptJobTest {
 
     @Test
     public void testUpdateOtaSlotOtaThenMainline() {
-        mPreRebootDexoptJob.onUpdateReady("_b" /* otaSlot */);
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_b" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
 
         when(mPreRebootDriver.run(eq("_b"), anyBoolean(), any())).thenReturn(true);
 
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
         mPreRebootDexoptJob.waitForRunningJob();
     }
 
     @Test
     public void testUpdateOtaSlotMainlineThenOta() {
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
-        mPreRebootDexoptJob.onUpdateReady("_a" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_a" /* otaSlot */);
 
         when(mPreRebootDriver.run(eq("_a"), anyBoolean(), any())).thenReturn(true);
 
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
         mPreRebootDexoptJob.waitForRunningJob();
     }
 
     @Test
     public void testUpdateOtaSlotMainlineThenMainline() {
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
 
         when(mPreRebootDriver.run(isNull(), anyBoolean(), any())).thenReturn(true);
 
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
         mPreRebootDexoptJob.waitForRunningJob();
     }
 
     @Test
     public void testUpdateOtaSlotOtaThenOta() {
-        mPreRebootDexoptJob.onUpdateReady("_b" /* otaSlot */);
-        mPreRebootDexoptJob.onUpdateReady("_b" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_b" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_b" /* otaSlot */);
 
         when(mPreRebootDriver.run(eq("_b"), anyBoolean(), any())).thenReturn(true);
 
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
         mPreRebootDexoptJob.waitForRunningJob();
     }
 
     @Test(expected = IllegalStateException.class)
     public void testUpdateOtaSlotOtaThenOtaDifferentSlots() {
-        mPreRebootDexoptJob.onUpdateReady("_b" /* otaSlot */);
-        mPreRebootDexoptJob.onUpdateReady("_a" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_b" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_a" /* otaSlot */);
     }
 
     @Test(expected = IllegalStateException.class)
     public void testUpdateOtaSlotOtaBogusSlot() {
-        mPreRebootDexoptJob.onUpdateReady("_bogus" /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl("_bogus" /* otaSlot */);
     }
 
     /**
@@ -379,10 +379,10 @@ public class PreRebootDexoptJobTest {
         });
 
         // An update arrives. A job is scheduled.
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
 
         // The job scheduler starts the job.
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
 
         var jobFinishedCalledAfterNewJobStarted = new Semaphore(0);
 
@@ -390,15 +390,15 @@ public class PreRebootDexoptJobTest {
             // Another update arrives. A new job is scheduled, replacing the old job. The old job
             // doesn't exit immediately, so this call is blocked.
             JobParameters oldParameters = mJobParameters;
-            mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+            mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
 
             // The job scheduler tries to cancel the old job because of the new update. This call
             // doesn't matter because the job has already been cancelled by ourselves during the
-            // `onUpdateReady` call above.
-            mPreRebootDexoptJob.onStopJob(oldParameters);
+            // `onUpdateReadyImpl` call above.
+            mPreRebootDexoptJob.onStopJobImpl(oldParameters);
 
             // The job scheduler starts the new job.
-            mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+            mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
 
             doAnswer(invocation -> {
                 jobFinishedCalledAfterNewJobStarted.release();
@@ -432,19 +432,21 @@ public class PreRebootDexoptJobTest {
     @Test
     public void testRace2() throws Exception {
         // An update arrives. A job is scheduled.
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
         JobParameters oldParameters = mJobParameters;
 
         // The job scheduler starts the job. In the meantime, another update arrives. It's not
-        // possible that `onStartJob` is called for the old job after `onUpdateReady` is called
-        // because `onUpdateReady` unschedules the old job. However, since both calls acquire a
+        // possible that `onStartJob` is called for the old job after `onUpdateReadyImpl` is called
+        // because `onUpdateReadyImpl` unschedules the old job. However, since both calls acquire a
         // lock, the order of execution may be reversed. When this happens, the `onStartJob` request
         // should not succeed.
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
-        assertThat(mPreRebootDexoptJob.onStartJob(mJobService, oldParameters)).isFalse();
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, oldParameters);
+        assertThat(mPreRebootDexoptJob.hasRunningJob()).isFalse();
 
         // The job scheduler starts the new job. This request should succeed.
-        assertThat(mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters)).isTrue();
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
+        assertThat(mPreRebootDexoptJob.hasRunningJob()).isTrue();
     }
 
     /**
@@ -463,10 +465,10 @@ public class PreRebootDexoptJobTest {
         });
 
         // An update arrives. A job is scheduled.
-        mPreRebootDexoptJob.onUpdateReady(null /* otaSlot */);
+        mPreRebootDexoptJob.onUpdateReadyImpl(null /* otaSlot */);
 
         // The job scheduler starts the job.
-        mPreRebootDexoptJob.onStartJob(mJobService, mJobParameters);
+        mPreRebootDexoptJob.onStartJobImpl(mJobService, mJobParameters);
 
         // Another update arrives, requesting a synchronous job run, replacing the old job. The new
         // job, which is synchronous, is started right after the old job is cancelled by
@@ -482,7 +484,7 @@ public class PreRebootDexoptJobTest {
         // The `onStopJob` call finally arrives. This call should be a no-op because the job has
         // already been cancelled by ourselves during the `onUpdateReadyStartNow` call above. It
         // should not cancel the new job.
-        mPreRebootDexoptJob.onStopJob(oldParameters);
+        mPreRebootDexoptJob.onStopJobImpl(oldParameters);
 
         // The new job should not be cancelled.
         assertThat(jobExited.tryAcquire()).isFalse();
diff --git a/libartservice/service/javatests/com/android/server/art/PrimaryDexopterParameterizedTest.java b/libartservice/service/javatests/com/android/server/art/PrimaryDexopterParameterizedTest.java
index 49d7c6cb41..10f9f59e91 100644
--- a/libartservice/service/javatests/com/android/server/art/PrimaryDexopterParameterizedTest.java
+++ b/libartservice/service/javatests/com/android/server/art/PrimaryDexopterParameterizedTest.java
@@ -51,8 +51,6 @@ import com.android.server.art.model.DexoptParams;
 import com.android.server.art.model.DexoptResult;
 import com.android.server.art.testing.TestingUtils;
 
-import dalvik.system.DexFile;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -344,7 +342,7 @@ public class PrimaryDexopterParameterizedTest extends PrimaryDexopterTestBase {
                 .when(mArtd)
                 .getDexoptNeeded("/somewhere/app/foo/base.apk", "arm", "PCL[]",
                         mParams.mExpectedCompilerFilter, mParams.mExpectedDexoptTrigger);
-        doThrow(ServiceSpecificException.class)
+        doThrow(new ServiceSpecificException(31, "This is an error message."))
                 .when(mArtd)
                 .dexopt(deepEq(buildOutputArtifacts("/somewhere/app/foo/base.apk", "arm",
                                 mParams.mIsInDalvikCache, permissionSettings,
diff --git a/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTest.java b/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTest.java
index 0030085497..5cc201cd37 100644
--- a/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTest.java
+++ b/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTest.java
@@ -577,7 +577,7 @@ public class PrimaryDexopterTest extends PrimaryDexopterTestBase {
 
         when(mArtd.dexopt(any(), eq(mDexPath), any(), any(), any(), any(), any(), any(), anyInt(),
                      any(), any()))
-                .thenThrow(ServiceSpecificException.class);
+                .thenThrow(new ServiceSpecificException(42, "This is an error message"));
 
         mPrimaryDexopter.dexopt();
 
diff --git a/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTestBase.java b/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTestBase.java
index 3105e4e51b..d94190ded5 100644
--- a/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTestBase.java
+++ b/libartservice/service/javatests/com/android/server/art/PrimaryDexopterTestBase.java
@@ -46,6 +46,7 @@ import org.mockito.Mock;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ThreadPoolExecutor;
 
 public class PrimaryDexopterTestBase {
     protected static final String PKG_NAME = "com.example.foo";
@@ -65,6 +66,7 @@ public class PrimaryDexopterTestBase {
     @Mock protected DexUseManagerLocal mDexUseManager;
     @Mock protected StorageManager mStorageManager;
     @Mock protected DexMetadataHelper.Injector mDexMetadataHelperInjector;
+    @Mock protected ThreadPoolExecutor mReporterExecutor;
     protected PackageState mPkgState;
     protected AndroidPackage mPkg;
     protected PackageUserState mPkgUserStateNotInstalled;
@@ -91,6 +93,7 @@ public class PrimaryDexopterTestBase {
         lenient().when(mInjector.getStorageManager()).thenReturn(mStorageManager);
         lenient().when(mInjector.getArtVersion()).thenReturn(ART_VERSION);
         lenient().when(mInjector.getConfig()).thenReturn(mConfig);
+        lenient().when(mInjector.getReporterExecutor()).thenReturn(mReporterExecutor);
         lenient().when(mInjector.getDexMetadataHelper()).thenReturn(mDexMetadataHelper);
         lenient().when(mInjector.isPreReboot()).thenReturn(false);
 
diff --git a/libartservice/service/javatests/com/android/server/art/SecondaryDexopterTest.java b/libartservice/service/javatests/com/android/server/art/SecondaryDexopterTest.java
index 07dd07dae7..074edc0629 100644
--- a/libartservice/service/javatests/com/android/server/art/SecondaryDexopterTest.java
+++ b/libartservice/service/javatests/com/android/server/art/SecondaryDexopterTest.java
@@ -61,6 +61,7 @@ import org.mockito.Mock;
 
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.function.Function;
 
 @SmallTest
@@ -108,6 +109,7 @@ public class SecondaryDexopterTest {
     @Mock private IArtd mArtd;
     @Mock private DexUseManagerLocal mDexUseManager;
     @Mock private DexMetadataHelper.Injector mDexMetadataHelperInjector;
+    @Mock private ThreadPoolExecutor mReporterExecutor;
     private PackageState mPkgState;
     private AndroidPackage mPkg;
     private CancellationSignal mCancellationSignal;
@@ -144,6 +146,7 @@ public class SecondaryDexopterTest {
         lenient().when(mInjector.isLauncherPackage(any())).thenReturn(false);
         lenient().when(mInjector.getDexUseManager()).thenReturn(mDexUseManager);
         lenient().when(mInjector.getConfig()).thenReturn(mConfig);
+        lenient().when(mInjector.getReporterExecutor()).thenReturn(mReporterExecutor);
         lenient().when(mInjector.getDexMetadataHelper()).thenReturn(mDexMetadataHelper);
 
         List<CheckedSecondaryDexInfo> secondaryDexInfo = createSecondaryDexInfo();
diff --git a/libartservice/service/javatests/com/android/server/art/UtilsTest.java b/libartservice/service/javatests/com/android/server/art/UtilsTest.java
index 95fd747fbb..b3220ffdff 100644
--- a/libartservice/service/javatests/com/android/server/art/UtilsTest.java
+++ b/libartservice/service/javatests/com/android/server/art/UtilsTest.java
@@ -203,4 +203,21 @@ public class UtilsTest {
         Executor executor = ForkJoinPool.commonPool();
         Utils.executeAndWait(executor, () -> { throw new IllegalArgumentException(); });
     }
+
+    @Test
+    public void testPathStartsWith() {
+        assertThat(Utils.pathStartsWith("/a/b", "/a")).isTrue();
+        assertThat(Utils.pathStartsWith("/a/b", "/a/")).isTrue();
+
+        assertThat(Utils.pathStartsWith("/a/c", "/a/b")).isFalse();
+        assertThat(Utils.pathStartsWith("/ab", "/a")).isFalse();
+
+        assertThat(Utils.pathStartsWith("/a", "/a")).isTrue();
+        assertThat(Utils.pathStartsWith("/a/", "/a")).isTrue();
+        assertThat(Utils.pathStartsWith("/a", "/a/")).isTrue();
+
+        assertThat(Utils.pathStartsWith("/a", "/")).isTrue();
+        assertThat(Utils.pathStartsWith("/", "/")).isTrue();
+        assertThat(Utils.pathStartsWith("/", "/a")).isFalse();
+    }
 }
diff --git a/libarttools/Android.bp b/libarttools/Android.bp
index 1fd1321b01..e82ce0c403 100644
--- a/libarttools/Android.bp
+++ b/libarttools/Android.bp
@@ -51,6 +51,11 @@ cc_library {
         "com.android.art",
         "com.android.art.debug",
     ],
+    target: {
+        android: {
+            compile_multilib: "first",
+        },
+    },
 }
 
 cc_library_headers {
@@ -84,14 +89,16 @@ art_cc_defaults {
     target: {
         android: {
             static_libs: ["libmodules-utils-build"],
+            compile_multilib: "first",
         },
     },
 }
 
-// Version of ART gtest `art_libarttools_tests` bundled with the ART APEX on target.
+// Version of ART gtest `art_libarttools_tests` bundled for host.
 // TODO(b/192274705): Remove this module when the migration to standalone ART gtests is complete.
 art_cc_test {
     name: "art_libarttools_tests",
+    device_supported: false,
     defaults: [
         "art_gtest_defaults",
         "art_libarttools_tests_defaults",
@@ -124,6 +131,7 @@ art_cc_test {
         "libbase",
         "libfstab",
     ],
+    test_config_template: ":art-gtests-target-standalone-non-multilib-template",
 }
 
 cc_binary {
@@ -137,7 +145,7 @@ cc_binary {
     shared_libs: [
         "libartbase",
         "libartpalette",
-        "libarttools", // Contains "libc++fs".
+        "libarttools",
         "libbase",
     ],
     static_libs: [
diff --git a/libarttools/art_exec.cc b/libarttools/art_exec.cc
index dfd0ca5bf9..715ab399a5 100644
--- a/libarttools/art_exec.cc
+++ b/libarttools/art_exec.cc
@@ -35,6 +35,7 @@
 #include "android-base/result.h"
 #include "android-base/strings.h"
 #include "base/macros.h"
+#include "base/os.h"
 #include "base/scoped_cap.h"
 #include "palette/palette.h"
 #include "system/thread_defs.h"
@@ -46,6 +47,7 @@ using ::android::base::Join;
 using ::android::base::ParseInt;
 using ::android::base::Result;
 using ::android::base::Split;
+using ::art::OS;
 
 constexpr const char* kUsage =
     R"(A wrapper binary that configures the process and executes a command.
@@ -231,13 +233,21 @@ int main(int argc, char** argv) {
 
   // `argv[argc]` is `nullptr`, which `execv` needs.
   std::vector<char*> command_args(&argv[options.command_pos], &argv[argc + 1]);
+  std::string program_path = argv[options.command_pos];
+  // "/mnt/compat_env" is prepared by dexopt_chroot_setup on Android V.
+  constexpr const char* kCompatArtdPath = "/mnt/compat_env/apex/com.android.art/bin/artd";
+  if (program_path == "/apex/com.android.art/bin/artd" && OS::FileExists(kCompatArtdPath)) {
+    LOG(INFO) << "Overriding program path to " << kCompatArtdPath;
+    program_path = kCompatArtdPath;
+    command_args[0] = program_path.data();
+  }
   std::string override_program_name;
   if (!options.process_name_suffix.empty()) {
     override_program_name = ART_FORMAT("{} ({})", command_args[0], options.process_name_suffix);
     command_args[0] = override_program_name.data();
   }
 
-  execv(argv[options.command_pos], command_args.data());
+  execv(program_path.c_str(), command_args.data());
 
   // Remove the trialing `nullptr`.
   command_args.resize(command_args.size() - 1);
diff --git a/libdexfile/Android.bp b/libdexfile/Android.bp
index 37f17308cd..b9320b7dae 100644
--- a/libdexfile/Android.bp
+++ b/libdexfile/Android.bp
@@ -270,11 +270,18 @@ art_cc_library {
     },
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This lib doesn't go into com.android.art, but
+        // TODO(b/183882457): This lib doesn't go into the following APEXes, but
         // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and libartd depends on this.
+        // stubs, and libartd and libprofiled depend on this.
         "com.android.art",
+        "test_broken_com.android.art",
     ],
+
+    // libdexfiled.so implements the libdexfile.so API in com.android.art.debug.
+    stubs: {
+        symbol_file: "libdexfile.map.txt",
+        versions: ["1"],
+    },
 }
 
 art_cc_defaults {
@@ -295,7 +302,6 @@ art_cc_defaults {
         "dex/dex_file_loader_test.cc",
         "dex/dex_file_verifier_test.cc",
         "dex/dex_instruction_test.cc",
-        "dex/fuzzer_corpus_test.cc",
         "dex/primitive_test.cc",
         "dex/proto_reference_test.cc",
         "dex/string_reference_test.cc",
@@ -306,7 +312,6 @@ art_cc_defaults {
     data: [
         ":art-gtest-jars-GetMethodSignature",
         ":art-gtest-jars-Lookup",
-        ":art-gtest-jars-DexFuzzerFolder",
         ":art-gtest-jars-Main",
         ":art-gtest-jars-MainEmptyUncompressed",
         ":art-gtest-jars-MultiDex",
@@ -333,7 +338,6 @@ art_cc_test {
         "art_standalone_gtest_defaults",
         "art_libdexfile_tests_defaults",
     ],
-    test_config: "art_standalone_libdexfile_tests.xml",
 }
 
 cc_library_headers {
@@ -411,7 +415,11 @@ art_cc_test {
     ],
 
     test_config_template: ":art-gtests-target-standalone-cts-template",
-    test_suites: ["cts"], // For backed-by API coverage.
+    // For backed-by API coverage.
+    test_suites: [
+        "cts",
+        "mcts-art",
+    ],
 }
 
 // Support library with a C++ API for accessing the libdexfile API for external
diff --git a/libdexfile/art_standalone_libdexfile_tests.xml b/libdexfile/art_standalone_libdexfile_tests.xml
deleted file mode 100644
index 4f18d8ab8b..0000000000
--- a/libdexfile/art_standalone_libdexfile_tests.xml
+++ /dev/null
@@ -1,53 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2021 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Runs art_standalone_libdexfile_tests.">
-    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.art.apex" />
-    <option name="config-descriptor:metadata" key="mainline-param" value="com.android.art.apex" />
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-        <option name="cleanup" value="true" />
-        <option name="push" value="art_standalone_libdexfile_tests->/data/local/tmp/art_standalone_libdexfile_tests/art_standalone_libdexfile_tests" />
-        <option name="append-bitness" value="true" />
-    </target_preparer>
-
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-        <option name="cleanup" value="true" />
-        <option name="push" value="art-gtest-jars-GetMethodSignature.jar->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-GetMethodSignature.jar" />
-        <option name="push" value="art-gtest-jars-Lookup.jar->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-Lookup.jar" />
-        <option name="push" value="art-gtest-jars-Main.jar->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-Main.jar" />
-        <option name="push" value="art-gtest-jars-MainEmptyUncompressed.jar->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-MainEmptyUncompressed.jar" />
-        <option name="push" value="art-gtest-jars-MultiDex.jar->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-MultiDex.jar" />
-        <option name="push" value="art-gtest-jars-Nested.jar->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-Nested.jar" />
-        <option name="push" value="art-gtest-jars-VerifierDeps.dex->/data/local/tmp/art_standalone_libdexfile_tests/art-gtest-jars-VerifierDeps.dex" />
-        <option name="push" value="fuzzer_corpus.zip->/data/local/tmp/art_standalone_libdexfile_tests/fuzzer_corpus.zip" />
-    </target_preparer>
-
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/art_standalone_libdexfile_tests" />
-        <option name="module-name" value="art_standalone_libdexfile_tests" />
-    </test>
-
-    <!-- When this test is run in a Mainline context (e.g. with `mts-tradefed`), only enable it if
-         one of the Mainline modules below is present on the device used for testing. -->
-    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
-        <!-- ART Mainline Module (internal version). -->
-        <option name="mainline-module-package-name" value="com.google.android.art" />
-        <!-- ART Mainline Module (external (AOSP) version). -->
-        <option name="mainline-module-package-name" value="com.android.art" />
-    </object>
-
-    <!-- Only run tests if the device under test is SDK version 31 (Android 12) or above. -->
-    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk31ModuleController" />
-</configuration>
diff --git a/libdexfile/dex/dex_file_loader.cc b/libdexfile/dex/dex_file_loader.cc
index d524dfceb1..e92a5ac813 100644
--- a/libdexfile/dex/dex_file_loader.cc
+++ b/libdexfile/dex/dex_file_loader.cc
@@ -161,12 +161,10 @@ std::string DexFileLoader::GetMultiDexLocation(size_t index, const char* dex_loc
   return StringPrintf("%s%cclasses%zu.dex", dex_location, kMultiDexSeparator, index + 1);
 }
 
-bool DexFileLoader::GetMultiDexChecksum(std::optional<uint32_t>* checksum,
-                                        std::string* error_msg,
-                                        bool* only_contains_uncompressed_dex) {
-  CHECK(checksum != nullptr);
-  checksum->reset();  // Return nullopt for an empty zip archive.
-
+bool DexFileLoader::GetMultiDexChecksums(
+    /*out*/ std::vector<std::pair<std::string, uint32_t>>* checksums,
+    /*out*/ std::string* error_msg,
+    /*out*/ bool* only_contains_uncompressed_dex) {
   uint32_t magic;
   if (!InitAndReadMagic(/*header_offset=*/0, &magic, error_msg)) {
     return false;
@@ -196,7 +194,7 @@ bool DexFileLoader::GetMultiDexChecksum(std::optional<uint32_t>* checksum,
           *only_contains_uncompressed_dex = false;
         }
       }
-      *checksum = checksum->value_or(kEmptyMultiDexChecksum) ^ zip_entry->GetCrc32();
+      checksums->emplace_back(GetMultiDexLocation(i, location_.c_str()), zip_entry->GetCrc32());
     }
     return true;
   }
@@ -205,6 +203,7 @@ bool DexFileLoader::GetMultiDexChecksum(std::optional<uint32_t>* checksum,
   }
   const uint8_t* begin = root_container_->Begin();
   const uint8_t* end = root_container_->End();
+  size_t i = 0;
   for (const uint8_t* ptr = begin; ptr < end;) {
     const auto* header = reinterpret_cast<const DexFile::Header*>(ptr);
     size_t size = dchecked_integral_cast<size_t>(end - ptr);
@@ -216,12 +215,28 @@ bool DexFileLoader::GetMultiDexChecksum(std::optional<uint32_t>* checksum,
       *error_msg = StringPrintf("Truncated dex file: '%s'", filename_.c_str());
       return false;
     }
-    *checksum = checksum->value_or(kEmptyMultiDexChecksum) ^ header->checksum_;
+    checksums->emplace_back(GetMultiDexLocation(i++, location_.c_str()), header->checksum_);
     ptr += header->file_size_;
   }
   return true;
 }
 
+bool DexFileLoader::GetMultiDexChecksum(std::optional<uint32_t>* checksum,
+                                        std::string* error_msg,
+                                        bool* only_contains_uncompressed_dex) {
+  CHECK(checksum != nullptr);
+  checksum->reset();  // Return nullopt for an empty zip archive.
+
+  std::vector<std::pair<std::string, uint32_t>> checksums;
+  if (!GetMultiDexChecksums(&checksums, error_msg, only_contains_uncompressed_dex)) {
+    return false;
+  }
+  for (const auto& [location, current_checksum] : checksums) {
+    *checksum = checksum->value_or(kEmptyMultiDexChecksum) ^ current_checksum;
+  }
+  return true;
+}
+
 std::string DexFileLoader::GetDexCanonicalLocation(const char* dex_location) {
   CHECK_NE(dex_location, static_cast<const char*>(nullptr));
   std::string base_location = GetBaseLocation(dex_location);
diff --git a/libdexfile/dex/dex_file_loader.h b/libdexfile/dex/dex_file_loader.h
index 9b5f7d56cd..1c7348214f 100644
--- a/libdexfile/dex/dex_file_loader.h
+++ b/libdexfile/dex/dex_file_loader.h
@@ -23,6 +23,7 @@
 #include <optional>
 #include <string>
 #include <string_view>
+#include <utility>
 #include <vector>
 
 #include "base/os.h"
@@ -72,6 +73,15 @@ class DexFileLoader {
   // index == 0, and dex_location + multi-dex-separator + GetMultiDexClassesDexName(index) else.
   static std::string GetMultiDexLocation(size_t index, const char* dex_location);
 
+  // Returns the multidex location and the checksum for each dex file in a zip or a dex container.
+  //
+  // This uses the source path provided to DexFileLoader constructor.
+  //
+  // Returns false on error.
+  bool GetMultiDexChecksums(/*out*/ std::vector<std::pair<std::string, uint32_t>>* checksums,
+                            /*out*/ std::string* error_msg,
+                            /*out*/ bool* only_contains_uncompressed_dex = nullptr);
+
   // Returns combined checksum of one or more dex files (one checksum for the whole multidex set).
   //
   // This uses the source path provided to DexFileLoader constructor.
diff --git a/libdexfile/dex/dex_file_verifier.cc b/libdexfile/dex/dex_file_verifier.cc
index 007181b1d7..d840027286 100644
--- a/libdexfile/dex/dex_file_verifier.cc
+++ b/libdexfile/dex/dex_file_verifier.cc
@@ -3120,7 +3120,7 @@ bool DexFileVerifier::CheckInterAnnotationSetItem() {
   uint32_t last_idx = 0;
 
   for (uint32_t i = 0; i < count; i++) {
-    if (*offsets != 0 && !CheckOffsetToTypeMap(*offsets, DexFile::kDexTypeAnnotationItem)) {
+    if (!CheckOffsetToTypeMap(*offsets, DexFile::kDexTypeAnnotationItem)) {
       return false;
     }
 
diff --git a/libdexfile/dex/fuzzer_corpus_test.cc b/libdexfile/dex/fuzzer_corpus_test.cc
deleted file mode 100644
index 24057e536d..0000000000
--- a/libdexfile/dex/fuzzer_corpus_test.cc
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <cstdint>
-#include <filesystem>
-#include <unordered_set>
-
-#include "android-base/file.h"
-#include "dex/dex_file_verifier.h"
-#include "dex/standard_dex_file.h"
-#include "gtest/gtest.h"
-#include "ziparchive/zip_archive.h"
-
-namespace art {
-
-class FuzzerCorpusTest : public testing::Test {
- public:
-  static void VerifyDexFile(const uint8_t* data,
-                            size_t size,
-                            const std::string& name,
-                            bool expected_success) {
-    // Do not verify the checksum as we only care about the DEX file contents,
-    // and know that the checksum would probably be erroneous (i.e. random).
-    constexpr bool kVerify = false;
-
-    // Special case for empty dex file. Set a fake data since the size is 0 anyway.
-    if (data == nullptr) {
-      ASSERT_EQ(size, 0);
-      data = reinterpret_cast<const uint8_t*>(&name);
-    }
-
-    auto container = std::make_shared<art::MemoryDexFileContainer>(data, size);
-    art::StandardDexFile dex_file(data,
-                                  /*location=*/name,
-                                  /*location_checksum=*/0,
-                                  /*oat_dex_file=*/nullptr,
-                                  container);
-
-    std::string error_msg;
-    bool success = art::dex::Verify(&dex_file, dex_file.GetLocation().c_str(), kVerify, &error_msg);
-    ASSERT_EQ(success, expected_success) << " Failed for " << name;
-  }
-};
-
-// Class that manages the ZipArchiveHandle liveness.
-class ZipArchiveHandleScope {
- public:
-  explicit ZipArchiveHandleScope(ZipArchiveHandle* handle) : handle_(handle) {}
-  ~ZipArchiveHandleScope() { CloseArchive(*(handle_.release())); }
-
- private:
-  std::unique_ptr<ZipArchiveHandle> handle_;
-};
-
-// Tests that we can verify dex files without crashing.
-TEST_F(FuzzerCorpusTest, VerifyCorpusDexFiles) {
-  // These dex files are expected to pass verification. The others are regressions tests.
-  const std::unordered_set<std::string> valid_dex_files = {"Main.dex", "hello_world.dex"};
-
-  // Consistency checks.
-  const std::string folder = android::base::GetExecutableDirectory();
-  ASSERT_TRUE(std::filesystem::is_directory(folder)) << folder << " is not a folder";
-  ASSERT_FALSE(std::filesystem::is_empty(folder)) << " No files found for directory " << folder;
-
-  const std::string filename = folder + "/fuzzer_corpus.zip";
-
-  // Iterate using ZipArchiveHandle. We have to be careful about managing the pointers with
-  // CloseArchive, StartIteration, and EndIteration.
-  std::string error_msg;
-  ZipArchiveHandle handle;
-  ZipArchiveHandleScope scope(&handle);
-  int32_t error = OpenArchive(filename.c_str(), &handle);
-  ASSERT_TRUE(error == 0) << "Error: " << error;
-
-  void* cookie;
-  error = StartIteration(handle, &cookie);
-  ASSERT_TRUE(error == 0) << "couldn't iterate " << filename << " : " << ErrorCodeString(error);
-
-  ZipEntry64 entry;
-  std::string name;
-  std::vector<char> data;
-  while ((error = Next(cookie, &entry, &name)) >= 0) {
-    if (!name.ends_with(".dex")) {
-      // Skip non-DEX files.
-      LOG(WARNING) << "Found a non-dex file: " << name;
-      continue;
-    }
-    data.resize(entry.uncompressed_length);
-    error = ExtractToMemory(handle, &entry, reinterpret_cast<uint8_t*>(data.data()), data.size());
-    ASSERT_TRUE(error == 0) << "failed to extract entry: " << name << " from " << filename << ""
-                            << ErrorCodeString(error);
-
-    const bool expected_success = valid_dex_files.find(name) != valid_dex_files.end();
-    VerifyDexFile(
-        reinterpret_cast<const uint8_t*>(data.data()), data.size(), name, expected_success);
-  }
-
-  ASSERT_TRUE(error >= -1) << "failed iterating " << filename << " : " << ErrorCodeString(error);
-  EndIteration(cookie);
-}
-
-}  // namespace art
diff --git a/libdexfile/dex/modifiers.h b/libdexfile/dex/modifiers.h
index e4fc74a3e7..def4ce2b44 100644
--- a/libdexfile/dex/modifiers.h
+++ b/libdexfile/dex/modifiers.h
@@ -111,7 +111,7 @@ static constexpr uint32_t kAccCorePlatformApi =       0x20000000;  // field, met
 // Uses an intrinsic bit but that's OK as intrinsics are always in the boot image.
 static constexpr uint32_t kAccMemorySharedMethod =       0x40000000;
 
-// Set by the compiler driver when compiling boot classes with instrinsic methods.
+// Set by the compiler driver when compiling boot classes with intrinsic methods.
 static constexpr uint32_t kAccIntrinsic  =            0x80000000;  // method (runtime)
 
 // Special runtime-only flags.
diff --git a/libelffile/elf/xz_utils.cc b/libelffile/elf/xz_utils.cc
index 4ec184a9ef..2914ac89fe 100644
--- a/libelffile/elf/xz_utils.cc
+++ b/libelffile/elf/xz_utils.cc
@@ -16,13 +16,13 @@
 
 #include "xz_utils.h"
 
-#include <vector>
 #include <mutex>
+#include <vector>
 
 #include "base/array_ref.h"
 #include "base/bit_utils.h"
+#include "base/globals.h"
 #include "base/leb128.h"
-#include "base/mem_map.h"
 #include "dwarf/writer.h"
 
 // liblzma.
@@ -99,7 +99,8 @@ void XzCompress(ArrayRef<const uint8_t> src,
 }
 
 void XzDecompress(ArrayRef<const uint8_t> src, std::vector<uint8_t>* dst) {
-  const size_t page_size = MemMap::GetPageSize();
+  static const size_t page_size = GetPageSizeSlow();
+  CHECK_NE(page_size, 0U);
 
   XzInitCrc();
   std::unique_ptr<CXzUnpacker> state(new CXzUnpacker());
diff --git a/libnativebridge/Android.bp b/libnativebridge/Android.bp
index 6a66b45ab2..fc83a4e00b 100644
--- a/libnativebridge/Android.bp
+++ b/libnativebridge/Android.bp
@@ -76,7 +76,7 @@ art_cc_library {
 }
 
 // TODO(b/124250621): eliminate the need for this library
-cc_library {
+cc_library_shared {
     name: "libnativebridge_lazy",
     defaults: ["libnativebridge-defaults"],
     visibility: [
@@ -95,6 +95,11 @@ cc_library {
     srcs: ["native_bridge_lazy.cc"],
     runtime_libs: ["libnativebridge"],
     shared_libs: ["liblog"],
+
+    // Apply the libnativebridge stub symbol file to the exported symbols from
+    // this shim library, to ensure that any symbols exposed here are also
+    // available as an exported API.
+    version_script: "libnativebridge.map.txt",
 }
 
 subdirs = ["tests"]
diff --git a/libnativebridge/include/nativebridge/native_bridge.h b/libnativebridge/include/nativebridge/native_bridge.h
index b2e4d2219b..491521642c 100644
--- a/libnativebridge/include/nativebridge/native_bridge.h
+++ b/libnativebridge/include/nativebridge/native_bridge.h
@@ -146,18 +146,6 @@ struct native_bridge_namespace_t;
 // Use NativeBridgeIsSupported() instead in non-namespace scenario.
 bool NativeBridgeIsPathSupported(const char* path);
 
-// Initializes anonymous namespace.
-// NativeBridge's peer of android_init_anonymous_namespace() of dynamic linker.
-//
-// The anonymous namespace is used in the case when a NativeBridge implementation
-// cannot identify the caller of dlopen/dlsym which happens for the code not loaded
-// by dynamic linker; for example calls from the mono-compiled code.
-//
-// Starting with v3, NativeBridge has two scenarios: with/without namespace.
-// Should not use in non-namespace scenario.
-bool NativeBridgeInitAnonymousNamespace(const char* public_ns_sonames,
-                                        const char* anon_ns_library_path);
-
 // Create new namespace in which native libraries will be loaded.
 // NativeBridge's peer of android_create_namespace() of dynamic linker.
 //
@@ -314,23 +302,8 @@ struct NativeBridgeCallbacks {
   // Use isSupported instead in non-namespace scenario.
   bool (*isPathSupported)(const char* library_path);
 
-  // Initializes anonymous namespace at native bridge side.
-  // NativeBridge's peer of android_init_anonymous_namespace() of dynamic linker.
-  //
-  // The anonymous namespace is used in the case when a NativeBridge implementation
-  // cannot identify the caller of dlopen/dlsym which happens for the code not loaded
-  // by dynamic linker; for example calls from the mono-compiled code.
-  //
-  // Parameters:
-  //   public_ns_sonames [IN] the name of "public" libraries.
-  //   anon_ns_library_path [IN] the library search path of (anonymous) namespace.
-  // Returns:
-  //   true if the pass is ok.
-  //   Otherwise, false.
-  //
-  // Starting with v3, NativeBridge has two scenarios: with/without namespace.
-  // Should not use in non-namespace scenario.
-  bool (*initAnonymousNamespace)(const char* public_ns_sonames, const char* anon_ns_library_path);
+  // No longer used.
+  bool (*unused_initAnonymousNamespace)(const char*, const char*);
 
   // Create new namespace in which native libraries will be loaded.
   // NativeBridge's peer of android_create_namespace() of dynamic linker.
diff --git a/libnativebridge/libnativebridge.map.txt b/libnativebridge/libnativebridge.map.txt
index 52d06eb60a..1c82d50f84 100644
--- a/libnativebridge/libnativebridge.map.txt
+++ b/libnativebridge/libnativebridge.map.txt
@@ -15,9 +15,7 @@
 #
 
 # Platform dependencies go through libnativebridge_lazy, which accesses
-# libnativebridge symbols through dlopen/dlsym. That means this list doesn't
-# have much effect, rather it's the function wrappers in native_bridge_lazy.cpp
-# that defines the exported interface. Please keep in sync with this list.
+# libnativebridge symbols through dlopen/dlsym and hence bypasses the stub.
 LIBNATIVEBRIDGE_1 {
   global:
     NativeBridgeGetError; # apex
diff --git a/libnativebridge/native_bridge.cc b/libnativebridge/native_bridge.cc
index 4ead5ada2d..4461f79919 100644
--- a/libnativebridge/native_bridge.cc
+++ b/libnativebridge/native_bridge.cc
@@ -668,19 +668,6 @@ bool NativeBridgeIsPathSupported(const char* path) {
   return false;
 }
 
-bool NativeBridgeInitAnonymousNamespace(const char* public_ns_sonames,
-                                        const char* anon_ns_library_path) {
-  if (NativeBridgeInitialized()) {
-    if (isCompatibleWith(NAMESPACE_VERSION)) {
-      return callbacks->initAnonymousNamespace(public_ns_sonames, anon_ns_library_path);
-    } else {
-      ALOGE("not compatible with version %d, cannot init namespace", NAMESPACE_VERSION);
-    }
-  }
-
-  return false;
-}
-
 native_bridge_namespace_t* NativeBridgeCreateNamespace(const char* name,
                                                        const char* ld_library_path,
                                                        const char* default_library_path,
diff --git a/libnativebridge/native_bridge_lazy.cc b/libnativebridge/native_bridge_lazy.cc
index 09eac02fd9..dd8a8068b4 100644
--- a/libnativebridge/native_bridge_lazy.cc
+++ b/libnativebridge/native_bridge_lazy.cc
@@ -69,20 +69,6 @@ void* NativeBridgeGetTrampoline(void* handle, const char* name, const char* shor
   return f(handle, name, shorty, len);
 }
 
-void* NativeBridgeGetTrampoline2(
-    void* handle, const char* name, const char* shorty, uint32_t len, JNICallType jni_call_type) {
-  static auto f = GET_FUNC_PTR(NativeBridgeGetTrampoline2);
-  return f(handle, name, shorty, len, jni_call_type);
-}
-
-void* NativeBridgeGetTrampolineForFunctionPointer(const void* method,
-                                                  const char* shorty,
-                                                  uint32_t len,
-                                                  JNICallType jni_call_type) {
-  static auto f = GET_FUNC_PTR(NativeBridgeGetTrampolineForFunctionPointer);
-  return f(method, shorty, len, jni_call_type);
-}
-
 const char* NativeBridgeGetError() {
   static auto f = GET_FUNC_PTR(NativeBridgeGetError);
   return f();
diff --git a/libnativebridge/tests/Android.bp b/libnativebridge/tests/Android.bp
index 3dbb79b730..93ef6feded 100644
--- a/libnativebridge/tests/Android.bp
+++ b/libnativebridge/tests/Android.bp
@@ -102,20 +102,9 @@ cc_test {
     name: "libnativebridge-tests",
     defaults: [
         "art_defaults",
-        "art_test_internal_library_defaults",
+        "art_standalone_test_defaults",
     ],
 
-    target: {
-        linux: {
-            cflags: [
-                // gtest issue
-                "-Wno-used-but-marked-unused",
-                "-Wno-deprecated",
-                "-Wno-missing-noreturn",
-            ],
-        },
-    },
-
     isolated: true,
 
     srcs: [
@@ -137,49 +126,56 @@ cc_test {
         "NativeBridge3UnloadLibrary_test.cpp",
         "NativeBridge3GetError_test.cpp",
         "NativeBridge3IsPathSupported_test.cpp",
-        "NativeBridge3InitAnonymousNamespace_test.cpp",
         "NativeBridge3CreateNamespace_test.cpp",
         "NativeBridge3LoadLibraryExt_test.cpp",
         "NativeBridge6PreZygoteFork_test.cpp",
         "NativeBridge7CriticalNative_test.cpp",
     ],
 
-    shared_libs: [
+    static_libs: [
         "libbase",
-        "liblog",
         "libnativebridge",
+    ],
+    shared_libs: [
+        "liblog",
         "libnativebridge6prezygotefork",
         "libnativebridge7criticalnative",
-
-        // Ideally these would only need to be listed in data_libs, but they
-        // are dlopen'd by libnativebridge, not by libnativebridge-tests,
-        // and the linker can't find them relative to /system/lib64/libnativebridge.so.
-        // Linking them here causes them to be loaded from alongside
-        // libnativebridge-tests when it is executed, and then the later dlopen
-        // returns the handle to the already-loaded library.
-        "libnativebridge-test-case",
-        "libnativebridge2-test-case",
-        "libnativebridge3-test-case",
-        "libnativebridge6-test-case",
-        "libnativebridge7-test-case",
     ],
     data_libs: [
+        "libnativebridge6prezygotefork",
+        "libnativebridge7criticalnative",
+
+        // These are dlopen'd by libnativebridge, not libnativebridge-tests, but
+        // the former is statically linked into the latter, so the linker will
+        // find them next to the test binary.
         "libnativebridge-test-case",
         "libnativebridge2-test-case",
         "libnativebridge3-test-case",
         "libnativebridge6-test-case",
         "libnativebridge7-test-case",
-        "libnativebridge6prezygotefork",
-        "libnativebridge7criticalnative",
     ],
 
+    target: {
+        linux: {
+            cflags: [
+                // gtest issue
+                "-Wno-used-but-marked-unused",
+                "-Wno-deprecated",
+                "-Wno-missing-noreturn",
+            ],
+        },
+        android: {
+            shared_libs: ["libdl_android"], // libnativebridge dependency
+        },
+    },
+
     test_suites: [
         "general-tests",
     ],
 }
 
-// Very basic tests in CTS to verify backed-by API coverage of the exported API
-// in libnativebridge.map.txt.
+// Very basic tests in CTS/MCTS to verify backed-by API coverage of the exported
+// API in libnativebridge.map.txt.
 cc_test {
     name: "art_libnativebridge_cts_tests",
     defaults: ["art_standalone_test_defaults"],
@@ -200,8 +196,9 @@ cc_test {
     defaults: ["art_standalone_test_defaults"],
     static_libs: [
         "libbase",
-        "libnativebridge_lazy",
     ],
+    shared_libs: ["libnativebridge_lazy"],
+    data_libs: ["libnativebridge_lazy"],
     srcs: ["libnativebridge_api_test.cpp"],
     test_suites: [
         "general-tests",
diff --git a/libnativebridge/tests/CodeCacheCreate_test.cpp b/libnativebridge/tests/CodeCacheCreate_test.cpp
index 57b1abc4c5..9af226c596 100644
--- a/libnativebridge/tests/CodeCacheCreate_test.cpp
+++ b/libnativebridge/tests/CodeCacheCreate_test.cpp
@@ -26,25 +26,25 @@ namespace android {
 // exist.
 TEST_F(NativeBridgeTest, CodeCacheCreate) {
     // Make sure that code_cache does not exist
-    rmdir(codeCache());
+    rmdir(CodeCache());
     struct stat st;
-    ASSERT_EQ(-1, stat(codeCache(), &st));
+    ASSERT_EQ(-1, stat(CodeCache(), &st));
     ASSERT_EQ(ENOENT, errno);
 
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary, nullptr));
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_FALSE(NativeBridgeError());
 
     // Check that code_cache was created
-    ASSERT_EQ(0, stat(codeCache(), &st));
+    ASSERT_EQ(0, stat(CodeCache(), &st));
     ASSERT_TRUE(S_ISDIR(st.st_mode));
 
     // Clean up
     UnloadNativeBridge();
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 
     ASSERT_FALSE(NativeBridgeError());
 }
diff --git a/libnativebridge/tests/CodeCacheExists_test.cpp b/libnativebridge/tests/CodeCacheExists_test.cpp
index c740bec79c..0e6d237c89 100644
--- a/libnativebridge/tests/CodeCacheExists_test.cpp
+++ b/libnativebridge/tests/CodeCacheExists_test.cpp
@@ -27,26 +27,26 @@ namespace android {
 TEST_F(NativeBridgeTest, CodeCacheExists) {
     // Make sure that code_cache does not exists
     struct stat st;
-    ASSERT_EQ(-1, stat(codeCache(), &st));
+    ASSERT_EQ(-1, stat(CodeCache(), &st));
     ASSERT_EQ(ENOENT, errno);
 
     // Create the code_cache
-    ASSERT_EQ(0, mkdir(codeCache(), S_IRWXU | S_IRWXG | S_IXOTH));
+    ASSERT_EQ(0, mkdir(CodeCache(), S_IRWXU | S_IRWXG | S_IXOTH));
 
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary, nullptr));
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_FALSE(NativeBridgeError());
 
     // Check that the code cache is still there
-    ASSERT_EQ(0, stat(codeCache(), &st));
+    ASSERT_EQ(0, stat(CodeCache(), &st));
     ASSERT_TRUE(S_ISDIR(st.st_mode));
 
     // Clean up
     UnloadNativeBridge();
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 
     ASSERT_FALSE(NativeBridgeError());
 }
diff --git a/libnativebridge/tests/CodeCacheStatFail_test.cpp b/libnativebridge/tests/CodeCacheStatFail_test.cpp
index 768f07944c..d13c6530ba 100644
--- a/libnativebridge/tests/CodeCacheStatFail_test.cpp
+++ b/libnativebridge/tests/CodeCacheStatFail_test.cpp
@@ -26,17 +26,17 @@ namespace android {
 // Tests that the bridge is initialized without errors if the code_cache is
 // existed as a file.
 TEST_F(NativeBridgeTest, CodeCacheStatFail) {
-  int fd = creat(codeCache(), O_RDWR);
+  int fd = creat(CodeCache(), O_RDWR);
   ASSERT_NE(-1, fd);
   close(fd);
 
   struct stat st;
-  ASSERT_EQ(-1, stat(codeCacheStatFail(), &st));
+  ASSERT_EQ(-1, stat(CodeCacheStatFail(), &st));
   ASSERT_EQ(ENOTDIR, errno);
 
   // Init
   ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary, nullptr));
-  ASSERT_TRUE(PreInitializeNativeBridge(codeCacheStatFail(), "isa"));
+  ASSERT_TRUE(PreInitializeNativeBridge(CodeCacheStatFail(), "isa"));
   ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
   ASSERT_TRUE(NativeBridgeAvailable());
   ASSERT_FALSE(NativeBridgeError());
@@ -45,7 +45,7 @@ TEST_F(NativeBridgeTest, CodeCacheStatFail) {
   UnloadNativeBridge();
 
   ASSERT_FALSE(NativeBridgeError());
-  unlink(codeCache());
+  unlink(CodeCache());
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/CompleteFlow_test.cpp b/libnativebridge/tests/CompleteFlow_test.cpp
index a4a6f20df9..24f255699c 100644
--- a/libnativebridge/tests/CompleteFlow_test.cpp
+++ b/libnativebridge/tests/CompleteFlow_test.cpp
@@ -24,7 +24,7 @@ TEST_F(NativeBridgeTest, CompleteFlow) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -41,7 +41,7 @@ TEST_F(NativeBridgeTest, CompleteFlow) {
     ASSERT_FALSE(NativeBridgeError());
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge2Signal_test.cpp b/libnativebridge/tests/NativeBridge2Signal_test.cpp
index a1663caeba..1edfcd4e57 100644
--- a/libnativebridge/tests/NativeBridge2Signal_test.cpp
+++ b/libnativebridge/tests/NativeBridge2Signal_test.cpp
@@ -25,7 +25,7 @@ TEST_F(NativeBridgeTest, V2_Signal) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary2, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -34,7 +34,7 @@ TEST_F(NativeBridgeTest, V2_Signal) {
     ASSERT_NE(nullptr, NativeBridgeGetSignalHandler(SIGSEGV));
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge3CreateNamespace_test.cpp b/libnativebridge/tests/NativeBridge3CreateNamespace_test.cpp
index 2b709e05ab..7cd8e6b34e 100644
--- a/libnativebridge/tests/NativeBridge3CreateNamespace_test.cpp
+++ b/libnativebridge/tests/NativeBridge3CreateNamespace_test.cpp
@@ -22,7 +22,7 @@ TEST_F(NativeBridgeTest, V3_CreateNamespace) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -32,7 +32,7 @@ TEST_F(NativeBridgeTest, V3_CreateNamespace) {
                                                    0, nullptr, nullptr));
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge3GetError_test.cpp b/libnativebridge/tests/NativeBridge3GetError_test.cpp
index e74e664881..cc376123eb 100644
--- a/libnativebridge/tests/NativeBridge3GetError_test.cpp
+++ b/libnativebridge/tests/NativeBridge3GetError_test.cpp
@@ -22,7 +22,7 @@ TEST_F(NativeBridgeTest, V3_GetError) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -31,7 +31,7 @@ TEST_F(NativeBridgeTest, V3_GetError) {
     ASSERT_EQ(nullptr, NativeBridgeGetError());
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge3InitAnonymousNamespace_test.cpp b/libnativebridge/tests/NativeBridge3InitAnonymousNamespace_test.cpp
deleted file mode 100644
index 2449939362..0000000000
--- a/libnativebridge/tests/NativeBridge3InitAnonymousNamespace_test.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "NativeBridgeTest.h"
-
-namespace android {
-
-TEST_F(NativeBridgeTest, V3_InitAnonymousNamespace) {
-  // Init
-  ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));
-  ASSERT_TRUE(NativeBridgeAvailable());
-  ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
-  ASSERT_TRUE(NativeBridgeAvailable());
-  ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
-  ASSERT_TRUE(NativeBridgeAvailable());
-
-  ASSERT_EQ(3U, NativeBridgeGetVersion());
-  ASSERT_EQ(true, NativeBridgeInitAnonymousNamespace(nullptr, nullptr));
-
-  // Clean-up code_cache
-  ASSERT_EQ(0, rmdir(codeCache()));
-}
-
-}  // namespace android
diff --git a/libnativebridge/tests/NativeBridge3IsPathSupported_test.cpp b/libnativebridge/tests/NativeBridge3IsPathSupported_test.cpp
index fd162c099d..cafa292560 100644
--- a/libnativebridge/tests/NativeBridge3IsPathSupported_test.cpp
+++ b/libnativebridge/tests/NativeBridge3IsPathSupported_test.cpp
@@ -22,7 +22,7 @@ TEST_F(NativeBridgeTest, V3_IsPathSupported) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -31,7 +31,7 @@ TEST_F(NativeBridgeTest, V3_IsPathSupported) {
     ASSERT_EQ(true, NativeBridgeIsPathSupported(nullptr));
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge3LoadLibraryExt_test.cpp b/libnativebridge/tests/NativeBridge3LoadLibraryExt_test.cpp
index eeb27e8431..1dbf11f2dd 100644
--- a/libnativebridge/tests/NativeBridge3LoadLibraryExt_test.cpp
+++ b/libnativebridge/tests/NativeBridge3LoadLibraryExt_test.cpp
@@ -22,7 +22,7 @@ TEST_F(NativeBridgeTest, V3_LoadLibraryExt) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -31,7 +31,7 @@ TEST_F(NativeBridgeTest, V3_LoadLibraryExt) {
     ASSERT_EQ(nullptr, NativeBridgeLoadLibraryExt(nullptr, 0, nullptr));
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge3UnloadLibrary_test.cpp b/libnativebridge/tests/NativeBridge3UnloadLibrary_test.cpp
index 39bf251f65..084b103971 100644
--- a/libnativebridge/tests/NativeBridge3UnloadLibrary_test.cpp
+++ b/libnativebridge/tests/NativeBridge3UnloadLibrary_test.cpp
@@ -22,7 +22,7 @@ TEST_F(NativeBridgeTest, V3_UnloadLibrary) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
@@ -31,7 +31,7 @@ TEST_F(NativeBridgeTest, V3_UnloadLibrary) {
     ASSERT_EQ(0, NativeBridgeUnloadLibrary(nullptr));
 
     // Clean-up code_cache
-    ASSERT_EQ(0, rmdir(codeCache()));
+    ASSERT_EQ(0, rmdir(CodeCache()));
 }
 
 }  // namespace android
diff --git a/libnativebridge/tests/NativeBridge6PreZygoteFork_test.cpp b/libnativebridge/tests/NativeBridge6PreZygoteFork_test.cpp
index b40e7bd79e..cfcded8676 100644
--- a/libnativebridge/tests/NativeBridge6PreZygoteFork_test.cpp
+++ b/libnativebridge/tests/NativeBridge6PreZygoteFork_test.cpp
@@ -23,7 +23,7 @@ TEST_F(NativeBridgeTest, V6_PreZygoteFork) {
     // Init
     ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary6, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
-    ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+    ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
     ASSERT_TRUE(NativeBridgeAvailable());
     ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
     ASSERT_TRUE(NativeBridgeAvailable());
diff --git a/libnativebridge/tests/NativeBridge7CriticalNative_test.cpp b/libnativebridge/tests/NativeBridge7CriticalNative_test.cpp
index a8c9bb65c4..e80d981d6d 100644
--- a/libnativebridge/tests/NativeBridge7CriticalNative_test.cpp
+++ b/libnativebridge/tests/NativeBridge7CriticalNative_test.cpp
@@ -23,7 +23,7 @@ TEST_F(NativeBridgeTest, V7_CriticalNative) {
   // Init
   ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary7, nullptr));
   ASSERT_TRUE(NativeBridgeAvailable());
-  ASSERT_TRUE(PreInitializeNativeBridge(appDataDir(), "isa"));
+  ASSERT_TRUE(PreInitializeNativeBridge(AppDataDir(), "isa"));
   ASSERT_TRUE(NativeBridgeAvailable());
   ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));
   ASSERT_TRUE(NativeBridgeAvailable());
diff --git a/libnativebridge/tests/NativeBridgeTest.h b/libnativebridge/tests/NativeBridgeTest.h
index 782e58424b..509973d756 100644
--- a/libnativebridge/tests/NativeBridgeTest.h
+++ b/libnativebridge/tests/NativeBridgeTest.h
@@ -35,22 +35,22 @@ namespace android {
 
 class NativeBridgeTest : public testing::Test {
  protected:
-  NativeBridgeTest() : tempDir() {
-    appDataDir_ = std::string(tempDir.path);
-    codeCache_ = appDataDir_ + "/code_cache";
-    codeCacheStatFail_ = codeCache_ + "/temp";
+  NativeBridgeTest() : temp_dir_() {
+    app_data_dir_ = std::string(temp_dir_.path);
+    code_cache_ = app_data_dir_ + "/code_cache";
+    code_cache_stat_fail_ = code_cache_ + "/temp";
   }
 
-  const char* appDataDir() { return appDataDir_.c_str(); }
+  const char* AppDataDir() { return app_data_dir_.c_str(); }
 
-  const char* codeCache() { return codeCache_.c_str(); }
+  const char* CodeCache() { return code_cache_.c_str(); }
 
-  const char* codeCacheStatFail() { return codeCacheStatFail_.c_str(); }
+  const char* CodeCacheStatFail() { return code_cache_stat_fail_.c_str(); }
 
-  TemporaryDir tempDir;
-  std::string appDataDir_;
-  std::string codeCache_;
-  std::string codeCacheStatFail_;
+  TemporaryDir temp_dir_;
+  std::string app_data_dir_;
+  std::string code_cache_;
+  std::string code_cache_stat_fail_;
 };
 
 };  // namespace android
diff --git a/libnativebridge/tests/NativeBridgeTestCase3.cpp b/libnativebridge/tests/NativeBridgeTestCase3.cpp
index c5bd032cef..398d762ff6 100644
--- a/libnativebridge/tests/NativeBridgeTestCase3.cpp
+++ b/libnativebridge/tests/NativeBridgeTestCase3.cpp
@@ -76,11 +76,6 @@ extern "C" bool native_bridge3_isPathSupported(const char* /* path */) {
   return true;
 }
 
-extern "C" bool native_bridge3_initAnonymousNamespace(const char* /* public_ns_sonames */,
-                                                      const char* /* anon_ns_library_path */) {
-  return true;
-}
-
 extern "C" android::native_bridge_namespace_t*
 native_bridge3_createNamespace(const char* /* name */,
                                const char* /* ld_library_path */,
@@ -118,7 +113,8 @@ android::NativeBridgeCallbacks NativeBridgeItf{
     .unloadLibrary = &native_bridge3_unloadLibrary,
     .getError = &native_bridge3_getError,
     .isPathSupported = &native_bridge3_isPathSupported,
-    .initAnonymousNamespace = &native_bridge3_initAnonymousNamespace,
+    .unused_initAnonymousNamespace = nullptr,
     .createNamespace = &native_bridge3_createNamespace,
     .linkNamespaces = &native_bridge3_linkNamespaces,
-    .loadLibraryExt = &native_bridge3_loadLibraryExt};
+    .loadLibraryExt = &native_bridge3_loadLibraryExt,
+};
diff --git a/libnativebridge/tests/NativeBridgeTestCase6.cpp b/libnativebridge/tests/NativeBridgeTestCase6.cpp
index 2b9fba51eb..351a7ea643 100644
--- a/libnativebridge/tests/NativeBridgeTestCase6.cpp
+++ b/libnativebridge/tests/NativeBridgeTestCase6.cpp
@@ -67,11 +67,6 @@ extern "C" bool native_bridge6_isPathSupported(const char* /* path */) {
   return true;
 }
 
-extern "C" bool native_bridge6_initAnonymousNamespace(const char* /* public_ns_sonames */,
-                                                      const char* /* anon_ns_library_path */) {
-  return true;
-}
-
 extern "C" android::native_bridge_namespace_t*
 native_bridge6_createNamespace(const char* /* name */,
                                const char* /* ld_library_path */,
@@ -121,7 +116,7 @@ android::NativeBridgeCallbacks NativeBridgeItf{
     .unloadLibrary = &native_bridge6_unloadLibrary,
     .getError = &native_bridge6_getError,
     .isPathSupported = &native_bridge6_isPathSupported,
-    .initAnonymousNamespace = &native_bridge6_initAnonymousNamespace,
+    .unused_initAnonymousNamespace = nullptr,
     .createNamespace = &native_bridge6_createNamespace,
     .linkNamespaces = &native_bridge6_linkNamespaces,
     .loadLibraryExt = &native_bridge6_loadLibraryExt,
@@ -130,4 +125,5 @@ android::NativeBridgeCallbacks NativeBridgeItf{
     // v5
     &native_bridge6_getExportedNamespace,
     // v6
-    &native_bridge6_preZygoteFork};
+    &native_bridge6_preZygoteFork,
+};
diff --git a/libnativebridge/tests/NativeBridgeTestCase7.cpp b/libnativebridge/tests/NativeBridgeTestCase7.cpp
index f84930c71b..6f4c5e4f8b 100644
--- a/libnativebridge/tests/NativeBridgeTestCase7.cpp
+++ b/libnativebridge/tests/NativeBridgeTestCase7.cpp
@@ -79,11 +79,6 @@ extern "C" const char* native_bridge7_getError() { return nullptr; }
 
 extern "C" bool native_bridge7_isPathSupported(const char* /* path */) { return true; }
 
-extern "C" bool native_bridge7_initAnonymousNamespace(const char* /* public_ns_sonames */,
-                                                      const char* /* anon_ns_library_path */) {
-  return true;
-}
-
 extern "C" android::native_bridge_namespace_t* native_bridge7_createNamespace(
     const char* /* name */,
     const char* /* ld_library_path */,
@@ -132,7 +127,7 @@ android::NativeBridgeCallbacks NativeBridgeItf{
     .unloadLibrary = &native_bridge7_unloadLibrary,
     .getError = &native_bridge7_getError,
     .isPathSupported = &native_bridge7_isPathSupported,
-    .initAnonymousNamespace = &native_bridge7_initAnonymousNamespace,
+    .unused_initAnonymousNamespace = nullptr,
     .createNamespace = &native_bridge7_createNamespace,
     .linkNamespaces = &native_bridge7_linkNamespaces,
     .loadLibraryExt = &native_bridge7_loadLibraryExt,
@@ -144,4 +139,5 @@ android::NativeBridgeCallbacks NativeBridgeItf{
     &native_bridge7_preZygoteFork,
     // v7
     &native_bridge7_getTrampoline2,
-    &native_bridge7_getTrampolineForFunctionPointer};
+    &native_bridge7_getTrampolineForFunctionPointer,
+};
diff --git a/libnativeloader/Android.bp b/libnativeloader/Android.bp
index 236f27fb92..3718f1e3ed 100644
--- a/libnativeloader/Android.bp
+++ b/libnativeloader/Android.bp
@@ -35,23 +35,6 @@ cc_library_headers {
 cc_defaults {
     name: "libnativeloader-defaults",
     defaults: ["art_defaults"],
-    header_libs: ["libnativeloader-headers"],
-    export_header_lib_headers: ["libnativeloader-headers"],
-}
-
-art_cc_library {
-    name: "libnativeloader",
-    defaults: ["libnativeloader-defaults"],
-    visibility: [
-        "//frameworks/base/cmds/app_process",
-        // TODO(b/133140750): Clean this up.
-        "//frameworks/base/native/webview/loader",
-    ],
-    apex_available: [
-        "com.android.art",
-        "com.android.art.debug",
-        "test_broken_com.android.art",
-    ],
     host_supported: true,
     srcs: [
         "native_loader.cpp",
@@ -59,11 +42,11 @@ art_cc_library {
     header_libs: [
         "art_libartbase_headers",
         "libnativehelper_header_only",
+        "libnativeloader-headers",
     ],
+    export_header_lib_headers: ["libnativeloader-headers"],
     shared_libs: [
-        "liblog",
         "libnativebridge",
-        "libbase",
     ],
     target: {
         android: {
@@ -81,6 +64,25 @@ art_cc_library {
             ],
         },
     },
+}
+
+art_cc_library {
+    name: "libnativeloader",
+    defaults: ["libnativeloader-defaults"],
+    shared_libs: [
+        "libbase",
+        "liblog",
+    ],
+    visibility: [
+        "//frameworks/base/cmds/app_process",
+        // TODO(b/133140750): Clean this up.
+        "//frameworks/base/native/webview/loader",
+    ],
+    apex_available: [
+        "com.android.art",
+        "com.android.art.debug",
+        "test_broken_com.android.art",
+    ],
     stubs: {
         symbol_file: "libnativeloader.map.txt",
         versions: ["1"],
@@ -91,9 +93,9 @@ art_cc_library {
 // inversion in places like in early boot where libnativeloader and/or
 // libnativebridge aren't available.
 // TODO(b/124250621) eliminate the need for this library
-cc_library {
+cc_library_shared {
     name: "libnativeloader_lazy",
-    defaults: ["libnativeloader-defaults"],
+    defaults: ["art_defaults"],
     visibility: [
         "//frameworks/base/core/jni",
         "//frameworks/native/opengl/libs",
@@ -108,15 +110,25 @@ cc_library {
     srcs: ["native_loader_lazy.cpp"],
     runtime_libs: ["libnativeloader"],
     shared_libs: ["liblog"],
+    header_libs: ["libnativeloader-headers"],
+    export_header_lib_headers: ["libnativeloader-headers"],
+
+    // Apply the libnativeloader stub symbol file to the exported symbols from
+    // this shim library, to ensure that any symbols exposed here are also
+    // available as an exported API.
+    version_script: "libnativeloader.map.txt",
 }
 
+// native_loader_test.cpp mocks functions from libdl_android and
+// libnativebridge, so those have to be linked dynamically and this test binary
+// needs to export symbols to override them.
 art_cc_test {
     name: "libnativeloader_test",
     defaults: [
         // Cannot use art_standalone_gtest_defaults because it makes us link
-        // libnativebridge statically through libart-gtest, but we need to mock
-        // its symbols here.
+        // libnativebridge statically through libart-gtest.
         "art_standalone_test_defaults",
+        "libnativeloader-defaults",
     ],
     host_supported: false,
 
@@ -132,7 +144,6 @@ art_cc_test {
     ],
     shared_libs: [
         "liblog", // libbase dependency
-        "libnativeloader",
     ],
     static_libs: [
         "libbase",
@@ -189,9 +200,8 @@ art_cc_test {
 art_cc_test {
     name: "libnativeloader_lazy_test",
     defaults: ["libnativeloader_api_test_defaults"],
-    static_libs: [
-        "libnativeloader_lazy",
-    ],
+    shared_libs: ["libnativeloader_lazy"],
+    data_libs: ["libnativeloader_lazy"],
     test_suites: [
         "general-tests",
         "mts-art",
diff --git a/libnativeloader/libnativeloader.map.txt b/libnativeloader/libnativeloader.map.txt
index 8c0fbddb4e..e88211541a 100644
--- a/libnativeloader/libnativeloader.map.txt
+++ b/libnativeloader/libnativeloader.map.txt
@@ -15,9 +15,7 @@
 #
 
 # Platform dependencies go through libnativeloader_lazy, which accesses
-# libnativeloader symbols through dlopen/dlsym. That means this list doesn't
-# have much effect, rather it's the function wrappers in native_loader_lazy.cpp
-# that defines the exported interface. Please keep in sync with this list.
+# libnativeloader symbols through dlopen/dlsym and hence bypasses the stub.
 LIBNATIVELOADER_1 {
   global:
     OpenNativeLibrary; # apex
diff --git a/libnativeloader/library_namespaces.cpp b/libnativeloader/library_namespaces.cpp
index e0f3d6af8c..7aa14080ce 100644
--- a/libnativeloader/library_namespaces.cpp
+++ b/libnativeloader/library_namespaces.cpp
@@ -86,6 +86,8 @@ constexpr const char* kProductLibPath = "/product/" LIB ":/system/product/" LIB;
 const std::regex kVendorPathRegex("(/system)?/vendor/.*");
 const std::regex kProductPathRegex("(/system)?/product/.*");
 const std::regex kSystemPathRegex("/system(_ext)?/.*");  // MUST be tested last.
+const std::regex kPartitionNativeLibPathRegex(
+    "/(system|(system/)?(system_ext|vendor|product))/lib(64)?/.*");
 
 jobject GetParentClassLoader(JNIEnv* env, jobject class_loader) {
   jclass class_loader_class = env->FindClass("java/lang/ClassLoader");
@@ -138,6 +140,12 @@ Result<ApiDomain> GetApiDomainFromPathList(const std::string& path_list) {
   return result;
 }
 
+// Returns true if the given path is in a partition-wide native library location,
+// i.e. <partition root>/lib(64).
+bool IsPartitionNativeLibPath(const std::string& path) {
+  return std::regex_match(path, kPartitionNativeLibPathRegex);
+}
+
 void LibraryNamespaces::Initialize() {
   // Once public namespace is initialized there is no
   // point in running this code - it will have no effect
diff --git a/libnativeloader/library_namespaces.h b/libnativeloader/library_namespaces.h
index b932a557e0..c9adee314c 100644
--- a/libnativeloader/library_namespaces.h
+++ b/libnativeloader/library_namespaces.h
@@ -58,6 +58,7 @@ using ApiDomain = enum {
 
 ApiDomain GetApiDomainFromPath(const std::string_view path);
 Result<ApiDomain> GetApiDomainFromPathList(const std::string& path_list);
+bool IsPartitionNativeLibPath(const std::string& path);
 
 // LibraryNamespaces is a singleton object that manages NativeLoaderNamespace
 // objects for an app process. Its main job is to create (and configure) a new
diff --git a/libnativeloader/library_namespaces_test.cpp b/libnativeloader/library_namespaces_test.cpp
index 706209a28e..0e2fa5de58 100644
--- a/libnativeloader/library_namespaces_test.cpp
+++ b/libnativeloader/library_namespaces_test.cpp
@@ -98,6 +98,23 @@ TEST(LibraryNamespacesTest, TestGetApiDomainFromPathList) {
   }
 }
 
+TEST(LibraryNamespacesTest, TestIsPartitionNativeLibPath) {
+  EXPECT_TRUE(IsPartitionNativeLibPath("/system/lib/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/system/lib64/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/system_ext/lib64/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/product/lib64/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/vendor/lib64/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/vendor/lib64/hw/libhw.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/system/system_ext/lib64/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/system/product/lib64/libfoo.so"));
+  EXPECT_TRUE(IsPartitionNativeLibPath("/system/vendor/lib64/libfoo.so"));
+
+  EXPECT_FALSE(IsPartitionNativeLibPath("/data/app/~~hash==/myapp-hash==/lib/arm64/libapp.so"));
+  EXPECT_FALSE(
+      IsPartitionNativeLibPath("/system/app/PrintSpooler/lib/arm64/libprintspooler_jni.so"));
+  EXPECT_FALSE(IsPartitionNativeLibPath("/product/app/Camera2/lib/arm64/libjni_jpegutil.so"));
+}
+
 }  // namespace
 }  // namespace nativeloader
 }  // namespace android
diff --git a/libnativeloader/native_loader.cpp b/libnativeloader/native_loader.cpp
index 13a4c2a482..3d24c3da14 100644
--- a/libnativeloader/native_loader.cpp
+++ b/libnativeloader/native_loader.cpp
@@ -31,6 +31,7 @@
 
 #include "android-base/file.h"
 #include "android-base/macros.h"
+#include <android-base/properties.h>
 #include "android-base/strings.h"
 #include "android-base/thread_annotations.h"
 #include "base/macros.h"
@@ -40,6 +41,7 @@
 
 #ifdef ART_TARGET_ANDROID
 #include "android-modules-utils/sdk_level.h"
+#include "android/api-level.h"
 #include "library_namespaces.h"
 #include "log/log.h"
 #include "nativeloader/dlext_namespaces.h"
@@ -54,9 +56,6 @@ namespace {
 using ::android::base::Result;
 using ::android::nativeloader::LibraryNamespaces;
 
-const std::regex kPartitionNativeLibPathRegex(
-    "/(system(_ext)?|(system/)?(vendor|product))/lib(64)?/.*");
-
 // NATIVELOADER_DEFAULT_NAMESPACE_LIBS is an environment variable that can be
 // used to list extra libraries (separated by ":") that libnativeloader will
 // load from the default namespace. The libraries must be listed without paths,
@@ -272,6 +271,21 @@ jstring CreateClassLoaderNamespace(JNIEnv* env,
   return nullptr;
 }
 
+#if defined(ART_TARGET_ANDROID)
+static bool ShouldBypassLoadingForB349878424() {
+  struct stat st;
+  if (stat("/system/lib64/libsobridge.so", &st) != 0 &&
+      stat("/system/lib64/libwalkstack.so", &st) != 0) {
+    return false;
+  }
+  std::string property = android::base::GetProperty("ro.product.build.fingerprint", "");
+  return android_get_device_api_level() == 33 &&
+      (property.starts_with("Xiaomi") ||
+       property.starts_with("Redmi") ||
+       property.starts_with("POCO"));
+}
+#endif
+
 void* OpenNativeLibrary(JNIEnv* env,
                         int32_t target_sdk_version,
                         const char* path,
@@ -320,6 +334,17 @@ void* OpenNativeLibrary(JNIEnv* env,
       }
     }
 
+    // Handle issue b/349878424.
+    static bool bypass_loading_for_b349878424 = ShouldBypassLoadingForB349878424();
+
+    if (bypass_loading_for_b349878424 &&
+        (strcmp("libsobridge.so", path) == 0 || strcmp("libwalkstack.so", path) == 0)) {
+      // Load a different library to pretend the loading was successful. This
+      // allows the device to boot.
+      ALOGD("Loading libbase.so instead of %s due to b/349878424", path);
+      path = "libbase.so";
+    }
+
     // Fall back to the system namespace. This happens for preloaded JNI
     // libraries in the zygote.
     void* handle = OpenSystemLibrary(path, RTLD_NOW);
@@ -340,10 +365,10 @@ void* OpenNativeLibrary(JNIEnv* env,
   // path, so we don't affect the lookup process for libraries specified by name
   // only.
   if (caller_location != nullptr &&
-      // Check that the library is in the partition-wide native library
-      // location. Apps in the partition may have their own native libraries,
-      // and those should still be loaded with the app's classloader namespace.
-      std::regex_match(path, kPartitionNativeLibPathRegex) &&
+      // Apps in the partition may have their own native libraries which should
+      // be loaded with the app's classloader namespace, so only do this for
+      // libraries in the partition-wide lib(64) directories.
+      nativeloader::IsPartitionNativeLibPath(path) &&
       // Don't do this if the system image is older than V, to avoid any compat
       // issues with apps and shared libs in them.
       android::modules::sdklevel::IsAtLeastV()) {
diff --git a/libprofile/Android.bp b/libprofile/Android.bp
index edea2ad5d8..ced2166957 100644
--- a/libprofile/Android.bp
+++ b/libprofile/Android.bp
@@ -208,5 +208,4 @@ art_cc_test {
         "art_standalone_gtest_defaults",
         "art_libprofile_tests_defaults",
     ],
-    test_config: "art_standalone_libprofile_tests.xml",
 }
diff --git a/libprofile/profile/profile_compilation_info.cc b/libprofile/profile/profile_compilation_info.cc
index 631bf1148b..799ad86919 100644
--- a/libprofile/profile/profile_compilation_info.cc
+++ b/libprofile/profile/profile_compilation_info.cc
@@ -60,6 +60,7 @@
 #include "dex/code_item_accessors-inl.h"
 #include "dex/descriptors_names.h"
 #include "dex/dex_file_loader.h"
+#include "dex/dex_instruction-inl.h"
 
 #ifdef ART_TARGET_ANDROID
 #include "android-modules-utils/sdk_level.h"
@@ -119,8 +120,8 @@ static_assert(ProfileCompilationInfo::kIndividualInlineCacheSize < kIsMegamorphi
 static_assert(ProfileCompilationInfo::kIndividualInlineCacheSize < kIsMissingTypesEncoding,
               "InlineCache::kIndividualInlineCacheSize is larger than expected");
 
-static constexpr uint32_t kSizeWarningThresholdBytes = 500000U;
-static constexpr uint32_t kSizeErrorThresholdBytes = 1500000U;
+static constexpr uint32_t kSizeWarningThresholdBytes = 5000000U;
+static constexpr uint32_t kSizeErrorThresholdBytes = 15000000U;
 
 static constexpr uint32_t kSizeWarningThresholdBootBytes = 25000000U;
 static constexpr uint32_t kSizeErrorThresholdBootBytes = 100000000U;
@@ -3030,9 +3031,49 @@ FlattenProfileData::ItemMetadata::ItemMetadata() :
     flags_(0) {
 }
 
-FlattenProfileData::ItemMetadata::ItemMetadata(const ItemMetadata& other) :
-    flags_(other.flags_),
-    annotations_(other.annotations_) {
+void FlattenProfileData::ItemMetadata::ExtractInlineCacheInfo(
+    const ProfileCompilationInfo& profile_info,
+    const DexFile* dex_file,
+    uint16_t dex_method_idx) {
+  ProfileCompilationInfo::MethodHotness hotness =
+      profile_info.GetMethodHotness(MethodReference(dex_file, dex_method_idx));
+  DCHECK(!hotness.IsHot() || hotness.GetInlineCacheMap() != nullptr);
+  if (!hotness.IsHot() || hotness.GetInlineCacheMap()->empty()) {
+    return;
+  }
+  const dex::MethodId& id = dex_file->GetMethodId(dex_method_idx);
+  const ProfileCompilationInfo::InlineCacheMap* inline_caches = hotness.GetInlineCacheMap();
+  const dex::ClassDef* class_def = dex_file->FindClassDef(id.class_idx_);
+  if (class_def == nullptr) {
+    // No class def found.
+    return;
+  }
+
+  CodeItemInstructionAccessor accessor(
+      *dex_file, dex_file->GetCodeItem(dex_file->FindCodeItemOffset(*class_def, dex_method_idx)));
+  for (const auto& [pc, ic_data] : *inline_caches) {
+    if (pc >= accessor.InsnsSizeInCodeUnits()) {
+      // Inlined inline caches are not supported in AOT, so discard any pc beyond the
+      // code item size. See also `HInliner::GetInlineCacheAOT`.
+      continue;
+    }
+    const Instruction& inst = accessor.InstructionAt(pc);
+    const dex::MethodId& target = dex_file->GetMethodId(inst.VRegB());
+    if (ic_data.classes.empty() && !ic_data.is_megamorphic && !ic_data.is_missing_types) {
+      continue;
+    }
+    InlineCacheInfo& val =
+        inline_cache_.FindOrAdd(TypeReference(dex_file, target.class_idx_))->second;
+    if (ic_data.is_megamorphic) {
+      val.is_megamorphic_ = true;
+    }
+    if (ic_data.is_missing_types) {
+      val.is_missing_types_ = true;
+    }
+    for (dex::TypeIndex type_index : ic_data.classes) {
+      val.classes_.insert(profile_info.GetTypeDescriptor(dex_file, type_index));
+    }
+  }
 }
 
 std::unique_ptr<FlattenProfileData> ProfileCompilationInfo::ExtractProfileData(
@@ -3067,6 +3108,8 @@ std::unique_ptr<FlattenProfileData> ProfileCompilationInfo::ExtractProfileData(
             result->method_metadata_.GetOrCreate(ref, create_metadata_fn);
         metadata.flags_ |= hotness.flags_;
         metadata.annotations_.push_back(annotation);
+        metadata.ExtractInlineCacheInfo(*this, dex_file.get(), method_idx);
+
         // Update the max aggregation counter for methods.
         // This is essentially a cache, to avoid traversing all the methods just to find out
         // this value.
@@ -3098,6 +3141,26 @@ std::unique_ptr<FlattenProfileData> ProfileCompilationInfo::ExtractProfileData(
   return result;
 }
 
+void FlattenProfileData::ItemMetadata::MergeInlineCacheInfo(
+    const SafeMap<TypeReference, InlineCacheInfo, TypeReferenceValueComparator>& other) {
+  for (const auto& [target, inline_cache_data] : other) {
+    if (!inline_cache_data.is_megamorphic_ && !inline_cache_data.is_missing_types_ &&
+        inline_cache_data.classes_.empty()) {
+      continue;
+    }
+    InlineCacheInfo& val = inline_cache_.FindOrAdd(target)->second;
+    if (inline_cache_data.is_megamorphic_) {
+      val.is_megamorphic_ = true;
+    }
+    if (inline_cache_data.is_missing_types_) {
+      val.is_missing_types_ = true;
+    }
+    for (const std::string& cls : inline_cache_data.classes_) {
+      val.classes_.insert(cls);
+    }
+  }
+}
+
 void FlattenProfileData::MergeData(const FlattenProfileData& other) {
   auto create_metadata_fn = []() { return FlattenProfileData::ItemMetadata(); };
   for (const auto& it : other.method_metadata_) {
@@ -3111,6 +3174,7 @@ void FlattenProfileData::MergeData(const FlattenProfileData& other) {
     metadata.flags_ |= otherData.GetFlags();
     metadata.annotations_.insert(
         metadata.annotations_.end(), other_annotations.begin(), other_annotations.end());
+    metadata.MergeInlineCacheInfo(otherData.GetInlineCache());
 
     max_aggregation_for_methods_ = std::max(
           max_aggregation_for_methods_,
diff --git a/libprofile/profile/profile_compilation_info.h b/libprofile/profile/profile_compilation_info.h
index 104198f1fa..f6b0105ff6 100644
--- a/libprofile/profile/profile_compilation_info.h
+++ b/libprofile/profile/profile_compilation_info.h
@@ -1092,8 +1092,14 @@ class FlattenProfileData {
  public:
   class ItemMetadata {
    public:
+    struct InlineCacheInfo {
+      bool is_megamorphic_ = false;
+      bool is_missing_types_ = false;
+      std::set<std::string> classes_;
+    };
+
     ItemMetadata();
-    ItemMetadata(const ItemMetadata& other);
+    ItemMetadata(const ItemMetadata& other) = default;
 
     uint16_t GetFlags() const {
       return flags_;
@@ -1111,12 +1117,29 @@ class FlattenProfileData {
       return (flags_ & flag) != 0;
     }
 
+    // Extracts inline cache info for the given method into this instance.
+    // Note that this will collapse all ICs with the same receiver type.
+    void ExtractInlineCacheInfo(const ProfileCompilationInfo& profile_info,
+                                const DexFile* dex_file,
+                                uint16_t dex_method_idx);
+
+    // Merges the inline cache info from the other metadata into this instance.
+    void MergeInlineCacheInfo(
+        const SafeMap<TypeReference, InlineCacheInfo, TypeReferenceValueComparator>& other);
+
+    const SafeMap<TypeReference, InlineCacheInfo, TypeReferenceValueComparator>& GetInlineCache()
+        const {
+      return inline_cache_;
+    }
+
    private:
     // will be 0 for classes and MethodHotness::Flags for methods.
     uint16_t flags_;
     // This is a list that may contain duplicates after a merge operation.
     // It represents that a method was used multiple times across different devices.
     std::list<ProfileCompilationInfo::ProfileSampleAnnotation> annotations_;
+    // Inline cache map for methods.
+    SafeMap<TypeReference, InlineCacheInfo, TypeReferenceValueComparator> inline_cache_;
 
     friend class ProfileCompilationInfo;
     friend class FlattenProfileData;
diff --git a/oatdump/oatdump.cc b/oatdump/oatdump.cc
index 5131a815ad..150bdae416 100644
--- a/oatdump/oatdump.cc
+++ b/oatdump/oatdump.cc
@@ -396,19 +396,27 @@ class OatDumper {
         oat_dex_files_(oat_file.GetOatDexFiles()),
         options_(options),
         resolved_addr2instr_(0),
-        instruction_set_(oat_file_.GetOatHeader().GetInstructionSet()),
-        disassembler_(Disassembler::Create(
-            instruction_set_,
-            new DisassemblerOptions(options_.absolute_addresses_,
-                                    oat_file.Begin(),
-                                    oat_file.End(),
-                                    /* can_read_literals_= */ true,
-                                    Is64BitInstructionSet(instruction_set_) ?
-                                        &Thread::DumpThreadOffset<PointerSize::k64> :
-                                        &Thread::DumpThreadOffset<PointerSize::k32>))) {
+        instruction_set_(oat_file_.GetOatHeader().GetInstructionSet()) {
     CHECK(options_.class_loader_ != nullptr);
     CHECK(options_.class_filter_ != nullptr);
     CHECK(options_.method_filter_ != nullptr);
+
+    std::string error_msg;
+    const uint8_t* elf_begin = oat_file.ComputeElfBegin(&error_msg);
+    DCHECK_NE(elf_begin, nullptr) << error_msg;
+    DCHECK_GE(oat_file.Begin(), elf_begin);
+    oat_offset_ = reinterpret_cast<size_t>(oat_file.Begin()) - reinterpret_cast<size_t>(elf_begin);
+
+    disassembler_ = Disassembler::Create(
+        instruction_set_,
+        new DisassemblerOptions(options_.absolute_addresses_,
+                                elf_begin,
+                                oat_file.End(),
+                                /* can_read_literals_= */ true,
+                                Is64BitInstructionSet(instruction_set_) ?
+                                    &Thread::DumpThreadOffset<PointerSize::k64> :
+                                    &Thread::DumpThreadOffset<PointerSize::k32>));
+
     AddAllOffsets();
   }
 
@@ -453,13 +461,13 @@ class OatDumper {
     os << "DEX FILE COUNT:\n";
     os << oat_header.GetDexFileCount() << "\n\n";
 
-#define DUMP_OAT_HEADER_OFFSET(label, offset) \
-    os << label " OFFSET:\n"; \
-    os << StringPrintf("0x%08x", oat_header.offset()); \
-    if (oat_header.offset() != 0 && options_.absolute_addresses_) { \
-      os << StringPrintf(" (%p)", oat_file_.Begin() + oat_header.offset()); \
-    } \
-    os << StringPrintf("\n\n");
+#define DUMP_OAT_HEADER_OFFSET(label, offset)                             \
+  os << label " OFFSET:\n";                                               \
+  os << StringPrintf("0x%08zx", AdjustOffset(oat_header.offset()));       \
+  if (oat_header.offset() != 0 && options_.absolute_addresses_) {         \
+    os << StringPrintf(" (%p)", oat_file_.Begin() + oat_header.offset()); \
+  }                                                                       \
+  os << StringPrintf("\n\n");
 
     DUMP_OAT_HEADER_OFFSET("EXECUTABLE", GetExecutableOffset);
     DUMP_OAT_HEADER_OFFSET("JNI DLSYM LOOKUP TRAMPOLINE",
@@ -508,7 +516,7 @@ class OatDumper {
     if (options_.addr2instr_ != 0) {
       resolved_addr2instr_ = options_.addr2instr_ + oat_header.GetExecutableOffset();
       os << "SEARCH ADDRESS (executable offset + input):\n";
-      os << StringPrintf("0x%08x\n\n", resolved_addr2instr_);
+      os << StringPrintf("0x%08zx\n\n", AdjustOffset(resolved_addr2instr_));
     }
 
     // Dump .data.img.rel.ro entries.
@@ -713,8 +721,9 @@ class OatDumper {
 
           std::string pretty_method = dex_file->PrettyMethod(dex_method_idx, true);
 
-          os << StringPrintf(
-              "{\"method\":\"%s\",\"offset\":\"0x%08x\"}\n", pretty_method.c_str(), code_offset);
+          os << StringPrintf("{\"method\":\"%s\",\"offset\":\"0x%08zx\"}\n",
+                             pretty_method.c_str(),
+                             AdjustOffset(code_offset));
         }
       }
     }
@@ -932,13 +941,12 @@ class OatDumper {
       const uint16_t class_def_index = accessor.GetClassDefIndex();
       uint32_t oat_class_offset = oat_dex_file.GetOatClassOffset(class_def_index);
       const OatFile::OatClass oat_class = oat_dex_file.GetOatClass(class_def_index);
-      os << StringPrintf("%zd: %s (offset=0x%08x) (type_idx=%d)",
+      os << StringPrintf("%zd: %s (offset=0x%08zx) (type_idx=%d)",
                          static_cast<ssize_t>(class_def_index),
                          descriptor,
-                         oat_class_offset,
+                         AdjustOffset(oat_class_offset),
                          accessor.GetClassIdx().index_)
-         << " (" << oat_class.GetStatus() << ")"
-         << " (" << oat_class.GetType() << ")\n";
+         << " (" << oat_class.GetStatus() << ")" << " (" << oat_class.GetType() << ")\n";
       // TODO: include bitmap here if type is kOatClassSomeCompiled?
       if (options_.list_classes_) {
         continue;
@@ -1186,23 +1194,25 @@ class OatDumper {
       if (options_.absolute_addresses_) {
         vios->Stream() << StringPrintf("%p ", oat_method_offsets);
       }
-      vios->Stream() << StringPrintf("(offset=0x%08x)\n", oat_method_offsets_offset);
+      vios->Stream() << StringPrintf("(offset=0x%08zx)\n", AdjustOffset(oat_method_offsets_offset));
       if (oat_method_offsets_offset > oat_file_.Size()) {
         vios->Stream() << StringPrintf(
-            "WARNING: oat method offsets offset 0x%08x is past end of file 0x%08zx.\n",
-            oat_method_offsets_offset, oat_file_.Size());
+            "WARNING: oat method offsets offset 0x%08zx is past end of file 0x%08zx.\n",
+            AdjustOffset(oat_method_offsets_offset),
+            AdjustOffset(oat_file_.Size()));
         // If we can't read OatMethodOffsets, the rest of the data is dangerous to read.
         vios->Stream() << std::flush;
         return false;
       }
 
       ScopedIndentation indent2(vios);
-      vios->Stream() << StringPrintf("code_offset: 0x%08x ", code_offset);
+      vios->Stream() << StringPrintf("code_offset: 0x%08zx ", AdjustOffset(code_offset));
       uint32_t aligned_code_begin = AlignCodeOffset(oat_method.GetCodeOffset());
       if (aligned_code_begin > oat_file_.Size()) {
-        vios->Stream() << StringPrintf("WARNING: "
-                                       "code offset 0x%08x is past end of file 0x%08zx.\n",
-                                       aligned_code_begin, oat_file_.Size());
+        vios->Stream() << StringPrintf(
+            "WARNING: code offset 0x%08zx is past end of file 0x%08zx.\n",
+            AdjustOffset(aligned_code_begin),
+            AdjustOffset(oat_file_.Size()));
         success = false;
       }
       vios->Stream() << "\n";
@@ -1211,18 +1221,19 @@ class OatDumper {
       vios->Stream() << "OatQuickMethodHeader ";
       uint32_t method_header_offset = oat_method.GetOatQuickMethodHeaderOffset();
       const OatQuickMethodHeader* method_header = oat_method.GetOatQuickMethodHeader();
-      if (AddStatsObject(method_header)) {
+      if (method_header != nullptr && AddStatsObject(method_header)) {
         stats_["QuickMethodHeader"].AddBytes(sizeof(*method_header));
       }
       if (options_.absolute_addresses_) {
         vios->Stream() << StringPrintf("%p ", method_header);
       }
-      vios->Stream() << StringPrintf("(offset=0x%08x)\n", method_header_offset);
+      vios->Stream() << StringPrintf("(offset=0x%08zx)\n", AdjustOffset(method_header_offset));
       if (method_header_offset > oat_file_.Size() ||
           sizeof(OatQuickMethodHeader) > oat_file_.Size() - method_header_offset) {
         vios->Stream() << StringPrintf(
-            "WARNING: oat quick method header at offset 0x%08x is past end of file 0x%08zx.\n",
-            method_header_offset, oat_file_.Size());
+            "WARNING: oat quick method header at offset 0x%08zx is past end of file 0x%08zx.\n",
+            AdjustOffset(method_header_offset),
+            AdjustOffset(oat_file_.Size()));
         // If we can't read the OatQuickMethodHeader, the rest of the data is dangerous to read.
         vios->Stream() << std::flush;
         return false;
@@ -1235,14 +1246,15 @@ class OatDumper {
       }
       uint32_t vmap_table_offset =
           (method_header == nullptr) ? 0 : method_header->GetCodeInfoOffset();
-      vios->Stream() << StringPrintf("(offset=0x%08x)\n", vmap_table_offset);
-
-      size_t vmap_table_offset_limit = method_header->GetCode() - oat_file_.Begin();
-      if (vmap_table_offset >= vmap_table_offset_limit) {
-        vios->Stream() << StringPrintf("WARNING: "
-                                       "vmap table offset 0x%08x is past end of file 0x%08zx. ",
-                                       vmap_table_offset,
-                                       vmap_table_offset_limit);
+      vios->Stream() << StringPrintf("(offset=0x%08zx)\n", AdjustOffset(vmap_table_offset));
+
+      size_t vmap_table_offset_limit =
+          (method_header == nullptr) ? 0 : (method_header->GetCode() - oat_file_.Begin());
+      if (method_header != nullptr && vmap_table_offset >= vmap_table_offset_limit) {
+        vios->Stream() << StringPrintf(
+            "WARNING: vmap table offset 0x%08zx is past end of file 0x%08zx. ",
+            AdjustOffset(vmap_table_offset),
+            AdjustOffset(vmap_table_offset_limit));
         success = false;
       } else if (options_.dump_vmap_) {
         DumpVmapData(vios, oat_method, code_item_accessor);
@@ -1273,7 +1285,7 @@ class OatDumper {
       {
         const void* code = oat_method.GetQuickCode();
         uint32_t aligned_code_begin = AlignCodeOffset(code_offset);
-        uint64_t aligned_code_end = aligned_code_begin + code_size;
+        uint32_t aligned_code_end = aligned_code_begin + code_size;
         if (AddStatsObject(code)) {
           stats_["Code"].AddBytes(code_size);
         }
@@ -1281,24 +1293,23 @@ class OatDumper {
         if (options_.absolute_addresses_) {
           vios->Stream() << StringPrintf("%p ", code);
         }
-        vios->Stream() << StringPrintf("(code_offset=0x%08x size=%u)%s\n",
-                                       code_offset,
+        vios->Stream() << StringPrintf("(code_offset=0x%08zx size=%u)%s\n",
+                                       AdjustOffset(code_offset),
                                        code_size,
                                        code != nullptr ? "..." : "");
 
         ScopedIndentation indent2(vios);
         if (aligned_code_begin > oat_file_.Size()) {
-          vios->Stream() << StringPrintf("WARNING: "
-                                         "start of code at 0x%08x is past end of file 0x%08zx.",
-                                         aligned_code_begin, oat_file_.Size());
+          vios->Stream() << StringPrintf(
+              "WARNING: start of code at 0x%08zx is past end of file 0x%08zx.",
+              AdjustOffset(aligned_code_begin),
+              AdjustOffset(oat_file_.Size()));
           success = false;
         } else if (aligned_code_end > oat_file_.Size()) {
           vios->Stream() << StringPrintf(
-              "WARNING: "
-              "end of code at 0x%08" PRIx64 " is past end of file 0x%08zx. "
-              "code size is 0x%08x.\n",
-              aligned_code_end,
-              oat_file_.Size(),
+              "WARNING: end of code at 0x%08zx is past end of file 0x%08zx. code size is 0x%08x.\n",
+              AdjustOffset(aligned_code_end),
+              AdjustOffset(oat_file_.Size()),
               code_size);
           success = false;
           if (options_.disassemble_code_) {
@@ -1764,7 +1775,11 @@ class OatDumper {
     // the mask bits would allow reconstructing the other indexes.
   }
 
+  // Adjusts an offset relative to the OAT file begin to an offset relative to the ELF file begin.
+  size_t AdjustOffset(size_t offset) const { return (offset > 0) ? (oat_offset_ + offset) : 0; }
+
   const OatFile& oat_file_;
+  size_t oat_offset_;
   const std::vector<const OatDexFile*> oat_dex_files_;
   const OatDumperOptions& options_;
   uint32_t resolved_addr2instr_;
diff --git a/odrefresh/Android.bp b/odrefresh/Android.bp
index 15c6a7b3c8..53e5f90fa6 100644
--- a/odrefresh/Android.bp
+++ b/odrefresh/Android.bp
@@ -32,28 +32,28 @@ cc_defaults {
         "odr_compilation_log.cc",
         "odr_fs_utils.cc",
         "odr_metrics.cc",
-        "odr_metrics_record.cc",
     ],
     local_include_dirs: ["include"],
     header_libs: ["dexoptanalyzer_headers"],
     generated_sources: [
-        "apex-info-list-tinyxml",
-        "art-apex-cache-info",
         "art-odrefresh-operator-srcs",
     ],
     shared_libs: [
         "liblog",
-        "libselinux",
     ],
     static_libs: [
         "libmodules-utils-build",
     ],
     tidy: true,
-    tidy_disabled_srcs: [":art-apex-cache-info"],
     tidy_flags: [
         "-format-style=file",
         "-header-filter=(art/odrefresh/|system/apex/)",
     ],
+    target: {
+        android: {
+            compile_multilib: "first",
+        },
+    },
 }
 
 cc_defaults {
@@ -62,17 +62,21 @@ cc_defaults {
         "art_defaults",
         "odrefresh-defaults",
     ],
-    srcs: ["odrefresh_main.cc"],
+    srcs: [
+        "odr_metrics_record.cc",
+        "odrefresh_main.cc",
+    ],
+    generated_sources: [
+        "apex-info-list-tinyxml",
+        "art-apex-cache-info",
+    ],
+    tidy_disabled_srcs: [":art-apex-cache-info"],
     shared_libs: [
         "libarttools",
         "libbase",
         "libdexfile",
+        "libselinux",
     ],
-    target: {
-        android: {
-            compile_multilib: "first",
-        },
-    },
 }
 
 cc_defaults {
@@ -217,6 +221,10 @@ art_cc_defaults {
         "odr_metrics_record_test.cc",
         "odrefresh_test.cc",
     ],
+    generated_headers: [
+        "apex-info-list-tinyxml",
+        "art-apex-cache-info",
+    ],
     static_libs: [
         "libgmock",
     ],
@@ -254,6 +262,7 @@ art_cc_test {
         "libarttools",
         "libbase",
     ],
+    test_config_template: ":art-gtests-target-standalone-non-multilib-template",
 }
 
 genrule {
diff --git a/odrefresh/odr_config.h b/odrefresh/odr_config.h
index 20eca87898..eb819ee29d 100644
--- a/odrefresh/odr_config.h
+++ b/odrefresh/odr_config.h
@@ -104,6 +104,12 @@ class OdrSystemProperties : public tools::SystemProperties {
   auto begin() const { return system_properties_->begin(); }
   auto end() const { return system_properties_->end(); }
 
+  // Return a given property's value if it exists in the map.
+  std::optional<std::string> GetOrNull(const std::string& key) const {
+    auto it = system_properties_->find(key);
+    return it != system_properties_->end() ? std::make_optional(it->second) : std::nullopt;
+  }
+
  protected:
   std::string GetProperty(const std::string& key) const override {
     auto it = system_properties_->find(key);
diff --git a/odrefresh/odr_metrics_record.h b/odrefresh/odr_metrics_record.h
index 4b18edb6d6..47db41978a 100644
--- a/odrefresh/odr_metrics_record.h
+++ b/odrefresh/odr_metrics_record.h
@@ -34,7 +34,8 @@ constexpr const char* kOdrefreshMetricsFile = "/data/misc/odrefresh/odrefresh-me
 static constexpr int32_t kOdrefreshMetricsVersion = 4;
 
 // Constant value used in ExecResult when the process was not run at all.
-// Mirrors EXEC_RESULT_STATUS_NOT_RUN contained in frameworks/proto_logging/atoms.proto.
+// Mirrors EXEC_RESULT_STATUS_NOT_RUN contained in
+// frameworks/proto_logging/stats/enums/art/common_enums.proto.
 static constexpr int32_t kExecResultNotRun = 5;
 static_assert(kExecResultNotRun > ExecResult::Status::kLast,
               "`art::odrefresh::kExecResultNotRun` value should not overlap with"
diff --git a/odrefresh/odrefresh.cc b/odrefresh/odrefresh.cc
index 6a09a88a4e..f0b8b44d23 100644
--- a/odrefresh/odrefresh.cc
+++ b/odrefresh/odrefresh.cc
@@ -85,8 +85,6 @@
 #include "odr_fs_utils.h"
 #include "odr_metrics.h"
 #include "odrefresh/odrefresh.h"
-#include "selinux/android.h"
-#include "selinux/selinux.h"
 #include "tools/cmdline_builder.h"
 
 namespace art {
@@ -145,7 +143,8 @@ void EraseFiles(const std::vector<std::unique_ptr<File>>& files) {
 //
 // Returns true if all files are moved, false otherwise.
 bool MoveOrEraseFiles(const std::vector<std::unique_ptr<File>>& files,
-                      std::string_view output_directory_path) {
+                      std::string_view output_directory_path,
+                      android::base::function_ref<int(const char*, unsigned int)> restorecon) {
   std::vector<std::unique_ptr<File>> output_files;
   for (auto& file : files) {
     std::string file_basename(Basename(file->GetPath()));
@@ -168,7 +167,7 @@ bool MoveOrEraseFiles(const std::vector<std::unique_ptr<File>>& files,
         return false;
       }
 
-      if (selinux_android_restorecon(output_file_path.c_str(), 0) < 0) {
+      if (restorecon(output_file_path.c_str(), 0) < 0) {
         LOG(ERROR) << "Failed to set security context for file " << QuotePath(output_file_path);
         EraseFiles(files);
         return false;
@@ -396,7 +395,7 @@ bool ArtifactsExist(const OdrArtifacts& artifacts,
 
 void AddDex2OatCommonOptions(/*inout*/ CmdlineBuilder& args) {
   args.Add("--android-root=out/empty");
-  args.Add("--abort-on-hard-verifier-error");
+  args.Add("--no-abort-on-hard-verifier-error");
   args.Add("--no-abort-on-soft-verifier-error");
   args.Add("--compilation-reason=boot");
   args.Add("--image-format=lz4");
@@ -683,25 +682,31 @@ int CompilationOptions::CompilationUnitCount() const {
   return count;
 }
 
-OnDeviceRefresh::OnDeviceRefresh(const OdrConfig& config)
+OnDeviceRefresh::OnDeviceRefresh(
+    const OdrConfig& config,
+    android::base::function_ref<int(const char*, const char*)> setfilecon,
+    android::base::function_ref<int(const char*, unsigned int)> restorecon)
     : OnDeviceRefresh(config,
+                      setfilecon,
+                      restorecon,
                       config.GetArtifactDirectory() + "/" + kCacheInfoFile,
                       std::make_unique<ExecUtils>(),
-                      CheckCompilationSpace,
-                      setfilecon) {}
+                      CheckCompilationSpace) {}
 
 OnDeviceRefresh::OnDeviceRefresh(
     const OdrConfig& config,
+    android::base::function_ref<int(const char*, const char*)> setfilecon,
+    android::base::function_ref<int(const char*, unsigned int)> restorecon,
     const std::string& cache_info_filename,
     std::unique_ptr<ExecUtils> exec_utils,
-    android::base::function_ref<bool()> check_compilation_space,
-    android::base::function_ref<int(const char*, const char*)> setfilecon)
+    android::base::function_ref<bool()> check_compilation_space)
     : config_(config),
       cache_info_filename_(cache_info_filename),
       start_time_(time(nullptr)),
       exec_utils_(std::move(exec_utils)),
       check_compilation_space_(check_compilation_space),
-      setfilecon_(setfilecon) {
+      setfilecon_(setfilecon),
+      restorecon_(restorecon) {
   // Updatable APEXes should not have DEX files in the DEX2OATBOOTCLASSPATH. At the time of
   // writing i18n is a non-updatable APEX and so does appear in the DEX2OATBOOTCLASSPATH.
   dex2oat_boot_classpath_jars_ = Split(config_.GetDex2oatBootClasspath(), ":");
@@ -1097,12 +1102,15 @@ WARN_UNUSED bool OnDeviceRefresh::CheckSystemPropertiesAreDefault() const {
   const OdrSystemProperties& system_properties = config_.GetSystemProperties();
 
   for (const SystemPropertyConfig& system_property_config : *kSystemProperties.get()) {
-    std::string property = system_properties.GetOrEmpty(system_property_config.name);
-    DCHECK_NE(property, "");
+    // Note that the `kSystemPropertySystemServerCompilerFilterOverride` property has an empty
+    // default value, so we use the `GetOrNull` method and check against nullopt
+    std::optional<std::string> property = system_properties.GetOrNull(system_property_config.name);
+    DCHECK(property.has_value()) << "Property " << system_property_config.name
+                                 << " does not exist in system properties map!";
 
-    if (property != system_property_config.default_value) {
+    if (*property != system_property_config.default_value) {
       LOG(INFO) << "System property " << system_property_config.name << " has a non-default value ("
-                << property << ").";
+                << *property << ").";
       return false;
     }
   }
@@ -1825,7 +1833,7 @@ WARN_UNUSED CompilationResult OnDeviceRefresh::RunDex2oat(
                                         ART_FORMAT("Failed to flush file '{}'", file->GetPath()));
       }
     }
-    if (!MoveOrEraseFiles(output_files, install_location)) {
+    if (!MoveOrEraseFiles(output_files, install_location, restorecon_)) {
       return CompilationResult::Error(
           OdrMetrics::Status::kIoError,
           ART_FORMAT("Failed to commit artifacts to '{}'", install_location));
@@ -1872,22 +1880,24 @@ OnDeviceRefresh::RunDex2oatForBootClasspath(const std::string& staging_dir,
 
     args.Add(StringPrintf("--base=0x%08x", ART_BASE_ADDRESS));
 
-    std::string dirty_image_objects_file(GetAndroidRoot() + "/etc/dirty-image-objects");
-    std::unique_ptr<File> file(OS::OpenFileForReading(dirty_image_objects_file.c_str()));
-    if (file != nullptr) {
-      args.Add("--dirty-image-objects-fd=%d", file->Fd());
-      readonly_files_raii.push_back(std::move(file));
-    } else if (errno == ENOENT) {
-      LOG(WARNING) << ART_FORMAT("Missing dirty objects file '{}'", dirty_image_objects_file);
-    } else {
-      return CompilationResult::Error(OdrMetrics::Status::kIoError,
-                                      ART_FORMAT("Failed to open dirty objects file '{}': {}",
-                                                 dirty_image_objects_file,
-                                                 strerror(errno)));
+    for (const std::string& prefix : {GetAndroidRoot(), GetArtRoot()}) {
+      std::string dirty_image_objects_file = prefix + "/etc/dirty-image-objects";
+      std::unique_ptr<File> file(OS::OpenFileForReading(dirty_image_objects_file.c_str()));
+      if (file != nullptr) {
+        args.Add("--dirty-image-objects-fd=%d", file->Fd());
+        readonly_files_raii.push_back(std::move(file));
+      } else if (errno == ENOENT) {
+        LOG(WARNING) << ART_FORMAT("Missing dirty objects file '{}'", dirty_image_objects_file);
+      } else {
+        return CompilationResult::Error(OdrMetrics::Status::kIoError,
+                                        ART_FORMAT("Failed to open dirty objects file '{}': {}",
+                                                   dirty_image_objects_file,
+                                                   strerror(errno)));
+      }
     }
 
     std::string preloaded_classes_file(GetAndroidRoot() + "/etc/preloaded-classes");
-    file.reset(OS::OpenFileForReading(preloaded_classes_file.c_str()));
+    std::unique_ptr<File> file(OS::OpenFileForReading(preloaded_classes_file.c_str()));
     if (file != nullptr) {
       args.Add("--preloaded-classes-fds=%d", file->Fd());
       readonly_files_raii.push_back(std::move(file));
diff --git a/odrefresh/odrefresh.h b/odrefresh/odrefresh.h
index 3031b1b554..301ef64157 100644
--- a/odrefresh/odrefresh.h
+++ b/odrefresh/odrefresh.h
@@ -158,14 +158,19 @@ class PreconditionCheckResult {
 
 class OnDeviceRefresh final {
  public:
-  explicit OnDeviceRefresh(const OdrConfig& config);
+  explicit OnDeviceRefresh(
+      const OdrConfig& config,
+      android::base::function_ref<int(const char*, const char*)> setfilecon,
+      android::base::function_ref<int(const char*, unsigned int)> restorecon);
 
   // Constructor with injections. For testing and internal use only.
-  OnDeviceRefresh(const OdrConfig& config,
-                  const std::string& cache_info_filename,
-                  std::unique_ptr<ExecUtils> exec_utils,
-                  android::base::function_ref<bool()> check_compilation_space,
-                  android::base::function_ref<int(const char*, const char*)> setfilecon);
+  OnDeviceRefresh(
+      const OdrConfig& config,
+      android::base::function_ref<int(const char*, const char*)> setfilecon,
+      android::base::function_ref<int(const char*, unsigned int)> restorecon,
+      const std::string& cache_info_filename,
+      std::unique_ptr<ExecUtils> exec_utils,
+      android::base::function_ref<bool()> check_compilation_space);
 
   // Returns the exit code and specifies what should be compiled in `compilation_options`.
   WARN_UNUSED ExitCode
@@ -388,6 +393,7 @@ class OnDeviceRefresh final {
 
   android::base::function_ref<bool()> check_compilation_space_;
   android::base::function_ref<int(const char*, const char*)> setfilecon_;
+  android::base::function_ref<int(const char*, unsigned int)> restorecon_;
 
   DISALLOW_COPY_AND_ASSIGN(OnDeviceRefresh);
 };
diff --git a/odrefresh/odrefresh_main.cc b/odrefresh/odrefresh_main.cc
index 2d3009e25c..22551f96f1 100644
--- a/odrefresh/odrefresh_main.cc
+++ b/odrefresh/odrefresh_main.cc
@@ -35,6 +35,8 @@
 #include "odr_metrics.h"
 #include "odrefresh.h"
 #include "odrefresh/odrefresh.h"
+#include "selinux/android.h"
+#include "selinux/selinux.h"
 
 namespace {
 
@@ -278,7 +280,7 @@ int main(int argc, char** argv) {
   GetSystemProperties(config.MutableSystemProperties());
 
   OdrMetrics metrics(config.GetArtifactDirectory());
-  OnDeviceRefresh odr(config);
+  OnDeviceRefresh odr(config, setfilecon, selinux_android_restorecon);
 
   std::string_view action(argv[0]);
   CompilationOptions compilation_options;
diff --git a/odrefresh/odrefresh_test.cc b/odrefresh/odrefresh_test.cc
index 424b606ff8..b19a4225b4 100644
--- a/odrefresh/odrefresh_test.cc
+++ b/odrefresh/odrefresh_test.cc
@@ -177,9 +177,9 @@ class OdRefreshTest : public CommonArtTest {
     CreateEmptyFile(dirty_image_objects_file_);
     preloaded_classes_file_ = system_etc_dir + "/preloaded-classes";
     CreateEmptyFile(preloaded_classes_file_);
-    std::string art_etc_dir = android_art_root_path + "/etc";
-    ASSERT_TRUE(EnsureDirectoryExists(art_etc_dir));
-    art_profile_ = art_etc_dir + "/boot-image.prof";
+    art_etc_dir_ = android_art_root_path + "/etc";
+    ASSERT_TRUE(EnsureDirectoryExists(art_etc_dir_));
+    art_profile_ = art_etc_dir_ + "/boot-image.prof";
     CreateEmptyFile(art_profile_);
 
     framework_dir_ = android_root_path + "/framework";
@@ -233,11 +233,13 @@ class OdRefreshTest : public CommonArtTest {
     cache_info_xml_ = dalvik_cache_dir_ + "/cache-info.xml";
     check_compilation_space_ = [] { return true; };
     setfilecon_ = [](auto, auto) { return 0; };
+    restorecon_ = [](auto, auto) { return 0; };
     odrefresh_ = std::make_unique<OnDeviceRefresh>(config_,
+                                                   setfilecon_,
+                                                   restorecon_,
                                                    cache_info_xml_,
                                                    std::move(mock_exec_utils),
-                                                   check_compilation_space_,
-                                                   setfilecon_);
+                                                   check_compilation_space_);
   }
 
   void TearDown() override {
@@ -267,6 +269,7 @@ class OdRefreshTest : public CommonArtTest {
   std::string services_foo_jar_;
   std::string services_bar_jar_;
   std::string dalvik_cache_dir_;
+  std::string art_etc_dir_;
   std::string framework_dir_;
   std::string framework_profile_;
   std::string art_profile_;
@@ -276,6 +279,7 @@ class OdRefreshTest : public CommonArtTest {
   std::string cache_info_xml_;
   std::function<bool()> check_compilation_space_;
   std::function<int(const char*, const char*)> setfilecon_;
+  std::function<int(const char*, unsigned int)> restorecon_;
 };
 
 TEST_F(OdRefreshTest, PrimaryBootImage) {
@@ -1011,5 +1015,55 @@ TEST_F(OdRefreshTest, OnlyBootImages) {
             ExitCode::kCompilationSuccess);
 }
 
+TEST_F(OdRefreshTest, DirtyImageObjects) {
+  // Primary.
+  EXPECT_CALL(*mock_exec_utils_,
+              DoExecAndReturnCode(AllOf(
+                  Contains(Flag("--dirty-image-objects-fd=", FdOf(dirty_image_objects_file_))),
+                  Contains(Flag("--dex-file=", core_oj_jar_)))))
+      .WillOnce(Return(0));
+
+  // Mainline extension.
+  EXPECT_CALL(*mock_exec_utils_,
+              DoExecAndReturnCode(AllOf(Contains(Flag("--dex-file=", conscrypt_jar_)))))
+      .WillOnce(Return(0));
+
+  EXPECT_EQ(odrefresh_->Compile(
+                *metrics_,
+                CompilationOptions{
+                    .boot_images_to_generate_for_isas{
+                        {InstructionSet::kX86_64,
+                         {.primary_boot_image = true, .boot_image_mainline_extension = true}}},
+                }),
+            ExitCode::kCompilationSuccess);
+}
+
+TEST_F(OdRefreshTest, DirtyImageObjectsMultipleFiles) {
+  std::string art_dirty_image_objects = art_etc_dir_ + "/dirty-image-objects";
+  auto file = ScopedCreateEmptyFile(art_dirty_image_objects);
+
+  // Primary.
+  EXPECT_CALL(*mock_exec_utils_,
+              DoExecAndReturnCode(AllOf(
+                  Contains(Flag("--dirty-image-objects-fd=", FdOf(dirty_image_objects_file_))),
+                  Contains(Flag("--dirty-image-objects-fd=", FdOf(art_dirty_image_objects))),
+                  Contains(Flag("--dex-file=", core_oj_jar_)))))
+      .WillOnce(Return(0));
+
+  // Mainline extension.
+  EXPECT_CALL(*mock_exec_utils_,
+              DoExecAndReturnCode(AllOf(Contains(Flag("--dex-file=", conscrypt_jar_)))))
+      .WillOnce(Return(0));
+
+  EXPECT_EQ(odrefresh_->Compile(
+                *metrics_,
+                CompilationOptions{
+                    .boot_images_to_generate_for_isas{
+                        {InstructionSet::kX86_64,
+                         {.primary_boot_image = true, .boot_image_mainline_extension = true}}},
+                }),
+            ExitCode::kCompilationSuccess);
+}
+
 }  // namespace odrefresh
 }  // namespace art
diff --git a/openjdkjvmti/ti_redefine.cc b/openjdkjvmti/ti_redefine.cc
index 3d0c05734c..0ba528a0a7 100644
--- a/openjdkjvmti/ti_redefine.cc
+++ b/openjdkjvmti/ti_redefine.cc
@@ -2031,13 +2031,14 @@ uint32_t Redefiner::ClassRedefinition::GetNewClassSize(art::ClassAccessor& acces
     }
   }
 
-  return art::mirror::Class::ComputeClassSize(/*has_embedded_vtable=*/ false,
-                                              /*num_vtable_entries=*/ 0,
+  return art::mirror::Class::ComputeClassSize(/*has_embedded_vtable=*/false,
+                                              /*num_vtable_entries=*/0,
                                               num_8bit_static_fields,
                                               num_16bit_static_fields,
                                               num_32bit_static_fields,
                                               num_64bit_static_fields,
                                               num_ref_static_fields,
+                                              /*num_ref_bitmap_entries=*/0,
                                               art::kRuntimePointerSize);
 }
 
diff --git a/perfetto_hprof/perfetto_hprof.cc b/perfetto_hprof/perfetto_hprof.cc
index d79394ba2f..07eb4c60f4 100644
--- a/perfetto_hprof/perfetto_hprof.cc
+++ b/perfetto_hprof/perfetto_hprof.cc
@@ -257,7 +257,7 @@ class JavaHprofDataSource : public perfetto::DataSource<JavaHprofDataSource> {
       return;
     }
     is_stopped_ = true;
-    async_stop_ = std::move(a.HandleStopAsynchronously());
+    async_stop_ = a.HandleStopAsynchronously();
   }
 
   static art::Thread* art_thread() {
diff --git a/profman/Android.bp b/profman/Android.bp
index df8c55fd18..948b6fd23d 100644
--- a/profman/Android.bp
+++ b/profman/Android.bp
@@ -32,6 +32,7 @@ cc_defaults {
         "boot_image_profile.cc",
         "profman.cc",
         "profile_assistant.cc",
+        "inline_cache_format_util.cc",
     ],
     header_libs: ["profman_headers"],
 
diff --git a/profman/boot_image_profile.cc b/profman/boot_image_profile.cc
index fc20f20a65..9c46786df2 100644
--- a/profman/boot_image_profile.cc
+++ b/profman/boot_image_profile.cc
@@ -20,13 +20,13 @@
 #include <set>
 
 #include "android-base/file.h"
-#include "base/unix_file/fd_file.h"
 #include "dex/class_accessor-inl.h"
 #include "dex/descriptors_names.h"
 #include "dex/dex_file-inl.h"
 #include "dex/method_reference.h"
 #include "dex/type_reference.h"
 #include "profile/profile_compilation_info.h"
+#include "inline_cache_format_util.h"
 
 namespace art {
 
@@ -100,7 +100,8 @@ static std::string MethodToProfileFormat(
     extra = kPackageUseDelim + GetPackageUseString(metadata);
   }
 
-  return flags_string + method + extra;
+  std::string inline_cache_string = GetInlineCacheLine(metadata.GetInlineCache());
+  return flags_string + method + extra + inline_cache_string;
 }
 
 // Converts a class representation to its final profile or preloaded classes format.
diff --git a/profman/inline_cache_format_util.cc b/profman/inline_cache_format_util.cc
new file mode 100644
index 0000000000..24ed8a09cd
--- /dev/null
+++ b/profman/inline_cache_format_util.cc
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "inline_cache_format_util.h"
+
+#include "profile/profile_compilation_info.h"
+
+namespace art {
+
+std::string GetInlineCacheLine(const SafeMap<TypeReference,
+                                             FlattenProfileData::ItemMetadata::InlineCacheInfo,
+                                             TypeReferenceValueComparator>& inline_cache) {
+  if (inline_cache.empty()) {
+    return "";
+  }
+  std::ostringstream dump_ic;
+  dump_ic << kProfileParsingInlineChacheSep;
+  for (const auto& [target_ref, inline_cache_data] : inline_cache) {
+    dump_ic << kProfileParsingInlineChacheTargetSep;
+    dump_ic << target_ref.dex_file->GetTypeDescriptor(
+        target_ref.dex_file->GetTypeId(target_ref.TypeIndex()));
+    if (inline_cache_data.is_missing_types_) {
+      dump_ic << kMissingTypesMarker;
+    } else if (inline_cache_data.is_megamorphic_) {
+      dump_ic << kMegamorphicTypesMarker;
+    } else {
+      bool first = true;
+      for (const std::string& cls : inline_cache_data.classes_) {
+        if (!first) {
+          dump_ic << kProfileParsingTypeSep;
+        }
+        first = false;
+        dump_ic << cls;
+      }
+    }
+  }
+  return dump_ic.str();
+}
+
+}  // namespace art
diff --git a/profman/inline_cache_format_util.h b/profman/inline_cache_format_util.h
new file mode 100644
index 0000000000..ef3d4742f6
--- /dev/null
+++ b/profman/inline_cache_format_util.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_PROFMAN_INLINE_CACHE_FORMAT_UTIL_H_
+#define ART_PROFMAN_INLINE_CACHE_FORMAT_UTIL_H_
+
+#include "profile/profile_compilation_info.h"
+
+namespace art {
+
+constexpr char kProfileParsingInlineChacheSep = '+';
+constexpr char kProfileParsingInlineChacheTargetSep = ']';
+constexpr char kMissingTypesMarker[] = "missing_types";
+constexpr char kMegamorphicTypesMarker[] = "megamorphic_types";
+constexpr char kProfileParsingTypeSep = ',';
+
+// Creates the inline-cache portion of a text-profile line. If there is no
+// inline-caches this will be an empty string. Otherwise it will be '@'
+// followed by an IC description matching the format described by
+// Profman::ProcessLine.
+std::string GetInlineCacheLine(const SafeMap<TypeReference,
+                                             FlattenProfileData::ItemMetadata::InlineCacheInfo,
+                                             TypeReferenceValueComparator>& inline_cache);
+
+}  // namespace art
+
+#endif  // ART_PROFMAN_INLINE_CACHE_FORMAT_UTIL_H_
diff --git a/profman/profile_assistant_test.cc b/profman/profile_assistant_test.cc
index 2a8dc84a85..1e056f119d 100644
--- a/profman/profile_assistant_test.cc
+++ b/profman/profile_assistant_test.cc
@@ -172,7 +172,7 @@ class ProfileAssistantTest : public CommonRuntimeTest, public ProfileTestHelper
   int ProcessProfiles(
       const std::vector<int>& profiles_fd,
       int reference_profile_fd,
-      const std::vector<const std::string>& extra_args = std::vector<const std::string>()) {
+      const std::vector<std::string>& extra_args = std::vector<std::string>()) {
     std::string profman_cmd = GetProfmanCmd();
     std::vector<std::string> argv_str;
     argv_str.push_back(profman_cmd);
@@ -416,8 +416,8 @@ class ProfileAssistantTest : public CommonRuntimeTest, public ProfileTestHelper
 
   int CheckCompilationMethodPercentChange(uint16_t methods_in_cur_profile,
                                           uint16_t methods_in_ref_profile,
-                                          const std::vector<const std::string>& extra_args =
-                                              std::vector<const std::string>()) {
+                                          const std::vector<std::string>& extra_args =
+                                              std::vector<std::string>()) {
     ScratchFile profile;
     ScratchFile reference_profile;
     std::vector<int> profile_fds({ GetFd(profile)});
@@ -442,8 +442,8 @@ class ProfileAssistantTest : public CommonRuntimeTest, public ProfileTestHelper
 
   int CheckCompilationClassPercentChange(uint16_t classes_in_cur_profile,
                                          uint16_t classes_in_ref_profile,
-                                         const std::vector<const std::string>& extra_args =
-                                             std::vector<const std::string>()) {
+                                         const std::vector<std::string>& extra_args =
+                                             std::vector<std::string>()) {
     uint16_t max_classes = std::max(classes_in_cur_profile, classes_in_ref_profile);
     const DexFile* dex1_x = BuildDex("location1_x",
                                      /*location_checksum=*/ 0x101,
@@ -666,7 +666,7 @@ TEST_F(ProfileAssistantTest, DoNotAdviseCompilation) {
 TEST_F(ProfileAssistantTest, DoNotAdviseCompilationMethodPercentage) {
   const uint16_t kNumberOfMethodsInRefProfile = 6000;
   const uint16_t kNumberOfMethodsInCurProfile = 6100;  // Threshold is 2%.
-  std::vector<const std::string> extra_args({"--min-new-methods-percent-change=2"});
+  std::vector<std::string> extra_args({"--min-new-methods-percent-change=2"});
 
   // We should not advise compilation.
   ASSERT_EQ(ProfmanResult::kSkipCompilationSmallDelta,
@@ -677,7 +677,7 @@ TEST_F(ProfileAssistantTest, DoNotAdviseCompilationMethodPercentage) {
 TEST_F(ProfileAssistantTest, ShouldAdviseCompilationMethodPercentage) {
   const uint16_t kNumberOfMethodsInRefProfile = 6000;
   const uint16_t kNumberOfMethodsInCurProfile = 6200;  // Threshold is 2%.
-  std::vector<const std::string> extra_args({"--min-new-methods-percent-change=2"});
+  std::vector<std::string> extra_args({"--min-new-methods-percent-change=2"});
 
   // We should advise compilation.
   ASSERT_EQ(ProfmanResult::kCompile,
@@ -688,7 +688,7 @@ TEST_F(ProfileAssistantTest, ShouldAdviseCompilationMethodPercentage) {
 TEST_F(ProfileAssistantTest, DoNotAdviseCompilationClassPercentage) {
   const uint16_t kNumberOfClassesInRefProfile = 6000;
   const uint16_t kNumberOfClassesInCurProfile = 6110;  // Threshold is 2%.
-  std::vector<const std::string> extra_args({"--min-new-classes-percent-change=2"});
+  std::vector<std::string> extra_args({"--min-new-classes-percent-change=2"});
 
   // We should not advise compilation.
   ASSERT_EQ(ProfmanResult::kSkipCompilationSmallDelta,
@@ -699,7 +699,7 @@ TEST_F(ProfileAssistantTest, DoNotAdviseCompilationClassPercentage) {
 TEST_F(ProfileAssistantTest, ShouldAdviseCompilationClassPercentage) {
   const uint16_t kNumberOfClassesInRefProfile = 6000;
   const uint16_t kNumberOfClassesInCurProfile = 6120;  // Threshold is 2%.
-  std::vector<const std::string> extra_args({"--min-new-classes-percent-change=2"});
+  std::vector<std::string> extra_args({"--min-new-classes-percent-change=2"});
 
   // We should advise compilation.
   ASSERT_EQ(ProfmanResult::kCompile,
@@ -2142,7 +2142,7 @@ TEST_F(ProfileAssistantTest, ForceMerge) {
   ProfileCompilationInfo info2;
   SetupProfile(dex1_7000, dex2_7000, 0, kNumberOfClassesInCurProfile, reference_profile, &info2);
 
-  std::vector<const std::string> extra_args({"--force-merge"});
+  std::vector<std::string> extra_args({"--force-merge"});
   int return_code = ProcessProfiles(profile_fds, reference_profile_fd, extra_args);
 
   ASSERT_EQ(return_code, ProfmanResult::kSuccess);
@@ -2168,7 +2168,7 @@ TEST_F(ProfileAssistantTest, ForceMergeAndAnalyze) {
   SetupProfile(
       dex1, dex2, kNumberOfMethodsInCurProfile, /*number_of_classes=*/0, cur_profile, &cur_info);
 
-  std::vector<const std::string> extra_args({"--force-merge-and-analyze"});
+  std::vector<std::string> extra_args({"--force-merge-and-analyze"});
   int return_code = ProcessProfiles({cur_profile.GetFd()}, ref_profile.GetFd(), extra_args);
 
   ASSERT_EQ(return_code, ProfmanResult::kCompile);
@@ -2194,7 +2194,7 @@ TEST_F(ProfileAssistantTest, ForceMergeAndAnalyzeNoDelta) {
   SetupProfile(
       dex1, dex2, kNumberOfMethodsInCurProfile, /*number_of_classes=*/0, cur_profile, &cur_info);
 
-  std::vector<const std::string> extra_args({"--force-merge-and-analyze"});
+  std::vector<std::string> extra_args({"--force-merge-and-analyze"});
   int return_code = ProcessProfiles({cur_profile.GetFd()}, ref_profile.GetFd(), extra_args);
 
   ASSERT_EQ(return_code, ProfmanResult::kSkipCompilationSmallDelta);
@@ -2219,7 +2219,7 @@ TEST_F(ProfileAssistantTest, ForceMergeAndAnalyzeEmptyProfiles) {
   SetupProfile(
       dex1, dex2, kNumberOfMethodsInCurProfile, /*number_of_classes=*/0, cur_profile, &cur_info);
 
-  std::vector<const std::string> extra_args({"--force-merge-and-analyze"});
+  std::vector<std::string> extra_args({"--force-merge-and-analyze"});
   int return_code = ProcessProfiles({cur_profile.GetFd()}, ref_profile.GetFd(), extra_args);
 
   ASSERT_EQ(return_code, ProfmanResult::kSkipCompilationEmptyProfiles);
@@ -2287,7 +2287,7 @@ TEST_F(ProfileAssistantTest, DifferentProfileVersions) {
 
   std::vector<int> profile_fds({ GetFd(profile1)});
   int reference_profile_fd = GetFd(profile2);
-  std::vector<const std::string> boot_image_args({"--boot-image-merge"});
+  std::vector<std::string> boot_image_args({"--boot-image-merge"});
   ASSERT_EQ(ProcessProfiles(profile_fds, reference_profile_fd, boot_image_args),
             ProfmanResult::kErrorDifferentVersions);
   ASSERT_EQ(ProcessProfiles(profile_fds, reference_profile_fd), ProfmanResult::kErrorBadProfiles);
diff --git a/profman/profman.cc b/profman/profman.cc
index 1525b476cd..19d480e233 100644
--- a/profman/profman.cc
+++ b/profman/profman.cc
@@ -63,6 +63,7 @@
 #include "profile/profile_compilation_info.h"
 #include "profile_assistant.h"
 #include "profman/profman_result.h"
+#include "inline_cache_format_util.h"
 
 namespace art {
 
@@ -209,14 +210,9 @@ static constexpr uint16_t kDefaultTestProfileClassPercentage = 5;
 
 // Separators used when parsing human friendly representation of profiles.
 static const std::string kMethodSep = "->";  // NOLINT [runtime/string] [4]
-static const std::string kMissingTypesMarker = "missing_types";  // NOLINT [runtime/string] [4]
-static const std::string kMegamorphicTypesMarker = "megamorphic_types";  // NOLINT [runtime/string] [4]
 static const std::string kClassAllMethods = "*";  // NOLINT [runtime/string] [4]
 static constexpr char kAnnotationStart = '{';
 static constexpr char kAnnotationEnd = '}';
-static constexpr char kProfileParsingInlineChacheSep = '+';
-static constexpr char kProfileParsingInlineChacheTargetSep = ']';
-static constexpr char kProfileParsingTypeSep = ',';
 static constexpr char kProfileParsingFirstCharInSignature = '(';
 static constexpr char kMethodFlagStringHot = 'H';
 static constexpr char kMethodFlagStringStartup = 'S';
@@ -566,13 +562,20 @@ class ProfMan final {
   }
 
   bool GetProfileFilterKeyFromApks(std::set<ProfileFilterKey>* profile_filter_keys) {
-    auto process_fn = [profile_filter_keys](std::unique_ptr<const DexFile>&& dex_file) {
-      // Store the profile key of the location instead of the location itself.
-      // This will make the matching in the profile filter method much easier.
-      profile_filter_keys->emplace(ProfileCompilationInfo::GetProfileDexFileBaseKey(
-          dex_file->GetLocation()), dex_file->GetLocationChecksum());
-    };
-    return OpenApkFilesFromLocations(process_fn);
+    return ForEachApkFile([&](File file, const std::string& location) {
+      ArtDexFileLoader dex_file_loader(&file, location);
+      std::vector<std::pair<std::string, uint32_t>> checksums;
+      std::string error_msg;
+      if (!dex_file_loader.GetMultiDexChecksums(&checksums, &error_msg)) {
+        LOG(ERROR) << "Open failed for '" << location << "' " << error_msg;
+        return false;
+      }
+      for (const auto& [multi_dex_location, checksum] : checksums) {
+        profile_filter_keys->emplace(
+            ProfileCompilationInfo::GetProfileDexFileBaseKey(multi_dex_location), checksum);
+      }
+      return true;
+    });
   }
 
   bool OpenApkFilesFromLocations(std::vector<std::unique_ptr<const DexFile>>* dex_files) {
@@ -584,6 +587,32 @@ class ProfMan final {
 
   bool OpenApkFilesFromLocations(
       const std::function<void(std::unique_ptr<const DexFile>&&)>& process_fn) {
+    static constexpr bool kVerifyChecksum = true;
+    std::string error_msg;
+    std::vector<std::unique_ptr<const DexFile>> dex_files_for_location;
+    bool result = ForEachApkFile([&](File file, const std::string& location) {
+      ArtDexFileLoader dex_file_loader(&file, location);
+      if (!dex_file_loader.Open(/*verify=*/false,
+                                kVerifyChecksum,
+                                /*allow_no_dex_files=*/true,
+                                &error_msg,
+                                &dex_files_for_location)) {
+        LOG(ERROR) << "Open failed for '" << location << "' " << error_msg;
+        return false;
+      }
+      return true;
+    });
+    if (!result) {
+      return false;
+    }
+    for (std::unique_ptr<const DexFile>& dex_file : dex_files_for_location) {
+      process_fn(std::move(dex_file));
+    }
+    return true;
+  }
+
+  bool ForEachApkFile(
+      const std::function<bool(File file, const std::string& location)>& process_fn) {
     bool use_apk_fd_list = !apks_fd_.empty();
     if (use_apk_fd_list) {
       // Get the APKs from the collection of FDs.
@@ -596,7 +625,7 @@ class ProfMan final {
         }
       } else {
         if (dex_locations_.size() != apks_fd_.size()) {
-            Usage("The number of apk-fds must match the number of dex-locations.");
+          Usage("The number of apk-fds must match the number of dex-locations.");
         }
       }
     } else if (!apk_files_.empty()) {
@@ -604,50 +633,30 @@ class ProfMan final {
         // If no dex locations are specified use the apk names as locations.
         dex_locations_ = apk_files_;
       } else if (dex_locations_.size() != apk_files_.size()) {
-          Usage("The number of apk-fds must match the number of dex-locations.");
+        Usage("The number of apk-fds must match the number of dex-locations.");
       }
     } else {
       // No APKs were specified.
       CHECK(dex_locations_.empty());
       return true;
     }
-    static constexpr bool kVerifyChecksum = true;
     for (size_t i = 0; i < dex_locations_.size(); ++i) {
-      std::string error_msg;
-      std::vector<std::unique_ptr<const DexFile>> dex_files_for_location;
       // We do not need to verify the apk for processing profiles.
       if (use_apk_fd_list) {
-          File file(apks_fd_[i], /*check_usage=*/false);
-          ArtDexFileLoader dex_file_loader(&file, dex_locations_[i]);
-          if (dex_file_loader.Open(/*verify=*/false,
-                                   kVerifyChecksum,
-                                   /*allow_no_dex_files=*/true,
-                                   &error_msg,
-                                   &dex_files_for_location)) {
-          } else {
-            LOG(ERROR) << "OpenZip failed for '" << dex_locations_[i] << "' " << error_msg;
-            return false;
-          }
+        File file(apks_fd_[i], /*check_usage=*/false);
+        if (!process_fn(std::move(file), dex_locations_[i])) {
+          return false;
+        }
       } else {
         File file(apk_files_[i], O_RDONLY, /*check_usage=*/false);
         if (file.Fd() < 0) {
           PLOG(ERROR) << "Unable to open '" << apk_files_[i] << "'";
           return false;
         }
-        ArtDexFileLoader dex_file_loader(&file, dex_locations_[i]);
-        if (dex_file_loader.Open(/*verify=*/false,
-                                 kVerifyChecksum,
-                                 /*allow_no_dex_files=*/true,
-                                 &error_msg,
-                                 &dex_files_for_location)) {
-        } else {
-          LOG(ERROR) << "Open failed for '" << dex_locations_[i] << "' " << error_msg;
+        if (!process_fn(std::move(file), dex_locations_[i])) {
           return false;
         }
       }
-      for (std::unique_ptr<const DexFile>& dex_file : dex_files_for_location) {
-        process_fn(std::move(dex_file));
-      }
     }
     return true;
   }
@@ -801,86 +810,6 @@ class ProfMan final {
     return dump_only_;
   }
 
-  // Creates the inline-cache portion of a text-profile line. If the class def can't be found, or if
-  // there is no inline-caches this will be and empty string. Otherwise it will be '@' followed by
-  // an IC description matching the format described by ProcessLine below. Note that this will
-  // collapse all ICs with the same receiver type.
-  std::string GetInlineCacheLine(const ProfileCompilationInfo& profile_info,
-                                 const dex::MethodId& id,
-                                 const DexFile* dex_file,
-                                 uint16_t dex_method_idx) {
-    ProfileCompilationInfo::MethodHotness hotness =
-        profile_info.GetMethodHotness(MethodReference(dex_file, dex_method_idx));
-    DCHECK(!hotness.IsHot() || hotness.GetInlineCacheMap() != nullptr);
-    if (!hotness.IsHot() || hotness.GetInlineCacheMap()->empty()) {
-      return "";
-    }
-    const ProfileCompilationInfo::InlineCacheMap* inline_caches = hotness.GetInlineCacheMap();
-    struct IcLineInfo {
-      bool is_megamorphic_ = false;
-      bool is_missing_types_ = false;
-      std::set<dex::TypeIndex> classes_;
-    };
-    std::unordered_map<dex::TypeIndex, IcLineInfo> ics;
-    const dex::ClassDef* class_def = dex_file->FindClassDef(id.class_idx_);
-    if (class_def == nullptr) {
-      // No class def found.
-      return "";
-    }
-
-    CodeItemInstructionAccessor accessor(
-        *dex_file, dex_file->GetCodeItem(dex_file->FindCodeItemOffset(*class_def, dex_method_idx)));
-    for (const auto& [pc, ic_data] : *inline_caches) {
-      if (pc >= accessor.InsnsSizeInCodeUnits()) {
-        // Inlined inline caches are not supported in AOT, so discard any pc beyond the
-        // code item size. See also `HInliner::GetInlineCacheAOT`.
-        continue;
-      }
-      const Instruction& inst = accessor.InstructionAt(pc);
-      const dex::MethodId& target = dex_file->GetMethodId(inst.VRegB());
-      if (ic_data.classes.empty() && !ic_data.is_megamorphic && !ic_data.is_missing_types) {
-        continue;
-      }
-      auto val = ics.find(target.class_idx_);
-      if (val == ics.end()) {
-        val = ics.insert({ target.class_idx_, {} }).first;
-      }
-      if (ic_data.is_megamorphic) {
-        val->second.is_megamorphic_ = true;
-      }
-      if (ic_data.is_missing_types) {
-        val->second.is_missing_types_ = true;
-      }
-      for (dex::TypeIndex type_index : ic_data.classes) {
-        val->second.classes_.insert(type_index);
-      }
-    }
-    if (ics.empty()) {
-      return "";
-    }
-    std::ostringstream dump_ic;
-    dump_ic << kProfileParsingInlineChacheSep;
-    for (const auto& [target, dex_data] : ics) {
-      dump_ic << kProfileParsingInlineChacheTargetSep;
-      dump_ic << dex_file->GetTypeDescriptor(dex_file->GetTypeId(target));
-      if (dex_data.is_missing_types_) {
-        dump_ic << kMissingTypesMarker;
-      } else if (dex_data.is_megamorphic_) {
-        dump_ic << kMegamorphicTypesMarker;
-      } else {
-        bool first = true;
-        for (dex::TypeIndex type_index : dex_data.classes_) {
-          if (!first) {
-            dump_ic << kProfileParsingTypeSep;
-          }
-          first = false;
-          dump_ic << profile_info.GetTypeDescriptor(dex_file, type_index);
-        }
-      }
-    }
-    return dump_ic.str();
-  }
-
   bool GetClassNamesAndMethods(const ProfileCompilationInfo& profile_info,
                                std::vector<std::unique_ptr<const DexFile>>* dex_files,
                                std::set<std::string>* out_lines) {
@@ -916,8 +845,9 @@ class ProfMan final {
           if (post_startup_methods.find(dex_method_idx) != post_startup_methods.end()) {
             flags_string += kMethodFlagStringPostStartup;
           }
-          std::string inline_cache_string =
-              GetInlineCacheLine(profile_info, id, dex_file.get(), dex_method_idx);
+          FlattenProfileData::ItemMetadata metadata;
+          metadata.ExtractInlineCacheInfo(profile_info, dex_file.get(), dex_method_idx);
+          std::string inline_cache_string = GetInlineCacheLine(metadata.GetInlineCache());
           out_lines->insert(ART_FORMAT("{}{}{}{}{}{}",
                                        flags_string,
                                        type_string,
diff --git a/runtime/Android.bp b/runtime/Android.bp
index fe9fe295f6..0d9009924a 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -301,7 +301,6 @@ cc_defaults {
         "interpreter/interpreter_cache.cc",
         "interpreter/interpreter_common.cc",
         "interpreter/interpreter_switch_impl0.cc",
-        "interpreter/interpreter_switch_impl1.cc",
         "interpreter/lock_count_data.cc",
         "interpreter/shadow_frame.cc",
         "interpreter/unstarted_runtime.cc",
@@ -379,7 +378,6 @@ cc_defaults {
         "native_stack_dump.cc",
         "non_debuggable_classes.cc",
         "nterp_helpers.cc",
-        "oat/aot_class_linker.cc",
         "oat/elf_file.cc",
         "oat/image.cc",
         "oat/index_bss_mapping.cc",
@@ -408,7 +406,6 @@ cc_defaults {
         "runtime_intrinsics.cc",
         "runtime_options.cc",
         "scoped_thread_state_change.cc",
-        "sdk_checker.cc",
         "signal_catcher.cc",
         "stack.cc",
         "startup_completed_task.cc",
@@ -418,7 +415,7 @@ cc_defaults {
         "thread_pool.cc",
         "ti/agent.cc",
         "trace.cc",
-        "transaction.cc",
+        "trace_profile.cc",
         "var_handles.cc",
         "vdex_file.cc",
         "verifier/class_verifier.cc",
@@ -786,6 +783,7 @@ gensrcs {
         "thread.h",
         "thread_state.h",
         "trace.h",
+        "trace_profile.h",
         "verifier/verifier_enums.h",
     ],
     output_extension: "operator_out.cc",
@@ -944,7 +942,6 @@ art_cc_defaults {
     ],
     srcs: [
         "common_runtime_test.cc",
-        "common_transaction_test.cc",
         "dexopt_test.cc",
     ],
     static_libs: [
@@ -986,6 +983,8 @@ art_cc_defaults {
     },
     data: [
         ":art-gtest-jars-AllFields",
+        ":art-gtest-jars-DexVerificationFuzzerFolder",
+        ":art-gtest-jars-ClassVerificationFuzzerFolder",
         ":art-gtest-jars-ErroneousA",
         ":art-gtest-jars-ErroneousB",
         ":art-gtest-jars-ErroneousInit",
@@ -1019,7 +1018,6 @@ art_cc_defaults {
         ":art-gtest-jars-StaticLeafMethods",
         ":art-gtest-jars-Statics",
         ":art-gtest-jars-StaticsFromCode",
-        ":art-gtest-jars-Transaction",
         ":art-gtest-jars-VerifierDeps",
         ":art-gtest-jars-VerifierDepsMulti",
         ":art-gtest-jars-XandY",
@@ -1038,7 +1036,6 @@ art_cc_defaults {
         "oat/oat_file_assistant_test.cc",
         "runtime_callbacks_test.cc",
         "subtype_check_test.cc",
-        "transaction_test.cc",
         "verifier/reg_type_test.cc",
     ],
     srcs: [
@@ -1065,6 +1062,7 @@ art_cc_defaults {
         "entrypoints/quick/quick_trampoline_entrypoints_test.cc",
         "entrypoints_order_test.cc",
         "exec_utils_test.cc",
+        "fuzzer_corpus_test.cc",
         "gc/accounting/card_table_test.cc",
         "gc/accounting/mod_union_table_test.cc",
         "gc/accounting/space_bitmap_test.cc",
@@ -1090,7 +1088,6 @@ art_cc_defaults {
         "intern_table_test.cc",
         "interpreter/safe_math_test.cc",
         "interpreter/unstarted_runtime_test.cc",
-        "interpreter/unstarted_runtime_transaction_test.cc",
         "jit/jit_memory_region_test.cc",
         "jit/profile_saver_test.cc",
         "jit/profiling_info_test.cc",
@@ -1106,7 +1103,6 @@ art_cc_defaults {
         "monitor_pool_test.cc",
         "monitor_test.cc",
         "native_stack_dump_test.cc",
-        "oat/jni_stub_hash_map_test.cc",
         "oat/oat_file_assistant_test.cc",
         "oat/oat_file_test.cc",
         "parsed_options_test.cc",
@@ -1120,7 +1116,6 @@ art_cc_defaults {
         "subtype_check_test.cc",
         "thread_pool_test.cc",
         "thread_test.cc",
-        "transaction_test.cc",
         "two_runtimes_test.cc",
         "vdex_file_test.cc",
         "verifier/method_verifier_test.cc",
diff --git a/runtime/arch/arm/asm_support_arm.S b/runtime/arch/arm/asm_support_arm.S
index 2ab9918f58..557f53acd0 100644
--- a/runtime/arch/arm/asm_support_arm.S
+++ b/runtime/arch/arm/asm_support_arm.S
@@ -287,6 +287,8 @@
 .macro DELIVER_PENDING_EXCEPTION_FRAME_READY
     mov    r0, rSELF                           @ pass Thread::Current
     bl     artDeliverPendingExceptionFromCode  @ artDeliverPendingExceptionFromCode(Thread*)
+    bl art_quick_do_long_jump                  @ (Context*)
+    bkpt  // Unreached
 .endm
 
     /*
diff --git a/runtime/arch/arm/asm_support_arm.h b/runtime/arch/arm/asm_support_arm.h
index 063270fab5..09c1609152 100644
--- a/runtime/arch/arm/asm_support_arm.h
+++ b/runtime/arch/arm/asm_support_arm.h
@@ -64,4 +64,11 @@
 // The offset of the MOV from the return address in LR for intrinsic CAS.
 #define BAKER_MARK_INTROSPECTION_INTRINSIC_CAS_MOV_OFFSET (-8)
 
+// Size of Context::gprs_.
+#define ARM_LONG_JUMP_GPRS_SIZE 64
+// Size of Context::fprs_.
+#define ARM_LONG_JUMP_FPRS_SIZE 128
+// Size of Context::gprs_ + Context::fprs_.
+#define ARM_LONG_JUMP_CONTEXT_SIZE (ARM_LONG_JUMP_GPRS_SIZE + ARM_LONG_JUMP_FPRS_SIZE)
+
 #endif  // ART_RUNTIME_ARCH_ARM_ASM_SUPPORT_ARM_H_
diff --git a/runtime/arch/arm/context_arm.cc b/runtime/arch/arm/context_arm.cc
index 4e880e4bf6..50aec3331b 100644
--- a/runtime/arch/arm/context_arm.cc
+++ b/runtime/arch/arm/context_arm.cc
@@ -97,11 +97,7 @@ void ArmContext::SmashCallerSaves() {
   fprs_[S15] = nullptr;
 }
 
-extern "C" NO_RETURN void art_quick_do_long_jump(uint32_t*, uint32_t*);
-
-void ArmContext::DoLongJump() {
-  uintptr_t gprs[kNumberOfCoreRegisters];
-  uint32_t fprs[kNumberOfSRegisters];
+void ArmContext::CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) {
   for (size_t i = 0; i < kNumberOfCoreRegisters; ++i) {
     gprs[i] = gprs_[i] != nullptr ? *gprs_[i] : kBadGprBase + i;
   }
@@ -110,8 +106,7 @@ void ArmContext::DoLongJump() {
   }
   // Ensure the Thread Register contains the address of the current thread.
   DCHECK_EQ(reinterpret_cast<uintptr_t>(Thread::Current()), gprs[TR]);
-  // The Marking Register will be updated by art_quick_do_long_jump.
-  art_quick_do_long_jump(gprs, fprs);
+  // The Marking Register will be updated after return by art_quick_do_long_jump.
 }
 
 }  // namespace arm
diff --git a/runtime/arch/arm/context_arm.h b/runtime/arch/arm/context_arm.h
index 592d01b380..62ebc33f5d 100644
--- a/runtime/arch/arm/context_arm.h
+++ b/runtime/arch/arm/context_arm.h
@@ -86,7 +86,7 @@ class ArmContext final : public Context {
   void SetFPR(uint32_t reg, uintptr_t value) override;
 
   void SmashCallerSaves() override;
-  NO_RETURN void DoLongJump() override;
+  void CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) override;
 
  private:
   // Pointers to register locations, initialized to null or the specific registers below.
diff --git a/runtime/arch/arm/jni_entrypoints_arm.S b/runtime/arch/arm/jni_entrypoints_arm.S
index 95b5eb5c62..8c80c338dd 100644
--- a/runtime/arch/arm/jni_entrypoints_arm.S
+++ b/runtime/arch/arm/jni_entrypoints_arm.S
@@ -389,10 +389,12 @@ ENTRY art_jni_lock_object_no_inline
     ldr    lr, [sp, #(MANAGED_ARGS_R4_LR_SAVE_SIZE - 4)]
     .cfi_restore lr
     DECREASE_FRAME MANAGED_ARGS_R4_LR_SAVE_SIZE
-    // Make a tail call to `artDeliverPendingExceptionFromCode()`.
+    // Make a call to `artDeliverPendingExceptionFromCode()`.
     // Rely on the JNI transition frame constructed in the JNI stub.
-    mov    r0, rSELF                           @ Pass Thread::Current().
-    b      artDeliverPendingExceptionFromCode  @ (Thread*)
+    mov    r0, rSELF                            @ Pass Thread::Current().
+    bl     artDeliverPendingExceptionFromCode   @ (Thread*)
+    bl     art_quick_do_long_jump               @ (Context*)
+    bkpt  // Unreached
 END art_jni_lock_object_no_inline
 
     /*
diff --git a/runtime/arch/arm/quick_entrypoints_arm.S b/runtime/arch/arm/quick_entrypoints_arm.S
index 6f4bf8ce2b..2621918d09 100644
--- a/runtime/arch/arm/quick_entrypoints_arm.S
+++ b/runtime/arch/arm/quick_entrypoints_arm.S
@@ -138,9 +138,11 @@
 .macro RETURN_OR_DEOPT_OR_DELIVER_PENDING_EXCEPTION is_ref = 0
     // Use R2 to allow returning 64-bit values in R0-R1.
     ldr r2, [rSELF, # THREAD_EXCEPTION_OFFSET]  // Get exception field.
+    CFI_REMEMBER_STATE
     cbnz r2, 1f
     DEOPT_OR_RETURN r2, \is_ref                 // Check if deopt is required
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
@@ -158,9 +160,19 @@
   mov r1, r0                           // pass the result
   mov r0, rSELF                        // Thread::Current
   bl artDeoptimizeIfNeeded
+
+  CFI_REMEMBER_STATE
+  cbnz r0, 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   REFRESH_MARKING_REGISTER
   bx     lr
+
+3:
+  // Deoptimize
+  CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+  bl art_quick_do_long_jump            // (Context*)
+  bkpt  // Unreached
 .endm
 
 .macro DEOPT_OR_RESTORE_SAVE_EVERYTHING_FRAME_AND_RETURN_R0 temp, is_ref
@@ -177,11 +189,19 @@
   mov r1, r0                                       // pass the result
   mov r0, rSELF                                    // Thread::Current
   bl artDeoptimizeIfNeeded
+
   CFI_REMEMBER_STATE
+  cbnz r0, 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   REFRESH_MARKING_REGISTER
   bx     lr
+
+3:
+  // Deoptimize
   CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+  bl art_quick_do_long_jump                        // (Context*)
+  bkpt  // Unreached
 .endm
 
 .macro NO_ARG_RUNTIME_EXCEPTION c_name, cxx_name
@@ -190,6 +210,8 @@ ENTRY \c_name
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME r0       @ save all registers as basis for long jump context
     mov r0, rSELF                   @ pass Thread::Current
     bl  \cxx_name                   @ \cxx_name(Thread*)
+    bl  art_quick_do_long_jump      @ (Context*)
+    bkpt  // Unreached
 END \c_name
 .endm
 
@@ -199,6 +221,8 @@ ENTRY \c_name
     SETUP_SAVE_EVERYTHING_FRAME r0  @ save all registers as basis for long jump context
     mov r0, rSELF                   @ pass Thread::Current
     bl  \cxx_name                   @ \cxx_name(Thread*)
+    bl  art_quick_do_long_jump      @ (Context*)
+    bkpt  // Unreached
 END \c_name
 .endm
 
@@ -208,6 +232,8 @@ ENTRY \c_name
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME r1       @ save all registers as basis for long jump context
     mov r1, rSELF                   @ pass Thread::Current
     bl  \cxx_name                   @ \cxx_name(Thread*)
+    bl  art_quick_do_long_jump      @ (Context*)
+    bkpt  // Unreached
 END \c_name
 .endm
 
@@ -217,20 +243,26 @@ ENTRY \c_name
     SETUP_SAVE_EVERYTHING_FRAME r2  @ save all registers as basis for long jump context
     mov r2, rSELF                   @ pass Thread::Current
     bl  \cxx_name                   @ \cxx_name(Thread*)
+    bl  art_quick_do_long_jump      @ (Context*)
+    bkpt  // Unreached
 END \c_name
 .endm
 
 .macro RETURN_OR_DEOPT_IF_INT_RESULT_IS_ZERO_OR_DELIVER
+    CFI_REMEMBER_STATE
     cbnz   r0, 1f              @ result non-zero branch over
     DEOPT_OR_RETURN r1
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
 .macro RETURN_OR_DEOPT_IF_RESULT_IS_NON_NULL_OR_DELIVER
+    CFI_REMEMBER_STATE
     cbz    r0, 1f              @ result zero branch over
     DEOPT_OR_RETURN r1, /* is_ref= */ 1
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
@@ -316,6 +348,8 @@ ENTRY art_quick_throw_null_pointer_exception_from_signal
     mov r0, lr                      @ pass the fault address stored in LR by the fault handler.
     mov r1, rSELF                   @ pass Thread::Current
     bl  artThrowNullPointerExceptionFromSignal  @ (Thread*)
+    bl  art_quick_do_long_jump                  @ (Context*)
+    bkpt  // Unreached
 END art_quick_throw_null_pointer_exception_from_signal
 
     /*
@@ -515,19 +549,29 @@ ENTRY art_quick_osr_stub
 END art_quick_osr_stub
 
     /*
-     * On entry r0 is uint32_t* gprs_ and r1 is uint32_t* fprs_.
-     * Both must reside on the stack, between current SP and target SP.
+     * On entry r0 is the long jump context. This is expected to be returned from a previous
+     * entrypoint call which threw an exception or deoptimized.
      * The r12 (IP) shall be clobbered rather than retrieved from gprs_.
      */
 ARM_ENTRY art_quick_do_long_jump
-    vldm r1, {s0-s31}     @ Load all fprs from argument fprs_.
-    mov  sp, r0           @ Make SP point to gprs_.
+    // Reserve space for the gprs + fprs;
+    INCREASE_FRAME ARM_LONG_JUMP_CONTEXT_SIZE
+
+    mov r1, sp
+    add r2, sp, #ARM_LONG_JUMP_GPRS_SIZE
+
+    bl artContextCopyForLongJump  // Context* context, uintptr_t* gprs, uintptr_t* fprs
+
+    add r0, sp, #ARM_LONG_JUMP_GPRS_SIZE
+
+    vldm r0, {s0-s31}     @ Load all fprs from argument fprs_.
                           @ Do not access fprs_ from now, they may be below SP.
     ldm  sp, {r0-r11}     @ load r0-r11 from gprs_.
     ldr  r12, [sp, #60]   @ Load the value of PC (r15) from gprs_ (60 = 4 * 15) into IP (r12).
     ldr  lr, [sp, #56]    @ Load LR from gprs_, 56 = 4 * 14.
     ldr  sp, [sp, #52]    @ Load SP from gprs_ 52 = 4 * 13.
                           @ Do not access gprs_ from now, they are below SP.
+    .cfi_def_cfa_offset 0
     REFRESH_MARKING_REGISTER
     bx   r12              @ Do long jump.
 END art_quick_do_long_jump
@@ -630,7 +674,8 @@ ENTRY art_quick_check_instance_of
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME r2       @ save all registers as basis for long jump context
     mov r2, rSELF                   @ pass Thread::Current
     bl  artThrowClassCastExceptionForObject  @ (Object*, Class*, Thread*)
-    bkpt
+    bl  art_quick_do_long_jump               @ (Context*)
+    bkpt  // Unreached
 END art_quick_check_instance_of
 
 // Restore rReg's value from [sp, #offset] if rReg is not the same as rExclude.
@@ -781,7 +826,8 @@ ENTRY art_quick_aput_obj
     mov r1, r2
     mov r2, rSELF                  @ Pass Thread::Current.
     bl artThrowArrayStoreException @ (Class*, Class*, Thread*)
-    bkpt                           @ Unreachable.
+    bl art_quick_do_long_jump      @ (Context*)
+    bkpt  // Unreached
 
 #if defined(USE_READ_BARRIER) && defined(USE_BAKER_READ_BARRIER)
     CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
@@ -1252,9 +1298,19 @@ ENTRY art_quick_test_suspend
     SETUP_SAVE_EVERYTHING_FRAME r0, RUNTIME_SAVE_EVERYTHING_FOR_SUSPEND_CHECK_METHOD_OFFSET @ save everything for GC stack crawl
     mov    r0, rSELF
     bl     artTestSuspendFromCode               @ (Thread*)
+
+    CFI_REMEMBER_STATE
+    cbnz   r0, .Ltest_suspend_deoptimize
+
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
     bx     lr
+
+.Ltest_suspend_deoptimize:
+    // Deoptimize
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl     art_quick_do_long_jump               @ (Context*)
+    bkpt  // Unreached
 END art_quick_test_suspend
 
     .extern artImplicitSuspendFromCode
@@ -1262,9 +1318,19 @@ ENTRY art_quick_implicit_suspend
     mov    r0, rSELF
     SETUP_SAVE_REFS_ONLY_FRAME r1             @ save callee saves for stack crawl
     bl     artImplicitSuspendFromCode         @ (Thread*)
+
+    CFI_REMEMBER_STATE
+    cbnz   r0, .Limplicit_suspend_deopt
+
     RESTORE_SAVE_REFS_ONLY_FRAME
     REFRESH_MARKING_REGISTER
     bx     lr
+
+.Limplicit_suspend_deopt:
+    // Deoptimize
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_REFS_ONLY
+    bl     art_quick_do_long_jump             @ (Context*)
+    bkpt  // Unreached
 END art_quick_implicit_suspend
 
     /*
@@ -1488,6 +1554,8 @@ ENTRY art_quick_deoptimize_from_compiled_code
     SETUP_SAVE_EVERYTHING_FRAME r1
     mov    r1, rSELF                      @ pass Thread::Current
     blx    artDeoptimizeFromCompiledCode  @ (DeoptimizationKind, Thread*)
+    bl     art_quick_do_long_jump         @ (Context*)
+    bkpt  // Unreached
 END art_quick_deoptimize_from_compiled_code
 
     /*
@@ -2389,9 +2457,19 @@ ENTRY art_quick_method_entry_hook
     mov r1, rSELF                            @ pass Thread::Current
     mov r2, sp                               @ pass SP
     bl  artMethodEntryHook                   @ (ArtMethod*, Thread*, SP)
+
+    CFI_REMEMBER_STATE
+    cbnz r0, .Lentryhook_deopt
+
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
     blx lr
+
+.Lentryhook_deopt:
+    // Deoptimize
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl  art_quick_do_long_jump               @ (Context*)
+    bkpt  // Unreached
 END art_quick_method_entry_hook
 
 ENTRY art_quick_method_exit_hook
@@ -2406,9 +2484,18 @@ ENTRY art_quick_method_exit_hook
     mov r0, rSELF                             @ pass Thread::Current
     blx artMethodExitHook                     @ (Thread*, ArtMethod**, gpr_res*, fpr_res*,
                                               @ frame_size)
-
     DECREASE_FRAME 8                          @ pop arguments on stack
+
+    CFI_REMEMBER_STATE
+    cbnz r0, .Lexithook_deopt_or_exception
+
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
     blx lr
+
+.Lexithook_deopt_or_exception:
+    // Deoptimize or exception thrown.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl  art_quick_do_long_jump                @ (Context*)
+    bkpt  // Unreached
 END art_quick_method_exit_hook
diff --git a/runtime/arch/arm64/asm_support_arm64.S b/runtime/arch/arm64/asm_support_arm64.S
index 25f84e7c61..56ce037b1a 100644
--- a/runtime/arch/arm64/asm_support_arm64.S
+++ b/runtime/arch/arm64/asm_support_arm64.S
@@ -369,6 +369,7 @@
 
     // Point of no return.
     bl artDeliverPendingExceptionFromCode  // artDeliverPendingExceptionFromCode(Thread*)
+    bl art_quick_do_long_jump              // (Context*)
     brk 0  // Unreached
 .endm
 
diff --git a/runtime/arch/arm64/asm_support_arm64.h b/runtime/arch/arm64/asm_support_arm64.h
index 39a82965cd..00c7b5776c 100644
--- a/runtime/arch/arm64/asm_support_arm64.h
+++ b/runtime/arch/arm64/asm_support_arm64.h
@@ -54,4 +54,11 @@
 // The offset of the reference load LDR from the return address in LR for GC root loads.
 #define BAKER_MARK_INTROSPECTION_GC_ROOT_LDR_OFFSET (-8)
 
+// Size of Context::gprs_.
+#define ARM64_LONG_JUMP_GPRS_SIZE 272
+// Size of Context::fprs_.
+#define ARM64_LONG_JUMP_FPRS_SIZE 256
+// Size of Context::gprs_ + Context::fprs_.
+#define ARM64_LONG_JUMP_CONTEXT_SIZE (ARM64_LONG_JUMP_GPRS_SIZE + ARM64_LONG_JUMP_FPRS_SIZE)
+
 #endif  // ART_RUNTIME_ARCH_ARM64_ASM_SUPPORT_ARM64_H_
diff --git a/runtime/arch/arm64/context_arm64.cc b/runtime/arch/arm64/context_arm64.cc
index 96cd101fe8..77009e4932 100644
--- a/runtime/arch/arm64/context_arm64.cc
+++ b/runtime/arch/arm64/context_arm64.cc
@@ -129,8 +129,6 @@ void Arm64Context::SmashCallerSaves() {
   fprs_[D31] = nullptr;
 }
 
-extern "C" NO_RETURN void art_quick_do_long_jump(uint64_t*, uint64_t*);
-
 #if defined(__aarch64__) && defined(__BIONIC__) && defined(M_MEMTAG_STACK_IS_ON)
 static inline __attribute__((no_sanitize("memtag"))) void untag_memory(void* from, void* to) {
   __asm__ __volatile__(
@@ -145,10 +143,7 @@ static inline __attribute__((no_sanitize("memtag"))) void untag_memory(void* fro
 }
 #endif
 
-__attribute__((no_sanitize("memtag"))) void Arm64Context::DoLongJump() {
-  uint64_t gprs[arraysize(gprs_)];
-  uint64_t fprs[kNumberOfDRegisters];
-
+void Arm64Context::CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) {
   // The long jump routine called below expects to find the value for SP at index 31.
   DCHECK_EQ(SP, 31);
 
@@ -170,8 +165,7 @@ __attribute__((no_sanitize("memtag"))) void Arm64Context::DoLongJump() {
   // Tell HWASan about the new stack top.
   if (__hwasan_handle_longjmp != nullptr)
     __hwasan_handle_longjmp(reinterpret_cast<void*>(gprs[SP]));
-  // The Marking Register will be updated by art_quick_do_long_jump.
-  art_quick_do_long_jump(gprs, fprs);
+  // The Marking Register will be updated after return by art_quick_do_long_jump.
 }
 
 }  // namespace arm64
diff --git a/runtime/arch/arm64/context_arm64.h b/runtime/arch/arm64/context_arm64.h
index 0a284c93d8..c537365cd6 100644
--- a/runtime/arch/arm64/context_arm64.h
+++ b/runtime/arch/arm64/context_arm64.h
@@ -87,7 +87,7 @@ class Arm64Context final : public Context {
   void SetFPR(uint32_t reg, uintptr_t value) override;
 
   void SmashCallerSaves() override;
-  NO_RETURN void DoLongJump() override;
+  void CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) override;
 
   static constexpr size_t kPC = kNumberOfXRegisters;
 
diff --git a/runtime/arch/arm64/entrypoints_init_arm64.cc b/runtime/arch/arm64/entrypoints_init_arm64.cc
index 41876ec0f1..51cdacbb47 100644
--- a/runtime/arch/arm64/entrypoints_init_arm64.cc
+++ b/runtime/arch/arm64/entrypoints_init_arm64.cc
@@ -19,6 +19,7 @@
 
 #include "arch/arm64/asm_support_arm64.h"
 #include "base/bit_utils.h"
+#include "com_android_art_flags.h"
 #include "entrypoints/entrypoint_utils.h"
 #include "entrypoints/jni/jni_entrypoints.h"
 #include "entrypoints/math_entrypoints.h"
@@ -29,6 +30,8 @@
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "interpreter/interpreter.h"
 
+namespace art_flags = com::android::art::flags;
+
 namespace art HIDDEN {
 
 // Cast entrypoints.
@@ -76,6 +79,9 @@ extern "C" mirror::Object* art_quick_read_barrier_mark_introspection(mirror::Obj
 extern "C" mirror::Object* art_quick_read_barrier_mark_introspection_arrays(mirror::Object*);
 extern "C" mirror::Object* art_quick_read_barrier_mark_introspection_gc_roots(mirror::Object*);
 
+extern "C" void art_quick_record_entry_trace_event();
+extern "C" void art_quick_record_exit_trace_event();
+
 void UpdateReadBarrierEntrypoints(QuickEntryPoints* qpoints, bool is_active) {
   // ARM64 is the architecture with the largest number of core
   // registers (32) that supports the read barrier configuration.
@@ -193,6 +199,13 @@ void InitEntryPoints(JniEntryPoints* jpoints,
   UpdateReadBarrierEntrypoints(qpoints, /*is_active=*/ false);
   qpoints->SetReadBarrierSlow(artReadBarrierSlow);
   qpoints->SetReadBarrierForRootSlow(artReadBarrierForRootSlow);
+
+  if (art_flags::always_enable_profile_code()) {
+    // These are used for always-on-tracing, currently only supported on arm64
+    // devices.
+    qpoints->SetRecordEntryTraceEvent(art_quick_record_entry_trace_event);
+    qpoints->SetRecordExitTraceEvent(art_quick_record_exit_trace_event);
+  }
 }
 
 }  // namespace art
diff --git a/runtime/arch/arm64/jni_entrypoints_arm64.S b/runtime/arch/arm64/jni_entrypoints_arm64.S
index c39dd0a8a7..2bfb02d062 100644
--- a/runtime/arch/arm64/jni_entrypoints_arm64.S
+++ b/runtime/arch/arm64/jni_entrypoints_arm64.S
@@ -428,10 +428,12 @@ ENTRY art_jni_lock_object_no_inline
 1:
     // All args are irrelevant when throwing an exception. Remove the spill area.
     DECREASE_FRAME (ALL_ARGS_SIZE + /*padding*/ 8 + /*LR*/ 8)
-    // Make a tail call to `artDeliverPendingExceptionFromCode()`.
+    // Make a call to `artDeliverPendingExceptionFromCode()`.
     // Rely on the JNI transition frame constructed in the JNI stub.
-    mov    x0, xSELF                           // Pass Thread::Current().
-    b      artDeliverPendingExceptionFromCode  // (Thread*)
+    mov    x0, xSELF                            // Pass Thread::Current().
+    bl     artDeliverPendingExceptionFromCode   // (Thread*)
+    bl     art_quick_do_long_jump               // (Context*)
+    brk 0  // Unreached
 END art_jni_lock_object_no_inline
 
     /*
diff --git a/runtime/arch/arm64/quick_entrypoints_arm64.S b/runtime/arch/arm64/quick_entrypoints_arm64.S
index 3c2445ce2c..3bb3b693d9 100644
--- a/runtime/arch/arm64/quick_entrypoints_arm64.S
+++ b/runtime/arch/arm64/quick_entrypoints_arm64.S
@@ -198,9 +198,11 @@
 
 .macro RETURN_OR_DEOPT_OR_DELIVER_PENDING_EXCEPTION is_ref = 0
     ldr x1, [xSELF, # THREAD_EXCEPTION_OFFSET]  // Get exception field.
+    CFI_REMEMBER_STATE
     cbnz x1, 1f
     DEOPT_OR_RETURN x1, \is_ref                // Check if deopt is required
 1:                                             // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
@@ -218,9 +220,19 @@
   mov x1, x0                        // pass the result
   mov x0, xSELF                     // Thread::Current
   bl artDeoptimizeIfNeeded
+
+  CFI_REMEMBER_STATE
+  cbnz x0, 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   REFRESH_MARKING_REGISTER
   ret
+
+3:
+  // Deoptimize.
+  CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+  bl art_quick_do_long_jump         // (Context*)
+  brk 0  // Unreached
 .endm
 
 .macro DEOPT_OR_RESTORE_SAVE_EVERYTHING_FRAME_AND_RETURN_X0 temp, is_ref
@@ -237,18 +249,28 @@
   mov x1, x0                                     // pass the result
   mov x0, xSELF                                  // Thread::Current
   bl artDeoptimizeIfNeeded
+
   CFI_REMEMBER_STATE
+  cbnz x0, 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   REFRESH_MARKING_REGISTER
   ret
+
+3:
+  // Deoptimize.
   CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+  bl art_quick_do_long_jump                      // (Context*)
+  brk 0  // Unreached
 .endm
 
 
 .macro RETURN_OR_DEOPT_IF_INT_RESULT_IS_ZERO_OR_DELIVER
+    CFI_REMEMBER_STATE
     cbnz w0, 1f                // result non-zero branch over
     DEOPT_OR_RETURN x1
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
@@ -258,7 +280,8 @@ ENTRY \c_name
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME // save all registers as basis for long jump context
     mov x0, xSELF                     // pass Thread::Current
     bl  \cxx_name                     // \cxx_name(Thread*)
-    brk 0
+    bl  art_quick_do_long_jump        // (Context*)
+    brk 0  // Unreached
 END \c_name
 .endm
 
@@ -268,7 +291,8 @@ ENTRY \c_name
     SETUP_SAVE_EVERYTHING_FRAME       // save all registers as basis for long jump context
     mov x0, xSELF                     // pass Thread::Current
     bl  \cxx_name                     // \cxx_name(Thread*)
-    brk 0
+    bl  art_quick_do_long_jump        // (Context*)
+    brk 0  // Unreached
 END \c_name
 .endm
 
@@ -278,7 +302,8 @@ ENTRY \c_name
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME // save all registers as basis for long jump context.
     mov x1, xSELF                     // pass Thread::Current.
     bl  \cxx_name                     // \cxx_name(arg, Thread*).
-    brk 0
+    bl  art_quick_do_long_jump        // (Context*)
+    brk 0  // Unreached
 END \c_name
 .endm
 
@@ -288,7 +313,8 @@ ENTRY \c_name
     SETUP_SAVE_EVERYTHING_FRAME       // save all registers as basis for long jump context
     mov x2, xSELF                     // pass Thread::Current
     bl  \cxx_name                     // \cxx_name(arg1, arg2, Thread*)
-    brk 0
+    bl  art_quick_do_long_jump        // (Context*)
+    brk 0  // Unreached
 END \c_name
 .endm
 
@@ -320,7 +346,8 @@ ENTRY art_quick_throw_null_pointer_exception_from_signal
     mov x0, lr                        // pass the fault address stored in LR by the fault handler.
     mov x1, xSELF                     // pass Thread::Current.
     bl  artThrowNullPointerExceptionFromSignal  // (arg, Thread*).
-    brk 0
+    bl  art_quick_do_long_jump                  // (Context*)
+    brk 0  // Unreached
 END art_quick_throw_null_pointer_exception_from_signal
 
     /*
@@ -776,56 +803,64 @@ ENTRY art_quick_osr_stub
 END art_quick_osr_stub
 
     /*
-     * On entry x0 is uintptr_t* gprs_ and x1 is uint64_t* fprs_.
-     * Both must reside on the stack, between current SP and target SP.
+     * On entry x0 is the long jump context. This is expected to be returned from a previous
+     * entrypoint call which threw an exception or deoptimized.
      * IP0 and IP1 shall be clobbered rather than retrieved from gprs_.
      */
 
 ENTRY art_quick_do_long_jump
+    // Reserve space for the gprs + fprs;
+    INCREASE_FRAME ARM64_LONG_JUMP_CONTEXT_SIZE
+
+    mov x1, sp
+    add x2, sp, #ARM64_LONG_JUMP_GPRS_SIZE
+
+    bl artContextCopyForLongJump  // Context* context, uintptr_t* gprs, uintptr_t* fprs
+
+    add x0, sp, #ARM64_LONG_JUMP_GPRS_SIZE
+
     // Load FPRs
-    ldp d0, d1, [x1, #0]
-    ldp d2, d3, [x1, #16]
-    ldp d4, d5, [x1, #32]
-    ldp d6, d7, [x1, #48]
-    ldp d8, d9, [x1, #64]
-    ldp d10, d11, [x1, #80]
-    ldp d12, d13, [x1, #96]
-    ldp d14, d15, [x1, #112]
-    ldp d16, d17, [x1, #128]
-    ldp d18, d19, [x1, #144]
-    ldp d20, d21, [x1, #160]
-    ldp d22, d23, [x1, #176]
-    ldp d24, d25, [x1, #192]
-    ldp d26, d27, [x1, #208]
-    ldp d28, d29, [x1, #224]
-    ldp d30, d31, [x1, #240]
-
-    // Load GPRs. Delay loading x0, x1 because x0 is used as gprs_.
-    ldp x2, x3, [x0, #16]
-    ldp x4, x5, [x0, #32]
-    ldp x6, x7, [x0, #48]
-    ldp x8, x9, [x0, #64]
-    ldp x10, x11, [x0, #80]
-    ldp x12, x13, [x0, #96]
-    ldp x14, x15, [x0, #112]
+    ldp d0, d1, [x0, #0]
+    ldp d2, d3, [x0, #16]
+    ldp d4, d5, [x0, #32]
+    ldp d6, d7, [x0, #48]
+    ldp d8, d9, [x0, #64]
+    ldp d10, d11, [x0, #80]
+    ldp d12, d13, [x0, #96]
+    ldp d14, d15, [x0, #112]
+    ldp d16, d17, [x0, #128]
+    ldp d18, d19, [x0, #144]
+    ldp d20, d21, [x0, #160]
+    ldp d22, d23, [x0, #176]
+    ldp d24, d25, [x0, #192]
+    ldp d26, d27, [x0, #208]
+    ldp d28, d29, [x0, #224]
+    ldp d30, d31, [x0, #240]
+
+    ldp x0, x1, [sp, #0]
+    ldp x2, x3, [sp, #16]
+    ldp x4, x5, [sp, #32]
+    ldp x6, x7, [sp, #48]
+    ldp x8, x9, [sp, #64]
+    ldp x10, x11, [sp, #80]
+    ldp x12, x13, [sp, #96]
+    ldp x14, x15, [sp, #112]
     // Do not load IP0 (x16) and IP1 (x17), these shall be clobbered below.
     // Don't load the platform register (x18) either.
-    ldr      x19, [x0, #152]      // xSELF.
-    ldp x20, x21, [x0, #160]      // For Baker RB, wMR (w20) is reloaded below.
-    ldp x22, x23, [x0, #176]
-    ldp x24, x25, [x0, #192]
-    ldp x26, x27, [x0, #208]
-    ldp x28, x29, [x0, #224]
-    ldp x30, xIP0, [x0, #240]     // LR and SP, load SP to IP0.
+    ldr      x19, [sp, #152]      // xSELF.
+    ldp x20, x21, [sp, #160]      // For Baker RB, wMR (w20) is reloaded below.
+    ldp x22, x23, [sp, #176]
+    ldp x24, x25, [sp, #192]
+    ldp x26, x27, [sp, #208]
+    ldp x28, x29, [sp, #224]
+    ldp x30, xIP0, [sp, #240]     // LR and SP, load SP to IP0.
 
     // Load PC to IP1, it's at the end (after the space for the unused XZR).
-    ldr xIP1, [x0, #33*8]
-
-    // Load x0, x1.
-    ldp x0, x1, [x0, #0]
+    ldr xIP1, [sp, #33*8]
 
     // Set SP. Do not access fprs_ and gprs_ from now, they are below SP.
     mov sp, xIP0
+    .cfi_def_cfa_offset 0
 
     REFRESH_MARKING_REGISTER
     REFRESH_SUSPEND_CHECK_REGISTER
@@ -922,7 +957,8 @@ ENTRY art_quick_check_instance_of
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME // save all registers as basis for long jump context
     mov x2, xSELF                     // pass Thread::Current
     bl artThrowClassCastExceptionForObject     // (Object*, Class*, Thread*)
-    brk 0                             // We should not return here...
+    bl art_quick_do_long_jump                  // (Context*)
+    brk 0  // Unreached
 END art_quick_check_instance_of
 
 // Restore xReg's value from [sp, #offset] if xReg is not the same as xExclude.
@@ -1072,7 +1108,8 @@ ENTRY art_quick_aput_obj
     mov x1, x2                      // Pass value.
     mov x2, xSELF                   // Pass Thread::Current.
     bl artThrowArrayStoreException  // (Object*, Object*, Thread*).
-    brk 0                           // Unreachable.
+    bl art_quick_do_long_jump       // (Context*)
+    brk 0  // Unreached
 
 #if defined(USE_READ_BARRIER) && defined(USE_BAKER_READ_BARRIER)
     CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
@@ -1181,9 +1218,11 @@ END \name
 .endm
 
 .macro RETURN_OR_DEOPT_IF_RESULT_IS_NON_NULL_OR_DELIVER
+    CFI_REMEMBER_STATE
     cbz w0, 1f                       // result zero branch over
     DEOPT_OR_RETURN x1, /*is_ref=*/1 // check for deopt or return
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
@@ -1565,10 +1604,21 @@ ENTRY art_quick_test_suspend
     SETUP_SAVE_EVERYTHING_FRAME RUNTIME_SAVE_EVERYTHING_FOR_SUSPEND_CHECK_METHOD_OFFSET
     mov    x0, xSELF
     bl     artTestSuspendFromCode       // (Thread*)
+
+    CFI_REMEMBER_STATE
+    cbnz   x0, .Ltest_suspend_deoptimize
+
+    // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
     REFRESH_SUSPEND_CHECK_REGISTER
     ret
+
+.Ltest_suspend_deoptimize:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl     art_quick_do_long_jump       // (Context*)
+    brk 0  // Unreached
 END art_quick_test_suspend
 
     /*
@@ -1580,10 +1630,20 @@ ENTRY art_quick_implicit_suspend
     SETUP_SAVE_EVERYTHING_FRAME RUNTIME_SAVE_EVERYTHING_FOR_SUSPEND_CHECK_METHOD_OFFSET
     mov    x0, xSELF
     bl     artImplicitSuspendFromCode   // (Thread*)
+
+    CFI_REMEMBER_STATE
+    cbnz   x0, .Limplicit_suspend_deopt
+
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
     REFRESH_SUSPEND_CHECK_REGISTER
     br     lr  // Do not use RET as we do not enter the entrypoint with "BL".
+
+.Limplicit_suspend_deopt:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl     art_quick_do_long_jump       // (Context*)
+    brk 0  // Unreached
 END art_quick_implicit_suspend
 
      /*
@@ -1873,7 +1933,8 @@ ENTRY art_quick_deoptimize_from_compiled_code
     SETUP_SAVE_EVERYTHING_FRAME
     mov    x1, xSELF                      // Pass thread.
     bl     artDeoptimizeFromCompiledCode  // (DeoptimizationKind, Thread*)
-    brk 0
+    bl     art_quick_do_long_jump         // (Context*)
+    brk 0  // Unreached
 END art_quick_deoptimize_from_compiled_code
 
 
@@ -2491,6 +2552,37 @@ ENTRY art_quick_compile_optimized
     ret
 END art_quick_compile_optimized
 
+ENTRY art_quick_record_entry_trace_event
+    ldr xIP1, [xSELF, #TRACE_BUFFER_CURRENT_OFFSET]
+    // xIP0 has the trace buffer pointer. This is loaded on the fast path before
+    // checking if we need to call this method. This will be still valid here.
+    cmp xIP1, xIP0
+    bhs .Lupdate_entry
+    mov xIP1, #TRACE_BUFFER_SIZE
+    add xIP1, xIP0, xIP1
+.Lupdate_entry:
+    sub xIP1, xIP1, 8
+    str x0, [xIP1]
+    str xIP1, [xSELF, #TRACE_BUFFER_CURRENT_OFFSET]
+    ret
+END art_quick_record_entry_trace_event
+
+ENTRY art_quick_record_exit_trace_event
+    ldr xIP1, [xSELF, #TRACE_BUFFER_CURRENT_OFFSET]
+    // xIP0 has the trace buffer pointer. This is loaded on the fast path before
+    // checking if we need to call this method. This will be still valid here.
+    cmp xIP1, xIP0
+    bhs .Lupdate_entry_exit
+    mov xIP1, #TRACE_BUFFER_SIZE
+    add xIP1, xIP0, xIP1
+.Lupdate_entry_exit:
+    sub xIP1, xIP1, 8
+    mov xIP0, #1
+    str xIP0, [xIP1]
+    str xIP1, [xSELF, #TRACE_BUFFER_CURRENT_OFFSET]
+    ret
+END art_quick_record_exit_trace_event
+
     .extern artMethodEntryHook
 ENTRY art_quick_method_entry_hook
     SETUP_SAVE_EVERYTHING_FRAME
@@ -2500,9 +2592,19 @@ ENTRY art_quick_method_entry_hook
     mov x2, sp                                // pass SP
     bl  artMethodEntryHook                    // (ArtMethod*, Thread*, SP)
 
+    CFI_REMEMBER_STATE
+    cbnz x0, .Lentryhook_deopt
+
+    // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME             // Note: will restore xSELF
     REFRESH_MARKING_REGISTER
     ret
+
+.Lentryhook_deopt:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl  art_quick_do_long_jump                // (Context*)
+    brk 0  // Unreached
 END art_quick_method_entry_hook
 
     .extern artMethodExitHook
@@ -2517,8 +2619,17 @@ ENTRY art_quick_method_exit_hook
     bl  artMethodExitHook                     // (Thread*, ArtMethod**, gpr_res*, fpr_res*,
                                               // frame_size)
 
+    CFI_REMEMBER_STATE
+    cbnz x0, .Lexithook_deopt_or_exception
+
     // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
     ret
+
+.Lexithook_deopt_or_exception:
+    // Deoptimize or exception thrown.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    bl  art_quick_do_long_jump                // (Context*)
+    brk 0  // Unreached
 END art_quick_method_exit_hook
diff --git a/runtime/arch/context.cc b/runtime/arch/context.cc
index b9931c44f8..1d69691619 100644
--- a/runtime/arch/context.cc
+++ b/runtime/arch/context.cc
@@ -22,4 +22,12 @@ Context* Context::Create() {
   return new RuntimeContextType;
 }
 
+extern "C" void artContextCopyForLongJump(Context* context, uintptr_t* gprs, uintptr_t* fprs) {
+  context->CopyContextTo(gprs, fprs);
+  // Once the context has been copied, it is no longer needed.
+  // The context pointer is passed via hand-written assembly stubs, otherwise we'd take the
+  // context argument as a `std::unique_ptr<>` to indicate the ownership handover.
+  delete context;
+}
+
 }  // namespace art
diff --git a/runtime/arch/context.h b/runtime/arch/context.h
index bfe322ec33..1a82aa8553 100644
--- a/runtime/arch/context.h
+++ b/runtime/arch/context.h
@@ -92,8 +92,9 @@ class Context {
   // an nterp frame.
   virtual void SetNterpDexPC([[maybe_unused]] uintptr_t new_value) { abort(); }
 
-  // Switches execution of the executing context to this context
-  NO_RETURN virtual void DoLongJump() = 0;
+  // Copies the values of GPRs and FPRs registers from this context to external buffers;
+  // the use case is to do a long jump afterwards.
+  virtual void CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) = 0;
 
   enum {
     kBadGprBase = 0xebad6070,
@@ -101,6 +102,9 @@ class Context {
   };
 };
 
+// Copy the GPRs and FPRs from the context to the given buffers.
+extern "C" void artContextCopyForLongJump(Context* context, uintptr_t* gprs, uintptr_t* fprs);
+
 }  // namespace art
 
 #endif  // ART_RUNTIME_ARCH_CONTEXT_H_
diff --git a/runtime/arch/riscv64/asm_support_riscv64.S b/runtime/arch/riscv64/asm_support_riscv64.S
index 22acbfb778..f8e3b488b5 100644
--- a/runtime/arch/riscv64/asm_support_riscv64.S
+++ b/runtime/arch/riscv64/asm_support_riscv64.S
@@ -714,8 +714,9 @@
 // Thread::Current()->exception_ when the runtime method frame is ready.
 .macro DELIVER_PENDING_EXCEPTION_FRAME_READY
     mv a0, xSELF
-    call artDeliverPendingExceptionFromCode  // Point of no return.
-    unimp                                    // Unreachable.
+    call artDeliverPendingExceptionFromCode
+    call art_quick_do_long_jump   // (Context*)
+    unimp  // Unreached
 .endm
 
 
diff --git a/runtime/arch/riscv64/asm_support_riscv64.h b/runtime/arch/riscv64/asm_support_riscv64.h
index 6d6ae62afb..f233eee36a 100644
--- a/runtime/arch/riscv64/asm_support_riscv64.h
+++ b/runtime/arch/riscv64/asm_support_riscv64.h
@@ -49,4 +49,11 @@
 #define NTERP_SIZE_SAVE_CALLEE_SAVES     192
 // clang-format on
 
+// Size of Context::gprs_.
+#define RISCV64_LONG_JUMP_GPRS_SIZE 264
+// Size of Context::fprs_.
+#define RISCV64_LONG_JUMP_FPRS_SIZE 256
+// Size of Context::gprs_ + Context::fprs_.
+#define RISCV64_LONG_JUMP_CONTEXT_SIZE (RISCV64_LONG_JUMP_GPRS_SIZE + RISCV64_LONG_JUMP_FPRS_SIZE)
+
 #endif  // ART_RUNTIME_ARCH_RISCV64_ASM_SUPPORT_RISCV64_H_
diff --git a/runtime/arch/riscv64/context_riscv64.cc b/runtime/arch/riscv64/context_riscv64.cc
index c9bfa16156..dceebe1e1f 100644
--- a/runtime/arch/riscv64/context_riscv64.cc
+++ b/runtime/arch/riscv64/context_riscv64.cc
@@ -120,12 +120,7 @@ void Riscv64Context::SmashCallerSaves() {
   fprs_[FA7] = nullptr;
 }
 
-extern "C" NO_RETURN void art_quick_do_long_jump(uint64_t*, uint64_t*);
-
-void Riscv64Context::DoLongJump() {
-  uint64_t gprs[arraysize(gprs_)];
-  uint64_t fprs[kNumberOfFRegisters];
-
+void Riscv64Context::CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) {
   // The long jump routine called below expects to find the value for SP at index 2.
   DCHECK_EQ(SP, 2);
 
@@ -143,7 +138,6 @@ void Riscv64Context::DoLongJump() {
   if (__hwasan_handle_longjmp != nullptr) {
     __hwasan_handle_longjmp(reinterpret_cast<void*>(gprs[SP]));
   }
-  art_quick_do_long_jump(gprs, fprs);
 }
 
 }  // namespace riscv64
diff --git a/runtime/arch/riscv64/context_riscv64.h b/runtime/arch/riscv64/context_riscv64.h
index 839317d2e0..278297d68c 100644
--- a/runtime/arch/riscv64/context_riscv64.h
+++ b/runtime/arch/riscv64/context_riscv64.h
@@ -79,7 +79,7 @@ class Riscv64Context final : public Context {
   void SetFPR(uint32_t reg, uintptr_t value) override;
 
   void SmashCallerSaves() override;
-  NO_RETURN void DoLongJump() override;
+  void CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) override;
 
   static constexpr size_t kPC = kNumberOfXRegisters;
 
diff --git a/runtime/arch/riscv64/jni_entrypoints_riscv64.S b/runtime/arch/riscv64/jni_entrypoints_riscv64.S
index c9d034b6cc..c1f855b4bf 100644
--- a/runtime/arch/riscv64/jni_entrypoints_riscv64.S
+++ b/runtime/arch/riscv64/jni_entrypoints_riscv64.S
@@ -522,10 +522,12 @@ ENTRY art_jni_lock_object_no_inline
 1:
     // All args are irrelevant when throwing an exception. Remove the spill area.
     DECREASE_FRAME (ALL_ARGS_SIZE + /*padding*/ 8 + /*RA*/ 8)
-    // Make a tail call to `artDeliverPendingExceptionFromCode()`.
+    // Make a call to `artDeliverPendingExceptionFromCode()`.
     // Rely on the JNI transition frame constructed in the JNI stub.
     mv     a0, xSELF                           // Pass Thread::Current().
-    tail   artDeliverPendingExceptionFromCode  // (Thread*)
+    call   artDeliverPendingExceptionFromCode  // (Thread*)
+    call   art_quick_do_long_jump              // (Context*)
+    unimp  // Unreached
 END art_jni_lock_object_no_inline
 
     /*
diff --git a/runtime/arch/riscv64/quick_entrypoints_riscv64.S b/runtime/arch/riscv64/quick_entrypoints_riscv64.S
index 141974e14a..06b9e9b7bb 100644
--- a/runtime/arch/riscv64/quick_entrypoints_riscv64.S
+++ b/runtime/arch/riscv64/quick_entrypoints_riscv64.S
@@ -429,8 +429,17 @@ ENTRY art_quick_method_entry_hook
     mv   a2, sp                               // pass SP
     call artMethodEntryHook                   // (ArtMethod*, Thread*, SP)
 
+    CFI_REMEMBER_STATE
+    bnez a0, .Lentryhook_deopt
+
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+
+.Lentryhook_deopt:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    call art_quick_do_long_jump               // (Context*)
+    unimp  // Unreached
 END art_quick_method_entry_hook
 
 
@@ -446,94 +455,110 @@ ENTRY art_quick_method_exit_hook
     call artMethodExitHook                         // (Thread*, ArtMethod**, gpr_res*, fpr_res*,
                                                    // frame_size)
 
+    CFI_REMEMBER_STATE
+    bnez a0, .Lexithook_deopt_or_exception
+
     // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
-END art_quick_method_exit_hook
 
+.Lexithook_deopt_or_exception:
+    // Deoptimize or exception thrown.
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    call art_quick_do_long_jump                    // (Context*)
+    unimp  // Unreached
+END art_quick_method_exit_hook
 
-// On entry a0 is uintptr_t* gprs_ and a1 is uint64_t* fprs_.
-// Both must reside on the stack, between current sp and target sp.
+// On entry a0 is the long jump context. This is expected to be returned from a previous entrypoint
+// call which threw an exception or deoptimized.
 ENTRY art_quick_do_long_jump
+    // Reserve space for the gprs + fprs;
+    INCREASE_FRAME RISCV64_LONG_JUMP_CONTEXT_SIZE
+
+    mv a1, sp
+    add a2, sp, RISCV64_LONG_JUMP_GPRS_SIZE
+
+    call artContextCopyForLongJump  // Context* context, uintptr_t* gprs, uintptr_t* fprs
+
+    add a0, sp, RISCV64_LONG_JUMP_GPRS_SIZE
+
     // Load FPRs
-    fld  ft0,  8*0(a1)   // f0
-    fld  ft1,  8*1(a1)   // f1
-    fld  ft2,  8*2(a1)   // f2
-    fld  ft3,  8*3(a1)   // f3
-    fld  ft4,  8*4(a1)   // f4
-    fld  ft5,  8*5(a1)   // f5
-    fld  ft6,  8*6(a1)   // f6
-    fld  ft7,  8*7(a1)   // f7
-    fld  fs0,  8*8(a1)   // f8
-    fld  fs1,  8*9(a1)   // f9
-    fld  fa0,  8*10(a1)  // f10
-    fld  fa1,  8*11(a1)  // f11
-    fld  fa2,  8*12(a1)  // f12
-    fld  fa3,  8*13(a1)  // f13
-    fld  fa4,  8*14(a1)  // f14
-    fld  fa5,  8*15(a1)  // f15
-    fld  fa6,  8*16(a1)  // f16
-    fld  fa7,  8*17(a1)  // f17
-    fld  fs2,  8*18(a1)  // f18
-    fld  fs3,  8*19(a1)  // f19
-    fld  fs4,  8*20(a1)  // f20
-    fld  fs5,  8*21(a1)  // f21
-    fld  fs6,  8*22(a1)  // f22
-    fld  fs7,  8*23(a1)  // f23
-    fld  fs8,  8*24(a1)  // f24
-    fld  fs9,  8*25(a1)  // f25
-    fld  fs10, 8*26(a1)  // f26
-    fld  fs11, 8*27(a1)  // f27
-    fld  ft8,  8*28(a1)  // f28
-    fld  ft9,  8*29(a1)  // f29
-    fld  ft10, 8*30(a1)  // f30
-    fld  ft11, 8*31(a1)  // f31
+    fld  ft0,  8*0(a0)   // f0
+    fld  ft1,  8*1(a0)   // f1
+    fld  ft2,  8*2(a0)   // f2
+    fld  ft3,  8*3(a0)   // f3
+    fld  ft4,  8*4(a0)   // f4
+    fld  ft5,  8*5(a0)   // f5
+    fld  ft6,  8*6(a0)   // f6
+    fld  ft7,  8*7(a0)   // f7
+    fld  fs0,  8*8(a0)   // f8
+    fld  fs1,  8*9(a0)   // f9
+    fld  fa0,  8*10(a0)  // f10
+    fld  fa1,  8*11(a0)  // f11
+    fld  fa2,  8*12(a0)  // f12
+    fld  fa3,  8*13(a0)  // f13
+    fld  fa4,  8*14(a0)  // f14
+    fld  fa5,  8*15(a0)  // f15
+    fld  fa6,  8*16(a0)  // f16
+    fld  fa7,  8*17(a0)  // f17
+    fld  fs2,  8*18(a0)  // f18
+    fld  fs3,  8*19(a0)  // f19
+    fld  fs4,  8*20(a0)  // f20
+    fld  fs5,  8*21(a0)  // f21
+    fld  fs6,  8*22(a0)  // f22
+    fld  fs7,  8*23(a0)  // f23
+    fld  fs8,  8*24(a0)  // f24
+    fld  fs9,  8*25(a0)  // f25
+    fld  fs10, 8*26(a0)  // f26
+    fld  fs11, 8*27(a0)  // f27
+    fld  ft8,  8*28(a0)  // f28
+    fld  ft9,  8*29(a0)  // f29
+    fld  ft10, 8*30(a0)  // f30
+    fld  ft11, 8*31(a0)  // f31
 
     // Load GPRs.
-    // Skip slot 8*0(a0) for zero/x0 as it is hard-wired zero.
-    ld  ra,   8*1(a0)   // x1
-    // Skip slot 8*2(a0) for sp/x2 as it is set below.
-    // Skip slot 8*3(a0) for platform-specific thread pointer gp/x3.
-    // Skip slot 8*4(a0) for platform-specific global pointer tp/x4.
-    // Skip slot 8*5(a0) for t0/x5 as it is clobbered below.
-    // Skip slot 8*6(a0) for t1/x6 as it is clobbered below.
-    ld  t2,   8*7(a0)   // x7
-    ld  s0,   8*8(a0)   // x8
-    ld  s1,   8*9(a0)   // x9
-    // Delay loading a0 as the base is in a0.
-    ld  a1,   8*11(a0)  // x11
-    ld  a2,   8*12(a0)  // x12
-    ld  a3,   8*13(a0)  // x13
-    ld  a4,   8*14(a0)  // x14
-    ld  a5,   8*15(a0)  // x15
-    ld  a6,   8*16(a0)  // x16
-    ld  a7,   8*17(a0)  // x17
-    ld  s2,   8*18(a0)  // x18
-    ld  s3,   8*19(a0)  // x19
-    ld  s4,   8*20(a0)  // x20
-    ld  s5,   8*21(a0)  // x21
-    ld  s6,   8*22(a0)  // x22
-    ld  s7,   8*23(a0)  // x23
-    ld  s8,   8*24(a0)  // x24
-    ld  s9,   8*25(a0)  // x25
-    ld  s10,  8*26(a0)  // x26
-    ld  s11,  8*27(a0)  // x27
-    ld  t3,   8*28(a0)  // x28
-    ld  t4,   8*29(a0)  // x29
-    ld  t5,   8*30(a0)  // x30
-    ld  t6,   8*31(a0)  // x31
+    // Skip slot 8*0(sp) for zero/x0 as it is hard-wired zero.
+    ld  ra,   8*1(sp)   // x1
+    // Skip slot 8*2(sp) for sp/x2 as it is set below.
+    // Skip slot 8*3(sp) for platform-specific thread pointer gp/x3.
+    // Skip slot 8*4(sp) for platform-specific global pointer tp/x4.
+    // Skip slot 8*5(sp) for t0/x5 as it is clobbered below.
+    // Skip slot 8*6(sp) for t1/x6 as it is clobbered below.
+    ld  t2,   8*7(sp)   // x7
+    ld  s0,   8*8(sp)   // x8
+    ld  s1,   8*9(sp)   // x9
+    ld  a0,   8*10(sp)  // x10
+    ld  a1,   8*11(sp)  // x11
+    ld  a2,   8*12(sp)  // x12
+    ld  a3,   8*13(sp)  // x13
+    ld  a4,   8*14(sp)  // x14
+    ld  a5,   8*15(sp)  // x15
+    ld  a6,   8*16(sp)  // x16
+    ld  a7,   8*17(sp)  // x17
+    ld  s2,   8*18(sp)  // x18
+    ld  s3,   8*19(sp)  // x19
+    ld  s4,   8*20(sp)  // x20
+    ld  s5,   8*21(sp)  // x21
+    ld  s6,   8*22(sp)  // x22
+    ld  s7,   8*23(sp)  // x23
+    ld  s8,   8*24(sp)  // x24
+    ld  s9,   8*25(sp)  // x25
+    ld  s10,  8*26(sp)  // x26
+    ld  s11,  8*27(sp)  // x27
+    ld  t3,   8*28(sp)  // x28
+    ld  t4,   8*29(sp)  // x29
+    ld  t5,   8*30(sp)  // x30
+    ld  t6,   8*31(sp)  // x31
 
     // Load sp to t0.
-    ld  t0, 8*2(a0)
+    ld  t0, 8*2(sp)
 
     // Load PC to t1, it is in the last stack slot.
-    ld  t1, 8*32(a0)
-
-    // Now load a0.
-    ld  a0, 8*10(a0)  // x10
+    ld  t1, 8*32(sp)
 
     // Set sp. Do not access fprs_ and gprs_ from now, they are below sp.
     mv sp, t0
+    .cfi_def_cfa_offset 0
 
     jr  t1
 END art_quick_do_long_jump
@@ -549,32 +574,47 @@ END art_quick_do_long_jump
     mv    a1, a0                      // pass the result
     mv    a0, xSELF                   // pass Thread::Current
     call  artDeoptimizeIfNeeded       // (Thread*, uintptr_t, bool)
+
+    CFI_REMEMBER_STATE
+    bnez  a0, 3f
+
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+3:
+    // Deoptimize
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    call  art_quick_do_long_jump      // (Context*)
+    unimp  // Unreached
 .endm
 
 
 .macro RETURN_OR_DEOPT_IF_RESULT_IS_NON_NULL_OR_DELIVER
+    CFI_REMEMBER_STATE
     beqz  a0, 1f
     DEOPT_OR_RETURN a1, /*is_ref=*/ 1
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
 
 .macro RETURN_OR_DEOPT_IF_INT_RESULT_IS_ZERO_OR_DELIVER
+    CFI_REMEMBER_STATE
     bnez  a0, 1f
     DEOPT_OR_RETURN a1
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION
 .endm
 
 
 .macro RETURN_OR_DEOPT_OR_DELIVER_PENDING_EXCEPTION is_ref = 0
     lwu   a1, THREAD_EXCEPTION_OFFSET(xSELF)   // Get exception field.
+    CFI_REMEMBER_STATE
     bnez  a1, 1f
     DEOPT_OR_RETURN a1, \is_ref                // Check if deopt is required.
 1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
     DELIVER_PENDING_EXCEPTION                  // Deliver exception on current thread.
 .endm
 
@@ -597,10 +637,18 @@ END art_quick_do_long_jump
   mv      a1, a0                                     // pass the result
   mv      a0, xSELF                                  // Thread::Current
   call    artDeoptimizeIfNeeded
+
   CFI_REMEMBER_STATE
+  bnez    a0, 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   ret
+
+3:
+  // Deoptimize
   CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+  call    art_quick_do_long_jump                     // (Context*)
+  unimp  // Unreached
 .endm
 
 
@@ -683,7 +731,8 @@ ENTRY art_quick_deoptimize_from_compiled_code
     SETUP_SAVE_EVERYTHING_FRAME
     mv    a1, xSELF                           // Pass Thread::Current().
     call  artDeoptimizeFromCompiledCode       // (DeoptimizationKind, Thread*)
-    unimp
+    call  art_quick_do_long_jump              // (Context*)
+    unimp  // Unreached
 END art_quick_deoptimize_from_compiled_code
 
 
@@ -738,7 +787,8 @@ ENTRY art_quick_check_instance_of
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME         // Save all registers as basis for long jump context.
     mv    a2, xSELF                           // Pass Thread::Current().
     call  artThrowClassCastExceptionForObject // (Object*, Class*, Thread*)
-    unimp                                     // We should not return here...
+    call  art_quick_do_long_jump              // (Context*)
+    unimp  // Unreached
 END art_quick_check_instance_of
 
 
@@ -748,7 +798,8 @@ ENTRY \c_name
     SETUP_SAVE_EVERYTHING_FRAME       // save all registers as basis for long jump context.
     mv    a\n, xSELF                  // pass Thread::Current.
     call  \cxx_name                   // \cxx_name(args..., Thread*).
-    unimp
+    call  art_quick_do_long_jump      // (Context*)
+    unimp  // Unreached
 END \c_name
 .endm
 
@@ -769,7 +820,8 @@ ENTRY \c_name
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME // save all registers as basis for long jump context.
     mv    a\n, xSELF                  // pass Thread::Current.
     call  \cxx_name                   // \cxx_name(args..., Thread*).
-    unimp
+    call  art_quick_do_long_jump      // (Context*)
+    unimp  // Unreached
 END \c_name
 .endm
 
@@ -801,7 +853,8 @@ ENTRY art_quick_throw_null_pointer_exception_from_signal
     mv    a0, ra                      // pass the fault address stored in RA by the fault handler.
     mv    a1, xSELF                   // pass Thread::Current.
     call  artThrowNullPointerExceptionFromSignal  // (arg, Thread*).
-    unimp
+    call  art_quick_do_long_jump                  // (Context*)
+    unimp  // Unreached
 END art_quick_throw_null_pointer_exception_from_signal
 
 
@@ -859,8 +912,18 @@ ENTRY art_quick_test_suspend
         RUNTIME_SAVE_EVERYTHING_FOR_SUSPEND_CHECK_METHOD_OFFSET
     mv   a0, xSELF
     call artTestSuspendFromCode
+
+    CFI_REMEMBER_STATE
+    bnez a0, .Ltest_suspend_deoptimize
+
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+
+.Ltest_suspend_deoptimize:
+    // Deoptimize
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, FRAME_SIZE_SAVE_EVERYTHING
+    call art_quick_do_long_jump   // (Context*)
+    unimp  // Unreached
 END art_quick_test_suspend
 
 
@@ -1331,7 +1394,8 @@ ENTRY art_quick_aput_obj
     mv    a1, a2                        // Pass value.
     mv    a2, xSELF                     // Pass Thread::Current().
     call  artThrowArrayStoreException   // (Object*, Object*, Thread*).
-    unimp                               // Unreachable.
+    call  art_quick_do_long_jump        // (Context*)
+    unimp  // Unreached
 
 #if defined(USE_READ_BARRIER) && defined(USE_BAKER_READ_BARRIER)
     CFI_RESTORE_STATE_AND_DEF_CFA sp, 0
diff --git a/runtime/arch/x86/asm_support_x86.S b/runtime/arch/x86/asm_support_x86.S
index 7ec2e2ea9b..49b0eb5f0d 100644
--- a/runtime/arch/x86/asm_support_x86.S
+++ b/runtime/arch/x86/asm_support_x86.S
@@ -384,6 +384,7 @@ MACRO0(DELIVER_PENDING_EXCEPTION_FRAME_READY)
     pushl %fs:THREAD_SELF_OFFSET               // pass Thread::Current()
     CFI_ADJUST_CFA_OFFSET(4)
     call SYMBOL(artDeliverPendingExceptionFromCode)  // artDeliverPendingExceptionFromCode(Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     CFI_ADJUST_CFA_OFFSET(-16)                 // Reset CFA in case there is more code afterwards.
 END_MACRO
diff --git a/runtime/arch/x86/asm_support_x86.h b/runtime/arch/x86/asm_support_x86.h
index 8c19e07ec3..a752a53f3e 100644
--- a/runtime/arch/x86/asm_support_x86.h
+++ b/runtime/arch/x86/asm_support_x86.h
@@ -29,4 +29,11 @@
 #define SAVE_EVERYTHING_FRAME_EAX_OFFSET \
     (FRAME_SIZE_SAVE_EVERYTHING - CALLEE_SAVE_EVERYTHING_NUM_CORE_SPILLS * POINTER_SIZE)
 
+// Size of Context::gprs_ + 1 so the stack pointer can be stored without being popped by pop-all.
+#define X86_LONG_JUMP_GPRS_SIZE 36
+// Size of Context::fprs_.
+#define X86_LONG_JUMP_FPRS_SIZE 64
+// Size of Context::gprs_ + Context::fprs_.
+#define X86_LONG_JUMP_CONTEXT_SIZE (X86_LONG_JUMP_GPRS_SIZE + X86_LONG_JUMP_FPRS_SIZE)
+
 #endif  // ART_RUNTIME_ARCH_X86_ASM_SUPPORT_X86_H_
diff --git a/runtime/arch/x86/context_x86.cc b/runtime/arch/x86/context_x86.cc
index f4b5e5bd52..40f1a4aa8d 100644
--- a/runtime/arch/x86/context_x86.cc
+++ b/runtime/arch/x86/context_x86.cc
@@ -88,15 +88,13 @@ void X86Context::SetFPR(uint32_t reg, uintptr_t value) {
   *fprs_[reg] = value;
 }
 
-void X86Context::DoLongJump() {
+void X86Context::CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) {
 #if defined(__i386__)
   // Array of GPR values, filled from the context backward for the long jump pop. We add a slot at
   // the top for the stack pointer that doesn't get popped in a pop-all.
-  volatile uintptr_t gprs[kNumberOfCpuRegisters + 1];
   for (size_t i = 0; i < kNumberOfCpuRegisters; ++i) {
-    gprs[kNumberOfCpuRegisters - i - 1] = gprs_[i] != nullptr ? *gprs_[i] : kBadGprBase + i;
+    gprs[kNumberOfCpuRegisters - i - 1] = (gprs_[i] != nullptr) ? *gprs_[i] : (kBadGprBase + i);
   }
-  uint32_t fprs[kNumberOfFloatRegisters];
   for (size_t i = 0; i < kNumberOfFloatRegisters; ++i) {
     fprs[i] = fprs_[i] != nullptr ? *fprs_[i] : kBadFprBase + i;
   }
@@ -104,28 +102,9 @@ void X86Context::DoLongJump() {
   uintptr_t esp = gprs[kNumberOfCpuRegisters - ESP - 1] - sizeof(intptr_t);
   gprs[kNumberOfCpuRegisters] = esp;
   *(reinterpret_cast<uintptr_t*>(esp)) = eip_;
-  MEMORY_TOOL_HANDLE_NO_RETURN;
-  __asm__ __volatile__(
-      "movl %1, %%ebx\n\t"          // Address base of FPRs.
-      "movsd 0(%%ebx), %%xmm0\n\t"  // Load up XMM0-XMM7.
-      "movsd 8(%%ebx), %%xmm1\n\t"
-      "movsd 16(%%ebx), %%xmm2\n\t"
-      "movsd 24(%%ebx), %%xmm3\n\t"
-      "movsd 32(%%ebx), %%xmm4\n\t"
-      "movsd 40(%%ebx), %%xmm5\n\t"
-      "movsd 48(%%ebx), %%xmm6\n\t"
-      "movsd 56(%%ebx), %%xmm7\n\t"
-      "movl %0, %%esp\n\t"  // ESP points to gprs.
-      "popal\n\t"           // Load all registers except ESP and EIP with values in gprs.
-      "popl %%esp\n\t"      // Load stack pointer.
-      "ret\n\t"             // From higher in the stack pop eip.
-      :  // output.
-      : "g"(&gprs[0]), "g"(&fprs[0]) // input.
-      :);  // clobber.
 #else
   UNIMPLEMENTED(FATAL);
 #endif
-  UNREACHABLE();
 }
 
 }  // namespace x86
diff --git a/runtime/arch/x86/context_x86.h b/runtime/arch/x86/context_x86.h
index ef2b27196b..455f731723 100644
--- a/runtime/arch/x86/context_x86.h
+++ b/runtime/arch/x86/context_x86.h
@@ -85,7 +85,7 @@ class X86Context final : public Context {
   void SetFPR(uint32_t reg, uintptr_t value) override;
 
   void SmashCallerSaves() override;
-  NO_RETURN void DoLongJump() override;
+  void CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) override;
 
  private:
   // Pretend XMM registers are made of uin32_t pieces, because they are manipulated
diff --git a/runtime/arch/x86/jni_entrypoints_x86.S b/runtime/arch/x86/jni_entrypoints_x86.S
index 448774a003..09b4d5a0f5 100644
--- a/runtime/arch/x86/jni_entrypoints_x86.S
+++ b/runtime/arch/x86/jni_entrypoints_x86.S
@@ -358,6 +358,7 @@ DEFINE_FUNCTION art_jni_lock_object_no_inline
     pushl %fs:THREAD_SELF_OFFSET          // pass Thread::Current()
     CFI_ADJUST_CFA_OFFSET(4)
     call SYMBOL(artDeliverPendingExceptionFromCode)  // (Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_jni_lock_object_no_inline
 
diff --git a/runtime/arch/x86/quick_entrypoints_x86.S b/runtime/arch/x86/quick_entrypoints_x86.S
index 5a32464290..d5c186e1ad 100644
--- a/runtime/arch/x86/quick_entrypoints_x86.S
+++ b/runtime/arch/x86/quick_entrypoints_x86.S
@@ -211,6 +211,7 @@ MACRO2(NO_ARG_RUNTIME_EXCEPTION, c_name, cxx_name)
     pushl %fs:THREAD_SELF_OFFSET               // pass Thread::Current()
     CFI_ADJUST_CFA_OFFSET(4)
     call CALLVAR(cxx_name)                     // cxx_name(Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -223,6 +224,7 @@ MACRO2(NO_ARG_RUNTIME_EXCEPTION_SAVE_EVERYTHING, c_name, cxx_name)
     pushl %fs:THREAD_SELF_OFFSET               // pass Thread::Current()
     CFI_ADJUST_CFA_OFFSET(4)
     call CALLVAR(cxx_name)                     // cxx_name(Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -236,6 +238,7 @@ MACRO2(ONE_ARG_RUNTIME_EXCEPTION, c_name, cxx_name)
     CFI_ADJUST_CFA_OFFSET(4)
     PUSH eax                                   // pass arg1
     call CALLVAR(cxx_name)                     // cxx_name(arg1, Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -250,6 +253,7 @@ MACRO2(TWO_ARG_RUNTIME_EXCEPTION_SAVE_EVERYTHING, c_name, cxx_name)
     PUSH ecx                                   // pass arg2
     PUSH eax                                   // pass arg1
     call CALLVAR(cxx_name)                     // cxx_name(arg1, arg2, Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -276,6 +280,7 @@ DEFINE_FUNCTION_CUSTOM_CFA art_quick_throw_null_pointer_exception_from_signal, 2
     CFI_ADJUST_CFA_OFFSET(4)
     PUSH eax                                              // pass arg1
     call SYMBOL(artThrowNullPointerExceptionFromSignal)   // (addr, self)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_quick_throw_null_pointer_exception_from_signal
 
@@ -644,6 +649,51 @@ DEFINE_FUNCTION art_quick_invoke_static_stub
     ret
 END_FUNCTION art_quick_invoke_static_stub
 
+    /*
+     * Long jump stub.
+     * Custom calling convention: On entry EAX is the long jump context. This is expected to
+     * be returned from a previous entrypoint call which threw an exception or deoptimized.
+     */
+DEFINE_FUNCTION art_quick_do_long_jump
+#if defined(__APPLE__)
+    int3
+    int3
+#else
+    // Reserve space for the gprs + fprs; add 16-byte stack alignment padding for call.
+    // (Note that the return address plus 3 args below shall take exactly 16 bytes.)
+    INCREASE_FRAME (X86_LONG_JUMP_CONTEXT_SIZE + 15) & ~15
+
+    lea 0(%esp), %esi                               // GPRS
+    lea X86_LONG_JUMP_GPRS_SIZE(%esp), %edx         // FPRS
+
+    PUSH_ARG edx
+    PUSH_ARG esi
+    PUSH_ARG eax
+    call SYMBOL(artContextCopyForLongJump)          // Context* context,
+                                                    // uintptr_t* gprs,
+                                                    // uintptr_t* fprs
+
+    DECREASE_FRAME 8                                // Remove the context and GPRS arguments.
+    POP_ARG edx                                     // Restore FPRS, make ESP point to GPRS.
+
+    // Address base of FPRs.
+    movsd 0(%edx), %xmm0     // Load up XMM0-XMM7.
+    movsd 8(%edx), %xmm1
+    movsd 16(%edx), %xmm2
+    movsd 24(%edx), %xmm3
+    movsd 32(%edx), %xmm4
+    movsd 40(%edx), %xmm5
+    movsd 48(%edx), %xmm6
+    movsd 56(%edx), %xmm7
+    popal            // Load all registers except ESP and EIP with values in gprs.
+    CFI_ADJUST_CFA_OFFSET(-(X86_LONG_JUMP_GPRS_SIZE - /*ESP*/ 4))
+
+    POP_ARG esp      // Load stack pointer.
+    CFI_DEF_CFA(esp, 4)
+    ret              // From higher in the stack pop EIP.
+#endif
+END_FUNCTION art_quick_do_long_jump
+
 MACRO3(ONE_ARG_DOWNCALL, c_name, cxx_name, return_macro)
     DEFINE_FUNCTION VAR(c_name)
     SETUP_SAVE_REFS_ONLY_FRAME ebx               // save ref containing registers for GC
@@ -737,18 +787,22 @@ MACRO2(ONE_ARG_SAVE_EVERYTHING_DOWNCALL_FOR_CLINIT, c_name, cxx_name)
 END_MACRO
 
 MACRO0(RETURN_OR_DEOPT_IF_RESULT_IS_NON_NULL_OR_DELIVER)
+    CFI_REMEMBER_STATE
     testl %eax, %eax                  // eax == 0 ?
     jz  1f                            // if eax == 0 goto 1
     DEOPT_OR_RETURN ebx, /*is_ref=*/1 // check if deopt is required
 1:                                    // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA esp, 4
     DELIVER_PENDING_EXCEPTION
 END_MACRO
 
 MACRO1(RETURN_OR_DEOPT_OR_DELIVER_PENDING_EXCEPTION, is_ref = 0)
+    CFI_REMEMBER_STATE
     cmpl MACRO_LITERAL(0),%fs:THREAD_EXCEPTION_OFFSET // exception field == 0 ?
     jne 1f                                            // if exception field != 0 goto 1
     DEOPT_OR_RETURN ebx, \is_ref                      // check if deopt is required
 1:                                                    // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA esp, 4
     DELIVER_PENDING_EXCEPTION
 END_MACRO
 
@@ -770,8 +824,19 @@ MACRO2(DEOPT_OR_RETURN, temp, is_ref = 0)
   CFI_ADJUST_CFA_OFFSET(4)
   call SYMBOL(artDeoptimizeIfNeeded)
   DECREASE_FRAME(16)                // pop arguments
+
+  CFI_REMEMBER_STATE
+  testl %eax, %eax
+  jnz 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   ret
+
+3:
+  // Deoptimize
+  CFI_RESTORE_STATE_AND_DEF_CFA esp, FRAME_SIZE_SAVE_EVERYTHING
+  call SYMBOL(art_quick_do_long_jump)
+  UNREACHABLE
 END_MACRO
 
 MACRO2(DEOPT_OR_RESTORE_SAVE_EVERYTHING_FRAME_AND_RETURN_EAX, temp, is_ref = 0)
@@ -791,18 +856,29 @@ MACRO2(DEOPT_OR_RESTORE_SAVE_EVERYTHING_FRAME_AND_RETURN_EAX, temp, is_ref = 0)
   CFI_ADJUST_CFA_OFFSET(4)
   call SYMBOL(artDeoptimizeIfNeeded)
   DECREASE_FRAME(16)                                // pop arguments
+
   CFI_REMEMBER_STATE
+  testl %eax, %eax
+  jnz 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   ret
+
+3:
+  // Deoptimize
   CFI_RESTORE_STATE_AND_DEF_CFA esp, FRAME_SIZE_SAVE_EVERYTHING
+  call SYMBOL(art_quick_do_long_jump)
+  UNREACHABLE
 END_MACRO
 
 
 MACRO0(RETURN_OR_DEOPT_IF_INT_RESULT_IS_ZERO_OR_DELIVER)
+    CFI_REMEMBER_STATE
     testl %eax, %eax               // eax == 0 ?
     jnz  1f                        // if eax != 0 goto 1
     DEOPT_OR_RETURN ebx            // check if deopt is needed
 1:                                 // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA esp, 4
     DELIVER_PENDING_EXCEPTION
 END_MACRO
 
@@ -1226,6 +1302,7 @@ DEFINE_FUNCTION art_quick_check_instance_of
     PUSH ecx                              // pass arg2
     PUSH eax                              // pass arg1
     call SYMBOL(artThrowClassCastExceptionForObject)  // (Object* src, Class* dest, Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_quick_check_instance_of
 
@@ -1302,6 +1379,7 @@ DEFINE_FUNCTION art_quick_aput_obj
     PUSH_ARG edx                  // Pass arg2 - value.
     PUSH_ARG eax                  // Pass arg1 - array.
     call SYMBOL(artThrowArrayStoreException) // (array, value, Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 
 #ifdef USE_READ_BARRIER
@@ -1358,8 +1436,19 @@ DEFINE_FUNCTION art_quick_test_suspend
     CFI_ADJUST_CFA_OFFSET(4)
     call SYMBOL(artTestSuspendFromCode)               // (Thread*)
     DECREASE_FRAME 16                                 // pop arguments
+
+    CFI_REMEMBER_STATE
+    testl %eax, %eax
+    jnz .Ltest_suspend_deoptimize
+
     RESTORE_SAVE_EVERYTHING_FRAME                     // restore frame up to return address
     ret                                               // return
+
+.Ltest_suspend_deoptimize:
+    // Deoptimize
+    CFI_RESTORE_STATE_AND_DEF_CFA esp, FRAME_SIZE_SAVE_EVERYTHING
+    call SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_quick_test_suspend
 
 DEFINE_FUNCTION art_quick_d2l
@@ -1703,12 +1792,13 @@ ONE_ARG_RUNTIME_EXCEPTION art_invoke_obsolete_method_stub, artInvokeObsoleteMeth
      */
 DEFINE_FUNCTION art_quick_deoptimize_from_compiled_code
     SETUP_SAVE_EVERYTHING_FRAME ebx
-    subl LITERAL(8), %esp                      // Align stack.
+    subl LITERAL(8), %esp                       // Align stack.
     CFI_ADJUST_CFA_OFFSET(8)
     pushl %fs:THREAD_SELF_OFFSET                // Pass Thread::Current().
     CFI_ADJUST_CFA_OFFSET(4)
     PUSH eax
     call SYMBOL(artDeoptimizeFromCompiledCode)  // (DeoptimizationKind, Thread*)
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_quick_deoptimize_from_compiled_code
 
@@ -2079,8 +2169,8 @@ DEFINE_FUNCTION art_quick_update_inline_cache
     movl INLINE_CACHE_CLASSES_OFFSET(%ebp), %eax
     cmpl %ecx, %eax
     je .Ldone
-    cmpl LITERAL(0), %eax
-    jne .Lentry2
+    testl %eax, %eax
+    jnz .Lentry2
     lock cmpxchg %ecx, INLINE_CACHE_CLASSES_OFFSET(%ebp)
     jz .Ldone
     jmp .Lentry1
@@ -2088,8 +2178,8 @@ DEFINE_FUNCTION art_quick_update_inline_cache
     movl (INLINE_CACHE_CLASSES_OFFSET+4)(%ebp), %eax
     cmpl %ecx, %eax
     je .Ldone
-    cmpl LITERAL(0), %eax
-    jne .Lentry3
+    testl %eax, %eax
+    jnz .Lentry3
     lock cmpxchg %ecx, (INLINE_CACHE_CLASSES_OFFSET+4)(%ebp)
     jz .Ldone
     jmp .Lentry2
@@ -2097,8 +2187,8 @@ DEFINE_FUNCTION art_quick_update_inline_cache
     movl (INLINE_CACHE_CLASSES_OFFSET+8)(%ebp), %eax
     cmpl %ecx, %eax
     je .Ldone
-    cmpl LITERAL(0), %eax
-    jne .Lentry4
+    testl %eax, %eax
+    jnz .Lentry4
     lock cmpxchg %ecx, (INLINE_CACHE_CLASSES_OFFSET+8)(%ebp)
     jz .Ldone
     jmp .Lentry3
@@ -2106,8 +2196,8 @@ DEFINE_FUNCTION art_quick_update_inline_cache
     movl (INLINE_CACHE_CLASSES_OFFSET+12)(%ebp), %eax
     cmpl %ecx, %eax
     je .Ldone
-    cmpl LITERAL(0), %eax
-    jne .Lentry5
+    testl %eax, %eax
+    jnz .Lentry5
     lock cmpxchg %ecx, (INLINE_CACHE_CLASSES_OFFSET+12)(%ebp)
     jz .Ldone
     jmp .Lentry4
@@ -2161,8 +2251,19 @@ DEFINE_FUNCTION art_quick_method_entry_hook
     addl LITERAL(16), %esp          // Pop arguments.
     CFI_ADJUST_CFA_OFFSET(-16)
 
+    CFI_REMEMBER_STATE
+    testl %eax, %eax
+    jnz .Lentryhook_deopt
+
+    // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+
+.Lentryhook_deopt:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA esp, FRAME_SIZE_SAVE_EVERYTHING
+    call SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_quick_method_entry_hook
 
 DEFINE_FUNCTION art_quick_method_exit_hook
@@ -2170,7 +2271,7 @@ DEFINE_FUNCTION art_quick_method_exit_hook
     SETUP_SAVE_EVERYTHING_FRAME_EDI_SAVED edi
 
     leal FRAME_SIZE_SAVE_EVERYTHING(%esp), %edi // Remember ArtMethod**
-    subl LITERAL(4), %esp                      // Align stack.
+    subl LITERAL(4), %esp                       // Align stack.
     CFI_ADJUST_CFA_OFFSET(4)
 
     PUSH_ARG edx                   // Save gpr return value. edx and eax need to be together
@@ -2187,13 +2288,26 @@ DEFINE_FUNCTION art_quick_method_exit_hook
     call SYMBOL(artMethodExitHook) // (Thread*, ArtMethod**, gpr_result*, fpr_result*,
                                    // frame_size)
 
-    // Return result could have been changed if it's a reference.
+    // Keep gpr_result in case the return result was changed.
     movl 20(%esp), %ecx
-    movl %ecx, (80+32)(%esp)
-    addl LITERAL(32), %esp         // Pop arguments and grp_result.
+
+    addl LITERAL(32), %esp         // Pop arguments and gpr_result.
     CFI_ADJUST_CFA_OFFSET(-32)
 
+    CFI_REMEMBER_STATE
+    testl %eax, %eax
+    jnz .Lexithook_deopt_or_exception
+
+    // Return result could have been changed if it's a reference.
+    movl %ecx, (80)(%esp)
+
     // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+
+.Lexithook_deopt_or_exception:
+    // Deoptimize or exception thrown.
+    CFI_RESTORE_STATE_AND_DEF_CFA esp, FRAME_SIZE_SAVE_EVERYTHING
+    call SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_quick_method_exit_hook
diff --git a/runtime/arch/x86_64/asm_support_x86_64.S b/runtime/arch/x86_64/asm_support_x86_64.S
index 7efa77b77e..bf0b958749 100644
--- a/runtime/arch/x86_64/asm_support_x86_64.S
+++ b/runtime/arch/x86_64/asm_support_x86_64.S
@@ -469,6 +469,8 @@ MACRO0(DELIVER_PENDING_EXCEPTION_FRAME_READY)
     // (Thread*) setup
     movq %gs:THREAD_SELF_OFFSET, %rdi
     call SYMBOL(artDeliverPendingExceptionFromCode)  // artDeliverPendingExceptionFromCode(Thread*)
+    movq %rax, %rdi                                  // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_MACRO
     /*
diff --git a/runtime/arch/x86_64/asm_support_x86_64.h b/runtime/arch/x86_64/asm_support_x86_64.h
index e4d7aa9457..8acce20aad 100644
--- a/runtime/arch/x86_64/asm_support_x86_64.h
+++ b/runtime/arch/x86_64/asm_support_x86_64.h
@@ -29,4 +29,11 @@
 #define SAVE_EVERYTHING_FRAME_RAX_OFFSET \
     (FRAME_SIZE_SAVE_EVERYTHING - CALLEE_SAVE_EVERYTHING_NUM_CORE_SPILLS * POINTER_SIZE)
 
+// Size of Context::gprs_.
+#define X86_64_LONG_JUMP_GPRS_SIZE 136
+// Size of Context::fprs_.
+#define X86_64_LONG_JUMP_FPRS_SIZE 128
+// Size of Context::gprs_ + Context::fprs_.
+#define X86_64_LONG_JUMP_CONTEXT_SIZE (X86_64_LONG_JUMP_GPRS_SIZE + X86_64_LONG_JUMP_FPRS_SIZE)
+
 #endif  // ART_RUNTIME_ARCH_X86_64_ASM_SUPPORT_X86_64_H_
diff --git a/runtime/arch/x86_64/context_x86_64.cc b/runtime/arch/x86_64/context_x86_64.cc
index 196f29f31d..d40395bc8b 100644
--- a/runtime/arch/x86_64/context_x86_64.cc
+++ b/runtime/arch/x86_64/context_x86_64.cc
@@ -100,13 +100,8 @@ void X86_64Context::SetFPR(uint32_t reg, uintptr_t value) {
   *fprs_[reg] = value;
 }
 
-extern "C" NO_RETURN void art_quick_do_long_jump(uintptr_t*, uintptr_t*);
-
-void X86_64Context::DoLongJump() {
+void X86_64Context::CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) {
 #if defined(__x86_64__)
-  uintptr_t gprs[kNumberOfCpuRegisters + 1];
-  uintptr_t fprs[kNumberOfFloatRegisters];
-
   for (size_t i = 0; i < kNumberOfCpuRegisters; ++i) {
     gprs[kNumberOfCpuRegisters - i - 1] = gprs_[i] != nullptr ? *gprs_[i] : kBadGprBase + i;
   }
@@ -118,8 +113,6 @@ void X86_64Context::DoLongJump() {
   uintptr_t rsp = gprs[kNumberOfCpuRegisters - RSP - 1] - sizeof(intptr_t);
   gprs[kNumberOfCpuRegisters] = rsp;
   *(reinterpret_cast<uintptr_t*>(rsp)) = rip_;
-
-  art_quick_do_long_jump(gprs, fprs);
 #else
   UNIMPLEMENTED(FATAL);
   UNREACHABLE();
diff --git a/runtime/arch/x86_64/context_x86_64.h b/runtime/arch/x86_64/context_x86_64.h
index 19e5f57345..cd2e027656 100644
--- a/runtime/arch/x86_64/context_x86_64.h
+++ b/runtime/arch/x86_64/context_x86_64.h
@@ -85,7 +85,7 @@ class X86_64Context final : public Context {
   void SetFPR(uint32_t reg, uintptr_t value) override;
 
   void SmashCallerSaves() override;
-  NO_RETURN void DoLongJump() override;
+  void CopyContextTo(uintptr_t* gprs, uintptr_t* fprs) override;
 
  private:
   // Pointers to register locations. Values are initialized to null or the special registers below.
diff --git a/runtime/arch/x86_64/entrypoints_init_x86_64.cc b/runtime/arch/x86_64/entrypoints_init_x86_64.cc
index f48ff9b541..9652f43c7f 100644
--- a/runtime/arch/x86_64/entrypoints_init_x86_64.cc
+++ b/runtime/arch/x86_64/entrypoints_init_x86_64.cc
@@ -120,6 +120,10 @@ void InitEntryPoints(JniEntryPoints* jpoints,
   qpoints->SetStringCompareTo(art_quick_string_compareto);
   qpoints->SetMemcpy(art_quick_memcpy);
 
+  // Invoke.
+  qpoints->SetInvokePolymorphicWithHiddenReceiver(
+      art_quick_invoke_polymorphic_with_hidden_receiver);
+
   // Read barrier.
   UpdateReadBarrierEntrypoints(qpoints, /*is_active=*/ false);
   qpoints->SetReadBarrierMarkReg04(nullptr);  // Cannot use register 4 (RSP) to pass arguments.
diff --git a/runtime/arch/x86_64/jni_entrypoints_x86_64.S b/runtime/arch/x86_64/jni_entrypoints_x86_64.S
index a7966db928..a635de8c28 100644
--- a/runtime/arch/x86_64/jni_entrypoints_x86_64.S
+++ b/runtime/arch/x86_64/jni_entrypoints_x86_64.S
@@ -458,11 +458,15 @@ DEFINE_FUNCTION art_jni_lock_object_no_inline
     ret
     .cfi_adjust_cfa_offset MANAGED_ARGS_SAVE_SIZE
 1:
-    // All args are irrelevant when throwing an exception. Remove the spill area.
-    DECREASE_FRAME MANAGED_ARGS_SAVE_SIZE
+    // All args are irrelevant when throwing an exception. Remove the spill area except for new
+    // padding to align stack.
+    DECREASE_FRAME MANAGED_ARGS_SAVE_SIZE - /*new padding*/ 8
     // Rely on the JNI transition frame constructed in the JNI stub.
     movq %gs:THREAD_SELF_OFFSET, %rdi     // Pass Thread::Current().
-    jmp  SYMBOL(artDeliverPendingExceptionFromCode)  // (Thread*); tail call.
+    call  SYMBOL(artDeliverPendingExceptionFromCode)  // (Thread*)
+    movq %rax, %rdi                       // pass Context*
+    call  SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_jni_lock_object_no_inline
 
     /*
diff --git a/runtime/arch/x86_64/quick_entrypoints_x86_64.S b/runtime/arch/x86_64/quick_entrypoints_x86_64.S
index 10e098d7db..b72890d444 100644
--- a/runtime/arch/x86_64/quick_entrypoints_x86_64.S
+++ b/runtime/arch/x86_64/quick_entrypoints_x86_64.S
@@ -201,6 +201,8 @@ MACRO2(NO_ARG_RUNTIME_EXCEPTION, c_name, cxx_name)
     // Outgoing argument set up
     movq %gs:THREAD_SELF_OFFSET, %rdi  // pass Thread::Current()
     call CALLVAR(cxx_name)             // cxx_name(Thread*)
+    movq %rax, %rdi                    // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -211,6 +213,8 @@ MACRO2(NO_ARG_RUNTIME_EXCEPTION_SAVE_EVERYTHING, c_name, cxx_name)
     // Outgoing argument set up
     movq %gs:THREAD_SELF_OFFSET, %rdi  // pass Thread::Current()
     call CALLVAR(cxx_name)             // cxx_name(Thread*)
+    movq %rax, %rdi                    // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -221,6 +225,8 @@ MACRO2(ONE_ARG_RUNTIME_EXCEPTION, c_name, cxx_name)
     // Outgoing argument set up
     movq %gs:THREAD_SELF_OFFSET, %rsi  // pass Thread::Current()
     call CALLVAR(cxx_name)             // cxx_name(arg1, Thread*)
+    movq %rax, %rdi                    // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -231,6 +237,8 @@ MACRO2(TWO_ARG_RUNTIME_EXCEPTION_SAVE_EVERYTHING, c_name, cxx_name)
     // Outgoing argument set up
     movq %gs:THREAD_SELF_OFFSET, %rdx  // pass Thread::Current()
     call CALLVAR(cxx_name)             // cxx_name(Thread*)
+    movq %rax, %rdi                    // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
     END_FUNCTION VAR(c_name)
 END_MACRO
@@ -254,6 +262,8 @@ DEFINE_FUNCTION_CUSTOM_CFA art_quick_throw_null_pointer_exception_from_signal, 2
     // Outgoing argument set up; RDI already contains the fault address.
     movq %gs:THREAD_SELF_OFFSET, %rsi  // pass Thread::Current()
     call SYMBOL(artThrowNullPointerExceptionFromSignal)  // (addr, self)
+    movq %rax, %rdi                    // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_quick_throw_null_pointer_exception_from_signal
 
@@ -591,52 +601,61 @@ END_FUNCTION art_quick_invoke_static_stub
 
     /*
      * Long jump stub.
-     * On entry:
-     *   rdi = gprs
-     *   rsi = fprs
+     * On entry rdi is the long jump context. This is expected to be returned from a previous
+     * entrypoint call which threw an exception or deoptimized.
      */
 DEFINE_FUNCTION art_quick_do_long_jump
 #if defined(__APPLE__)
     int3
     int3
 #else
+    // Reserve space for the gprs + fprs;
+    INCREASE_FRAME X86_64_LONG_JUMP_CONTEXT_SIZE
+
+    leaq 0(%rsp), %rsi                              // GPRS
+    leaq X86_64_LONG_JUMP_GPRS_SIZE(%rsp), %rdx     // FPRS
+
+    call SYMBOL(artContextCopyForLongJump)          // Context* context,
+                                                    // uintptr_t* gprs,
+                                                    // uintptr_t* fprs
+
     // Restore FPRs.
-    movq 0(%rsi), %xmm0
-    movq 8(%rsi), %xmm1
-    movq 16(%rsi), %xmm2
-    movq 24(%rsi), %xmm3
-    movq 32(%rsi), %xmm4
-    movq 40(%rsi), %xmm5
-    movq 48(%rsi), %xmm6
-    movq 56(%rsi), %xmm7
-    movq 64(%rsi), %xmm8
-    movq 72(%rsi), %xmm9
-    movq 80(%rsi), %xmm10
-    movq 88(%rsi), %xmm11
-    movq 96(%rsi), %xmm12
-    movq 104(%rsi), %xmm13
-    movq 112(%rsi), %xmm14
-    movq 120(%rsi), %xmm15
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+0)(%rsp), %xmm0
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+8)(%rsp), %xmm1
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+16)(%rsp), %xmm2
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+24)(%rsp), %xmm3
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+32)(%rsp), %xmm4
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+40)(%rsp), %xmm5
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+48)(%rsp), %xmm6
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+56)(%rsp), %xmm7
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+64)(%rsp), %xmm8
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+72)(%rsp), %xmm9
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+80)(%rsp), %xmm10
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+88)(%rsp), %xmm11
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+96)(%rsp), %xmm12
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+104)(%rsp), %xmm13
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+112)(%rsp), %xmm14
+    movq (X86_64_LONG_JUMP_GPRS_SIZE+120)(%rsp), %xmm15
     // Restore FPRs.
-    movq %rdi, %rsp   // RSP points to gprs.
     // Load all registers except RSP and RIP with values in gprs.
-    popq %r15
-    popq %r14
-    popq %r13
-    popq %r12
-    popq %r11
-    popq %r10
-    popq %r9
-    popq %r8
-    popq %rdi
-    popq %rsi
-    popq %rbp
+    POP_ARG r15
+    POP_ARG r14
+    POP_ARG r13
+    POP_ARG r12
+    POP_ARG r11
+    POP_ARG r10
+    POP_ARG r9
+    POP_ARG r8
+    POP_ARG rdi
+    POP_ARG rsi
+    POP_ARG rbp
     addq LITERAL(8), %rsp   // Skip rsp
-    popq %rbx
-    popq %rdx
-    popq %rcx
-    popq %rax
+    POP_ARG rbx
+    POP_ARG rdx
+    POP_ARG rcx
+    POP_ARG rax
     popq %rsp      // Load stack pointer.
+    CFI_DEF_CFA(rsp, 8)
     ret            // From higher in the stack pop rip.
 #endif  // __APPLE__
 END_FUNCTION art_quick_do_long_jump
@@ -709,20 +728,24 @@ MACRO2(ONE_ARG_SAVE_EVERYTHING_DOWNCALL_FOR_CLINIT, c_name, cxx_name)
 END_MACRO
 
 MACRO0(RETURN_OR_DEOPT_IF_RESULT_IS_NON_NULL_OR_DELIVER)
+    CFI_REMEMBER_STATE
     testq %rax, %rax               // rax == 0 ?
     jz  1f                         // if rax == 0 goto 1
     DEOPT_OR_RETURN /*is_ref=*/1   // Check if deopt is required
 1:                                 // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA rsp, 8
     DELIVER_PENDING_EXCEPTION
 END_MACRO
 
 
 MACRO1(RETURN_OR_DEOPT_OR_DELIVER_PENDING_EXCEPTION, is_ref = 0)
     movq %gs:THREAD_EXCEPTION_OFFSET, %rcx // get exception field
+    CFI_REMEMBER_STATE
     testq %rcx, %rcx               // rcx == 0 ?
     jnz 1f                         // if rcx != 0 goto 1
     DEOPT_OR_RETURN \is_ref        // Check if deopt is required
 1:                                 // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA rsp, 8
     DELIVER_PENDING_EXCEPTION
 END_MACRO
 
@@ -740,8 +763,20 @@ MACRO1(DEOPT_OR_RETURN, is_ref = 0)
   movq %rax, %rsi                      // pass the result
   movq %gs:THREAD_SELF_OFFSET, %rdi    // pass Thread::Current
   call SYMBOL(artDeoptimizeIfNeeded)
+
+  CFI_REMEMBER_STATE
+  testq %rax, %rax
+  jnz 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   ret
+
+3:
+  // Deoptimize.
+  CFI_RESTORE_STATE_AND_DEF_CFA rsp, FRAME_SIZE_SAVE_EVERYTHING
+  movq %rax, %rdi                      // pass Context*
+  call SYMBOL(art_quick_do_long_jump)
+  UNREACHABLE
 END_MACRO
 
 MACRO1(DEOPT_OR_RESTORE_SAVE_EVERYTHING_FRAME_AND_RETURN_RAX, is_ref = 0)
@@ -757,19 +792,31 @@ MACRO1(DEOPT_OR_RESTORE_SAVE_EVERYTHING_FRAME_AND_RETURN_RAX, is_ref = 0)
   movq %rax, %rsi                                   // pass the result
   movq %gs:THREAD_SELF_OFFSET, %rdi                 // pass Thread::Current
   call SYMBOL(artDeoptimizeIfNeeded)
+
   CFI_REMEMBER_STATE
+  testq %rax, %rax
+  jnz 3f
+
   RESTORE_SAVE_EVERYTHING_FRAME
   ret
+
+3:
+  // Deoptimize.
   CFI_RESTORE_STATE_AND_DEF_CFA rsp, FRAME_SIZE_SAVE_EVERYTHING
+  movq %rax, %rdi                                   // pass Context*
+  call SYMBOL(art_quick_do_long_jump)
+  UNREACHABLE
 END_MACRO
 
 
 
 MACRO0(RETURN_OR_DEOPT_IF_INT_RESULT_IS_ZERO_OR_DELIVER)
+    CFI_REMEMBER_STATE
     testl %eax, %eax               // eax == 0 ?
     jnz  1f                        // if eax != 0 goto 1
     DEOPT_OR_RETURN                // Check if we need a deopt
 1:                                 // deliver exception on current thread
+    CFI_RESTORE_STATE_AND_DEF_CFA rsp, 8
     DELIVER_PENDING_EXCEPTION
 END_MACRO
 
@@ -1142,8 +1189,8 @@ DEFINE_FUNCTION art_quick_check_instance_of
     CFI_ADJUST_CFA_OFFSET(8)
     SETUP_FP_CALLEE_SAVE_FRAME
     call SYMBOL(artInstanceOfFromCode)  // (Object* obj, Class* ref_klass)
-    testq %rax, %rax
     CFI_REMEMBER_STATE
+    testq %rax, %rax
     jz .Lthrow_class_cast_exception   // jump forward if not assignable
     RESTORE_FP_CALLEE_SAVE_FRAME
     addq LITERAL(24), %rsp            // pop arguments
@@ -1162,6 +1209,8 @@ DEFINE_FUNCTION art_quick_check_instance_of
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME // save all registers as basis for long jump context
     mov %gs:THREAD_SELF_OFFSET, %rdx  // pass Thread::Current()
     call SYMBOL(artThrowClassCastExceptionForObject)  // (Object* src, Class* dest, Thread*)
+    movq %rax, %rdi                   // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_quick_check_instance_of
 
@@ -1227,10 +1276,12 @@ DEFINE_FUNCTION art_quick_aput_obj
 .Laput_obj_throw_array_store_exception:
     SETUP_SAVE_ALL_CALLEE_SAVES_FRAME  // Save all registers as basis for long jump context.
     // Outgoing argument set up.
-    movq %rdx, %rsi                         // Pass arg 2 = value.
-    movq %gs:THREAD_SELF_OFFSET, %rdx       // Pass arg 3 = Thread::Current().
-                                            // Pass arg 1 = array.
+    movq %rdx, %rsi                          // Pass arg 2 = value.
+    movq %gs:THREAD_SELF_OFFSET, %rdx        // Pass arg 3 = Thread::Current().
+                                             // Pass arg 1 = array.
     call SYMBOL(artThrowArrayStoreException) // (array, value, Thread*)
+    movq %rax, %rdi                          // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 
 #ifdef USE_READ_BARRIER
@@ -1269,8 +1320,21 @@ DEFINE_FUNCTION art_quick_test_suspend
     // Outgoing argument set up
     movq %gs:THREAD_SELF_OFFSET, %rdi           // pass Thread::Current()
     call SYMBOL(artTestSuspendFromCode)         // (Thread*)
+
+    CFI_REMEMBER_STATE
+    testq %rax, %rax
+    jnz .Ltest_suspend_deoptimize
+
+    // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME               // restore frame up to return address
     ret
+
+.Ltest_suspend_deoptimize:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA rsp, FRAME_SIZE_SAVE_EVERYTHING
+    movq %rax, %rdi                             // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_quick_test_suspend
 
 UNIMPLEMENTED art_quick_ldiv
@@ -1569,6 +1633,8 @@ DEFINE_FUNCTION art_quick_deoptimize_from_compiled_code
                                                 // Stack should be aligned now.
     movq %gs:THREAD_SELF_OFFSET, %rsi           // Pass Thread.
     call SYMBOL(artDeoptimizeFromCompiledCode)  // (DeoptimizationKind, Thread*)
+    movq %rax, %rdi                             // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
     UNREACHABLE
 END_FUNCTION art_quick_deoptimize_from_compiled_code
 
@@ -1904,6 +1970,25 @@ DEFINE_FUNCTION art_quick_invoke_polymorphic
     RETURN_OR_DELIVER_PENDING_EXCEPTION
 END_FUNCTION art_quick_invoke_polymorphic
 
+    /*
+     * Slow path for MethodHandle.invokeExact intrinsic.
+     * That intrinsic has a custom calling convention: the argument allocation doesn't start from
+     * the receiver (MethodHandle) object, but from the argument following it. That's done to match
+     * expectation of the underlying method when MethodHandle targets a method. That also affects
+     * the way arguments are spilled onto the stack.
+     */
+DEFINE_FUNCTION art_quick_invoke_polymorphic_with_hidden_receiver
+                                                        // On entry: RDI := receiver
+    SETUP_SAVE_REFS_AND_ARGS_FRAME                      // save callee saves
+    movq %gs:THREAD_SELF_OFFSET, %rsi                   // RSI := Thread (self)
+    movq %rsp, %rdx                                     // RDX := pass SP
+    call SYMBOL(artInvokePolymorphicWithHiddenReceiver) // invoke with (receiver, self, SP)
+                                                        // save the code pointer
+    RESTORE_SAVE_REFS_AND_ARGS_FRAME
+    movq %rax, %xmm0                               // Result is in RAX. Copy to FP result register.
+    RETURN_OR_DELIVER_PENDING_EXCEPTION
+END_FUNCTION art_quick_invoke_polymorphic_with_hidden_receiver
+
 DEFINE_FUNCTION art_quick_invoke_custom
     SETUP_SAVE_REFS_AND_ARGS_FRAME                 // save callee saves
                                                    // RDI := call_site_index
@@ -1998,11 +2083,22 @@ DEFINE_FUNCTION art_quick_method_entry_hook
     movq FRAME_SIZE_SAVE_EVERYTHING(%rsp), %rdi // pass ArtMethod
     movq %gs:THREAD_SELF_OFFSET, %rsi           // pass Thread::Current()
     movq %rsp, %rdx                             // SP
+    call SYMBOL(artMethodEntryHook)             // (ArtMethod*, Thread*, sp)
 
-    call SYMBOL(artMethodEntryHook)              // (ArtMethod*, Thread*, sp)
+    CFI_REMEMBER_STATE
+    testq %rax, %rax
+    jnz .Lentryhook_deopt
 
+    // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+
+.Lentryhook_deopt:
+    // Deoptimize.
+    CFI_RESTORE_STATE_AND_DEF_CFA rsp, FRAME_SIZE_SAVE_EVERYTHING
+    movq %rax, %rdi                             // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_quick_method_entry_hook
 
 // On entry, method is at the bottom of the stack.
@@ -2018,7 +2114,18 @@ DEFINE_FUNCTION art_quick_method_exit_hook
     call SYMBOL(artMethodExitHook)              // (Thread*, ArtMethod**, gpr_res*, fpr_res*,
                                                 //  frame_size)
 
+    CFI_REMEMBER_STATE
+    testq %rax, %rax
+    jnz .Lexithook_deopt_or_exception
+
     // Normal return.
     RESTORE_SAVE_EVERYTHING_FRAME
     ret
+
+.Lexithook_deopt_or_exception:
+    // Deoptimize or exception thrown.
+    CFI_RESTORE_STATE_AND_DEF_CFA rsp, FRAME_SIZE_SAVE_EVERYTHING
+    movq %rax, %rdi                             // pass Context*
+    call SYMBOL(art_quick_do_long_jump)
+    UNREACHABLE
 END_FUNCTION art_quick_method_exit_hook
diff --git a/runtime/art_method-inl.h b/runtime/art_method-inl.h
index d87040ab49..2b88b733f7 100644
--- a/runtime/art_method-inl.h
+++ b/runtime/art_method-inl.h
@@ -31,6 +31,8 @@
 #include "dex/signature.h"
 #include "gc_root-inl.h"
 #include "imtable-inl.h"
+#include "jit/jit.h"
+#include "jit/jit_code_cache-inl.h"
 #include "jit/jit_options.h"
 #include "mirror/class-inl.h"
 #include "mirror/dex_cache-inl.h"
@@ -619,6 +621,13 @@ void ArtMethod::VisitRoots(RootVisitorType& visitor, PointerSize pointer_size) {
       }
     }
   }
+
+  // JIT-ted code can hold references to heap objects like MethodType-s. Visiting them here to
+  // treat them as strongly reachable.
+  Runtime* runtime = Runtime::Current();
+  if (runtime->GetJit() != nullptr) {
+    runtime->GetJit()->GetCodeCache()->VisitRootTables(this, visitor);
+  }
 }
 
 template<typename RootVisitorType>
@@ -664,22 +673,6 @@ void ArtMethod::VisitArrayRoots(RootVisitorType& visitor,
   }
 }
 
-template <typename Visitor>
-inline void ArtMethod::UpdateEntrypoints(const Visitor& visitor, PointerSize pointer_size) {
-  if (IsNative()) {
-    const void* old_native_code = GetEntryPointFromJniPtrSize(pointer_size);
-    const void* new_native_code = visitor(old_native_code);
-    if (old_native_code != new_native_code) {
-      SetEntryPointFromJniPtrSize(new_native_code, pointer_size);
-    }
-  }
-  const void* old_code = GetEntryPointFromQuickCompiledCodePtrSize(pointer_size);
-  const void* new_code = visitor(old_code);
-  if (old_code != new_code) {
-    SetEntryPointFromQuickCompiledCodePtrSize(new_code, pointer_size);
-  }
-}
-
 template <ReadBarrierOption kReadBarrierOption>
 inline bool ArtMethod::StillNeedsClinitCheck() {
   if (!NeedsClinitCheckBeforeCall()) {
diff --git a/runtime/art_method.cc b/runtime/art_method.cc
index dac2c08a46..d4bed097ec 100644
--- a/runtime/art_method.cc
+++ b/runtime/art_method.cc
@@ -38,6 +38,7 @@
 #include "gc/accounting/card_table-inl.h"
 #include "hidden_api.h"
 #include "interpreter/interpreter.h"
+#include "intrinsics_enum.h"
 #include "jit/jit.h"
 #include "jit/jit_code_cache.h"
 #include "jit/profiling_info.h"
@@ -187,12 +188,14 @@ void ArtMethod::ThrowInvocationTimeError(ObjPtr<mirror::Object> receiver) {
     // IllegalAccessError.
     DCHECK(IsAbstract());
     ObjPtr<mirror::Class> current = receiver->GetClass();
+    std::string_view name = GetNameView();
+    Signature signature = GetSignature();
     while (current != nullptr) {
       for (ArtMethod& method : current->GetDeclaredMethodsSlice(kRuntimePointerSize)) {
         ArtMethod* np_method = method.GetInterfaceMethodIfProxy(kRuntimePointerSize);
         if (!np_method->IsStatic() &&
-            np_method->GetNameView() == GetNameView() &&
-            np_method->GetSignature() == GetSignature()) {
+            np_method->GetNameView() == name &&
+            np_method->GetSignature() == signature) {
           if (!np_method->IsPublic()) {
             ThrowIllegalAccessErrorForImplementingMethod(receiver->GetClass(), np_method, this);
             return;
@@ -340,9 +343,6 @@ uint32_t ArtMethod::FindCatchBlock(Handle<mirror::Class> exception_type,
       // removed by a pro-guard like tool.
       // Note: this is not RI behavior. RI would have failed when loading the class.
       self->ClearException();
-      // Delete any long jump context as this routine is called during a stack walk which will
-      // release its in use context at the end.
-      delete self->GetLongJumpContext();
       LOG(WARNING) << "Unresolved exception class when finding catch block: "
         << DescriptorToDot(GetTypeDescriptorFromTypeIdx(iter_type_idx));
     } else if (iter_exception_type->IsAssignableFrom(exception_type.Get())) {
@@ -718,14 +718,15 @@ const void* ArtMethod::GetOatMethodQuickCode(PointerSize pointer_size) {
   return nullptr;
 }
 
-void ArtMethod::SetIntrinsic(uint32_t intrinsic) {
+void ArtMethod::SetIntrinsic(Intrinsics intrinsic) {
   // Currently we only do intrinsics for static/final methods or methods of final
   // classes. We don't set kHasSingleImplementation for those methods.
   DCHECK(IsStatic() || IsFinal() || GetDeclaringClass()->IsFinal()) <<
       "Potential conflict with kAccSingleImplementation";
   static const int kAccFlagsShift = CTZ(kAccIntrinsicBits);
-  DCHECK_LE(intrinsic, kAccIntrinsicBits >> kAccFlagsShift);
-  uint32_t intrinsic_bits = intrinsic << kAccFlagsShift;
+  uint32_t intrinsic_u32 = enum_cast<uint32_t>(intrinsic);
+  DCHECK_LE(intrinsic_u32, kAccIntrinsicBits >> kAccFlagsShift);
+  uint32_t intrinsic_bits = intrinsic_u32 << kAccFlagsShift;
   uint32_t new_value = (GetAccessFlags() & ~kAccIntrinsicBits) | kAccIntrinsic | intrinsic_bits;
   if (kIsDebugBuild) {
     uint32_t java_flags = (GetAccessFlags() & kAccJavaFlagsMask);
@@ -924,40 +925,4 @@ ALWAYS_INLINE static inline void DoGetAccessFlagsHelper(ArtMethod* method)
         method->GetDeclaringClass<kReadBarrierOption>()->IsErroneous());
 }
 
-template <typename T>
-bool CompareExchange(uintptr_t ptr, uintptr_t old_value, uintptr_t new_value) {
-  std::atomic<T>* atomic_addr = reinterpret_cast<std::atomic<T>*>(ptr);
-  T cast_old_value = dchecked_integral_cast<T>(old_value);
-  return reinterpret_cast<const void*>(
-      atomic_addr->compare_exchange_strong(cast_old_value,
-                                           dchecked_integral_cast<T>(new_value),
-                                           std::memory_order_relaxed));
-}
-
-void ArtMethod::SetEntryPointFromQuickCompiledCodePtrSize(
-    const void* entry_point_from_quick_compiled_code, PointerSize pointer_size) {
-  const void* current_entry_point = GetEntryPointFromQuickCompiledCodePtrSize(pointer_size);
-  if (current_entry_point == entry_point_from_quick_compiled_code) {
-    return;
-  }
-
-  // Do an atomic exchange to avoid potentially unregistering JIT code twice.
-  MemberOffset offset = EntryPointFromQuickCompiledCodeOffset(pointer_size);
-  uintptr_t old_value = reinterpret_cast<uintptr_t>(current_entry_point);
-  uintptr_t new_value = reinterpret_cast<uintptr_t>(entry_point_from_quick_compiled_code);
-  uintptr_t ptr = reinterpret_cast<uintptr_t>(this) + offset.Uint32Value();
-  bool success = (pointer_size == PointerSize::k32)
-      ? CompareExchange<uint32_t>(ptr, old_value, new_value)
-      : CompareExchange<uint64_t>(ptr, old_value, new_value);
-
-  // If we successfully updated the entrypoint and the old entrypoint is JITted
-  // code, register the old entrypoint as zombie.
-  jit::Jit* jit = Runtime::Current()->GetJit();
-  if (success &&
-      jit != nullptr &&
-      jit->GetCodeCache()->ContainsPc(current_entry_point)) {
-    jit->GetCodeCache()->AddZombieCode(this, current_entry_point);
-  }
-}
-
 }  // namespace art
diff --git a/runtime/art_method.h b/runtime/art_method.h
index 0a6cda65fd..30dc09f67f 100644
--- a/runtime/art_method.h
+++ b/runtime/art_method.h
@@ -35,6 +35,7 @@
 #include "dex/primitive.h"
 #include "interpreter/mterp/nterp.h"
 #include "gc_root.h"
+#include "intrinsics_enum.h"
 #include "obj_ptr.h"
 #include "offsets.h"
 #include "read_barrier_option.h"
@@ -246,16 +247,16 @@ class EXPORT ArtMethod final {
     return (access_flags & kAccIntrinsic) != 0;
   }
 
-  ALWAYS_INLINE void SetIntrinsic(uint32_t intrinsic) REQUIRES_SHARED(Locks::mutator_lock_);
+  ALWAYS_INLINE void SetIntrinsic(Intrinsics intrinsic) REQUIRES_SHARED(Locks::mutator_lock_);
 
-  uint32_t GetIntrinsic() const {
+  Intrinsics GetIntrinsic() const {
     static const int kAccFlagsShift = CTZ(kAccIntrinsicBits);
     static_assert(IsPowerOfTwo((kAccIntrinsicBits >> kAccFlagsShift) + 1),
                   "kAccIntrinsicBits are not continuous");
     static_assert((kAccIntrinsic & kAccIntrinsicBits) == 0,
                   "kAccIntrinsic overlaps kAccIntrinsicBits");
     DCHECK(IsIntrinsic());
-    return (GetAccessFlags() & kAccIntrinsicBits) >> kAccFlagsShift;
+    return static_cast<Intrinsics>((GetAccessFlags() & kAccIntrinsicBits) >> kAccFlagsShift);
   }
 
   void SetNotIntrinsic() REQUIRES_SHARED(Locks::mutator_lock_);
@@ -779,7 +780,11 @@ class EXPORT ArtMethod final {
   }
   ALWAYS_INLINE void SetEntryPointFromQuickCompiledCodePtrSize(
       const void* entry_point_from_quick_compiled_code, PointerSize pointer_size)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    SetNativePointer(EntryPointFromQuickCompiledCodeOffset(pointer_size),
+                     entry_point_from_quick_compiled_code,
+                     pointer_size);
+  }
 
   static constexpr MemberOffset DataOffset(PointerSize pointer_size) {
     return MemberOffset(PtrSizedFieldsOffset(pointer_size) + OFFSETOF_MEMBER(
@@ -1048,11 +1053,6 @@ class EXPORT ArtMethod final {
   std::string JniLongName()
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Update entry points by passing them through the visitor.
-  template <typename Visitor>
-  ALWAYS_INLINE void UpdateEntrypoints(const Visitor& visitor, PointerSize pointer_size)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
   // Visit the individual members of an ArtMethod.  Used by imgdiag.
   // As imgdiag does not support mixing instruction sets or pointer sizes (e.g., using imgdiag32
   // to inspect 64-bit images, etc.), we can go beneath the accessors directly to the class members.
@@ -1209,8 +1209,6 @@ class EXPORT ArtMethod final {
   // Used by GetName and GetNameView to share common code.
   const char* GetRuntimeMethodName() REQUIRES_SHARED(Locks::mutator_lock_);
 
-  friend class RuntimeImageHelper;  // For SetNativePointer.
-
   DISALLOW_COPY_AND_ASSIGN(ArtMethod);  // Need to use CopyFrom to deal with 32 vs 64 bits.
 };
 
diff --git a/runtime/art_standalone_runtime_tests.xml b/runtime/art_standalone_runtime_tests.xml
index d0e959c345..7e61731893 100644
--- a/runtime/art_standalone_runtime_tests.xml
+++ b/runtime/art_standalone_runtime_tests.xml
@@ -59,10 +59,11 @@
         <option name="push" value="art-gtest-jars-StaticLeafMethods.jar->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-StaticLeafMethods.jar" />
         <option name="push" value="art-gtest-jars-Statics.jar->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-Statics.jar" />
         <option name="push" value="art-gtest-jars-StaticsFromCode.jar->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-StaticsFromCode.jar" />
-        <option name="push" value="art-gtest-jars-Transaction.jar->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-Transaction.jar" />
         <option name="push" value="art-gtest-jars-VerifierDeps.dex->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-VerifierDeps.dex" />
         <option name="push" value="art-gtest-jars-VerifierDepsMulti.dex->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-VerifierDepsMulti.dex" />
         <option name="push" value="art-gtest-jars-XandY.jar->/data/local/tmp/art_standalone_runtime_tests/art-gtest-jars-XandY.jar" />
+        <option name="push" value="dex_verification_fuzzer_corpus.zip->/data/local/tmp/art_standalone_runtime_tests/dex_verification_fuzzer_corpus.zip" />
+        <option name="push" value="class_verification_fuzzer_corpus.zip->/data/local/tmp/art_standalone_runtime_tests/class_verification_fuzzer_corpus.zip" />
     </target_preparer>
 
     <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
diff --git a/runtime/base/gc_visited_arena_pool.cc b/runtime/base/gc_visited_arena_pool.cc
index 57606d11a6..89e4d7c65a 100644
--- a/runtime/base/gc_visited_arena_pool.cc
+++ b/runtime/base/gc_visited_arena_pool.cc
@@ -49,25 +49,9 @@ TrackedArena::TrackedArena(uint8_t* start, size_t size, bool pre_zygote_fork, bo
   }
 }
 
-void TrackedArena::ReleasePages(uint8_t* begin, size_t size, bool pre_zygote_fork) {
-  DCHECK_ALIGNED_PARAM(begin, gPageSize);
-  // Userfaultfd GC uses MAP_SHARED mappings for linear-alloc and therefore
-  // MADV_DONTNEED will not free the pages from page cache. Therefore use
-  // MADV_REMOVE instead, which is meant for this purpose.
-  // Arenas allocated pre-zygote fork are private anonymous and hence must be
-  // released using MADV_DONTNEED.
-  if (!gUseUserfaultfd || pre_zygote_fork ||
-      (madvise(begin, size, MADV_REMOVE) == -1 && errno == EINVAL)) {
-    // MADV_REMOVE fails if invoked on anonymous mapping, which could happen
-    // if the arena is released before userfaultfd-GC starts using memfd. So
-    // use MADV_DONTNEED.
-    ZeroAndReleaseMemory(begin, size);
-  }
-}
-
 void TrackedArena::Release() {
   if (bytes_allocated_ > 0) {
-    ReleasePages(Begin(), Size(), pre_zygote_fork_);
+    ZeroAndReleaseMemory(Begin(), Size());
     if (first_obj_array_.get() != nullptr) {
       std::fill_n(first_obj_array_.get(), DivideByPageSize(Size()), nullptr);
     }
@@ -210,7 +194,7 @@ void GcVisitedArenaPool::FreeSingleObjArena(uint8_t* addr) {
   if (zygote_arena) {
     free(addr);
   } else {
-    TrackedArena::ReleasePages(addr, size, /*pre_zygote_fork=*/false);
+    ZeroAndReleaseMemory(addr, size);
     WriterMutexLock wmu(self, lock_);
     FreeRangeLocked(addr, size);
   }
@@ -383,7 +367,7 @@ void GcVisitedArenaPool::FreeArenaChain(Arena* first) {
   for (auto& iter : free_ranges) {
     // No need to madvise pre-zygote-fork arenas as they will munmapped below.
     if (!std::get<2>(iter)) {
-      TrackedArena::ReleasePages(std::get<0>(iter), std::get<1>(iter), /*pre_zygote_fork=*/false);
+      ZeroAndReleaseMemory(std::get<0>(iter), std::get<1>(iter));
     }
   }
 
diff --git a/runtime/base/gc_visited_arena_pool.h b/runtime/base/gc_visited_arena_pool.h
index 4caaaf4b8f..ac98563d67 100644
--- a/runtime/base/gc_visited_arena_pool.h
+++ b/runtime/base/gc_visited_arena_pool.h
@@ -112,11 +112,6 @@ class TrackedArena final : public Arena {
   }
   bool IsWaitingForDeletion() const { return waiting_for_deletion_; }
 
-  // Madvise the pages in the given range. 'begin' is expected to be page
-  // aligned.
-  // TODO: Remove this once we remove the shmem (minor-fault) code in
-  // userfaultfd GC and directly use ZeroAndReleaseMemory().
-  static void ReleasePages(uint8_t* begin, size_t size, bool pre_zygote_fork);
   void Release() override;
   bool IsPreZygoteForkArena() const { return pre_zygote_fork_; }
   bool IsSingleObjectArena() const { return first_obj_array_.get() == nullptr; }
diff --git a/runtime/base/locks.cc b/runtime/base/locks.cc
index 011d46e6b4..2c10bfd700 100644
--- a/runtime/base/locks.cc
+++ b/runtime/base/locks.cc
@@ -64,6 +64,7 @@ Mutex* Locks::runtime_shutdown_lock_ = nullptr;
 Mutex* Locks::runtime_thread_pool_lock_ = nullptr;
 Mutex* Locks::cha_lock_ = nullptr;
 Mutex* Locks::jit_lock_ = nullptr;
+ReaderWriterMutex* Locks::jit_mutator_lock_ = nullptr;
 Mutex* Locks::subtype_check_lock_ = nullptr;
 Mutex* Locks::thread_list_lock_ = nullptr;
 ConditionVariable* Locks::thread_exit_cond_ = nullptr;
@@ -92,7 +93,7 @@ static void BackOff(uint32_t i) {
     volatile uint32_t x = 0;
     const uint32_t spin_count = 10 * i;
     for (uint32_t spin = 0; spin < spin_count; ++spin) {
-      ++x;  // Volatile; hence should not be optimized away.
+      x = x + 1;  // Volatile; hence should not be optimized away.
     }
     // TODO: Consider adding x86 PAUSE and/or ARM YIELD here.
   } else if (i <= kYieldMax) {
@@ -151,6 +152,7 @@ void Locks::Init() {
     DCHECK(profiler_lock_ != nullptr);
     DCHECK(cha_lock_ != nullptr);
     DCHECK(jit_lock_ != nullptr);
+    DCHECK(jit_mutator_lock_ != nullptr);
     DCHECK(subtype_check_lock_ != nullptr);
     DCHECK(thread_list_lock_ != nullptr);
     DCHECK(thread_suspend_count_lock_ != nullptr);
@@ -316,7 +318,10 @@ void Locks::Init() {
     DCHECK(jit_lock_ == nullptr);
     jit_lock_ = new Mutex("Jit code cache", current_lock_level);
 
-    UPDATE_CURRENT_LOCK_LEVEL(kCHALock);
+    UPDATE_CURRENT_LOCK_LEVEL(kJitCodeCacheMutatorAndCHALock);
+    DCHECK(jit_mutator_lock_ == nullptr);
+    jit_mutator_lock_ = new ReaderWriterMutex("Jit code cache for mutator", current_lock_level);
+
     DCHECK(cha_lock_ == nullptr);
     cha_lock_ = new Mutex("CHA lock", current_lock_level);
 
diff --git a/runtime/base/locks.h b/runtime/base/locks.h
index d6a59f8b83..8dcad7a091 100644
--- a/runtime/base/locks.h
+++ b/runtime/base/locks.h
@@ -67,7 +67,7 @@ enum LockLevel : uint8_t {
   kMarkSweepMarkStackLock,
   // Can be held while GC related work is done, and thus must be above kMarkSweepMarkStackLock
   kThreadWaitLock,
-  kCHALock,
+  kJitCodeCacheMutatorAndCHALock,
   kRosAllocGlobalLock,
   kRosAllocBracketLock,
   kRosAllocBulkFreeLock,
@@ -336,9 +336,12 @@ class EXPORT Locks {
   // GetThreadLocalStorage.
   static Mutex* custom_tls_lock_ ACQUIRED_AFTER(jni_function_table_lock_);
 
-  // Guard access to any JIT data structure.
+  // Guard access to JIT data structures mostly used by the JIT thread.
   static Mutex* jit_lock_ ACQUIRED_AFTER(custom_tls_lock_);
 
+  // Guard access to any JIT data structure that mutators can also access.
+  static ReaderWriterMutex* jit_mutator_lock_ ACQUIRED_AFTER(custom_tls_lock_);
+
   // Guards Class Hierarchy Analysis (CHA).
   static Mutex* cha_lock_ ACQUIRED_AFTER(jit_lock_);
 
diff --git a/runtime/base/mutex.cc b/runtime/base/mutex.cc
index 831c53599d..0abe9667f8 100644
--- a/runtime/base/mutex.cc
+++ b/runtime/base/mutex.cc
@@ -109,7 +109,7 @@ static void BackOff(uint32_t i) {
     volatile uint32_t x = 0;
     const uint32_t spin_count = 10 * i;
     for (uint32_t spin = 0; spin < spin_count; ++spin) {
-      ++x;  // Volatile; hence should not be optimized away.
+      x = x + 1;  // Volatile; hence should not be optimized away.
     }
     // TODO: Consider adding x86 PAUSE and/or ARM YIELD here.
   } else if (i <= kYieldMax) {
diff --git a/runtime/class_linker-inl.h b/runtime/class_linker-inl.h
index 6951e35791..6461f54f5f 100644
--- a/runtime/class_linker-inl.h
+++ b/runtime/class_linker-inl.h
@@ -43,7 +43,8 @@ inline ObjPtr<mirror::Class> ClassLinker::FindArrayClass(Thread* self,
                                                          ObjPtr<mirror::Class> element_class) {
   for (size_t i = 0; i < kFindArrayCacheSize; ++i) {
     // Read the cached array class once to avoid races with other threads setting it.
-    ObjPtr<mirror::Class> array_class = find_array_class_cache_[i].Read();
+    ObjPtr<mirror::Class> array_class =
+        find_array_class_cache_[i].load(std::memory_order_acquire).Read();
     if (array_class != nullptr && array_class->GetComponentType() == element_class) {
       return array_class;
     }
@@ -57,7 +58,8 @@ inline ObjPtr<mirror::Class> ClassLinker::FindArrayClass(Thread* self,
   if (array_class != nullptr) {
     // Benign races in storing array class and incrementing index.
     size_t victim_index = find_array_class_cache_next_victim_;
-    find_array_class_cache_[victim_index] = GcRoot<mirror::Class>(array_class);
+    find_array_class_cache_[victim_index].store(GcRoot<mirror::Class>(array_class),
+                                                std::memory_order_release);
     find_array_class_cache_next_victim_ = (victim_index + 1) % kFindArrayCacheSize;
   } else {
     // We should have a NoClassDefFoundError.
diff --git a/runtime/class_linker.cc b/runtime/class_linker.cc
index c8394b2a5d..2d1bf6f780 100644
--- a/runtime/class_linker.cc
+++ b/runtime/class_linker.cc
@@ -138,6 +138,7 @@
 #include "nterp_helpers-inl.h"
 #include "nterp_helpers.h"
 #include "oat/image-inl.h"
+#include "oat/jni_stub_hash_map-inl.h"
 #include "oat/oat.h"
 #include "oat/oat_file-inl.h"
 #include "oat/oat_file.h"
@@ -147,13 +148,13 @@
 #include "profile/profile_compilation_info.h"
 #include "runtime.h"
 #include "runtime_callbacks.h"
+#include "scoped_assert_no_transaction_checks.h"
 #include "scoped_thread_state_change-inl.h"
 #include "startup_completed_task.h"
 #include "thread-inl.h"
 #include "thread.h"
 #include "thread_list.h"
 #include "trace.h"
-#include "transaction.h"
 #include "vdex_file.h"
 #include "verifier/class_verifier.h"
 #include "verifier/verifier_deps.h"
@@ -409,6 +410,14 @@ void ClassLinker::ForceClassInitialized(Thread* self, Handle<mirror::Class> klas
   MakeInitializedClassesVisiblyInitialized(self, /*wait=*/true);
 }
 
+const void* ClassLinker::FindBootJniStub(ArtMethod* method) {
+  return FindBootJniStub(JniStubKey(method));
+}
+
+const void* ClassLinker::FindBootJniStub(uint32_t flags, std::string_view shorty) {
+  return FindBootJniStub(JniStubKey(flags, shorty));
+}
+
 const void* ClassLinker::FindBootJniStub(JniStubKey key) {
   auto it = boot_image_jni_stubs_.find(key);
   if (it == boot_image_jni_stubs_.end()) {
@@ -634,7 +643,9 @@ ClassLinker::ClassLinker(InternTable* intern_table, bool fast_class_not_found_ex
   CHECK(intern_table_ != nullptr);
   static_assert(kFindArrayCacheSize == arraysize(find_array_class_cache_),
                 "Array cache size wrong.");
-  std::fill_n(find_array_class_cache_, kFindArrayCacheSize, GcRoot<mirror::Class>(nullptr));
+  for (size_t i = 0; i < kFindArrayCacheSize; i++) {
+    find_array_class_cache_[i].store(GcRoot<mirror::Class>(nullptr), std::memory_order_relaxed);
+  }
 }
 
 void ClassLinker::CheckSystemClass(Thread* self, Handle<mirror::Class> c1, const char* descriptor) {
@@ -2814,9 +2825,13 @@ void ClassLinker::FinishArrayClassSetup(ObjPtr<mirror::Class> array_class) {
   array_class->SetVTable(java_lang_Object->GetVTable());
   array_class->SetPrimitiveType(Primitive::kPrimNot);
   ObjPtr<mirror::Class> component_type = array_class->GetComponentType();
-  array_class->SetClassFlags(component_type->IsPrimitive()
-                                 ? mirror::kClassFlagNoReferenceFields
-                                 : mirror::kClassFlagObjectArray);
+  DCHECK_LT(component_type->GetPrimitiveTypeSizeShift(), 4u);
+  uint32_t class_flags =
+      component_type->GetPrimitiveTypeSizeShift() << mirror::kArrayComponentSizeShiftShift;
+  class_flags |= component_type->IsPrimitive()
+                     ? (mirror::kClassFlagNoReferenceFields | mirror::kClassFlagPrimitiveArray)
+                     : mirror::kClassFlagObjectArray;
+  array_class->SetClassFlags(class_flags);
   array_class->SetClassLoader(component_type->GetClassLoader());
   array_class->SetStatusForPrimitiveOrArray(ClassStatus::kLoaded);
   array_class->PopulateEmbeddedVTable(image_pointer_size_);
@@ -3671,13 +3686,14 @@ uint32_t ClassLinker::SizeOfClassWithoutEmbeddedTables(const DexFile& dex_file,
         UNREACHABLE();
     }
   }
-  return mirror::Class::ComputeClassSize(false,
-                                         0,
+  return mirror::Class::ComputeClassSize(/*has_embedded_vtable=*/false,
+                                         /*num_vtable_entries=*/0,
                                          num_8,
                                          num_16,
                                          num_32,
                                          num_64,
                                          num_ref,
+                                         /*num_ref_bitmap_entries=*/0,
                                          image_pointer_size_);
 }
 
@@ -4650,7 +4666,7 @@ ObjPtr<mirror::Class> ClassLinker::CreateArrayClass(Thread* self,
   auto visitor = [this, array_class_size, component_type](ObjPtr<mirror::Object> obj,
                                                           size_t usable_size)
       REQUIRES_SHARED(Locks::mutator_lock_) {
-    ScopedAssertNoNewTransactionRecords sanntr("CreateArrayClass");
+    ScopedAssertNoTransactionChecks santc("CreateArrayClass");
     mirror::Class::InitializeClassVisitor init_class(array_class_size);
     init_class(obj, usable_size);
     ObjPtr<mirror::Class> klass = ObjPtr<mirror::Class>::DownCast(obj);
@@ -6320,7 +6336,8 @@ bool ClassLinker::LinkClass(Thread* self,
   if (!LinkStaticFields(self, klass, &class_size)) {
     return false;
   }
-  CreateReferenceInstanceOffsets(klass);
+  class_size =
+      mirror::Class::AdjustClassSizeForReferenceOffsetBitmapDuringLinking(klass.Get(), class_size);
   CHECK_EQ(ClassStatus::kLoaded, klass->GetStatus());
 
   ImTable* imt = nullptr;
@@ -6362,6 +6379,7 @@ bool ClassLinker::LinkClass(Thread* self,
 
     if (klass->ShouldHaveEmbeddedVTable()) {
       klass->PopulateEmbeddedVTable(image_pointer_size_);
+      klass->PopulateReferenceOffsetBitmap();
     }
     if (klass->ShouldHaveImt()) {
       klass->SetImt(imt, image_pointer_size_);
@@ -8731,12 +8749,9 @@ bool ClassLinker::LinkMethodsHelper<kPointerSize>::FindCopiedMethodsForInterface
       size_t hash = ComputeMethodHash(interface_method);
       auto it1 = declared_virtual_signatures.FindWithHash(interface_method, hash);
       if (it1 != declared_virtual_signatures.end()) {
-        ArtMethod* virtual_method = klass->GetVirtualMethodDuringLinking(*it1, kPointerSize);
-        if (!virtual_method->IsAbstract() && !virtual_method->IsPublic()) {
-          sants.reset();
-          ThrowIllegalAccessErrorForImplementingMethod(klass, virtual_method, interface_method);
-          return false;
-        }
+        // Virtual methods in interfaces are always public.
+        // This is checked by the `DexFileVerifier`.
+        DCHECK(klass->GetVirtualMethodDuringLinking(*it1, kPointerSize)->IsPublic());
         continue;  // This default method is masked by a method declared in this interface.
       }
 
@@ -9587,7 +9602,7 @@ class RecordAnnotationVisitor final : public annotations::AnnotationVisitor {
   RecordAnnotationVisitor() {}
 
   bool ValidateCounts() {
-    if (is_error_) {
+    if (has_error_) {
       return false;
     }
 
@@ -9619,15 +9634,13 @@ class RecordAnnotationVisitor final : public annotations::AnnotationVisitor {
                                names_count_));
     }
 
-    return !is_error_;
+    return !has_error_;
   }
 
-  const std::string& GetErrorMsg() { return error_msg_; }
-
   bool IsRecordAnnotationFound() { return count_ != 0; }
 
   annotations::VisitorStatus VisitAnnotation(const char* descriptor, uint8_t visibility) override {
-    if (is_error_) {
+    if (has_error_) {
       return annotations::VisitorStatus::kVisitBreak;
     }
 
@@ -9649,7 +9662,7 @@ class RecordAnnotationVisitor final : public annotations::AnnotationVisitor {
   annotations::VisitorStatus VisitAnnotationElement(const char* element_name,
                                                     uint8_t type,
                                                     [[maybe_unused]] const JValue& value) override {
-    if (is_error_) {
+    if (has_error_) {
       return annotations::VisitorStatus::kVisitBreak;
     }
 
@@ -9695,7 +9708,7 @@ class RecordAnnotationVisitor final : public annotations::AnnotationVisitor {
                                                uint32_t index,
                                                uint8_t type,
                                                [[maybe_unused]] const JValue& value) override {
-    if (is_error_) {
+    if (has_error_) {
       return annotations::VisitorStatus::kVisitBreak;
     }
     switch (visiting_type_) {
@@ -9779,14 +9792,12 @@ class RecordAnnotationVisitor final : public annotations::AnnotationVisitor {
   }
 
  private:
-  bool is_error_ = false;
   uint32_t count_ = 0;
   uint32_t names_count_ = UINT32_MAX;
   uint32_t types_count_ = UINT32_MAX;
   uint32_t signatures_count_ = UINT32_MAX;
   uint32_t visibilities_count_ = UINT32_MAX;
   uint32_t annotations_count_ = UINT32_MAX;
-  std::string error_msg_;
   RecordElementType visiting_type_;
 
   inline bool ExpectedTypeOrError(uint8_t type,
@@ -9808,11 +9819,6 @@ class RecordAnnotationVisitor final : public annotations::AnnotationVisitor {
     return false;
   }
 
-  void SetErrorMsg(const std::string& msg) {
-    is_error_ = true;
-    error_msg_ = msg;
-  }
-
   DISALLOW_COPY_AND_ASSIGN(RecordAnnotationVisitor);
 };
 
@@ -9856,6 +9862,11 @@ bool ClassLinker::VerifyRecordClass(Handle<mirror::Class> klass, ObjPtr<mirror::
   // optional, but should have the same size if it exists.
   RecordAnnotationVisitor visitor;
   annotations::VisitClassAnnotations(klass, &visitor);
+  if (UNLIKELY(visitor.HasError())) {
+    ThrowClassFormatError(klass.Get(), "%s", visitor.GetErrorMsg().c_str());
+    return false;
+  }
+
   if (!visitor.IsRecordAnnotationFound()) {
     return true;
   }
@@ -9870,35 +9881,6 @@ bool ClassLinker::VerifyRecordClass(Handle<mirror::Class> klass, ObjPtr<mirror::
   return true;
 }
 
-//  Set the bitmap of reference instance field offsets.
-void ClassLinker::CreateReferenceInstanceOffsets(Handle<mirror::Class> klass) {
-  uint32_t reference_offsets = 0;
-  ObjPtr<mirror::Class> super_class = klass->GetSuperClass();
-  // Leave the reference offsets as 0 for mirror::Object (the class field is handled specially).
-  if (super_class != nullptr) {
-    reference_offsets = super_class->GetReferenceInstanceOffsets();
-    // Compute reference offsets unless our superclass overflowed.
-    if (reference_offsets != mirror::Class::kClassWalkSuper) {
-      size_t num_reference_fields = klass->NumReferenceInstanceFieldsDuringLinking();
-      if (num_reference_fields != 0u) {
-        // All of the fields that contain object references are guaranteed be grouped in memory
-        // starting at an appropriately aligned address after super class object data.
-        uint32_t start_offset = RoundUp(super_class->GetObjectSize(),
-                                        sizeof(mirror::HeapReference<mirror::Object>));
-        uint32_t start_bit = (start_offset - mirror::kObjectHeaderSize) /
-            sizeof(mirror::HeapReference<mirror::Object>);
-        if (start_bit + num_reference_fields > 32) {
-          reference_offsets = mirror::Class::kClassWalkSuper;
-        } else {
-          reference_offsets |= (0xffffffffu << start_bit) &
-                               (0xffffffffu >> (32 - (start_bit + num_reference_fields)));
-        }
-      }
-    }
-  }
-  klass->SetReferenceInstanceOffsets(reference_offsets);
-}
-
 ObjPtr<mirror::String> ClassLinker::DoResolveString(dex::StringIndex string_idx,
                                                     ObjPtr<mirror::DexCache> dex_cache) {
   StackHandleScope<1> hs(Thread::Current());
@@ -10921,7 +10903,9 @@ jobject ClassLinker::CreatePathClassLoader(Thread* self,
 }
 
 void ClassLinker::DropFindArrayClassCache() {
-  std::fill_n(find_array_class_cache_, kFindArrayCacheSize, GcRoot<mirror::Class>(nullptr));
+  for (size_t i = 0; i < kFindArrayCacheSize; i++) {
+    find_array_class_cache_[i].store(GcRoot<mirror::Class>(nullptr), std::memory_order_relaxed);
+  }
   find_array_class_cache_next_victim_ = 0;
 }
 
@@ -11331,6 +11315,12 @@ void ClassLinker::VisitTransactionRoots([[maybe_unused]] RootVisitor* visitor) {
   // Nothing to do for normal `ClassLinker`, only `AotClassLinker` handles transactions.
 }
 
+const void* ClassLinker::GetTransactionalInterpreter() {
+  // Should not be called on ClassLinker, only on AotClassLinker that overrides this.
+  LOG(FATAL) << "UNREACHABLE";
+  UNREACHABLE();
+}
+
 void ClassLinker::RemoveDexFromCaches(const DexFile& dex_file) {
   ReaderMutexLock mu(Thread::Current(), *Locks::dex_lock_);
 
diff --git a/runtime/class_linker.h b/runtime/class_linker.h
index daf9534c3a..505566f702 100644
--- a/runtime/class_linker.h
+++ b/runtime/class_linker.h
@@ -159,13 +159,13 @@ class AllocatorVisitor {
       REQUIRES_SHARED(Locks::classlinker_classes_lock_, Locks::mutator_lock_) = 0;
 };
 
-class EXPORT ClassLinker {
+class ClassLinker {
  public:
   static constexpr bool kAppImageMayContainStrings = true;
 
-  explicit ClassLinker(InternTable* intern_table,
-                       bool fast_class_not_found_exceptions = true);
-  virtual ~ClassLinker();
+  EXPORT explicit ClassLinker(InternTable* intern_table,
+                              bool fast_class_not_found_exceptions = true);
+  EXPORT virtual ~ClassLinker();
 
   // Initialize class linker by bootstraping from dex files.
   bool InitWithoutImage(std::vector<std::unique_ptr<const DexFile>> boot_class_path,
@@ -197,17 +197,17 @@ class EXPORT ClassLinker {
                       /*out*/ std::string* error_msg) REQUIRES(!Locks::dex_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  bool OpenImageDexFiles(gc::space::ImageSpace* space,
-                         std::vector<std::unique_ptr<const DexFile>>* out_dex_files,
-                         std::string* error_msg)
+  EXPORT bool OpenImageDexFiles(gc::space::ImageSpace* space,
+                                std::vector<std::unique_ptr<const DexFile>>* out_dex_files,
+                                std::string* error_msg)
       REQUIRES(!Locks::dex_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Finds a class by its descriptor, loading it if necessary.
   // If class_loader is null, searches boot_class_path_.
-  ObjPtr<mirror::Class> FindClass(Thread* self,
-                                  const char* descriptor,
-                                  Handle<mirror::ClassLoader> class_loader)
+  EXPORT ObjPtr<mirror::Class> FindClass(Thread* self,
+                                         const char* descriptor,
+                                         Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_);
 
@@ -241,9 +241,9 @@ class EXPORT ClassLinker {
 
   // Finds a class by its descriptor, returning null if it isn't wasn't loaded
   // by the given 'class_loader'.
-  ObjPtr<mirror::Class> LookupClass(Thread* self,
-                                    const char* descriptor,
-                                    ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT ObjPtr<mirror::Class> LookupClass(Thread* self,
+                                           const char* descriptor,
+                                           ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES(!Locks::classlinker_classes_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -343,10 +343,10 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Find a method with the given index from class `klass`, and update the dex cache.
-  ArtMethod* FindResolvedMethod(ObjPtr<mirror::Class> klass,
-                                ObjPtr<mirror::DexCache> dex_cache,
-                                ObjPtr<mirror::ClassLoader> class_loader,
-                                uint32_t method_idx)
+  EXPORT ArtMethod* FindResolvedMethod(ObjPtr<mirror::Class> klass,
+                                       ObjPtr<mirror::DexCache> dex_cache,
+                                       ObjPtr<mirror::ClassLoader> class_loader,
+                                       uint32_t method_idx)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Find a method using the wrong lookup mechanism. If `klass` is an interface,
@@ -376,9 +376,9 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
-  ArtMethod* ResolveMethodWithoutInvokeType(uint32_t method_idx,
-                                            Handle<mirror::DexCache> dex_cache,
-                                            Handle<mirror::ClassLoader> class_loader)
+  EXPORT ArtMethod* ResolveMethodWithoutInvokeType(uint32_t method_idx,
+                                                   Handle<mirror::DexCache> dex_cache,
+                                                   Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
@@ -409,9 +409,9 @@ class EXPORT ClassLinker {
   // and ClassLoader, storing the result in DexCache. The ClassLinker and ClassLoader
   // are used as in ResolveType. No is_static argument is provided so that Java
   // field resolution semantics are followed.
-  ArtField* ResolveFieldJLS(uint32_t field_idx,
-                            Handle<mirror::DexCache> dex_cache,
-                            Handle<mirror::ClassLoader> class_loader)
+  EXPORT ArtField* ResolveFieldJLS(uint32_t field_idx,
+                                   Handle<mirror::DexCache> dex_cache,
+                                   Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
@@ -419,11 +419,11 @@ class EXPORT ClassLinker {
   // and ClassLoader, storing the result in DexCache. The declaring class is assumed
   // to have been already resolved into `klass`. The `is_static` argument is used to
   // determine if we are resolving a static or non-static field.
-  ArtField* FindResolvedField(ObjPtr<mirror::Class> klass,
-                              ObjPtr<mirror::DexCache> dex_cache,
-                              ObjPtr<mirror::ClassLoader> class_loader,
-                              uint32_t field_idx,
-                              bool is_static)
+  EXPORT ArtField* FindResolvedField(ObjPtr<mirror::Class> klass,
+                                     ObjPtr<mirror::DexCache> dex_cache,
+                                     ObjPtr<mirror::ClassLoader> class_loader,
+                                     uint32_t field_idx,
+                                     bool is_static)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Find a field with a given ID from the DexFile associated with the given DexCache
@@ -445,9 +445,9 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
-  ObjPtr<mirror::MethodType> ResolveMethodType(Thread* self,
-                                               dex::ProtoIndex proto_idx,
-                                               ArtMethod* referrer)
+  EXPORT ObjPtr<mirror::MethodType> ResolveMethodType(Thread* self,
+                                                      dex::ProtoIndex proto_idx,
+                                                      ArtMethod* referrer)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   bool ResolveMethodType(Thread* self,
@@ -461,24 +461,24 @@ class EXPORT ClassLinker {
   // Resolve a method handle with a given ID from the DexFile. The
   // result is not cached in the DexCache as the instance will only be
   // used once in most circumstances.
-  ObjPtr<mirror::MethodHandle> ResolveMethodHandle(Thread* self,
-                                                   uint32_t method_handle_idx,
-                                                   ArtMethod* referrer)
+  EXPORT ObjPtr<mirror::MethodHandle> ResolveMethodHandle(Thread* self,
+                                                          uint32_t method_handle_idx,
+                                                          ArtMethod* referrer)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Returns true on success, false if there's an exception pending.
   // can_run_clinit=false allows the compiler to attempt to init a class,
   // given the restriction that no <clinit> execution is possible.
-  bool EnsureInitialized(Thread* self,
-                         Handle<mirror::Class> c,
-                         bool can_init_fields,
-                         bool can_init_parents)
+  EXPORT bool EnsureInitialized(Thread* self,
+                                Handle<mirror::Class> c,
+                                bool can_init_fields,
+                                bool can_init_parents)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
   // Initializes a few essential classes, namely `java.lang.Class`,
   // `java.lang.Object` and `java.lang.reflect.Field`.
-  void RunEarlyRootClinits(Thread* self)
+  EXPORT  void RunEarlyRootClinits(Thread* self)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
@@ -491,12 +491,12 @@ class EXPORT ClassLinker {
   // Directly register an already existing dex cache. RegisterDexFile should be preferred since that
   // reduplicates DexCaches when possible. The DexCache given to this function must already be fully
   // initialized and not already registered.
-  void RegisterExistingDexCache(ObjPtr<mirror::DexCache> cache,
-                                ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT void RegisterExistingDexCache(ObjPtr<mirror::DexCache> cache,
+                                       ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES(!Locks::dex_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  ObjPtr<mirror::DexCache> RegisterDexFile(const DexFile& dex_file,
-                                           ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT ObjPtr<mirror::DexCache> RegisterDexFile(const DexFile& dex_file,
+                                                  ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES(!Locks::dex_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -504,7 +504,7 @@ class EXPORT ClassLinker {
     return boot_class_path_;
   }
 
-  void VisitClasses(ClassVisitor* visitor)
+  EXPORT void VisitClasses(ClassVisitor* visitor)
       REQUIRES(!Locks::classlinker_classes_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -517,7 +517,7 @@ class EXPORT ClassLinker {
   // so that it can visit individual classes without holding the doesn't hold the
   // Locks::classlinker_classes_lock_. As the Locks::classlinker_classes_lock_ isn't held this code
   // can race with insertion and deletion of classes while the visitor is being called.
-  void VisitClassesWithoutClassesLock(ClassVisitor* visitor)
+  EXPORT void VisitClassesWithoutClassesLock(ClassVisitor* visitor)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_);
 
@@ -531,10 +531,10 @@ class EXPORT ClassLinker {
   template<typename Visitor>
   void VisitKnownDexFiles(Thread* self, Visitor visitor) REQUIRES(Locks::mutator_lock_);
 
-  bool IsDexFileRegistered(Thread* self, const DexFile& dex_file)
+  EXPORT bool IsDexFileRegistered(Thread* self, const DexFile& dex_file)
       REQUIRES(!Locks::dex_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  ObjPtr<mirror::DexCache> FindDexCache(Thread* self, const DexFile& dex_file)
+  EXPORT ObjPtr<mirror::DexCache> FindDexCache(Thread* self, const DexFile& dex_file)
       REQUIRES(!Locks::dex_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
   ObjPtr<mirror::DexCache> FindDexCache(Thread* self, const OatDexFile& oat_dex_file)
@@ -554,32 +554,32 @@ class EXPORT ClassLinker {
   // Convenience AllocClass() overload that uses mirror::Class::InitializeClassVisitor
   // for the class initialization and uses the `java_lang_Class` from class roots
   // instead of an explicit argument.
-  ObjPtr<mirror::Class> AllocClass(Thread* self, uint32_t class_size)
+  EXPORT ObjPtr<mirror::Class> AllocClass(Thread* self, uint32_t class_size)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Roles::uninterruptible_);
 
   // Setup the classloader, class def index, type idx so that we can insert this class in the class
   // table.
-  void SetupClass(const DexFile& dex_file,
-                  const dex::ClassDef& dex_class_def,
-                  Handle<mirror::Class> klass,
-                  ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT void SetupClass(const DexFile& dex_file,
+                         const dex::ClassDef& dex_class_def,
+                         Handle<mirror::Class> klass,
+                         ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  void LoadClass(Thread* self,
-                 const DexFile& dex_file,
-                 const dex::ClassDef& dex_class_def,
-                 Handle<mirror::Class> klass)
+  EXPORT void LoadClass(Thread* self,
+                        const DexFile& dex_file,
+                        const dex::ClassDef& dex_class_def,
+                        Handle<mirror::Class> klass)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Link the class and place it into the class-table using the given descriptor. NB if the
   // descriptor is null the class will not be placed in any class-table. This is useful implementing
   // obsolete classes and should not be used otherwise.
-  bool LinkClass(Thread* self,
-                 const char* descriptor,
-                 Handle<mirror::Class> klass,
-                 Handle<mirror::ObjectArray<mirror::Class>> interfaces,
-                 MutableHandle<mirror::Class>* h_new_class_out)
+  EXPORT bool LinkClass(Thread* self,
+                        const char* descriptor,
+                        Handle<mirror::Class> klass,
+                        Handle<mirror::ObjectArray<mirror::Class>> interfaces,
+                        MutableHandle<mirror::Class>* h_new_class_out)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::classlinker_classes_lock_);
 
@@ -592,13 +592,14 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Roles::uninterruptible_);
 
-  verifier::FailureKind VerifyClass(
+  EXPORT verifier::FailureKind VerifyClass(
       Thread* self,
       verifier::VerifierDeps* verifier_deps,
       Handle<mirror::Class> klass,
       verifier::HardFailLogMode log_level = verifier::HardFailLogMode::kLogNone)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_);
+  EXPORT  // For `libarttest.so`.
   bool VerifyClassUsingOatFile(Thread* self,
                                const DexFile& dex_file,
                                Handle<mirror::Class> klass,
@@ -624,19 +625,19 @@ class EXPORT ClassLinker {
   pid_t GetDexLockOwner();  // For SignalCatcher.
 
   // Is the given entry point quick code to run the resolution stub?
-  bool IsQuickResolutionStub(const void* entry_point) const;
+  EXPORT bool IsQuickResolutionStub(const void* entry_point) const;
 
   // Is the given entry point quick code to bridge into the interpreter?
-  bool IsQuickToInterpreterBridge(const void* entry_point) const;
+  EXPORT bool IsQuickToInterpreterBridge(const void* entry_point) const;
 
   // Is the given entry point quick code to run the generic JNI stub?
-  bool IsQuickGenericJniStub(const void* entry_point) const;
+  EXPORT bool IsQuickGenericJniStub(const void* entry_point) const;
 
   // Is the given entry point the JNI dlsym lookup stub?
-  bool IsJniDlsymLookupStub(const void* entry_point) const;
+  EXPORT bool IsJniDlsymLookupStub(const void* entry_point) const;
 
   // Is the given entry point the JNI dlsym lookup critical stub?
-  bool IsJniDlsymLookupCriticalStub(const void* entry_point) const;
+  EXPORT bool IsJniDlsymLookupCriticalStub(const void* entry_point) const;
 
   // Is the given entry point the nterp trampoline?
   bool IsNterpTrampoline(const void* entry_point) const {
@@ -657,7 +658,7 @@ class EXPORT ClassLinker {
   }
 
   // Set the entrypoints up for an obsolete method.
-  void SetEntryPointsForObsoleteMethod(ArtMethod* method) const
+  EXPORT void SetEntryPointsForObsoleteMethod(ArtMethod* method) const
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Attempts to insert a class into a class table.  Returns null if
@@ -687,7 +688,7 @@ class EXPORT ClassLinker {
 
   // Calls `CreateWellKnownClassLoader()` with `WellKnownClasses::dalvik_system_PathClassLoader`,
   // and null parent and libraries. Wraps the result in a JNI global reference.
-  jobject CreatePathClassLoader(Thread* self, const std::vector<const DexFile*>& dex_files)
+  EXPORT jobject CreatePathClassLoader(Thread* self, const std::vector<const DexFile*>& dex_files)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_);
 
@@ -714,7 +715,7 @@ class EXPORT ClassLinker {
 
   // Clear the ArrayClass cache. This is necessary when cleaning up for the image, as the cache
   // entries are roots, but potentially not image classes.
-  void DropFindArrayClassCache() REQUIRES_SHARED(Locks::mutator_lock_);
+  EXPORT void DropFindArrayClassCache() REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Clean up class loaders, this needs to happen after JNI weak globals are cleared.
   void CleanupClassLoaders()
@@ -723,7 +724,7 @@ class EXPORT ClassLinker {
 
   // Unlike GetOrCreateAllocatorForClassLoader, GetAllocatorForClassLoader asserts that the
   // allocator for this class loader is already created.
-  LinearAlloc* GetAllocatorForClassLoader(ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT LinearAlloc* GetAllocatorForClassLoader(ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Return the linear alloc for a class loader if it is already allocated, otherwise allocate and
@@ -738,7 +739,7 @@ class EXPORT ClassLinker {
       REQUIRES(!Locks::classlinker_classes_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  static bool IsBootClassLoader(ObjPtr<mirror::Object> class_loader)
+  EXPORT static bool IsBootClassLoader(ObjPtr<mirror::Object> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   ArtMethod* AddMethodToConflictTable(ObjPtr<mirror::Class> klass,
@@ -757,7 +758,8 @@ class EXPORT ClassLinker {
 
 
   // Create the IMT and conflict tables for a class.
-  void FillIMTAndConflictTables(ObjPtr<mirror::Class> klass) REQUIRES_SHARED(Locks::mutator_lock_);
+  EXPORT void FillIMTAndConflictTables(ObjPtr<mirror::Class> klass)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Visit all of the class tables. This is used by dex2oat to allow pruning dex caches.
   template <class Visitor>
@@ -767,6 +769,7 @@ class EXPORT ClassLinker {
 
   // Visit all of the allocators that belong to classloaders except boot classloader.
   // This is used by 616-cha-unloading test to confirm memory reuse.
+  EXPORT  // For `libarttest.so`.
   void VisitAllocators(AllocatorVisitor* visitor) const
       REQUIRES_SHARED(Locks::classlinker_classes_lock_, Locks::mutator_lock_);
 
@@ -794,7 +797,7 @@ class EXPORT ClassLinker {
   // Returns null if not found.
   // This returns a pointer to the class-table, without requiring any locking - including the
   // boot class-table. It is the caller's responsibility to access this under lock, if required.
-  ClassTable* ClassTableForClassLoader(ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT ClassTable* ClassTableForClassLoader(ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       NO_THREAD_SAFETY_ANALYSIS;
 
@@ -819,7 +822,7 @@ class EXPORT ClassLinker {
       REQUIRES(!Locks::dex_lock_);
 
   // Visit all of the class loaders in the class linker.
-  void VisitClassLoaders(ClassLoaderVisitor* visitor) const
+  EXPORT void VisitClassLoaders(ClassLoaderVisitor* visitor) const
       REQUIRES_SHARED(Locks::classlinker_classes_lock_, Locks::mutator_lock_);
 
   // Visit all of the dex caches in the class linker.
@@ -827,13 +830,14 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::dex_lock_, Locks::mutator_lock_);
 
   // Checks that a class and its superclass from another class loader have the same virtual methods.
-  bool ValidateSuperClassDescriptors(Handle<mirror::Class> klass)
+  EXPORT bool ValidateSuperClassDescriptors(Handle<mirror::Class> klass)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   ClassHierarchyAnalysis* GetClassHierarchyAnalysis() {
     return cha_.get();
   }
 
+  EXPORT
   void MakeInitializedClassesVisiblyInitialized(Thread* self, bool wait /* ==> no locks held */);
 
   // Registers the native method and returns the new entry point. NB The returned entry point
@@ -875,7 +879,7 @@ class EXPORT ClassLinker {
 
   // Forces a class to be marked as initialized without actually running initializers. Should only
   // be used by plugin code when creating new classes directly.
-  void ForceClassInitialized(Thread* self, Handle<mirror::Class> klass)
+  EXPORT void ForceClassInitialized(Thread* self, Handle<mirror::Class> klass)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
@@ -954,34 +958,34 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_);
   virtual bool IsTransactionAborted() const;
 
-  // Vist transaction roots for AOT compilation.
+  // Visit transaction roots for AOT compilation.
   virtual void VisitTransactionRoots(RootVisitor* visitor)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  // Get transactional switch interpreter entrypoint for AOT compilation.
+  virtual const void* GetTransactionalInterpreter();
+
   void RemoveDexFromCaches(const DexFile& dex_file);
   ClassTable* GetBootClassTable() REQUIRES_SHARED(Locks::classlinker_classes_lock_) {
     return boot_class_table_.get();
   }
   // Find a matching JNI stub from boot images that we could reuse as entrypoint.
-  const void* FindBootJniStub(ArtMethod* method)
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    return FindBootJniStub(JniStubKey(method));
-  }
+  EXPORT const void* FindBootJniStub(ArtMethod* method)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
-  const void* FindBootJniStub(uint32_t flags, std::string_view shorty) {
-    return FindBootJniStub(JniStubKey(flags, shorty));
-  }
+  EXPORT const void* FindBootJniStub(uint32_t flags, std::string_view shorty);
 
   const void* FindBootJniStub(JniStubKey key);
 
  protected:
-  virtual bool InitializeClass(Thread* self,
-                               Handle<mirror::Class> klass,
-                               bool can_run_clinit,
-                               bool can_init_parents)
+  EXPORT virtual bool InitializeClass(Thread* self,
+                                      Handle<mirror::Class> klass,
+                                      bool can_run_clinit,
+                                      bool can_init_parents)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_);
 
+  EXPORT
   virtual verifier::FailureKind PerformClassVerification(Thread* self,
                                                          verifier::VerifierDeps* verifier_deps,
                                                          Handle<mirror::Class> klass,
@@ -1195,36 +1199,36 @@ class EXPORT ClassLinker {
       REQUIRES(!Locks::dex_lock_);
 
   // Implementation of LookupResolvedType() called when the type was not found in the dex cache.
-  ObjPtr<mirror::Class> DoLookupResolvedType(dex::TypeIndex type_idx,
-                                             ObjPtr<mirror::Class> referrer)
+  EXPORT ObjPtr<mirror::Class> DoLookupResolvedType(dex::TypeIndex type_idx,
+                                                    ObjPtr<mirror::Class> referrer)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  ObjPtr<mirror::Class> DoLookupResolvedType(dex::TypeIndex type_idx,
-                                             ObjPtr<mirror::DexCache> dex_cache,
-                                             ObjPtr<mirror::ClassLoader> class_loader)
+  EXPORT ObjPtr<mirror::Class> DoLookupResolvedType(dex::TypeIndex type_idx,
+                                                    ObjPtr<mirror::DexCache> dex_cache,
+                                                    ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Implementation of ResolveString() called when the string was not found in the dex cache.
-  ObjPtr<mirror::String> DoResolveString(dex::StringIndex string_idx,
-                                         ObjPtr<mirror::DexCache> dex_cache)
+  EXPORT ObjPtr<mirror::String> DoResolveString(dex::StringIndex string_idx,
+                                                ObjPtr<mirror::DexCache> dex_cache)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  ObjPtr<mirror::String> DoResolveString(dex::StringIndex string_idx,
-                                         Handle<mirror::DexCache> dex_cache)
+  EXPORT ObjPtr<mirror::String> DoResolveString(dex::StringIndex string_idx,
+                                                Handle<mirror::DexCache> dex_cache)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Implementation of LookupString() called when the string was not found in the dex cache.
-  ObjPtr<mirror::String> DoLookupString(dex::StringIndex string_idx,
-                                        ObjPtr<mirror::DexCache> dex_cache)
+  EXPORT ObjPtr<mirror::String> DoLookupString(dex::StringIndex string_idx,
+                                               ObjPtr<mirror::DexCache> dex_cache)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Implementation of ResolveType() called when the type was not found in the dex cache. May be
   // used with ArtField*, ArtMethod* or ObjPtr<Class>.
   template <typename RefType>
-  ObjPtr<mirror::Class> DoResolveType(dex::TypeIndex type_idx, RefType referrer)
+  EXPORT ObjPtr<mirror::Class> DoResolveType(dex::TypeIndex type_idx, RefType referrer)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
-  ObjPtr<mirror::Class> DoResolveType(dex::TypeIndex type_idx,
-                                      Handle<mirror::DexCache> dex_cache,
-                                      Handle<mirror::ClassLoader> class_loader)
+  EXPORT ObjPtr<mirror::Class> DoResolveType(dex::TypeIndex type_idx,
+                                             Handle<mirror::DexCache> dex_cache,
+                                             Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
@@ -1305,8 +1309,6 @@ class EXPORT ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_);
   bool VerifyRecordClass(Handle<mirror::Class> klass, ObjPtr<mirror::Class> super)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  void CreateReferenceInstanceOffsets(Handle<mirror::Class> klass)
-      REQUIRES_SHARED(Locks::mutator_lock_);
 
   void CheckProxyConstructor(ArtMethod* constructor) const
       REQUIRES_SHARED(Locks::mutator_lock_);
@@ -1462,7 +1464,7 @@ class EXPORT ClassLinker {
   // A cache of the last FindArrayClass results. The cache serves to avoid creating array class
   // descriptors for the sake of performing FindClass.
   static constexpr size_t kFindArrayCacheSize = 16;
-  GcRoot<mirror::Class> find_array_class_cache_[kFindArrayCacheSize];
+  std::atomic<GcRoot<mirror::Class>> find_array_class_cache_[kFindArrayCacheSize];
   size_t find_array_class_cache_next_victim_;
 
   bool init_done_;
@@ -1516,6 +1518,8 @@ class EXPORT ClassLinker {
   friend class linker::ImageWriter;  // for GetClassRoots
   friend class JniCompilerTest;  // for GetRuntimeQuickGenericJniStub
   friend class JniInternalTest;  // for GetRuntimeQuickGenericJniStub
+  friend class VerifyClassesFuzzerHelper;  // for FindDexCacheDataLocked.
+  friend class VerifyClassesFuzzerCorpusTestHelper;  // for FindDexCacheDataLocked.
   friend class VMClassLoader;  // for LookupClass and FindClassInBaseDexClassLoader.
   ART_FRIEND_TEST(ClassLinkerTest, RegisterDexFileName);  // for DexLock, and RegisterDexFileLocked
   ART_FRIEND_TEST(mirror::DexCacheMethodHandlesTest, Open);  // for AllocDexCache
diff --git a/runtime/class_linker_test.cc b/runtime/class_linker_test.cc
index 932341d895..9c4e0289ae 100644
--- a/runtime/class_linker_test.cc
+++ b/runtime/class_linker_test.cc
@@ -395,7 +395,8 @@ class ClassLinkerTest : public CommonRuntimeTest {
       k = k->GetSuperClass();
     }
     EXPECT_GE(total_num_reference_instance_fields, 1U);  // Should always have Object's class.
-    if (klass->GetReferenceInstanceOffsets() != mirror::Class::kClassWalkSuper) {
+    if ((klass->GetReferenceInstanceOffsets() & mirror::Class::kVisitReferencesSlowpathMask) == 0 &&
+        klass->ShouldHaveEmbeddedVTable()) {
       // The reference instance offsets have a bit set for each reference offset.
       // +1 for Object's class.
       EXPECT_EQ(static_cast<uint32_t>(POPCOUNT(klass->GetReferenceInstanceOffsets())) + 1,
@@ -777,7 +778,8 @@ struct MethodHandleOffsets : public CheckOffsets<mirror::MethodHandle> {
 struct MethodHandleImplOffsets : public CheckOffsets<mirror::MethodHandleImpl> {
   MethodHandleImplOffsets() : CheckOffsets<mirror::MethodHandleImpl>(
       false, "Ljava/lang/invoke/MethodHandleImpl;") {
-    addOffset(OFFSETOF_MEMBER(mirror::MethodHandleImpl, info_), "info");
+    addOffset(OFFSETOF_MEMBER(mirror::MethodHandleImpl, target_class_or_info_),
+              "targetClassOrMethodHandleInfo");
   }
 };
 
diff --git a/runtime/common_runtime_test.cc b/runtime/common_runtime_test.cc
index 311391dbbf..165b3a9c8a 100644
--- a/runtime/common_runtime_test.cc
+++ b/runtime/common_runtime_test.cc
@@ -58,7 +58,6 @@
 #include "mirror/object_array-alloc-inl.h"
 #include "native/dalvik_system_DexFile.h"
 #include "noop_compiler_callbacks.h"
-#include "oat/aot_class_linker.h"
 #include "profile/profile_compilation_info.h"
 #include "runtime-inl.h"
 #include "runtime_intrinsics.h"
@@ -112,6 +111,7 @@ void CommonRuntimeTestImpl::SetUp() {
   static bool gSlowDebugTestFlag = false;
   RegisterRuntimeDebugFlag(&gSlowDebugTestFlag);
 
+  // Create default compiler callbacks. `SetUpRuntimeOptions()` can replace or remove this.
   callbacks_.reset(new NoopCompilerCallbacks());
 
   SetUpRuntimeOptions(&options);
diff --git a/runtime/common_throws.cc b/runtime/common_throws.cc
index 3724866556..ec43f69b19 100644
--- a/runtime/common_throws.cc
+++ b/runtime/common_throws.cc
@@ -241,7 +241,9 @@ void ThrowIllegalAccessErrorForImplementingMethod(ObjPtr<mirror::Class> klass,
                                                   ArtMethod* implementation_method,
                                                   ArtMethod* interface_method)
     REQUIRES_SHARED(Locks::mutator_lock_) {
-  DCHECK(!implementation_method->IsAbstract());
+  // Note: For a non-public abstract implementing method, both `AbstractMethodError` and
+  // `IllegalAccessError` are reasonable. We now follow the RI behaviour and throw the latter,
+  // so we do not assert here that the implementation method is concrete as we did in the past.
   DCHECK(!implementation_method->IsPublic());
   ThrowIllegalAccessError(
       klass,
@@ -765,8 +767,7 @@ void ThrowStackOverflowError(Thread* self) {
 
     // stackState is set as result of fillInStackTrace. fillInStackTrace calls
     // nativeFillInStackTrace.
-    ObjPtr<mirror::Object> stack_state_val =
-        soa.Decode<mirror::Object>(self->CreateInternalStackTrace(soa));
+    ObjPtr<mirror::Object> stack_state_val = self->CreateInternalStackTrace(soa);
     if (stack_state_val != nullptr) {
       WellKnownClasses::java_lang_Throwable_stackState
           ->SetObject</*kTransactionActive=*/ false>(exc.Get(), stack_state_val);
diff --git a/runtime/common_throws.h b/runtime/common_throws.h
index 71b0968fc0..9b5da327f2 100644
--- a/runtime/common_throws.h
+++ b/runtime/common_throws.h
@@ -48,7 +48,7 @@ void ThrowAbstractMethodError(uint32_t method_idx, const DexFile& dex_file)
 
 // ArithmeticException
 
-void ThrowArithmeticExceptionDivideByZero() REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
+EXPORT void ThrowArithmeticExceptionDivideByZero() REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 // ArrayIndexOutOfBoundsException
 
@@ -79,7 +79,7 @@ void ThrowClassCircularityError(ObjPtr<mirror::Class> c, const char* fmt, ...)
 
 // ClassCastException
 
-void ThrowClassCastException(ObjPtr<mirror::Class> dest_type, ObjPtr<mirror::Class> src_type)
+EXPORT void ThrowClassCastException(ObjPtr<mirror::Class> dest_type, ObjPtr<mirror::Class> src_type)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 void ThrowClassCastException(const char* msg)
@@ -111,7 +111,7 @@ EXPORT void ThrowIllegalAccessErrorField(ObjPtr<mirror::Class> referrer, ArtFiel
 EXPORT void ThrowIllegalAccessErrorFinalField(ArtMethod* referrer, ArtField* accessed)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
-void ThrowIllegalAccessError(ObjPtr<mirror::Class> referrer, const char* fmt, ...)
+EXPORT void ThrowIllegalAccessError(ObjPtr<mirror::Class> referrer, const char* fmt, ...)
     __attribute__((__format__(__printf__, 2, 3)))
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
@@ -143,14 +143,12 @@ void ThrowIncompatibleClassChangeError(InvokeType expected_type,
                                        ArtMethod* referrer)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
-void ThrowIncompatibleClassChangeErrorClassForInterfaceDispatch(ArtMethod* interface_method,
-                                                                ObjPtr<mirror::Object> this_object,
-                                                                ArtMethod* referrer)
+EXPORT void ThrowIncompatibleClassChangeErrorClassForInterfaceDispatch(
+    ArtMethod* interface_method, ObjPtr<mirror::Object> this_object, ArtMethod* referrer)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
-EXPORT void ThrowIncompatibleClassChangeErrorField(ArtField* resolved_field,
-                                                   bool is_static,
-                                                   ArtMethod* referrer)
+EXPORT void ThrowIncompatibleClassChangeErrorField(
+    ArtField* resolved_field, bool is_static, ArtMethod* referrer)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 void ThrowIncompatibleClassChangeError(ObjPtr<mirror::Class> referrer, const char* fmt, ...)
@@ -191,7 +189,7 @@ void ThrowWrappedLinkageError(ObjPtr<mirror::Class> referrer, const char* fmt, .
 
 // NegativeArraySizeException
 
-void ThrowNegativeArraySizeException(int size)
+EXPORT void ThrowNegativeArraySizeException(int size)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 void ThrowNegativeArraySizeException(const char* msg)
@@ -218,16 +216,14 @@ void ThrowNoSuchMethodError(InvokeType type,
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 // NullPointerException
-
+EXPORT
 void ThrowNullPointerExceptionForFieldAccess(ArtField* field, ArtMethod* method, bool is_read)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
-void ThrowNullPointerExceptionForMethodAccess(uint32_t method_idx,
-                                              InvokeType type)
+EXPORT void ThrowNullPointerExceptionForMethodAccess(uint32_t method_idx, InvokeType type)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
-void ThrowNullPointerExceptionForMethodAccess(ArtMethod* method,
-                                              InvokeType type)
+void ThrowNullPointerExceptionForMethodAccess(ArtMethod* method, InvokeType type)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 void ThrowNullPointerExceptionFromDexPC(bool check_address = false, uintptr_t addr = 0)
@@ -236,7 +232,7 @@ void ThrowNullPointerExceptionFromDexPC(bool check_address = false, uintptr_t ad
 EXPORT void ThrowNullPointerException(const char* msg)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
-void ThrowNullPointerException()
+EXPORT void ThrowNullPointerException()
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 // ReadOnlyBufferException
diff --git a/runtime/compiler_callbacks.h b/runtime/compiler_callbacks.h
index cd6f6b893b..e196b0b921 100644
--- a/runtime/compiler_callbacks.h
+++ b/runtime/compiler_callbacks.h
@@ -25,7 +25,9 @@
 
 namespace art HIDDEN {
 
+class ClassLinker;
 class CompilerDriver;
+class InternTable;
 
 namespace mirror {
 
@@ -48,6 +50,8 @@ class CompilerCallbacks {
 
   virtual ~CompilerCallbacks() { }
 
+  virtual ClassLinker* CreateAotClassLinker(InternTable* intern_table) = 0;
+
   virtual void AddUncompilableMethod(MethodReference ref) = 0;
   virtual void AddUncompilableClass(ClassReference ref) = 0;
   virtual void ClassRejected(ClassReference ref) = 0;
diff --git a/runtime/dex/dex_file_annotations.cc b/runtime/dex/dex_file_annotations.cc
index 3d334e70fd..f44077655b 100644
--- a/runtime/dex/dex_file_annotations.cc
+++ b/runtime/dex/dex_file_annotations.cc
@@ -26,6 +26,7 @@
 #include "class_linker-inl.h"
 #include "class_root-inl.h"
 #include "dex/dex_file-inl.h"
+#include "dex/dex_file_types.h"
 #include "dex/dex_instruction-inl.h"
 #include "jni/jni_internal.h"
 #include "jvalue-inl.h"
@@ -221,6 +222,8 @@ bool SkipAnnotationValue(const DexFile& dex_file, const uint8_t** annotation_ptr
     case DexFile::kDexAnnotationLong:
     case DexFile::kDexAnnotationFloat:
     case DexFile::kDexAnnotationDouble:
+    case DexFile::kDexAnnotationMethodType:
+    case DexFile::kDexAnnotationMethodHandle:
     case DexFile::kDexAnnotationString:
     case DexFile::kDexAnnotationType:
     case DexFile::kDexAnnotationMethod:
@@ -465,6 +468,11 @@ bool ProcessAnnotationValue(const ClassData& klass,
       primitive_type = Primitive::kPrimBoolean;
       width = 0;
       break;
+    case DexFile::kDexAnnotationMethodType:
+    case DexFile::kDexAnnotationMethodHandle:
+      // These annotations are unexpected here. Don't process them.
+      LOG(WARNING) << StringPrintf("Unexpected annotation of type 0x%02x", value_type);
+      return false;
     case DexFile::kDexAnnotationString: {
       uint32_t index = DexFile::ReadUnsignedInt(annotation, value_arg, false);
       if (result_style == DexFile::kAllRaw) {
@@ -1929,6 +1937,11 @@ static VisitorStatus VisitEncodedValue(const ClassData& klass,
 
   VisitorStatus status =
       VisitElement(visitor, element_name, depth, element_index, annotation_value);
+  if (UNLIKELY(visitor->HasError())) {
+    // Stop visiting since we won't verify the class anyway.
+    return annotations::VisitorStatus::kVisitBreak;
+  }
+
   switch (annotation_value.type_) {
     case DexFile::kDexAnnotationArray: {
       DCHECK(!is_consumed) << " unexpected consumption of array-typed element '" << element_name
@@ -1943,6 +1956,10 @@ static VisitorStatus VisitEncodedValue(const ClassData& klass,
       for (; i < array_size && element_status != VisitorStatus::kVisitBreak; ++i) {
         element_status = VisitEncodedValue(
             klass, dex_file, annotation_ptr, visitor, element_name, next_depth, i);
+        if (UNLIKELY(visitor->HasError())) {
+          // Stop visiting since we won't verify the class anyway.
+          return annotations::VisitorStatus::kVisitBreak;
+        }
       }
       for (; i < array_size; ++i) {
         SkipAnnotationValue(dex_file, annotation_ptr);
@@ -1962,6 +1979,17 @@ static VisitorStatus VisitEncodedValue(const ClassData& klass,
       }
       break;
     }
+    case DexFile::kDexAnnotationMethodType:
+    case DexFile::kDexAnnotationMethodHandle:
+      // kDexAnnotationMethodType and kDexAnnotationMethodHandle return false in order to not
+      // crash the process but they are unexpected here.
+      visitor->SetErrorMsg(StringPrintf(
+          "Encountered unexpected annotation element type 0x%02x of %s for the class %s",
+          annotation_value.type_,
+          element_name,
+          klass.GetRealClass()->PrettyClass().c_str()));
+      // Stop visiting since we won't verify the class anyway.
+      return annotations::VisitorStatus::kVisitBreak;
     default: {
       // kDexAnnotationArray and kDexAnnotationAnnotation are the only 2 known value_types causing
       // ProcessAnnotationValue return false. For other value_types, we shouldn't need to iterate
@@ -2014,6 +2042,10 @@ void VisitClassAnnotations(Handle<mirror::Class> klass, AnnotationVisitor* visit
 
       status = VisitEncodedValue(
           data, dex_file, &annotation, visitor, element_name, /*depth=*/0, /*ignored*/ 0);
+      if (UNLIKELY(visitor->HasError())) {
+        // Encountered an error, bail out since we won't verify the class anyway.
+        return;
+      }
       if (status == VisitorStatus::kVisitBreak) {
         break;
       }
diff --git a/runtime/dex/dex_file_annotations.h b/runtime/dex/dex_file_annotations.h
index 6f6c6ddc1f..29267b89b8 100644
--- a/runtime/dex/dex_file_annotations.h
+++ b/runtime/dex/dex_file_annotations.h
@@ -203,6 +203,21 @@ class AnnotationVisitor {
                                           uint32_t index,
                                           uint8_t type,
                                           const JValue& value) = 0;
+
+  bool HasError() const { return has_error_; }
+  void SetErrorMsg(const std::string& msg) {
+    DCHECK(!has_error_) << "Already had an error set. New error: " << msg
+                        << ", old error: " << error_msg_;
+    has_error_ = true;
+    error_msg_ = msg;
+  }
+  const std::string& GetErrorMsg() const { return error_msg_; }
+
+ protected:
+  // Whether we found an error while visiting the annotations. If true, `error_msg_` will contain
+  // the information about the error.
+  bool has_error_ = false;
+  std::string error_msg_;
 };
 
 // Visit all annotation elements and array elements without creating
diff --git a/runtime/dex2oat_environment_test.h b/runtime/dex2oat_environment_test.h
index 08b36bbb37..7e8378aa67 100644
--- a/runtime/dex2oat_environment_test.h
+++ b/runtime/dex2oat_environment_test.h
@@ -17,11 +17,15 @@
 #ifndef ART_RUNTIME_DEX2OAT_ENVIRONMENT_TEST_H_
 #define ART_RUNTIME_DEX2OAT_ENVIRONMENT_TEST_H_
 
+#include <sys/wait.h>
+
 #include <fstream>
 #include <optional>
 #include <string>
 #include <vector>
 
+#include "android-base/result.h"
+#include "android-base/strings.h"
 #include "base/file_utils.h"
 #include "base/macros.h"
 #include "base/os.h"
@@ -41,6 +45,8 @@
 
 namespace art HIDDEN {
 
+using ::android::base::Result;
+
 static constexpr bool kDebugArgs = false;
 
 class Dex2oatScratchDirs {
@@ -193,12 +199,11 @@ class Dex2oatEnvironmentTest : public Dex2oatScratchDirs, public CommonRuntimeTe
     return GetTestDexFileName("Nested");
   }
 
-  int Dex2Oat(const std::vector<std::string>& dex2oat_args,
-              std::string* output,
-              std::string* error_msg) {
+  Result<int> Dex2Oat(const std::vector<std::string>& dex2oat_args, std::string* output) {
     std::vector<std::string> argv;
-    if (!CommonRuntimeTest::StartDex2OatCommandLine(&argv, error_msg)) {
-      ::testing::AssertionFailure() << "Could not start dex2oat cmd line " << *error_msg;
+    std::string error_msg;
+    if (!CommonRuntimeTest::StartDex2OatCommandLine(&argv, &error_msg)) {
+      return Errorf("Could not start dex2oat cmd line: {}", error_msg);
     }
 
     Runtime* runtime = Runtime::Current();
@@ -235,18 +240,20 @@ class Dex2oatEnvironmentTest : public Dex2oatScratchDirs, public CommonRuntimeTe
 
     // We need dex2oat to actually log things.
     auto post_fork_fn = []() { return setenv("ANDROID_LOG_TAGS", "*:d", 1) == 0; };
+
     ForkAndExecResult res = ForkAndExec(argv, post_fork_fn, output);
     if (res.stage != ForkAndExecResult::kFinished) {
-      *error_msg = strerror(errno);
-      ::testing::AssertionFailure() << "Failed to finish dex2oat invocation: " << *error_msg;
+      return ErrnoErrorf("Failed to finish dex2oat invocation '{}'",
+                         android::base::Join(argv, ' '));
     }
 
-    if (!res.StandardSuccess()) {
-      // We cannot use ASSERT_TRUE since the method returns an int and not void.
-      ::testing::AssertionFailure() << "dex2oat fork/exec failed: " << *error_msg;
+    if (!WIFEXITED(res.status_code)) {
+      return Errorf("dex2oat didn't terminate normally (status_code={:#x}): {}",
+                    res.status_code,
+                    android::base::Join(argv, ' '));
     }
 
-    return res.status_code;
+    return WEXITSTATUS(res.status_code);
   }
 
   void CreateDexMetadata(const std::string& vdex, const std::string& out_dm) {
diff --git a/runtime/entrypoints/entrypoint_utils-inl.h b/runtime/entrypoints/entrypoint_utils-inl.h
index b0d0ab4b07..fde8043032 100644
--- a/runtime/entrypoints/entrypoint_utils-inl.h
+++ b/runtime/entrypoints/entrypoint_utils-inl.h
@@ -509,6 +509,7 @@ static inline bool IsStringInit(const Instruction& instr, ArtMethod* caller)
   return false;
 }
 
+LIBART_PROTECTED
 extern "C" size_t NterpGetMethod(Thread* self, ArtMethod* caller, const uint16_t* dex_pc_ptr);
 
 template <InvokeType type>
diff --git a/runtime/entrypoints/entrypoint_utils.h b/runtime/entrypoints/entrypoint_utils.h
index 3dfeaae024..a5408752be 100644
--- a/runtime/entrypoints/entrypoint_utils.h
+++ b/runtime/entrypoints/entrypoint_utils.h
@@ -181,7 +181,7 @@ JValue InvokeProxyInvocationHandler(ScopedObjectAccessAlreadyRunnable& soa,
     REQUIRES_SHARED(Locks::mutator_lock_)
     REQUIRES(!Roles::uninterruptible_);
 
-bool FillArrayData(ObjPtr<mirror::Object> obj, const Instruction::ArrayDataPayload* payload)
+EXPORT bool FillArrayData(ObjPtr<mirror::Object> obj, const Instruction::ArrayDataPayload* payload)
     REQUIRES_SHARED(Locks::mutator_lock_)
     REQUIRES(!Roles::uninterruptible_);
 
diff --git a/runtime/entrypoints/quick/quick_default_externs.h b/runtime/entrypoints/quick/quick_default_externs.h
index 5119b27076..7736964067 100644
--- a/runtime/entrypoints/quick/quick_default_externs.h
+++ b/runtime/entrypoints/quick/quick_default_externs.h
@@ -132,6 +132,7 @@ extern "C" void art_jni_unlock_object_no_inline(art::mirror::Object*);
 
 // Polymorphic invoke entrypoints.
 extern "C" void art_quick_invoke_polymorphic(uint32_t, void*);
+extern "C" void art_quick_invoke_polymorphic_with_hidden_receiver(uint32_t, void*);
 extern "C" void art_quick_invoke_custom(uint32_t, void*);
 
 // Thread entrypoints.
diff --git a/runtime/entrypoints/quick/quick_default_init_entrypoints.h b/runtime/entrypoints/quick/quick_default_init_entrypoints.h
index 46840e60ed..8249285aae 100644
--- a/runtime/entrypoints/quick/quick_default_init_entrypoints.h
+++ b/runtime/entrypoints/quick/quick_default_init_entrypoints.h
@@ -109,6 +109,8 @@ static void DefaultInitEntryPoints(JniEntryPoints* jpoints,
   qpoints->SetInvokeVirtualTrampolineWithAccessCheck(
       art_quick_invoke_virtual_trampoline_with_access_check);
   qpoints->SetInvokePolymorphic(art_quick_invoke_polymorphic);
+  // Adding support for x86_64 first.
+  qpoints->SetInvokePolymorphicWithHiddenReceiver(nullptr);
   qpoints->SetInvokeCustom(art_quick_invoke_custom);
 
   // Thread
@@ -136,6 +138,10 @@ static void DefaultInitEntryPoints(JniEntryPoints* jpoints,
   qpoints->SetMethodEntryHook(art_quick_method_entry_hook);
   qpoints->SetMethodExitHook(art_quick_method_exit_hook);
 
+  // These are used for on-demand-tracing, currently only supported on arm64 devices.
+  qpoints->SetRecordEntryTraceEvent(nullptr);
+  qpoints->SetRecordExitTraceEvent(nullptr);
+
   if (monitor_jni_entry_exit) {
     qpoints->SetJniMethodStart(art_jni_monitored_method_start);
     qpoints->SetJniMethodEnd(art_jni_monitored_method_end);
diff --git a/runtime/entrypoints/quick/quick_deoptimization_entrypoints.cc b/runtime/entrypoints/quick/quick_deoptimization_entrypoints.cc
index 29060457fd..3dfeacc7ba 100644
--- a/runtime/entrypoints/quick/quick_deoptimization_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_deoptimization_entrypoints.cc
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include "arch/context.h"
 #include "base/logging.h"  // For VLOG_IS_ON.
 #include "base/mutex.h"
 #include "callee_save_frame.h"
@@ -25,48 +26,18 @@
 
 namespace art HIDDEN {
 
-NO_RETURN static void artDeoptimizeImpl(Thread* self,
-                                        DeoptimizationKind kind,
-                                        bool single_frame,
-                                        bool skip_method_exit_callbacks)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
-  Runtime::Current()->IncrementDeoptimizationCount(kind);
-  if (VLOG_IS_ON(deopt)) {
-    if (single_frame) {
-      // Deopt logging will be in DeoptimizeSingleFrame. It is there to take advantage of the
-      // specialized visitor that will show whether a method is Quick or Shadow.
-    } else {
-      LOG(INFO) << "Deopting:";
-      self->Dump(LOG_STREAM(INFO));
-    }
-  }
-
-  self->AssertHasDeoptimizationContext();
-  QuickExceptionHandler exception_handler(self, true);
-  if (single_frame) {
-    exception_handler.DeoptimizeSingleFrame(kind);
-  } else {
-    exception_handler.DeoptimizeStack(skip_method_exit_callbacks);
-  }
-  if (exception_handler.IsFullFragmentDone()) {
-    exception_handler.DoLongJump(true);
-  } else {
-    exception_handler.DeoptimizePartialFragmentFixup();
-    // We cannot smash the caller-saves, as we need the ArtMethod in a parameter register that would
-    // be caller-saved. This has the downside that we cannot track incorrect register usage down the
-    // line.
-    exception_handler.DoLongJump(false);
-  }
-}
-
-extern "C" NO_RETURN void artDeoptimize(Thread* self, bool skip_method_exit_callbacks)
+extern "C" Context* artDeoptimize(Thread* self, bool skip_method_exit_callbacks)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
-  artDeoptimizeImpl(self, DeoptimizationKind::kFullFrame, false, skip_method_exit_callbacks);
+  std::unique_ptr<Context> context = self->Deoptimize(DeoptimizationKind::kFullFrame,
+                                                      /*single_frame=*/ false,
+                                                      skip_method_exit_callbacks);
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // This is called directly from compiled code by an HDeoptimize.
-extern "C" NO_RETURN void artDeoptimizeFromCompiledCode(DeoptimizationKind kind, Thread* self)
+extern "C" Context* artDeoptimizeFromCompiledCode(DeoptimizationKind kind, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   // Before deoptimizing to interpreter, we must push the deoptimization context.
@@ -79,7 +50,11 @@ extern "C" NO_RETURN void artDeoptimizeFromCompiledCode(DeoptimizationKind kind,
                                   DeoptimizationMethodType::kDefault);
   // Deopting from compiled code, so method exit haven't run yet. Don't skip method exit callbacks
   // if required.
-  artDeoptimizeImpl(self, kind, true, /* skip_method_exit_callbacks= */ false);
+  std::unique_ptr<Context> context = self->Deoptimize(kind,
+                                                      /*single_frame=*/ true,
+                                                      /* skip_method_exit_callbacks= */ false);
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 }  // namespace art
diff --git a/runtime/entrypoints/quick/quick_entrypoints_list.h b/runtime/entrypoints/quick/quick_entrypoints_list.h
index aa3360e1a4..e6f89e337c 100644
--- a/runtime/entrypoints/quick/quick_entrypoints_list.h
+++ b/runtime/entrypoints/quick/quick_entrypoints_list.h
@@ -134,6 +134,7 @@
   V(InvokeSuperTrampolineWithAccessCheck, void, uint32_t, void*) \
   V(InvokeVirtualTrampolineWithAccessCheck, void, uint32_t, void*) \
   V(InvokePolymorphic, void, uint32_t, void*) \
+  V(InvokePolymorphicWithHiddenReceiver, void, uint32_t, void*) \
   V(InvokeCustom, void, uint32_t, void*) \
 \
   V(TestSuspend, void, void) \
@@ -208,7 +209,9 @@
   V(ReadBarrierForRootSlow, mirror::Object*, GcRoot<mirror::Object>*) \
 \
   V(MethodEntryHook, void, ArtMethod*, Thread*) \
-  V(MethodExitHook, int32_t, Thread*, ArtMethod*, uint64_t*, uint64_t*)
+  V(MethodExitHook, int32_t, Thread*, ArtMethod*, uint64_t*, uint64_t*) \
+  V(RecordEntryTraceEvent, void) \
+  V(RecordExitTraceEvent, void)
 
 #endif  // ART_RUNTIME_ENTRYPOINTS_QUICK_QUICK_ENTRYPOINTS_LIST_H_
 #undef ART_RUNTIME_ENTRYPOINTS_QUICK_QUICK_ENTRYPOINTS_LIST_H_   // #define is only for lint.
diff --git a/runtime/entrypoints/quick/quick_thread_entrypoints.cc b/runtime/entrypoints/quick/quick_thread_entrypoints.cc
index 53e14d0d7a..e3511c80d5 100644
--- a/runtime/entrypoints/quick/quick_thread_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_thread_entrypoints.cc
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include "arch/context.h"
 #include "callee_save_frame.h"
 #include "jit/jit.h"
 #include "runtime.h"
@@ -21,8 +22,9 @@
 
 namespace art HIDDEN {
 
-extern "C" void artDeoptimizeIfNeeded(Thread* self, uintptr_t result, bool is_ref)
+extern "C" Context* artDeoptimizeIfNeeded(Thread* self, uintptr_t result, bool is_ref)
     REQUIRES_SHARED(Locks::mutator_lock_) {
+  ScopedQuickEntrypointChecks sqec(self);
   instrumentation::Instrumentation* instr = Runtime::Current()->GetInstrumentation();
   DCHECK(!self->IsExceptionPending());
 
@@ -32,10 +34,11 @@ extern "C" void artDeoptimizeIfNeeded(Thread* self, uintptr_t result, bool is_re
   DeoptimizationMethodType type = instr->GetDeoptimizationMethodType(*sp);
   JValue jvalue;
   jvalue.SetJ(result);
-  instr->DeoptimizeIfNeeded(self, sp, type, jvalue, is_ref);
+  std::unique_ptr<Context> context = instr->DeoptimizeIfNeeded(self, sp, type, jvalue, is_ref);
+  return context.release();
 }
 
-extern "C" void artTestSuspendFromCode(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_) {
+extern "C" Context* artTestSuspendFromCode(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_) {
   // Called when there is a pending checkpoint or suspend request.
   ScopedQuickEntrypointChecks sqec(self);
   self->CheckSuspend();
@@ -45,11 +48,12 @@ extern "C" void artTestSuspendFromCode(Thread* self) REQUIRES_SHARED(Locks::muta
   ArtMethod** sp = self->GetManagedStack()->GetTopQuickFrame();
   JValue result;
   result.SetJ(0);
-  Runtime::Current()->GetInstrumentation()->DeoptimizeIfNeeded(
+  std::unique_ptr<Context> context = Runtime::Current()->GetInstrumentation()->DeoptimizeIfNeeded(
       self, sp, DeoptimizationMethodType::kKeepDexPc, result, /* is_ref= */ false);
+  return context.release();
 }
 
-extern "C" void artImplicitSuspendFromCode(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_) {
+extern "C" Context* artImplicitSuspendFromCode(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_) {
   // Called when there is a pending checkpoint or suspend request.
   ScopedQuickEntrypointChecks sqec(self);
   self->CheckSuspend(/*implicit=*/ true);
@@ -59,8 +63,9 @@ extern "C" void artImplicitSuspendFromCode(Thread* self) REQUIRES_SHARED(Locks::
   ArtMethod** sp = self->GetManagedStack()->GetTopQuickFrame();
   JValue result;
   result.SetJ(0);
-  Runtime::Current()->GetInstrumentation()->DeoptimizeIfNeeded(
+  std::unique_ptr<Context> context = Runtime::Current()->GetInstrumentation()->DeoptimizeIfNeeded(
       self, sp, DeoptimizationMethodType::kKeepDexPc, result, /* is_ref= */ false);
+  return context.release();
 }
 
 extern "C" void artCompileOptimized(ArtMethod* method, Thread* self)
diff --git a/runtime/entrypoints/quick/quick_throw_entrypoints.cc b/runtime/entrypoints/quick/quick_throw_entrypoints.cc
index 781f3e549d..3ca95eabe4 100644
--- a/runtime/entrypoints/quick/quick_throw_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_throw_entrypoints.cc
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include "arch/context.h"
 #include "art_method-inl.h"
 #include "callee_save_frame.h"
 #include "dex/code_item_accessors-inl.h"
@@ -27,23 +28,27 @@
 namespace art HIDDEN {
 
 // Deliver an exception that's pending on thread helping set up a callee save frame on the way.
-extern "C" NO_RETURN void artDeliverPendingExceptionFromCode(Thread* self)
+extern "C" Context* artDeliverPendingExceptionFromCode(Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
-extern "C" NO_RETURN uint64_t artInvokeObsoleteMethod(ArtMethod* method, Thread* self)
+extern "C" Context* artInvokeObsoleteMethod(ArtMethod* method, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   DCHECK(method->IsObsolete());
   ScopedQuickEntrypointChecks sqec(self);
   ThrowInternalError("Attempting to invoke obsolete version of '%s'.",
                      method->PrettyMethod().c_str());
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // Called by generated code to throw an exception.
-extern "C" NO_RETURN void artDeliverExceptionFromCode(mirror::Throwable* exception, Thread* self)
+extern "C" Context* artDeliverExceptionFromCode(mirror::Throwable* exception, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   /*
    * exception may be null, in which case this routine should
@@ -58,61 +63,75 @@ extern "C" NO_RETURN void artDeliverExceptionFromCode(mirror::Throwable* excepti
   } else {
     self->SetException(exception);
   }
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // Called by generated code to throw a NPE exception.
-extern "C" NO_RETURN void artThrowNullPointerExceptionFromCode(Thread* self)
+extern "C" Context* artThrowNullPointerExceptionFromCode(Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   // We come from an explicit check in the generated code. This path is triggered
   // only if the object is indeed null.
   ThrowNullPointerExceptionFromDexPC(/* check_address= */ false, 0U);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // Installed by a signal handler to throw a NPE exception.
-extern "C" NO_RETURN void artThrowNullPointerExceptionFromSignal(uintptr_t addr, Thread* self)
+extern "C" Context* artThrowNullPointerExceptionFromSignal(uintptr_t addr, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   ThrowNullPointerExceptionFromDexPC(/* check_address= */ true, addr);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // Called by generated code to throw an arithmetic divide by zero exception.
-extern "C" NO_RETURN void artThrowDivZeroFromCode(Thread* self)
+extern "C" Context* artThrowDivZeroFromCode(Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   ThrowArithmeticExceptionDivideByZero();
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // Called by generated code to throw an array index out of bounds exception.
-extern "C" NO_RETURN void artThrowArrayBoundsFromCode(int index, int length, Thread* self)
+extern "C" Context* artThrowArrayBoundsFromCode(int index, int length, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   ThrowArrayIndexOutOfBoundsException(index, length);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 // Called by generated code to throw a string index out of bounds exception.
-extern "C" NO_RETURN void artThrowStringBoundsFromCode(int index, int length, Thread* self)
+extern "C" Context* artThrowStringBoundsFromCode(int index, int length, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   ThrowStringIndexOutOfBoundsException(index, length);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
-extern "C" NO_RETURN void artThrowStackOverflowFromCode(Thread* self)
+extern "C" Context* artThrowStackOverflowFromCode(Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   ThrowStackOverflowError(self);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
-extern "C" NO_RETURN void artThrowClassCastException(mirror::Class* dest_type,
-                                                     mirror::Class* src_type,
-                                                     Thread* self)
+extern "C" Context* artThrowClassCastException(mirror::Class* dest_type,
+                                               mirror::Class* src_type,
+                                               Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   if (dest_type == nullptr) {
@@ -137,23 +156,28 @@ extern "C" NO_RETURN void artThrowClassCastException(mirror::Class* dest_type,
   }
   DCHECK(!dest_type->IsAssignableFrom(src_type));
   ThrowClassCastException(dest_type, src_type);
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
-extern "C" NO_RETURN void artThrowClassCastExceptionForObject(mirror::Object* obj,
-                                                              mirror::Class* dest_type,
-                                                              Thread* self)
+extern "C" Context* artThrowClassCastExceptionForObject(mirror::Object* obj,
+                                                        mirror::Class* dest_type,
+                                                        Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   DCHECK(obj != nullptr);
-  artThrowClassCastException(dest_type, obj->GetClass(), self);
+  return artThrowClassCastException(dest_type, obj->GetClass(), self);
 }
 
-extern "C" NO_RETURN void artThrowArrayStoreException(mirror::Object* array, mirror::Object* value,
-                                                      Thread* self)
+extern "C" Context* artThrowArrayStoreException(mirror::Object* array,
+                                                mirror::Object* value,
+                                                Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
   ThrowArrayStoreException(value->GetClass(), array->GetClass());
-  self->QuickDeliverException();
+  std::unique_ptr<Context> context = self->QuickDeliverException();
+  DCHECK(context != nullptr);
+  return context.release();
 }
 
 }  // namespace art
diff --git a/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc b/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
index b53339acd9..99390f1b3e 100644
--- a/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
@@ -14,8 +14,12 @@
  * limitations under the License.
  */
 
+#include "android-base/logging.h"
+#include "arch/context.h"
 #include "art_method-inl.h"
+#include "art_method.h"
 #include "base/callee_save_type.h"
+#include "base/globals.h"
 #include "base/pointer_size.h"
 #include "callee_save_frame.h"
 #include "common_throws.h"
@@ -60,8 +64,8 @@
 
 namespace art HIDDEN {
 
-extern "C" NO_RETURN void artDeoptimizeFromCompiledCode(DeoptimizationKind kind, Thread* self);
-extern "C" NO_RETURN void artDeoptimize(Thread* self, bool skip_method_exit_callbacks);
+extern "C" Context* artDeoptimizeFromCompiledCode(DeoptimizationKind kind, Thread* self);
+extern "C" Context* artDeoptimize(Thread* self, bool skip_method_exit_callbacks);
 
 // Visits the arguments as saved to the stack by a CalleeSaveType::kRefAndArgs callee save frame.
 class QuickArgumentVisitor {
@@ -238,6 +242,10 @@ class QuickArgumentVisitor {
   // | RBX/R3          |    callee save
   // | RDX/R2          |    arg2
   // | RCX/R1          |    arg3
+  // | XMM15           |    callee save
+  // | XMM14           |    callee save
+  // | XMM13           |    callee save
+  // | XMM12           |    callee save
   // | XMM7            |    float arg 8
   // | XMM6            |    float arg 7
   // | XMM5            |    float arg 6
@@ -576,6 +584,7 @@ class BuildQuickShadowFrameVisitor final : public QuickArgumentVisitor {
       : QuickArgumentVisitor(sp, is_static, shorty), sf_(sf), cur_reg_(first_arg_reg) {}
 
   void Visit() REQUIRES_SHARED(Locks::mutator_lock_) override;
+  void SetReceiver(ObjPtr<mirror::Object> receiver) REQUIRES_SHARED(Locks::mutator_lock_);
 
  private:
   ShadowFrame* const sf_;
@@ -584,6 +593,12 @@ class BuildQuickShadowFrameVisitor final : public QuickArgumentVisitor {
   DISALLOW_COPY_AND_ASSIGN(BuildQuickShadowFrameVisitor);
 };
 
+void BuildQuickShadowFrameVisitor::SetReceiver(ObjPtr<mirror::Object> receiver) {
+  DCHECK_EQ(cur_reg_, 0u);
+  sf_->SetVRegReference(cur_reg_, receiver);
+  ++cur_reg_;
+}
+
 void BuildQuickShadowFrameVisitor::Visit() {
   Primitive::Type type = GetParamPrimitiveType();
   switch (type) {
@@ -2365,14 +2380,6 @@ extern "C" uint64_t artInvokePolymorphic(mirror::Object* raw_receiver, Thread* s
   ArtMethod* resolved_method = linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
       self, inst.VRegB(), caller_method, kVirtual);
 
-  Handle<mirror::MethodType> method_type(
-      hs.NewHandle(linker->ResolveMethodType(self, proto_idx, caller_method)));
-  if (UNLIKELY(method_type.IsNull())) {
-    // This implies we couldn't resolve one or more types in this method handle.
-    CHECK(self->IsExceptionPending());
-    return 0UL;
-  }
-
   DCHECK_EQ(ArtMethod::NumArgRegisters(shorty) + 1u, (uint32_t)inst.VRegA());
   DCHECK_EQ(resolved_method->IsStatic(), kMethodIsStatic);
 
@@ -2401,10 +2408,18 @@ extern "C" uint64_t artInvokePolymorphic(mirror::Object* raw_receiver, Thread* s
   // Call DoInvokePolymorphic with |is_range| = true, as shadow frame has argument registers in
   // consecutive order.
   RangeInstructionOperands operands(first_arg + 1, num_vregs - 1);
-  Intrinsics intrinsic = static_cast<Intrinsics>(resolved_method->GetIntrinsic());
+  Intrinsics intrinsic = resolved_method->GetIntrinsic();
   JValue result;
   bool success = false;
   if (resolved_method->GetDeclaringClass() == GetClassRoot<mirror::MethodHandle>(linker)) {
+    Handle<mirror::MethodType> method_type(
+        hs.NewHandle(linker->ResolveMethodType(self, proto_idx, caller_method)));
+    if (UNLIKELY(method_type.IsNull())) {
+      // This implies we couldn't resolve one or more types in this method handle.
+      CHECK(self->IsExceptionPending());
+      return 0UL;
+    }
+
     Handle<mirror::MethodHandle> method_handle(hs.NewHandle(
         ObjPtr<mirror::MethodHandle>::DownCast(receiver_handle.Get())));
     if (intrinsic == Intrinsics::kMethodHandleInvokeExact) {
@@ -2430,10 +2445,12 @@ extern "C" uint64_t artInvokePolymorphic(mirror::Object* raw_receiver, Thread* s
         ObjPtr<mirror::VarHandle>::DownCast(receiver_handle.Get())));
     mirror::VarHandle::AccessMode access_mode =
         mirror::VarHandle::GetAccessModeByIntrinsic(intrinsic);
+
     success = VarHandleInvokeAccessor(self,
                                       *shadow_frame,
                                       var_handle,
-                                      method_type,
+                                      caller_method,
+                                      proto_idx,
                                       access_mode,
                                       &operands,
                                       &result);
@@ -2451,6 +2468,106 @@ extern "C" uint64_t artInvokePolymorphic(mirror::Object* raw_receiver, Thread* s
   return NanBoxResultIfNeeded(result.GetJ(), shorty[0]);
 }
 
+extern "C" uint64_t artInvokePolymorphicWithHiddenReceiver(mirror::Object* raw_receiver,
+                                                           Thread* self,
+                                                           ArtMethod** sp)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
+  ScopedQuickEntrypointChecks sqec(self);
+  DCHECK(raw_receiver != nullptr);
+  DCHECK(raw_receiver->InstanceOf(WellKnownClasses::java_lang_invoke_MethodHandle.Get()));
+  DCHECK_EQ(*sp, Runtime::Current()->GetCalleeSaveMethod(CalleeSaveType::kSaveRefsAndArgs));
+
+  JNIEnvExt* env = self->GetJniEnv();
+  ScopedObjectAccessUnchecked soa(env);
+  ScopedJniEnvLocalRefState env_state(env);
+  const char* old_cause = self->StartAssertNoThreadSuspension("Making stack arguments safe.");
+
+  // From the instruction, get the |callsite_shorty| and expose arguments on the stack to the GC.
+  uint32_t dex_pc;
+  ArtMethod* caller_method = QuickArgumentVisitor::GetCallingMethodAndDexPc(sp, &dex_pc);
+  const Instruction& inst = caller_method->DexInstructions().InstructionAt(dex_pc);
+  DCHECK(inst.Opcode() == Instruction::INVOKE_POLYMORPHIC ||
+         inst.Opcode() == Instruction::INVOKE_POLYMORPHIC_RANGE);
+  const dex::ProtoIndex proto_idx(inst.VRegH());
+  std::string_view shorty = caller_method->GetDexFile()->GetShortyView(proto_idx);
+
+  // invokeExact is not a static method, but here we use custom calling convention and the receiver
+  // (MethodHandle) object is not passed as a first argument, but through different means and hence
+  // shorty and arguments allocation looks as-if invokeExact was static.
+  RememberForGcArgumentVisitor gc_visitor(sp, /* is_static= */ true, shorty, &soa);
+  gc_visitor.VisitArguments();
+
+  // Wrap raw_receiver in a Handle for safety.
+  StackHandleScope<2> hs(self);
+  Handle<mirror::MethodHandle> method_handle(
+      hs.NewHandle(down_cast<mirror::MethodHandle*>(raw_receiver)));
+
+  self->EndAssertNoThreadSuspension(old_cause);
+
+  ClassLinker* linker = Runtime::Current()->GetClassLinker();
+  ArtMethod* invoke_exact = WellKnownClasses::java_lang_invoke_MethodHandle_invokeExact;
+  if (kIsDebugBuild) {
+    ArtMethod* resolved_method = linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
+        self, inst.VRegB(), caller_method, kVirtual);
+    CHECK_EQ(resolved_method, invoke_exact);
+  }
+
+  Handle<mirror::MethodType> method_type(
+      hs.NewHandle(linker->ResolveMethodType(self, proto_idx, caller_method)));
+  if (UNLIKELY(method_type.IsNull())) {
+    // This implies we couldn't resolve one or more types in this method handle.
+    CHECK(self->IsExceptionPending());
+    return 0UL;
+  }
+
+  DCHECK_EQ(ArtMethod::NumArgRegisters(shorty) + 1u, (uint32_t)inst.VRegA());
+
+  // Fix references before constructing the shadow frame.
+  gc_visitor.FixupReferences();
+
+  // Construct shadow frame placing arguments consecutively from |first_arg|.
+  const bool is_range = inst.Opcode() == Instruction::INVOKE_POLYMORPHIC_RANGE;
+  const size_t num_vregs = is_range ? inst.VRegA_4rcc() : inst.VRegA_45cc();
+  const size_t first_arg = 0;
+  ShadowFrameAllocaUniquePtr shadow_frame_unique_ptr =
+      CREATE_SHADOW_FRAME(num_vregs, invoke_exact, dex_pc);
+  ShadowFrame* shadow_frame = shadow_frame_unique_ptr.get();
+  ScopedStackedShadowFramePusher frame_pusher(self, shadow_frame);
+  // Pretend the method is static, see the gc_visitor comment above.
+  BuildQuickShadowFrameVisitor shadow_frame_builder(sp,
+                                                    /* is_static= */ true,
+                                                    shorty,
+                                                    shadow_frame,
+                                                    first_arg);
+  // Receiver is not passed as a regular argument, adding it to ShadowFrame manually.
+  shadow_frame_builder.SetReceiver(method_handle.Get());
+  shadow_frame_builder.VisitArguments();
+
+  // Push a transition back into managed code onto the linked list in thread.
+  ManagedStack fragment;
+  self->PushManagedStackFragment(&fragment);
+
+  RangeInstructionOperands operands(first_arg + 1, num_vregs - 1);
+  JValue result;
+  bool success = MethodHandleInvokeExact(self,
+                                         *shadow_frame,
+                                         method_handle,
+                                         method_type,
+                                         &operands,
+                                         &result);
+
+  DCHECK(success || self->IsExceptionPending());
+
+  // Pop transition record.
+  self->PopManagedStackFragment(fragment);
+
+  bool is_ref = shorty[0] == 'L';
+  Runtime::Current()->GetInstrumentation()->PushDeoptContextIfNeeded(
+      self, DeoptimizationMethodType::kDefault, is_ref, result);
+
+  return NanBoxResultIfNeeded(result.GetJ(), shorty[0]);
+}
+
 // Returns uint64_t representing raw bits from JValue.
 extern "C" uint64_t artInvokeCustom(uint32_t call_site_idx, Thread* self, ArtMethod** sp)
     REQUIRES_SHARED(Locks::mutator_lock_) {
@@ -2517,12 +2634,14 @@ extern "C" void artJniMethodEntryHook(Thread* self)
   instr->MethodEnterEvent(self, method);
 }
 
-extern "C" void artMethodEntryHook(ArtMethod* method, Thread* self, ArtMethod** sp)
+extern "C" Context* artMethodEntryHook(ArtMethod* method, Thread* self, ArtMethod** sp)
     REQUIRES_SHARED(Locks::mutator_lock_) {
+  ScopedQuickEntrypointChecks sqec(self);
   instrumentation::Instrumentation* instr = Runtime::Current()->GetInstrumentation();
   if (instr->HasFastMethodEntryListenersOnly()) {
     instr->MethodEnterEvent(self, method);
-    return;
+    // No exception or deoptimization.
+    return nullptr;
   }
 
   if (instr->HasMethodEntryListeners()) {
@@ -2533,19 +2652,22 @@ extern "C" void artMethodEntryHook(ArtMethod* method, Thread* self, ArtMethod**
       // Instrumentation can request deoptimizing only a particular method (for ex: when
       // there are break points on the method). In such cases deoptimize only this method.
       // FullFrame deoptimizations are handled on method exits.
-      artDeoptimizeFromCompiledCode(DeoptimizationKind::kDebugging, self);
+      return artDeoptimizeFromCompiledCode(DeoptimizationKind::kDebugging, self);
     }
   } else {
     DCHECK(!instr->IsDeoptimized(method));
   }
+  // No exception or deoptimization.
+  return nullptr;
 }
 
-extern "C" void artMethodExitHook(Thread* self,
-                                  ArtMethod** sp,
-                                  uint64_t* gpr_result,
-                                  uint64_t* fpr_result,
-                                  uint32_t frame_size)
+extern "C" Context* artMethodExitHook(Thread* self,
+                                      ArtMethod** sp,
+                                      uint64_t* gpr_result,
+                                      uint64_t* fpr_result,
+                                      uint32_t frame_size)
   REQUIRES_SHARED(Locks::mutator_lock_) {
+  ScopedQuickEntrypointChecks sqec(self);
   DCHECK_EQ(reinterpret_cast<uintptr_t>(self), reinterpret_cast<uintptr_t>(Thread::Current()));
   // Instrumentation exit stub must not be entered with a pending exception.
   CHECK(!self->IsExceptionPending())
@@ -2560,7 +2682,8 @@ extern "C" void artMethodExitHook(Thread* self,
     // or a return value.
     JValue return_value;
     instr->MethodExitEvent(self, method, /* frame= */ {}, return_value);
-    return;
+    // No exception or deoptimization.
+    return nullptr;
   }
 
   bool is_ref = false;
@@ -2593,8 +2716,10 @@ extern "C" void artMethodExitHook(Thread* self,
   if (self->IsExceptionPending() || self->ObserveAsyncException()) {
     // The exception was thrown from the method exit callback. We should not call method unwind
     // callbacks for this case.
-    self->QuickDeliverException(/* is_method_exit_exception= */ true);
-    UNREACHABLE();
+    std::unique_ptr<Context> context =
+        self->QuickDeliverException(/* is_method_exit_exception= */ true);
+    DCHECK(context != nullptr);
+    return context.release();
   }
 
   // We should deoptimize here if the caller requires a deoptimization or if the current method
@@ -2609,9 +2734,15 @@ extern "C" void artMethodExitHook(Thread* self,
         ret_val, is_ref, self->GetException(), false, deopt_method_type);
     // Method exit callback has already been run for this method. So tell the deoptimizer to skip
     // callbacks for this frame.
-    artDeoptimize(self, /*skip_method_exit_callbacks = */ true);
-    UNREACHABLE();
+    std::unique_ptr<Context> context = self->Deoptimize(DeoptimizationKind::kFullFrame,
+                                                        /* single_frame= */ false,
+                                                        /* skip_method_exit_callbacks= */ true);
+    DCHECK(context != nullptr);
+    return context.release();
   }
+
+  // No exception or deoptimization.
+  return nullptr;
 }
 
 }  // namespace art
diff --git a/runtime/entrypoints_order_test.cc b/runtime/entrypoints_order_test.cc
index 20f2863bb5..3f55d37e8d 100644
--- a/runtime/entrypoints_order_test.cc
+++ b/runtime/entrypoints_order_test.cc
@@ -96,22 +96,18 @@ class EntrypointsOrderTest : public CommonArtTest {
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, wait_next, monitor_enter_object, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, monitor_enter_object, top_handle_scope, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, top_handle_scope, class_loader_override, sizeof(void*));
-    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, class_loader_override, long_jump_context, sizeof(void*));
-    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, long_jump_context,
-                        stacked_shadow_frame_record, sizeof(void*));
+    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, class_loader_override, stacked_shadow_frame_record, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, stacked_shadow_frame_record,
                         deoptimization_context_stack, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, deoptimization_context_stack,
                         frame_id_to_shadow_frame, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, frame_id_to_shadow_frame, name, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, name, pthread_self, sizeof(void*));
-    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, pthread_self, last_no_thread_suspension_cause,
-                        sizeof(void*));
-    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, last_no_thread_suspension_cause,
-                        active_suspendall_barrier, sizeof(void*));
+    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, pthread_self, active_suspendall_barrier, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, active_suspendall_barrier,
                         active_suspend1_barriers, sizeof(void*));
-    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, active_suspend1_barriers, thread_local_pos, sizeof(void*));
+    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, active_suspend1_barriers, thread_local_pos,
+                        sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, thread_local_pos, thread_local_end, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, thread_local_end, thread_local_start, sizeof(void*));
     EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, thread_local_start, thread_local_limit, sizeof(void*));
@@ -136,14 +132,20 @@ class EntrypointsOrderTest : public CommonArtTest {
     EXPECT_OFFSET_DIFFP(
         Thread, tlsPtr_, top_reflective_handle_scope, method_trace_buffer, sizeof(void*));
     EXPECT_OFFSET_DIFFP(
-        Thread, tlsPtr_, method_trace_buffer, method_trace_buffer_index, sizeof(void*));
+        Thread, tlsPtr_, method_trace_buffer, method_trace_buffer_curr_entry, sizeof(void*));
     EXPECT_OFFSET_DIFFP(
-        Thread, tlsPtr_, method_trace_buffer_index, thread_exit_flags, sizeof(void*));
+        Thread, tlsPtr_, method_trace_buffer_curr_entry, thread_exit_flags, sizeof(void*));
+    EXPECT_OFFSET_DIFFP(
+        Thread, tlsPtr_, thread_exit_flags, last_no_thread_suspension_cause, sizeof(void*));
+    EXPECT_OFFSET_DIFFP(Thread, tlsPtr_, last_no_thread_suspension_cause,
+                        last_no_transaction_checks_cause, sizeof(void*));
     // The first field after tlsPtr_ is forced to a 16 byte alignment so it might have some space.
     auto offset_tlsptr_end = OFFSETOF_MEMBER(Thread, tlsPtr_) +
         sizeof(decltype(reinterpret_cast<Thread*>(16)->tlsPtr_));
-    CHECKED(offset_tlsptr_end - OFFSETOF_MEMBER(Thread, tlsPtr_.thread_exit_flags) == sizeof(void*),
-            "async_exception last field");
+    CHECKED(
+        offset_tlsptr_end - OFFSETOF_MEMBER(Thread, tlsPtr_.last_no_transaction_checks_cause) ==
+            sizeof(void*),
+        "last_no_transaction_checks_cause last field");
   }
 
   void CheckJniEntryPoints() {
@@ -289,7 +291,10 @@ class EntrypointsOrderTest : public CommonArtTest {
                          pInvokeVirtualTrampolineWithAccessCheck, sizeof(void*));
     EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pInvokeVirtualTrampolineWithAccessCheck,
                          pInvokePolymorphic, sizeof(void*));
-    EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pInvokePolymorphic, pInvokeCustom, sizeof(void*));
+    EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pInvokePolymorphic,
+                         pInvokePolymorphicWithHiddenReceiver, sizeof(void*));
+    EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pInvokePolymorphicWithHiddenReceiver,
+                         pInvokeCustom, sizeof(void*));
     EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pInvokeCustom, pTestSuspend, sizeof(void*));
     EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pTestSuspend, pDeliverException, sizeof(void*));
 
@@ -410,8 +415,10 @@ class EntrypointsOrderTest : public CommonArtTest {
     EXPECT_OFFSET_DIFFNP(
         QuickEntryPoints, pReadBarrierForRootSlow, pMethodEntryHook, sizeof(void*));
     EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pMethodEntryHook, pMethodExitHook, sizeof(void*));
+    EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pMethodExitHook, pRecordEntryTraceEvent, sizeof(void*));
+    EXPECT_OFFSET_DIFFNP(QuickEntryPoints, pRecordEntryTraceEvent, pRecordExitTraceEvent, sizeof(void*));
 
-    CHECKED(OFFSETOF_MEMBER(QuickEntryPoints, pMethodExitHook) + sizeof(void*) ==
+    CHECKED(OFFSETOF_MEMBER(QuickEntryPoints, pRecordExitTraceEvent) + sizeof(void*) ==
                 sizeof(QuickEntryPoints),
             QuickEntryPoints_all);
   }
diff --git a/runtime/exec_utils.cc b/runtime/exec_utils.cc
index 05a7cc6bdc..927cc38df9 100644
--- a/runtime/exec_utils.cc
+++ b/runtime/exec_utils.cc
@@ -212,9 +212,8 @@ ExecResult WaitChildWithTimeout(pid_t pid,
 }
 
 bool ParseProcStat(const std::string& stat_content,
-                   int64_t uptime_ms,
                    int64_t ticks_per_sec,
-                   /*out*/ ProcessStat* stat) {
+                   /*out*/ int64_t* cpu_time_ms) {
   size_t pos = stat_content.rfind(") ");
   if (pos == std::string::npos) {
     return false;
@@ -224,22 +223,15 @@ bool ParseProcStat(const std::string& stat_content,
   // contain anything, including spaces.
   Split(std::string_view(stat_content).substr(pos + 2), ' ', &stat_fields);
   constexpr int kSkippedFields = 2;
-  int64_t utime, stime, cutime, cstime, starttime;
+  int64_t utime, stime, cutime, cstime;
   if (stat_fields.size() < 22 - kSkippedFields ||
       !ParseInt(stat_fields[13 - kSkippedFields], &utime) ||
       !ParseInt(stat_fields[14 - kSkippedFields], &stime) ||
       !ParseInt(stat_fields[15 - kSkippedFields], &cutime) ||
-      !ParseInt(stat_fields[16 - kSkippedFields], &cstime) ||
-      !ParseInt(stat_fields[21 - kSkippedFields], &starttime)) {
+      !ParseInt(stat_fields[16 - kSkippedFields], &cstime)) {
     return false;
   }
-  if (starttime == 0) {
-    // The start time is the time the process started after system boot, so it's not supposed to be
-    // zero unless the process is `init`.
-    return false;
-  }
-  stat->cpu_time_ms = (utime + stime + cutime + cstime) * 1000 / ticks_per_sec;
-  stat->wall_time_ms = uptime_ms - starttime * 1000 / ticks_per_sec;
+  *cpu_time_ms = (utime + stime + cutime + cstime) * 1000 / ticks_per_sec;
   return true;
 }
 
@@ -278,6 +270,8 @@ ExecResult ExecUtils::ExecAndReturnResult(const std::vector<std::string>& arg_ve
     return {.status = ExecResult::kStartFailed};
   }
 
+  std::string stat_error_msg;
+  std::optional<int64_t> start_time = GetUptimeMs(&stat_error_msg);
   callbacks.on_start(pid);
 
   // Wait for subprocess to finish.
@@ -297,9 +291,8 @@ ExecResult ExecUtils::ExecAndReturnResult(const std::vector<std::string>& arg_ve
   }
 
   if (stat != nullptr) {
-    std::string local_error_msg;
-    if (!GetStat(pid, stat, &local_error_msg)) {
-      LOG(ERROR) << "Failed to get process stat: " << local_error_msg;
+    if (!start_time.has_value() || !GetStat(pid, start_time.value(), stat, &stat_error_msg)) {
+      LOG(ERROR) << "Failed to get process stat: " << stat_error_msg;
     }
   }
 
@@ -352,6 +345,7 @@ std::optional<int64_t> ExecUtils::GetUptimeMs(std::string* error_msg) const {
 int64_t ExecUtils::GetTicksPerSec() const { return sysconf(_SC_CLK_TCK); }
 
 bool ExecUtils::GetStat(pid_t pid,
+                        int64_t start_time,
                         /*out*/ ProcessStat* stat,
                         /*out*/ std::string* error_msg) const {
   std::optional<int64_t> uptime_ms = GetUptimeMs(error_msg);
@@ -364,10 +358,11 @@ bool ExecUtils::GetStat(pid_t pid,
     return false;
   }
   int64_t ticks_per_sec = GetTicksPerSec();
-  if (!ParseProcStat(stat_content, *uptime_ms, ticks_per_sec, stat)) {
+  if (!ParseProcStat(stat_content, ticks_per_sec, &stat->cpu_time_ms)) {
     *error_msg = StringPrintf("Failed to parse /proc/%d/stat '%s'", pid, stat_content.c_str());
     return false;
   }
+  stat->wall_time_ms = uptime_ms.value() - start_time;
   return true;
 }
 
diff --git a/runtime/exec_utils.h b/runtime/exec_utils.h
index ebcc2e4e66..6a97cc7e5b 100644
--- a/runtime/exec_utils.h
+++ b/runtime/exec_utils.h
@@ -48,7 +48,7 @@ struct ExecCallbacks {
 
 struct ExecResult {
   // This struct needs to be in sync with the ExecResultStatus enum contained within the
-  // OdrefreshReported atom in frameworks/proto_logging/atoms/art/odrefresh_extension_atoms.proto.
+  // OdrefreshReported atom in frameworks/proto_logging/stats/enums/art/common_enums.proto.
   enum Status {
     // Unable to get the status.
     kUnknown = 0,
@@ -118,7 +118,10 @@ class EXPORT ExecUtils {
   virtual int64_t GetTicksPerSec() const;
 
  private:
-  bool GetStat(pid_t pid, /*out*/ ProcessStat* stat, /*out*/ std::string* error_msg) const;
+  bool GetStat(pid_t pid,
+               int64_t start_time,
+               /*out*/ ProcessStat* stat,
+               /*out*/ std::string* error_msg) const;
 };
 
 inline bool Exec(const std::vector<std::string>& arg_vector, /*out*/ std::string* error_msg) {
diff --git a/runtime/exec_utils_test.cc b/runtime/exec_utils_test.cc
index e1fc6272d5..eb21652c19 100644
--- a/runtime/exec_utils_test.cc
+++ b/runtime/exec_utils_test.cc
@@ -218,9 +218,11 @@ TEST_P(ExecUtilsTest, ExecStat) {
   // The process filename is "a) b".
   EXPECT_CALL(*exec_utils_, GetProcStat(_))
       .WillOnce(Return(
-          "14963 (a) b) Z 6067 14963 1 0 -1 4228108 105 0 0 0 94 5 0 0 39 19 1 0 162034388 0 0 "
+          "14963 (a) b) Z 6067 14963 1 0 -1 4228108 105 0 0 0 94 5 0 0 39 19 1 0 0 0 0 "
           "18446744073709551615 0 0 0 0 0 0 20999 0 0 1 0 0 17 71 0 0 0 0 0 0 0 0 0 0 0 0 9"));
-  EXPECT_CALL(*exec_utils_, DoGetUptimeMs()).WillOnce(Return(1620344887ll));
+  EXPECT_CALL(*exec_utils_, DoGetUptimeMs())
+      .WillOnce(Return(1620343880ll))
+      .WillOnce(Return(1620344887ll));
   EXPECT_CALL(*exec_utils_, GetTicksPerSec()).WillOnce(Return(100));
 
   ASSERT_EQ(exec_utils_
@@ -245,13 +247,8 @@ TEST_P(ExecUtilsTest, ExecStatNoStartTime) {
   std::string error_msg;
   ProcessStat stat;
 
-  // The process filename is "a) b".
-  EXPECT_CALL(*exec_utils_, GetProcStat(_))
-      .WillOnce(Return(
-          "14963 (a) b) Z 6067 14963 1 0 -1 4228108 105 0 0 0 94 5 0 0 39 19 1 0 0 0 0 "
-          "18446744073709551615 0 0 0 0 0 0 20999 0 0 1 0 0 17 71 0 0 0 0 0 0 0 0 0 0 0 0 9"));
-  EXPECT_CALL(*exec_utils_, DoGetUptimeMs()).WillOnce(Return(1620344887ll));
-  EXPECT_CALL(*exec_utils_, GetTicksPerSec()).WillOnce(Return(100));
+  EXPECT_CALL(*exec_utils_, DoGetUptimeMs())
+      .WillOnce(Return(Result<int64_t>(Errorf("Failed to get uptime"))));
 
   ASSERT_EQ(exec_utils_
                 ->ExecAndReturnResult(command,
@@ -276,6 +273,7 @@ TEST_P(ExecUtilsTest, ExecStatNoUptime) {
   ProcessStat stat;
 
   EXPECT_CALL(*exec_utils_, DoGetUptimeMs())
+      .WillOnce(Return(162034388ll))
       .WillOnce(Return(Result<int64_t>(Errorf("Failed to get uptime"))));
 
   ASSERT_EQ(exec_utils_
@@ -301,9 +299,11 @@ TEST_P(ExecUtilsTest, ExecStatFailed) {
 
   EXPECT_CALL(*exec_utils_, GetProcStat(_))
       .WillOnce(Return(
-          "14963 (a) b) Z 6067 14963 1 0 -1 4228108 105 0 0 0 94 5 0 0 39 19 1 0 162034388 0 0 "
+          "14963 (a) b) Z 6067 14963 1 0 -1 4228108 105 0 0 0 94 5 0 0 39 19 1 0 0 0 0 "
           "18446744073709551615 0 0 0 0 0 0 20999 0 0 1 0 0 17 71 0 0 0 0 0 0 0 0 0 0 0 0 9"));
-  EXPECT_CALL(*exec_utils_, DoGetUptimeMs()).WillOnce(Return(1620344887ll));
+  EXPECT_CALL(*exec_utils_, DoGetUptimeMs())
+      .WillOnce(Return(1620343880ll))
+      .WillOnce(Return(1620344887ll));
   EXPECT_CALL(*exec_utils_, GetTicksPerSec()).WillOnce(Return(100));
 
   // This will always time out.
diff --git a/runtime/fault_handler.cc b/runtime/fault_handler.cc
index 635de2af69..05bbfcf912 100644
--- a/runtime/fault_handler.cc
+++ b/runtime/fault_handler.cc
@@ -102,11 +102,6 @@ static std::ostream& PrintSignalInfo(std::ostream& os, siginfo_t* info) {
   return os;
 }
 
-static bool InstallSigbusHandler() {
-  return gUseUserfaultfd &&
-         Runtime::Current()->GetHeap()->MarkCompactCollector()->IsUsingSigbusFeature();
-}
-
 void FaultManager::Init(bool use_sig_chain) {
   CHECK(!initialized_);
   if (use_sig_chain) {
@@ -125,7 +120,7 @@ void FaultManager::Init(bool use_sig_chain) {
     };
 
     AddSpecialSignalHandlerFn(SIGSEGV, &sa);
-    if (InstallSigbusHandler()) {
+    if (gUseUserfaultfd) {
       sa.sc_sigaction = art_sigbus_handler;
       AddSpecialSignalHandlerFn(SIGBUS, &sa);
     }
@@ -151,7 +146,7 @@ void FaultManager::Init(bool use_sig_chain) {
     }
 
     initialized_ = true;
-  } else if (InstallSigbusHandler()) {
+  } else if (gUseUserfaultfd) {
     struct sigaction act;
     std::memset(&act, '\0', sizeof(act));
     act.sa_flags = SA_SIGINFO | SA_RESTART;
@@ -173,7 +168,7 @@ void FaultManager::Init(bool use_sig_chain) {
 void FaultManager::Release() {
   if (initialized_) {
     RemoveSpecialSignalHandlerFn(SIGSEGV, art_sigsegv_handler);
-    if (InstallSigbusHandler()) {
+    if (gUseUserfaultfd) {
       RemoveSpecialSignalHandlerFn(SIGBUS, art_sigbus_handler);
     }
     initialized_ = false;
diff --git a/runtime/fuzzer_corpus_test.cc b/runtime/fuzzer_corpus_test.cc
new file mode 100644
index 0000000000..24edebcc20
--- /dev/null
+++ b/runtime/fuzzer_corpus_test.cc
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cstdint>
+#include <filesystem>
+#include <unordered_set>
+
+#include "android-base/file.h"
+#include "android-base/macros.h"
+#include "common_runtime_test.h"
+#include "dex/class_accessor-inl.h"
+#include "dex/dex_file_verifier.h"
+#include "dex/standard_dex_file.h"
+#include "gtest/gtest.h"
+#include "handle_scope-inl.h"
+#include "jni/java_vm_ext.h"
+#include "verifier/class_verifier.h"
+#include "ziparchive/zip_archive.h"
+
+namespace art {
+// Global variable to count how many DEX files passed DEX file verification and they were
+// registered, since these are the cases for which we would be running the GC.
+int skipped_gc_iterations = 0;
+// Global variable to call the GC once every maximum number of iterations.
+// TODO: These values were obtained from local experimenting. They can be changed after
+// further investigation.
+static constexpr int kMaxSkipGCIterations = 100;
+
+// A class to be friends with ClassLinker and access the internal FindDexCacheDataLocked method.
+// TODO: Deduplicate this since it is the same with tools/fuzzer/libart_verify_classes_fuzzer.cc.
+class VerifyClassesFuzzerCorpusTestHelper {
+ public:
+  static const ClassLinker::DexCacheData* GetDexCacheData(Runtime* runtime, const DexFile* dex_file)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    Thread* self = Thread::Current();
+    ReaderMutexLock mu(self, *Locks::dex_lock_);
+    ClassLinker* class_linker = runtime->GetClassLinker();
+    const ClassLinker::DexCacheData* cached_data = class_linker->FindDexCacheDataLocked(*dex_file);
+    return cached_data;
+  }
+};
+
+// Manages the ZipArchiveHandle liveness.
+class ZipArchiveHandleScope {
+ public:
+  explicit ZipArchiveHandleScope(ZipArchiveHandle* handle) : handle_(handle) {}
+  ~ZipArchiveHandleScope() { CloseArchive(*(handle_.release())); }
+
+ private:
+  std::unique_ptr<ZipArchiveHandle> handle_;
+};
+
+class FuzzerCorpusTest : public CommonRuntimeTest {
+ public:
+  static void DexFileVerification(const uint8_t* data,
+                                  size_t size,
+                                  const std::string& name,
+                                  bool expected_success) {
+    // Do not verify the checksum as we only care about the DEX file contents,
+    // and know that the checksum would probably be erroneous (i.e. random).
+    constexpr bool kVerify = false;
+
+    auto container = std::make_shared<MemoryDexFileContainer>(data, size);
+    StandardDexFile dex_file(data,
+                             /*location=*/name,
+                             /*location_checksum=*/0,
+                             /*oat_dex_file=*/nullptr,
+                             container);
+
+    std::string error_msg;
+    bool is_valid_dex_file =
+        dex::Verify(&dex_file, dex_file.GetLocation().c_str(), kVerify, &error_msg);
+    ASSERT_EQ(is_valid_dex_file, expected_success) << " Failed for " << name;
+  }
+
+  static void ClassVerification(const uint8_t* data,
+                                size_t size,
+                                const std::string& name,
+                                bool expected_success) {
+    // Do not verify the checksum as we only care about the DEX file contents,
+    // and know that the checksum would probably be erroneous (i.e. random)
+    constexpr bool kVerify = false;
+    bool passed_class_verification = true;
+
+    auto container = std::make_shared<MemoryDexFileContainer>(data, size);
+    StandardDexFile dex_file(data,
+                             /*location=*/name,
+                             /*location_checksum=*/0,
+                             /*oat_dex_file=*/nullptr,
+                             container);
+
+    std::string error_msg;
+    const bool success_dex =
+        dex::Verify(&dex_file, dex_file.GetLocation().c_str(), kVerify, &error_msg);
+    ASSERT_EQ(success_dex, true) << " Failed for " << name;
+
+    Runtime* runtime = Runtime::Current();
+    CHECK(runtime != nullptr);
+
+    ScopedObjectAccess soa(Thread::Current());
+    ClassLinker* class_linker = runtime->GetClassLinker();
+    jobject class_loader = RegisterDexFileAndGetClassLoader(runtime, &dex_file);
+
+    // Scope for the handles
+    {
+      art::StackHandleScope<3> scope(soa.Self());
+      art::Handle<art::mirror::ClassLoader> h_loader =
+          scope.NewHandle(soa.Decode<art::mirror::ClassLoader>(class_loader));
+      art::MutableHandle<art::mirror::Class> h_klass(scope.NewHandle<art::mirror::Class>(nullptr));
+      art::MutableHandle<art::mirror::DexCache> h_dex_cache(
+          scope.NewHandle<art::mirror::DexCache>(nullptr));
+
+      for (art::ClassAccessor accessor : dex_file.GetClasses()) {
+        const char* descriptor = accessor.GetDescriptor();
+        h_klass.Assign(class_linker->FindClass(soa.Self(), descriptor, h_loader));
+        // Ignore classes that couldn't be loaded since we are looking for crashes during
+        // class/method verification.
+        if (h_klass == nullptr || h_klass->IsErroneous()) {
+          // Treat as failure to pass verification
+          passed_class_verification = false;
+          soa.Self()->ClearException();
+          continue;
+        }
+        h_dex_cache.Assign(h_klass->GetDexCache());
+        verifier::FailureKind failure =
+            verifier::ClassVerifier::VerifyClass(soa.Self(),
+                                                 /* verifier_deps= */ nullptr,
+                                                 h_dex_cache->GetDexFile(),
+                                                 h_klass,
+                                                 h_dex_cache,
+                                                 h_loader,
+                                                 *h_klass->GetClassDef(),
+                                                 runtime->GetCompilerCallbacks(),
+                                                 verifier::HardFailLogMode::kLogWarning,
+                                                 /* api_level= */ 0,
+                                                 &error_msg);
+        if (failure != verifier::FailureKind::kNoFailure) {
+          passed_class_verification = false;
+        }
+      }
+    }
+    skipped_gc_iterations++;
+
+    // Delete weak root to the DexCache before removing a DEX file from the cache. This is usually
+    // handled by the GC, but since we are not calling it every iteration, we need to delete them
+    // manually.
+    const ClassLinker::DexCacheData* dex_cache_data =
+        VerifyClassesFuzzerCorpusTestHelper::GetDexCacheData(runtime, &dex_file);
+    soa.Env()->GetVm()->DeleteWeakGlobalRef(soa.Self(), dex_cache_data->weak_root);
+
+    class_linker->RemoveDexFromCaches(dex_file);
+
+    // Delete global ref and unload class loader to free RAM.
+    soa.Env()->GetVm()->DeleteGlobalRef(soa.Self(), class_loader);
+
+    if (skipped_gc_iterations == kMaxSkipGCIterations) {
+      runtime->GetHeap()->CollectGarbage(/* clear_soft_references */ true);
+      skipped_gc_iterations = 0;
+    }
+
+    ASSERT_EQ(passed_class_verification, expected_success) << " Failed for " << name;
+  }
+
+  void TestFuzzerHelper(
+      const std::string& archive_filename,
+      const std::unordered_set<std::string>& valid_dex_files,
+      std::function<void(const uint8_t*, size_t, const std::string&, bool)> verify_file) {
+    // Consistency checks.
+    const std::string folder = android::base::GetExecutableDirectory();
+    ASSERT_TRUE(std::filesystem::is_directory(folder)) << folder << " is not a folder";
+    ASSERT_FALSE(std::filesystem::is_empty(folder)) << " No files found for directory " << folder;
+    const std::string filename = folder + "/" + archive_filename;
+
+    // Iterate using ZipArchiveHandle. We have to be careful about managing the pointers with
+    // CloseArchive, StartIteration, and EndIteration.
+    std::string error_msg;
+    ZipArchiveHandle handle;
+    ZipArchiveHandleScope scope(&handle);
+    int32_t error = OpenArchive(filename.c_str(), &handle);
+    ASSERT_TRUE(error == 0) << "Error: " << error;
+
+    void* cookie;
+    error = StartIteration(handle, &cookie);
+    ASSERT_TRUE(error == 0) << "couldn't iterate " << filename << " : " << ErrorCodeString(error);
+
+    ZipEntry64 entry;
+    std::string name;
+    std::vector<char> data;
+    while ((error = Next(cookie, &entry, &name)) >= 0) {
+      if (!name.ends_with(".dex")) {
+        // Skip non-DEX files.
+        LOG(WARNING) << "Found a non-dex file: " << name;
+        continue;
+      }
+      data.resize(entry.uncompressed_length);
+      error = ExtractToMemory(handle, &entry, reinterpret_cast<uint8_t*>(data.data()), data.size());
+      ASSERT_TRUE(error == 0) << "failed to extract entry: " << name << " from " << filename << ""
+                              << ErrorCodeString(error);
+
+      const uint8_t* file_data = reinterpret_cast<const uint8_t*>(data.data());
+      // Special case for empty dex file. Set a fake data since the size is 0 anyway.
+      if (file_data == nullptr) {
+        ASSERT_EQ(data.size(), 0);
+        file_data = reinterpret_cast<const uint8_t*>(&name);
+      }
+
+      const bool is_valid_dex_file = valid_dex_files.find(name) != valid_dex_files.end();
+      verify_file(file_data, data.size(), name, is_valid_dex_file);
+    }
+
+    ASSERT_TRUE(error >= -1) << "failed iterating " << filename << " : " << ErrorCodeString(error);
+    EndIteration(cookie);
+  }
+
+ private:
+  static jobject RegisterDexFileAndGetClassLoader(Runtime* runtime, StandardDexFile* dex_file)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    Thread* self = Thread::Current();
+    ClassLinker* class_linker = runtime->GetClassLinker();
+    const std::vector<const DexFile*> dex_files = {dex_file};
+    jobject class_loader = class_linker->CreatePathClassLoader(self, dex_files);
+    ObjPtr<mirror::ClassLoader> cl = self->DecodeJObject(class_loader)->AsClassLoader();
+    class_linker->RegisterDexFile(*dex_file, cl);
+    return class_loader;
+  }
+};
+
+// Tests that we can verify dex files without crashing.
+TEST_F(FuzzerCorpusTest, VerifyCorpusDexFiles) {
+  // These dex files are expected to pass verification. The others are regressions tests.
+  const std::unordered_set<std::string> valid_dex_files = {"Main.dex", "hello_world.dex"};
+  const std::string archive_filename = "dex_verification_fuzzer_corpus.zip";
+
+  TestFuzzerHelper(archive_filename, valid_dex_files, DexFileVerification);
+}
+
+// Tests that we can verify classes from dex files without crashing.
+TEST_F(FuzzerCorpusTest, VerifyCorpusClassDexFiles) {
+  // These dex files are expected to pass verification. The others are regressions tests.
+  const std::unordered_set<std::string> valid_dex_files = {"Main.dex", "hello_world.dex"};
+  const std::string archive_filename = "class_verification_fuzzer_corpus.zip";
+
+  TestFuzzerHelper(archive_filename, valid_dex_files, ClassVerification);
+}
+
+}  // namespace art
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index e4b308e846..caaa3f6cbc 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -62,8 +62,6 @@ static constexpr bool kDisallowReadBarrierDuringScan = kIsDebugBuild;
 // Slow path mark stack size, increase this if the stack is getting full and it is causing
 // performance problems.
 static constexpr size_t kReadBarrierMarkStackSize = 512 * KB;
-// Size (in the number of objects) of the sweep array free buffer.
-static constexpr size_t kSweepArrayChunkFreeSize = 1024;
 // Verify that there are no missing card marks.
 static constexpr bool kVerifyNoMissingCardMarks = kIsDebugBuild;
 
@@ -139,18 +137,6 @@ ConcurrentCopying::ConcurrentCopying(Heap* heap,
       pooled_mark_stacks_.push_back(mark_stack);
     }
   }
-  if (use_generational_cc_) {
-    // Allocate sweep array free buffer.
-    std::string error_msg;
-    sweep_array_free_buffer_mem_map_ = MemMap::MapAnonymous(
-        "concurrent copying sweep array free buffer",
-        RoundUp(kSweepArrayChunkFreeSize * sizeof(mirror::Object*), gPageSize),
-        PROT_READ | PROT_WRITE,
-        /*low_4gb=*/ false,
-        &error_msg);
-    CHECK(sweep_array_free_buffer_mem_map_.IsValid())
-        << "Couldn't allocate sweep array free buffer: " << error_msg;
-  }
   // Return type of these functions are different. And even though the base class
   // is same, using ternary operator complains.
   metrics::ArtMetrics* metrics = GetMetrics();
@@ -2522,22 +2508,12 @@ void ConcurrentCopying::Sweep(bool swap_bitmaps) {
   }
 }
 
-// Copied and adapted from MarkSweep::SweepArray.
-void ConcurrentCopying::SweepArray(accounting::ObjectStack* allocations, bool swap_bitmaps) {
+void ConcurrentCopying::SweepArray(accounting::ObjectStack* obj_arr, bool swap_bitmaps) {
   // This method is only used when Generational CC collection is enabled.
   DCHECK(use_generational_cc_);
   CheckEmptyMarkStack();
   TimingLogger::ScopedTiming t("SweepArray", GetTimings());
-  Thread* self = Thread::Current();
-  mirror::Object** chunk_free_buffer = reinterpret_cast<mirror::Object**>(
-      sweep_array_free_buffer_mem_map_.BaseBegin());
-  size_t chunk_free_pos = 0;
-  ObjectBytePair freed;
-  ObjectBytePair freed_los;
-  // How many objects are left in the array, modified after each space is swept.
-  StackReference<mirror::Object>* objects = allocations->Begin();
-  size_t count = allocations->Size();
-  // Start by sweeping the continuous spaces.
+  std::vector<space::ContinuousSpace*> sweep_spaces;
   for (space::ContinuousSpace* space : heap_->GetContinuousSpaces()) {
     if (!space->IsAllocSpace() ||
         space == region_space_ ||
@@ -2545,72 +2521,9 @@ void ConcurrentCopying::SweepArray(accounting::ObjectStack* allocations, bool sw
         space->GetLiveBitmap() == nullptr) {
       continue;
     }
-    space::AllocSpace* alloc_space = space->AsAllocSpace();
-    accounting::ContinuousSpaceBitmap* live_bitmap = space->GetLiveBitmap();
-    accounting::ContinuousSpaceBitmap* mark_bitmap = space->GetMarkBitmap();
-    if (swap_bitmaps) {
-      std::swap(live_bitmap, mark_bitmap);
-    }
-    StackReference<mirror::Object>* out = objects;
-    for (size_t i = 0; i < count; ++i) {
-      mirror::Object* const obj = objects[i].AsMirrorPtr();
-      if (kUseThreadLocalAllocationStack && obj == nullptr) {
-        continue;
-      }
-      if (space->HasAddress(obj)) {
-        // This object is in the space, remove it from the array and add it to the sweep buffer
-        // if needed.
-        if (!mark_bitmap->Test(obj)) {
-          if (chunk_free_pos >= kSweepArrayChunkFreeSize) {
-            TimingLogger::ScopedTiming t2("FreeList", GetTimings());
-            freed.objects += chunk_free_pos;
-            freed.bytes += alloc_space->FreeList(self, chunk_free_pos, chunk_free_buffer);
-            chunk_free_pos = 0;
-          }
-          chunk_free_buffer[chunk_free_pos++] = obj;
-        }
-      } else {
-        (out++)->Assign(obj);
-      }
-    }
-    if (chunk_free_pos > 0) {
-      TimingLogger::ScopedTiming t2("FreeList", GetTimings());
-      freed.objects += chunk_free_pos;
-      freed.bytes += alloc_space->FreeList(self, chunk_free_pos, chunk_free_buffer);
-      chunk_free_pos = 0;
-    }
-    // All of the references which space contained are no longer in the allocation stack, update
-    // the count.
-    count = out - objects;
-  }
-  // Handle the large object space.
-  space::LargeObjectSpace* large_object_space = GetHeap()->GetLargeObjectsSpace();
-  if (large_object_space != nullptr) {
-    accounting::LargeObjectBitmap* large_live_objects = large_object_space->GetLiveBitmap();
-    accounting::LargeObjectBitmap* large_mark_objects = large_object_space->GetMarkBitmap();
-    if (swap_bitmaps) {
-      std::swap(large_live_objects, large_mark_objects);
-    }
-    for (size_t i = 0; i < count; ++i) {
-      mirror::Object* const obj = objects[i].AsMirrorPtr();
-      // Handle large objects.
-      if (kUseThreadLocalAllocationStack && obj == nullptr) {
-        continue;
-      }
-      if (!large_mark_objects->Test(obj)) {
-        ++freed_los.objects;
-        freed_los.bytes += large_object_space->Free(self, obj);
-      }
-    }
-  }
-  {
-    TimingLogger::ScopedTiming t2("RecordFree", GetTimings());
-    RecordFree(freed);
-    RecordFreeLOS(freed_los);
-    t2.NewTiming("ResetStack");
-    allocations->Reset();
+    sweep_spaces.push_back(space);
   }
-  sweep_array_free_buffer_mem_map_.MadviseDontNeedAndZero();
+  GarbageCollector::SweepArray(obj_arr, swap_bitmaps, &sweep_spaces);
 }
 
 void ConcurrentCopying::MarkZygoteLargeObjects() {
@@ -3662,7 +3575,8 @@ mirror::Object* ConcurrentCopying::IsMarked(mirror::Object* from_ref) {
 }
 
 bool ConcurrentCopying::IsOnAllocStack(mirror::Object* ref) {
-  // TODO: Explain why this is here. What release operation does it pair with?
+  // Pairs with release fence after allocation-stack push in
+  // Heap::AllocObjectWithAllocator().
   std::atomic_thread_fence(std::memory_order_acquire);
   accounting::ObjectStack* alloc_stack = GetAllocationStack();
   return alloc_stack->Contains(ref);
diff --git a/runtime/gc/collector/concurrent_copying.h b/runtime/gc/collector/concurrent_copying.h
index 469d54abdf..ae94c14113 100644
--- a/runtime/gc/collector/concurrent_copying.h
+++ b/runtime/gc/collector/concurrent_copying.h
@@ -42,8 +42,6 @@ class Object;
 namespace gc {
 
 namespace accounting {
-template<typename T> class AtomicStack;
-using ObjectStack = AtomicStack<mirror::Object>;
 template <size_t kAlignment> class SpaceBitmap;
 using ContinuousSpaceBitmap = SpaceBitmap<kObjectAlignment>;
 class HeapBitmap;
@@ -261,8 +259,7 @@ class ConcurrentCopying : public GarbageCollector {
   // a subset of the heap.
   void Sweep(bool swap_bitmaps)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::heap_bitmap_lock_, !mark_stack_lock_);
-  // Sweep only pointers within an array.
-  void SweepArray(accounting::ObjectStack* allocation_stack_, bool swap_bitmaps)
+  void SweepArray(accounting::ObjectStack* obj_arr, bool swap_bitmaps)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::heap_bitmap_lock_, !mark_stack_lock_);
   void SweepLargeObjects(bool swap_bitmaps)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::heap_bitmap_lock_);
@@ -484,11 +481,6 @@ class ConcurrentCopying : public GarbageCollector {
   // ObjPtr since the GC may transition to suspended and runnable between phases.
   mirror::Class* java_lang_Object_;
 
-  // Sweep array free buffer, used to sweep the spaces based on an array more
-  // efficiently, by recording dead objects to be freed in batches (see
-  // ConcurrentCopying::SweepArray).
-  MemMap sweep_array_free_buffer_mem_map_;
-
   // Use signed because after_gc may be larger than before_gc.
   int64_t num_bytes_allocated_before_gc_;
 
diff --git a/runtime/gc/collector/garbage_collector.cc b/runtime/gc/collector/garbage_collector.cc
index d6d3ab3418..798300fa29 100644
--- a/runtime/gc/collector/garbage_collector.cc
+++ b/runtime/gc/collector/garbage_collector.cc
@@ -300,6 +300,96 @@ void GarbageCollector::SwapBitmaps() {
   }
 }
 
+void GarbageCollector::SweepArray(accounting::ObjectStack* allocations,
+                                  bool swap_bitmaps,
+                                  std::vector<space::ContinuousSpace*>* sweep_spaces) {
+  Thread* self = Thread::Current();
+  static constexpr size_t kSweepArrayChunkFreeSize = 1024;
+  mirror::Object** chunk_free_buffer = new mirror::Object*[kSweepArrayChunkFreeSize];
+  size_t chunk_free_pos = 0;
+  ObjectBytePair freed;
+  ObjectBytePair freed_los;
+  // How many objects are left in the array, modified after each space is swept.
+  StackReference<mirror::Object>* objects = allocations->Begin();
+  size_t count = allocations->Size();
+  // Start by sweeping the continuous spaces.
+  for (space::ContinuousSpace* space : *sweep_spaces) {
+    space::AllocSpace* alloc_space = space->AsAllocSpace();
+    accounting::ContinuousSpaceBitmap* live_bitmap = space->GetLiveBitmap();
+    accounting::ContinuousSpaceBitmap* mark_bitmap = space->GetMarkBitmap();
+    if (swap_bitmaps) {
+      std::swap(live_bitmap, mark_bitmap);
+    }
+    StackReference<mirror::Object>* out = objects;
+    for (size_t i = 0; i < count; ++i) {
+      mirror::Object* const obj = objects[i].AsMirrorPtr();
+      if (kUseThreadLocalAllocationStack && obj == nullptr) {
+        continue;
+      }
+      if (space->HasAddress(obj)) {
+        // This object is in the space, remove it from the array and add it to the sweep buffer
+        // if needed.
+        if (!mark_bitmap->Test(obj)) {
+          // Handle the case where buffer allocation failed.
+          if (LIKELY(chunk_free_buffer != nullptr)) {
+            if (chunk_free_pos >= kSweepArrayChunkFreeSize) {
+              TimingLogger::ScopedTiming t2("FreeList", GetTimings());
+              freed.objects += chunk_free_pos;
+              freed.bytes += alloc_space->FreeList(self, chunk_free_pos, chunk_free_buffer);
+              chunk_free_pos = 0;
+            }
+            chunk_free_buffer[chunk_free_pos++] = obj;
+          } else {
+            freed.objects++;
+            freed.bytes += alloc_space->Free(self, obj);
+          }
+        }
+      } else {
+        (out++)->Assign(obj);
+      }
+    }
+    if (chunk_free_pos > 0) {
+      TimingLogger::ScopedTiming t2("FreeList", GetTimings());
+      freed.objects += chunk_free_pos;
+      freed.bytes += alloc_space->FreeList(self, chunk_free_pos, chunk_free_buffer);
+      chunk_free_pos = 0;
+    }
+    // All of the references which space contained are no longer in the allocation stack, update
+    // the count.
+    count = out - objects;
+  }
+  if (chunk_free_buffer != nullptr) {
+    delete[] chunk_free_buffer;
+  }
+  // Handle the large object space.
+  space::LargeObjectSpace* large_object_space = GetHeap()->GetLargeObjectsSpace();
+  if (large_object_space != nullptr) {
+    accounting::LargeObjectBitmap* large_live_objects = large_object_space->GetLiveBitmap();
+    accounting::LargeObjectBitmap* large_mark_objects = large_object_space->GetMarkBitmap();
+    if (swap_bitmaps) {
+      std::swap(large_live_objects, large_mark_objects);
+    }
+    for (size_t i = 0; i < count; ++i) {
+      mirror::Object* const obj = objects[i].AsMirrorPtr();
+      // Handle large objects.
+      if (kUseThreadLocalAllocationStack && obj == nullptr) {
+        continue;
+      }
+      if (!large_mark_objects->Test(obj)) {
+        ++freed_los.objects;
+        freed_los.bytes += large_object_space->Free(self, obj);
+      }
+    }
+  }
+  {
+    TimingLogger::ScopedTiming t2("RecordFree", GetTimings());
+    RecordFree(freed);
+    RecordFreeLOS(freed_los);
+    t2.NewTiming("ResetStack");
+    allocations->Reset();
+  }
+}
+
 uint64_t GarbageCollector::GetEstimatedMeanThroughput() const {
   // Add 1ms to prevent possible division by 0.
   return (total_freed_bytes_ * 1000) / (NsToMs(GetCumulativeTimings().GetTotalNs()) + 1);
@@ -353,6 +443,13 @@ const Iteration* GarbageCollector::GetCurrentIteration() const {
 }
 
 bool GarbageCollector::ShouldEagerlyReleaseMemoryToOS() const {
+  // We have seen old kernels and custom kernel features misbehave in the
+  // presence of too much usage of MADV_FREE. So always release memory eagerly
+  // while we investigate.
+  static constexpr bool kEnableLazyRelease = false;
+  if (!kEnableLazyRelease) {
+    return true;
+  }
   Runtime* runtime = Runtime::Current();
   // Zygote isn't a memory heavy process, we should always instantly release memory to the OS.
   if (runtime->IsZygote()) {
diff --git a/runtime/gc/collector/garbage_collector.h b/runtime/gc/collector/garbage_collector.h
index 010ea49c62..f4ee570808 100644
--- a/runtime/gc/collector/garbage_collector.h
+++ b/runtime/gc/collector/garbage_collector.h
@@ -45,8 +45,17 @@ namespace gc {
 
 class Heap;
 
-namespace collector {
+namespace accounting {
+template <typename T>
+class AtomicStack;
+using ObjectStack = AtomicStack<mirror::Object>;
+}  // namespace accounting
+
+namespace space {
+class ContinuousSpace;
+}  // namespace space
 
+namespace collector {
 class GarbageCollector : public RootVisitor, public IsMarkedVisitor, public MarkObjectVisitor {
  public:
   class SCOPED_LOCKABLE ScopedPause {
@@ -150,6 +159,12 @@ class GarbageCollector : public RootVisitor, public IsMarkedVisitor, public Mark
   virtual void RunPhases() REQUIRES(!Locks::mutator_lock_) = 0;
   // Revoke all the thread-local buffers.
   virtual void RevokeAllThreadLocalBuffers() = 0;
+  // Deallocates unmarked objects referenced by 'obj_arr' that reside either in the
+  // given continuous-spaces or in large-object space. WARNING: Trashes objects.
+  void SweepArray(accounting::ObjectStack* obj_arr,
+                  bool swap_bitmaps,
+                  std::vector<space::ContinuousSpace*>* sweep_spaces)
+      REQUIRES(Locks::heap_bitmap_lock_) REQUIRES_SHARED(Locks::mutator_lock_);
 
   static constexpr size_t kPauseBucketSize = 500;
   static constexpr size_t kPauseBucketCount = 32;
diff --git a/runtime/gc/collector/immune_spaces_test.cc b/runtime/gc/collector/immune_spaces_test.cc
index ee0feb8cbc..d9b60ecff2 100644
--- a/runtime/gc/collector/immune_spaces_test.cc
+++ b/runtime/gc/collector/immune_spaces_test.cc
@@ -38,6 +38,11 @@ class FakeOatFile : public OatFile {
     begin_ = begin;
     end_ = end;
   }
+
+  const uint8_t* ComputeElfBegin(std::string* error_msg) const override {
+    *error_msg = "Not applicable";
+    return nullptr;
+  }
 };
 
 class FakeImageSpace : public space::ImageSpace {
diff --git a/runtime/gc/collector/mark_compact-inl.h b/runtime/gc/collector/mark_compact-inl.h
index 24d47638b1..05dc65a961 100644
--- a/runtime/gc/collector/mark_compact-inl.h
+++ b/runtime/gc/collector/mark_compact-inl.h
@@ -27,40 +27,11 @@ namespace collector {
 
 inline void MarkCompact::UpdateClassAfterObjectMap(mirror::Object* obj) {
   mirror::Class* klass = obj->GetClass<kVerifyNone, kWithoutReadBarrier>();
-  // Track a class if it needs walking super-classes for visiting references or
-  // if it's higher in address order than its objects and is in moving space.
-  if (UNLIKELY(
-          (std::less<mirror::Object*>{}(obj, klass) && HasAddress(klass)) ||
-          (klass->GetReferenceInstanceOffsets<kVerifyNone>() == mirror::Class::kClassWalkSuper &&
-           walk_super_class_cache_ != klass))) {
-    // Since this function gets invoked in the compaction pause as well, it is
-    // preferable to store such super class separately rather than updating key
-    // as the latter would require traversing the hierarchy for every object of 'klass'.
-    auto ret1 = class_after_obj_hash_map_.try_emplace(ObjReference::FromMirrorPtr(klass),
-                                                      ObjReference::FromMirrorPtr(obj));
-    if (ret1.second) {
-      if (klass->GetReferenceInstanceOffsets<kVerifyNone>() == mirror::Class::kClassWalkSuper) {
-        // In this case we require traversing through the super class hierarchy
-        // and find the super class at the highest address order.
-        mirror::Class* highest_klass = HasAddress(klass) ? klass : nullptr;
-        for (ObjPtr<mirror::Class> k = klass->GetSuperClass<kVerifyNone, kWithoutReadBarrier>();
-             k != nullptr;
-             k = k->GetSuperClass<kVerifyNone, kWithoutReadBarrier>()) {
-          // TODO: Can we break once we encounter a super class outside the moving space?
-          if (HasAddress(k.Ptr())) {
-            highest_klass = std::max(highest_klass, k.Ptr(), std::less<mirror::Class*>());
-          }
-        }
-        if (highest_klass != nullptr && highest_klass != klass) {
-          auto ret2 = super_class_after_class_hash_map_.try_emplace(
-              ObjReference::FromMirrorPtr(klass), ObjReference::FromMirrorPtr(highest_klass));
-          DCHECK(ret2.second);
-        } else {
-          walk_super_class_cache_ = klass;
-        }
-      }
-    } else if (std::less<mirror::Object*>{}(obj, ret1.first->second.AsMirrorPtr())) {
-      ret1.first->second = ObjReference::FromMirrorPtr(obj);
+  if (UNLIKELY(std::less<mirror::Object*>{}(obj, klass) && HasAddress(klass))) {
+    auto [iter, success] = class_after_obj_map_.try_emplace(ObjReference::FromMirrorPtr(klass),
+                                                            ObjReference::FromMirrorPtr(obj));
+    if (!success && std::less<mirror::Object*>{}(obj, iter->second.AsMirrorPtr())) {
+      iter->second = ObjReference::FromMirrorPtr(obj);
     }
   }
 }
@@ -221,6 +192,14 @@ uint32_t MarkCompact::LiveWordsBitmap<kAlignment>::FindNthLiveWordOffset(size_t
   UNREACHABLE();
 }
 
+inline bool MarkCompact::IsOnAllocStack(mirror::Object* ref) {
+  // Pairs with release fence after allocation-stack push in
+  // Heap::AllocObjectWithAllocator().
+  std::atomic_thread_fence(std::memory_order_acquire);
+  accounting::ObjectStack* stack = heap_->GetAllocationStack();
+  return stack->Contains(ref);
+}
+
 inline void MarkCompact::UpdateRef(mirror::Object* obj,
                                    MemberOffset offset,
                                    uint8_t* begin,
diff --git a/runtime/gc/collector/mark_compact.cc b/runtime/gc/collector/mark_compact.cc
index 0189b52493..618625ec61 100644
--- a/runtime/gc/collector/mark_compact.cc
+++ b/runtime/gc/collector/mark_compact.cc
@@ -67,9 +67,6 @@
 #ifndef MREMAP_DONTUNMAP
 #define MREMAP_DONTUNMAP 4
 #endif
-#ifndef MAP_FIXED_NOREPLACE
-#define MAP_FIXED_NOREPLACE 0x100000
-#endif
 #endif  // __BIONIC__
 
 // See aosp/2996596 for where these values came from.
@@ -329,8 +326,6 @@ namespace collector {
 // significantly.
 static constexpr bool kCheckLocks = kDebugLocking;
 static constexpr bool kVerifyRootsMarked = kIsDebugBuild;
-// Two threads should suffice on devices.
-static constexpr size_t kMaxNumUffdWorkers = 2;
 // Number of compaction buffers reserved for mutator threads in SIGBUS feature
 // case. It's extremely unlikely that we will ever have more than these number
 // of mutator threads trying to access the moving-space during one compaction
@@ -391,17 +386,10 @@ bool MarkCompact::CreateUserfaultfd(bool post_fork) {
         // for which we don't need to ask for any features. Note: this mode
         // is not used in production.
         struct uffdio_api api = {.api = UFFD_API, .features = 0, .ioctls = 0};
-        if (use_uffd_sigbus_) {
-          // We should add SIGBUS feature only if we plan on using it as
-          // requesting it here will mean threading mode will not work.
-          CHECK_EQ(gUffdFeatures & kUffdFeaturesForSigbus, kUffdFeaturesForSigbus);
-          api.features |= kUffdFeaturesForSigbus;
-        }
-        if (uffd_minor_fault_supported_) {
-          // NOTE: This option is currently disabled.
-          CHECK_EQ(gUffdFeatures & kUffdFeaturesForMinorFault, kUffdFeaturesForMinorFault);
-          api.features |= kUffdFeaturesForMinorFault;
-        }
+        // We should add SIGBUS feature only if we plan on using it as
+        // requesting it here will mean threading mode will not work.
+        CHECK_EQ(gUffdFeatures & kUffdFeaturesForSigbus, kUffdFeaturesForSigbus);
+        api.features |= kUffdFeaturesForSigbus;
         CHECK_EQ(ioctl(uffd_, UFFDIO_API, &api), 0)
             << "ioctl_userfaultfd: API: " << strerror(errno);
       }
@@ -420,11 +408,6 @@ MarkCompact::LiveWordsBitmap<kAlignment>* MarkCompact::LiveWordsBitmap<kAlignmen
           MemRangeBitmap::Create("Concurrent Mark Compact live words bitmap", begin, end));
 }
 
-static bool IsSigbusFeatureAvailable() {
-  MarkCompact::GetUffdAndMinorFault();
-  return (gUffdFeatures & kUffdFeaturesForSigbus) == kUffdFeaturesForSigbus;
-}
-
 size_t MarkCompact::ComputeInfoMapSize() {
   size_t moving_space_size = bump_pointer_space_->Capacity();
   size_t chunk_info_vec_size = moving_space_size / kOffsetChunkSize;
@@ -464,32 +447,19 @@ MarkCompact::MarkCompact(Heap* heap)
       moving_space_bitmap_(bump_pointer_space_->GetMarkBitmap()),
       moving_space_begin_(bump_pointer_space_->Begin()),
       moving_space_end_(bump_pointer_space_->Limit()),
-      moving_to_space_fd_(kFdUnused),
-      moving_from_space_fd_(kFdUnused),
       uffd_(kFdUnused),
-      sigbus_in_progress_count_(kSigbusCounterCompactionDoneMask),
-      compaction_in_progress_count_(0),
-      thread_pool_counter_(0),
+      sigbus_in_progress_count_{kSigbusCounterCompactionDoneMask, kSigbusCounterCompactionDoneMask},
       compacting_(false),
+      marking_done_(false),
       uffd_initialized_(false),
-      uffd_minor_fault_supported_(false),
-      use_uffd_sigbus_(IsSigbusFeatureAvailable()),
-      minor_fault_initialized_(false),
-      map_linear_alloc_shared_(false),
       clamp_info_map_status_(ClampInfoStatus::kClampInfoNotDone) {
   if (kIsDebugBuild) {
     updated_roots_.reset(new std::unordered_set<void*>());
   }
-  // TODO: When using minor-fault feature, the first GC after zygote-fork
-  // requires mapping the linear-alloc again with MAP_SHARED. This leaves a
-  // gap for suspended threads to access linear-alloc when it's empty (after
-  // mremap) and not yet userfaultfd registered. This cannot be fixed by merely
-  // doing uffd registration first. For now, just assert that we are not using
-  // minor-fault. Eventually, a cleanup of linear-alloc update logic to only
-  // use private anonymous would be ideal.
-  CHECK(!uffd_minor_fault_supported_);
+  if (gUffdFeatures == 0) {
+    GetUffdAndMinorFault();
+  }
   uint8_t* moving_space_begin = bump_pointer_space_->Begin();
-
   // TODO: Depending on how the bump-pointer space move is implemented. If we
   // switch between two virtual memories each time, then we will have to
   // initialize live_words_bitmap_ accordingly.
@@ -535,31 +505,8 @@ MarkCompact::MarkCompact(Heap* heap)
     from_space_begin_ = from_space_map_.Begin();
   }
 
-  // In some cases (32-bit or kObjPtrPoisoning) it's too much to ask for 3
-  // heap-sized mappings in low-4GB. So tolerate failure here by attempting to
-  // mmap again right before the compaction pause. And if even that fails, then
-  // running the GC cycle in copy-mode rather than minor-fault.
-  //
-  // This map doesn't have to be aligned to 2MB as we don't mremap on it.
-  if (!kObjPtrPoisoning && uffd_minor_fault_supported_) {
-    // We need this map only if minor-fault feature is supported. But in that case
-    // don't create the mapping if obj-ptr poisoning is enabled as then the mapping
-    // has to be created in low_4gb. Doing this here rather than later causes the
-    // Dex2oatImageTest.TestExtension gtest to fail in 64-bit platforms.
-    shadow_to_space_map_ = MemMap::MapAnonymous("Concurrent mark-compact moving-space shadow",
-                                                moving_space_size,
-                                                PROT_NONE,
-                                                /*low_4gb=*/false,
-                                                &err_msg);
-    if (!shadow_to_space_map_.IsValid()) {
-      LOG(WARNING) << "Failed to allocate concurrent mark-compact moving-space shadow: " << err_msg;
-    }
-  }
-  const size_t num_pages =
-      1 + (use_uffd_sigbus_ ? kMutatorCompactionBufferCount :
-                              std::min(heap_->GetParallelGCThreadCount(), kMaxNumUffdWorkers));
   compaction_buffers_map_ = MemMap::MapAnonymous("Concurrent mark-compact compaction buffers",
-                                                 gPageSize * num_pages,
+                                                 (1 + kMutatorCompactionBufferCount) * gPageSize,
                                                  PROT_READ | PROT_WRITE,
                                                  /*low_4gb=*/kObjPtrPoisoning,
                                                  &err_msg);
@@ -575,15 +522,6 @@ MarkCompact::MarkCompact(Heap* heap)
   // In most of the cases, we don't expect more than one LinearAlloc space.
   linear_alloc_spaces_data_.reserve(1);
 
-  // Ensure that huge-pages are not used on the moving-space, which may happen
-  // if THP is 'always' enabled and breaks our assumption that a normal-page is
-  // mapped when any address is accessed.
-  int ret = madvise(moving_space_begin, moving_space_size, MADV_NOHUGEPAGE);
-  // Some devices may not have THP configured in the kernel. On such devices
-  // madvise will fail with EINVAL. Obviously, on such devices this madvise is
-  // not required in the first place.
-  CHECK(ret == 0 || errno == EINVAL);
-
   // Initialize GC metrics.
   metrics::ArtMetrics* metrics = GetMetrics();
   // The mark-compact collector supports only full-heap collections at the moment.
@@ -608,18 +546,6 @@ void MarkCompact::AddLinearAllocSpaceData(uint8_t* begin, size_t len) {
   DCHECK_ALIGNED_PARAM(len, gPageSize);
   DCHECK_GE(len, Heap::GetPMDSize());
   size_t alignment = Heap::BestPageTableAlignment(len);
-  bool is_shared = false;
-  // We use MAP_SHARED on non-zygote processes for leveraging userfaultfd's minor-fault feature.
-  if (map_linear_alloc_shared_) {
-    void* ret = mmap(begin,
-                     len,
-                     PROT_READ | PROT_WRITE,
-                     MAP_ANONYMOUS | MAP_SHARED | MAP_FIXED,
-                     /*fd=*/-1,
-                     /*offset=*/0);
-    CHECK_EQ(ret, begin) << "mmap failed: " << strerror(errno);
-    is_shared = true;
-  }
   std::string err_msg;
   MemMap shadow(MemMap::MapAnonymousAligned("linear-alloc shadow map",
                                             len,
@@ -641,11 +567,8 @@ void MarkCompact::AddLinearAllocSpaceData(uint8_t* begin, size_t len) {
     LOG(FATAL) << "Failed to allocate linear-alloc page-status shadow map: " << err_msg;
     UNREACHABLE();
   }
-  linear_alloc_spaces_data_.emplace_back(std::forward<MemMap>(shadow),
-                                         std::forward<MemMap>(page_status_map),
-                                         begin,
-                                         begin + len,
-                                         is_shared);
+  linear_alloc_spaces_data_.emplace_back(
+      std::forward<MemMap>(shadow), std::forward<MemMap>(page_status_map), begin, begin + len);
 }
 
 void MarkCompact::ClampGrowthLimit(size_t new_capacity) {
@@ -664,11 +587,6 @@ void MarkCompact::ClampGrowthLimit(size_t new_capacity) {
     if (kClampFromSpace) {
       from_space_map_.SetSize(new_capacity);
     }
-    // NOTE: We usually don't use shadow_to_space_map_ and therefore the condition will
-    // mostly be false.
-    if (shadow_to_space_map_.IsValid() && shadow_to_space_map_.Size() > new_capacity) {
-      shadow_to_space_map_.SetSize(new_capacity);
-    }
     clamp_info_map_status_ = ClampInfoStatus::kClampInfoPending;
   }
   CHECK_EQ(moving_space_begin_, bump_pointer_space_->Begin());
@@ -789,7 +707,6 @@ void MarkCompact::InitializePhase() {
   black_allocations_begin_ = bump_pointer_space_->Limit();
   CHECK_EQ(moving_space_begin_, bump_pointer_space_->Begin());
   moving_space_end_ = bump_pointer_space_->Limit();
-  walk_super_class_cache_ = nullptr;
   // TODO: Would it suffice to read it once in the constructor, which is called
   // in zygote process?
   pointer_size_ = Runtime::Current()->GetClassLinker()->GetImagePointerSize();
@@ -851,9 +768,6 @@ void MarkCompact::RunPhases() {
     ReclaimPhase();
     PrepareForCompaction();
   }
-  if (uffd_ != kFallbackMode && !use_uffd_sigbus_) {
-    heap_->GetThreadPool()->WaitForWorkersToBeCreated();
-  }
 
   {
     // Compaction pause
@@ -1026,34 +940,6 @@ void MarkCompact::InitNonMovingSpaceFirstObjects() {
   non_moving_first_objs_count_ = page_idx;
 }
 
-bool MarkCompact::CanCompactMovingSpaceWithMinorFault() {
-  size_t min_size = (moving_first_objs_count_ + black_page_count_) * gPageSize;
-  return minor_fault_initialized_ && shadow_to_space_map_.IsValid() &&
-         shadow_to_space_map_.Size() >= min_size;
-}
-
-class MarkCompact::ConcurrentCompactionGcTask : public SelfDeletingTask {
- public:
-  explicit ConcurrentCompactionGcTask(MarkCompact* collector, size_t idx)
-      : collector_(collector), index_(idx) {}
-
-  void Run([[maybe_unused]] Thread* self) override REQUIRES_SHARED(Locks::mutator_lock_) {
-    if (collector_->CanCompactMovingSpaceWithMinorFault()) {
-      collector_->ConcurrentCompaction<MarkCompact::kMinorFaultMode>(/*buf=*/nullptr);
-    } else {
-      // The passed page/buf to ConcurrentCompaction is used by the thread as a
-      // gPageSize buffer for compacting and updating objects into and then
-      // passing the buf to uffd ioctls.
-      uint8_t* buf = collector_->compaction_buffers_map_.Begin() + index_ * gPageSize;
-      collector_->ConcurrentCompaction<MarkCompact::kCopyMode>(buf);
-    }
-  }
-
- private:
-  MarkCompact* const collector_;
-  size_t index_;
-};
-
 void MarkCompact::PrepareForCompaction() {
   TimingLogger::ScopedTiming t(__FUNCTION__, GetTimings());
   uint8_t* space_begin = bump_pointer_space_->Begin();
@@ -1122,219 +1008,8 @@ void MarkCompact::PrepareForCompaction() {
   // The chunk-info vector entries for the post marking-pause allocations will be
   // also updated in the pre-compaction pause.
 
-  bool is_zygote = Runtime::Current()->IsZygote();
-  if (!uffd_initialized_ && CreateUserfaultfd(/*post_fork*/false)) {
-    if (!use_uffd_sigbus_) {
-      // Register the buffer that we use for terminating concurrent compaction
-      struct uffdio_register uffd_register;
-      uffd_register.range.start = reinterpret_cast<uintptr_t>(conc_compaction_termination_page_);
-      uffd_register.range.len = gPageSize;
-      uffd_register.mode = UFFDIO_REGISTER_MODE_MISSING;
-      CHECK_EQ(ioctl(uffd_, UFFDIO_REGISTER, &uffd_register), 0)
-          << "ioctl_userfaultfd: register compaction termination page: " << strerror(errno);
-    }
-    if (!uffd_minor_fault_supported_ && shadow_to_space_map_.IsValid()) {
-      // A valid shadow-map for moving space is only possible if we
-      // were able to map it in the constructor. That also means that its size
-      // matches the moving-space.
-      CHECK_EQ(shadow_to_space_map_.Size(), bump_pointer_space_->Capacity());
-      // Release the shadow map for moving-space if we don't support minor-fault
-      // as it's not required.
-      shadow_to_space_map_.Reset();
-    }
-  }
-  // For zygote we create the thread pool each time before starting compaction,
-  // and get rid of it when finished. This is expected to happen rarely as
-  // zygote spends most of the time in native fork loop.
-  if (uffd_ != kFallbackMode) {
-    if (!use_uffd_sigbus_) {
-      ThreadPool* pool = heap_->GetThreadPool();
-      if (UNLIKELY(pool == nullptr)) {
-        // On devices with 2 cores, GetParallelGCThreadCount() will return 1,
-        // which is desired number of workers on such devices.
-        heap_->CreateThreadPool(std::min(heap_->GetParallelGCThreadCount(), kMaxNumUffdWorkers));
-        pool = heap_->GetThreadPool();
-      }
-      size_t num_threads = pool->GetThreadCount();
-      thread_pool_counter_ = num_threads;
-      for (size_t i = 0; i < num_threads; i++) {
-        pool->AddTask(thread_running_gc_, new ConcurrentCompactionGcTask(this, i + 1));
-      }
-      CHECK_EQ(pool->GetTaskCount(thread_running_gc_), num_threads);
-    }
-    /*
-     * Possible scenarios for mappings:
-     * A) All zygote GCs (or if minor-fault feature isn't available): uses
-     * uffd's copy mode
-     *  1) For moving-space ('to' space is same as the moving-space):
-     *    a) Private-anonymous mappings for 'to' and 'from' space are created in
-     *    the constructor.
-     *    b) In the compaction pause, we mremap(dontunmap) from 'to' space to
-     *    'from' space. This results in moving all pages to 'from' space and
-     *    emptying the 'to' space, thereby preparing it for userfaultfd
-     *    registration.
-     *
-     *  2) For linear-alloc space:
-     *    a) Private-anonymous mappings for the linear-alloc and its 'shadow'
-     *    are created by the arena-pool.
-     *    b) In the compaction pause, we mremap(dontumap) with similar effect as
-     *    (A.1.b) above.
-     *
-     * B) First GC after zygote: uses uffd's copy-mode
-     *  1) For moving-space:
-     *    a) If the mmap for shadow-map has been successful in the constructor,
-     *    then we remap it (mmap with MAP_FIXED) to get a shared-anonymous
-     *    mapping.
-     *    b) Else, we create two memfd and ftruncate them to the moving-space
-     *    size.
-     *    c) Same as (A.1.b)
-     *    d) If (B.1.a), then mremap(dontunmap) from shadow-map to
-     *    'to' space. This will make both of them map to the same pages
-     *    e) If (B.1.b), then mmap with the first memfd in shared mode on the
-     *    'to' space.
-     *    f) At the end of compaction, we will have moved the moving-space
-     *    objects to a MAP_SHARED mapping, readying it for minor-fault from next
-     *    GC cycle.
-     *
-     *  2) For linear-alloc space:
-     *    a) Same as (A.2.b)
-     *    b) mmap a shared-anonymous mapping onto the linear-alloc space.
-     *    c) Same as (B.1.f)
-     *
-     * C) All subsequent GCs: preferable minor-fault mode. But may also require
-     * using copy-mode.
-     *  1) For moving-space:
-     *    a) If the shadow-map is created and no memfd was used, then that means
-     *    we are using shared-anonymous. Therefore, mmap a shared-anonymous on
-     *    the shadow-space.
-     *    b) If the shadow-map is not mapped yet, then mmap one with a size
-     *    big enough to hold the compacted moving space. This may fail, in which
-     *    case we will use uffd's copy-mode.
-     *    c) If (b) is successful, then mmap the free memfd onto shadow-map.
-     *    d) Same as (A.1.b)
-     *    e) In compaction pause, if the shadow-map was not created, then use
-     *    copy-mode.
-     *    f) Else, if the created map is smaller than the required-size, then
-     *    use mremap (without dontunmap) to expand the size. If failed, then use
-     *    copy-mode.
-     *    g) Otherwise, same as (B.1.d) and use minor-fault mode.
-     *
-     *  2) For linear-alloc space:
-     *    a) Same as (A.2.b)
-     *    b) Use minor-fault mode
-     */
-    auto mmap_shadow_map = [this](int flags, int fd) {
-      void* ret = mmap(shadow_to_space_map_.Begin(),
-                       shadow_to_space_map_.Size(),
-                       PROT_READ | PROT_WRITE,
-                       flags,
-                       fd,
-                       /*offset=*/0);
-      DCHECK_NE(ret, MAP_FAILED) << "mmap for moving-space shadow failed:" << strerror(errno);
-    };
-    // Setup all the virtual memory ranges required for concurrent compaction.
-    if (minor_fault_initialized_) {
-      DCHECK(!is_zygote);
-      if (UNLIKELY(!shadow_to_space_map_.IsValid())) {
-        // This case happens only once on the first GC in minor-fault mode, if
-        // we were unable to reserve shadow-map for moving-space in the
-        // beginning.
-        DCHECK_GE(moving_to_space_fd_, 0);
-        // Take extra 4MB to reduce the likelihood of requiring resizing this
-        // map in the pause due to black allocations.
-        size_t reqd_size = std::min(moving_first_objs_count_ * gPageSize + 4 * MB,
-                                    bump_pointer_space_->Capacity());
-        // We cannot support memory-tool with shadow-map (as it requires
-        // appending a redzone) in this case because the mapping may have to be expanded
-        // using mremap (in KernelPreparation()), which would ignore the redzone.
-        // MemMap::MapFile() appends a redzone, but MemMap::MapAnonymous() doesn't.
-        std::string err_msg;
-        shadow_to_space_map_ = MemMap::MapAnonymous("moving-space-shadow",
-                                                    reqd_size,
-                                                    PROT_NONE,
-                                                    /*low_4gb=*/kObjPtrPoisoning,
-                                                    &err_msg);
-
-        if (shadow_to_space_map_.IsValid()) {
-          CHECK(!kMemoryToolAddsRedzones || shadow_to_space_map_.GetRedzoneSize() == 0u);
-          // We want to use MemMap to get low-4GB mapping, if required, but then also
-          // want to have its ownership as we may grow it (in
-          // KernelPreparation()). If the ownership is not taken and we try to
-          // resize MemMap, then it unmaps the virtual range.
-          MemMap temp = shadow_to_space_map_.TakeReservedMemory(shadow_to_space_map_.Size(),
-                                                                /*reuse*/ true);
-          std::swap(temp, shadow_to_space_map_);
-          DCHECK(!temp.IsValid());
-        } else {
-          LOG(WARNING) << "Failed to create moving space's shadow map of " << PrettySize(reqd_size)
-                       << " size. " << err_msg;
-        }
-      }
-
-      if (LIKELY(shadow_to_space_map_.IsValid())) {
-        int fd = moving_to_space_fd_;
-        int mmap_flags = MAP_SHARED | MAP_FIXED;
-        if (fd == kFdUnused) {
-          // Unused moving-to-space fd means we are using anonymous shared
-          // mapping.
-          DCHECK_EQ(shadow_to_space_map_.Size(), bump_pointer_space_->Capacity());
-          mmap_flags |= MAP_ANONYMOUS;
-          fd = -1;
-        }
-        // If the map is smaller than required, then we'll do mremap in the
-        // compaction pause to increase the size.
-        mmap_shadow_map(mmap_flags, fd);
-      }
-
-      for (auto& data : linear_alloc_spaces_data_) {
-        DCHECK_EQ(mprotect(data.shadow_.Begin(), data.shadow_.Size(), PROT_READ | PROT_WRITE), 0)
-            << "mprotect failed: " << strerror(errno);
-      }
-    } else if (!is_zygote && uffd_minor_fault_supported_) {
-      // First GC after zygote-fork. We will still use uffd's copy mode but will
-      // use it to move objects to MAP_SHARED (to prepare for subsequent GCs, which
-      // will use uffd's minor-fault feature).
-      if (shadow_to_space_map_.IsValid() &&
-          shadow_to_space_map_.Size() == bump_pointer_space_->Capacity()) {
-        mmap_shadow_map(MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, /*fd=*/-1);
-      } else {
-        size_t size = bump_pointer_space_->Capacity();
-        DCHECK_EQ(moving_to_space_fd_, kFdUnused);
-        DCHECK_EQ(moving_from_space_fd_, kFdUnused);
-        const char* name = bump_pointer_space_->GetName();
-        moving_to_space_fd_ = memfd_create(name, MFD_CLOEXEC);
-        CHECK_NE(moving_to_space_fd_, -1)
-            << "memfd_create: failed for " << name << ": " << strerror(errno);
-        moving_from_space_fd_ = memfd_create(name, MFD_CLOEXEC);
-        CHECK_NE(moving_from_space_fd_, -1)
-            << "memfd_create: failed for " << name << ": " << strerror(errno);
-
-        // memfds are considered as files from resource limits point of view.
-        // And the moving space could be several hundred MBs. So increase the
-        // limit, if it's lower than moving-space size.
-        bool rlimit_changed = false;
-        rlimit rlim_read;
-        CHECK_EQ(getrlimit(RLIMIT_FSIZE, &rlim_read), 0) << "getrlimit failed: " << strerror(errno);
-        if (rlim_read.rlim_cur < size) {
-          rlimit_changed = true;
-          rlimit rlim = rlim_read;
-          rlim.rlim_cur = size;
-          CHECK_EQ(setrlimit(RLIMIT_FSIZE, &rlim), 0) << "setrlimit failed: " << strerror(errno);
-        }
-
-        // moving-space will map this fd so that we compact objects into it.
-        int ret = ftruncate(moving_to_space_fd_, size);
-        CHECK_EQ(ret, 0) << "ftruncate failed for moving-space:" << strerror(errno);
-        ret = ftruncate(moving_from_space_fd_, size);
-        CHECK_EQ(ret, 0) << "ftruncate failed for moving-space:" << strerror(errno);
-
-        if (rlimit_changed) {
-          // reset the rlimit to the original limits.
-          CHECK_EQ(setrlimit(RLIMIT_FSIZE, &rlim_read), 0)
-              << "setrlimit failed: " << strerror(errno);
-        }
-      }
-    }
+  if (!uffd_initialized_) {
+    CreateUserfaultfd(/*post_fork=*/false);
   }
 }
 
@@ -1430,6 +1105,7 @@ void MarkCompact::MarkingPause() {
   // Enable the reference processing slow path, needs to be done with mutators
   // paused since there is no lock in the GetReferent fast path.
   heap_->GetReferenceProcessor()->EnableSlowPath();
+  marking_done_ = true;
 }
 
 void MarkCompact::SweepSystemWeaks(Thread* self, Runtime* runtime, const bool paused) {
@@ -1708,16 +1384,14 @@ void MarkCompact::CompactPage(mirror::Object* obj,
     }
     obj_size = RoundUp(obj_size, kAlignment);
     DCHECK_GT(obj_size, offset_within_obj)
-        << "obj:" << obj
-        << " class:"
-        << obj->GetClass<kDefaultVerifyFlags, kWithFromSpaceBarrier>()
+        << "obj:" << obj << " class:" << obj->GetClass<kDefaultVerifyFlags, kWithFromSpaceBarrier>()
         << " to_addr:" << to_ref
         << " black-allocation-begin:" << reinterpret_cast<void*>(black_allocations_begin_)
         << " post-compact-end:" << reinterpret_cast<void*>(post_compact_end_)
-        << " offset:" << offset * kAlignment
-        << " class-after-obj-iter:"
-        << (class_after_obj_iter_ != class_after_obj_ordered_map_.rend() ?
-            class_after_obj_iter_->first.AsMirrorPtr() : nullptr)
+        << " offset:" << offset * kAlignment << " class-after-obj-iter:"
+        << (class_after_obj_iter_ != class_after_obj_map_.rend() ?
+                class_after_obj_iter_->first.AsMirrorPtr() :
+                nullptr)
         << " last-reclaimed-page:" << reinterpret_cast<void*>(last_reclaimed_page_)
         << " last-checked-reclaim-page-idx:" << last_checked_reclaim_page_idx_
         << " offset-of-last-idx:"
@@ -1772,16 +1446,15 @@ void MarkCompact::CompactPage(mirror::Object* obj,
     obj_size = RoundUp(obj_size, kAlignment);
     DCHECK_GT(obj_size, 0u)
         << "from_addr:" << obj
-        << " from-space-class:"
-        << obj->GetClass<kDefaultVerifyFlags, kWithFromSpaceBarrier>()
+        << " from-space-class:" << obj->GetClass<kDefaultVerifyFlags, kWithFromSpaceBarrier>()
         << " to_addr:" << ref
         << " black-allocation-begin:" << reinterpret_cast<void*>(black_allocations_begin_)
         << " post-compact-end:" << reinterpret_cast<void*>(post_compact_end_)
-        << " offset:" << offset * kAlignment
-        << " bytes_done:" << bytes_done
+        << " offset:" << offset * kAlignment << " bytes_done:" << bytes_done
         << " class-after-obj-iter:"
-        << (class_after_obj_iter_ != class_after_obj_ordered_map_.rend() ?
-            class_after_obj_iter_->first.AsMirrorPtr() : nullptr)
+        << (class_after_obj_iter_ != class_after_obj_map_.rend() ?
+                class_after_obj_iter_->first.AsMirrorPtr() :
+                nullptr)
         << " last-reclaimed-page:" << reinterpret_cast<void*>(last_reclaimed_page_)
         << " last-checked-reclaim-page-idx:" << last_checked_reclaim_page_idx_
         << " offset-of-last-idx:"
@@ -1989,104 +1662,6 @@ void MarkCompact::SlideBlackPage(mirror::Object* first_obj,
   }
 }
 
-template <bool kFirstPageMapping>
-void MarkCompact::MapProcessedPages(uint8_t* to_space_start,
-                                    Atomic<PageState>* state_arr,
-                                    size_t arr_idx,
-                                    size_t arr_len) {
-  CHECK(minor_fault_initialized_);
-  DCHECK_LT(arr_idx, arr_len);
-  DCHECK_ALIGNED_PARAM(to_space_start, gPageSize);
-  // Claim all the contiguous pages, which are ready to be mapped, and then do
-  // so in a single ioctl. This helps avoid the overhead of invoking syscall
-  // several times and also maps the already-processed pages, avoiding
-  // unnecessary faults on them.
-  size_t length = kFirstPageMapping ? gPageSize : 0;
-  if (kFirstPageMapping) {
-    arr_idx++;
-  }
-  // We need to guarantee that we don't end up sucsessfully marking a later
-  // page 'mapping' and then fail to mark an earlier page. To guarantee that
-  // we use acq_rel order.
-  for (; arr_idx < arr_len; arr_idx++, length += gPageSize) {
-    PageState expected_state = PageState::kProcessed;
-    if (!state_arr[arr_idx].compare_exchange_strong(
-            expected_state, PageState::kProcessedAndMapping, std::memory_order_acq_rel)) {
-      break;
-    }
-  }
-  if (length > 0) {
-    // Note: We need the first page to be attempted (to be mapped) by the ioctl
-    // as this function is called due to some mutator thread waiting on the
-    // 'to_space_start' page. Therefore, the ioctl must always be called
-    // with 'to_space_start' as the 'start' address because it can bail out in
-    // the middle (not attempting to map the subsequent pages) if it finds any
-    // page either already mapped in between, or missing on the shadow-map.
-    struct uffdio_continue uffd_continue;
-    uffd_continue.range.start = reinterpret_cast<uintptr_t>(to_space_start);
-    uffd_continue.range.len = length;
-    uffd_continue.mode = 0;
-    int ret = ioctl(uffd_, UFFDIO_CONTINUE, &uffd_continue);
-    if (UNLIKELY(ret == -1 && errno == EAGAIN)) {
-      // This can happen only in linear-alloc.
-      DCHECK(linear_alloc_spaces_data_.end() !=
-             std::find_if(linear_alloc_spaces_data_.begin(),
-                          linear_alloc_spaces_data_.end(),
-                          [to_space_start](const LinearAllocSpaceData& data) {
-                            return data.begin_ <= to_space_start && to_space_start < data.end_;
-                          }));
-
-      // This could happen if userfaultfd couldn't find any pages mapped in the
-      // shadow map. For instance, if there are certain (contiguous) pages on
-      // linear-alloc which are allocated and have first-object set-up but have
-      // not been accessed yet.
-      // Bail out by setting the remaining pages' state back to kProcessed and
-      // then waking up any waiting threads.
-      DCHECK_GE(uffd_continue.mapped, 0);
-      DCHECK_ALIGNED_PARAM(uffd_continue.mapped, gPageSize);
-      DCHECK_LT(uffd_continue.mapped, static_cast<ssize_t>(length));
-      if (kFirstPageMapping) {
-        // In this case the first page must be mapped.
-        DCHECK_GE(uffd_continue.mapped, static_cast<ssize_t>(gPageSize));
-      }
-      // Nobody would modify these pages' state simultaneously so only atomic
-      // store is sufficient. Use 'release' order to ensure that all states are
-      // modified sequentially.
-      for (size_t remaining_len = length - uffd_continue.mapped; remaining_len > 0;
-           remaining_len -= gPageSize) {
-        arr_idx--;
-        DCHECK_EQ(state_arr[arr_idx].load(std::memory_order_relaxed),
-                  PageState::kProcessedAndMapping);
-        state_arr[arr_idx].store(PageState::kProcessed, std::memory_order_release);
-      }
-      uffd_continue.range.start =
-          reinterpret_cast<uintptr_t>(to_space_start) + uffd_continue.mapped;
-      uffd_continue.range.len = length - uffd_continue.mapped;
-      ret = ioctl(uffd_, UFFDIO_WAKE, &uffd_continue.range);
-      CHECK_EQ(ret, 0) << "ioctl_userfaultfd: wake failed: " << strerror(errno);
-    } else {
-      // We may receive ENOENT if gc-thread unregisters the
-      // range behind our back, which is fine because that
-      // happens only when it knows compaction is done.
-      CHECK(ret == 0 || !kFirstPageMapping || errno == ENOENT)
-          << "ioctl_userfaultfd: continue failed: " << strerror(errno);
-      if (ret == 0) {
-        DCHECK_EQ(uffd_continue.mapped, static_cast<ssize_t>(length));
-      }
-    }
-    if (use_uffd_sigbus_) {
-      // Nobody else would modify these pages' state simultaneously so atomic
-      // store is sufficient.
-      for (; uffd_continue.mapped > 0; uffd_continue.mapped -= gPageSize) {
-        arr_idx--;
-        DCHECK_EQ(state_arr[arr_idx].load(std::memory_order_relaxed),
-                  PageState::kProcessedAndMapping);
-        state_arr[arr_idx].store(PageState::kProcessedAndMapped, std::memory_order_release);
-      }
-    }
-  }
-}
-
 template <uint32_t kYieldMax = 5, uint64_t kSleepUs = 10>
 static void BackOff(uint32_t i) {
   // TODO: Consider adding x86 PAUSE and/or ARM YIELD here.
@@ -2151,7 +1726,8 @@ size_t MarkCompact::ZeropageIoctl(void* addr,
   }
 }
 
-size_t MarkCompact::CopyIoctl(void* dst, void* buffer, size_t length, bool return_on_contention) {
+size_t MarkCompact::CopyIoctl(
+    void* dst, void* buffer, size_t length, bool return_on_contention, bool tolerate_enoent) {
   int32_t backoff_count = -1;
   int32_t max_backoff = 10;  // max native priority.
   struct uffdio_copy uffd_copy;
@@ -2203,9 +1779,10 @@ size_t MarkCompact::CopyIoctl(void* dst, void* buffer, size_t length, bool retur
       uffd_copy.copy += gPageSize;
       break;
     } else {
-      DCHECK_EQ(uffd_copy.copy, -errno);
-      LOG(FATAL) << "ioctl_userfaultfd: copy failed: " << strerror(errno) << ". src:" << buffer
-                 << " dst:" << dst;
+      CHECK(tolerate_enoent && errno == ENOENT)
+          << "ioctl_userfaultfd: copy failed: " << strerror(errno) << ". src:" << buffer
+          << " dst:" << dst;
+      return uffd_copy.copy > 0 ? uffd_copy.copy : 0;
     }
   }
   return uffd_copy.copy;
@@ -2231,7 +1808,11 @@ bool MarkCompact::DoPageCompactionWithStateChange(size_t page_idx,
     func();
     if (kMode == kCopyMode) {
       if (map_immediately) {
-        CopyIoctl(to_space_page, page, gPageSize, /*return_on_contention=*/false);
+        CopyIoctl(to_space_page,
+                  page,
+                  gPageSize,
+                  /*return_on_contention=*/false,
+                  /*tolerate_enoent=*/false);
         // Store is sufficient as no other thread could modify the status at this
         // point. Relaxed order is sufficient as the ioctl will act as a fence.
         moving_pages_status_[page_idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapped),
@@ -2247,18 +1828,6 @@ bool MarkCompact::DoPageCompactionWithStateChange(size_t page_idx,
         // Store is sufficient as no other thread would modify the status at this point.
         moving_pages_status_[page_idx].store(store_val, std::memory_order_release);
       }
-    } else if (kMode == kMinorFaultMode) {
-      expected_state = static_cast<uint8_t>(PageState::kProcessing);
-      desired_state = static_cast<uint8_t>(PageState::kProcessed);
-      // the CAS needs to be with release order to ensure that stores to the
-      // page makes it to memory *before* other threads observe that it's
-      // ready to be mapped.
-      if (!moving_pages_status_[page_idx].compare_exchange_strong(
-              expected_state, desired_state, std::memory_order_release)) {
-        // Some mutator has requested to map the page after processing it.
-        DCHECK_EQ(expected_state, static_cast<uint8_t>(PageState::kProcessingAndMapping));
-      }
-      UNREACHABLE();
     }
     return true;
   } else {
@@ -2352,7 +1921,7 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
   DCHECK_ALIGNED_PARAM(reclaim_begin, gPageSize);
   DCHECK_ALIGNED_PARAM(last_reclaimed_page_, gPageSize);
   // Check if the 'class_after_obj_map_' map allows pages to be freed.
-  for (; class_after_obj_iter_ != class_after_obj_ordered_map_.rend(); class_after_obj_iter_++) {
+  for (; class_after_obj_iter_ != class_after_obj_map_.rend(); class_after_obj_iter_++) {
     mirror::Object* klass = class_after_obj_iter_->first.AsMirrorPtr();
     mirror::Class* from_klass = static_cast<mirror::Class*>(GetFromSpaceAddr(klass));
     // Check with class' end to ensure that, if required, the entire class survives.
@@ -2360,10 +1929,7 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
     DCHECK_LE(klass_end, last_reclaimed_page_);
     if (reinterpret_cast<uint8_t*>(klass_end) >= reclaim_begin) {
       // Found a class which is in the reclaim range.
-      uint8_t* obj_addr = reinterpret_cast<uint8_t*>(class_after_obj_iter_->second.AsMirrorPtr());
-      // NOTE: Don't assert that obj is of 'klass' type as klass could instead
-      // be its super-class.
-      if (obj_addr < idx_addr) {
+      if (reinterpret_cast<uint8_t*>(class_after_obj_iter_->second.AsMirrorPtr()) < idx_addr) {
         // Its lowest-address object is not compacted yet. Reclaim starting from
         // the end of this class.
         reclaim_begin = AlignUp(klass_end, gPageSize);
@@ -2385,8 +1951,8 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
       if (MapMovingSpacePages(cur_page_idx,
                               end_idx_for_mapping,
                               /*from_ioctl=*/false,
-                              /*return_on_contention=*/true) ==
-          end_idx_for_mapping - cur_page_idx) {
+                              /*return_on_contention=*/true,
+                              /*tolerate_enoent=*/false) == end_idx_for_mapping - cur_page_idx) {
         all_mapped = true;
       }
     } else {
@@ -2401,8 +1967,7 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
       DCHECK_LT(gBufferPages, kMinFromSpaceMadviseSize);
       size -= gBufferPages;
       uint8_t* addr = last_reclaimed_page_ - size;
-      int behavior = minor_fault_initialized_ ? MADV_REMOVE : MADV_DONTNEED;
-      CHECK_EQ(madvise(addr + from_space_slide_diff_, size, behavior), 0)
+      CHECK_EQ(madvise(addr + from_space_slide_diff_, size, MADV_DONTNEED), 0)
           << "madvise of from-space failed: " << strerror(errno);
       last_reclaimed_page_ = addr;
       cur_reclaimable_page_ = addr;
@@ -2414,29 +1979,6 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
   return all_mapped;
 }
 
-void MarkCompact::UpdateClassAfterObjMap() {
-  CHECK(class_after_obj_ordered_map_.empty());
-  for (const auto& pair : class_after_obj_hash_map_) {
-    auto super_class_iter = super_class_after_class_hash_map_.find(pair.first);
-    ObjReference key = super_class_iter != super_class_after_class_hash_map_.end()
-                       ? super_class_iter->second
-                       : pair.first;
-    if (std::less<mirror::Object*>{}(pair.second.AsMirrorPtr(), key.AsMirrorPtr()) &&
-        HasAddress(key.AsMirrorPtr())) {
-      auto [ret_iter, success] = class_after_obj_ordered_map_.try_emplace(key, pair.second);
-      // It could fail only if the class 'key' has objects of its own, which are lower in
-      // address order, as well of some of its derived class. In this case
-      // choose the lowest address object.
-      if (!success &&
-          std::less<mirror::Object*>{}(pair.second.AsMirrorPtr(), ret_iter->second.AsMirrorPtr())) {
-        ret_iter->second = pair.second;
-      }
-    }
-  }
-  class_after_obj_hash_map_.clear();
-  super_class_after_class_hash_map_.clear();
-}
-
 template <int kMode>
 void MarkCompact::CompactMovingSpace(uint8_t* page) {
   // For every page we have a starting object, which may have started in some
@@ -2453,31 +1995,23 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
   size_t page_status_arr_len = moving_first_objs_count_ + black_page_count_;
   size_t idx = page_status_arr_len;
   uint8_t* to_space_end = bump_pointer_space_->Begin() + page_status_arr_len * gPageSize;
-  uint8_t* shadow_space_end = nullptr;
-  if (kMode == kMinorFaultMode) {
-    shadow_space_end = shadow_to_space_map_.Begin() + page_status_arr_len * gPageSize;
-  }
   uint8_t* pre_compact_page = black_allocations_begin_ + (black_page_count_ * gPageSize);
 
   DCHECK(IsAlignedParam(pre_compact_page, gPageSize));
 
-  UpdateClassAfterObjMap();
   // These variables are maintained by FreeFromSpacePages().
   last_reclaimed_page_ = pre_compact_page;
   last_reclaimable_page_ = last_reclaimed_page_;
   cur_reclaimable_page_ = last_reclaimed_page_;
   last_checked_reclaim_page_idx_ = idx;
-  class_after_obj_iter_ = class_after_obj_ordered_map_.rbegin();
+  class_after_obj_iter_ = class_after_obj_map_.rbegin();
   // Allocated-black pages
   mirror::Object* next_page_first_obj = nullptr;
   while (idx > moving_first_objs_count_) {
     idx--;
     pre_compact_page -= gPageSize;
     to_space_end -= gPageSize;
-    if (kMode == kMinorFaultMode) {
-      shadow_space_end -= gPageSize;
-      page = shadow_space_end;
-    } else if (kMode == kFallbackMode) {
+    if (kMode == kFallbackMode) {
       page = to_space_end;
     }
     mirror::Object* first_obj = first_objs_moving_space_[idx].AsMirrorPtr();
@@ -2510,10 +2044,7 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
   while (idx > 0) {
     idx--;
     to_space_end -= gPageSize;
-    if (kMode == kMinorFaultMode) {
-      shadow_space_end -= gPageSize;
-      page = shadow_space_end;
-    } else if (kMode == kFallbackMode) {
+    if (kMode == kFallbackMode) {
       page = to_space_end;
     } else {
       DCHECK_EQ(kMode, kCopyMode);
@@ -2536,8 +2067,11 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
     if (kMode == kCopyMode && (!success || page == reserve_page) && end_idx_for_mapping - idx > 1) {
       // map the pages in the following address as they can't be mapped with the
       // pages yet-to-be-compacted as their src-side pages won't be contiguous.
-      MapMovingSpacePages(
-          idx + 1, end_idx_for_mapping, /*from_fault=*/false, /*return_on_contention=*/true);
+      MapMovingSpacePages(idx + 1,
+                          end_idx_for_mapping,
+                          /*from_fault=*/false,
+                          /*return_on_contention=*/true,
+                          /*tolerate_enoent=*/false);
     }
     if (FreeFromSpacePages(idx, kMode, end_idx_for_mapping)) {
       end_idx_for_mapping = idx;
@@ -2545,8 +2079,11 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
   }
   // map one last time to finish anything left.
   if (kMode == kCopyMode && end_idx_for_mapping > 0) {
-    MapMovingSpacePages(
-        idx, end_idx_for_mapping, /*from_fault=*/false, /*return_on_contention=*/false);
+    MapMovingSpacePages(idx,
+                        end_idx_for_mapping,
+                        /*from_fault=*/false,
+                        /*return_on_contention=*/false,
+                        /*tolerate_enoent=*/false);
   }
   DCHECK_EQ(to_space_end, bump_pointer_space_->Begin());
 }
@@ -2554,7 +2091,8 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
 size_t MarkCompact::MapMovingSpacePages(size_t start_idx,
                                         size_t arr_len,
                                         bool from_fault,
-                                        bool return_on_contention) {
+                                        bool return_on_contention,
+                                        bool tolerate_enoent) {
   DCHECK_LT(start_idx, arr_len);
   size_t arr_idx = start_idx;
   bool wait_for_unmapped = false;
@@ -2590,8 +2128,11 @@ size_t MarkCompact::MapMovingSpacePages(size_t start_idx,
       uint8_t* from_space_start = from_space_begin_ + from_space_offset;
       DCHECK_ALIGNED_PARAM(to_space_start, gPageSize);
       DCHECK_ALIGNED_PARAM(from_space_start, gPageSize);
-      size_t mapped_len =
-          CopyIoctl(to_space_start, from_space_start, map_count * gPageSize, return_on_contention);
+      size_t mapped_len = CopyIoctl(to_space_start,
+                                    from_space_start,
+                                    map_count * gPageSize,
+                                    return_on_contention,
+                                    tolerate_enoent);
       for (size_t l = 0; l < mapped_len; l += gPageSize, arr_idx++) {
         // Store is sufficient as anyone storing is doing it with the same value.
         moving_pages_status_[arr_idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapped),
@@ -3267,10 +2808,9 @@ void MarkCompact::CompactionPause() {
             }
           });
     }
-    if (use_uffd_sigbus_) {
-      // Release order wrt to mutator threads' SIGBUS handler load.
-      sigbus_in_progress_count_.store(0, std::memory_order_release);
-    }
+    // Release order wrt to mutator threads' SIGBUS handler load.
+    sigbus_in_progress_count_[0].store(0, std::memory_order_relaxed);
+    sigbus_in_progress_count_[1].store(0, std::memory_order_release);
     KernelPreparation();
   }
 
@@ -3283,21 +2823,12 @@ void MarkCompact::CompactionPause() {
     bump_pointer_space_->RecordFree(freed_objects_, freed_bytes);
     RecordFree(ObjectBytePair(freed_objects_, freed_bytes));
   } else {
-    DCHECK_EQ(compaction_in_progress_count_.load(std::memory_order_relaxed), 0u);
     DCHECK_EQ(compaction_buffer_counter_.load(std::memory_order_relaxed), 1);
-    if (!use_uffd_sigbus_) {
-      // We must start worker threads before resuming mutators to avoid deadlocks.
-      heap_->GetThreadPool()->StartWorkers(thread_running_gc_);
-    }
   }
   stack_low_addr_ = nullptr;
 }
 
-void MarkCompact::KernelPrepareRangeForUffd(uint8_t* to_addr,
-                                            uint8_t* from_addr,
-                                            size_t map_size,
-                                            int fd,
-                                            uint8_t* shadow_addr) {
+void MarkCompact::KernelPrepareRangeForUffd(uint8_t* to_addr, uint8_t* from_addr, size_t map_size) {
   int mremap_flags = MREMAP_MAYMOVE | MREMAP_FIXED;
   if (gHaveMremapDontunmap) {
     mremap_flags |= MREMAP_DONTUNMAP;
@@ -3308,31 +2839,16 @@ void MarkCompact::KernelPrepareRangeForUffd(uint8_t* to_addr,
       << "mremap to move pages failed: " << strerror(errno)
       << ". space-addr=" << reinterpret_cast<void*>(to_addr) << " size=" << PrettySize(map_size);
 
-  if (shadow_addr != nullptr) {
-    DCHECK_EQ(fd, kFdUnused);
-    DCHECK(gHaveMremapDontunmap);
-    ret = mremap(shadow_addr, map_size, map_size, mremap_flags, to_addr);
-    CHECK_EQ(ret, static_cast<void*>(to_addr))
-        << "mremap from shadow to to-space map failed: " << strerror(errno);
-  } else if (!gHaveMremapDontunmap || fd > kFdUnused) {
+  if (!gHaveMremapDontunmap) {
     // Without MREMAP_DONTUNMAP the source mapping is unmapped by mremap. So mmap
     // the moving space again.
     int mmap_flags = MAP_FIXED;
-    if (fd == kFdUnused) {
-      // Use MAP_FIXED_NOREPLACE so that if someone else reserves 'to_addr'
-      // mapping in meantime, which can happen when MREMAP_DONTUNMAP isn't
-      // available, to avoid unmapping someone else' mapping and then causing
-      // crashes elsewhere.
-      mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED_NOREPLACE;
-      // On some platforms MAP_ANONYMOUS expects fd to be -1.
-      fd = -1;
-    } else if (IsValidFd(fd)) {
-      mmap_flags |= MAP_SHARED;
-    } else {
-      DCHECK_EQ(fd, kFdSharedAnon);
-      mmap_flags |= MAP_SHARED | MAP_ANONYMOUS;
-    }
-    ret = mmap(to_addr, map_size, PROT_READ | PROT_WRITE, mmap_flags, fd, 0);
+    // Use MAP_FIXED_NOREPLACE so that if someone else reserves 'to_addr'
+    // mapping in meantime, which can happen when MREMAP_DONTUNMAP isn't
+    // available, to avoid unmapping someone else' mapping and then causing
+    // crashes elsewhere.
+    mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED_NOREPLACE;
+    ret = mmap(to_addr, map_size, PROT_READ | PROT_WRITE, mmap_flags, -1, 0);
     CHECK_EQ(ret, static_cast<void*>(to_addr))
         << "mmap for moving space failed: " << strerror(errno);
   }
@@ -3342,54 +2858,10 @@ void MarkCompact::KernelPreparation() {
   TimingLogger::ScopedTiming t("(Paused)KernelPreparation", GetTimings());
   uint8_t* moving_space_begin = bump_pointer_space_->Begin();
   size_t moving_space_size = bump_pointer_space_->Capacity();
-  int mode = kCopyMode;
   size_t moving_space_register_sz = (moving_first_objs_count_ + black_page_count_) * gPageSize;
   DCHECK_LE(moving_space_register_sz, moving_space_size);
-  if (minor_fault_initialized_) {
-    if (shadow_to_space_map_.IsValid()) {
-      size_t shadow_size = shadow_to_space_map_.Size();
-      void* addr = shadow_to_space_map_.Begin();
-      if (shadow_size < moving_space_register_sz) {
-        addr = mremap(addr,
-                      shadow_size,
-                      moving_space_register_sz,
-                      // Don't allow moving with obj-ptr poisoning as the
-                      // mapping needs to be in <4GB address space.
-                      kObjPtrPoisoning ? 0 : MREMAP_MAYMOVE,
-                      /*new_address=*/nullptr);
-        if (addr != MAP_FAILED) {
-          // Succeeded in expanding the mapping. Update the MemMap entry for shadow map.
-          MemMap temp = MemMap::MapPlaceholder(
-              "moving-space-shadow", static_cast<uint8_t*>(addr), moving_space_register_sz);
-          std::swap(shadow_to_space_map_, temp);
-        }
-      }
-      if (addr != MAP_FAILED) {
-        mode = kMinorFaultMode;
-      } else {
-        // We are not going to use shadow map. So protect it to catch any
-        // potential bugs.
-        DCHECK_EQ(mprotect(shadow_to_space_map_.Begin(), shadow_to_space_map_.Size(), PROT_NONE), 0)
-            << "mprotect failed: " << strerror(errno);
-      }
-    }
-  }
-
-  bool map_shared =
-      minor_fault_initialized_ || (!Runtime::Current()->IsZygote() && uffd_minor_fault_supported_);
-  uint8_t* shadow_addr = nullptr;
-  if (moving_to_space_fd_ == kFdUnused && map_shared) {
-    DCHECK(gHaveMremapDontunmap);
-    DCHECK(shadow_to_space_map_.IsValid());
-    DCHECK_EQ(shadow_to_space_map_.Size(), moving_space_size);
-    shadow_addr = shadow_to_space_map_.Begin();
-  }
 
-  KernelPrepareRangeForUffd(moving_space_begin,
-                            from_space_begin_,
-                            moving_space_size,
-                            moving_to_space_fd_,
-                            shadow_addr);
+  KernelPrepareRangeForUffd(moving_space_begin, from_space_begin_, moving_space_size);
 
   if (IsValidFd(uffd_)) {
     if (moving_space_register_sz > 0) {
@@ -3405,91 +2877,39 @@ void MarkCompact::KernelPreparation() {
       // the used portion after compaction, the two split vmas merge. This is
       // necessary for the mremap of the next GC cycle to not fail due to having
       // more than one vma in the source range.
-      if (moving_space_register_sz < moving_space_size) {
-        *const_cast<volatile uint8_t*>(moving_space_begin + moving_space_register_sz) = 0;
+      //
+      // Fault in address aligned to PMD size so that in case THP is enabled,
+      // we don't mistakenly fault a page in beginning portion that will be
+      // registered with uffd. If the alignment takes us beyond the space, then
+      // fault the first page and madvise it.
+      size_t pmd_size = Heap::GetPMDSize();
+      uint8_t* fault_in_addr = AlignUp(moving_space_begin + moving_space_register_sz, pmd_size);
+      if (bump_pointer_space_->Contains(reinterpret_cast<mirror::Object*>(fault_in_addr))) {
+        *const_cast<volatile uint8_t*>(fault_in_addr) = 0;
+      } else {
+        DCHECK_ALIGNED_PARAM(moving_space_begin, gPageSize);
+        *const_cast<volatile uint8_t*>(moving_space_begin) = 0;
+        madvise(moving_space_begin, pmd_size, MADV_DONTNEED);
       }
       // Register the moving space with userfaultfd.
-      RegisterUffd(moving_space_begin, moving_space_register_sz, mode);
+      RegisterUffd(moving_space_begin, moving_space_register_sz);
+      // madvise ensures that if any page gets mapped (only possible if some
+      // thread is reading the page(s) without trying to make sense as we hold
+      // mutator-lock exclusively) between mremap and uffd-registration, then
+      // it gets zapped so that the map is empty and ready for userfaults. If
+      // we could mremap after uffd-registration (like in case of linear-alloc
+      // space below) then we wouldn't need it. But since we don't register the
+      // entire space, we can't do that.
+      madvise(moving_space_begin, moving_space_register_sz, MADV_DONTNEED);
     }
     // Prepare linear-alloc for concurrent compaction.
     for (auto& data : linear_alloc_spaces_data_) {
-      bool mmap_again = map_shared && !data.already_shared_;
       DCHECK_EQ(static_cast<ssize_t>(data.shadow_.Size()), data.end_ - data.begin_);
       // There could be threads running in suspended mode when the compaction
       // pause is being executed. In order to make the userfaultfd setup atomic,
       // the registration has to be done *before* moving the pages to shadow map.
-      if (!mmap_again) {
-        // See the comment in the constructor as to why it's conditionally done.
-        RegisterUffd(data.begin_,
-                     data.shadow_.Size(),
-                     minor_fault_initialized_ ? kMinorFaultMode : kCopyMode);
-      }
-      KernelPrepareRangeForUffd(data.begin_,
-                                data.shadow_.Begin(),
-                                data.shadow_.Size(),
-                                mmap_again ? kFdSharedAnon : kFdUnused);
-      if (mmap_again) {
-        data.already_shared_ = true;
-        RegisterUffd(data.begin_,
-                     data.shadow_.Size(),
-                     minor_fault_initialized_ ? kMinorFaultMode : kCopyMode);
-      }
-    }
-  }
-  if (map_shared) {
-    // Start mapping linear-alloc MAP_SHARED only after the compaction pause of
-    // the first GC in non-zygote processes. This is the GC which sets up
-    // mappings for using minor-fault in future. Up to this point we run
-    // userfaultfd in copy-mode, which requires the mappings (of linear-alloc)
-    // to be MAP_PRIVATE.
-    map_linear_alloc_shared_ = true;
-  }
-}
-
-template <int kMode>
-void MarkCompact::ConcurrentCompaction(uint8_t* buf) {
-  DCHECK_NE(kMode, kFallbackMode);
-  DCHECK(kMode != kCopyMode || buf != nullptr);
-  size_t nr_moving_space_used_pages = moving_first_objs_count_ + black_page_count_;
-  while (true) {
-    struct uffd_msg msg;
-    ssize_t nread = read(uffd_, &msg, sizeof(msg));
-    CHECK_GT(nread, 0);
-    CHECK_EQ(msg.event, UFFD_EVENT_PAGEFAULT);
-    DCHECK_EQ(nread, static_cast<ssize_t>(sizeof(msg)));
-    uint8_t* fault_addr = reinterpret_cast<uint8_t*>(msg.arg.pagefault.address);
-    if (fault_addr == conc_compaction_termination_page_) {
-      // The counter doesn't need to be updated atomically as only one thread
-      // would wake up against the gc-thread's load to this fault_addr. In fact,
-      // the other threads would wake up serially because every exiting thread
-      // will wake up gc-thread, which would retry load but again would find the
-      // page missing. Also, the value will be flushed to caches due to the ioctl
-      // syscall below.
-      uint8_t ret = thread_pool_counter_--;
-      // If 'gKernelHasFaultRetry == true' then only the last thread should map the
-      // zeropage so that the gc-thread can proceed. Otherwise, each thread does
-      // it and the gc-thread will repeat this fault until thread_pool_counter == 0.
-      if (!gKernelHasFaultRetry || ret == 1) {
-        ZeropageIoctl(fault_addr, gPageSize, /*tolerate_eexist=*/false, /*tolerate_enoent=*/false);
-      } else {
-        struct uffdio_range uffd_range;
-        uffd_range.start = msg.arg.pagefault.address;
-        uffd_range.len = gPageSize;
-        CHECK_EQ(ioctl(uffd_, UFFDIO_WAKE, &uffd_range), 0)
-            << "ioctl_userfaultfd: wake failed for concurrent-compaction termination page: "
-            << strerror(errno);
-      }
-      break;
-    }
-    uint8_t* fault_page = AlignDown(fault_addr, gPageSize);
-    if (HasAddress(reinterpret_cast<mirror::Object*>(fault_addr))) {
-      ConcurrentlyProcessMovingPage<kMode>(fault_page, buf, nr_moving_space_used_pages);
-    } else if (minor_fault_initialized_) {
-      ConcurrentlyProcessLinearAllocPage<kMinorFaultMode>(
-          fault_page, (msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_MINOR) != 0);
-    } else {
-      ConcurrentlyProcessLinearAllocPage<kCopyMode>(
-          fault_page, (msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_MINOR) != 0);
+      RegisterUffd(data.begin_, data.shadow_.Size());
+      KernelPrepareRangeForUffd(data.begin_, data.shadow_.Begin(), data.shadow_.Size());
     }
   }
 }
@@ -3499,35 +2919,34 @@ bool MarkCompact::SigbusHandler(siginfo_t* info) {
    public:
     explicit ScopedInProgressCount(MarkCompact* collector) : collector_(collector) {
       // Increment the count only if compaction is not done yet.
-      SigbusCounterType prev =
-          collector_->sigbus_in_progress_count_.load(std::memory_order_relaxed);
-      while ((prev & kSigbusCounterCompactionDoneMask) == 0) {
-        if (collector_->sigbus_in_progress_count_.compare_exchange_strong(
-                prev, prev + 1, std::memory_order_acquire)) {
-          DCHECK_LT(prev, kSigbusCounterCompactionDoneMask - 1);
-          compaction_done_ = false;
-          return;
+      for (idx_ = 0; idx_ < 2; idx_++) {
+        SigbusCounterType prev =
+            collector_->sigbus_in_progress_count_[idx_].load(std::memory_order_relaxed);
+        while ((prev & kSigbusCounterCompactionDoneMask) == 0) {
+          if (collector_->sigbus_in_progress_count_[idx_].compare_exchange_strong(
+                  prev, prev + 1, std::memory_order_acquire)) {
+            DCHECK_LT(prev, kSigbusCounterCompactionDoneMask - 1);
+            return;
+          }
         }
       }
-      compaction_done_ = true;
     }
 
-    bool IsCompactionDone() const {
-      return compaction_done_;
-    }
+    bool TolerateEnoent() const { return idx_ == 1; }
+
+    bool IsCompactionDone() const { return idx_ == 2; }
 
     ~ScopedInProgressCount() {
-      if (!IsCompactionDone()) {
-        collector_->sigbus_in_progress_count_.fetch_sub(1, std::memory_order_release);
+      if (idx_ < 2) {
+        collector_->sigbus_in_progress_count_[idx_].fetch_sub(1, std::memory_order_release);
       }
     }
 
    private:
     MarkCompact* const collector_;
-    bool compaction_done_;
+    uint8_t idx_;
   };
 
-  DCHECK(use_uffd_sigbus_);
   if (info->si_code != BUS_ADRERR) {
     // Userfaultfd raises SIGBUS with BUS_ADRERR. All other causes can't be
     // handled here.
@@ -3541,23 +2960,16 @@ bool MarkCompact::SigbusHandler(siginfo_t* info) {
       Thread* self = Thread::Current();
       Locks::mutator_lock_->AssertSharedHeld(self);
       size_t nr_moving_space_used_pages = moving_first_objs_count_ + black_page_count_;
-      if (minor_fault_initialized_) {
-        ConcurrentlyProcessMovingPage<kMinorFaultMode>(
-            fault_page, nullptr, nr_moving_space_used_pages);
-      } else {
-        ConcurrentlyProcessMovingPage<kCopyMode>(
-            fault_page, self->GetThreadLocalGcBuffer(), nr_moving_space_used_pages);
-      }
+      ConcurrentlyProcessMovingPage(fault_page,
+                                    self->GetThreadLocalGcBuffer(),
+                                    nr_moving_space_used_pages,
+                                    spc.TolerateEnoent());
       return true;
     } else {
       // Find the linear-alloc space containing fault-addr
       for (auto& data : linear_alloc_spaces_data_) {
         if (data.begin_ <= fault_page && data.end_ > fault_page) {
-          if (minor_fault_initialized_) {
-            ConcurrentlyProcessLinearAllocPage<kMinorFaultMode>(fault_page, false);
-          } else {
-            ConcurrentlyProcessLinearAllocPage<kCopyMode>(fault_page, false);
-          }
+          ConcurrentlyProcessLinearAllocPage(fault_page, spc.TolerateEnoent());
           return true;
         }
       }
@@ -3578,37 +2990,19 @@ bool MarkCompact::SigbusHandler(siginfo_t* info) {
   }
 }
 
-template <int kMode>
 void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
                                                 uint8_t* buf,
-                                                size_t nr_moving_space_used_pages) {
-  // TODO: add a class for Scoped dtor to set that a page has already mapped.
-  // This helps in avoiding a zero-page ioctl in gc-thread before unregistering
-  // unused space.
-  class ScopedInProgressCount {
-   public:
-    explicit ScopedInProgressCount(MarkCompact* collector) : collector_(collector) {
-      collector_->compaction_in_progress_count_.fetch_add(1, std::memory_order_relaxed);
-    }
-
-    ~ScopedInProgressCount() {
-      collector_->compaction_in_progress_count_.fetch_sub(1, std::memory_order_relaxed);
-    }
-
-   private:
-    MarkCompact* collector_;
-  };
-
+                                                size_t nr_moving_space_used_pages,
+                                                bool tolerate_enoent) {
   Thread* self = Thread::Current();
   uint8_t* unused_space_begin =
       bump_pointer_space_->Begin() + nr_moving_space_used_pages * gPageSize;
   DCHECK(IsAlignedParam(unused_space_begin, gPageSize));
-  DCHECK(kMode == kCopyMode || fault_page < unused_space_begin);
-  if (kMode == kCopyMode && fault_page >= unused_space_begin) {
+  if (fault_page >= unused_space_begin) {
     // There is a race which allows more than one thread to install a
     // zero-page. But we can tolerate that. So absorb the EEXIST returned by
     // the ioctl and move on.
-    ZeropageIoctl(fault_page, gPageSize, /*tolerate_eexist=*/true, /*tolerate_enoent=*/true);
+    ZeropageIoctl(fault_page, gPageSize, /*tolerate_eexist=*/true, tolerate_enoent);
     return;
   }
   size_t page_idx = DivideByPageSize(fault_page - bump_pointer_space_->Begin());
@@ -3630,8 +3024,7 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
       }
     }
     if (length > 0) {
-      length =
-          ZeropageIoctl(fault_page, length, /*tolerate_eexist=*/true, /*tolerate_enoent=*/true);
+      length = ZeropageIoctl(fault_page, length, /*tolerate_eexist=*/true, tolerate_enoent);
       for (size_t len = 0, idx = page_idx; len < length; idx++, len += gPageSize) {
         moving_pages_status_[idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapped),
                                         std::memory_order_release);
@@ -3640,17 +3033,13 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
     return;
   }
 
-  uint32_t raw_state = moving_pages_status_[page_idx].load(
-      use_uffd_sigbus_ ? std::memory_order_acquire : std::memory_order_relaxed);
+  uint32_t raw_state = moving_pages_status_[page_idx].load(std::memory_order_acquire);
   uint32_t backoff_count = 0;
   PageState state;
   while (true) {
     state = GetPageStateFromWord(raw_state);
     if (state == PageState::kProcessing || state == PageState::kMutatorProcessing ||
         state == PageState::kProcessingAndMapping || state == PageState::kProcessedAndMapping) {
-      if (!use_uffd_sigbus_) {
-        break;
-      }
       // Wait for the page to be mapped (by gc-thread or some mutator) before returning.
       // The wait is not expected to be long as the read state indicates that the other
       // thread is actively working on the page.
@@ -3660,25 +3049,14 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
       // Nothing to do.
       break;
     } else {
-      // The increment to the in-progress counter must be done before updating
-      // the page's state. Otherwise, we will end up leaving a window wherein
-      // the GC-thread could observe that no worker is working on compaction
-      // and could end up unregistering the moving space from userfaultfd.
-      ScopedInProgressCount spc(this);
-      // Acquire order to ensure we don't start writing to shadow map, which is
-      // shared, before the CAS is successful. Release order to ensure that the
-      // increment to moving_compaction_in_progress above is not re-ordered
-      // after the CAS.
+      // Acquire order to ensure we don't start writing to a page, which could
+      // be shared, before the CAS is successful.
       if (state == PageState::kUnprocessed &&
           moving_pages_status_[page_idx].compare_exchange_strong(
               raw_state,
               static_cast<uint8_t>(PageState::kMutatorProcessing),
-              std::memory_order_acq_rel)) {
-        if (kMode == kMinorFaultMode) {
-          DCHECK_EQ(buf, nullptr);
-          buf = shadow_to_space_map_.Begin() + page_idx * gPageSize;
-        } else if (UNLIKELY(buf == nullptr)) {
-          DCHECK_EQ(kMode, kCopyMode);
+              std::memory_order_acquire)) {
+        if (UNLIKELY(buf == nullptr)) {
           uint16_t idx = compaction_buffer_counter_.fetch_add(1, std::memory_order_relaxed);
           // The buffer-map is one page bigger as the first buffer is used by GC-thread.
           CHECK_LE(idx, kMutatorCompactionBufferCount);
@@ -3689,8 +3067,10 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
 
         if (fault_page < post_compact_end_) {
           // The page has to be compacted.
-          CompactPage(
-              first_obj, pre_compact_offset_moving_space_[page_idx], buf, kMode == kCopyMode);
+          CompactPage(first_obj,
+                      pre_compact_offset_moving_space_[page_idx],
+                      buf,
+                      /*needs_memset_zero=*/true);
         } else {
           DCHECK_NE(first_obj, nullptr);
           DCHECK_GT(pre_compact_offset_moving_space_[page_idx], 0u);
@@ -3706,7 +3086,7 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
                          first_chunk_size,
                          pre_compact_page,
                          buf,
-                         kMode == kCopyMode);
+                         /*needs_memset_zero=*/true);
         }
         // Nobody else would simultaneously modify this page's state so an
         // atomic store is sufficient. Use 'release' order to guarantee that
@@ -3716,16 +3096,11 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
         // to immediately map the page, so that info is not needed.
         moving_pages_status_[page_idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapping),
                                              std::memory_order_release);
-        if (kMode == kCopyMode) {
-          CopyIoctl(fault_page, buf, gPageSize, /*return_on_contention=*/false);
-          // Store is sufficient as no other thread modifies the status at this stage.
-          moving_pages_status_[page_idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapped),
-                                               std::memory_order_release);
-          break;
-        } else {
-          // We don't support minor-fault feature anymore.
-          UNREACHABLE();
-        }
+        CopyIoctl(fault_page, buf, gPageSize, /*return_on_contention=*/false, tolerate_enoent);
+        // Store is sufficient as no other thread modifies the status at this stage.
+        moving_pages_status_[page_idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapped),
+                                             std::memory_order_release);
+        break;
       }
       state = GetPageStateFromWord(raw_state);
       if (state == PageState::kProcessed) {
@@ -3736,7 +3111,8 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
         if (MapMovingSpacePages(page_idx,
                                 arr_len,
                                 /*from_fault=*/true,
-                                /*return_on_contention=*/false) > 0) {
+                                /*return_on_contention=*/false,
+                                tolerate_enoent) > 0) {
           break;
         }
         raw_state = moving_pages_status_[page_idx].load(std::memory_order_acquire);
@@ -3750,8 +3126,8 @@ bool MarkCompact::MapUpdatedLinearAllocPages(uint8_t* start_page,
                                              Atomic<PageState>* state,
                                              size_t length,
                                              bool free_pages,
-                                             bool single_ioctl) {
-  DCHECK(!minor_fault_initialized_);
+                                             bool single_ioctl,
+                                             bool tolerate_enoent) {
   DCHECK_ALIGNED_PARAM(length, gPageSize);
   Atomic<PageState>* madv_state = state;
   size_t madv_len = length;
@@ -3790,19 +3166,15 @@ bool MarkCompact::MapUpdatedLinearAllocPages(uint8_t* start_page,
       map_len = CopyIoctl(start_page,
                           start_shadow_page,
                           map_len,
-                          /*return_on_contention=*/false);
+                          /*return_on_contention=*/false,
+                          tolerate_enoent);
       DCHECK_NE(map_len, 0u);
-      if (use_uffd_sigbus_) {
-        // Declare that the pages are ready to be accessed. Store is sufficient
-        // as any thread will be storing the same value.
-        for (size_t l = 0; l < map_len; l += gPageSize, state++) {
-          PageState s = state->load(std::memory_order_relaxed);
-          DCHECK(s == PageState::kProcessed || s == PageState::kProcessedAndMapped)
-              << "state:" << s;
-          state->store(PageState::kProcessedAndMapped, std::memory_order_release);
-        }
-      } else {
-        state += DivideByPageSize(map_len);
+      // Declare that the pages are ready to be accessed. Store is sufficient
+      // as any thread will be storing the same value.
+      for (size_t l = 0; l < map_len; l += gPageSize, state++) {
+        PageState s = state->load(std::memory_order_relaxed);
+        DCHECK(s == PageState::kProcessed || s == PageState::kProcessedAndMapped) << "state:" << s;
+        state->store(PageState::kProcessedAndMapped, std::memory_order_release);
       }
       if (single_ioctl) {
         break;
@@ -3831,9 +3203,7 @@ bool MarkCompact::MapUpdatedLinearAllocPages(uint8_t* start_page,
   return true;
 }
 
-template <int kMode>
-void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool is_minor_fault) {
-  DCHECK(!is_minor_fault || kMode == kMinorFaultMode);
+void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool tolerate_enoent) {
   auto arena_iter = linear_alloc_arenas_.end();
   {
     TrackedArena temp_arena(fault_page);
@@ -3855,7 +3225,7 @@ void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool i
       arena_iter->second <= fault_page) {
     // Fault page isn't in any of the arenas that existed before we started
     // compaction. So map zeropage and return.
-    ZeropageIoctl(fault_page, gPageSize, /*tolerate_eexist=*/true, /*tolerate_enoent=*/false);
+    ZeropageIoctl(fault_page, gPageSize, /*tolerate_eexist=*/true, tolerate_enoent);
   } else {
     // Find the linear-alloc space containing fault-page
     LinearAllocSpaceData* space_data = nullptr;
@@ -3870,8 +3240,7 @@ void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool i
     size_t page_idx = DivideByPageSize(fault_page - space_data->begin_);
     Atomic<PageState>* state_arr =
         reinterpret_cast<Atomic<PageState>*>(space_data->page_status_map_.Begin());
-    PageState state = state_arr[page_idx].load(use_uffd_sigbus_ ? std::memory_order_acquire :
-                                                                  std::memory_order_relaxed);
+    PageState state = state_arr[page_idx].load(std::memory_order_acquire);
     uint32_t backoff_count = 0;
     while (true) {
       switch (state) {
@@ -3880,48 +3249,36 @@ void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool i
           // shared, before the CAS is successful.
           if (state_arr[page_idx].compare_exchange_strong(
                   state, PageState::kProcessing, std::memory_order_acquire)) {
-            if (kMode == kCopyMode || is_minor_fault) {
-              LinearAllocPageUpdater updater(this);
-              uint8_t* first_obj = arena_iter->first->GetFirstObject(fault_page);
-              // null first_obj indicates that it's a page from arena for
-              // intern-table/class-table. So first object isn't required.
-              if (first_obj != nullptr) {
-                updater.MultiObjectArena(fault_page + diff, first_obj + diff);
-              } else {
-                updater.SingleObjectArena(fault_page + diff, gPageSize);
-              }
-              if (kMode == kCopyMode) {
-                if (updater.WasLastPageTouched()) {
-                  state_arr[page_idx].store(PageState::kProcessed, std::memory_order_release);
-                  state = PageState::kProcessed;
-                  continue;
-                } else {
-                  // If the page wasn't touched, then it means it is empty and
-                  // is most likely not present on the shadow-side. Furthermore,
-                  // since the shadow is also userfaultfd registered doing copy
-                  // ioctl fails as the copy-from-user in the kernel will cause
-                  // userfault. Instead, just map a zeropage, which is not only
-                  // correct but also efficient as it avoids unnecessary memcpy
-                  // in the kernel.
-                  ZeropageIoctl(
-                      fault_page, gPageSize, /*tolerate_eexist=*/false, /*tolerate_enoent=*/false);
-                  state_arr[page_idx].store(PageState::kProcessedAndMapped,
-                                            std::memory_order_release);
-                  return;
-                }
-              }
+            LinearAllocPageUpdater updater(this);
+            uint8_t* first_obj = arena_iter->first->GetFirstObject(fault_page);
+            // null first_obj indicates that it's a page from arena for
+            // intern-table/class-table. So first object isn't required.
+            if (first_obj != nullptr) {
+              updater.MultiObjectArena(fault_page + diff, first_obj + diff);
             } else {
-              // Don't touch the page in this case (there is no reason to do so
-              // anyways) as it would mean reading from first_obj, which could be on
-              // another missing page and hence may cause this thread to block, leading
-              // to deadlocks.
-              // Force read the page if it is missing so that a zeropage gets mapped on
-              // the shadow map and then CONTINUE ioctl will map it on linear-alloc.
-              ForceRead(fault_page + diff);
+              updater.SingleObjectArena(fault_page + diff, gPageSize);
+            }
+            if (updater.WasLastPageTouched()) {
+              state_arr[page_idx].store(PageState::kProcessed, std::memory_order_release);
+              state = PageState::kProcessed;
+              continue;
+            } else {
+              // If the page wasn't touched, then it means it is empty and
+              // is most likely not present on the shadow-side. Furthermore,
+              // since the shadow is also userfaultfd registered doing copy
+              // ioctl fails as the copy-from-user in the kernel will cause
+              // userfault. Instead, just map a zeropage, which is not only
+              // correct but also efficient as it avoids unnecessary memcpy
+              // in the kernel.
+              if (ZeropageIoctl(fault_page,
+                                gPageSize,
+                                /*tolerate_eexist=*/false,
+                                tolerate_enoent)) {
+                state_arr[page_idx].store(PageState::kProcessedAndMapped,
+                                          std::memory_order_release);
+              }
+              return;
             }
-            MapProcessedPages</*kFirstPageMapping=*/true>(
-                fault_page, state_arr, page_idx, space_data->page_status_map_.Size());
-            return;
           }
         }
           continue;
@@ -3933,7 +3290,8 @@ void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool i
                                          state_arr + page_idx,
                                          space_data->end_ - fault_page,
                                          /*free_pages=*/false,
-                                         /*single_ioctl=*/true)) {
+                                         /*single_ioctl=*/true,
+                                         tolerate_enoent)) {
             return;
           }
           // fault_page was not mapped by this thread (some other thread claimed
@@ -3942,13 +3300,10 @@ void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool i
         case PageState::kProcessing:
         case PageState::kProcessingAndMapping:
         case PageState::kProcessedAndMapping:
-          if (use_uffd_sigbus_) {
-            // Wait for the page to be mapped before returning.
-            BackOff(backoff_count++);
-            state = state_arr[page_idx].load(std::memory_order_acquire);
-            continue;
-          }
-          return;
+          // Wait for the page to be mapped before returning.
+          BackOff(backoff_count++);
+          state = state_arr[page_idx].load(std::memory_order_acquire);
+          continue;
         case PageState::kMutatorProcessing:
           LOG(FATAL) << "Unreachable";
           UNREACHABLE();
@@ -3958,16 +3313,6 @@ void MarkCompact::ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool i
       }
       break;
     }
-
-    DCHECK_EQ(kMode, kMinorFaultMode);
-    DCHECK_EQ(state, PageState::kProcessed);
-    if (!is_minor_fault) {
-      // Force read the page if it is missing so that a zeropage gets mapped on
-      // the shadow map and then CONTINUE ioctl will map it on linear-alloc.
-      ForceRead(fault_page + diff);
-    }
-    MapProcessedPages</*kFirstPageMapping=*/false>(
-        fault_page, state_arr, page_idx, space_data->page_status_map_.Size());
   }
 }
 
@@ -4000,7 +3345,8 @@ void MarkCompact::ProcessLinearAlloc() {
                                state_arr + page_idx,
                                unmapped_range_end - unmapped_range_start,
                                /*free_pages=*/true,
-                               /*single_ioctl=*/false);
+                               /*single_ioctl=*/false,
+                               /*tolerate_enoent=*/false);
   };
   for (auto& pair : linear_alloc_arenas_) {
     const TrackedArena* arena = pair.first;
@@ -4088,28 +3434,17 @@ void MarkCompact::ProcessLinearAlloc() {
             updater.SingleObjectArena(page_begin + diff, page_size);
           }
           expected_state = PageState::kProcessing;
-          if (!minor_fault_initialized_) {
-            // Store is sufficient as no other thread could be modifying it. Use
-            // release order to ensure that the writes to shadow page are
-            // committed to memory before.
-            if (updater.WasLastPageTouched()) {
-              state_arr[page_idx].store(PageState::kProcessed, std::memory_order_release);
-            } else {
-              // See comment in ConcurrentlyProcessLinearAllocPage() with same situation.
-              ZeropageIoctl(
-                  page_begin, gPageSize, /*tolerate_eexist=*/false, /*tolerate_enoent=*/false);
-              // Ioctl will act as release fence.
-              state_arr[page_idx].store(PageState::kProcessedAndMapped, std::memory_order_release);
-            }
-          } else if (!state_arr[page_idx].compare_exchange_strong(
-                         expected_state, PageState::kProcessed, std::memory_order_release)) {
-            DCHECK_EQ(expected_state, PageState::kProcessingAndMapping);
-            // Force read in case the page was missing and updater didn't touch it
-            // as there was nothing to do. This will ensure that a zeropage is
-            // faulted on the shadow map.
-            ForceRead(page_begin + diff);
-            MapProcessedPages</*kFirstPageMapping=*/true>(
-                page_begin, state_arr, page_idx, space_data->page_status_map_.Size());
+          // Store is sufficient as no other thread could be modifying it. Use
+          // release order to ensure that the writes to shadow page are
+          // committed to memory before.
+          if (updater.WasLastPageTouched()) {
+            state_arr[page_idx].store(PageState::kProcessed, std::memory_order_release);
+          } else {
+            // See comment in ConcurrentlyProcessLinearAllocPage() with same situation.
+            ZeropageIoctl(
+                page_begin, gPageSize, /*tolerate_eexist=*/false, /*tolerate_enoent=*/false);
+            // Ioctl will act as release fence.
+            state_arr[page_idx].store(PageState::kProcessedAndMapped, std::memory_order_release);
           }
         }
       };
@@ -4123,15 +3458,12 @@ void MarkCompact::ProcessLinearAlloc() {
   }
 }
 
-void MarkCompact::RegisterUffd(void* addr, size_t size, int mode) {
+void MarkCompact::RegisterUffd(void* addr, size_t size) {
   DCHECK(IsValidFd(uffd_));
   struct uffdio_register uffd_register;
   uffd_register.range.start = reinterpret_cast<uintptr_t>(addr);
   uffd_register.range.len = size;
   uffd_register.mode = UFFDIO_REGISTER_MODE_MISSING;
-  if (mode == kMinorFaultMode) {
-    uffd_register.mode |= UFFDIO_REGISTER_MODE_MINOR;
-  }
   CHECK_EQ(ioctl(uffd_, UFFDIO_REGISTER, &uffd_register), 0)
       << "ioctl_userfaultfd: register failed: " << strerror(errno)
       << ". start:" << static_cast<void*>(addr) << " len:" << PrettySize(size);
@@ -4148,16 +3480,6 @@ void MarkCompact::UnregisterUffd(uint8_t* start, size_t len) {
   CHECK_EQ(ioctl(uffd_, UFFDIO_UNREGISTER, &range), 0)
       << "ioctl_userfaultfd: unregister failed: " << strerror(errno)
       << ". addr:" << static_cast<void*>(start) << " len:" << PrettySize(len);
-  // Due to an oversight in the kernel implementation of 'unregister', the
-  // waiting threads are woken up only for copy uffds. Therefore, for now, we
-  // have to explicitly wake up the threads in minor-fault case.
-  // TODO: The fix in the kernel is being worked on. Once the kernel version
-  // containing the fix is known, make it conditional on that as well.
-  if (minor_fault_initialized_) {
-    CHECK_EQ(ioctl(uffd_, UFFDIO_WAKE, &range), 0)
-        << "ioctl_userfaultfd: wake failed: " << strerror(errno)
-        << ". addr:" << static_cast<void*>(start) << " len:" << PrettySize(len);
-  }
 }
 
 void MarkCompact::CompactionPhase() {
@@ -4168,106 +3490,57 @@ void MarkCompact::CompactionPhase() {
     RecordFree(ObjectBytePair(freed_objects_, freed_bytes));
   }
 
-  if (CanCompactMovingSpaceWithMinorFault()) {
-    CompactMovingSpace<kMinorFaultMode>(/*page=*/nullptr);
-  } else {
-    CompactMovingSpace<kCopyMode>(compaction_buffers_map_.Begin());
-  }
+  CompactMovingSpace<kCopyMode>(compaction_buffers_map_.Begin());
 
   ProcessLinearAlloc();
 
-  if (use_uffd_sigbus_) {
-    // Set compaction-done bit so that no new mutator threads start compaction
-    // process in the SIGBUS handler.
-    SigbusCounterType count = sigbus_in_progress_count_.fetch_or(kSigbusCounterCompactionDoneMask,
-                                                                 std::memory_order_acq_rel);
+  auto wait_for_compaction_counter = [this](size_t idx) {
+    SigbusCounterType count = sigbus_in_progress_count_[idx].fetch_or(
+        kSigbusCounterCompactionDoneMask, std::memory_order_acq_rel);
     // Wait for SIGBUS handlers already in play.
     for (uint32_t i = 0; count > 0; i++) {
       BackOff(i);
-      count = sigbus_in_progress_count_.load(std::memory_order_acquire);
+      count = sigbus_in_progress_count_[idx].load(std::memory_order_acquire);
       count &= ~kSigbusCounterCompactionDoneMask;
     }
-  } else {
-    DCHECK(IsAlignedParam(conc_compaction_termination_page_, gPageSize));
-    // We will only iterate once if gKernelHasFaultRetry is true.
-    do {
-      // madvise the page so that we can get userfaults on it.
-      ZeroAndReleaseMemory(conc_compaction_termination_page_, gPageSize);
-      // The following load triggers 'special' userfaults. When received by the
-      // thread-pool workers, they will exit out of the compaction task. This fault
-      // happens because we madvised the page.
-      ForceRead(conc_compaction_termination_page_);
-    } while (thread_pool_counter_ > 0);
+  };
+  // Set compaction-done bit in the first counter to indicate that gc-thread
+  // is done compacting and mutators should stop incrementing this counter.
+  // Mutator should tolerate ENOENT after this. This helps avoid priority
+  // inversion in case mutators need to map zero-pages after compaction is
+  // finished but before gc-thread manages to unregister the spaces.
+  wait_for_compaction_counter(0);
+
+  // Unregister moving-space
+  size_t moving_space_size = bump_pointer_space_->Capacity();
+  size_t used_size = (moving_first_objs_count_ + black_page_count_) * gPageSize;
+  if (used_size > 0) {
+    UnregisterUffd(bump_pointer_space_->Begin(), used_size);
   }
   // Unregister linear-alloc spaces
   for (auto& data : linear_alloc_spaces_data_) {
     DCHECK_EQ(data.end_ - data.begin_, static_cast<ssize_t>(data.shadow_.Size()));
     UnregisterUffd(data.begin_, data.shadow_.Size());
-    // madvise linear-allocs's page-status array. Note that we don't need to
-    // madvise the shado-map as the pages from it were reclaimed in
-    // ProcessLinearAlloc() after arenas were mapped.
-    data.page_status_map_.MadviseDontNeedAndZero();
-    if (minor_fault_initialized_) {
-      DCHECK_EQ(mprotect(data.shadow_.Begin(), data.shadow_.Size(), PROT_NONE), 0)
-          << "mprotect failed: " << strerror(errno);
-    }
   }
 
-  // Make sure no mutator is reading from the from-space before unregistering
-  // userfaultfd from moving-space and then zapping from-space. The mutator
-  // and GC may race to set a page state to processing or further along. The two
-  // attempts are ordered. If the collector wins, then the mutator will see that
-  // and not access the from-space page. If the muator wins, then the
-  // compaction_in_progress_count_ increment by the mutator happens-before the test
-  // here, and we will not see a zero value until the mutator has completed.
-  for (uint32_t i = 0; compaction_in_progress_count_.load(std::memory_order_acquire) > 0; i++) {
-    BackOff(i);
-  }
-  size_t moving_space_size = bump_pointer_space_->Capacity();
-  size_t used_size = (moving_first_objs_count_ + black_page_count_) * gPageSize;
-  if (used_size > 0) {
-    UnregisterUffd(bump_pointer_space_->Begin(), used_size);
-  }
+  // Set compaction-done bit in the second counter to indicate that gc-thread
+  // is done unregistering the spaces and therefore mutators, if in SIGBUS,
+  // should return without attempting to map the faulted page. When the mutator
+  // will access the address again, it will succeed. Once this counter is 0,
+  // the gc-thread can safely initialize/madvise the data structures.
+  wait_for_compaction_counter(1);
+
   // Release all of the memory taken by moving-space's from-map
-  if (minor_fault_initialized_) {
-    if (IsValidFd(moving_from_space_fd_)) {
-      // A strange behavior is observed wherein between GC cycles the from-space'
-      // first page is accessed. But the memfd that is mapped on from-space, is
-      // used on to-space in next GC cycle, causing issues with userfaultfd as the
-      // page isn't missing. A possible reason for this could be prefetches. The
-      // mprotect ensures that such accesses don't succeed.
-      int ret = mprotect(from_space_begin_, moving_space_size, PROT_NONE);
-      CHECK_EQ(ret, 0) << "mprotect(PROT_NONE) for from-space failed: " << strerror(errno);
-      // madvise(MADV_REMOVE) needs PROT_WRITE. Use fallocate() instead, which
-      // does the same thing.
-      ret = fallocate(moving_from_space_fd_,
-                      FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
-                      /*offset=*/0,
-                      moving_space_size);
-      CHECK_EQ(ret, 0) << "fallocate for from-space failed: " << strerror(errno);
-    } else {
-      // We don't have a valid fd, so use madvise(MADV_REMOVE) instead. mprotect
-      // is not required in this case as we create fresh
-      // MAP_SHARED+MAP_ANONYMOUS mapping in each GC cycle.
-      int ret = madvise(from_space_begin_, moving_space_size, MADV_REMOVE);
-      CHECK_EQ(ret, 0) << "madvise(MADV_REMOVE) failed for from-space map:" << strerror(errno);
-    }
-  } else {
-    from_space_map_.MadviseDontNeedAndZero();
-  }
+  from_space_map_.MadviseDontNeedAndZero();
   // mprotect(PROT_NONE) all maps except to-space in debug-mode to catch any unexpected accesses.
-  if (shadow_to_space_map_.IsValid()) {
-    DCHECK_EQ(mprotect(shadow_to_space_map_.Begin(), shadow_to_space_map_.Size(), PROT_NONE), 0)
-        << "mprotect(PROT_NONE) for shadow-map failed:" << strerror(errno);
-  }
-  if (!IsValidFd(moving_from_space_fd_)) {
-    // The other case is already mprotected above.
-    DCHECK_EQ(mprotect(from_space_begin_, moving_space_size, PROT_NONE), 0)
-        << "mprotect(PROT_NONE) for from-space failed: " << strerror(errno);
-  }
+  DCHECK_EQ(mprotect(from_space_begin_, moving_space_size, PROT_NONE), 0)
+      << "mprotect(PROT_NONE) for from-space failed: " << strerror(errno);
 
-  if (!use_uffd_sigbus_) {
-    heap_->GetThreadPool()->StopWorkers(thread_running_gc_);
+  // madvise linear-allocs's page-status array. Note that we don't need to
+  // madvise the shado-map as the pages from it were reclaimed in
+  // ProcessLinearAlloc() after arenas were mapped.
+  for (auto& data : linear_alloc_spaces_data_) {
+    data.page_status_map_.MadviseDontNeedAndZero();
   }
 }
 
@@ -4775,7 +4048,9 @@ mirror::Object* MarkCompact::IsMarked(mirror::Object* obj) {
     }
     return (is_black || moving_space_bitmap_->Test(obj)) ? obj : nullptr;
   } else if (non_moving_space_bitmap_->HasAddress(obj)) {
-    return non_moving_space_bitmap_->Test(obj) ? obj : nullptr;
+    if (non_moving_space_bitmap_->Test(obj)) {
+      return obj;
+    }
   } else if (immune_spaces_.ContainsObject(obj)) {
     return obj;
   } else {
@@ -4785,7 +4060,9 @@ mirror::Object* MarkCompact::IsMarked(mirror::Object* obj) {
     accounting::LargeObjectBitmap* los_bitmap = heap_->GetLargeObjectsSpace()->GetMarkBitmap();
     if (los_bitmap->HasAddress(obj)) {
       DCHECK(IsAlignedParam(obj, space::LargeObjectSpace::ObjectAlignment()));
-      return los_bitmap->Test(obj) ? obj : nullptr;
+      if (los_bitmap->Test(obj)) {
+        return obj;
+      }
     } else {
       // The given obj is not in any of the known spaces, so return null. This could
       // happen for instance in interpreter caches wherein a concurrent updation
@@ -4795,6 +4072,7 @@ mirror::Object* MarkCompact::IsMarked(mirror::Object* obj) {
       return nullptr;
     }
   }
+  return marking_done_ && IsOnAllocStack(obj) ? obj : nullptr;
 }
 
 bool MarkCompact::IsNullOrMarkedHeapReference(mirror::HeapReference<mirror::Object>* obj,
@@ -4818,22 +4096,9 @@ void MarkCompact::FinishPhase() {
   GetCurrentIteration()->SetScannedBytes(bytes_scanned_);
   bool is_zygote = Runtime::Current()->IsZygote();
   compacting_ = false;
-  minor_fault_initialized_ = !is_zygote && uffd_minor_fault_supported_;
-  // Madvise compaction buffers. When using threaded implementation, skip the first page,
-  // which is used by the gc-thread for the next iteration. Otherwise, we get into a
-  // deadlock due to userfault on it in the next iteration. This page is not consuming any
-  // physical memory because we already madvised it above and then we triggered a read
-  // userfault, which maps a special zero-page.
-  if (use_uffd_sigbus_ || !minor_fault_initialized_ || !shadow_to_space_map_.IsValid() ||
-      shadow_to_space_map_.Size() < (moving_first_objs_count_ + black_page_count_) * gPageSize) {
-    size_t adjustment = use_uffd_sigbus_ ? 0 : gPageSize;
-    ZeroAndReleaseMemory(compaction_buffers_map_.Begin() + adjustment,
-                         compaction_buffers_map_.Size() - adjustment);
-  } else if (shadow_to_space_map_.Size() == bump_pointer_space_->Capacity()) {
-    // Now that we are going to use minor-faults from next GC cycle, we can
-    // unmap the buffers used by worker threads.
-    compaction_buffers_map_.SetSize(gPageSize);
-  }
+  marking_done_ = false;
+
+  ZeroAndReleaseMemory(compaction_buffers_map_.Begin(), compaction_buffers_map_.Size());
   info_map_.MadviseDontNeedAndZero();
   live_words_bitmap_->ClearBitmap();
   // TODO: We can clear this bitmap right before compaction pause. But in that
@@ -4843,7 +4108,6 @@ void MarkCompact::FinishPhase() {
   moving_space_bitmap_->Clear();
 
   if (UNLIKELY(is_zygote && IsValidFd(uffd_))) {
-    heap_->DeleteThreadPool();
     // This unregisters all ranges as a side-effect.
     close(uffd_);
     uffd_ = kFdUnused;
@@ -4858,20 +4122,13 @@ void MarkCompact::FinishPhase() {
       updated_roots_->clear();
     }
   }
-  class_after_obj_ordered_map_.clear();
+  class_after_obj_map_.clear();
   linear_alloc_arenas_.clear();
   {
     ReaderMutexLock mu(thread_running_gc_, *Locks::mutator_lock_);
     WriterMutexLock mu2(thread_running_gc_, *Locks::heap_bitmap_lock_);
     heap_->ClearMarkedObjects();
   }
-  std::swap(moving_to_space_fd_, moving_from_space_fd_);
-  if (IsValidFd(moving_to_space_fd_)) {
-    // Confirm that the memfd to be used on to-space in next GC cycle is empty.
-    struct stat buf;
-    DCHECK_EQ(fstat(moving_to_space_fd_, &buf), 0) << "fstat failed: " << strerror(errno);
-    DCHECK_EQ(buf.st_blocks, 0u);
-  }
   GcVisitedArenaPool* arena_pool =
       static_cast<GcVisitedArenaPool*>(Runtime::Current()->GetLinearAllocArenaPool());
   arena_pool->DeleteUnusedArenas();
diff --git a/runtime/gc/collector/mark_compact.h b/runtime/gc/collector/mark_compact.h
index dbadfd05d7..56a6a17196 100644
--- a/runtime/gc/collector/mark_compact.h
+++ b/runtime/gc/collector/mark_compact.h
@@ -21,7 +21,6 @@
 
 #include <map>
 #include <memory>
-#include <unordered_map>
 #include <unordered_set>
 
 #include "barrier.h"
@@ -60,10 +59,8 @@ class MarkCompact final : public GarbageCollector {
 
   static constexpr size_t kAlignment = kObjectAlignment;
   static constexpr int kCopyMode = -1;
-  static constexpr int kMinorFaultMode = -2;
   // Fake file descriptor for fall back mode (when uffd isn't available)
   static constexpr int kFallbackMode = -3;
-  static constexpr int kFdSharedAnon = -1;
   static constexpr int kFdUnused = -2;
 
   // Bitmask for the compaction-done bit in the sigbus_in_progress_count_.
@@ -82,8 +79,6 @@ class MarkCompact final : public GarbageCollector {
   // InitializePhase(). Therefore, it's safe to update without any memory ordering.
   bool IsCompacting() const { return compacting_; }
 
-  bool IsUsingSigbusFeature() const { return use_uffd_sigbus_; }
-
   // Called by SIGBUS handler. NO_THREAD_SAFETY_ANALYSIS for mutator-lock, which
   // is asserted in the function.
   bool SigbusHandler(siginfo_t* info) REQUIRES(!lock_) NO_THREAD_SAFETY_ANALYSIS;
@@ -260,6 +255,8 @@ class MarkCompact final : public GarbageCollector {
                                              + from_space_slide_diff_);
   }
 
+  inline bool IsOnAllocStack(mirror::Object* ref)
+      REQUIRES_SHARED(Locks::mutator_lock_, Locks::heap_bitmap_lock_);
   // Verifies that that given object reference refers to a valid object.
   // Otherwise fataly dumps logs, including those from callback.
   template <typename Callback>
@@ -486,38 +483,23 @@ class MarkCompact final : public GarbageCollector {
   void KernelPreparation();
   // Called by KernelPreparation() for every memory range being prepared for
   // userfaultfd registration.
-  void KernelPrepareRangeForUffd(uint8_t* to_addr,
-                                 uint8_t* from_addr,
-                                 size_t map_size,
-                                 int fd,
-                                 uint8_t* shadow_addr = nullptr);
+  void KernelPrepareRangeForUffd(uint8_t* to_addr, uint8_t* from_addr, size_t map_size);
 
-  void RegisterUffd(void* addr, size_t size, int mode);
+  void RegisterUffd(void* addr, size_t size);
   void UnregisterUffd(uint8_t* start, size_t len);
 
-  // Called by thread-pool workers to read uffd_ and process fault events.
-  template <int kMode>
-  void ConcurrentCompaction(uint8_t* buf) REQUIRES_SHARED(Locks::mutator_lock_);
-  // Called by thread-pool workers to compact and copy/map the fault page in
-  // moving space.
-  template <int kMode>
+  // Called by SIGBUS handler to compact and copy/map the fault page in moving space.
   void ConcurrentlyProcessMovingPage(uint8_t* fault_page,
                                      uint8_t* buf,
-                                     size_t nr_moving_space_used_pages)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  // Called by thread-pool workers to process and copy/map the fault page in
-  // linear-alloc.
-  template <int kMode>
-  void ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool is_minor_fault)
+                                     size_t nr_moving_space_used_pages,
+                                     bool tolerate_enoent) REQUIRES_SHARED(Locks::mutator_lock_);
+  // Called by SIGBUS handler to process and copy/map the fault page in linear-alloc.
+  void ConcurrentlyProcessLinearAllocPage(uint8_t* fault_page, bool tolerate_enoent)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Process concurrently all the pages in linear-alloc. Called by gc-thread.
   void ProcessLinearAlloc() REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Returns true if the moving space can be compacted using uffd's minor-fault
-  // feature.
-  bool CanCompactMovingSpaceWithMinorFault();
-
   // Does the following:
   // 1. Checks the status of to-space pages in [cur_page_idx,
   //    last_checked_reclaim_page_idx_) range to see whether the corresponding
@@ -530,17 +512,6 @@ class MarkCompact final : public GarbageCollector {
   bool FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_idx_for_mapping)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Maps processed pages (from moving space and linear-alloc) for uffd's
-  // minor-fault feature. We try to 'claim' all processed (and unmapped) pages
-  // contiguous to 'to_space_start'.
-  // kFirstPageMapping indicates if the first page is already claimed or not. It
-  // also indicates that the ioctl must succeed in mapping the first page.
-  template <bool kFirstPageMapping>
-  void MapProcessedPages(uint8_t* to_space_start,
-                         Atomic<PageState>* state_arr,
-                         size_t arr_idx,
-                         size_t arr_len) REQUIRES_SHARED(Locks::mutator_lock_);
-
   // Maps moving space pages in [start_idx, arr_len) range. It fetches the page
   // address containing the compacted content from moving_pages_status_ array.
   // 'from_fault' is true when called from userfault (sigbus handler).
@@ -550,7 +521,8 @@ class MarkCompact final : public GarbageCollector {
   size_t MapMovingSpacePages(size_t start_idx,
                              size_t arr_len,
                              bool from_fault,
-                             bool return_on_contention) REQUIRES_SHARED(Locks::mutator_lock_);
+                             bool return_on_contention,
+                             bool tolerate_enoent) REQUIRES_SHARED(Locks::mutator_lock_);
 
   bool IsValidFd(int fd) const { return fd >= 0; }
 
@@ -567,12 +539,6 @@ class MarkCompact final : public GarbageCollector {
   ALWAYS_INLINE void UpdateClassAfterObjectMap(mirror::Object* obj)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Updates 'class_after_obj_map_' map by updating the keys (class) with its
-  // highest-address super-class (obtained from 'super_class_after_class_map_'),
-  // if there is any. This is to ensure we don't free from-space pages before
-  // the lowest-address obj is compacted.
-  void UpdateClassAfterObjMap();
-
   void MarkZygoteLargeObjects() REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(Locks::heap_bitmap_lock_);
 
@@ -588,7 +554,8 @@ class MarkCompact final : public GarbageCollector {
   // function also uses thread's priority to decide how long we delay before
   // forcing the ioctl operation. If ioctl returns EEXIST, then also function
   // returns. Returns number of bytes (multiple of page-size) mapped.
-  size_t CopyIoctl(void* dst, void* buffer, size_t length, bool return_on_contention);
+  size_t CopyIoctl(
+      void* dst, void* buffer, size_t length, bool return_on_contention, bool tolerate_enoent);
 
   // Called after updating linear-alloc page(s) to map the page. It first
   // updates the state of the pages to kProcessedAndMapping and after ioctl to
@@ -600,7 +567,8 @@ class MarkCompact final : public GarbageCollector {
                                   Atomic<PageState>* state,
                                   size_t length,
                                   bool free_pages,
-                                  bool single_ioctl);
+                                  bool single_ioctl,
+                                  bool tolerate_enoent);
   // Called for clamping of 'info_map_' and other GC data structures, which are
   // small and/or in >4GB address space. There is no real benefit of clamping
   // them synchronously during app forking. It clamps only if clamp_info_map_status_
@@ -639,7 +607,6 @@ class MarkCompact final : public GarbageCollector {
   // that double updation doesn't happen in the first place.
   std::unique_ptr<std::unordered_set<void*>> updated_roots_ GUARDED_BY(lock_);
   MemMap from_space_map_;
-  MemMap shadow_to_space_map_;
   // Any array of live-bytes in logical chunks of kOffsetChunkSize size
   // in the 'to-be-compacted' space.
   MemMap info_map_;
@@ -664,72 +631,33 @@ class MarkCompact final : public GarbageCollector {
   // have more than one, but this is to be ready for the worst case.
   class LinearAllocSpaceData {
    public:
-    LinearAllocSpaceData(MemMap&& shadow,
-                         MemMap&& page_status_map,
-                         uint8_t* begin,
-                         uint8_t* end,
-                         bool already_shared)
+    LinearAllocSpaceData(MemMap&& shadow, MemMap&& page_status_map, uint8_t* begin, uint8_t* end)
         : shadow_(std::move(shadow)),
           page_status_map_(std::move(page_status_map)),
           begin_(begin),
-          end_(end),
-          already_shared_(already_shared) {}
+          end_(end) {}
 
     MemMap shadow_;
     MemMap page_status_map_;
     uint8_t* begin_;
     uint8_t* end_;
-    // Indicates if the linear-alloc is already MAP_SHARED.
-    bool already_shared_;
   };
-
   std::vector<LinearAllocSpaceData> linear_alloc_spaces_data_;
 
-  class ObjReferenceHash {
-   public:
-    uint32_t operator()(const ObjReference& ref) const {
-      return ref.AsVRegValue() >> kObjectAlignmentShift;
-    }
-  };
-
-  class ObjReferenceEqualFn {
-   public:
-    bool operator()(const ObjReference& a, const ObjReference& b) const {
-      return a.AsMirrorPtr() == b.AsMirrorPtr();
-    }
-  };
-
   class LessByObjReference {
    public:
     bool operator()(const ObjReference& a, const ObjReference& b) const {
       return std::less<mirror::Object*>{}(a.AsMirrorPtr(), b.AsMirrorPtr());
     }
   };
-
-  // Data structures used to track objects whose layout information is stored in later
-  // allocated classes (at higher addresses). We must be careful not to free the
-  // corresponding from-space pages prematurely.
-  using ObjObjOrderedMap = std::map<ObjReference, ObjReference, LessByObjReference>;
-  using ObjObjUnorderedMap =
-      std::unordered_map<ObjReference, ObjReference, ObjReferenceHash, ObjReferenceEqualFn>;
-  // Unordered map of <K, S> such that the class K (in moving space) has kClassWalkSuper
-  // in reference bitmap and S is its highest address super class.
-  ObjObjUnorderedMap super_class_after_class_hash_map_;
-  // Unordered map of <K, V> such that the class K (in moving space) is after its objects
-  // or would require iterating super-class hierarchy when visiting references. And V is
-  // its lowest address object (in moving space).
-  ObjObjUnorderedMap class_after_obj_hash_map_;
-  // Ordered map constructed before starting compaction using the above two maps. Key is a
-  // class (or super-class) which is higher in address order than some of its object(s) and
-  // value is the corresponding object with lowest address.
-  ObjObjOrderedMap class_after_obj_ordered_map_;
+  using ClassAfterObjectMap = std::map<ObjReference, ObjReference, LessByObjReference>;
+  // map of <K, V> such that the class K (in moving space) is after its
+  // objects, and its object V is the lowest object (in moving space).
+  ClassAfterObjectMap class_after_obj_map_;
   // Since the compaction is done in reverse, we use a reverse iterator. It is maintained
   // either at the pair whose class is lower than the first page to be freed, or at the
   // pair whose object is not yet compacted.
-  ObjObjOrderedMap::const_reverse_iterator class_after_obj_iter_;
-  // Cached reference to the last class which has kClassWalkSuper in reference
-  // bitmap but has all its super classes lower address order than itself.
-  mirror::Class* walk_super_class_cache_;
+  ClassAfterObjectMap::const_reverse_iterator class_after_obj_iter_;
   // Used by FreeFromSpacePages() for maintaining markers in the moving space for
   // how far the pages have been reclaimed (madvised) and checked.
   //
@@ -830,50 +758,33 @@ class MarkCompact final : public GarbageCollector {
   // in MarkingPause(). It reaches the correct count only once the marking phase
   // is completed.
   int32_t freed_objects_;
-  // memfds for moving space for using userfaultfd's minor-fault feature.
-  // Initialized to kFdUnused to indicate that mmap should be MAP_PRIVATE in
-  // KernelPrepareRange().
-  int moving_to_space_fd_;
-  int moving_from_space_fd_;
   // Userfault file descriptor, accessed only by the GC itself.
   // kFallbackMode value indicates that we are in the fallback mode.
   int uffd_;
-  // Number of mutator-threads currently executing SIGBUS handler. When the
-  // GC-thread is done with compaction, it set the most significant bit to
-  // indicate that. Mutator threads check for the flag when incrementing in the
-  // handler.
-  std::atomic<SigbusCounterType> sigbus_in_progress_count_;
-  // Number of mutator-threads/uffd-workers working on moving-space page. It
-  // must be 0 before gc-thread can unregister the space after it's done
-  // sequentially compacting all pages of the space.
-  std::atomic<uint16_t> compaction_in_progress_count_;
+  // Counters to synchronize mutator threads and gc-thread at the end of
+  // compaction. Counter 0 represents the number of mutators still working on
+  // moving space pages which started before gc-thread finished compacting pages,
+  // whereas the counter 1 represents those which started afterwards but
+  // before unregistering the space from uffd. Once counter 1 reaches 0, the
+  // gc-thread madvises spaces and data structures like page-status array.
+  // Both the counters are set to 0 before compaction begins. They are or'ed
+  // with kSigbusCounterCompactionDoneMask one-by-one by gc-thread after
+  // compaction to communicate the status to future mutators.
+  std::atomic<SigbusCounterType> sigbus_in_progress_count_[2];
   // When using SIGBUS feature, this counter is used by mutators to claim a page
   // out of compaction buffers to be used for the entire compaction cycle.
   std::atomic<uint16_t> compaction_buffer_counter_;
-  // Used to exit from compaction loop at the end of concurrent compaction
-  uint8_t thread_pool_counter_;
   // True while compacting.
   bool compacting_;
+  // Set to true in MarkingPause() to indicate when allocation_stack_ should be
+  // checked in IsMarked() for black allocations.
+  bool marking_done_;
   // Flag indicating whether one-time uffd initialization has been done. It will
   // be false on the first GC for non-zygote processes, and always for zygote.
   // Its purpose is to minimize the userfaultfd overhead to the minimal in
   // Heap::PostForkChildAction() as it's invoked in app startup path. With
   // this, we register the compaction-termination page on the first GC.
   bool uffd_initialized_;
-  // Flag indicating if userfaultfd supports minor-faults. Set appropriately in
-  // CreateUserfaultfd(), where we get this information from the kernel.
-  const bool uffd_minor_fault_supported_;
-  // Flag indicating if we should use sigbus signals instead of threads to
-  // handle userfaults.
-  const bool use_uffd_sigbus_;
-  // For non-zygote processes this flag indicates if the spaces are ready to
-  // start using userfaultfd's minor-fault feature. This initialization involves
-  // starting to use shmem (memfd_create) for the userfaultfd protected spaces.
-  bool minor_fault_initialized_;
-  // Set to true when linear-alloc can start mapping with MAP_SHARED. Set on
-  // non-zygote processes during first GC, which sets up everyting for using
-  // minor-fault from next GC.
-  bool map_linear_alloc_shared_;
   // Clamping statue of `info_map_`. Initialized with 'NotDone'. Once heap is
   // clamped but info_map_ is delayed, we set it to 'Pending'. Once 'info_map_'
   // is also clamped, then we set it to 'Finished'.
@@ -892,7 +803,6 @@ class MarkCompact final : public GarbageCollector {
   class ClassLoaderRootsUpdater;
   class LinearAllocPageUpdater;
   class ImmuneSpaceUpdateObjVisitor;
-  class ConcurrentCompactionGcTask;
 
   DISALLOW_IMPLICIT_CONSTRUCTORS(MarkCompact);
 };
diff --git a/runtime/gc/collector/mark_sweep.cc b/runtime/gc/collector/mark_sweep.cc
index 515f031964..918e97fb96 100644
--- a/runtime/gc/collector/mark_sweep.cc
+++ b/runtime/gc/collector/mark_sweep.cc
@@ -53,7 +53,6 @@ namespace collector {
 // Performance options.
 static constexpr bool kUseRecursiveMark = false;
 static constexpr bool kUseMarkStackPrefetch = true;
-static constexpr size_t kSweepArrayChunkFreeSize = 1024;
 static constexpr bool kPreCleanCards = true;
 
 // Parallelism options.
@@ -93,25 +92,14 @@ void MarkSweep::BindBitmaps() {
 
 MarkSweep::MarkSweep(Heap* heap, bool is_concurrent, const std::string& name_prefix)
     : GarbageCollector(heap,
-                       name_prefix +
-                       (is_concurrent ? "concurrent mark sweep": "mark sweep")),
+                       name_prefix + (is_concurrent ? "concurrent mark sweep" : "mark sweep")),
       current_space_bitmap_(nullptr),
       mark_bitmap_(nullptr),
       mark_stack_(nullptr),
       gc_barrier_(new Barrier(0)),
       mark_stack_lock_("mark sweep mark stack lock", kMarkSweepMarkStackLock),
       is_concurrent_(is_concurrent),
-      live_stack_freeze_size_(0) {
-  std::string error_msg;
-  sweep_array_free_buffer_mem_map_ = MemMap::MapAnonymous(
-      "mark sweep sweep array free buffer",
-      RoundUp(kSweepArrayChunkFreeSize * sizeof(mirror::Object*), gPageSize),
-      PROT_READ | PROT_WRITE,
-      /*low_4gb=*/ false,
-      &error_msg);
-  CHECK(sweep_array_free_buffer_mem_map_.IsValid())
-      << "Couldn't allocate sweep array free buffer: " << error_msg;
-}
+      live_stack_freeze_size_(0) {}
 
 void MarkSweep::InitializePhase() {
   TimingLogger::ScopedTiming t(__FUNCTION__, GetTimings());
@@ -1204,17 +1192,8 @@ void MarkSweep::MarkRootsCheckpoint(Thread* self,
   Locks::heap_bitmap_lock_->ExclusiveLock(self);
 }
 
-void MarkSweep::SweepArray(accounting::ObjectStack* allocations, bool swap_bitmaps) {
+void MarkSweep::SweepArray(accounting::ObjectStack* obj_arr, bool swap_bitmaps) {
   TimingLogger::ScopedTiming t(__FUNCTION__, GetTimings());
-  Thread* self = Thread::Current();
-  mirror::Object** chunk_free_buffer = reinterpret_cast<mirror::Object**>(
-      sweep_array_free_buffer_mem_map_.BaseBegin());
-  size_t chunk_free_pos = 0;
-  ObjectBytePair freed;
-  ObjectBytePair freed_los;
-  // How many objects are left in the array, modified after each space is swept.
-  StackReference<mirror::Object>* objects = allocations->Begin();
-  size_t count = allocations->Size();
   // Change the order to ensure that the non-moving space last swept as an optimization.
   std::vector<space::ContinuousSpace*> sweep_spaces;
   space::ContinuousSpace* non_moving_space = nullptr;
@@ -1234,74 +1213,7 @@ void MarkSweep::SweepArray(accounting::ObjectStack* allocations, bool swap_bitma
   if (non_moving_space != nullptr) {
     sweep_spaces.push_back(non_moving_space);
   }
-  // Start by sweeping the continuous spaces.
-  for (space::ContinuousSpace* space : sweep_spaces) {
-    space::AllocSpace* alloc_space = space->AsAllocSpace();
-    accounting::ContinuousSpaceBitmap* live_bitmap = space->GetLiveBitmap();
-    accounting::ContinuousSpaceBitmap* mark_bitmap = space->GetMarkBitmap();
-    if (swap_bitmaps) {
-      std::swap(live_bitmap, mark_bitmap);
-    }
-    StackReference<mirror::Object>* out = objects;
-    for (size_t i = 0; i < count; ++i) {
-      mirror::Object* const obj = objects[i].AsMirrorPtr();
-      if (kUseThreadLocalAllocationStack && obj == nullptr) {
-        continue;
-      }
-      if (space->HasAddress(obj)) {
-        // This object is in the space, remove it from the array and add it to the sweep buffer
-        // if needed.
-        if (!mark_bitmap->Test(obj)) {
-          if (chunk_free_pos >= kSweepArrayChunkFreeSize) {
-            TimingLogger::ScopedTiming t2("FreeList", GetTimings());
-            freed.objects += chunk_free_pos;
-            freed.bytes += alloc_space->FreeList(self, chunk_free_pos, chunk_free_buffer);
-            chunk_free_pos = 0;
-          }
-          chunk_free_buffer[chunk_free_pos++] = obj;
-        }
-      } else {
-        (out++)->Assign(obj);
-      }
-    }
-    if (chunk_free_pos > 0) {
-      TimingLogger::ScopedTiming t2("FreeList", GetTimings());
-      freed.objects += chunk_free_pos;
-      freed.bytes += alloc_space->FreeList(self, chunk_free_pos, chunk_free_buffer);
-      chunk_free_pos = 0;
-    }
-    // All of the references which space contained are no longer in the allocation stack, update
-    // the count.
-    count = out - objects;
-  }
-  // Handle the large object space.
-  space::LargeObjectSpace* large_object_space = GetHeap()->GetLargeObjectsSpace();
-  if (large_object_space != nullptr) {
-    accounting::LargeObjectBitmap* large_live_objects = large_object_space->GetLiveBitmap();
-    accounting::LargeObjectBitmap* large_mark_objects = large_object_space->GetMarkBitmap();
-    if (swap_bitmaps) {
-      std::swap(large_live_objects, large_mark_objects);
-    }
-    for (size_t i = 0; i < count; ++i) {
-      mirror::Object* const obj = objects[i].AsMirrorPtr();
-      // Handle large objects.
-      if (kUseThreadLocalAllocationStack && obj == nullptr) {
-        continue;
-      }
-      if (!large_mark_objects->Test(obj)) {
-        ++freed_los.objects;
-        freed_los.bytes += large_object_space->Free(self, obj);
-      }
-    }
-  }
-  {
-    TimingLogger::ScopedTiming t2("RecordFree", GetTimings());
-    RecordFree(freed);
-    RecordFreeLOS(freed_los);
-    t2.NewTiming("ResetStack");
-    allocations->Reset();
-  }
-  sweep_array_free_buffer_mem_map_.MadviseDontNeedAndZero();
+  GarbageCollector::SweepArray(obj_arr, swap_bitmaps, &sweep_spaces);
 }
 
 void MarkSweep::Sweep(bool swap_bitmaps) {
diff --git a/runtime/gc/collector/mark_sweep.h b/runtime/gc/collector/mark_sweep.h
index 2a628a40fe..b022c7bcf0 100644
--- a/runtime/gc/collector/mark_sweep.h
+++ b/runtime/gc/collector/mark_sweep.h
@@ -41,16 +41,9 @@ class Thread;
 enum VisitRootFlags : uint8_t;
 
 namespace gc {
-
 class Heap;
 
-namespace accounting {
-template<typename T> class AtomicStack;
-using ObjectStack = AtomicStack<mirror::Object>;
-}  // namespace accounting
-
 namespace collector {
-
 class MarkSweep : public GarbageCollector {
  public:
   MarkSweep(Heap* heap, bool is_concurrent, const std::string& name_prefix = "");
@@ -153,10 +146,8 @@ class MarkSweep : public GarbageCollector {
   // Sweeps unmarked objects to complete the garbage collection.
   void SweepLargeObjects(bool swap_bitmaps) REQUIRES(Locks::heap_bitmap_lock_);
 
-  // Sweep only pointers within an array. WARNING: Trashes objects.
-  void SweepArray(accounting::ObjectStack* allocation_stack_, bool swap_bitmaps)
-      REQUIRES(Locks::heap_bitmap_lock_)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+  void SweepArray(accounting::ObjectStack* obj_arr, bool swap_bitmaps)
+      REQUIRES(Locks::heap_bitmap_lock_) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Blackens an object.
   void ScanObject(mirror::Object* obj)
@@ -350,11 +341,6 @@ class MarkSweep : public GarbageCollector {
   // Verification.
   size_t live_stack_freeze_size_;
 
-  // Sweep array free buffer, used to sweep the spaces based on an array more
-  // efficiently, by recording dead objects to be freed in batches (see
-  // MarkSweep::SweepArray).
-  MemMap sweep_array_free_buffer_mem_map_;
-
  private:
   class CardScanTask;
   class CheckpointMarkThreadRoots;
diff --git a/runtime/gc/collector/semi_space.h b/runtime/gc/collector/semi_space.h
index b6d98ce84d..e6d1266e55 100644
--- a/runtime/gc/collector/semi_space.h
+++ b/runtime/gc/collector/semi_space.h
@@ -39,21 +39,14 @@ class Object;
 }  // namespace mirror
 
 namespace gc {
-
 class Heap;
 
-namespace accounting {
-template <typename T> class AtomicStack;
-using ObjectStack = AtomicStack<mirror::Object>;
-}  // namespace accounting
-
 namespace space {
 class ContinuousMemMapAllocSpace;
 class ContinuousSpace;
 }  // namespace space
 
 namespace collector {
-
 class SemiSpace : public GarbageCollector {
  public:
   // If true, use remembered sets in the generational mode.
diff --git a/runtime/gc/heap-inl.h b/runtime/gc/heap-inl.h
index 5d6e149b98..b309dfad06 100644
--- a/runtime/gc/heap-inl.h
+++ b/runtime/gc/heap-inl.h
@@ -250,6 +250,8 @@ inline mirror::Object* Heap::AllocObjectWithAllocator(Thread* self,
   }
   if (AllocatorHasAllocationStack(allocator)) {
     PushOnAllocationStack(self, &obj);
+    // Ensure that the push to allocation stack is done before the object is published.
+    std::atomic_thread_fence(std::memory_order_release);
   }
   if (kInstrumented) {
     if (gc_stress_mode_) {
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index 07340bd7d3..8f3189f6e5 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -2016,15 +2016,16 @@ mirror::Object* Heap::AllocateInternalWithGc(Thread* self,
   // then there is no hope, so we throw OOME.
   collector::GcType tried_type = next_gc_type_;
   if (last_gc < tried_type) {
-    const bool gc_ran = PERFORM_SUSPENDING_OPERATION(
-        CollectGarbageInternal(tried_type, kGcCauseForAlloc, false, starting_gc_num + 1)
-        != collector::kGcTypeNone);
+    VLOG(gc) << "Starting a blocking GC " << kGcCauseForAlloc;
+    PERFORM_SUSPENDING_OPERATION(
+        CollectGarbageInternal(tried_type, kGcCauseForAlloc, false, starting_gc_num + 1));
 
     if ((was_default_allocator && allocator != GetCurrentAllocator()) ||
         (!instrumented && EntrypointsInstrumented())) {
       return nullptr;
     }
-    if (gc_ran && have_reclaimed_enough()) {
+    // Check this even if we didn't actually run a GC; if we didn't someone else probably did.
+    if (have_reclaimed_enough()) {
       mirror::Object* ptr = TryToAllocate<true, false>(self, allocator,
                                                        alloc_size, bytes_allocated,
                                                        usable_size, bytes_tl_bulk_allocated);
@@ -2053,11 +2054,22 @@ mirror::Object* Heap::AllocateInternalWithGc(Thread* self,
   // "GC thrashing", or
   // (b) GC was sufficiently productive (reclaimed min_freed_to_continue bytes) AND allowed us to
   // satisfy the allocation request.
+  bool gc_ran;
+  int gc_attempts = 0;
+  // A requested GC can fail to run because either someone else beat us to it, or because we can't
+  // run a GC in this state. In the latter case, we return quickly. Just try a small number of
+  // times.
+  static constexpr int kMaxGcAttempts = 5;
   do {
     bytes_freed_before = GetBytesFreedEver();
     pre_oome_gc_count_.fetch_add(1, std::memory_order_relaxed);
-    PERFORM_SUSPENDING_OPERATION(
-        CollectGarbageInternal(gc_plan_.back(), kGcCauseForAlloc, true, GC_NUM_ANY));
+    // TODO(b/353333767): Do this only if nobody else beats us to it. If we're having trouble
+    // allocating, probably other threads are in the same boat.
+    starting_gc_num = GetCurrentGcNum();
+    gc_ran = PERFORM_SUSPENDING_OPERATION(
+        CollectGarbageInternal(gc_plan_.back(), kGcCauseForAlloc, true, starting_gc_num + 1) !=
+        collector::kGcTypeNone);
+    ++gc_attempts;
     if ((was_default_allocator && allocator != GetCurrentAllocator()) ||
         (!instrumented && EntrypointsInstrumented())) {
       return nullptr;
@@ -2108,7 +2120,8 @@ mirror::Object* Heap::AllocateInternalWithGc(Thread* self,
     // issue, and there is no other thread allocating, GCs will quickly become unsuccessful, and we
     // will stop then. If another thread is allocating aggressively, this may go on for a while,
     // but we are still making progress somewhere.
-  } while (GetBytesFreedEver() - bytes_freed_before > min_freed_to_continue);
+  } while ((!gc_ran && gc_attempts < kMaxGcAttempts) ||
+           GetBytesFreedEver() - bytes_freed_before > min_freed_to_continue);
 #undef PERFORM_SUSPENDING_OPERATION
   // Throw an OOM error.
   {
@@ -3651,53 +3664,52 @@ void Heap::RosAllocVerification(TimingLogger* timings, const char* name) {
 collector::GcType Heap::WaitForGcToComplete(GcCause cause, Thread* self) {
   ScopedThreadStateChange tsc(self, ThreadState::kWaitingForGcToComplete);
   MutexLock mu(self, *gc_complete_lock_);
-  return WaitForGcToCompleteLocked(cause, self);
+  return WaitForGcToCompleteLocked(cause, self, /* only_one= */ true);
 }
 
-collector::GcType Heap::WaitForGcToCompleteLocked(GcCause cause, Thread* self) {
+collector::GcType Heap::WaitForGcToCompleteLocked(GcCause cause, Thread* self, bool only_one) {
   gc_complete_cond_->CheckSafeToWait(self);
   collector::GcType last_gc_type = collector::kGcTypeNone;
   GcCause last_gc_cause = kGcCauseNone;
-  uint64_t wait_start = NanoTime();
-  while (collector_type_running_ != kCollectorTypeNone) {
-    if (!task_processor_->IsRunningThread(self)) {
-      // The current thread is about to wait for a currently running
-      // collection to finish. If the waiting thread is not the heap
-      // task daemon thread, the currently running collection is
-      // considered as a blocking GC.
-      running_collection_is_blocking_ = true;
-      VLOG(gc) << "Waiting for a blocking GC " << cause;
-    }
-    SCOPED_TRACE << "GC: Wait For Completion " << cause;
-    // We must wait, change thread state then sleep on gc_complete_cond_;
-    gc_complete_cond_->Wait(self);
-    last_gc_type = last_gc_type_;
-    last_gc_cause = last_gc_cause_;
-  }
-  uint64_t wait_time = NanoTime() - wait_start;
-  total_wait_time_ += wait_time;
-  if (wait_time > long_pause_log_threshold_) {
-    LOG(INFO) << "WaitForGcToComplete blocked " << cause << " on " << last_gc_cause << " for "
-              << PrettyDuration(wait_time);
+  if (collector_type_running_ != kCollectorTypeNone) {
+    uint64_t wait_start = NanoTime();
+    uint32_t starting_gc_num = GetCurrentGcNum();
+    while (collector_type_running_ != kCollectorTypeNone &&
+           (!only_one || GCNumberLt(GetCurrentGcNum(), starting_gc_num + 1))) {
+      if (!task_processor_->IsRunningThread(self)) {
+        // The current thread is about to wait for a currently running
+        // collection to finish. If the waiting thread is not the heap
+        // task daemon thread, the currently running collection is
+        // considered as a blocking GC.
+        running_collection_is_blocking_ = true;
+        VLOG(gc) << "Waiting for a blocking GC " << cause;
+      }
+      SCOPED_TRACE << "GC: Wait For Completion " << cause;
+      // We must wait, change thread state then sleep on gc_complete_cond_;
+      gc_complete_cond_->Wait(self);
+      last_gc_type = last_gc_type_;
+      last_gc_cause = last_gc_cause_;
+    }
+    uint64_t wait_time = NanoTime() - wait_start;
+    total_wait_time_ += wait_time;
+    if (wait_time > long_pause_log_threshold_) {
+      LOG(INFO) << "WaitForGcToComplete blocked " << cause << " on " << last_gc_cause << " for "
+                << PrettyDuration(wait_time);
+    }
   }
   if (!task_processor_->IsRunningThread(self)) {
     // The current thread is about to run a collection. If the thread
     // is not the heap task daemon thread, it's considered as a
     // blocking GC (i.e., blocking itself).
     running_collection_is_blocking_ = true;
-    // Don't log fake "GC" types that are only used for debugger or hidden APIs. If we log these,
-    // it results in log spam. kGcCauseExplicit is already logged in LogGC, so avoid it here too.
-    if (cause == kGcCauseForAlloc ||
-        cause == kGcCauseDisableMovingGc) {
-      VLOG(gc) << "Starting a blocking GC " << cause;
-    }
   }
+  DCHECK(only_one || collector_type_running_ == kCollectorTypeNone);
   return last_gc_type;
 }
 
 void Heap::DumpForSigQuit(std::ostream& os) {
   os << "Heap: " << GetPercentFree() << "% free, " << PrettySize(GetBytesAllocated()) << "/"
-     << PrettySize(GetTotalMemory());
+     << PrettySize(GetTotalMemory()) << "\n";
   {
     os << "Image spaces:\n";
     ScopedObjectAccess soa(Thread::Current());
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index c51fcc54e0..58a73af74b 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -129,7 +129,7 @@ enum HomogeneousSpaceCompactResult {
 static constexpr bool kUseRosAlloc = true;
 
 // If true, use thread-local allocation stack.
-static constexpr bool kUseThreadLocalAllocationStack = true;
+static constexpr bool kUseThreadLocalAllocationStack = false;
 
 class Heap {
  public:
@@ -484,7 +484,8 @@ class Heap {
 
   // Blocks the caller until the garbage collector becomes idle and returns the type of GC we
   // waited for. Only waits for running collections, ignoring a requested but unstarted GC. Only
-  // heuristic, since a new GC may have started by the time we return.
+  // heuristic, since a new GC may have started by the time we return. However, if we hold the
+  // mutator lock, even in shared mode, a new GC can't get very far, so long as we keep it.
   EXPORT collector::GcType WaitForGcToComplete(GcCause cause, Thread* self)
       REQUIRES(!*gc_complete_lock_);
 
@@ -1166,8 +1167,9 @@ class Heap {
                                                bool grow);
 
   // Blocks the caller until the garbage collector becomes idle and returns the type of GC we
-  // waited for.
-  collector::GcType WaitForGcToCompleteLocked(GcCause cause, Thread* self)
+  // waited for. If only_one is true, we only wait for the currently running GC, and may return
+  // while a new GC is again running.
+  collector::GcType WaitForGcToCompleteLocked(GcCause cause, Thread* self, bool only_one = false)
       REQUIRES(gc_complete_lock_);
 
   void RequestCollectorTransition(CollectorType desired_collector_type, uint64_t delta_time)
@@ -1253,7 +1255,7 @@ class Heap {
   void PushOnAllocationStack(Thread* self, ObjPtr<mirror::Object>* obj)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!*gc_complete_lock_, !*pending_task_lock_, !process_state_update_lock_);
-  void PushOnAllocationStackWithInternalGC(Thread* self, ObjPtr<mirror::Object>* obj)
+  EXPORT void PushOnAllocationStackWithInternalGC(Thread* self, ObjPtr<mirror::Object>* obj)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!*gc_complete_lock_, !*pending_task_lock_, !process_state_update_lock_);
   EXPORT void PushOnThreadLocalAllocationStackWithInternalGC(Thread* thread,
diff --git a/runtime/gc/space/image_space.cc b/runtime/gc/space/image_space.cc
index 4333d08452..b970b12978 100644
--- a/runtime/gc/space/image_space.cc
+++ b/runtime/gc/space/image_space.cc
@@ -1405,14 +1405,20 @@ class ImageSpace::Loader {
               method.SetImtConflictTable(new_table, kPointerSize);
             }
           }
-          const void* old_code = method.GetEntryPointFromQuickCompiledCodePtrSize(kPointerSize);
-          const void* new_code = forward_code(old_code);
-          if (old_code != new_code) {
-            method.SetEntryPointFromQuickCompiledCodePtrSize(new_code, kPointerSize);
-          }
         } else {
           patch_object_visitor.PatchGcRoot(&method.DeclaringClassRoot());
-          method.UpdateEntrypoints(forward_code, kPointerSize);
+          if (method.IsNative()) {
+            const void* old_native_code = method.GetEntryPointFromJniPtrSize(kPointerSize);
+            const void* new_native_code = forward_code(old_native_code);
+            if (old_native_code != new_native_code) {
+              method.SetEntryPointFromJniPtrSize(new_native_code, kPointerSize);
+            }
+          }
+        }
+        const void* old_code = method.GetEntryPointFromQuickCompiledCodePtrSize(kPointerSize);
+        const void* new_code = forward_code(old_code);
+        if (old_code != new_code) {
+          method.SetEntryPointFromQuickCompiledCode(new_code);
         }
       }, target_base, kPointerSize);
     }
diff --git a/runtime/gc_root.h b/runtime/gc_root.h
index da9d3af6cb..ea85ca7de8 100644
--- a/runtime/gc_root.h
+++ b/runtime/gc_root.h
@@ -183,6 +183,10 @@ class GcRootSource {
   DISALLOW_COPY_AND_ASSIGN(GcRootSource);
 };
 
+// A small CompressedReference wrapper class that makes it harder to forget about read barriers.
+// Used for references that are roots for an object graph, whether or not they are actually traced
+// from. Requires an explicit VisitRoots call for tracing. See also Handle (implicitly traced by a
+// GC) and StackReference (traced explicitly, but not as the result of a read barrier).
 template<class MirrorType>
 class GcRoot {
  public:
@@ -190,6 +194,10 @@ class GcRoot {
   ALWAYS_INLINE MirrorType* Read(GcRootSource* gc_root_source = nullptr) const
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  // TODO: This is often called repeatedly from functions to process an explicit array of roots.
+  // And it calls a function that takes an array of roots. By processing a single root at a time
+  // here and turning it into a 1-element array, do we lose performance? Or does the compiler
+  // eliminate the extra work?
   void VisitRoot(RootVisitor* visitor, const RootInfo& info) const
       REQUIRES_SHARED(Locks::mutator_lock_) {
     DCHECK(!IsNull());
diff --git a/runtime/hidden_api.h b/runtime/hidden_api.h
index 4b97b0d552..43883ef4e1 100644
--- a/runtime/hidden_api.h
+++ b/runtime/hidden_api.h
@@ -286,7 +286,7 @@ ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtField* field)
 ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtMethod* method)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   if (UNLIKELY(method->IsIntrinsic())) {
-    switch (static_cast<Intrinsics>(method->GetIntrinsic())) {
+    switch (method->GetIntrinsic()) {
       case Intrinsics::kSystemArrayCopyChar:
       case Intrinsics::kSystemArrayCopyByte:
       case Intrinsics::kSystemArrayCopyInt:
@@ -327,6 +327,7 @@ ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtMethod* method)
       case Intrinsics::kUnsafeLoadFence:
       case Intrinsics::kUnsafeStoreFence:
       case Intrinsics::kUnsafeFullFence:
+      case Intrinsics::kJdkUnsafeArrayBaseOffset:
       case Intrinsics::kJdkUnsafeCASInt:
       case Intrinsics::kJdkUnsafeCASLong:
       case Intrinsics::kJdkUnsafeCASObject:
@@ -377,6 +378,7 @@ ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtMethod* method)
       case Intrinsics::kFP16ToFloat:
       case Intrinsics::kFP16ToHalf:
       case Intrinsics::kFP16Rint:
+      case Intrinsics::kUnsafeArrayBaseOffset:
       case Intrinsics::kUnsafeGet:
       case Intrinsics::kUnsafeGetLong:
       case Intrinsics::kUnsafeGetByte:
diff --git a/runtime/hprof/hprof.cc b/runtime/hprof/hprof.cc
index 9e1bc29d84..f77370d3d4 100644
--- a/runtime/hprof/hprof.cc
+++ b/runtime/hprof/hprof.cc
@@ -1262,7 +1262,14 @@ void Hprof::DumpHeapClass(mirror::Class* klass) {
     // Strings are variable length with character data at the end like arrays.
     // This outputs the size of an empty string.
     __ AddU4(sizeof(mirror::String));
-  } else if (klass->IsArrayClass() || klass->IsPrimitive()) {
+  } else if (klass->IsArrayClass()) {
+    // Arrays are variable length with element data at the end of the header,
+    // padded to alignment. The offset to the data is the header memory size,
+    // after padding.
+    uint32_t component_size = klass->GetComponentSize();
+    uint32_t array_header_size = mirror::Array::DataOffset(component_size).Uint32Value();
+    __ AddU4(array_header_size);
+  } else if (klass->IsPrimitive()) {
     __ AddU4(0);
   } else {
     __ AddU4(klass->GetObjectSize());  // instance size
diff --git a/runtime/instrumentation.cc b/runtime/instrumentation.cc
index 46ef653e2c..ce8c35bfac 100644
--- a/runtime/instrumentation.cc
+++ b/runtime/instrumentation.cc
@@ -55,8 +55,7 @@
 #include "thread_list.h"
 
 namespace art HIDDEN {
-extern "C" NO_RETURN void artDeoptimize(Thread* self, bool skip_method_exit_callbacks);
-extern "C" NO_RETURN void artDeliverPendingExceptionFromCode(Thread* self);
+extern "C" void artDeliverPendingExceptionFromCode(Thread* self);
 
 namespace instrumentation {
 
@@ -249,31 +248,59 @@ static bool CodeSupportsEntryExitHooks(const void* entry_point, ArtMethod* metho
   return false;
 }
 
-static void UpdateEntryPoints(ArtMethod* method, const void* quick_code)
+template <typename T>
+bool CompareExchange(uintptr_t ptr, uintptr_t old_value, uintptr_t new_value) {
+  std::atomic<T>* atomic_addr = reinterpret_cast<std::atomic<T>*>(ptr);
+  T cast_old_value = dchecked_integral_cast<T>(old_value);
+  return atomic_addr->compare_exchange_strong(cast_old_value,
+                                              dchecked_integral_cast<T>(new_value),
+                                              std::memory_order_relaxed);
+}
+
+static void UpdateEntryPoints(ArtMethod* method, const void* new_code)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   if (kIsDebugBuild) {
     if (method->StillNeedsClinitCheckMayBeDead()) {
-      CHECK(CanHandleInitializationCheck(quick_code));
+      CHECK(CanHandleInitializationCheck(new_code));
     }
     jit::Jit* jit = Runtime::Current()->GetJit();
-    if (jit != nullptr && jit->GetCodeCache()->ContainsPc(quick_code)) {
+    if (jit != nullptr && jit->GetCodeCache()->ContainsPc(new_code)) {
       // Ensure we always have the thumb entrypoint for JIT on arm32.
       if (kRuntimeISA == InstructionSet::kArm) {
-        CHECK_EQ(reinterpret_cast<uintptr_t>(quick_code) & 1, 1u);
+        CHECK_EQ(reinterpret_cast<uintptr_t>(new_code) & 1, 1u);
       }
     }
     const Instrumentation* instr = Runtime::Current()->GetInstrumentation();
     if (instr->EntryExitStubsInstalled()) {
-      CHECK(CodeSupportsEntryExitHooks(quick_code, method));
+      CHECK(CodeSupportsEntryExitHooks(new_code, method));
     }
     if (instr->InterpreterStubsInstalled() && !method->IsNative()) {
-      CHECK_EQ(quick_code, GetQuickToInterpreterBridge());
+      CHECK_EQ(new_code, GetQuickToInterpreterBridge());
     }
   }
-  // If the method is from a boot image, don't dirty it if the entrypoint
-  // doesn't change.
-  if (method->GetEntryPointFromQuickCompiledCode() != quick_code) {
-    method->SetEntryPointFromQuickCompiledCode(quick_code);
+  const void* current_entry_point = method->GetEntryPointFromQuickCompiledCode();
+  if (current_entry_point == new_code) {
+    // If the method is from a boot image, don't dirty it if the entrypoint
+    // doesn't change.
+    return;
+  }
+
+  // Do an atomic exchange to avoid potentially unregistering JIT code twice.
+  MemberOffset offset = ArtMethod::EntryPointFromQuickCompiledCodeOffset(kRuntimePointerSize);
+  uintptr_t old_value = reinterpret_cast<uintptr_t>(current_entry_point);
+  uintptr_t new_value = reinterpret_cast<uintptr_t>(new_code);
+  uintptr_t ptr = reinterpret_cast<uintptr_t>(method) + offset.Uint32Value();
+  bool success = (kRuntimePointerSize == PointerSize::k32)
+      ? CompareExchange<uint32_t>(ptr, old_value, new_value)
+      : CompareExchange<uint64_t>(ptr, old_value, new_value);
+
+  // If we successfully updated the entrypoint and the old entrypoint is JITted
+  // code, register the old entrypoint as zombie.
+  jit::Jit* jit = Runtime::Current()->GetJit();
+  if (success &&
+      jit != nullptr &&
+      jit->GetCodeCache()->ContainsPc(current_entry_point)) {
+    jit->GetCodeCache()->AddZombieCode(method, current_entry_point);
   }
 }
 
@@ -1696,11 +1723,11 @@ bool Instrumentation::PushDeoptContextIfNeeded(Thread* self,
   return true;
 }
 
-void Instrumentation::DeoptimizeIfNeeded(Thread* self,
-                                         ArtMethod** sp,
-                                         DeoptimizationMethodType type,
-                                         JValue return_value,
-                                         bool is_reference) {
+std::unique_ptr<Context> Instrumentation::DeoptimizeIfNeeded(Thread* self,
+                                                             ArtMethod** sp,
+                                                             DeoptimizationMethodType type,
+                                                             JValue return_value,
+                                                             bool is_reference) {
   if (self->IsAsyncExceptionPending() || ShouldDeoptimizeCaller(self, sp)) {
     self->PushDeoptimizationContext(return_value,
                                     is_reference,
@@ -1709,8 +1736,12 @@ void Instrumentation::DeoptimizeIfNeeded(Thread* self,
                                     type);
     // This is requested from suspend points or when returning from runtime methods so exit
     // callbacks wouldn't be run yet. So don't skip method callbacks.
-    artDeoptimize(self, /* skip_method_exit_callbacks= */ false);
+    return self->Deoptimize(DeoptimizationKind::kFullFrame,
+                            /* single_frame= */ false,
+                            /* skip_method_exit_callbacks= */ false);
   }
+  // No exception or deoptimization.
+  return nullptr;
 }
 
 bool Instrumentation::NeedsSlowInterpreterForMethod(Thread* self, ArtMethod* method) {
diff --git a/runtime/instrumentation.h b/runtime/instrumentation.h
index 35e7f13c08..59e6b29b90 100644
--- a/runtime/instrumentation.h
+++ b/runtime/instrumentation.h
@@ -43,6 +43,7 @@ class Throwable;
 }  // namespace mirror
 class ArtField;
 class ArtMethod;
+class Context;
 template <typename T> class Handle;
 template <typename T> class MutableHandle;
 struct NthCallerVisitor;
@@ -533,11 +534,14 @@ class Instrumentation {
                                 DeoptimizationMethodType deopt_type,
                                 bool is_ref,
                                 const JValue& result) REQUIRES_SHARED(Locks::mutator_lock_);
-  void DeoptimizeIfNeeded(Thread* self,
-                          ArtMethod** sp,
-                          DeoptimizationMethodType type,
-                          JValue result,
-                          bool is_ref) REQUIRES_SHARED(Locks::mutator_lock_);
+
+  // Deoptimize upon pending exception or if the caller requires it. Returns a long jump context if
+  // a deoptimization is needed and taken.
+  std::unique_ptr<Context> DeoptimizeIfNeeded(Thread* self,
+                                              ArtMethod** sp,
+                                              DeoptimizationMethodType type,
+                                              JValue result,
+                                              bool is_ref) REQUIRES_SHARED(Locks::mutator_lock_);
   // This returns if the caller of runtime method requires a deoptimization. This checks both if the
   // method requires a deopt or if this particular frame needs a deopt because of a class
   // redefinition.
diff --git a/runtime/intern_table.h b/runtime/intern_table.h
index 6a76c74c3a..d91a3216c6 100644
--- a/runtime/intern_table.h
+++ b/runtime/intern_table.h
@@ -294,11 +294,11 @@ class InternTable {
   // Note: Transaction rollback calls these helper functions directly.
   EXPORT ObjPtr<mirror::String> InsertStrong(ObjPtr<mirror::String> s, uint32_t hash)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::intern_table_lock_);
-  ObjPtr<mirror::String> InsertWeak(ObjPtr<mirror::String> s, uint32_t hash)
+  EXPORT ObjPtr<mirror::String> InsertWeak(ObjPtr<mirror::String> s, uint32_t hash)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::intern_table_lock_);
-  void RemoveStrong(ObjPtr<mirror::String> s, uint32_t hash)
+  EXPORT void RemoveStrong(ObjPtr<mirror::String> s, uint32_t hash)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::intern_table_lock_);
-  void RemoveWeak(ObjPtr<mirror::String> s, uint32_t hash)
+  void EXPORT RemoveWeak(ObjPtr<mirror::String> s, uint32_t hash)
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(Locks::intern_table_lock_);
 
   // Change the weak root state. May broadcast to waiters.
diff --git a/runtime/interpreter/interpreter.cc b/runtime/interpreter/interpreter.cc
index fb6f36d5e7..eeeb300a92 100644
--- a/runtime/interpreter/interpreter.cc
+++ b/runtime/interpreter/interpreter.cc
@@ -237,13 +237,12 @@ static JValue ExecuteSwitch(Thread* self,
                             ShadowFrame& shadow_frame,
                             JValue result_register,
                             bool interpret_one_instruction) REQUIRES_SHARED(Locks::mutator_lock_) {
-  if (Runtime::Current()->IsActiveTransaction()) {
-    return ExecuteSwitchImpl<true>(
-        self, accessor, shadow_frame, result_register, interpret_one_instruction);
-  } else {
-    return ExecuteSwitchImpl<false>(
-        self, accessor, shadow_frame, result_register, interpret_one_instruction);
-  }
+  Runtime* runtime = Runtime::Current();
+  auto switch_impl_cpp = runtime->IsActiveTransaction()
+      ? runtime->GetClassLinker()->GetTransactionalInterpreter()
+      : reinterpret_cast<const void*>(&ExecuteSwitchImplCpp</*transaction_active=*/ false>);
+  return ExecuteSwitchImpl(
+      self, accessor, shadow_frame, result_register, interpret_one_instruction, switch_impl_cpp);
 }
 
 NO_STACK_PROTECTOR
diff --git a/runtime/interpreter/interpreter_common.cc b/runtime/interpreter/interpreter_common.cc
index f11c62bc71..f530fa245d 100644
--- a/runtime/interpreter/interpreter_common.cc
+++ b/runtime/interpreter/interpreter_common.cc
@@ -439,12 +439,10 @@ static bool DoVarHandleInvokeCommon(Thread* self,
   bool is_var_args = inst->HasVarArgs();
   const uint32_t vRegC = is_var_args ? inst->VRegC_45cc() : inst->VRegC_4rcc();
   const uint16_t vRegH = is_var_args ? inst->VRegH_45cc() : inst->VRegH_4rcc();
-  StackHandleScope<4> hs(self);
+  StackHandleScope<1> hs(self);
   Handle<mirror::VarHandle> var_handle = hs.NewHandle(
       ObjPtr<mirror::VarHandle>::DownCast(shadow_frame.GetVRegReference(vRegC)));
   ArtMethod* method = shadow_frame.GetMethod();
-  Handle<mirror::DexCache> dex_cache = hs.NewHandle(method->GetDexCache());
-  Handle<mirror::ClassLoader> class_loader = hs.NewHandle(method->GetClassLoader());
   uint32_t var_args[Instruction::kMaxVarArgRegs];
   std::optional<VarArgsInstructionOperands> var_args_operands(std::nullopt);
   std::optional<RangeInstructionOperands> range_operands(std::nullopt);
@@ -458,63 +456,12 @@ static bool DoVarHandleInvokeCommon(Thread* self,
     all_operands = &range_operands.value();
   }
   NoReceiverInstructionOperands operands(all_operands);
-  ClassLinker* const class_linker = Runtime::Current()->GetClassLinker();
 
-  // If the `ThreadLocalRandom` class is not yet initialized, do the `VarHandle` operation
-  // without creating a managed `MethodType` object. This avoids a circular initialization
-  // issue when `ThreadLocalRandom.<clinit>` indirectly calls `AtomicLong.compareAndSet()`
-  // (implemented with a `VarHandle`) and the `MethodType` caching circles back to the
-  // `ThreadLocalRandom` with uninitialized `seeder` and throws NPE.
-  //
-  // Do a quick test for "visibly initialized" without a read barrier and, if that fails,
-  // do a thorough test for "initialized" (including load acquire) with the read barrier.
-  ArtField* field = WellKnownClasses::java_util_concurrent_ThreadLocalRandom_seeder;
-  if (LIKELY(field->GetDeclaringClass<kWithoutReadBarrier>()->IsVisiblyInitialized()) ||
-      field->GetDeclaringClass()->IsInitialized()) {
-    Handle<mirror::MethodType> callsite_type(hs.NewHandle(
-        class_linker->ResolveMethodType(self, dex::ProtoIndex(vRegH), dex_cache, class_loader)));
-    if (LIKELY(callsite_type != nullptr)) {
-      return VarHandleInvokeAccessor(self,
-                                     shadow_frame,
-                                     var_handle,
-                                     callsite_type,
-                                     access_mode,
-                                     &operands,
-                                     result);
-    }
-    // This implies we couldn't resolve one or more types in this VarHandle,
-    // or we could not allocate the `MethodType` object.
-    CHECK(self->IsExceptionPending());
-    if (self->GetException()->GetClass() != WellKnownClasses::java_lang_OutOfMemoryError.Get()) {
-      return false;
-    }
-    // Clear the OOME and retry without creating an actual `MethodType` object.
-    // This prevents unexpected OOME for trivial `VarHandle` operations.
-    // It also prevents odd situations where a `VarHandle` operation succeeds but the same
-    // operation fails later because the `MethodType` object was evicted from the `DexCache`
-    // and we suddenly run out of memory to allocate a new one.
-    //
-    // We have previously seen OOMEs in the run-test `183-rmw-stress-test` with
-    // `--optimizng --no-image` (boot class path methods run in interpreter without JIT)
-    // but it probably happened on the first execution of a trivial `VarHandle` operation
-    // and not due to the `DexCache` eviction mentioned above.
-    self->ClearException();
-  }
-
-  VariableSizedHandleScope callsite_type_hs(self);
-  mirror::RawMethodType callsite_type(&callsite_type_hs);
-  if (!class_linker->ResolveMethodType(self,
-                                       dex::ProtoIndex(vRegH),
-                                       dex_cache,
-                                       class_loader,
-                                       callsite_type)) {
-    CHECK(self->IsExceptionPending());
-    return false;
-  }
   return VarHandleInvokeAccessor(self,
                                  shadow_frame,
                                  var_handle,
-                                 callsite_type,
+                                 method,
+                                 dex::ProtoIndex(vRegH),
                                  access_mode,
                                  &operands,
                                  result);
@@ -580,7 +527,7 @@ bool DoInvokePolymorphic(Thread* self,
   DCHECK(invoke_method->IsIntrinsic());
 
   // Dispatch based on intrinsic identifier associated with method.
-  switch (static_cast<art::Intrinsics>(invoke_method->GetIntrinsic())) {
+  switch (invoke_method->GetIntrinsic()) {
 #define CASE_SIGNATURE_POLYMORPHIC_INTRINSIC(Name, ...) \
     case Intrinsics::k##Name:                           \
       return Do ## Name(self, shadow_frame, inst, inst_data, result);
diff --git a/runtime/interpreter/interpreter_common.h b/runtime/interpreter/interpreter_common.h
index bad54ee448..ce6c412ba8 100644
--- a/runtime/interpreter/interpreter_common.h
+++ b/runtime/interpreter/interpreter_common.h
@@ -66,7 +66,7 @@
 namespace art HIDDEN {
 namespace interpreter {
 
-void ThrowNullPointerExceptionFromInterpreter()
+EXPORT void ThrowNullPointerExceptionFromInterpreter()
     REQUIRES_SHARED(Locks::mutator_lock_);
 
 static inline void DoMonitorEnter(Thread* self, ShadowFrame* frame, ObjPtr<mirror::Object> ref)
@@ -114,13 +114,13 @@ static inline bool DoMonitorCheckOnExit(Thread* self, ShadowFrame* frame)
 // DoFastInvoke and DoInvokeVirtualQuick functions.
 // Returns true on success, otherwise throws an exception and returns false.
 template<bool is_range>
-bool DoCall(ArtMethod* called_method,
-            Thread* self,
-            ShadowFrame& shadow_frame,
-            const Instruction* inst,
-            uint16_t inst_data,
-            bool string_init,
-            JValue* result);
+EXPORT bool DoCall(ArtMethod* called_method,
+                   Thread* self,
+                   ShadowFrame& shadow_frame,
+                   const Instruction* inst,
+                   uint16_t inst_data,
+                   bool string_init,
+                   JValue* result);
 
 // Called by the switch interpreter to know if we can stay in it.
 bool ShouldStayInSwitchInterpreter(ArtMethod* method)
@@ -133,7 +133,8 @@ NO_INLINE bool CheckStackOverflow(Thread* self, size_t frame_size)
 
 // Sends the normal method exit event.
 // Returns true if the events succeeded and false if there is a pending exception.
-template <typename T> bool SendMethodExitEvents(
+template <typename T>
+bool SendMethodExitEvents(
     Thread* self,
     const instrumentation::Instrumentation* instrumentation,
     ShadowFrame& frame,
@@ -149,6 +150,7 @@ NeedsMethodExitEvent(const instrumentation::Instrumentation* ins)
 COLD_ATTR void UnlockHeldMonitors(Thread* self, ShadowFrame* shadow_frame)
     REQUIRES_SHARED(Locks::mutator_lock_);
 
+EXPORT
 void PerformNonStandardReturn(Thread* self,
                               ShadowFrame& frame,
                               JValue& result,
@@ -211,18 +213,18 @@ ART_INTRINSICS_LIST(DECLARE_SIGNATURE_POLYMORPHIC_HANDLER)
 
 // Performs a invoke-polymorphic or invoke-polymorphic-range.
 template<bool is_range>
-bool DoInvokePolymorphic(Thread* self,
-                         ShadowFrame& shadow_frame,
-                         const Instruction* inst,
-                         uint16_t inst_data,
-                         JValue* result)
+EXPORT bool DoInvokePolymorphic(Thread* self,
+                                ShadowFrame& shadow_frame,
+                                const Instruction* inst,
+                                uint16_t inst_data,
+                                JValue* result)
     REQUIRES_SHARED(Locks::mutator_lock_);
 
-bool DoInvokeCustom(Thread* self,
-                    ShadowFrame& shadow_frame,
-                    uint32_t call_site_idx,
-                    const InstructionOperands* operands,
-                    JValue* result)
+EXPORT bool DoInvokeCustom(Thread* self,
+                           ShadowFrame& shadow_frame,
+                           uint32_t call_site_idx,
+                           const InstructionOperands* operands,
+                           JValue* result)
     REQUIRES_SHARED(Locks::mutator_lock_);
 
 // Performs a custom invoke (invoke-custom/invoke-custom-range).
@@ -278,11 +280,13 @@ ALWAYS_INLINE static JValue GetFieldValue(const ShadowFrame& shadow_frame, uint3
   return field_value;
 }
 
+LIBART_PROTECTED
 extern "C" size_t NterpGetStaticField(Thread* self,
                                       ArtMethod* caller,
                                       const uint16_t* dex_pc_ptr,
                                       size_t resolve_field_type);
 
+LIBART_PROTECTED
 extern "C" uint32_t NterpGetInstanceFieldOffset(Thread* self,
                                                 ArtMethod* caller,
                                                 const uint16_t* dex_pc_ptr,
@@ -422,10 +426,10 @@ static inline bool DoLongRemainder(ShadowFrame& shadow_frame,
 // Handles filled-new-array and filled-new-array-range instructions.
 // Returns true on success, otherwise throws an exception and returns false.
 template <bool is_range>
-bool DoFilledNewArray(const Instruction* inst,
-                      const ShadowFrame& shadow_frame,
-                      Thread* self,
-                      JValue* result);
+EXPORT bool DoFilledNewArray(const Instruction* inst,
+                             const ShadowFrame& shadow_frame,
+                             Thread* self,
+                             JValue* result);
 
 // Handles packed-switch instruction.
 // Returns the branch offset to the next instruction to execute.
@@ -498,14 +502,14 @@ static inline int32_t DoSparseSwitch(const Instruction* inst, const ShadowFrame&
 // This function accepts a null Instrumentation* as a way to cause instrumentation events not to be
 // reported.
 // TODO We might wish to reconsider how we cause some events to be ignored.
-bool MoveToExceptionHandler(Thread* self,
-                            ShadowFrame& shadow_frame,
-                            bool skip_listeners,
-                            bool skip_throw_listener) REQUIRES_SHARED(Locks::mutator_lock_);
-
-NO_RETURN void UnexpectedOpcode(const Instruction* inst, const ShadowFrame& shadow_frame)
-  __attribute__((cold))
-  REQUIRES_SHARED(Locks::mutator_lock_);
+EXPORT bool MoveToExceptionHandler(Thread* self,
+                                   ShadowFrame& shadow_frame,
+                                   bool skip_listeners,
+                                   bool skip_throw_listener) REQUIRES_SHARED(Locks::mutator_lock_);
+
+NO_RETURN EXPORT void UnexpectedOpcode(const Instruction* inst, const ShadowFrame& shadow_frame)
+    COLD_ATTR
+    REQUIRES_SHARED(Locks::mutator_lock_);
 
 // Set true if you want TraceExecution invocation before each bytecode execution.
 constexpr bool kTraceExecutionEnabled = false;
diff --git a/runtime/interpreter/interpreter_switch_impl.h b/runtime/interpreter/interpreter_switch_impl.h
index c390692f10..0b5a86f22d 100644
--- a/runtime/interpreter/interpreter_switch_impl.h
+++ b/runtime/interpreter/interpreter_switch_impl.h
@@ -51,16 +51,17 @@ void ExecuteSwitchImplCpp(SwitchImplContext* ctx)
 
 // Hand-written assembly method which wraps the C++ implementation,
 // while defining the DEX PC in the CFI so that libunwind can resolve it.
-extern "C" void ExecuteSwitchImplAsm(SwitchImplContext* ctx, void* impl, const uint16_t* dexpc)
-  REQUIRES_SHARED(Locks::mutator_lock_);
+extern "C" void ExecuteSwitchImplAsm(
+    SwitchImplContext* ctx, const void* impl, const uint16_t* dexpc)
+    REQUIRES_SHARED(Locks::mutator_lock_);
 
 // Wrapper around the switch interpreter which ensures we can unwind through it.
-template<bool transaction_active>
-ALWAYS_INLINE JValue ExecuteSwitchImpl(Thread* self,
-                                       const CodeItemDataAccessor& accessor,
-                                       ShadowFrame& shadow_frame,
-                                       JValue result_register,
-                                       bool interpret_one_instruction)
+ALWAYS_INLINE inline JValue ExecuteSwitchImpl(Thread* self,
+                                              const CodeItemDataAccessor& accessor,
+                                              ShadowFrame& shadow_frame,
+                                              JValue result_register,
+                                              bool interpret_one_instruction,
+                                              const void* switch_impl_cpp)
   REQUIRES_SHARED(Locks::mutator_lock_) {
   SwitchImplContext ctx {
     .self = self,
@@ -70,9 +71,8 @@ ALWAYS_INLINE JValue ExecuteSwitchImpl(Thread* self,
     .interpret_one_instruction = interpret_one_instruction,
     .result = JValue(),
   };
-  void* impl = reinterpret_cast<void*>(&ExecuteSwitchImplCpp<transaction_active>);
   const uint16_t* dex_pc = ctx.accessor.Insns();
-  ExecuteSwitchImplAsm(&ctx, impl, dex_pc);
+  ExecuteSwitchImplAsm(&ctx, switch_impl_cpp, dex_pc);
   return ctx.result;
 }
 
diff --git a/runtime/interpreter/lock_count_data.h b/runtime/interpreter/lock_count_data.h
index ec108fc5c1..6e6b6c986d 100644
--- a/runtime/interpreter/lock_count_data.h
+++ b/runtime/interpreter/lock_count_data.h
@@ -41,18 +41,18 @@ class LockCountData {
  public:
   // Add the given object to the list of monitors, that is, objects that have been locked. This
   // will not throw (but be skipped if there is an exception pending on entry).
-  void AddMonitor(Thread* self, mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_);
+  EXPORT void AddMonitor(Thread* self, mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Try to remove the given object from the monitor list, indicating an unlock operation.
   // This will throw an IllegalMonitorStateException (clearing any already pending exception), in
   // case that there wasn't a lock recorded for the object.
-  void RemoveMonitorOrThrow(Thread* self,
-                            const mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_);
+  EXPORT void RemoveMonitorOrThrow(Thread* self,
+                                   const mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Check whether all acquired monitors have been released. This will potentially throw an
   // IllegalMonitorStateException, clearing any already pending exception. Returns true if the
   // check shows that everything is OK wrt/ lock counting, false otherwise.
-  bool CheckAllMonitorsReleasedOrThrow(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_);
+  EXPORT bool CheckAllMonitorsReleasedOrThrow(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_);
 
   template <typename T, typename... Args>
   void VisitMonitors(T visitor, Args&&... args) REQUIRES_SHARED(Locks::mutator_lock_) {
diff --git a/runtime/interpreter/mterp/arm64ng/main.S b/runtime/interpreter/mterp/arm64ng/main.S
index 602273f13a..7d83edbad1 100644
--- a/runtime/interpreter/mterp/arm64ng/main.S
+++ b/runtime/interpreter/mterp/arm64ng/main.S
@@ -324,46 +324,6 @@ END \name
 
 // Uses x12, x13, and x14 as temporaries.
 .macro FETCH_CODE_ITEM_INFO code_item, registers, outs, ins, load_ins
-    tbz \code_item, #0, 4f
-    and \code_item, \code_item, #-2 // Remove the extra bit that marks it's a compact dex file
-    ldrh w13, [\code_item, #COMPACT_CODE_ITEM_FIELDS_OFFSET]
-    ubfx \registers, w13, #COMPACT_CODE_ITEM_REGISTERS_SIZE_SHIFT, #4
-    ubfx \outs, w13, #COMPACT_CODE_ITEM_OUTS_SIZE_SHIFT, #4
-    .if \load_ins
-    ubfx \ins, w13, #COMPACT_CODE_ITEM_INS_SIZE_SHIFT, #4
-    .else
-    ubfx w14, w13, #COMPACT_CODE_ITEM_INS_SIZE_SHIFT, #4
-    add \registers, \registers, w14
-    .endif
-    ldrh w13, [\code_item, #COMPACT_CODE_ITEM_FLAGS_OFFSET]
-    tst w13, #COMPACT_CODE_ITEM_REGISTERS_INS_OUTS_FLAGS
-    b.eq 3f
-    sub x14, \code_item, #4
-    tst w13, #COMPACT_CODE_ITEM_INSNS_FLAG
-    csel x14, x14, \code_item, ne
-
-    tbz w13, #COMPACT_CODE_ITEM_REGISTERS_BIT, 1f
-    ldrh w12, [x14, #-2]!
-    add \registers, \registers, w12
-1:
-    tbz w13, #COMPACT_CODE_ITEM_INS_BIT, 2f
-    ldrh w12, [x14, #-2]!
-    .if \load_ins
-    add \ins, \ins, w12
-    .else
-    add \registers, \registers, w12
-    .endif
-2:
-    tbz w13, #COMPACT_CODE_ITEM_OUTS_BIT, 3f
-    ldrh w12, [x14, #-2]!
-    add \outs, \outs, w12
-3:
-    .if \load_ins
-    add \registers, \registers, \ins
-    .endif
-    add \code_item, \code_item, #COMPACT_CODE_ITEM_INSNS_OFFSET
-    b 5f
-4:
     // Fetch dex register size.
     ldrh \registers, [\code_item, #CODE_ITEM_REGISTERS_SIZE_OFFSET]
     // Fetch outs size.
@@ -372,7 +332,6 @@ END \name
     ldrh \ins, [\code_item, #CODE_ITEM_INS_SIZE_OFFSET]
     .endif
     add \code_item, \code_item, #CODE_ITEM_INSNS_OFFSET
-5:
 .endm
 
 .macro TEST_IF_MARKING label
diff --git a/runtime/interpreter/mterp/armng/main.S b/runtime/interpreter/mterp/armng/main.S
index ec23572b40..906536654b 100644
--- a/runtime/interpreter/mterp/armng/main.S
+++ b/runtime/interpreter/mterp/armng/main.S
@@ -330,54 +330,6 @@ END \name
 // - if load_ins is 1, \ins contains the ins
 // - \code_item is replaced with a pointer to the instructions
 .macro FETCH_CODE_ITEM_INFO code_item, registers, outs, ins, load_ins
-    tst \code_item, #1
-    beq 5f
-    bic \code_item, \code_item, #1 // Remove the extra bit that marks it's a compact dex file
-    ldrh lr, [\code_item, #COMPACT_CODE_ITEM_FIELDS_OFFSET]
-    ubfx \registers, lr, #COMPACT_CODE_ITEM_REGISTERS_SIZE_SHIFT, #4
-    ubfx \outs, lr, #COMPACT_CODE_ITEM_OUTS_SIZE_SHIFT, #4
-    .if \load_ins
-    ubfx \ins, lr, #COMPACT_CODE_ITEM_INS_SIZE_SHIFT, #4
-    .else
-    ubfx ip, lr, #COMPACT_CODE_ITEM_INS_SIZE_SHIFT, #4
-    add \registers, \registers, ip
-    .endif
-
-    ldrh lr, [\code_item, #COMPACT_CODE_ITEM_FLAGS_OFFSET]
-    tst lr, #COMPACT_CODE_ITEM_REGISTERS_INS_OUTS_FLAGS
-    beq 4f
-    mov ip, \code_item
-    tst lr, #COMPACT_CODE_ITEM_INSNS_FLAG
-    beq 1f
-    sub ip, ip, #4
-1:
-    tst lr, #COMPACT_CODE_ITEM_REGISTERS_FLAG
-    beq 2f
-    ldrh lr, [ip, #-2]!
-    add \registers, \registers, lr
-    ldrh lr, [\code_item, #COMPACT_CODE_ITEM_FLAGS_OFFSET]
-2:
-    tst lr, #COMPACT_CODE_ITEM_INS_FLAG
-    beq 3f
-    ldrh lr, [ip, #-2]!
-    .if \load_ins
-    add \ins, \ins, lr
-    .else
-    add \registers, \registers, lr
-    .endif
-    ldrh lr, [\code_item, #COMPACT_CODE_ITEM_FLAGS_OFFSET]
-3:
-    tst lr, #COMPACT_CODE_ITEM_OUTS_FLAG
-    beq 4f
-    ldrh lr, [ip, #-2]!
-    add \outs, \outs, lr
-4:
-    .if \load_ins
-    add \registers, \registers, \ins
-    .endif
-    add \code_item, \code_item, #COMPACT_CODE_ITEM_INSNS_OFFSET
-    b 6f
-5:
     // Fetch dex register size.
     ldrh \registers, [\code_item, #CODE_ITEM_REGISTERS_SIZE_OFFSET]
     // Fetch outs size.
@@ -386,7 +338,6 @@ END \name
     ldrh \ins, [\code_item, #CODE_ITEM_INS_SIZE_OFFSET]
     .endif
     add \code_item, \code_item, #CODE_ITEM_INSNS_OFFSET
-6:
 .endm
 
 // Setup the stack to start executing the method. Expects:
diff --git a/runtime/interpreter/mterp/nterp.cc b/runtime/interpreter/mterp/nterp.cc
index b2591d8af0..a3e72725ce 100644
--- a/runtime/interpreter/mterp/nterp.cc
+++ b/runtime/interpreter/mterp/nterp.cc
@@ -316,7 +316,7 @@ static constexpr std::array<uint8_t, 256u> GenerateOpcodeInvokeTypes() {
 
 static constexpr std::array<uint8_t, 256u> kOpcodeInvokeTypes = GenerateOpcodeInvokeTypes();
 
-FLATTEN
+LIBART_PROTECTED FLATTEN
 extern "C" size_t NterpGetMethod(Thread* self, ArtMethod* caller, const uint16_t* dex_pc_ptr)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   UpdateHotness(caller);
@@ -389,6 +389,7 @@ extern "C" size_t NterpGetMethod(Thread* self, ArtMethod* caller, const uint16_t
   }
 }
 
+LIBART_PROTECTED
 extern "C" size_t NterpGetStaticField(Thread* self,
                                       ArtMethod* caller,
                                       const uint16_t* dex_pc_ptr,
@@ -444,6 +445,7 @@ extern "C" size_t NterpGetStaticField(Thread* self,
   }
 }
 
+LIBART_PROTECTED
 extern "C" uint32_t NterpGetInstanceFieldOffset(Thread* self,
                                                 ArtMethod* caller,
                                                 const uint16_t* dex_pc_ptr,
diff --git a/runtime/interpreter/mterp/riscv64/main.S b/runtime/interpreter/mterp/riscv64/main.S
index bfc49c0c20..a9b917ad35 100644
--- a/runtime/interpreter/mterp/riscv64/main.S
+++ b/runtime/interpreter/mterp/riscv64/main.S
@@ -127,10 +127,6 @@ END \name
 //   - \ins: in count. If set to register "zero" (x0), load is skipped.
 //   - \code_item: holds instruction array on exit
 .macro FETCH_CODE_ITEM_INFO code_item, regs, outs, ins
-    // Check LSB of \code_item. If 1, it's a compact dex file.
-    BRANCH_IF_BIT_CLEAR \regs, \code_item, 0, 1f  // Regular dex.
-    unimp  // Compact dex: unimplemented.
-1:
     // Unpack values from regular dex format.
     lhu \regs, CODE_ITEM_REGISTERS_SIZE_OFFSET(\code_item)
     lhu \outs, CODE_ITEM_OUTS_SIZE_OFFSET(\code_item)
diff --git a/runtime/interpreter/mterp/x86_64ng/main.S b/runtime/interpreter/mterp/x86_64ng/main.S
index f346cb873d..f6f48ffcc3 100644
--- a/runtime/interpreter/mterp/x86_64ng/main.S
+++ b/runtime/interpreter/mterp/x86_64ng/main.S
@@ -278,61 +278,6 @@ END_FUNCTION \name
 // - if load_ins is 1, \ins contains the ins
 // - \code_item is replace with a pointer to the instructions
 .macro FETCH_CODE_ITEM_INFO code_item, registers, outs, ins, load_ins
-    testq MACRO_LITERAL(1), \code_item
-    je 5f
-    andq $$-2, \code_item  // Remove the extra bit that marks it's a compact dex file.
-    movzwl COMPACT_CODE_ITEM_FIELDS_OFFSET(\code_item), %r10d
-    movl %r10d, \registers
-    sarl $$COMPACT_CODE_ITEM_REGISTERS_SIZE_SHIFT, \registers
-    andl $$0xf, \registers
-    movl %r10d, \outs
-    sarl $$COMPACT_CODE_ITEM_OUTS_SIZE_SHIFT, \outs
-    andl $$0xf, \outs
-    .if \load_ins
-    movl %r10d, \ins
-    sarl $$COMPACT_CODE_ITEM_INS_SIZE_SHIFT, \ins
-    andl $$0xf, \ins
-    .else
-    movl %r10d, %r11d
-    sarl $$COMPACT_CODE_ITEM_INS_SIZE_SHIFT, %r11d
-    andl $$0xf, %r11d
-    addl %r11d, \registers
-    .endif
-    testw $$COMPACT_CODE_ITEM_REGISTERS_INS_OUTS_FLAGS, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 4f
-    movq \code_item, %r11
-    testw $$COMPACT_CODE_ITEM_INSNS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 1f
-    subq $$4, %r11
-1:
-    testw $$COMPACT_CODE_ITEM_REGISTERS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 2f
-    subq $$2, %r11
-    movzwl (%r11), %r10d
-    addl %r10d, \registers
-2:
-    testw $$COMPACT_CODE_ITEM_INS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 3f
-    subq $$2, %r11
-    movzwl (%r11), %r10d
-    .if \load_ins
-    addl %r10d, \ins
-    .else
-    addl %r10d, \registers
-    .endif
-3:
-    testw $$COMPACT_CODE_ITEM_OUTS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 4f
-    subq $$2, %r11
-    movzwl (%r11), %r10d
-    addl %r10d, \outs
-4:
-    .if \load_ins
-    addl \ins, \registers
-    .endif
-    addq $$COMPACT_CODE_ITEM_INSNS_OFFSET, \code_item
-    jmp 6f
-5:
     // Fetch dex register size.
     movzwl CODE_ITEM_REGISTERS_SIZE_OFFSET(\code_item), \registers
     // Fetch outs size.
@@ -341,7 +286,6 @@ END_FUNCTION \name
     movzwl CODE_ITEM_INS_SIZE_OFFSET(\code_item), \ins
     .endif
     addq $$CODE_ITEM_INSNS_OFFSET, \code_item
-6:
 .endm
 
 // Setup the stack to start executing the method. Expects:
diff --git a/runtime/interpreter/mterp/x86ng/main.S b/runtime/interpreter/mterp/x86ng/main.S
index b64040f7d2..65a6a75df1 100644
--- a/runtime/interpreter/mterp/x86ng/main.S
+++ b/runtime/interpreter/mterp/x86ng/main.S
@@ -327,61 +327,6 @@ END_FUNCTION \name
 // - if load_ins is 1, \ins contains the ins
 // - \code_item is replaced with a pointer to the instructions
 .macro FETCH_CODE_ITEM_INFO code_item, registers, outs, ins, load_ins
-    testl MACRO_LITERAL(1), \code_item
-    je 5f
-    andl $$-2, \code_item  // Remove the extra bit that marks it's a compact dex file.
-    movzwl COMPACT_CODE_ITEM_FIELDS_OFFSET(\code_item), %edx
-    movl %edx, \registers
-    sarl $$COMPACT_CODE_ITEM_REGISTERS_SIZE_SHIFT, \registers
-    andl $$0xf, \registers
-    movl %edx, \outs
-    sarl $$COMPACT_CODE_ITEM_OUTS_SIZE_SHIFT, \outs
-    andl $$0xf, \outs
-    .if \load_ins
-    movl %edx, \ins
-    sarl $$COMPACT_CODE_ITEM_INS_SIZE_SHIFT, \ins
-    andl $$0xf, \ins
-    .else
-    movl %edx, %eax
-    sarl $$COMPACT_CODE_ITEM_INS_SIZE_SHIFT, %eax
-    andl $$0xf, %eax
-    addl %eax, \registers
-    .endif
-    testw $$COMPACT_CODE_ITEM_REGISTERS_INS_OUTS_FLAGS, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 4f
-    movl \code_item, %eax
-    testw $$COMPACT_CODE_ITEM_INSNS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 1f
-    subl $$4, %eax
-1:
-    testw $$COMPACT_CODE_ITEM_REGISTERS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 2f
-    subl $$2, %eax
-    movzwl (%eax), %edx
-    addl %edx, \registers
-2:
-    testw $$COMPACT_CODE_ITEM_INS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 3f
-    subl $$2, %eax
-    movzwl (%eax), %edx
-    .if \load_ins
-    addl %edx, \ins
-    .else
-    addl %edx, \registers
-    .endif
-3:
-    testw $$COMPACT_CODE_ITEM_OUTS_FLAG, COMPACT_CODE_ITEM_FLAGS_OFFSET(\code_item)
-    je 4f
-    subl $$2, %eax
-    movzwl (%eax), %edx
-    addl %edx, \outs
-4:
-    .if \load_ins
-    addl \ins, \registers
-    .endif
-    addl $$COMPACT_CODE_ITEM_INSNS_OFFSET, \code_item
-    jmp 6f
-5:
     // Fetch dex register size.
     movzwl CODE_ITEM_REGISTERS_SIZE_OFFSET(\code_item), \registers
     // Fetch outs size.
@@ -390,7 +335,6 @@ END_FUNCTION \name
     movzwl CODE_ITEM_INS_SIZE_OFFSET(\code_item), \ins
     .endif
     addl $$CODE_ITEM_INSNS_OFFSET, \code_item
-6:
 .endm
 
 // Setup the stack to start executing the method. Expects:
diff --git a/runtime/interpreter/unstarted_runtime.cc b/runtime/interpreter/unstarted_runtime.cc
index 43e0692eee..0dde04145a 100644
--- a/runtime/interpreter/unstarted_runtime.cc
+++ b/runtime/interpreter/unstarted_runtime.cc
@@ -477,6 +477,7 @@ void UnstartedRuntime::UnstartedClassGetEnclosingClass(
   Handle<mirror::Class> klass(hs.NewHandle(shadow_frame->GetVRegReference(arg_offset)->AsClass()));
   if (klass->IsProxyClass() || klass->GetDexCache() == nullptr) {
     result->SetL(nullptr);
+    return;
   }
   result->SetL(annotations::GetEnclosingClass(klass));
 }
@@ -2099,8 +2100,7 @@ void UnstartedRuntime::UnstartedJNIThrowableNativeFillInStackTrace(
     [[maybe_unused]] uint32_t* args,
     JValue* result) {
   ScopedObjectAccessUnchecked soa(self);
-  ScopedLocalRef<jobject> stack_trace(self->GetJniEnv(), self->CreateInternalStackTrace(soa));
-  result->SetL(soa.Decode<mirror::Object>(stack_trace.get()));
+  result->SetL(self->CreateInternalStackTrace(soa));
 }
 
 void UnstartedRuntime::UnstartedJNIUnsafeCompareAndSwapInt(
diff --git a/runtime/intrinsics_list.h b/runtime/intrinsics_list.h
index 862c3cbd52..cdd23596b5 100644
--- a/runtime/intrinsics_list.h
+++ b/runtime/intrinsics_list.h
@@ -38,6 +38,7 @@
 //
 // Note: adding a new intrinsic requires an art image version change,
 // as the modifiers flag for some ArtMethods will need to be changed.
+// The image version is located in runtime/oat/image.cc
 //
 // Note: j.l.Integer.valueOf says kNoThrow even though it could throw an
 // OOME. The kNoThrow should be renamed to kNoVisibleThrow, as it is ok to
@@ -179,6 +180,10 @@
   V(MathRoundDouble, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "round", "(D)J") \
   V(MathRoundFloat, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "round", "(F)I") \
   V(MathMultiplyHigh, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "multiplyHigh", "(JJ)J") \
+  V(MathSignumDouble, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "signum", "(D)D") \
+  V(MathSignumFloat, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "signum", "(F)F") \
+  V(MathCopySignDouble, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "copySign", "(DD)D") \
+  V(MathCopySignFloat, kStatic, kNeedsEnvironment, kNoSideEffects, kNoThrow, "Ljava/lang/Math;", "copySign", "(FF)F") \
   V(SystemArrayCopyByte, kStatic, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljava/lang/System;", "arraycopy", "([BI[BII)V") \
   V(SystemArrayCopyChar, kStatic, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljava/lang/System;", "arraycopy", "([CI[CII)V") \
   V(SystemArrayCopyInt, kStatic, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljava/lang/System;", "arraycopy", "([II[III)V") \
@@ -229,6 +234,7 @@
   V(StringBuilderAppendDouble, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljava/lang/StringBuilder;", "append", "(D)Ljava/lang/StringBuilder;") \
   V(StringBuilderLength, kVirtual, kNeedsEnvironment, kReadSideEffects, kNoThrow, "Ljava/lang/StringBuilder;", "length", "()I") \
   V(StringBuilderToString, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljava/lang/StringBuilder;", "toString", "()Ljava/lang/String;") \
+  V(UnsafeArrayBaseOffset, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "arrayBaseOffset", "(Ljava/lang/Class;)I") \
   V(UnsafeCASInt, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "compareAndSwapInt", "(Ljava/lang/Object;JII)Z") \
   V(UnsafeCASLong, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "compareAndSwapLong", "(Ljava/lang/Object;JJJ)Z") \
   V(UnsafeCASObject, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "compareAndSwapObject", "(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z") \
@@ -254,6 +260,7 @@
   V(UnsafeGetAndSetInt, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getAndSetInt", "(Ljava/lang/Object;JI)I") \
   V(UnsafeGetAndSetLong, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getAndSetLong", "(Ljava/lang/Object;JJ)J") \
   V(UnsafeGetAndSetObject, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getAndSetObject", "(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;") \
+  V(JdkUnsafeArrayBaseOffset, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "arrayBaseOffset", "(Ljava/lang/Class;)I") \
   V(JdkUnsafeCASInt, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "compareAndSwapInt", "(Ljava/lang/Object;JII)Z") \
   V(JdkUnsafeCASLong, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "compareAndSwapLong", "(Ljava/lang/Object;JJJ)Z") \
   V(JdkUnsafeCASObject, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "compareAndSwapObject", "(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z") \
diff --git a/runtime/jit/debugger_interface.cc b/runtime/jit/debugger_interface.cc
index 8c9fb4c999..d367bbf5cd 100644
--- a/runtime/jit/debugger_interface.cc
+++ b/runtime/jit/debugger_interface.cc
@@ -218,8 +218,12 @@ static std::vector<const void*> g_removed_jit_functions GUARDED_BY(g_jit_debug_l
 static uint32_t g_jit_num_unpacked_entries = 0;
 
 struct DexNativeInfo {
+  static Mutex* Lock() RETURN_CAPABILITY(g_dex_debug_lock) { return &g_dex_debug_lock; }
   static constexpr bool kCopySymfileData = false;  // Just reference DEX files.
-  static JITDescriptor& Descriptor() { return __dex_debug_descriptor; }
+  static JITDescriptor& Descriptor() REQUIRES(g_dex_debug_lock) {
+    g_dex_debug_lock.AssertHeld(Thread::Current());
+    return __dex_debug_descriptor;
+  }
   static void NotifyNativeDebugger() { __dex_debug_register_code_ptr(); }
   static const void* Alloc(size_t size) { return malloc(size); }
   static void Free(const void* ptr) { free(const_cast<void*>(ptr)); }
@@ -227,14 +231,19 @@ struct DexNativeInfo {
 };
 
 struct JitNativeInfo {
+  static Mutex* Lock() RETURN_CAPABILITY(g_jit_debug_lock) { return &g_jit_debug_lock; }
   static constexpr bool kCopySymfileData = true;  // Copy debug info to JIT memory.
-  static JITDescriptor& Descriptor() { return __jit_debug_descriptor; }
+  static JITDescriptor& Descriptor() REQUIRES(g_jit_debug_lock) {
+    g_jit_debug_lock.AssertHeld(Thread::Current());
+    return __jit_debug_descriptor;
+  }
   static void NotifyNativeDebugger() { __jit_debug_register_code_ptr(); }
   static const void* Alloc(size_t size) { return Memory()->AllocateData(size); }
   static void Free(const void* ptr) { Memory()->FreeData(reinterpret_cast<const uint8_t*>(ptr)); }
   static void Free(void* ptr) = delete;
 
-  template<class T> static T* Writable(const T* v) {
+  template <class T>
+  static T* Writable(const T* v) REQUIRES(g_jit_debug_lock) {
     // Special case: This entry is in static memory and not allocated in JIT memory.
     if (v == reinterpret_cast<const void*>(&Descriptor().application_tail_entry_)) {
       return const_cast<T*>(v);
@@ -280,8 +289,9 @@ static void Sequnlock(JITDescriptor& descriptor) {
 
 // Insert 'entry' in the linked list before 'next' and mark it as valid (append if 'next' is null).
 // This method must be called under global lock (g_jit_debug_lock or g_dex_debug_lock).
-template<class NativeInfo>
-static void InsertNewEntry(const JITCodeEntry* entry, const JITCodeEntry* next) {
+template <class NativeInfo>
+static void InsertNewEntry(const JITCodeEntry* entry, const JITCodeEntry* next)
+    REQUIRES(NativeInfo::Lock()) {
   CHECK_EQ(entry->seqlock_.load(kNonRacingRelaxed) & 1, 1u) << "Expected invalid entry";
   JITDescriptor& descriptor = NativeInfo::Descriptor();
   const JITCodeEntry* prev = (next != nullptr ? next->prev_ : descriptor.tail_);
@@ -304,12 +314,12 @@ static void InsertNewEntry(const JITCodeEntry* entry, const JITCodeEntry* next)
 }
 
 // This must be called with the appropriate lock taken (g_{jit,dex}_debug_lock).
-template<class NativeInfo>
+template <class NativeInfo>
 static const JITCodeEntry* CreateJITCodeEntryInternal(
     ArrayRef<const uint8_t> symfile = ArrayRef<const uint8_t>(),
     const void* addr = nullptr,
     bool allow_packing = false,
-    bool is_compressed = false) {
+    bool is_compressed = false) REQUIRES(NativeInfo::Lock()) {
   JITDescriptor& descriptor = NativeInfo::Descriptor();
 
   // Allocate JITCodeEntry if needed.
@@ -368,8 +378,8 @@ static const JITCodeEntry* CreateJITCodeEntryInternal(
   return entry;
 }
 
-template<class NativeInfo>
-static void DeleteJITCodeEntryInternal(const JITCodeEntry* entry) {
+template <class NativeInfo>
+static void DeleteJITCodeEntryInternal(const JITCodeEntry* entry) REQUIRES(NativeInfo::Lock()) {
   CHECK(entry != nullptr);
   JITDescriptor& descriptor = NativeInfo::Descriptor();
 
@@ -466,6 +476,8 @@ void RemoveNativeDebugInfoForDex(Thread* self, const DexFile* dexfile) {
 //
 void NativeDebugInfoPreFork() {
   CHECK(Runtime::Current()->IsZygote());
+  MutexLock mu(Thread::Current(), *Locks::jit_lock_);  // Needed to alloc entry.
+  MutexLock mu2(Thread::Current(), g_jit_debug_lock);
   JITDescriptor& descriptor = JitNativeInfo::Descriptor();
   if (descriptor.zygote_head_entry_ != nullptr) {
     return;  // Already done - we need to do this only on the first fork.
@@ -473,7 +485,6 @@ void NativeDebugInfoPreFork() {
 
   // Create the zygote-owned head entry (with no ELF file).
   // The data will be allocated from the current JIT memory (owned by zygote).
-  MutexLock mu(Thread::Current(), *Locks::jit_lock_);  // Needed to alloc entry.
   const JITCodeEntry* zygote_head =
     reinterpret_cast<const JITCodeEntry*>(JitNativeInfo::Alloc(sizeof(JITCodeEntry)));
   CHECK(zygote_head != nullptr);
@@ -488,6 +499,7 @@ void NativeDebugInfoPreFork() {
 
 void NativeDebugInfoPostFork() {
   CHECK(!Runtime::Current()->IsZygote());
+  MutexLock mu(Thread::Current(), g_jit_debug_lock);
   JITDescriptor& descriptor = JitNativeInfo::Descriptor();
   descriptor.free_entries_ = nullptr;  // Don't reuse zygote's entries.
 }
@@ -575,7 +587,7 @@ static void RepackEntries(bool compress_entries, ArrayRef<const void*> removed)
   g_jit_num_unpacked_entries = 0;
 }
 
-void RepackNativeDebugInfoForJitLocked() REQUIRES(g_jit_debug_lock);
+static void RepackNativeDebugInfoForJitLocked() REQUIRES(g_jit_debug_lock);
 
 void AddNativeDebugInfoForJit(const void* code_ptr,
                               const std::vector<uint8_t>& symfile,
@@ -627,7 +639,7 @@ void RemoveNativeDebugInfoForJit(const void* code_ptr) {
   VLOG(jit) << "JIT mini-debug-info removed for " << code_ptr;
 }
 
-void RepackNativeDebugInfoForJitLocked() {
+static void RepackNativeDebugInfoForJitLocked() {
   // Remove entries which are inside packed and compressed ELF files.
   std::vector<const void*>& removed = g_removed_jit_functions;
   std::sort(removed.begin(), removed.end());
diff --git a/runtime/jit/jit.cc b/runtime/jit/jit.cc
index 4d395c8528..567f07adf0 100644
--- a/runtime/jit/jit.cc
+++ b/runtime/jit/jit.cc
@@ -1401,6 +1401,15 @@ void Jit::EnqueueOptimizedCompilation(ArtMethod* method, Thread* self) {
     return;
   }
 
+  const void* entry_point = method->GetEntryPointFromQuickCompiledCode();
+  // Check if we already have optimized code. We might still be executing baseline code even
+  // when we have optimized code.
+  if (GetCodeCache()->ContainsPc(entry_point) &&
+      !CodeInfo::IsBaseline(
+          OatQuickMethodHeader::FromEntryPoint(entry_point)->GetOptimizedCodeInfoPtr())) {
+    return;
+  }
+
   // We arrive here after a baseline compiled code has reached its baseline
   // hotness threshold. If we're not only using the baseline compiler, enqueue a compilation
   // task that will compile optimize the method.
diff --git a/runtime/jit/jit_code_cache-inl.h b/runtime/jit/jit_code_cache-inl.h
new file mode 100644
index 0000000000..fab2073e55
--- /dev/null
+++ b/runtime/jit/jit_code_cache-inl.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_JIT_JIT_CODE_CACHE_INL_H_
+#define ART_RUNTIME_JIT_JIT_CODE_CACHE_INL_H_
+
+#include "jit/jit_code_cache.h"
+
+#include "base/macros.h"
+#include "read_barrier.h"
+#include "thread.h"
+#include "well_known_classes-inl.h"
+
+namespace art HIDDEN {
+
+class ArtMethod;
+
+namespace jit {
+
+template<typename RootVisitorType>
+EXPORT void JitCodeCache::VisitRootTables(ArtMethod* method, RootVisitorType& visitor) {
+  if (method->IsNative()) {
+    return;
+  }
+
+  Thread* self = Thread::Current();
+  ScopedDebugDisallowReadBarriers sddrb(self);
+  MutexLock mu(self, *Locks::jit_lock_);
+
+  auto code_ptrs_it = method_code_map_reversed_.find(method);
+  if (code_ptrs_it == method_code_map_reversed_.end()) {
+    return;
+  }
+
+  const std::vector<const void*>& code_ptrs = code_ptrs_it->second;
+
+  for (const void* code_ptr : code_ptrs) {
+    uint32_t number_of_roots = 0;
+    const uint8_t* root_table = GetRootTable(code_ptr, &number_of_roots);
+    uint8_t* roots_data = private_region_.IsInDataSpace(root_table)
+        ? private_region_.GetWritableDataAddress(root_table)
+        : shared_region_.GetWritableDataAddress(root_table);
+    GcRoot<mirror::Object>* roots = reinterpret_cast<GcRoot<mirror::Object>*>(roots_data);
+    for (uint32_t i = 0; i < number_of_roots; ++i) {
+      // This does not need a read barrier because this is called by GC.
+      mirror::Object* object = roots[i].Read<kWithoutReadBarrier>();
+      if (object == nullptr ||
+          object == Runtime::GetWeakClassSentinel() ||
+          object->IsString<kDefaultVerifyFlags>() ||
+          object->IsClass<kDefaultVerifyFlags>()) {
+        continue;
+      }
+      // We don't need to visit j.l.Class and j.l.String and the only remaining possible
+      // objects are MethodType-s.
+      ObjPtr<mirror::Class> method_type_class =
+          WellKnownClasses::java_lang_invoke_MethodType.Get<kWithoutReadBarrier>();
+      ObjPtr<mirror::Class> klass =
+          object->GetClass<kDefaultVerifyFlags, kWithoutReadBarrier>();
+      DCHECK(klass == method_type_class ||
+             klass == ReadBarrier::IsMarked(method_type_class.Ptr()) ||
+             ReadBarrier::IsMarked(klass.Ptr()) == method_type_class);
+
+      visitor.VisitRoot(roots[i].AddressWithoutBarrier());
+    }
+  }
+}
+
+}  // namespace jit
+}  // namespace art
+
+#endif  // ART_RUNTIME_JIT_JIT_CODE_CACHE_INL_H_
+
+
diff --git a/runtime/jit/jit_code_cache.cc b/runtime/jit/jit_code_cache.cc
index 4b69dc5c01..2b83eff44f 100644
--- a/runtime/jit/jit_code_cache.cc
+++ b/runtime/jit/jit_code_cache.cc
@@ -50,6 +50,7 @@
 #include "jit/profiling_info.h"
 #include "jit/jit_scoped_code_cache_write.h"
 #include "linear_alloc.h"
+#include "mirror/method_type.h"
 #include "oat/oat_file-inl.h"
 #include "oat/oat_quick_method_header.h"
 #include "object_callbacks.h"
@@ -59,6 +60,7 @@
 #include "thread-current-inl.h"
 #include "thread-inl.h"
 #include "thread_list.h"
+#include "well_known_classes-inl.h"
 
 namespace art HIDDEN {
 namespace jit {
@@ -294,7 +296,7 @@ bool JitCodeCache::ContainsPc(const void* ptr) const {
 bool JitCodeCache::ContainsMethod(ArtMethod* method) {
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
+  ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
   if (UNLIKELY(method->IsNative())) {
     auto it = jni_stubs_map_.find(JniStubKey(method));
     if (it != jni_stubs_map_.end() &&
@@ -319,7 +321,7 @@ const void* JitCodeCache::GetJniStubCode(ArtMethod* method) {
   DCHECK(method->IsNative());
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
+  ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
   auto it = jni_stubs_map_.find(JniStubKey(method));
   if (it != jni_stubs_map_.end()) {
     JniStubData& data = it->second;
@@ -338,7 +340,7 @@ const void* JitCodeCache::GetSavedEntryPointOfPreCompiledMethod(ArtMethod* metho
     if (method->GetDeclaringClass<kWithoutReadBarrier>()->IsBootStrapClassLoaded()) {
       code_ptr = zygote_map_.GetCodeFor(method);
     } else {
-      MutexLock mu(self, *Locks::jit_lock_);
+      WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
       auto it = saved_compiled_methods_map_.find(method);
       if (it != saved_compiled_methods_map_.end()) {
         code_ptr = it->second;
@@ -400,52 +402,67 @@ static void DCheckRootsAreValid(const std::vector<Handle<mirror::Object>>& roots
   }
 }
 
-static const uint8_t* GetRootTable(const void* code_ptr, uint32_t* number_of_roots = nullptr) {
-  OatQuickMethodHeader* method_header = OatQuickMethodHeader::FromCodePointer(code_ptr);
-  uint8_t* data = method_header->GetOptimizedCodeInfoPtr();
-  uint32_t roots = GetNumberOfRoots(data);
-  if (number_of_roots != nullptr) {
-    *number_of_roots = roots;
-  }
-  return data - ComputeRootTableSize(roots);
-}
-
 void JitCodeCache::SweepRootTables(IsMarkedVisitor* visitor) {
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
-  for (const auto& entry : method_code_map_) {
-    uint32_t number_of_roots = 0;
-    const uint8_t* root_table = GetRootTable(entry.first, &number_of_roots);
-    uint8_t* roots_data = private_region_.IsInDataSpace(root_table)
-        ? private_region_.GetWritableDataAddress(root_table)
-        : shared_region_.GetWritableDataAddress(root_table);
-    GcRoot<mirror::Object>* roots = reinterpret_cast<GcRoot<mirror::Object>*>(roots_data);
-    for (uint32_t i = 0; i < number_of_roots; ++i) {
-      // This does not need a read barrier because this is called by GC.
-      mirror::Object* object = roots[i].Read<kWithoutReadBarrier>();
-      if (object == nullptr || object == Runtime::GetWeakClassSentinel()) {
-        // entry got deleted in a previous sweep.
-      } else if (object->IsString<kDefaultVerifyFlags>()) {
-        mirror::Object* new_object = visitor->IsMarked(object);
-        // We know the string is marked because it's a strongly-interned string that
-        // is always alive.
-        // TODO: Do not use IsMarked for j.l.Class, and adjust once we move this method
-        // out of the weak access/creation pause. b/32167580
-        DCHECK_NE(new_object, nullptr) << "old-string:" << object;
-        if (new_object != object) {
-          roots[i] = GcRoot<mirror::Object>(new_object);
-        }
-      } else {
-        mirror::Object* new_klass = visitor->IsMarked(object);
-        if (new_klass == nullptr) {
-          roots[i] = GcRoot<mirror::Object>(Runtime::GetWeakClassSentinel());
-        } else if (new_klass != object) {
-          roots[i] = GcRoot<mirror::Object>(new_klass);
+  {
+    ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
+    for (const auto& entry : method_code_map_) {
+      uint32_t number_of_roots = 0;
+      const uint8_t* root_table = GetRootTable(entry.first, &number_of_roots);
+      uint8_t* roots_data = private_region_.IsInDataSpace(root_table)
+          ? private_region_.GetWritableDataAddress(root_table)
+          : shared_region_.GetWritableDataAddress(root_table);
+      GcRoot<mirror::Object>* roots = reinterpret_cast<GcRoot<mirror::Object>*>(roots_data);
+      for (uint32_t i = 0; i < number_of_roots; ++i) {
+        // This does not need a read barrier because this is called by GC.
+        mirror::Object* object = roots[i].Read<kWithoutReadBarrier>();
+        if (object == nullptr || object == Runtime::GetWeakClassSentinel()) {
+          // entry got deleted in a previous sweep.
+        } else if (object->IsString<kDefaultVerifyFlags>()) {
+          mirror::Object* new_object = visitor->IsMarked(object);
+          // We know the string is marked because it's a strongly-interned string that
+          // is always alive.
+          // TODO: Do not use IsMarked for j.l.Class, and adjust once we move this method
+          // out of the weak access/creation pause. b/32167580
+          DCHECK_NE(new_object, nullptr) << "old-string:" << object;
+          if (new_object != object) {
+            roots[i] = GcRoot<mirror::Object>(new_object);
+          }
+        } else if (object->IsClass<kDefaultVerifyFlags>()) {
+          mirror::Object* new_klass = visitor->IsMarked(object);
+          if (new_klass == nullptr) {
+            roots[i] = GcRoot<mirror::Object>(Runtime::GetWeakClassSentinel());
+          } else if (new_klass != object) {
+            roots[i] = GcRoot<mirror::Object>(new_klass);
+          }
+        } else {
+          mirror::Object* new_method_type = visitor->IsMarked(object);
+          if (kIsDebugBuild) {
+            if (new_method_type != nullptr) {
+              // SweepSystemWeaks() is happening in the compaction pause. At that point
+              // IsMarked(object) returns the moved address, but the content is not there yet.
+              if (!Runtime::Current()->GetHeap()->IsPerformingUffdCompaction()) {
+                ObjPtr<mirror::Class> method_type_class =
+                    WellKnownClasses::java_lang_invoke_MethodType.Get<kWithoutReadBarrier>();
+
+                CHECK_EQ((new_method_type->GetClass<kVerifyNone, kWithoutReadBarrier>()),
+                         method_type_class.Ptr());
+              }
+            }
+          }
+          if (new_method_type == nullptr) {
+            roots[i] = nullptr;
+          } else if (new_method_type != object) {
+            // References are updated in VisitRootTables. Reaching this means that ArtMethod is no
+            // longer reachable.
+            roots[i] = GcRoot<mirror::Object>(new_method_type);
+          }
         }
       }
     }
   }
+  MutexLock mu(self, *Locks::jit_lock_);
   // Walk over inline caches to clear entries containing unloaded classes.
   for (const auto& [_, info] : profiling_infos_) {
     InlineCache* caches = info->GetInlineCaches();
@@ -505,6 +522,7 @@ void JitCodeCache::FreeAllMethodHeaders(
   if (kIsDebugBuild && !Runtime::Current()->IsZygote()) {
     std::map<const void*, ArtMethod*> compiled_methods;
     std::set<const void*> debug_info;
+    ReaderMutexLock mu2(Thread::Current(), *Locks::jit_mutator_lock_);
     VisitAllMethods([&](const void* addr, ArtMethod* method) {
       if (!IsInZygoteExecSpace(addr)) {
         CHECK(addr != nullptr && method != nullptr);
@@ -535,10 +553,11 @@ void JitCodeCache::RemoveMethodsIn(Thread* self, const LinearAlloc& alloc) {
   // the CHA dependency map just once with an unordered_set.
   std::unordered_set<OatQuickMethodHeader*> method_headers;
   MutexLock mu(self, *Locks::jit_lock_);
-  // We do not check if a code cache GC is in progress, as this method comes
-  // with the classlinker_classes_lock_ held, and suspending ourselves could
-  // lead to a deadlock.
   {
+    WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
+    // We do not check if a code cache GC is in progress, as this method comes
+    // with the classlinker_classes_lock_ held, and suspending ourselves could
+    // lead to a deadlock.
     for (auto it = jni_stubs_map_.begin(); it != jni_stubs_map_.end();) {
       it->second.RemoveMethodsIn(alloc);
       if (it->second.GetMethods().empty()) {
@@ -556,35 +575,38 @@ void JitCodeCache::RemoveMethodsIn(Thread* self, const LinearAlloc& alloc) {
         ++it;
       }
     }
-    for (auto it = processed_zombie_jni_code_.begin(); it != processed_zombie_jni_code_.end();) {
-      if (alloc.ContainsUnsafe(*it)) {
-        it = processed_zombie_jni_code_.erase(it);
-      } else {
-        ++it;
-      }
-    }
     for (auto it = method_code_map_.begin(); it != method_code_map_.end();) {
       if (alloc.ContainsUnsafe(it->second)) {
         method_headers.insert(OatQuickMethodHeader::FromCodePointer(it->first));
         VLOG(jit) << "JIT removed " << it->second->PrettyMethod() << ": " << it->first;
         zombie_code_.erase(it->first);
         processed_zombie_code_.erase(it->first);
+        method_code_map_reversed_.erase(it->second);
         it = method_code_map_.erase(it);
       } else {
         ++it;
       }
     }
+    for (auto it = osr_code_map_.begin(); it != osr_code_map_.end();) {
+      DCHECK(!ContainsElement(zombie_code_, it->second));
+      if (alloc.ContainsUnsafe(it->first)) {
+        // Note that the code has already been pushed to method_headers in the loop
+        // above and is going to be removed in FreeCode() below.
+        it = osr_code_map_.erase(it);
+      } else {
+        ++it;
+      }
+    }
   }
-  for (auto it = osr_code_map_.begin(); it != osr_code_map_.end();) {
-    DCHECK(!ContainsElement(zombie_code_, it->second));
-    if (alloc.ContainsUnsafe(it->first)) {
-      // Note that the code has already been pushed to method_headers in the loop
-      // above and is going to be removed in FreeCode() below.
-      it = osr_code_map_.erase(it);
+
+  for (auto it = processed_zombie_jni_code_.begin(); it != processed_zombie_jni_code_.end();) {
+    if (alloc.ContainsUnsafe(*it)) {
+      it = processed_zombie_jni_code_.erase(it);
     } else {
       ++it;
     }
   }
+
   for (auto it = profiling_infos_.begin(); it != profiling_infos_.end();) {
     ProfilingInfo* info = it->second;
     if (alloc.ContainsUnsafe(info->GetMethod())) {
@@ -614,6 +636,16 @@ void JitCodeCache::WaitUntilInlineCacheAccessible(Thread* self) {
   }
 }
 
+const uint8_t* JitCodeCache::GetRootTable(const void* code_ptr, uint32_t* number_of_roots) {
+  OatQuickMethodHeader* method_header = OatQuickMethodHeader::FromCodePointer(code_ptr);
+  uint8_t* data = method_header->GetOptimizedCodeInfoPtr();
+  uint32_t num_roots = GetNumberOfRoots(data);
+  if (number_of_roots != nullptr) {
+    *number_of_roots = num_roots;
+  }
+  return data - ComputeRootTableSize(num_roots);
+}
+
 void JitCodeCache::BroadcastForInlineCacheAccess() {
   Thread* self = Thread::Current();
   MutexLock mu(self, *Locks::jit_lock_);
@@ -740,6 +772,7 @@ bool JitCodeCache::Commit(Thread* self,
 
     if (UNLIKELY(method->IsNative())) {
       ScopedDebugDisallowReadBarriers sddrb(self);
+      WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
       auto it = jni_stubs_map_.find(JniStubKey(method));
       DCHECK(it != jni_stubs_map_.end())
           << "Entry inserted in NotifyCompilationOf() should be alive.";
@@ -754,10 +787,31 @@ bool JitCodeCache::Commit(Thread* self,
         zygote_map_.Put(code_ptr, method);
       } else {
         ScopedDebugDisallowReadBarriers sddrb(self);
+        WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
         method_code_map_.Put(code_ptr, method);
+
+        // Searching for MethodType-s in roots. They need to be treated as strongly reachable while
+        // the corresponding ArtMethod is not removed.
+        ObjPtr<mirror::Class> method_type_class =
+            WellKnownClasses::java_lang_invoke_MethodType.Get<kWithoutReadBarrier>();
+
+        for (const Handle<mirror::Object>& root : roots) {
+          ObjPtr<mirror::Class> klass = root->GetClass<kDefaultVerifyFlags, kWithoutReadBarrier>();
+          if (klass == method_type_class ||
+              klass == ReadBarrier::IsMarked(method_type_class.Ptr()) ||
+              ReadBarrier::IsMarked(klass.Ptr()) == method_type_class) {
+            auto it = method_code_map_reversed_.FindOrAdd(method, std::vector<const void*>());
+            std::vector<const void*>& code_ptrs = it->second;
+
+            DCHECK(std::find(code_ptrs.begin(), code_ptrs.end(), code_ptr) == code_ptrs.end());
+            it->second.emplace_back(code_ptr);
+            break;
+          }
+        }
       }
       if (compilation_kind == CompilationKind::kOsr) {
         ScopedDebugDisallowReadBarriers sddrb(self);
+        WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
         osr_code_map_.Put(method, code_ptr);
       } else if (method->StillNeedsClinitCheck()) {
         ScopedDebugDisallowReadBarriers sddrb(self);
@@ -767,6 +821,7 @@ bool JitCodeCache::Commit(Thread* self,
         // The shared region can easily be queried. For the private region, we
         // use a side map.
         if (!IsSharedRegion(*region)) {
+          WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
           saved_compiled_methods_map_.Put(method, code_ptr);
         }
       } else {
@@ -806,7 +861,6 @@ bool JitCodeCache::RemoveMethod(ArtMethod* method, bool release_memory) {
   ScopedDebugDisallowReadBarriers sddrb(self);
   MutexLock mu(self, *Locks::jit_lock_);
 
-  bool osr = osr_code_map_.find(method) != osr_code_map_.end();
   bool in_cache = RemoveMethodLocked(method, release_memory);
 
   if (!in_cache) {
@@ -814,11 +868,6 @@ bool JitCodeCache::RemoveMethod(ArtMethod* method, bool release_memory) {
   }
 
   Runtime::Current()->GetInstrumentation()->InitializeMethodsCode(method, /*aot_code=*/ nullptr);
-  VLOG(jit)
-      << "JIT removed (osr=" << std::boolalpha << osr << std::noboolalpha << ") "
-      << ArtMethod::PrettyMethod(method) << "@" << method
-      << " ccache_size=" << PrettySize(CodeCacheSizeLocked()) << ": "
-      << " dcache_size=" << PrettySize(DataCacheSizeLocked());
   return true;
 }
 
@@ -832,6 +881,7 @@ bool JitCodeCache::RemoveMethodLocked(ArtMethod* method, bool release_memory) {
 
   bool in_cache = false;
   ScopedCodeCacheWrite ccw(private_region_);
+  WriterMutexLock mu(Thread::Current(), *Locks::jit_mutator_lock_);
   if (UNLIKELY(method->IsNative())) {
     auto it = jni_stubs_map_.find(JniStubKey(method));
     if (it != jni_stubs_map_.end() && it->second.RemoveMethod(method)) {
@@ -859,6 +909,7 @@ bool JitCodeCache::RemoveMethodLocked(ArtMethod* method, bool release_memory) {
         ++it;
       }
     }
+    method_code_map_reversed_.erase(method);
 
     auto osr_it = osr_code_map_.find(method);
     if (osr_it != osr_code_map_.end()) {
@@ -888,7 +939,7 @@ void JitCodeCache::NotifyMethodRedefined(ArtMethod* method) {
 void JitCodeCache::MoveObsoleteMethod(ArtMethod* old_method, ArtMethod* new_method) {
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
+  WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
   if (old_method->IsNative()) {
     // Update methods in jni_stubs_map_.
     for (auto& entry : jni_stubs_map_) {
@@ -897,6 +948,7 @@ void JitCodeCache::MoveObsoleteMethod(ArtMethod* old_method, ArtMethod* new_meth
     }
     return;
   }
+
   // Update method_code_map_ to point to the new method.
   for (auto& it : method_code_map_) {
     if (it.second == old_method) {
@@ -909,6 +961,12 @@ void JitCodeCache::MoveObsoleteMethod(ArtMethod* old_method, ArtMethod* new_meth
     osr_code_map_.Put(new_method, code_map->second);
     osr_code_map_.erase(old_method);
   }
+
+  auto node = method_code_map_reversed_.extract(old_method);
+  if (!node.empty()) {
+    node.key() = new_method;
+    method_code_map_reversed_.insert(std::move(node));
+  }
 }
 
 void JitCodeCache::TransitionToDebuggable() {
@@ -917,16 +975,17 @@ void JitCodeCache::TransitionToDebuggable() {
   // ClassLinker::UpdateEntryPointsClassVisitor.
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  {
-    MutexLock mu(self, *Locks::jit_lock_);
-    if (kIsDebugBuild) {
-      // TODO: Check `jni_stubs_map_`?
-      for (const auto& entry : method_code_map_) {
-        ArtMethod* method = entry.second;
-        DCHECK(!method->IsPreCompiled());
-        DCHECK(!IsInZygoteExecSpace(method->GetEntryPointFromQuickCompiledCode()));
-      }
+  if (kIsDebugBuild) {
+    // TODO: Check `jni_stubs_map_`?
+    ReaderMutexLock mu2(self, *Locks::jit_mutator_lock_);
+    for (const auto& entry : method_code_map_) {
+      ArtMethod* method = entry.second;
+      DCHECK(!method->IsPreCompiled());
+      DCHECK(!IsInZygoteExecSpace(method->GetEntryPointFromQuickCompiledCode()));
     }
+  }
+  {
+    WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
     // Not strictly necessary, but this map is useless now.
     saved_compiled_methods_map_.clear();
   }
@@ -1108,12 +1167,32 @@ void JitCodeCache::RemoveUnmarkedCode(Thread* self) {
     } else {
       OatQuickMethodHeader* header = OatQuickMethodHeader::FromCodePointer(code_ptr);
       method_headers.insert(header);
-      method_code_map_.erase(header->GetCode());
+      {
+        WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
+        auto method_it = method_code_map_.find(header->GetCode());
+
+        if (method_it != method_code_map_.end()) {
+          ArtMethod* method = method_it->second;
+          auto code_ptrs_it = method_code_map_reversed_.find(method);
+
+          if (code_ptrs_it != method_code_map_reversed_.end()) {
+            std::vector<const void*>& code_ptrs = code_ptrs_it->second;
+            RemoveElement(code_ptrs, code_ptr);
+
+            if (code_ptrs.empty()) {
+              method_code_map_reversed_.erase(code_ptrs_it);
+            }
+          }
+        }
+
+        method_code_map_.erase(header->GetCode());
+      }
       VLOG(jit) << "JIT removed " << *it;
       it = processed_zombie_code_.erase(it);
     }
   }
   for (auto it = processed_zombie_jni_code_.begin(); it != processed_zombie_jni_code_.end();) {
+    WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
     ArtMethod* method = *it;
     auto stub = jni_stubs_map_.find(JniStubKey(method));
     if (stub == jni_stubs_map_.end()) {
@@ -1147,51 +1226,52 @@ void JitCodeCache::RemoveUnmarkedCode(Thread* self) {
   FreeAllMethodHeaders(method_headers);
 }
 
+class JitGcTask final : public Task {
+ public:
+  JitGcTask() {}
+
+  void Run(Thread* self) override {
+    Runtime::Current()->GetJit()->GetCodeCache()->DoCollection(self);
+  }
+
+  void Finalize() override {
+    delete this;
+  }
+};
+
 void JitCodeCache::AddZombieCode(ArtMethod* method, const void* entry_point) {
   CHECK(ContainsPc(entry_point));
   CHECK(method->IsNative() || (method->GetEntryPointFromQuickCompiledCode() != entry_point));
   const void* code_ptr = OatQuickMethodHeader::FromEntryPoint(entry_point)->GetCode();
   if (!IsInZygoteExecSpace(code_ptr)) {
     Thread* self = Thread::Current();
-    if (Locks::jit_lock_->IsExclusiveHeld(self)) {
+    if (Locks::jit_mutator_lock_->IsExclusiveHeld(self)) {
       AddZombieCodeInternal(method, code_ptr);
     } else {
-      MutexLock mu(Thread::Current(), *Locks::jit_lock_);
+      WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
       AddZombieCodeInternal(method, code_ptr);
     }
   }
 }
 
 
-class JitGcTask final : public Task {
- public:
-  JitGcTask() {}
-
-  void Run(Thread* self) override {
-    Runtime::Current()->GetJit()->GetCodeCache()->DoCollection(self);
-  }
-
-  void Finalize() override {
-    delete this;
-  }
-};
-
 void JitCodeCache::AddZombieCodeInternal(ArtMethod* method, const void* code_ptr) {
   if (method->IsNative()) {
-    CHECK(jni_stubs_map_.find(JniStubKey(method)) != jni_stubs_map_.end());
     zombie_jni_code_.insert(method);
   } else {
     CHECK(!ContainsElement(zombie_code_, code_ptr));
     zombie_code_.insert(code_ptr);
   }
+
   // Arbitrary threshold of number of zombie code before doing a GC.
   static constexpr size_t kNumberOfZombieCodeThreshold = kIsDebugBuild ? 1 : 1000;
   size_t number_of_code_to_delete =
       zombie_code_.size() + zombie_jni_code_.size() + osr_code_map_.size();
   if (number_of_code_to_delete >= kNumberOfZombieCodeThreshold) {
     JitThreadPool* pool = Runtime::Current()->GetJit()->GetThreadPool();
-    if (pool != nullptr && !gc_task_scheduled_) {
-      gc_task_scheduled_ = true;
+    if (pool != nullptr && !std::atomic_exchange_explicit(&gc_task_scheduled_,
+                                                          true,
+                                                          std::memory_order_relaxed)) {
       pool->AddTask(Thread::Current(), new JitGcTask());
     }
   }
@@ -1252,16 +1332,19 @@ void JitCodeCache::DoCollection(Thread* self) {
           reinterpret_cast<uintptr_t>(private_region_.GetExecPages()->Begin()),
           reinterpret_cast<uintptr_t>(
               private_region_.GetExecPages()->Begin() + private_region_.GetCurrentCapacity() / 2)));
-    processed_zombie_code_.insert(zombie_code_.begin(), zombie_code_.end());
-    zombie_code_.clear();
-    processed_zombie_jni_code_.insert(zombie_jni_code_.begin(), zombie_jni_code_.end());
-    zombie_jni_code_.clear();
-    // Empty osr method map, as osr compiled code will be deleted (except the ones
-    // on thread stacks).
-    for (auto it = osr_code_map_.begin(); it != osr_code_map_.end(); ++it) {
-      processed_zombie_code_.insert(it->second);
+    {
+      WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
+      processed_zombie_code_.insert(zombie_code_.begin(), zombie_code_.end());
+      zombie_code_.clear();
+      processed_zombie_jni_code_.insert(zombie_jni_code_.begin(), zombie_jni_code_.end());
+      zombie_jni_code_.clear();
+      // Empty osr method map, as osr compiled code will be deleted (except the ones
+      // on thread stacks).
+      for (auto it = osr_code_map_.begin(); it != osr_code_map_.end(); ++it) {
+        processed_zombie_code_.insert(it->second);
+      }
+      osr_code_map_.clear();
     }
-    osr_code_map_.clear();
   }
   TimingLogger logger("JIT code cache timing logger", true, VLOG_IS_ON(jit));
   {
@@ -1276,20 +1359,16 @@ void JitCodeCache::DoCollection(Thread* self) {
       RemoveUnmarkedCode(self);
     }
 
+    gc_task_scheduled_ = false;
     MutexLock mu(self, *Locks::jit_lock_);
     live_bitmap_.reset(nullptr);
-    NotifyCollectionDone(self);
+    collection_in_progress_ = false;
+    lock_cond_.Broadcast(self);
   }
 
   Runtime::Current()->GetJit()->AddTimingLogger(logger);
 }
 
-void JitCodeCache::NotifyCollectionDone(Thread* self) {
-  collection_in_progress_ = false;
-  gc_task_scheduled_ = false;
-  lock_cond_.Broadcast(self);
-}
-
 OatQuickMethodHeader* JitCodeCache::LookupMethodHeader(uintptr_t pc, ArtMethod* method) {
   static_assert(kRuntimeISA != InstructionSet::kThumb2, "kThumb2 cannot be a runtime ISA");
   const void* pc_ptr = reinterpret_cast<const void*>(pc);
@@ -1304,10 +1383,10 @@ OatQuickMethodHeader* JitCodeCache::LookupMethodHeader(uintptr_t pc, ArtMethod*
 
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
   OatQuickMethodHeader* method_header = nullptr;
   ArtMethod* found_method = nullptr;  // Only for DCHECK(), not for JNI stubs.
   if (method != nullptr && UNLIKELY(method->IsNative())) {
+    ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
     auto it = jni_stubs_map_.find(JniStubKey(method));
     if (it == jni_stubs_map_.end()) {
       return nullptr;
@@ -1331,19 +1410,23 @@ OatQuickMethodHeader* JitCodeCache::LookupMethodHeader(uintptr_t pc, ArtMethod*
         return OatQuickMethodHeader::FromCodePointer(code_ptr);
       }
     }
-    auto it = method_code_map_.lower_bound(pc_ptr);
-    if ((it == method_code_map_.end() || it->first != pc_ptr) &&
-        it != method_code_map_.begin()) {
-      --it;
-    }
-    if (it != method_code_map_.end()) {
-      const void* code_ptr = it->first;
-      if (OatQuickMethodHeader::FromCodePointer(code_ptr)->Contains(pc)) {
-        method_header = OatQuickMethodHeader::FromCodePointer(code_ptr);
-        found_method = it->second;
+    {
+      ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
+      auto it = method_code_map_.lower_bound(pc_ptr);
+      if ((it == method_code_map_.end() || it->first != pc_ptr) &&
+          it != method_code_map_.begin()) {
+        --it;
+      }
+      if (it != method_code_map_.end()) {
+        const void* code_ptr = it->first;
+        if (OatQuickMethodHeader::FromCodePointer(code_ptr)->Contains(pc)) {
+          method_header = OatQuickMethodHeader::FromCodePointer(code_ptr);
+          found_method = it->second;
+        }
       }
     }
     if (method_header == nullptr && method == nullptr) {
+      ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
       // Scan all compiled JNI stubs as well. This slow search is used only
       // for checks in debug build, for release builds the `method` is not null.
       for (auto&& entry : jni_stubs_map_) {
@@ -1371,7 +1454,7 @@ OatQuickMethodHeader* JitCodeCache::LookupMethodHeader(uintptr_t pc, ArtMethod*
 OatQuickMethodHeader* JitCodeCache::LookupOsrMethodHeader(ArtMethod* method) {
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
+  ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
   auto it = osr_code_map_.find(method);
   if (it == osr_code_map_.end()) {
     return nullptr;
@@ -1444,7 +1527,8 @@ void JitCodeCache::GetProfiledMethods(const std::set<std::string>& dex_base_loca
   Runtime::Current()->GetClassLinker()->GetClassLoaders(self, &handles);
 
   // Wait for any GC to be complete, to prevent looking at ArtMethods whose
-  // class loader is being deleted.
+  // class loader is being deleted. Since we remain runnable, another new GC
+  // can't get far.
   Runtime::Current()->GetHeap()->WaitForGcToComplete(gc::kGcCauseProfileSaver, self);
 
   // We'll be looking at inline caches, so ensure they are accessible.
@@ -1455,6 +1539,7 @@ void JitCodeCache::GetProfiledMethods(const std::set<std::string>& dex_base_loca
   {
     MutexLock mu(self, *Locks::jit_lock_);
     profiling_infos = profiling_infos_;
+    ReaderMutexLock mu2(self, *Locks::jit_mutator_lock_);
     for (const auto& entry : method_code_map_) {
       copies.push_back(entry.second);
     }
@@ -1549,7 +1634,7 @@ void JitCodeCache::GetProfiledMethods(const std::set<std::string>& dex_base_loca
 bool JitCodeCache::IsOsrCompiled(ArtMethod* method) {
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
+  ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
   return osr_code_map_.find(method) != osr_code_map_.end();
 }
 
@@ -1590,15 +1675,15 @@ bool JitCodeCache::NotifyCompilationOf(ArtMethod* method,
 
   ScopedDebugDisallowReadBarriers sddrb(self);
   if (compilation_kind == CompilationKind::kOsr) {
-    MutexLock mu(self, *Locks::jit_lock_);
+    ReaderMutexLock mu(self, *Locks::jit_mutator_lock_);
     if (osr_code_map_.find(method) != osr_code_map_.end()) {
       return false;
     }
   }
 
   if (UNLIKELY(method->IsNative())) {
-    MutexLock mu(self, *Locks::jit_lock_);
     JniStubKey key(method);
+    WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
     auto it = jni_stubs_map_.find(key);
     bool new_compilation = false;
     if (it == jni_stubs_map_.end()) {
@@ -1652,8 +1737,8 @@ void JitCodeCache::DoneCompilerUse(ArtMethod* method, Thread* self) {
 void JitCodeCache::DoneCompiling(ArtMethod* method, Thread* self) {
   DCHECK_EQ(Thread::Current(), self);
   ScopedDebugDisallowReadBarriers sddrb(self);
-  MutexLock mu(self, *Locks::jit_lock_);
   if (UNLIKELY(method->IsNative())) {
+    WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
     auto it = jni_stubs_map_.find(JniStubKey(method));
     DCHECK(it != jni_stubs_map_.end());
     JniStubData* data = &it->second;
@@ -1668,33 +1753,38 @@ void JitCodeCache::DoneCompiling(ArtMethod* method, Thread* self) {
 void JitCodeCache::InvalidateAllCompiledCode() {
   Thread* self = Thread::Current();
   ScopedDebugDisallowReadBarriers sddrb(self);
-  art::MutexLock mu(self, *Locks::jit_lock_);
   VLOG(jit) << "Invalidating all compiled code";
   Runtime* runtime = Runtime::Current();
   ClassLinker* linker = runtime->GetClassLinker();
   instrumentation::Instrumentation* instr = runtime->GetInstrumentation();
 
-  // Change entry points of native methods back to the GenericJNI entrypoint.
-  for (const auto& entry : jni_stubs_map_) {
-    const JniStubData& data = entry.second;
-    if (!data.IsCompiled() || IsInZygoteExecSpace(data.GetCode())) {
-      continue;
-    }
-    const OatQuickMethodHeader* method_header =
-        OatQuickMethodHeader::FromCodePointer(data.GetCode());
-    for (ArtMethod* method : data.GetMethods()) {
-      if (method->GetEntryPointFromQuickCompiledCode() == method_header->GetEntryPoint()) {
-        instr->InitializeMethodsCode(method, /*aot_code=*/ nullptr);
+  {
+    WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
+    // Change entry points of native methods back to the GenericJNI entrypoint.
+    for (const auto& entry : jni_stubs_map_) {
+      const JniStubData& data = entry.second;
+      if (!data.IsCompiled() || IsInZygoteExecSpace(data.GetCode())) {
+        continue;
+      }
+      const OatQuickMethodHeader* method_header =
+          OatQuickMethodHeader::FromCodePointer(data.GetCode());
+      for (ArtMethod* method : data.GetMethods()) {
+        if (method->GetEntryPointFromQuickCompiledCode() == method_header->GetEntryPoint()) {
+          instr->InitializeMethodsCode(method, /*aot_code=*/ nullptr);
+        }
       }
     }
-  }
-  for (const auto& entry : method_code_map_) {
-    ArtMethod* meth = entry.second;
-    if (UNLIKELY(meth->IsObsolete())) {
-      linker->SetEntryPointsForObsoleteMethod(meth);
-    } else {
-      instr->InitializeMethodsCode(meth, /*aot_code=*/ nullptr);
+
+    for (const auto& entry : method_code_map_) {
+      ArtMethod* meth = entry.second;
+      if (UNLIKELY(meth->IsObsolete())) {
+        linker->SetEntryPointsForObsoleteMethod(meth);
+      } else {
+        instr->InitializeMethodsCode(meth, /*aot_code=*/ nullptr);
+      }
     }
+    osr_code_map_.clear();
+    saved_compiled_methods_map_.clear();
   }
 
   for (const auto& entry : zygote_map_) {
@@ -1706,9 +1796,6 @@ void JitCodeCache::InvalidateAllCompiledCode() {
     }
     instr->InitializeMethodsCode(entry.method, /*aot_code=*/nullptr);
   }
-
-  saved_compiled_methods_map_.clear();
-  osr_code_map_.clear();
 }
 
 void JitCodeCache::InvalidateCompiledCodeFor(ArtMethod* method,
@@ -1724,7 +1811,7 @@ void JitCodeCache::InvalidateCompiledCodeFor(ArtMethod* method,
   } else {
     Thread* self = Thread::Current();
     ScopedDebugDisallowReadBarriers sddrb(self);
-    MutexLock mu(self, *Locks::jit_lock_);
+    WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
     auto it = osr_code_map_.find(method);
     if (it != osr_code_map_.end() && OatQuickMethodHeader::FromCodePointer(it->second) == header) {
       // Remove the OSR method, to avoid using it again.
@@ -1755,6 +1842,7 @@ void JitCodeCache::Dump(std::ostream& os) {
        << shared_region_.GetUsedMemoryForData() / KB << "KB / "
        << shared_region_.GetResidentMemoryForData() / KB << "KB\n";
   }
+  ReaderMutexLock mu2(Thread::Current(), *Locks::jit_mutator_lock_);
   os << "Current JIT mini-debug-info size: " << PrettySize(GetJitMiniDebugInfoMemUsage()) << "\n"
      << "Current JIT capacity: " << PrettySize(GetCurrentRegion()->GetCurrentCapacity()) << "\n"
      << "Current number of JIT JNI stub entries: " << jni_stubs_map_.size() << "\n"
@@ -1770,7 +1858,7 @@ void JitCodeCache::Dump(std::ostream& os) {
 }
 
 void JitCodeCache::DumpAllCompiledMethods(std::ostream& os) {
-  MutexLock mu(Thread::Current(), *Locks::jit_lock_);
+  ReaderMutexLock mu(Thread::Current(), *Locks::jit_mutator_lock_);
   for (const auto& [code_ptr, meth] : method_code_map_) {  // Includes OSR methods.
     OatQuickMethodHeader* header = OatQuickMethodHeader::FromCodePointer(code_ptr);
     os << meth->PrettyMethod() << "@"  << std::hex
diff --git a/runtime/jit/jit_code_cache.h b/runtime/jit/jit_code_cache.h
index 3dd57121ca..2d2f841360 100644
--- a/runtime/jit/jit_code_cache.h
+++ b/runtime/jit/jit_code_cache.h
@@ -25,6 +25,7 @@
 #include <unordered_set>
 #include <vector>
 
+#include "android-base/thread_annotations.h"
 #include "base/arena_containers.h"
 #include "base/array_ref.h"
 #include "base/atomic.h"
@@ -356,6 +357,11 @@ class JitCodeCache {
 
   bool IsOsrCompiled(ArtMethod* method) REQUIRES(!Locks::jit_lock_);
 
+  // Visit GC roots (except j.l.Class and j.l.String) held by JIT-ed code.
+  template<typename RootVisitorType>
+  EXPORT void VisitRootTables(ArtMethod* method,
+                              RootVisitorType& visitor) NO_THREAD_SAFETY_ANALYSIS;
+
   void SweepRootTables(IsMarkedVisitor* visitor)
       REQUIRES(!Locks::jit_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
@@ -431,7 +437,7 @@ class JitCodeCache {
   JitCodeCache();
 
   void AddZombieCodeInternal(ArtMethod* method, const void* code_ptr)
-      REQUIRES(Locks::jit_lock_)
+      REQUIRES(Locks::jit_mutator_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   ProfilingInfo* AddProfilingInfoInternal(Thread* self,
@@ -446,9 +452,6 @@ class JitCodeCache {
   bool WaitForPotentialCollectionToComplete(Thread* self)
       REQUIRES(Locks::jit_lock_) REQUIRES_SHARED(!Locks::mutator_lock_);
 
-  // Notify all waiting threads that a collection is done.
-  void NotifyCollectionDone(Thread* self) REQUIRES(Locks::jit_lock_);
-
   // Remove CHA dependents and underlying allocations for entries in `method_headers`.
   void FreeAllMethodHeaders(const std::unordered_set<OatQuickMethodHeader*>& method_headers)
       REQUIRES(Locks::jit_lock_)
@@ -462,7 +465,7 @@ class JitCodeCache {
 
   // Call given callback for every compiled method in the code cache.
   void VisitAllMethods(const std::function<void(const void*, ArtMethod*)>& cb)
-      REQUIRES(Locks::jit_lock_);
+      REQUIRES_SHARED(Locks::jit_mutator_lock_);
 
   // Free code and data allocations for `code_ptr`.
   void FreeCodeAndData(const void* code_ptr)
@@ -508,6 +511,8 @@ class JitCodeCache {
       REQUIRES(!Locks::jit_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  EXPORT const uint8_t* GetRootTable(const void* code_ptr, uint32_t* number_of_roots = nullptr);
+
   class JniStubKey;
   class JniStubData;
 
@@ -544,27 +549,29 @@ class JitCodeCache {
   // before the declaring class memory is freed.
 
   // Holds compiled code associated with the shorty for a JNI stub.
-  SafeMap<JniStubKey, JniStubData> jni_stubs_map_ GUARDED_BY(Locks::jit_lock_);
+  SafeMap<JniStubKey, JniStubData> jni_stubs_map_ GUARDED_BY(Locks::jit_mutator_lock_);
 
   // Holds compiled code associated to the ArtMethod.
-  SafeMap<const void*, ArtMethod*> method_code_map_ GUARDED_BY(Locks::jit_lock_);
+  SafeMap<const void*, ArtMethod*> method_code_map_ GUARDED_BY(Locks::jit_mutator_lock_);
+  // Subset of `method_code_map_`, but keyed by `ArtMethod*`. Used to treat certain
+  // objects (like `MethodType`-s) as strongly reachable from the corresponding ArtMethod.
+  SafeMap<ArtMethod*, std::vector<const void*>> method_code_map_reversed_
+      GUARDED_BY(Locks::jit_mutator_lock_);
 
   // Holds compiled code associated to the ArtMethod. Used when pre-jitting
   // methods whose entrypoints have the resolution stub.
-  SafeMap<ArtMethod*, const void*> saved_compiled_methods_map_ GUARDED_BY(Locks::jit_lock_);
+  SafeMap<ArtMethod*, const void*> saved_compiled_methods_map_ GUARDED_BY(Locks::jit_mutator_lock_);
 
   // Holds osr compiled code associated to the ArtMethod.
-  SafeMap<ArtMethod*, const void*> osr_code_map_ GUARDED_BY(Locks::jit_lock_);
-
-  // ProfilingInfo objects we have allocated.
-  SafeMap<ArtMethod*, ProfilingInfo*> profiling_infos_ GUARDED_BY(Locks::jit_lock_);
+  SafeMap<ArtMethod*, const void*> osr_code_map_ GUARDED_BY(Locks::jit_mutator_lock_);
 
   // Zombie code and JNI methods to consider for collection.
-  std::set<const void*> zombie_code_ GUARDED_BY(Locks::jit_lock_);
-  std::set<ArtMethod*> zombie_jni_code_ GUARDED_BY(Locks::jit_lock_);
+  std::set<const void*> zombie_code_ GUARDED_BY(Locks::jit_mutator_lock_);
+  std::set<ArtMethod*> zombie_jni_code_ GUARDED_BY(Locks::jit_mutator_lock_);
 
-  std::set<const void*> processed_zombie_code_ GUARDED_BY(Locks::jit_lock_);
-  std::set<ArtMethod*> processed_zombie_jni_code_ GUARDED_BY(Locks::jit_lock_);
+  // ProfilingInfo objects we have allocated. Mutators don't need to access
+  // these so this can be guarded by the JIT lock.
+  SafeMap<ArtMethod*, ProfilingInfo*> profiling_infos_ GUARDED_BY(Locks::jit_lock_);
 
   // Methods that the zygote has compiled and can be shared across processes
   // forked from the zygote.
@@ -579,7 +586,7 @@ class JitCodeCache {
   bool collection_in_progress_ GUARDED_BY(Locks::jit_lock_);
 
   // Whether a GC task is already scheduled.
-  bool gc_task_scheduled_ GUARDED_BY(Locks::jit_lock_);
+  std::atomic<bool> gc_task_scheduled_;
 
   // Bitmap for collecting code and data.
   std::unique_ptr<CodeCacheBitmap> live_bitmap_;
@@ -587,6 +594,10 @@ class JitCodeCache {
   // Whether we can do garbage collection. Not 'const' as tests may override this.
   bool garbage_collect_code_ GUARDED_BY(Locks::jit_lock_);
 
+  // Zombie code being processed by the GC.
+  std::set<const void*> processed_zombie_code_ GUARDED_BY(Locks::jit_lock_);
+  std::set<ArtMethod*> processed_zombie_jni_code_ GUARDED_BY(Locks::jit_lock_);
+
   // ---------------- JIT statistics -------------------------------------- //
 
   // Number of baseline compilations done throughout the lifetime of the JIT.
diff --git a/runtime/jit/profile_saver.cc b/runtime/jit/profile_saver.cc
index 3506faaa7f..81cb384f62 100644
--- a/runtime/jit/profile_saver.cc
+++ b/runtime/jit/profile_saver.cc
@@ -124,35 +124,27 @@ void ProfileSaver::Run() {
   // under mutex, but should drop it.
   Locks::profiler_lock_->ExclusiveUnlock(self);
 
-  bool check_for_first_save =
-      options_.GetMinFirstSaveMs() != ProfileSaverOptions::kMinFirstSaveMsNotSet;
-  bool force_early_first_save = check_for_first_save && IsFirstSave();
-
-  // Fetch the resolved classes for the app images after sleeping for
-  // options_.GetSaveResolvedClassesDelayMs().
-  // TODO(calin) This only considers the case of the primary profile file.
-  // Anything that gets loaded in the same VM will not have their resolved
-  // classes save (unless they started before the initial saving was done).
-  {
+  // Fetch the resolved classes for the app images after waiting for Startup
+  // completion notification.
+  const uint64_t thread_start_time = NanoTime();
+
+  // Wait for startup to complete with a timeout at StartupCompletedTask.
+  // Note that we may be woken up by JIT notifications.
+  // We need to wait for startup to complete to make sure we have
+  // the resolved classes and methods.
+  while (!Runtime::Current()->GetStartupCompleted() && !ShuttingDown(self)) {
     MutexLock mu(self, wait_lock_);
-
-    const uint64_t sleep_time = MsToNs(force_early_first_save
-      ? options_.GetMinFirstSaveMs()
-      : options_.GetSaveResolvedClassesDelayMs());
-    const uint64_t start_time = NanoTime();
-    const uint64_t end_time = start_time + sleep_time;
-    while (!Runtime::Current()->GetStartupCompleted() || force_early_first_save) {
-      const uint64_t current_time = NanoTime();
-      if (current_time >= end_time) {
-        break;
-      }
-      period_condition_.TimedWait(self, NsToMs(end_time - current_time), 0);
-    }
-    total_ms_of_sleep_ += NsToMs(NanoTime() - start_time);
+    // Make sure to sleep again until startup is completed.
+    period_condition_.Wait(self);
   }
 
+  // Mark collected classes/methods as startup.
   FetchAndCacheResolvedClassesAndMethods(/*startup=*/ true);
 
+  bool is_min_first_save_set =
+      options_.GetMinFirstSaveMs() != ProfileSaverOptions::kMinFirstSaveMsNotSet;
+  bool force_first_save = is_min_first_save_set && IsFirstSave();
+
   // When we save without waiting for JIT notifications we use a simple
   // exponential back off policy bounded by max_wait_without_jit.
   uint32_t max_wait_without_jit = options_.GetMinSavePeriodMs() * 16;
@@ -160,24 +152,35 @@ void ProfileSaver::Run() {
 
   // Loop for the profiled methods.
   while (!ShuttingDown(self)) {
-    // Sleep only if we don't have to force an early first save configured
-    // with GetMinFirstSaveMs().
-    // If we do have to save early, move directly to the processing part
-    // since we already slept before fetching and resolving the startup
-    // classes.
-    if (!force_early_first_save) {
-      uint64_t sleep_start = NanoTime();
-      uint64_t sleep_time = 0;
+    // In case of force_first_save we need to count from the start of the thread.
+    uint64_t sleep_start = force_first_save ? thread_start_time : NanoTime();
+    uint64_t sleep_time = 0;
+    {
+      MutexLock mu(self, wait_lock_);
+      if (options_.GetWaitForJitNotificationsToSave()) {
+        period_condition_.Wait(self);
+      } else {
+        period_condition_.TimedWait(self, cur_wait_without_jit, 0);
+        if (cur_wait_without_jit < max_wait_without_jit) {
+          cur_wait_without_jit *= 2;
+        }
+      }
+      sleep_time = NanoTime() - sleep_start;
+    }
+    // Check if the thread was woken up for shutdown.
+    if (ShuttingDown(self)) {
+      break;
+    }
+    total_number_of_wake_ups_++;
+    // We might have been woken up by a huge number of notifications to guarantee saving.
+    // If we didn't meet the minimum saving period go back to sleep (only if missed by
+    // a reasonable margin).
+    uint64_t min_save_period_ns = MsToNs(force_first_save ? options_.GetMinFirstSaveMs() :
+                                                                  options_.GetMinSavePeriodMs());
+    while (min_save_period_ns * 0.9 > sleep_time) {
       {
         MutexLock mu(self, wait_lock_);
-        if (options_.GetWaitForJitNotificationsToSave()) {
-          period_condition_.Wait(self);
-        } else {
-          period_condition_.TimedWait(self, cur_wait_without_jit, 0);
-          if (cur_wait_without_jit < max_wait_without_jit) {
-            cur_wait_without_jit *= 2;
-          }
-        }
+        period_condition_.TimedWait(self, NsToMs(min_save_period_ns - sleep_time), 0);
         sleep_time = NanoTime() - sleep_start;
       }
       // Check if the thread was woken up for shutdown.
@@ -185,24 +188,8 @@ void ProfileSaver::Run() {
         break;
       }
       total_number_of_wake_ups_++;
-      // We might have been woken up by a huge number of notifications to guarantee saving.
-      // If we didn't meet the minimum saving period go back to sleep (only if missed by
-      // a reasonable margin).
-      uint64_t min_save_period_ns = MsToNs(options_.GetMinSavePeriodMs());
-      while (min_save_period_ns * 0.9 > sleep_time) {
-        {
-          MutexLock mu(self, wait_lock_);
-          period_condition_.TimedWait(self, NsToMs(min_save_period_ns - sleep_time), 0);
-          sleep_time = NanoTime() - sleep_start;
-        }
-        // Check if the thread was woken up for shutdown.
-        if (ShuttingDown(self)) {
-          break;
-        }
-        total_number_of_wake_ups_++;
-      }
-      total_ms_of_sleep_ += NsToMs(NanoTime() - sleep_start);
     }
+    total_ms_of_sleep_ += NsToMs(NanoTime() - sleep_start);
 
     if (ShuttingDown(self)) {
       break;
@@ -210,15 +197,12 @@ void ProfileSaver::Run() {
 
     uint16_t number_of_new_methods = 0;
     uint64_t start_work = NanoTime();
-    // If we force an early_first_save do not run FetchAndCacheResolvedClassesAndMethods
-    // again. We just did it. So pass true to skip_class_and_method_fetching.
     bool profile_saved_to_disk = ProcessProfilingInfo(
         /*force_save=*/ false,
-        /*skip_class_and_method_fetching=*/ force_early_first_save,
         &number_of_new_methods);
 
     // Reset the flag, so we can continue on the normal schedule.
-    force_early_first_save = false;
+    force_first_save = false;
 
     // Update the notification counter based on result. Note that there might be contention on this
     // but we don't care about to be 100% precise.
@@ -780,10 +764,7 @@ void ProfileSaver::FetchAndCacheResolvedClassesAndMethods(bool startup) {
                  << " sampled methods in " << PrettyDuration(NanoTime() - start_time);
 }
 
-bool ProfileSaver::ProcessProfilingInfo(
-        bool force_save,
-        bool skip_class_and_method_fetching,
-        /*out*/uint16_t* number_of_new_methods) {
+bool ProfileSaver::ProcessProfilingInfo(bool force_save, /*out*/uint16_t* number_of_new_methods) {
   ScopedTrace trace(__PRETTY_FUNCTION__);
 
   // Resolve any new registered locations.
@@ -801,11 +782,7 @@ bool ProfileSaver::ProcessProfilingInfo(
     *number_of_new_methods = 0;
   }
 
-  if (!skip_class_and_method_fetching) {
-    // We only need to do this once, not once per dex location.
-    // TODO: Figure out a way to only do it when stuff has changed? It takes 30-50ms.
-    FetchAndCacheResolvedClassesAndMethods(/*startup=*/ false);
-  }
+  FetchAndCacheResolvedClassesAndMethods(/*startup=*/ false);
 
   for (const auto& it : tracked_locations) {
     if (!force_save && ShuttingDown(Thread::Current())) {
@@ -1085,10 +1062,7 @@ void ProfileSaver::Stop(bool dump_info) {
 
   // Force save everything before destroying the thread since we want profiler_pthread_ to remain
   // valid.
-  profile_saver->ProcessProfilingInfo(
-      /*force_ save=*/ true,
-      /*skip_class_and_method_fetching=*/ false,
-      /*number_of_new_methods=*/ nullptr);
+  profile_saver->ProcessProfilingInfo(/*force_ save=*/ true, /*number_of_new_methods=*/ nullptr);
 
   // Wait for the saver thread to stop.
   CHECK_PTHREAD_CALL(pthread_join, (profiler_pthread, nullptr), "profile saver thread shutdown");
@@ -1207,10 +1181,7 @@ void ProfileSaver::ForceProcessProfiles() {
   // but we only use this in testing when we now this won't happen.
   // Refactor the way we handle the instance so that we don't end up in this situation.
   if (saver != nullptr) {
-    saver->ProcessProfilingInfo(
-        /*force_save=*/ true,
-        /*skip_class_and_method_fetching=*/ false,
-        /*number_of_new_methods=*/ nullptr);
+    saver->ProcessProfilingInfo(/*force_save=*/ true, /*number_of_new_methods=*/ nullptr);
   }
 }
 
diff --git a/runtime/jit/profile_saver.h b/runtime/jit/profile_saver.h
index 1042db9a89..ee99bf1594 100644
--- a/runtime/jit/profile_saver.h
+++ b/runtime/jit/profile_saver.h
@@ -80,10 +80,7 @@ class ProfileSaver {
   // written to disk.
   // If force_save is true, the saver will ignore any constraints which limit IO (e.g. will write
   // the profile to disk even if it's just one new method).
-  bool ProcessProfilingInfo(
-        bool force_save,
-        bool skip_class_and_method_fetching,
-        /*out*/uint16_t* number_of_new_methods)
+  bool ProcessProfilingInfo(bool force_save, /*out*/uint16_t* number_of_new_methods)
       REQUIRES(!Locks::profiler_lock_)
       REQUIRES(!Locks::mutator_lock_);
 
diff --git a/runtime/jit/profile_saver_options.h b/runtime/jit/profile_saver_options.h
index ed2f00f48f..707ebf480a 100644
--- a/runtime/jit/profile_saver_options.h
+++ b/runtime/jit/profile_saver_options.h
@@ -25,55 +25,50 @@ struct ProfileSaverOptions {
   // Default value for the min save period on first use, indicating that the
   // period is not configured.
   static constexpr uint32_t kMinFirstSaveMsNotSet = 0;
-  static constexpr uint32_t kSaveResolvedClassesDelayMs = 5 * 1000;  // 5 seconds
   static constexpr uint32_t kMinMethodsToSave = 10;
   static constexpr uint32_t kMinClassesToSave = 10;
   static constexpr uint32_t kMinNotificationBeforeWake = 10;
   static constexpr uint32_t kMaxNotificationBeforeWake = 50;
   static constexpr uint16_t kInlineCacheThreshold = 4000;
 
-  ProfileSaverOptions() :
-    enabled_(false),
-    min_save_period_ms_(kMinSavePeriodMs),
-    min_first_save_ms_(kMinFirstSaveMsNotSet),
-    save_resolved_classes_delay_ms_(kSaveResolvedClassesDelayMs),
-    min_methods_to_save_(kMinMethodsToSave),
-    min_classes_to_save_(kMinClassesToSave),
-    min_notification_before_wake_(kMinNotificationBeforeWake),
-    max_notification_before_wake_(kMaxNotificationBeforeWake),
-    inline_cache_threshold_(kInlineCacheThreshold),
-    profile_path_(""),
-    profile_boot_class_path_(false),
-    profile_aot_code_(false),
-    wait_for_jit_notifications_to_save_(true) {}
+  ProfileSaverOptions()
+      : enabled_(false),
+        min_save_period_ms_(kMinSavePeriodMs),
+        min_first_save_ms_(kMinFirstSaveMsNotSet),
+        min_methods_to_save_(kMinMethodsToSave),
+        min_classes_to_save_(kMinClassesToSave),
+        min_notification_before_wake_(kMinNotificationBeforeWake),
+        max_notification_before_wake_(kMaxNotificationBeforeWake),
+        inline_cache_threshold_(kInlineCacheThreshold),
+        profile_path_(""),
+        profile_boot_class_path_(false),
+        profile_aot_code_(false),
+        wait_for_jit_notifications_to_save_(true) {}
 
-  ProfileSaverOptions(
-      bool enabled,
-      uint32_t min_save_period_ms,
-      uint32_t min_first_save_ms,
-      uint32_t save_resolved_classes_delay_ms,
-      uint32_t min_methods_to_save,
-      uint32_t min_classes_to_save,
-      uint32_t min_notification_before_wake,
-      uint32_t max_notification_before_wake,
-      uint16_t inline_cache_threshold,
-      const std::string& profile_path,
-      bool profile_boot_class_path,
-      bool profile_aot_code = false,
-      bool wait_for_jit_notifications_to_save = true)
-  : enabled_(enabled),
-    min_save_period_ms_(min_save_period_ms),
-    min_first_save_ms_(min_first_save_ms),
-    save_resolved_classes_delay_ms_(save_resolved_classes_delay_ms),
-    min_methods_to_save_(min_methods_to_save),
-    min_classes_to_save_(min_classes_to_save),
-    min_notification_before_wake_(min_notification_before_wake),
-    max_notification_before_wake_(max_notification_before_wake),
-    inline_cache_threshold_(inline_cache_threshold),
-    profile_path_(profile_path),
-    profile_boot_class_path_(profile_boot_class_path),
-    profile_aot_code_(profile_aot_code),
-    wait_for_jit_notifications_to_save_(wait_for_jit_notifications_to_save) {}
+  ProfileSaverOptions(bool enabled,
+                      uint32_t min_save_period_ms,
+                      uint32_t min_first_save_ms,
+                      uint32_t min_methods_to_save,
+                      uint32_t min_classes_to_save,
+                      uint32_t min_notification_before_wake,
+                      uint32_t max_notification_before_wake,
+                      uint16_t inline_cache_threshold,
+                      const std::string& profile_path,
+                      bool profile_boot_class_path,
+                      bool profile_aot_code = false,
+                      bool wait_for_jit_notifications_to_save = true)
+      : enabled_(enabled),
+        min_save_period_ms_(min_save_period_ms),
+        min_first_save_ms_(min_first_save_ms),
+        min_methods_to_save_(min_methods_to_save),
+        min_classes_to_save_(min_classes_to_save),
+        min_notification_before_wake_(min_notification_before_wake),
+        max_notification_before_wake_(max_notification_before_wake),
+        inline_cache_threshold_(inline_cache_threshold),
+        profile_path_(profile_path),
+        profile_boot_class_path_(profile_boot_class_path),
+        profile_aot_code_(profile_aot_code),
+        wait_for_jit_notifications_to_save_(wait_for_jit_notifications_to_save) {}
 
   bool IsEnabled() const {
     return enabled_;
@@ -88,9 +83,6 @@ struct ProfileSaverOptions {
   uint32_t GetMinFirstSaveMs() const {
     return min_first_save_ms_;
   }
-  uint32_t GetSaveResolvedClassesDelayMs() const {
-    return save_resolved_classes_delay_ms_;
-  }
   uint32_t GetMinMethodsToSave() const {
     return min_methods_to_save_;
   }
@@ -126,7 +118,6 @@ struct ProfileSaverOptions {
     os << "enabled_" << pso.enabled_
         << ", min_save_period_ms_" << pso.min_save_period_ms_
         << ", min_first_save_ms_" << pso.min_first_save_ms_
-        << ", save_resolved_classes_delay_ms_" << pso.save_resolved_classes_delay_ms_
         << ", min_methods_to_save_" << pso.min_methods_to_save_
         << ", min_classes_to_save_" << pso.min_classes_to_save_
         << ", min_notification_before_wake_" << pso.min_notification_before_wake_
@@ -141,7 +132,6 @@ struct ProfileSaverOptions {
   bool enabled_;
   uint32_t min_save_period_ms_;
   uint32_t min_first_save_ms_;
-  uint32_t save_resolved_classes_delay_ms_;
   uint32_t min_methods_to_save_;
   uint32_t min_classes_to_save_;
   uint32_t min_notification_before_wake_;
diff --git a/runtime/jni/jni_internal.cc b/runtime/jni/jni_internal.cc
index 69069968da..51350dc713 100644
--- a/runtime/jni/jni_internal.cc
+++ b/runtime/jni/jni_internal.cc
@@ -2575,11 +2575,26 @@ class JNI {
     Handle<mirror::Class> c = hs.NewHandle(soa.Decode<mirror::Class>(java_class));
     if (UNLIKELY(method_count == 0)) {
       LOG(WARNING) << "JNI RegisterNativeMethods: attempt to register 0 native methods for "
-          << c->PrettyDescriptor();
+                   << c->PrettyDescriptor();
       return JNI_OK;
     }
-    bool is_class_loader_namespace_natively_bridged =
-        IsClassLoaderNamespaceNativelyBridged(soa, c->GetClassLoader());
+    ScopedLocalRef<jobject> jclass_loader(env, nullptr);
+    if (c->GetClassLoader() != nullptr) {
+      jclass_loader.reset(soa.Env()->AddLocalReference<jobject>(c->GetClassLoader()));
+    }
+
+    bool is_class_loader_namespace_natively_bridged = false;
+    {
+      // Making sure to release mutator_lock_ before proceeding.
+      // FindNativeLoaderNamespaceByClassLoader eventually acquires lock on g_namespaces_mutex
+      // which may cause a deadlock if another thread is waiting for mutator_lock_
+      // for IsSameObject call in libnativeloader's CreateClassLoaderNamespace (which happens
+      // under g_namespace_mutex lock)
+      ScopedThreadSuspension sts(soa.Self(), ThreadState::kNative);
+
+      is_class_loader_namespace_natively_bridged =
+          IsClassLoaderNamespaceNativelyBridged(env, jclass_loader.get());
+    }
 
     CHECK_NON_NULL_ARGUMENT_FN_NAME("RegisterNatives", methods, JNI_ERR);
     for (jint i = 0; i < method_count; ++i) {
@@ -2914,16 +2929,13 @@ class JNI {
     return array;
   }
 
-  static bool IsClassLoaderNamespaceNativelyBridged(ScopedObjectAccess& soa,
-                                                    ObjPtr<mirror::ClassLoader> class_loader)
-      REQUIRES_SHARED(Locks::mutator_lock_) {
+  static bool IsClassLoaderNamespaceNativelyBridged(JNIEnv* env, jobject jclass_loader) {
 #if defined(ART_TARGET_ANDROID)
-    ScopedLocalRef<jobject> jclass_loader(soa.Env(), soa.AddLocalReference<jobject>(class_loader));
     android::NativeLoaderNamespace* ns =
-        android::FindNativeLoaderNamespaceByClassLoader(soa.Env(), jclass_loader.get());
+        android::FindNativeLoaderNamespaceByClassLoader(env, jclass_loader);
     return ns != nullptr && android::IsNamespaceNativeBridged(ns);
 #else
-    UNUSED(soa, class_loader);
+    UNUSED(env, jclass_loader);
     return false;
 #endif
   }
diff --git a/runtime/method_handles.cc b/runtime/method_handles.cc
index f2ac3c89ca..c4e4d206a4 100644
--- a/runtime/method_handles.cc
+++ b/runtime/method_handles.cc
@@ -721,9 +721,8 @@ bool DoVarHandleInvokeTranslation(Thread* self,
 
   // Determine the accessor kind to dispatch
   ArtMethod* target_method = method_handle->GetTargetMethod();
-  int intrinsic_index = target_method->GetIntrinsic();
   mirror::VarHandle::AccessMode access_mode =
-      mirror::VarHandle::GetAccessModeByIntrinsic(static_cast<Intrinsics>(intrinsic_index));
+      mirror::VarHandle::GetAccessModeByIntrinsic(target_method->GetIntrinsic());
   Handle<mirror::MethodType> vh_type =
       hs.NewHandle(vh->GetMethodTypeForAccessMode(self, access_mode));
   Handle<mirror::MethodType> mh_invoke_type = hs.NewHandle(
diff --git a/runtime/metrics/reporter_test.cc b/runtime/metrics/reporter_test.cc
index 97a845c26a..039e43ca48 100644
--- a/runtime/metrics/reporter_test.cc
+++ b/runtime/metrics/reporter_test.cc
@@ -125,6 +125,7 @@ class MetricsReporterTest : public CommonRuntimeTest {
   }
 
   void TearDown() override {
+    reporter_->MaybeStopBackgroundThread();
     reporter_ = nullptr;
     backend_ = nullptr;
   }
diff --git a/runtime/mirror/array-inl.h b/runtime/mirror/array-inl.h
index 830a7e5fb6..1898aca12f 100644
--- a/runtime/mirror/array-inl.h
+++ b/runtime/mirror/array-inl.h
@@ -34,27 +34,26 @@ namespace mirror {
 
 inline uint32_t Array::ClassSize(PointerSize pointer_size) {
   uint32_t vtable_entries = Object::kVTableLength;
-  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, pointer_size);
+  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, 0, pointer_size);
 }
 
-template <VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption, bool kIsObjArray>
-inline size_t Array::SizeOf() {
-  // When we are certain that this is a object array, then don't fetch shift
-  // from component_type_ as that doesn't work well with userfaultfd GC as the
-  // component-type class may be allocated at a higher address than the array.
-  size_t component_size_shift = kIsObjArray ?
-                                    Primitive::ComponentSizeShift(Primitive::kPrimNot) :
-                                    GetClass<kVerifyFlags, kReadBarrierOption>()
-                                        ->template GetComponentSizeShift<kReadBarrierOption>();
-  // Don't need to check this since we already check this in GetClass.
-  int32_t component_count =
-      GetLength<static_cast<VerifyObjectFlags>(kVerifyFlags & ~kVerifyThis)>();
+template <VerifyObjectFlags kVerifyFlags>
+inline size_t Array::SizeOf(size_t component_size_shift) {
+  int32_t component_count = GetLength<kVerifyFlags>();
   // This is safe from overflow because the array was already allocated.
   size_t header_size = DataOffset(1U << component_size_shift).SizeValue();
   size_t data_size = component_count << component_size_shift;
   return header_size + data_size;
 }
 
+template <VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption>
+inline size_t Array::SizeOf() {
+  size_t component_size_shift = GetClass<kVerifyFlags, kReadBarrierOption>()
+                                    ->template GetComponentSizeShift<kReadBarrierOption>();
+  // Don't need to check this since we already check this in GetClass.
+  return SizeOf<static_cast<VerifyObjectFlags>(kVerifyFlags & ~kVerifyThis)>(component_size_shift);
+}
+
 template<VerifyObjectFlags kVerifyFlags>
 inline bool Array::CheckIsValidIndex(int32_t index) {
   if (UNLIKELY(static_cast<uint32_t>(index) >=
diff --git a/runtime/mirror/array.h b/runtime/mirror/array.h
index 565faa90b1..7a0976ab48 100644
--- a/runtime/mirror/array.h
+++ b/runtime/mirror/array.h
@@ -59,9 +59,10 @@ class MANAGED Array : public Object {
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Roles::uninterruptible_);
 
+  template <VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags>
+  size_t SizeOf(size_t component_size_shift) REQUIRES_SHARED(Locks::mutator_lock_);
   template <VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
-            ReadBarrierOption kReadBarrierOption = kWithoutReadBarrier,
-            bool kIsObjArray = false>
+            ReadBarrierOption kReadBarrierOption = kWithoutReadBarrier>
   size_t SizeOf() REQUIRES_SHARED(Locks::mutator_lock_);
   template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags>
   ALWAYS_INLINE int32_t GetLength() REQUIRES_SHARED(Locks::mutator_lock_) {
diff --git a/runtime/mirror/class-inl.h b/runtime/mirror/class-inl.h
index b2c8e52351..f60a554f91 100644
--- a/runtime/mirror/class-inl.h
+++ b/runtime/mirror/class-inl.h
@@ -596,6 +596,9 @@ inline ArtMethod* Class::FindVirtualMethodForInterface(ArtMethod* method,
 inline ArtMethod* Class::FindVirtualMethodForVirtual(ArtMethod* method, PointerSize pointer_size) {
   // Only miranda or default methods may come from interfaces and be used as a virtual.
   DCHECK(!method->GetDeclaringClass()->IsInterface() || method->IsDefault() || method->IsMiranda());
+  DCHECK(method->GetDeclaringClass()->IsAssignableFrom(this))
+      << "Method " << method->PrettyMethod()
+      << " is not declared in " << PrettyDescriptor() << " or its super classes";
   // The argument method may from a super class.
   // Use the index to a potentially overridden one for this instance's class.
   return GetVTableEntry(method->GetMethodIndex(), pointer_size);
@@ -603,6 +606,9 @@ inline ArtMethod* Class::FindVirtualMethodForVirtual(ArtMethod* method, PointerS
 
 inline ArtMethod* Class::FindVirtualMethodForSuper(ArtMethod* method, PointerSize pointer_size) {
   DCHECK(!method->GetDeclaringClass()->IsInterface());
+  DCHECK(method->GetDeclaringClass()->IsAssignableFrom(this))
+      << "Method " << method->PrettyMethod()
+      << " is not declared in " << PrettyDescriptor() << " or its super classes";
   return GetSuperClass()->GetVTableEntry(method->GetMethodIndex(), pointer_size);
 }
 
@@ -657,7 +663,7 @@ inline MemberOffset Class::GetFirstReferenceStaticFieldOffset(PointerSize pointe
   if (ShouldHaveEmbeddedVTable<kVerifyFlags>()) {
     // Static fields come after the embedded tables.
     base = Class::ComputeClassSize(
-        true, GetEmbeddedVTableLength<kVerifyFlags>(), 0, 0, 0, 0, 0, pointer_size);
+        true, GetEmbeddedVTableLength<kVerifyFlags>(), 0, 0, 0, 0, 0, 0, pointer_size);
   }
   return MemberOffset(base);
 }
@@ -668,8 +674,8 @@ inline MemberOffset Class::GetFirstReferenceStaticFieldOffsetDuringLinking(
   uint32_t base = sizeof(Class);  // Static fields come after the class.
   if (ShouldHaveEmbeddedVTable()) {
     // Static fields come after the embedded tables.
-    base = Class::ComputeClassSize(true, GetVTableDuringLinking()->GetLength(),
-                                           0, 0, 0, 0, 0, pointer_size);
+    base = Class::ComputeClassSize(
+        true, GetVTableDuringLinking()->GetLength(), 0, 0, 0, 0, 0, 0, pointer_size);
   }
   return MemberOffset(base);
 }
@@ -757,6 +763,127 @@ inline size_t Class::GetPrimitiveTypeSizeShift() {
   return size_shift;
 }
 
+template <VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption>
+inline void Class::VerifyOverflowReferenceBitmap() {
+  // Can't reliably access super-classes during CMC compaction.
+  if (Runtime::Current() != nullptr && Runtime::Current()->GetHeap() != nullptr &&
+      Runtime::Current()->GetHeap()->IsPerformingUffdCompaction()) {
+    return;
+  }
+  CHECK(!IsVariableSize<kVerifyFlags>());
+  ObjPtr<Class> klass;
+  ObjPtr<mirror::Class> super_class;
+  size_t num_bits =
+      (RoundUp(GetObjectSize<kVerifyFlags>(), sizeof(mirror::HeapReference<mirror::Object>)) -
+       mirror::kObjectHeaderSize) /
+      sizeof(mirror::HeapReference<mirror::Object>);
+  std::vector<bool> check_bitmap(num_bits, false);
+  for (klass = this; klass != nullptr; klass = super_class) {
+    super_class = klass->GetSuperClass<kVerifyFlags, kReadBarrierOption>();
+    if (klass->NumReferenceInstanceFields<kVerifyFlags>() != 0) {
+      break;
+    }
+  }
+
+  if (super_class != nullptr) {
+    std::vector<ObjPtr<Class>> klasses;
+    for (; klass != nullptr; klass = super_class) {
+      super_class = klass->GetSuperClass<kVerifyFlags, kReadBarrierOption>();
+      if (super_class != nullptr) {
+        klasses.push_back(klass);
+      }
+    }
+
+    for (auto iter = klasses.rbegin(); iter != klasses.rend(); iter++) {
+      klass = *iter;
+      size_t idx = (klass->GetFirstReferenceInstanceFieldOffset<kVerifyFlags, kReadBarrierOption>()
+                        .Uint32Value() -
+                    mirror::kObjectHeaderSize) /
+                   sizeof(mirror::HeapReference<mirror::Object>);
+      uint32_t num_refs = klass->NumReferenceInstanceFields<kVerifyFlags>();
+      for (uint32_t i = 0; i < num_refs; i++) {
+        check_bitmap[idx++] = true;
+      }
+      CHECK_LE(idx, num_bits) << PrettyClass();
+    }
+  }
+
+  uint32_t ref_offsets =
+      GetField32<kVerifyFlags>(OFFSET_OF_OBJECT_MEMBER(Class, reference_instance_offsets_));
+  CHECK_NE(ref_offsets, 0u) << PrettyClass();
+  CHECK((ref_offsets & kVisitReferencesSlowpathMask) != 0) << PrettyClass();
+  uint32_t bitmap_num_words = ref_offsets & ~kVisitReferencesSlowpathMask;
+  uint32_t* overflow_bitmap = reinterpret_cast<uint32_t*>(
+      reinterpret_cast<uint8_t*>(this) +
+      (GetClassSize<kVerifyFlags>() - bitmap_num_words * sizeof(uint32_t)));
+  for (uint32_t i = 0, field_offset = 0; i < bitmap_num_words; i++, field_offset += 32) {
+    ref_offsets = overflow_bitmap[i];
+    uint32_t check_bitmap_idx = field_offset;
+    // Confirm that all the bits in check_bitmap that ought to be set, are set.
+    while (ref_offsets != 0) {
+      if ((ref_offsets & 1) != 0) {
+        CHECK(check_bitmap[check_bitmap_idx])
+            << PrettyClass() << " i:" << i << " field_offset:" << field_offset
+            << " check_bitmap_idx:" << check_bitmap_idx << " bitmap_word:" << overflow_bitmap[i];
+        check_bitmap[check_bitmap_idx] = false;
+      }
+      ref_offsets >>= 1;
+      check_bitmap_idx++;
+    }
+  }
+  // Confirm that there is no other bit set.
+  std::ostringstream oss;
+  bool found = false;
+  for (size_t i = 0; i < check_bitmap.size(); i++) {
+    if (check_bitmap[i]) {
+      if (!found) {
+        DumpClass(oss, kDumpClassFullDetail);
+        oss << " set-bits:";
+      }
+      found = true;
+      oss << i << ",";
+    }
+  }
+  if (found) {
+    oss << " stored-bitmap:";
+    for (size_t i = 0; i < bitmap_num_words; i++) {
+      oss << overflow_bitmap[i] << ":";
+    }
+    LOG(FATAL) << oss.str();
+  }
+}
+
+inline size_t Class::AdjustClassSizeForReferenceOffsetBitmapDuringLinking(ObjPtr<Class> klass,
+                                                                          size_t class_size) {
+  if (klass->IsInstantiable()) {
+    // Find the first class with non-zero instance field count and its super-class'
+    // object-size together will tell us the required size.
+    for (ObjPtr<Class> k = klass; k != nullptr; k = k->GetSuperClass()) {
+      size_t num_reference_fields = k->NumReferenceInstanceFieldsDuringLinking();
+      if (num_reference_fields != 0) {
+        ObjPtr<Class> super = k->GetSuperClass();
+        // Leave it for mirror::Object (the class field is handled specially).
+        if (super != nullptr) {
+          // All of the fields that contain object references are guaranteed to be grouped in
+          // memory starting at an appropriately aligned address after super class object data.
+          uint32_t start_offset =
+              RoundUp(super->GetObjectSize(), sizeof(mirror::HeapReference<mirror::Object>));
+          uint32_t start_bit = (start_offset - mirror::kObjectHeaderSize) /
+                               sizeof(mirror::HeapReference<mirror::Object>);
+          if (start_bit + num_reference_fields > 31) {
+            // Alignment that maybe required at the end of static fields smaller than 32-bit.
+            class_size = RoundUp(class_size, sizeof(uint32_t));
+            // 32-bit words required for the overflow bitmap.
+            class_size += RoundUp(start_bit + num_reference_fields, 32) / 32 * sizeof(uint32_t);
+          }
+        }
+        break;
+      }
+    }
+  }
+  return class_size;
+}
+
 inline uint32_t Class::ComputeClassSize(bool has_embedded_vtable,
                                         uint32_t num_vtable_entries,
                                         uint32_t num_8bit_static_fields,
@@ -764,6 +891,7 @@ inline uint32_t Class::ComputeClassSize(bool has_embedded_vtable,
                                         uint32_t num_32bit_static_fields,
                                         uint32_t num_64bit_static_fields,
                                         uint32_t num_ref_static_fields,
+                                        uint32_t num_ref_bitmap_entries,
                                         PointerSize pointer_size) {
   // Space used by java.lang.Class and its instance fields.
   uint32_t size = sizeof(Class);
@@ -799,6 +927,12 @@ inline uint32_t Class::ComputeClassSize(bool has_embedded_vtable,
   // Space used for primitive static fields.
   size += num_8bit_static_fields * sizeof(uint8_t) + num_16bit_static_fields * sizeof(uint16_t) +
       num_32bit_static_fields * sizeof(uint32_t) + num_64bit_static_fields * sizeof(uint64_t);
+
+  // Space used by reference-offset bitmap.
+  if (num_ref_bitmap_entries > 0) {
+    size = RoundUp(size, sizeof(uint32_t));
+    size += num_ref_bitmap_entries * sizeof(uint32_t);
+  }
   return size;
 }
 
diff --git a/runtime/mirror/class-refvisitor-inl.h b/runtime/mirror/class-refvisitor-inl.h
index 21ed1cd636..96c218b175 100644
--- a/runtime/mirror/class-refvisitor-inl.h
+++ b/runtime/mirror/class-refvisitor-inl.h
@@ -25,12 +25,32 @@
 namespace art HIDDEN {
 namespace mirror {
 
+// NO_THREAD_SAFETY_ANALYSIS for mutator_lock_ and heap_bitmap_lock_, as
+// requirements for these vary depending on the visitor.
+template <VerifyObjectFlags kVerifyFlags, typename Visitor>
+inline void Class::VisitStaticFieldsReferences(const Visitor& visitor) NO_THREAD_SAFETY_ANALYSIS {
+  DCHECK(!IsTemp<kVerifyFlags>());
+  const size_t num_reference_fields = NumReferenceStaticFields();
+  if (num_reference_fields > 0u) {
+    // Presumably GC can happen when we are cross compiling, it should not cause performance
+    // problems to do pointer size logic.
+    MemberOffset field_offset = GetFirstReferenceStaticFieldOffset<kVerifyFlags>(
+        Runtime::Current()->GetClassLinker()->GetImagePointerSize());
+    for (size_t i = 0u; i < num_reference_fields; ++i) {
+      DCHECK_NE(field_offset.Uint32Value(), ClassOffset().Uint32Value());
+      visitor(this, field_offset, /*is_static=*/true);
+      field_offset =
+          MemberOffset(field_offset.Uint32Value() + sizeof(mirror::HeapReference<mirror::Object>));
+    }
+  }
+}
+
 template <bool kVisitNativeRoots,
           VerifyObjectFlags kVerifyFlags,
           ReadBarrierOption kReadBarrierOption,
           typename Visitor>
 inline void Class::VisitReferences(ObjPtr<Class> klass, const Visitor& visitor) {
-  VisitInstanceFieldsReferences<kVerifyFlags, kReadBarrierOption>(klass.Ptr(), visitor);
+  VisitInstanceFieldsReferences<kVerifyFlags>(klass.Ptr(), visitor);
   // Right after a class is allocated, but not yet loaded
   // (ClassStatus::kNotReady, see ClassLinker::LoadClass()), GC may find it
   // and scan it. IsTemp() may call Class::GetAccessFlags() but may
@@ -42,7 +62,7 @@ inline void Class::VisitReferences(ObjPtr<Class> klass, const Visitor& visitor)
     // Temp classes don't ever populate imt/vtable or static fields and they are not even
     // allocated with the right size for those. Also, unresolved classes don't have fields
     // linked yet.
-    VisitStaticFieldsReferences<kVerifyFlags, kReadBarrierOption>(this, visitor);
+    VisitStaticFieldsReferences<kVerifyFlags>(visitor);
   }
   if (kVisitNativeRoots) {
     // Since this class is reachable, we must also visit the associated roots when we scan it.
diff --git a/runtime/mirror/class.cc b/runtime/mirror/class.cc
index 12fbc36926..43dbc43115 100644
--- a/runtime/mirror/class.cc
+++ b/runtime/mirror/class.cc
@@ -451,15 +451,28 @@ void Class::DumpClass(std::ostream& os, int flags) {
 }
 
 void Class::SetReferenceInstanceOffsets(uint32_t new_reference_offsets) {
-  if (kIsDebugBuild && new_reference_offsets != kClassWalkSuper) {
+  if (kIsDebugBuild) {
     // Check that the number of bits set in the reference offset bitmap
     // agrees with the number of references.
     uint32_t count = 0;
     for (ObjPtr<Class> c = this; c != nullptr; c = c->GetSuperClass()) {
       count += c->NumReferenceInstanceFieldsDuringLinking();
     }
+    uint32_t pop_cnt;
+    if ((new_reference_offsets & kVisitReferencesSlowpathMask) == 0) {
+      pop_cnt = static_cast<uint32_t>(POPCOUNT(new_reference_offsets));
+    } else {
+      uint32_t bitmap_num_words = new_reference_offsets & ~kVisitReferencesSlowpathMask;
+      uint32_t* overflow_bitmap =
+          reinterpret_cast<uint32_t*>(reinterpret_cast<uint8_t*>(this) +
+                                      (GetClassSize() - bitmap_num_words * sizeof(uint32_t)));
+      pop_cnt = 0;
+      for (uint32_t i = 0; i < bitmap_num_words; i++) {
+        pop_cnt += static_cast<uint32_t>(POPCOUNT(overflow_bitmap[i]));
+      }
+    }
     // +1 for the Class in Object.
-    CHECK_EQ(static_cast<uint32_t>(POPCOUNT(new_reference_offsets)) + 1, count);
+    CHECK_EQ(pop_cnt + 1, count);
   }
   // Not called within a transaction.
   SetField32<false>(OFFSET_OF_OBJECT_MEMBER(Class, reference_instance_offsets_),
@@ -1607,6 +1620,114 @@ void Class::PopulateEmbeddedVTable(PointerSize pointer_size) {
   }
 }
 
+// Set the bitmap of reference instance field offsets.
+void Class::PopulateReferenceOffsetBitmap() {
+  size_t num_reference_fields;
+  ObjPtr<mirror::Class> super_class;
+  ObjPtr<Class> klass;
+  // Find the first class with non-zero instance reference fields.
+  for (klass = this; klass != nullptr; klass = super_class) {
+    super_class = klass->GetSuperClass();
+    num_reference_fields = klass->NumReferenceInstanceFieldsDuringLinking();
+    if (num_reference_fields != 0) {
+      break;
+    }
+  }
+
+  uint32_t ref_offsets = 0;
+  // Leave the reference offsets as 0 for mirror::Object (the class field is handled specially).
+  if (super_class != nullptr) {
+    // All of the reference fields added by this class are guaranteed to be grouped in memory
+    // starting at an appropriately aligned address after super class object data.
+    uint32_t start_offset =
+        RoundUp(super_class->GetObjectSize(), sizeof(mirror::HeapReference<mirror::Object>));
+    uint32_t start_bit =
+        (start_offset - mirror::kObjectHeaderSize) / sizeof(mirror::HeapReference<mirror::Object>);
+    uint32_t end_bit = start_bit + num_reference_fields;
+    bool overflowing = end_bit > 31;
+    uint32_t* overflow_bitmap;  // Pointer to the last word of overflow bitmap to be written into.
+    uint32_t overflow_words_to_write;  // Number of overflow bitmap words remaining to write.
+    // Index in 'overflow_bitmap' from where to start writing bitmap words (in reverse order).
+    int32_t overflow_bitmap_word_idx;
+    if (overflowing) {
+      // We will write overflow bitmap in reverse.
+      overflow_bitmap =
+          reinterpret_cast<uint32_t*>(reinterpret_cast<uint8_t*>(this) + GetClassSize());
+      DCHECK_ALIGNED(overflow_bitmap, sizeof(uint32_t));
+      overflow_bitmap_word_idx = 0;
+      overflow_words_to_write = RoundUp(end_bit, 32) / 32;
+    }
+    // TODO: Simplify by copying the bitmap from the super-class and then
+    // appending the reference fields added by this class.
+    while (true) {
+      if (UNLIKELY(overflowing)) {
+        // Write all the bitmap words which got skipped between previous
+        // super-class and the current one.
+        for (uint32_t new_words_to_write = RoundUp(end_bit, 32) / 32;
+             overflow_words_to_write > new_words_to_write;
+             overflow_words_to_write--) {
+          overflow_bitmap[--overflow_bitmap_word_idx] = ref_offsets;
+          ref_offsets = 0;
+        }
+        // Handle the references in the current super-class.
+        if (num_reference_fields != 0u) {
+          uint32_t aligned_end_bit = RoundDown(end_bit, 32);
+          uint32_t aligned_start_bit = RoundUp(start_bit, 32);
+          // Handle the case where a class' references are spanning across multiple 32-bit
+          // words of the overflow bitmap.
+          if (aligned_end_bit >= aligned_start_bit) {
+            // handle the unaligned end first
+            if (aligned_end_bit < end_bit) {
+              ref_offsets |= 0xffffffffu >> (32 - (end_bit - aligned_end_bit));
+              overflow_bitmap[--overflow_bitmap_word_idx] = ref_offsets;
+              overflow_words_to_write--;
+              ref_offsets = 0;
+            }
+            // store all the 32-bit bitmap words in between
+            for (; aligned_end_bit > aligned_start_bit; aligned_end_bit -= 32) {
+              overflow_bitmap[--overflow_bitmap_word_idx] = 0xffffffffu;
+              overflow_words_to_write--;
+            }
+            CHECK_EQ(ref_offsets, 0u);
+            // handle the unaligned start now
+            if (aligned_start_bit > start_bit) {
+              ref_offsets = 0xffffffffu << (32 - (aligned_start_bit - start_bit));
+            }
+          } else {
+            DCHECK_EQ(aligned_start_bit - aligned_end_bit, 32u);
+            ref_offsets |= (0xffffffffu << (32 - (aligned_start_bit - start_bit))) &
+                           (0xffffffffu >> (32 - (end_bit - aligned_end_bit)));
+          }
+        }
+      } else if (num_reference_fields != 0u) {
+        ref_offsets |= (0xffffffffu << start_bit) & (0xffffffffu >> (32 - end_bit));
+      }
+
+      klass = super_class;
+      super_class = klass->GetSuperClass();
+      if (super_class == nullptr) {
+        break;
+      }
+      num_reference_fields = klass->NumReferenceInstanceFieldsDuringLinking();
+      start_offset =
+          RoundUp(super_class->GetObjectSize(), sizeof(mirror::HeapReference<mirror::Object>));
+      start_bit = (start_offset - mirror::kObjectHeaderSize) /
+                  sizeof(mirror::HeapReference<mirror::Object>);
+      end_bit = start_bit + num_reference_fields;
+    }
+    if (overflowing) {
+      // We should not have more than one word left to write in the overflow bitmap.
+      DCHECK_LE(overflow_words_to_write, 1u)
+          << "overflow_bitmap_word_idx:" << -overflow_bitmap_word_idx;
+      if (overflow_words_to_write > 0) {
+        overflow_bitmap[--overflow_bitmap_word_idx] = ref_offsets;
+      }
+      ref_offsets = -overflow_bitmap_word_idx | kVisitReferencesSlowpathMask;
+    }
+  }
+  SetReferenceInstanceOffsets(ref_offsets);
+}
+
 class ReadBarrierOnNativeRootsVisitor {
  public:
   void operator()([[maybe_unused]] ObjPtr<Object> obj,
@@ -1657,6 +1778,7 @@ class CopyClassVisitor {
     h_new_class_obj->PopulateEmbeddedVTable(pointer_size_);
     h_new_class_obj->SetImt(imt_, pointer_size_);
     h_new_class_obj->SetClassSize(new_length_);
+    h_new_class_obj->PopulateReferenceOffsetBitmap();
     // Visit all of the references to make sure there is no from space references in the native
     // roots.
     h_new_class_obj->Object::VisitReferences(ReadBarrierOnNativeRootsVisitor(), VoidFunctor());
diff --git a/runtime/mirror/class.h b/runtime/mirror/class.h
index 17d45b4312..6384bfabc0 100644
--- a/runtime/mirror/class.h
+++ b/runtime/mirror/class.h
@@ -83,11 +83,12 @@ class EXPORT MANAGED Class final : public Object {
  public:
   MIRROR_CLASS("Ljava/lang/Class;");
 
-  // A magic value for reference_instance_offsets_. Ignore the bits and walk the super chain when
-  // this is the value.
-  // [This is an unlikely "natural" value, since it would be 30 non-ref instance fields followed by
-  // 2 ref instance fields.]
-  static constexpr uint32_t kClassWalkSuper = 0xC0000000;
+  // 'reference_instance_offsets_' may contain up to 31 reference offsets. If
+  // more bits are required, then we set the most-significant bit and store the
+  // number of 32-bit bitmap entries required in the remaining bits. All the
+  // required bitmap entries after stored after static fields (at the end of the class).
+  static constexpr uint32_t kVisitReferencesSlowpathShift = 31;
+  static constexpr uint32_t kVisitReferencesSlowpathMask = 1u << kVisitReferencesSlowpathShift;
 
   // Shift primitive type by kPrimitiveTypeSizeShiftShift to get the component type size shift
   // Used for computing array size as follows:
@@ -566,6 +567,12 @@ class EXPORT MANAGED Class final : public Object {
   void SetClassSize(uint32_t new_class_size)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  // Adjust class-size during linking in case an overflow bitmap for reference
+  // offsets is required.
+  static size_t AdjustClassSizeForReferenceOffsetBitmapDuringLinking(ObjPtr<Class> klass,
+                                                                     size_t class_size)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
   // Compute how many bytes would be used a class with the given elements.
   static uint32_t ComputeClassSize(bool has_embedded_vtable,
                                    uint32_t num_vtable_entries,
@@ -574,18 +581,19 @@ class EXPORT MANAGED Class final : public Object {
                                    uint32_t num_32bit_static_fields,
                                    uint32_t num_64bit_static_fields,
                                    uint32_t num_ref_static_fields,
+                                   uint32_t num_ref_bitmap_entries,
                                    PointerSize pointer_size);
 
   // The size of java.lang.Class.class.
   static uint32_t ClassClassSize(PointerSize pointer_size) {
     // The number of vtable entries in java.lang.Class.
     uint32_t vtable_entries = Object::kVTableLength + 83;
-    return ComputeClassSize(true, vtable_entries, 0, 0, 4, 1, 0, pointer_size);
+    return ComputeClassSize(true, vtable_entries, 0, 0, 4, 1, 0, 0, pointer_size);
   }
 
   // The size of a java.lang.Class representing a primitive such as int.class.
   static uint32_t PrimitiveClassSize(PointerSize pointer_size) {
-    return ComputeClassSize(false, 0, 0, 0, 0, 0, 0, pointer_size);
+    return ComputeClassSize(false, 0, 0, 0, 0, 0, 0, 0, pointer_size);
   }
 
   template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags>
@@ -896,6 +904,14 @@ class EXPORT MANAGED Class final : public Object {
   void PopulateEmbeddedVTable(PointerSize pointer_size)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  template <VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
+            ReadBarrierOption kReadBarrierOption = kWithReadBarrier>
+  void VerifyOverflowReferenceBitmap() REQUIRES_SHARED(Locks::mutator_lock_);
+  // If the bitmap in `reference_instance_offsets_` was found to be insufficient
+  // in CreateReferenceInstanceOffsets(), then populate the overflow bitmap,
+  // which is at the end of class object.
+  void PopulateReferenceOffsetBitmap() REQUIRES_SHARED(Locks::mutator_lock_);
+
   // Given a method implemented by this class but potentially from a super class, return the
   // specific implementation method for this class.
   ArtMethod* FindVirtualMethodForVirtual(ArtMethod* method, PointerSize pointer_size)
@@ -1435,6 +1451,9 @@ class EXPORT MANAGED Class final : public Object {
   // Check that the pointer size matches the one in the class linker.
   ALWAYS_INLINE static void CheckPointerSize(PointerSize pointer_size);
 
+  template <VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags, typename Visitor>
+  void VisitStaticFieldsReferences(const Visitor& visitor) HOT_ATTR;
+
   template <bool kVisitNativeRoots,
             VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
             ReadBarrierOption kReadBarrierOption = kWithReadBarrier,
@@ -1549,7 +1568,8 @@ class EXPORT MANAGED Class final : public Object {
   // TODO: really 16bits
   int32_t dex_type_idx_;
 
-  // Number of instance fields that are object refs.
+  // Number of instance fields that are object refs. Does not count object refs
+  // in any super classes.
   uint32_t num_reference_instance_fields_;
 
   // Number of static fields that are object refs,
@@ -1583,19 +1603,20 @@ class EXPORT MANAGED Class final : public Object {
   // The offset of the first declared virtual methods in the methods_ array.
   uint16_t virtual_methods_offset_;
 
-  // TODO: ?
-  // initiating class loader list
-  // NOTE: for classes with low serialNumber, these are unused, and the
-  // values are kept in a table in gDvm.
-  // InitiatingLoaderList initiating_loader_list_;
-
   // The following data exist in real class objects.
-  // Embedded Imtable, for class object that's not an interface, fixed size.
-  // ImTableEntry embedded_imtable_[0];
+  // Embedded Vtable length, for class object that's instantiable, fixed size.
+  // uint32_t vtable_length_;
+  // Embedded Imtable pointer, for class object that's not an interface, fixed size.
+  // ImTableEntry embedded_imtable_;
   // Embedded Vtable, for class object that's not an interface, variable size.
   // VTableEntry embedded_vtable_[0];
   // Static fields, variable size.
   // uint32_t fields_[0];
+  // Embedded bitmap of offsets of ifields, for classes that need more than 31
+  // reference-offset bits. 'reference_instance_offsets_' stores the number of
+  // 32-bit entries that hold the entire bitmap. We compute the offset of first
+  // entry by subtracting this number from class_size_.
+  // uint32_t reference_bitmap_[0];
 
   ART_FRIEND_TEST(DexCacheTest, TestResolvedFieldAccess);  // For ResolvedFieldAccessTest
   friend struct art::ClassOffsets;  // for verifying offset information
diff --git a/runtime/mirror/class_ext.cc b/runtime/mirror/class_ext.cc
index d8cabd37b0..49177aca02 100644
--- a/runtime/mirror/class_ext.cc
+++ b/runtime/mirror/class_ext.cc
@@ -38,7 +38,7 @@ namespace mirror {
 
 uint32_t ClassExt::ClassSize(PointerSize pointer_size) {
   uint32_t vtable_entries = Object::kVTableLength;
-  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, pointer_size);
+  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, 0, pointer_size);
 }
 
 void ClassExt::SetObsoleteArrays(ObjPtr<PointerArray> methods,
diff --git a/runtime/mirror/class_flags.h b/runtime/mirror/class_flags.h
index 26a87c9546..b3d38b0ba8 100644
--- a/runtime/mirror/class_flags.h
+++ b/runtime/mirror/class_flags.h
@@ -61,6 +61,14 @@ static constexpr uint32_t kClassFlagPhantomReference   = 0x00000400;
 // Class is a record class. See doc at java.lang.Class#isRecord().
 static constexpr uint32_t kClassFlagRecord             = 0x00000800;
 
+// Class is a primitive array class.
+static constexpr uint32_t kClassFlagPrimitiveArray = 0x00001000;
+
+// NOTE: The most significant 2 bits are used to store the component size shift
+// for arrays (both primitive and object). See Primitive::ComponentSizeShift()
+// for size shift of different types.
+static constexpr uint32_t kArrayComponentSizeShiftShift = 30;
+
 // Combination of flags to figure out if the class is either the weak/soft/phantom/finalizer
 // reference class.
 static constexpr uint32_t kClassFlagReference =
diff --git a/runtime/mirror/class_loader.h b/runtime/mirror/class_loader.h
index 0e925f4598..d62768f589 100644
--- a/runtime/mirror/class_loader.h
+++ b/runtime/mirror/class_loader.h
@@ -75,8 +75,7 @@ class MANAGED ClassLoader : public Object {
             ReadBarrierOption kReadBarrierOption = kWithReadBarrier,
             typename Visitor>
   void VisitReferences(ObjPtr<Class> klass, const Visitor& visitor)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      REQUIRES(!Locks::classlinker_classes_lock_);
+      REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(!Locks::classlinker_classes_lock_);
 
   // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
   HeapReference<String> name_;
diff --git a/runtime/mirror/dex_cache-inl.h b/runtime/mirror/dex_cache-inl.h
index 8f9d624399..4ac5131958 100644
--- a/runtime/mirror/dex_cache-inl.h
+++ b/runtime/mirror/dex_cache-inl.h
@@ -128,7 +128,7 @@ inline T* GcRootArray<T>::Get(uint32_t index) {
 
 inline uint32_t DexCache::ClassSize(PointerSize pointer_size) {
   const uint32_t vtable_entries = Object::kVTableLength;
-  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, pointer_size);
+  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, 0, pointer_size);
 }
 
 inline String* DexCache::GetResolvedString(dex::StringIndex string_idx) {
@@ -296,7 +296,7 @@ template <bool kVisitNativeRoots,
           typename Visitor>
 inline void DexCache::VisitReferences(ObjPtr<Class> klass, const Visitor& visitor) {
   // Visit instance fields first.
-  VisitInstanceFieldsReferences<kVerifyFlags, kReadBarrierOption>(klass, visitor);
+  VisitInstanceFieldsReferences<kVerifyFlags>(klass, visitor);
   // Visit arrays after.
   if (kVisitNativeRoots) {
     VisitNativeRoots<kVerifyFlags, kReadBarrierOption>(visitor);
diff --git a/runtime/mirror/dex_cache.h b/runtime/mirror/dex_cache.h
index c1d71e1501..c1d8cd8335 100644
--- a/runtime/mirror/dex_cache.h
+++ b/runtime/mirror/dex_cache.h
@@ -505,7 +505,7 @@ class MANAGED DexCache final : public Object {
                     kDexCacheFieldCacheSize,
                     LinearAllocKind::kNoGCRoots,
                     NativeArray<ArtField>,
-                    ArtField,
+                    ArtField*,
                     NumFieldIds,
                     LinearAllocKind::kNoGCRoots)
 
@@ -527,7 +527,7 @@ class MANAGED DexCache final : public Object {
                     kDexCacheMethodCacheSize,
                     LinearAllocKind::kNoGCRoots,
                     NativeArray<ArtMethod>,
-                    ArtMethod,
+                    ArtMethod*,
                     NumMethodIds,
                     LinearAllocKind::kNoGCRoots)
 
diff --git a/runtime/mirror/method_handle_impl.cc b/runtime/mirror/method_handle_impl.cc
index 0a37f95af8..5e80fb0925 100644
--- a/runtime/mirror/method_handle_impl.cc
+++ b/runtime/mirror/method_handle_impl.cc
@@ -16,9 +16,12 @@
 
 #include "method_handle_impl-inl.h"
 
+#include "art_method-alloc-inl.h"
 #include "class-alloc-inl.h"
 #include "class_root-inl.h"
 
+#include "well_known_classes.h"
+
 namespace art HIDDEN {
 namespace mirror {
 
@@ -49,8 +52,9 @@ ObjPtr<mirror::MethodHandleImpl> MethodHandleImpl::Create(Thread* const self,
     REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(!Roles::uninterruptible_) {
   StackHandleScope<1> hs(self);
   Handle<mirror::MethodHandleImpl> mh(hs.NewHandle(ObjPtr<MethodHandleImpl>::DownCast(
-      GetClassRoot<MethodHandleImpl>()->AllocObject(self))));
-  mh->Initialize(art_field_or_method, kind, method_type);
+      WellKnownClasses::java_lang_invoke_MethodHandleImpl_init->NewObject<'J', 'I', 'L'>(
+          self, art_field_or_method, static_cast<uint32_t>(kind), method_type))));
+
   return mh.Get();
 }
 
diff --git a/runtime/mirror/method_handle_impl.h b/runtime/mirror/method_handle_impl.h
index ba1763afe3..427a20013e 100644
--- a/runtime/mirror/method_handle_impl.h
+++ b/runtime/mirror/method_handle_impl.h
@@ -81,6 +81,18 @@ class MANAGED MethodHandle : public Object {
   // method or field.
   void VisitTarget(ReflectiveValueVisitor* v) REQUIRES(Locks::mutator_lock_);
 
+  static MemberOffset ArtFieldOrMethodOffset() {
+    return MemberOffset(OFFSETOF_MEMBER(MethodHandle, art_field_or_method_));
+  }
+
+  static MemberOffset HandleKindOffset() {
+    return MemberOffset(OFFSETOF_MEMBER(MethodHandle, handle_kind_));
+  }
+
+  static MemberOffset MethodTypeOffset() {
+    return MemberOffset(OFFSETOF_MEMBER(MethodHandle, method_type_));
+  }
+
  protected:
   void Initialize(uintptr_t art_field_or_method, Kind kind, Handle<MethodType> method_type)
       REQUIRES_SHARED(Locks::mutator_lock_);
@@ -99,15 +111,6 @@ class MANAGED MethodHandle : public Object {
   static MemberOffset AsTypeCacheOffset() {
     return MemberOffset(OFFSETOF_MEMBER(MethodHandle, as_type_cache_));
   }
-  static MemberOffset MethodTypeOffset() {
-    return MemberOffset(OFFSETOF_MEMBER(MethodHandle, method_type_));
-  }
-  static MemberOffset ArtFieldOrMethodOffset() {
-    return MemberOffset(OFFSETOF_MEMBER(MethodHandle, art_field_or_method_));
-  }
-  static MemberOffset HandleKindOffset() {
-    return MemberOffset(OFFSETOF_MEMBER(MethodHandle, handle_kind_));
-  }
 
   friend struct art::MethodHandleOffsets;  // for verifying offset information
   DISALLOW_IMPLICIT_CONSTRUCTORS(MethodHandle);
@@ -125,11 +128,7 @@ class MANAGED MethodHandleImpl : public MethodHandle {
       REQUIRES_SHARED(Locks::mutator_lock_) REQUIRES(!Roles::uninterruptible_);
 
  private:
-  static MemberOffset InfoOffset() {
-    return MemberOffset(OFFSETOF_MEMBER(MethodHandleImpl, info_));
-  }
-
-  HeapReference<mirror::Object> info_;  // Unused by the runtime.
+  HeapReference<mirror::Object> target_class_or_info_;  // Unused by the runtime.
 
   friend struct art::MethodHandleImplOffsets;  // for verifying offset information
   DISALLOW_IMPLICIT_CONSTRUCTORS(MethodHandleImpl);
diff --git a/runtime/mirror/object-inl.h b/runtime/mirror/object-inl.h
index 14b9ca3af0..6a6f50347c 100644
--- a/runtime/mirror/object-inl.h
+++ b/runtime/mirror/object-inl.h
@@ -46,7 +46,7 @@ namespace mirror {
 
 inline uint32_t Object::ClassSize(PointerSize pointer_size) {
   uint32_t vtable_entries = kVTableLength;
-  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, pointer_size);
+  return Class::ComputeClassSize(true, vtable_entries, 0, 0, 0, 0, 0, 0, pointer_size);
 }
 
 template<VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption>
@@ -345,6 +345,7 @@ inline bool Object::IsPhantomReferenceInstance() {
   return GetClass<kVerifyFlags>()->IsPhantomReferenceClass();
 }
 
+// TODO: optimize this by using class_flags_ to determine type
 template<VerifyObjectFlags kVerifyFlags>
 inline size_t Object::SizeOf() {
   // Read barrier is never required for SizeOf since objects sizes are constant. Reading from-space
@@ -858,65 +859,40 @@ inline void Object::UpdateField64ViaAccessor(MemberOffset field_offset,
   accessor->Access(addr);
 }
 
-template<bool kIsStatic,
-         VerifyObjectFlags kVerifyFlags,
-         ReadBarrierOption kReadBarrierOption,
-         typename Visitor>
-inline void Object::VisitFieldsReferences(uint32_t ref_offsets, const Visitor& visitor) {
-  if (!kIsStatic && (ref_offsets != mirror::Class::kClassWalkSuper)) {
-    // Instance fields and not the slow-path.
-    uint32_t field_offset = mirror::kObjectHeaderSize;
-    while (ref_offsets != 0) {
-      if ((ref_offsets & 1) != 0) {
-        visitor(this, MemberOffset(field_offset), kIsStatic);
-      }
-      ref_offsets >>= 1;
-      field_offset += sizeof(mirror::HeapReference<mirror::Object>);
+template <VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption, typename Visitor>
+inline void Object::VisitInstanceFieldsReferences(ObjPtr<Class> klass, const Visitor& visitor) {
+  // Using NO_THREAD_SAFETY_ANALYSIS as heap_bitmap_lock_ and mutator_lock_ are
+  // required in shared/exclusive modes in all possible combinations.
+  auto visit_one_word = [&visitor, this](uint32_t field_offset, uint32_t ref_offsets)
+                            NO_THREAD_SAFETY_ANALYSIS {
+                              while (ref_offsets != 0) {
+                                if ((ref_offsets & 1) != 0) {
+                                  visitor(this, MemberOffset(field_offset), /*is_static=*/false);
+                                }
+                                ref_offsets >>= 1;
+                                field_offset += sizeof(HeapReference<Object>);
+                              }
+                            };
+
+  uint32_t ref_offsets = klass->GetReferenceInstanceOffsets<kVerifyFlags>();
+  DCHECK_NE(ref_offsets, 0u) << klass->PrettyDescriptor();
+  if (UNLIKELY((ref_offsets & Class::kVisitReferencesSlowpathMask) != 0)) {
+    if (kIsDebugBuild) {
+      klass->VerifyOverflowReferenceBitmap<kVerifyFlags, kReadBarrierOption>();
     }
-  } else {
-    // There is no reference offset bitmap. In the non-static case, walk up the class
-    // inheritance hierarchy and find reference offsets the hard way. In the static case, just
-    // consider this class.
-    for (ObjPtr<Class> klass = kIsStatic
-            ? ObjPtr<Class>::DownCast(this)
-            : GetClass<kVerifyFlags, kReadBarrierOption>();
-        klass != nullptr;
-        klass = kIsStatic ? nullptr : klass->GetSuperClass<kVerifyFlags, kReadBarrierOption>()) {
-      const size_t num_reference_fields =
-          kIsStatic ? klass->NumReferenceStaticFields() : klass->NumReferenceInstanceFields();
-      if (num_reference_fields == 0u) {
-        continue;
-      }
-      // Presumably GC can happen when we are cross compiling, it should not cause performance
-      // problems to do pointer size logic.
-      MemberOffset field_offset = kIsStatic
-          ? klass->GetFirstReferenceStaticFieldOffset<kVerifyFlags>(
-              Runtime::Current()->GetClassLinker()->GetImagePointerSize())
-          : klass->GetFirstReferenceInstanceFieldOffset<kVerifyFlags, kReadBarrierOption>();
-      for (size_t i = 0u; i < num_reference_fields; ++i) {
-        // TODO: Do a simpler check?
-        if (field_offset.Uint32Value() != ClassOffset().Uint32Value()) {
-          visitor(this, field_offset, kIsStatic);
-        }
-        field_offset = MemberOffset(field_offset.Uint32Value() +
-                                    sizeof(mirror::HeapReference<mirror::Object>));
-      }
+    uint32_t bitmap_num_words = ref_offsets & ~Class::kVisitReferencesSlowpathMask;
+    uint32_t* overflow_bitmap = reinterpret_cast<uint32_t*>(
+        reinterpret_cast<uint8_t*>(klass.Ptr()) +
+        (klass->GetClassSize<kVerifyFlags>() - bitmap_num_words * sizeof(uint32_t)));
+    for (uint32_t i = 0; i < bitmap_num_words; i++) {
+      visit_one_word(kObjectHeaderSize + i * sizeof(HeapReference<Object>) * 32,
+                     overflow_bitmap[i]);
     }
+  } else {
+    visit_one_word(mirror::kObjectHeaderSize, ref_offsets);
   }
 }
 
-template<VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption, typename Visitor>
-inline void Object::VisitInstanceFieldsReferences(ObjPtr<Class> klass, const Visitor& visitor) {
-  VisitFieldsReferences<false, kVerifyFlags, kReadBarrierOption>(
-      klass->GetReferenceInstanceOffsets<kVerifyFlags>(), visitor);
-}
-
-template<VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption, typename Visitor>
-inline void Object::VisitStaticFieldsReferences(ObjPtr<Class> klass, const Visitor& visitor) {
-  DCHECK(!klass->IsTemp<kVerifyFlags>());
-  klass->VisitFieldsReferences<true, kVerifyFlags, kReadBarrierOption>(0, visitor);
-}
-
 template<VerifyObjectFlags kVerifyFlags, ReadBarrierOption kReadBarrierOption>
 inline bool Object::IsClassLoader() {
   return GetClass<kVerifyFlags, kReadBarrierOption>()->template IsClassLoaderClass<kVerifyFlags>();
diff --git a/runtime/mirror/object-refvisitor-inl.h b/runtime/mirror/object-refvisitor-inl.h
index 7010263c71..140ef9f93b 100644
--- a/runtime/mirror/object-refvisitor-inl.h
+++ b/runtime/mirror/object-refvisitor-inl.h
@@ -72,6 +72,7 @@ inline void Object::VisitReferences(const Visitor& visitor,
   const uint32_t class_flags = klass->GetClassFlags<kVerifyNone>();
   if (LIKELY(class_flags == kClassFlagNormal) || class_flags == kClassFlagRecord) {
     CheckNormalClass<kVerifyFlags>(klass);
+    DCHECK(klass->IsInstantiableNonArray()) << klass->PrettyDescriptor();
     VisitInstanceFieldsReferences<kVerifyFlags, kReadBarrierOption>(klass, visitor);
     return;
   }
@@ -84,24 +85,27 @@ inline void Object::VisitReferences(const Visitor& visitor,
   DCHECK(!klass->IsStringClass<kVerifyFlags>());
   if (class_flags == kClassFlagClass) {
     DCHECK(klass->IsClassClass<kVerifyFlags>());
+    DCHECK(klass->IsInstantiableNonArray()) << klass->PrettyDescriptor();
     ObjPtr<Class> as_klass = AsClass<kVerifyNone>();
     as_klass->VisitReferences<kVisitNativeRoots, kVerifyFlags, kReadBarrierOption>(klass, visitor);
     return;
   }
 
-  if (class_flags == kClassFlagObjectArray) {
+  if ((class_flags & kClassFlagObjectArray) != 0) {
     DCHECK((klass->IsObjectArrayClass<kVerifyFlags, kReadBarrierOption>()));
     AsObjectArray<mirror::Object, kVerifyNone>()->VisitReferences(visitor);
     return;
   }
 
   if ((class_flags & kClassFlagReference) != 0) {
+    DCHECK(klass->IsInstantiableNonArray()) << klass->PrettyDescriptor();
     VisitInstanceFieldsReferences<kVerifyFlags, kReadBarrierOption>(klass, visitor);
     ref_visitor(klass, AsReference<kVerifyFlags, kReadBarrierOption>());
     return;
   }
 
   if (class_flags == kClassFlagDexCache) {
+    DCHECK(klass->IsInstantiableNonArray()) << klass->PrettyDescriptor();
     DCHECK(klass->IsDexCacheClass<kVerifyFlags>());
     ObjPtr<mirror::DexCache> const dex_cache = AsDexCache<kVerifyFlags, kReadBarrierOption>();
     dex_cache->VisitReferences<kVisitNativeRoots,
@@ -111,6 +115,7 @@ inline void Object::VisitReferences(const Visitor& visitor,
   }
 
   if (class_flags == kClassFlagClassLoader) {
+    DCHECK(klass->IsInstantiableNonArray()) << klass->PrettyDescriptor();
     DCHECK(klass->IsClassLoaderClass<kVerifyFlags>());
     ObjPtr<mirror::ClassLoader> const class_loader =
         AsClassLoader<kVerifyFlags, kReadBarrierOption>();
@@ -147,13 +152,11 @@ inline size_t Object::VisitRefsForCompaction(const Visitor& visitor,
   } else if ((class_flags & kClassFlagNoReferenceFields) != 0) {
     if ((class_flags & kClassFlagString) != 0) {
       size = kFetchObjSize ? static_cast<String*>(this)->SizeOf<kSizeOfFlags>() : 0;
-    } else if (klass->IsArrayClass<kVerifyFlags>()) {
-      // TODO: We can optimize this by implementing a SizeOf() version which takes
-      // component-size-shift as an argument, thereby avoiding multiple loads of
-      // component_type.
-      size = kFetchObjSize
-             ? static_cast<Array*>(this)->SizeOf<kSizeOfFlags, kReadBarrierOption>()
-             : 0;
+    } else if ((class_flags & kClassFlagPrimitiveArray) != 0) {
+      ObjPtr<Array> arr = ObjPtr<Array>::DownCast(this);
+      size = kFetchObjSize ?
+                 arr->SizeOf<kSizeOfFlags>(class_flags >> kArrayComponentSizeShiftShift) :
+                 0;
     } else {
       // Only possibility left is of a normal klass instance with no references.
       size = kFetchObjSize ? klass->GetObjectSize<kSizeOfFlags>() : 0;
@@ -164,11 +167,11 @@ inline size_t Object::VisitRefsForCompaction(const Visitor& visitor,
     as_klass->VisitReferences<kVisitNativeRoots, kVerifyFlags, kReadBarrierOption>(klass,
                                                                                    visitor);
     size = kFetchObjSize ? as_klass->SizeOf<kSizeOfFlags>() : 0;
-  } else if (class_flags == kClassFlagObjectArray) {
+  } else if ((class_flags & kClassFlagObjectArray) != 0) {
     ObjPtr<ObjectArray<Object>> obj_arr = ObjPtr<ObjectArray<Object>>::DownCast(this);
     obj_arr->VisitReferences(visitor, begin, end);
     size = kFetchObjSize ?
-               obj_arr->SizeOf<kSizeOfFlags, kReadBarrierOption, /*kIsObjArray*/ true>() :
+               obj_arr->SizeOf<kSizeOfFlags>(class_flags >> kArrayComponentSizeShiftShift) :
                0;
   } else if ((class_flags & kClassFlagReference) != 0) {
     VisitInstanceFieldsReferences<kVerifyFlags, kReadBarrierOption>(klass, visitor);
diff --git a/runtime/mirror/object.h b/runtime/mirror/object.h
index debac07aba..97e218b4de 100644
--- a/runtime/mirror/object.h
+++ b/runtime/mirror/object.h
@@ -714,23 +714,11 @@ class EXPORT MANAGED LOCKABLE Object {
     }
   }
 
-  // TODO: Fixme when anotatalysis works with visitors.
-  template<bool kIsStatic,
-          VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
-          ReadBarrierOption kReadBarrierOption = kWithReadBarrier,
-          typename Visitor>
-  void VisitFieldsReferences(uint32_t ref_offsets, const Visitor& visitor) HOT_ATTR
-      NO_THREAD_SAFETY_ANALYSIS;
-  template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
-           ReadBarrierOption kReadBarrierOption = kWithReadBarrier,
-           typename Visitor>
+  template <VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
+            ReadBarrierOption kReadBarrierOption = kWithReadBarrier,
+            typename Visitor>
   void VisitInstanceFieldsReferences(ObjPtr<mirror::Class> klass, const Visitor& visitor) HOT_ATTR
       REQUIRES_SHARED(Locks::mutator_lock_);
-  template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
-           ReadBarrierOption kReadBarrierOption = kWithReadBarrier,
-           typename Visitor>
-  void VisitStaticFieldsReferences(ObjPtr<mirror::Class> klass, const Visitor& visitor) HOT_ATTR
-      REQUIRES_SHARED(Locks::mutator_lock_);
 
  private:
   template <bool kAllowInflation>
diff --git a/runtime/mirror/reference-inl.h b/runtime/mirror/reference-inl.h
index c8a0957a0a..ac3d7c424b 100644
--- a/runtime/mirror/reference-inl.h
+++ b/runtime/mirror/reference-inl.h
@@ -27,7 +27,7 @@ namespace mirror {
 
 inline uint32_t Reference::ClassSize(PointerSize pointer_size) {
   uint32_t vtable_entries = Object::kVTableLength + 4;
-  return Class::ComputeClassSize(false, vtable_entries, 2, 0, 0, 0, 0, pointer_size);
+  return Class::ComputeClassSize(false, vtable_entries, 2, 0, 0, 0, 0, 0, pointer_size);
 }
 
 template<bool kTransactionActive>
diff --git a/runtime/mirror/string-inl.h b/runtime/mirror/string-inl.h
index c76ef69b1d..97f1fb8fc6 100644
--- a/runtime/mirror/string-inl.h
+++ b/runtime/mirror/string-inl.h
@@ -39,7 +39,7 @@ inline uint32_t String::ClassSize(PointerSize pointer_size) {
 #else
   uint32_t vtable_entries = Object::kVTableLength + 72;
 #endif
-  return Class::ComputeClassSize(true, vtable_entries, 3, 0, 0, 1, 3, pointer_size);
+  return Class::ComputeClassSize(true, vtable_entries, 3, 0, 0, 1, 3, 0, pointer_size);
 }
 
 inline uint16_t String::CharAt(int32_t index) {
diff --git a/runtime/mirror/var_handle.cc b/runtime/mirror/var_handle.cc
index ec332cbcbc..f246e5fd6b 100644
--- a/runtime/mirror/var_handle.cc
+++ b/runtime/mirror/var_handle.cc
@@ -1548,7 +1548,7 @@ VarHandle::AccessMode VarHandle::GetAccessModeByIntrinsic(Intrinsics intrinsic)
     default:
       break;
   }
-  LOG(FATAL) << "Unknown VarHandle instrinsic: " << static_cast<int>(intrinsic);
+  LOG(FATAL) << "Unknown VarHandle intrinsic: " << static_cast<int>(intrinsic);
   UNREACHABLE();
 }
 
diff --git a/runtime/native/dalvik_system_VMDebug.cc b/runtime/native/dalvik_system_VMDebug.cc
index 18120fe826..11d2898c3c 100644
--- a/runtime/native/dalvik_system_VMDebug.cc
+++ b/runtime/native/dalvik_system_VMDebug.cc
@@ -50,6 +50,7 @@
 #include "string_array_utils.h"
 #include "thread-inl.h"
 #include "trace.h"
+#include "trace_profile.h"
 
 namespace art HIDDEN {
 
@@ -153,6 +154,46 @@ static void VMDebug_stopMethodTracing(JNIEnv*, jclass) {
   Trace::Stop();
 }
 
+static void VMDebug_stopLowOverheadTraceImpl(JNIEnv*, jclass) {
+  TraceProfiler::Stop();
+}
+
+static void VMDebug_dumpLowOverheadTraceImpl(JNIEnv* env, jclass, jstring javaProfileFileName) {
+  ScopedUtfChars profileFileName(env, javaProfileFileName);
+  if (profileFileName.c_str() == nullptr) {
+    LOG(ERROR) << "Filename not provided, ignoring the request to dump profile";
+    return;
+  }
+  TraceProfiler::Dump(profileFileName.c_str());
+}
+
+static void VMDebug_dumpLowOverheadTraceFdImpl(JNIEnv* env, jclass, jint originalFd) {
+  if (originalFd < 0) {
+    ScopedObjectAccess soa(env);
+    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;",
+                                   "Trace fd is invalid: %d",
+                                   originalFd);
+    return;
+  }
+
+  // Set the O_CLOEXEC flag atomically here, so the file gets closed when a new process is forked.
+  int fd = DupCloexec(originalFd);
+  if (fd < 0) {
+    ScopedObjectAccess soa(env);
+    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;",
+                                   "dup(%d) failed: %s",
+                                   originalFd,
+                                   strerror(errno));
+    return;
+  }
+
+  TraceProfiler::Dump(fd);
+}
+
+static void VMDebug_startLowOverheadTraceImpl(JNIEnv*, jclass) {
+  TraceProfiler::Start();
+}
+
 static jboolean VMDebug_isDebuggerConnected(JNIEnv*, jclass) {
   // This function will be replaced by the debugger when it's connected. See
   // external/oj-libjdwp/src/share/vmDebug.c for implementation when debugger is connected.
@@ -593,6 +634,10 @@ static JNINativeMethod gMethods[] = {
     NATIVE_METHOD(VMDebug, addApplication, "(Ljava/lang/String;)V"),
     NATIVE_METHOD(VMDebug, removeApplication, "(Ljava/lang/String;)V"),
     NATIVE_METHOD(VMDebug, setUserId, "(I)V"),
+    NATIVE_METHOD(VMDebug, startLowOverheadTraceImpl, "()V"),
+    NATIVE_METHOD(VMDebug, stopLowOverheadTraceImpl, "()V"),
+    NATIVE_METHOD(VMDebug, dumpLowOverheadTraceImpl, "(Ljava/lang/String;)V"),
+    NATIVE_METHOD(VMDebug, dumpLowOverheadTraceFdImpl, "(I)V"),
 };
 
 void register_dalvik_system_VMDebug(JNIEnv* env) {
diff --git a/runtime/native/dalvik_system_VMRuntime.cc b/runtime/native/dalvik_system_VMRuntime.cc
index 1b7ed5cc08..0e9660aaac 100644
--- a/runtime/native/dalvik_system_VMRuntime.cc
+++ b/runtime/native/dalvik_system_VMRuntime.cc
@@ -536,6 +536,11 @@ static jobject VMRuntime_getBaseApkOptimizationInfo(JNIEnv* env, [[maybe_unused]
   return env->NewObject(cls.get(), ctor, j_compiler_filter.get(), j_compilation_reason.get());
 }
 
+static jlong VMRuntime_getFullGcCount([[maybe_unused]] JNIEnv* env, [[maybe_unused]] jclass klass) {
+  metrics::ArtMetrics* metrics = GetMetrics();
+  return metrics->FullGcCount()->Value();
+}
+
 static JNINativeMethod gMethods[] = {
   FAST_NATIVE_METHOD(VMRuntime, addressOf, "(Ljava/lang/Object;)J"),
   NATIVE_METHOD(VMRuntime, bootClassPath, "()Ljava/lang/String;"),
@@ -587,6 +592,7 @@ static JNINativeMethod gMethods[] = {
   NATIVE_METHOD(VMRuntime, isValidClassLoaderContext, "(Ljava/lang/String;)Z"),
   NATIVE_METHOD(VMRuntime, getBaseApkOptimizationInfo,
       "()Ldalvik/system/DexFile$OptimizationInfo;"),
+  NATIVE_METHOD(VMRuntime, getFullGcCount, "()J"),
 };
 
 void register_dalvik_system_VMRuntime(JNIEnv* env) {
diff --git a/runtime/native/dalvik_system_VMStack.cc b/runtime/native/dalvik_system_VMStack.cc
index 366059bd17..f55e2b5c18 100644
--- a/runtime/native/dalvik_system_VMStack.cc
+++ b/runtime/native/dalvik_system_VMStack.cc
@@ -76,7 +76,7 @@ static jint VMStack_fillStackTraceElements(JNIEnv* env, jclass, jobject javaThre
   ScopedFastNativeObjectAccess soa(env);
   auto fn = [](Thread* thread, const ScopedFastNativeObjectAccess& soaa)
       REQUIRES_SHARED(Locks::mutator_lock_) -> jobject {
-    return thread->CreateInternalStackTrace(soaa);
+    return soaa.AddLocalReference<jobject>(thread->CreateInternalStackTrace(soaa));
   };
   jobject trace = GetThreadStack(soa, javaThread, fn);
   if (trace == nullptr) {
@@ -143,7 +143,7 @@ static jobjectArray VMStack_getThreadStackTrace(JNIEnv* env, jclass, jobject jav
   ScopedFastNativeObjectAccess soa(env);
   auto fn = [](Thread* thread, const ScopedFastNativeObjectAccess& soaa)
      REQUIRES_SHARED(Locks::mutator_lock_) -> jobject {
-    return thread->CreateInternalStackTrace(soaa);
+    return soaa.AddLocalReference<jobject>(thread->CreateInternalStackTrace(soaa));
   };
   jobject trace = GetThreadStack(soa, javaThread, fn);
   if (trace == nullptr) {
diff --git a/runtime/native/java_lang_StackStreamFactory.cc b/runtime/native/java_lang_StackStreamFactory.cc
index 24d903047d..78e38a0914 100644
--- a/runtime/native/java_lang_StackStreamFactory.cc
+++ b/runtime/native/java_lang_StackStreamFactory.cc
@@ -27,7 +27,7 @@ namespace art HIDDEN {
 
 static jobject StackStreamFactory_nativeGetStackAnchor(JNIEnv* env, jclass) {
   ScopedFastNativeObjectAccess soa(env);
-  return soa.Self()->CreateInternalStackTrace(soa);
+  return soa.AddLocalReference<jobject>(soa.Self()->CreateInternalStackTrace(soa));
 }
 
 static jint StackStreamFactory_nativeFetchStackFrameInfo(JNIEnv* env, jclass,
diff --git a/runtime/native/java_lang_Throwable.cc b/runtime/native/java_lang_Throwable.cc
index 091ad03bb2..45496b1a3c 100644
--- a/runtime/native/java_lang_Throwable.cc
+++ b/runtime/native/java_lang_Throwable.cc
@@ -27,7 +27,7 @@ namespace art HIDDEN {
 
 static jobject Throwable_nativeFillInStackTrace(JNIEnv* env, jclass) {
   ScopedFastNativeObjectAccess soa(env);
-  return soa.Self()->CreateInternalStackTrace(soa);
+  return soa.AddLocalReference<jobject>(soa.Self()->CreateInternalStackTrace(soa));
 }
 
 static jobjectArray Throwable_nativeGetStackTrace(JNIEnv* env, jclass, jobject javaStackState) {
diff --git a/runtime/native/org_apache_harmony_dalvik_ddmc_DdmVmInternal.cc b/runtime/native/org_apache_harmony_dalvik_ddmc_DdmVmInternal.cc
index 2ba10fa7e3..e26d804daa 100644
--- a/runtime/native/org_apache_harmony_dalvik_ddmc_DdmVmInternal.cc
+++ b/runtime/native/org_apache_harmony_dalvik_ddmc_DdmVmInternal.cc
@@ -55,7 +55,7 @@ static jobjectArray DdmVmInternal_getStackTraceById(JNIEnv* env, jclass, jint th
   if (static_cast<uint32_t>(thin_lock_id) == self->GetThreadId()) {
     // No need to suspend ourself to build stacktrace.
     ScopedObjectAccess soa(env);
-    jobject internal_trace = self->CreateInternalStackTrace(soa);
+    jobject internal_trace = soa.AddLocalReference<jobject>(self->CreateInternalStackTrace(soa));
     trace = Thread::InternalStackTraceToStackTraceElementArray(soa, internal_trace);
   } else {
     ThreadList* thread_list = Runtime::Current()->GetThreadList();
@@ -70,7 +70,8 @@ static jobjectArray DdmVmInternal_getStackTraceById(JNIEnv* env, jclass, jint th
     if (thread != nullptr) {
       {
         ScopedObjectAccess soa(env);
-        jobject internal_trace = thread->CreateInternalStackTrace(soa);
+        jobject internal_trace =
+            soa.AddLocalReference<jobject>(thread->CreateInternalStackTrace(soa));
         trace = Thread::InternalStackTraceToStackTraceElementArray(soa, internal_trace);
       }
       // Restart suspended thread.
diff --git a/runtime/native_gc_triggering.md b/runtime/native_gc_triggering.md
index 3e8fb08f01..8adbb94bf3 100644
--- a/runtime/native_gc_triggering.md
+++ b/runtime/native_gc_triggering.md
@@ -45,10 +45,13 @@ difficult to approximate, even to within an order of magnitude.
 The triggering heuristic
 ------------------------
 
-We normally check for the need to trigger a GC due to native memory pressure only as a result of
-calls to the `NativeAllocationRegistry` or `VMRuntime.registerNativeAllocation` APIs. Thus an
-application not using these APIs, e.g. because it is running almost entirely native code, may
-never do so. This is generally a feature, rather than a bug.
+Though we use mallinfo() to track native allocation, this call itself can be expensive, and thus
+we perform this check fairly rarely. More precisely, we do so only after the application has
+called `NativeAllocationRegistry.registerNativeAllocation()` a certain number of times or
+with a sufficiently large argument, or after `VMRuntime.registerNativeAllocation` is called.
+Thus an application not using these APIs, e.g. because it is running almost entirely native
+code, may never do so. This can be useful, in that an application that runs basically only
+native code, and thus deallocates its own native memory, does not trigger the GC.
 
 The actual computation for triggering a native-allocation-GC is performed by
 `Heap::NativeMemoryOverTarget()`. This computes and compares two quantities:
diff --git a/runtime/noop_compiler_callbacks.h b/runtime/noop_compiler_callbacks.h
index 34e15e71ad..2a4a45af17 100644
--- a/runtime/noop_compiler_callbacks.h
+++ b/runtime/noop_compiler_callbacks.h
@@ -18,15 +18,21 @@
 #define ART_RUNTIME_NOOP_COMPILER_CALLBACKS_H_
 
 #include "base/macros.h"
+#include "class_linker.h"
 #include "compiler_callbacks.h"
 
 namespace art HIDDEN {
 
+// Used for tests and some tools that pretend to be a compiler (say, oatdump).
 class NoopCompilerCallbacks final : public CompilerCallbacks {
  public:
   NoopCompilerCallbacks() : CompilerCallbacks(CompilerCallbacks::CallbackMode::kCompileApp) {}
   ~NoopCompilerCallbacks() {}
 
+  ClassLinker* CreateAotClassLinker(InternTable* intern_table) override {
+    return new PermissiveClassLinker(intern_table);
+  }
+
   void AddUncompilableMethod([[maybe_unused]] MethodReference ref) override {}
   void AddUncompilableClass([[maybe_unused]] ClassReference ref) override {}
   void ClassRejected([[maybe_unused]] ClassReference ref) override {}
@@ -34,6 +40,190 @@ class NoopCompilerCallbacks final : public CompilerCallbacks {
   verifier::VerifierDeps* GetVerifierDeps() const override { return nullptr; }
 
  private:
+  // When we supply compiler callbacks, we need an appropriate `ClassLinker` that can
+  // handle `SdkChecker`-related calls that are unimplemented in the base `ClassLinker`.
+  class PermissiveClassLinker : public ClassLinker {
+   public:
+    explicit PermissiveClassLinker(InternTable* intern_table)
+        : ClassLinker(intern_table, /*fast_class_not_found_exceptions=*/ false) {}
+
+    bool DenyAccessBasedOnPublicSdk([[maybe_unused]] ArtMethod* art_method) const override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      return false;
+    }
+    bool DenyAccessBasedOnPublicSdk([[maybe_unused]] ArtField* art_field) const override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      return false;
+    }
+    bool DenyAccessBasedOnPublicSdk(
+        [[maybe_unused]] std::string_view type_descriptor) const override {
+      return false;
+    }
+    void SetEnablePublicSdkChecks([[maybe_unused]] bool enabled) override {}
+
+    // Transaction-related virtual functions should not be called on `PermissiveClassLinker`.
+
+    bool TransactionWriteConstraint([[maybe_unused]] Thread* self,
+                                    [[maybe_unused]] ObjPtr<mirror::Object> obj) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    bool TransactionWriteValueConstraint([[maybe_unused]] Thread* self,
+                                         [[maybe_unused]] ObjPtr<mirror::Object> value) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    bool TransactionAllocationConstraint([[maybe_unused]] Thread* self,
+                                         [[maybe_unused]] ObjPtr<mirror::Class> klass) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteFieldBoolean([[maybe_unused]] mirror::Object* obj,
+                                 [[maybe_unused]] MemberOffset field_offset,
+                                 [[maybe_unused]] uint8_t value,
+                                 [[maybe_unused]] bool is_volatile) override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteFieldByte([[maybe_unused]] mirror::Object* obj,
+                              [[maybe_unused]] MemberOffset field_offset,
+                              [[maybe_unused]] int8_t value,
+                              [[maybe_unused]] bool is_volatile) override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteFieldChar([[maybe_unused]] mirror::Object* obj,
+                              [[maybe_unused]] MemberOffset field_offset,
+                              [[maybe_unused]] uint16_t value,
+                              [[maybe_unused]] bool is_volatile) override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteFieldShort([[maybe_unused]] mirror::Object* obj,
+                               [[maybe_unused]] MemberOffset field_offset,
+                               [[maybe_unused]] int16_t value,
+                               [[maybe_unused]] bool is_volatile) override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteField32([[maybe_unused]] mirror::Object* obj,
+                            [[maybe_unused]] MemberOffset field_offset,
+                            [[maybe_unused]] uint32_t value,
+                            [[maybe_unused]] bool is_volatile) override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteField64([[maybe_unused]] mirror::Object* obj,
+                            [[maybe_unused]] MemberOffset field_offset,
+                            [[maybe_unused]] uint64_t value,
+                            [[maybe_unused]] bool is_volatile) override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteFieldReference([[maybe_unused]] mirror::Object* obj,
+                                   [[maybe_unused]] MemberOffset field_offset,
+                                   [[maybe_unused]] ObjPtr<mirror::Object> value,
+                                   [[maybe_unused]] bool is_volatile) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWriteArray([[maybe_unused]] mirror::Array* array,
+                          [[maybe_unused]] size_t index,
+                          [[maybe_unused]] uint64_t value) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordStrongStringInsertion([[maybe_unused]] ObjPtr<mirror::String> s) override
+        REQUIRES(Locks::intern_table_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWeakStringInsertion([[maybe_unused]] ObjPtr<mirror::String> s) override
+        REQUIRES(Locks::intern_table_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordStrongStringRemoval([[maybe_unused]] ObjPtr<mirror::String> s) override
+        REQUIRES(Locks::intern_table_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordWeakStringRemoval([[maybe_unused]] ObjPtr<mirror::String> s) override
+        REQUIRES(Locks::intern_table_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordResolveString([[maybe_unused]] ObjPtr<mirror::DexCache> dex_cache,
+                             [[maybe_unused]] dex::StringIndex string_idx) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void RecordResolveMethodType([[maybe_unused]] ObjPtr<mirror::DexCache> dex_cache,
+                                 [[maybe_unused]] dex::ProtoIndex proto_idx) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void ThrowTransactionAbortError([[maybe_unused]] Thread* self) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void AbortTransactionF([[maybe_unused]] Thread* self,
+                           [[maybe_unused]] const char* fmt, ...) override
+        __attribute__((__format__(__printf__, 3, 4)))
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void AbortTransactionV([[maybe_unused]] Thread* self,
+                           [[maybe_unused]] const char* fmt,
+                           [[maybe_unused]] va_list args) override
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    bool IsTransactionAborted() const override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+
+    void VisitTransactionRoots([[maybe_unused]] RootVisitor* visitor) override {
+      // Nothing to do for `PermissiveClassLinker`, only `AotClassLinker` handles transactions.
+    }
+
+    const void* GetTransactionalInterpreter() override {
+      LOG(FATAL) << "UNREACHABLE";
+      UNREACHABLE();
+    }
+  };
+
   DISALLOW_COPY_AND_ASSIGN(NoopCompilerCallbacks);
 };
 
diff --git a/runtime/oat/elf_file.cc b/runtime/oat/elf_file.cc
index c66cba1dd0..436a28a603 100644
--- a/runtime/oat/elf_file.cc
+++ b/runtime/oat/elf_file.cc
@@ -1688,6 +1688,8 @@ size_t ElfFile::GetElfSegmentAlignmentFromFile() const {
   DELEGATE_TO_IMPL(GetElfSegmentAlignmentFromFile);
 }
 
+const uint8_t* ElfFile::GetBaseAddress() const { DELEGATE_TO_IMPL(GetBaseAddress); }
+
 bool ElfFile::Strip(File* file, std::string* error_msg) {
   std::unique_ptr<ElfFile> elf_file(ElfFile::Open(file, true, false, /*low_4gb=*/false, error_msg));
   if (elf_file.get() == nullptr) {
diff --git a/runtime/oat/elf_file.h b/runtime/oat/elf_file.h
index 125b4441f1..90e6c61817 100644
--- a/runtime/oat/elf_file.h
+++ b/runtime/oat/elf_file.h
@@ -84,6 +84,8 @@ class ElfFile {
 
   size_t GetElfSegmentAlignmentFromFile() const;
 
+  const uint8_t* GetBaseAddress() const;
+
   // Strip an ELF file of unneeded debugging information.
   // Returns true on success, false on failure.
   static bool Strip(File* file, std::string* error_msg);
diff --git a/runtime/oat/image.cc b/runtime/oat/image.cc
index f69989b592..d1ab8a1cce 100644
--- a/runtime/oat/image.cc
+++ b/runtime/oat/image.cc
@@ -34,8 +34,8 @@
 namespace art HIDDEN {
 
 const uint8_t ImageHeader::kImageMagic[] = { 'a', 'r', 't', '\n' };
-// Last change: Add unsignedRemainder intrinsics.
-const uint8_t ImageHeader::kImageVersion[] = { '1', '1', '1', '\0' };
+// Last change: Add intrinsics for Unsafe/JdkUnsafe.arrayBaseOffset.
+const uint8_t ImageHeader::kImageVersion[] = { '1', '1', '4', '\0' };
 
 ImageHeader::ImageHeader(uint32_t image_reservation_size,
                          uint32_t component_count,
diff --git a/runtime/oat/jni_stub_hash_map-inl.h b/runtime/oat/jni_stub_hash_map-inl.h
new file mode 100644
index 0000000000..5ac0308a5b
--- /dev/null
+++ b/runtime/oat/jni_stub_hash_map-inl.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_OAT_JNI_STUB_HASH_MAP_INL_H_
+#define ART_RUNTIME_OAT_JNI_STUB_HASH_MAP_INL_H_
+
+#include "jni_stub_hash_map.h"
+
+#include "art_method-inl.h"
+
+namespace art {
+
+inline JniStubKey::JniStubKey(uint32_t flags, std::string_view shorty)
+    : flags_(flags & (kAccStatic | kAccSynchronized | kAccFastNative | kAccCriticalNative)),
+      shorty_(shorty) {
+  DCHECK(ArtMethod::IsNative(flags));
+}
+
+inline JniStubKey::JniStubKey(ArtMethod* method)
+    : JniStubKey(method->GetAccessFlags(), method->GetShortyView()) {}
+
+}  // namespace art
+
+#endif  // ART_RUNTIME_OAT_JNI_STUB_HASH_MAP_INL_H_
diff --git a/runtime/oat/jni_stub_hash_map.cc b/runtime/oat/jni_stub_hash_map.cc
index fccf697b7d..add1005291 100644
--- a/runtime/oat/jni_stub_hash_map.cc
+++ b/runtime/oat/jni_stub_hash_map.cc
@@ -21,6 +21,7 @@
 #include "arch/riscv64/jni_frame_riscv64.h"
 #include "arch/x86_64/jni_frame_x86_64.h"
 #include "base/macros.h"
+#include "dex/modifiers.h"
 
 namespace art HIDDEN {
 
diff --git a/runtime/oat/jni_stub_hash_map.h b/runtime/oat/jni_stub_hash_map.h
index 6e4603d3fb..83528843e0 100644
--- a/runtime/oat/jni_stub_hash_map.h
+++ b/runtime/oat/jni_stub_hash_map.h
@@ -21,25 +21,22 @@
 #include <string_view>
 
 #include "arch/instruction_set.h"
-#include "art_method.h"
 #include "base/hash_map.h"
+#include "base/locks.h"
 
 namespace art HIDDEN {
 
+class ArtMethod;
+
 class JniStubKey {
  public:
   JniStubKey() = default;
   JniStubKey(const JniStubKey& other) = default;
   JniStubKey& operator=(const JniStubKey& other) = default;
 
-  JniStubKey(uint32_t flags, std::string_view shorty)
-      : flags_(flags & (kAccStatic | kAccSynchronized | kAccFastNative | kAccCriticalNative)),
-        shorty_(shorty) {
-    DCHECK(ArtMethod::IsNative(flags));
-  }
+  JniStubKey(uint32_t flags, std::string_view shorty);
 
-  explicit JniStubKey(ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_)
-      : JniStubKey(method->GetAccessFlags(), method->GetShortyView()) {}
+  explicit JniStubKey(ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_);
 
   uint32_t Flags() const {
     return flags_;
diff --git a/runtime/oat/oat.h b/runtime/oat/oat.h
index b850fe8dd5..fa50571b27 100644
--- a/runtime/oat/oat.h
+++ b/runtime/oat/oat.h
@@ -44,8 +44,8 @@ std::ostream& operator<<(std::ostream& stream, StubType stub_type);
 class EXPORT PACKED(4) OatHeader {
  public:
   static constexpr std::array<uint8_t, 4> kOatMagic { { 'o', 'a', 't', '\n' } };
-  // Last oat version changed reason: Implement `HLoadClass::LoadKind::kAppImageRelRo`.
-  static constexpr std::array<uint8_t, 4> kOatVersion{{'2', '4', '4', '\0'}};
+  // Last oat version changed reason: Adding new entrypoints for InvokeExact intrisic.
+  static constexpr std::array<uint8_t, 4> kOatVersion{{'2', '4', '7', '\0'}};
 
   static constexpr const char* kDex2OatCmdLineKey = "dex2oat-cmdline";
   static constexpr const char* kDebuggableKey = "debuggable";
diff --git a/runtime/oat/oat_file.cc b/runtime/oat/oat_file.cc
index 655591f879..879e3f1622 100644
--- a/runtime/oat/oat_file.cc
+++ b/runtime/oat/oat_file.cc
@@ -17,27 +17,17 @@
 #include "oat_file.h"
 
 #include <dlfcn.h>
-
-#ifndef __APPLE__
-#include <link.h>  // for dl_iterate_phdr.
-#endif
+#include <sys/stat.h>
 #include <unistd.h>
 
+#include <cstdint>
 #include <cstdlib>
 #include <cstring>
 #include <sstream>
 #include <type_traits>
-#include <sys/stat.h>
-
-// dlopen_ext support from bionic.
-#ifdef ART_TARGET_ANDROID
-#include "android/dlext.h"
-#include "nativeloader/dlext_namespaces.h"
-#endif
 
-#include <android-base/logging.h>
+#include "android-base/logging.h"
 #include "android-base/stringprintf.h"
-
 #include "arch/instruction_set_features.h"
 #include "art_method.h"
 #include "base/bit_vector.h"
@@ -61,9 +51,9 @@
 #include "dex/utf-inl.h"
 #include "elf/elf_utils.h"
 #include "elf_file.h"
-#include "gc_root.h"
 #include "gc/heap.h"
 #include "gc/space/image_space.h"
+#include "gc_root.h"
 #include "mirror/class.h"
 #include "mirror/object-inl.h"
 #include "oat.h"
@@ -73,6 +63,16 @@
 #include "vdex_file.h"
 #include "verifier/verifier_deps.h"
 
+#ifndef __APPLE__
+#include <link.h>  // for dl_iterate_phdr.
+#endif
+
+// dlopen_ext support from bionic.
+#ifdef ART_TARGET_ANDROID
+#include "android/dlext.h"
+#include "nativeloader/dlext_namespaces.h"
+#endif
+
 namespace art HIDDEN {
 
 using android::base::StringAppendV;
@@ -1170,6 +1170,16 @@ class DlOpenOatFile final : public OatFileBase {
   // Ask the linker where it mmaped the file and notify our mmap wrapper of the regions.
   void PreSetup(const std::string& elf_filename) override;
 
+  const uint8_t* ComputeElfBegin(std::string* error_msg) const override {
+    Dl_info info;
+    if (dladdr(Begin(), &info) == 0) {
+      *error_msg =
+          StringPrintf("Failed to dladdr '%s': %s", GetLocation().c_str(), strerror(errno));
+      return nullptr;
+    }
+    return reinterpret_cast<const uint8_t*>(info.dli_fbase);
+  }
+
  private:
   bool Dlopen(const std::string& elf_filename,
               /*inout*/MemMap* reservation,  // Where to load if not null.
@@ -1601,6 +1611,10 @@ class ElfOatFile final : public OatFileBase {
 
   void PreSetup([[maybe_unused]] const std::string& elf_filename) override {}
 
+  const uint8_t* ComputeElfBegin(std::string*) const override {
+    return elf_file_->GetBaseAddress();
+  }
+
  private:
   bool ElfFileOpen(File* file,
                    bool writable,
@@ -1888,6 +1902,12 @@ class OatFileBackedByVdex final : public OatFileBase {
     return nullptr;
   }
 
+  const uint8_t* ComputeElfBegin(std::string* error_msg) const override {
+    *error_msg = StringPrintf("Cannot get ELF begin because '%s' is not backed by an ELF file",
+                              GetLocation().c_str());
+    return nullptr;
+  }
+
  private:
   std::unique_ptr<OatHeader> oat_header_;
 
diff --git a/runtime/oat/oat_file.h b/runtime/oat/oat_file.h
index d37dc76c54..39304f6a8c 100644
--- a/runtime/oat/oat_file.h
+++ b/runtime/oat/oat_file.h
@@ -361,6 +361,10 @@ class OatFile {
     return DexEnd() - DexBegin();
   }
 
+  // Returns the base address of the ELF file, or nullptr if the oat file is not backed by an ELF
+  // file or an error occurred.
+  virtual const uint8_t* ComputeElfBegin(std::string* error_msg) const = 0;
+
   EXPORT const uint8_t* Begin() const;
   EXPORT const uint8_t* End() const;
 
diff --git a/runtime/oat/oat_file_assistant.cc b/runtime/oat/oat_file_assistant.cc
index 782b7b3316..149b97b598 100644
--- a/runtime/oat/oat_file_assistant.cc
+++ b/runtime/oat/oat_file_assistant.cc
@@ -79,7 +79,7 @@ std::ostream& operator<<(std::ostream& stream, const OatFileAssistant::OatStatus
       stream << "kOatUpToDate";
       break;
     case OatFileAssistant::kOatContextOutOfDate:
-      stream << "kOaContextOutOfDate";
+      stream << "kOatContextOutOfDate";
       break;
   }
 
diff --git a/runtime/quick_exception_handler.cc b/runtime/quick_exception_handler.cc
index 37734f7d74..beb42a6a05 100644
--- a/runtime/quick_exception_handler.cc
+++ b/runtime/quick_exception_handler.cc
@@ -52,7 +52,7 @@ static constexpr size_t kInvalidFrameDepth = 0xffffffff;
 
 QuickExceptionHandler::QuickExceptionHandler(Thread* self, bool is_deoptimization)
     : self_(self),
-      context_(self->GetLongJumpContext()),
+      context_(Context::Create()),
       is_deoptimization_(is_deoptimization),
       handler_quick_frame_(nullptr),
       handler_quick_frame_pc_(0),
@@ -200,7 +200,7 @@ void QuickExceptionHandler::FindCatch(ObjPtr<mirror::Throwable> exception,
 
     // Walk the stack to find catch handler.
     CatchBlockStackVisitor visitor(self_,
-                                   context_,
+                                   context_.get(),
                                    &exception_ref,
                                    this,
                                    /*skip_frames=*/already_popped,
@@ -709,7 +709,7 @@ void QuickExceptionHandler::DeoptimizeStack(bool skip_method_exit_callbacks) {
     self_->DumpStack(LOG_STREAM(INFO) << "Deoptimizing: ");
   }
 
-  DeoptimizeStackVisitor visitor(self_, context_, this, false, skip_method_exit_callbacks);
+  DeoptimizeStackVisitor visitor(self_, context_.get(), this, false, skip_method_exit_callbacks);
   visitor.WalkStack(true);
   PrepareForLongJumpToInvokeStubOrInterpreterBridge();
 }
@@ -720,7 +720,7 @@ void QuickExceptionHandler::DeoptimizeSingleFrame(DeoptimizationKind kind) {
   // This deopt is requested while still executing the method. We haven't run method exit callbacks
   // yet, so don't skip them.
   DeoptimizeStackVisitor visitor(
-      self_, context_, this, true, /* skip_method_exit_callbacks= */ false);
+      self_, context_.get(), this, true, /* skip_method_exit_callbacks= */ false);
   visitor.WalkStack(true);
 
   // Compiled code made an explicit deoptimization.
@@ -806,9 +806,8 @@ void QuickExceptionHandler::DeoptimizePartialFragmentFixup() {
   }
 }
 
-void QuickExceptionHandler::DoLongJump(bool smash_caller_saves) {
-  // Place context back on thread so it will be available when we continue.
-  self_->ReleaseLongJumpContext(context_);
+std::unique_ptr<Context> QuickExceptionHandler::PrepareLongJump(bool smash_caller_saves) {
+  // Prepare and return the context.
   context_->SetSP(reinterpret_cast<uintptr_t>(handler_quick_frame_));
   CHECK_NE(handler_quick_frame_pc_, 0u);
   context_->SetPC(handler_quick_frame_pc_);
@@ -827,8 +826,7 @@ void QuickExceptionHandler::DoLongJump(bool smash_caller_saves) {
   }
   // Clear the dex_pc list so as not to leak memory.
   handler_dex_pc_list_.reset();
-  context_->DoLongJump();
-  UNREACHABLE();
+  return std::move(context_);
 }
 
 void QuickExceptionHandler::DumpFramesWithType(Thread* self, bool details) {
diff --git a/runtime/quick_exception_handler.h b/runtime/quick_exception_handler.h
index d39c82bea3..e5cce62b44 100644
--- a/runtime/quick_exception_handler.h
+++ b/runtime/quick_exception_handler.h
@@ -19,6 +19,7 @@
 
 #include <android-base/logging.h>
 #include <cstdint>
+#include <memory>
 #include <optional>
 
 #include "base/array_ref.h"
@@ -46,11 +47,6 @@ class QuickExceptionHandler {
   QuickExceptionHandler(Thread* self, bool is_deoptimization)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  NO_RETURN ~QuickExceptionHandler() {
-    LOG(FATAL) << "UNREACHABLE";  // Expected to take long jump.
-    UNREACHABLE();
-  }
-
   // Find the catch handler for the given exception and call all required Instrumentation methods.
   // Note this might result in the exception being caught being different from 'exception'.
   void FindCatch(ObjPtr<mirror::Throwable> exception, bool is_method_exit_exception)
@@ -81,8 +77,9 @@ class QuickExceptionHandler {
   void SetCatchEnvironmentForOptimizedHandler(StackVisitor* stack_visitor)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Long jump either to a catch handler or to the upcall.
-  NO_RETURN void DoLongJump(bool smash_caller_saves = true) REQUIRES_SHARED(Locks::mutator_lock_);
+  // Prepares a long jump context for a jump to either to a catch handler or to the upcall.
+  std::unique_ptr<Context> PrepareLongJump(bool smash_caller_saves = true)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   void SetHandlerQuickFrame(ArtMethod** handler_quick_frame) {
     handler_quick_frame_ = handler_quick_frame;
@@ -148,7 +145,7 @@ class QuickExceptionHandler {
 
  private:
   Thread* const self_;
-  Context* const context_;
+  std::unique_ptr<Context> context_;
   // Should we deoptimize the stack?
   const bool is_deoptimization_;
   // Quick frame with found handler or last frame if no handler found.
diff --git a/runtime/runtime.cc b/runtime/runtime.cc
index 152180985e..53c1cb152f 100644
--- a/runtime/runtime.cc
+++ b/runtime/runtime.cc
@@ -154,7 +154,6 @@
 #include "native_stack_dump.h"
 #include "nativehelper/scoped_local_ref.h"
 #include "nterp_helpers.h"
-#include "oat/aot_class_linker.h"
 #include "oat/elf_file.h"
 #include "oat/image-inl.h"
 #include "oat/oat.h"
@@ -1257,13 +1256,11 @@ void Runtime::InitNonZygoteOrPostFork(
     }
   }
 
-  // We only used the runtime thread pool for loading app images. However the
-  // speed up that this brings in theory isn't there in practice b/328173302.
-  static constexpr bool kUseRuntimeThreadPool = false;
-  // Create the thread pools.
+  // Create the thread pool for loading app images.
   // Avoid creating the runtime thread pool for system server since it will not be used and would
   // waste memory.
-  if (!is_system_server && kUseRuntimeThreadPool) {
+  if (!is_system_server &&
+      android::base::GetBoolProperty("dalvik.vm.parallel-image-loading", false)) {
     ScopedTrace timing("CreateThreadPool");
     constexpr size_t kStackSize = 64 * KB;
     constexpr size_t kMaxRuntimeWorkers = 4u;
@@ -1281,7 +1278,7 @@ void Runtime::InitNonZygoteOrPostFork(
   heap_->ResetGcPerformanceInfo();
   GetMetrics()->Reset();
 
-  if (metrics_reporter_ != nullptr) {
+  if (AreMetricsInitialized()) {
     // Now that we know if we are an app or system server, reload the metrics reporter config
     // in case there are any difference.
     metrics::ReportingConfig metrics_config =
@@ -1956,7 +1953,7 @@ bool Runtime::Init(RuntimeArgumentMap&& runtime_options_in) {
   CHECK_GE(GetHeap()->GetContinuousSpaces().size(), 1U);
 
   if (UNLIKELY(IsAotCompiler())) {
-    class_linker_ = new AotClassLinker(intern_table_);
+    class_linker_ = compiler_callbacks_->CreateAotClassLinker(intern_table_);
   } else {
     class_linker_ = new ClassLinker(
         intern_table_,
@@ -2115,7 +2112,12 @@ bool Runtime::Init(RuntimeArgumentMap&& runtime_options_in) {
   // Class-roots are setup, we can now finish initializing the JniIdManager.
   GetJniIdManager()->Init(self);
 
-  InitMetrics();
+  // Initialize metrics only for the Zygote process or
+  // if explicitly enabled via command line argument.
+  if (IsZygote() || gFlags.MetricsForceEnable.GetValue()) {
+    LOG(INFO) << "Initializing ART runtime metrics";
+    InitMetrics();
+  }
 
   // Runtime initialization is largely done now.
   // We load plugins first since that can modify the runtime state slightly.
@@ -2216,7 +2218,7 @@ void Runtime::InitMetrics() {
 }
 
 void Runtime::RequestMetricsReport(bool synchronous) {
-  if (metrics_reporter_) {
+  if (AreMetricsInitialized()) {
     metrics_reporter_->RequestMetricsReport(synchronous);
   }
 }
@@ -2874,7 +2876,7 @@ void Runtime::RegisterAppInfo(const std::string& package_name,
       ref_profile_filename,
       AppInfo::FromVMRuntimeConstants(code_type));
 
-  if (metrics_reporter_ != nullptr) {
+  if (AreMetricsInitialized()) {
     metrics_reporter_->NotifyAppInfoUpdated(&app_info_);
   }
 
@@ -3311,14 +3313,14 @@ bool Runtime::NotifyStartupCompleted() {
 
   ProfileSaver::NotifyStartupCompleted();
 
-  if (metrics_reporter_ != nullptr) {
+  if (AreMetricsInitialized()) {
     metrics_reporter_->NotifyStartupCompleted();
   }
   return true;
 }
 
 void Runtime::NotifyDexFileLoaded() {
-  if (metrics_reporter_ != nullptr) {
+  if (AreMetricsInitialized()) {
     metrics_reporter_->NotifyAppInfoUpdated(&app_info_);
   }
 }
@@ -3492,4 +3494,13 @@ void Runtime::AddExtraBootDexFiles(const std::string& filename,
   GetClassLinker()->AddExtraBootDexFiles(Thread::Current(), std::move(dex_files));
 }
 
+void Runtime::DCheckNoTransactionCheckAllowed() {
+  if (kIsDebugBuild) {
+    Thread* self = Thread::Current();
+    if (self != nullptr) {
+      self->AssertNoTransactionCheckAllowed();
+    }
+  }
+}
+
 }  // namespace art
diff --git a/runtime/runtime.h b/runtime/runtime.h
index 89020ef5ae..e43d1d3432 100644
--- a/runtime/runtime.h
+++ b/runtime/runtime.h
@@ -631,6 +631,9 @@ class Runtime {
   }
 
   bool IsActiveTransaction() {
+    if (kIsDebugBuild) {
+      DCheckNoTransactionCheckAllowed();
+    }
     return active_transaction_;
   }
 
@@ -1129,6 +1132,8 @@ class Runtime {
     }
   }
 
+  bool AreMetricsInitialized() const { return metrics_reporter_ != nullptr; }
+
  private:
   static void InitPlatformSignalHandlers();
 
@@ -1179,15 +1184,13 @@ class Runtime {
 
   void AppendToBootClassPath(const std::string& filename, const std::string& location);
 
+  void DCheckNoTransactionCheckAllowed();
+
   // Don't use EXPORT ("default" visibility), because quick_entrypoints_x86.o
   // refers to this symbol and it can't link with R_386_PC32 relocation.
   // A pointer to the active runtime or null.
   LIBART_PROTECTED static Runtime* instance_;
 
-  // NOTE: these must match the gc::ProcessState values as they come directly from the framework.
-  static constexpr int kProfileForground = 0;
-  static constexpr int kProfileBackground = 1;
-
   static constexpr uint32_t kCalleeSaveSize = 6u;
 
   // 64 bit so that we can share the same asm offsets for both 32 and 64 bits.
diff --git a/runtime/runtime_image.cc b/runtime/runtime_image.cc
index b134c79286..fdba92e67f 100644
--- a/runtime/runtime_image.cc
+++ b/runtime/runtime_image.cc
@@ -964,9 +964,7 @@ class RuntimeImageHelper {
           entrypoint = boot_jni_stub;
         }
       }
-      copy->SetNativePointer(ArtMethod::EntryPointFromQuickCompiledCodeOffset(kRuntimePointerSize),
-                             entrypoint,
-                             kRuntimePointerSize);
+      copy->SetEntryPointFromQuickCompiledCode(entrypoint);
 
       if (method->IsNative()) {
         StubType stub_type = method->IsCriticalNative()
@@ -1612,9 +1610,15 @@ class RuntimeImageHelper {
     // Clear static field values.
     auto clear_class = [&] () REQUIRES_SHARED(Locks::mutator_lock_) {
       MemberOffset static_offset = cls->GetFirstReferenceStaticFieldOffset(kRuntimePointerSize);
-      memset(objects_.data() + offset + static_offset.Uint32Value(),
-             0,
-             cls->GetClassSize() - static_offset.Uint32Value());
+      uint32_t ref_offsets = cls->GetReferenceInstanceOffsets();
+      size_t size = cls->GetClassSize() - static_offset.Uint32Value();
+      // Adjust for overflow instance-offset bitmap, which is after the static
+      // fields.
+      if ((ref_offsets & mirror::Class::kVisitReferencesSlowpathMask) != 0) {
+        ref_offsets &= ~mirror::Class::kVisitReferencesSlowpathMask;
+        size -= ref_offsets * sizeof(uint32_t);
+      }
+      memset(objects_.data() + offset + static_offset.Uint32Value(), 0, size);
     };
     clear_class();
 
diff --git a/runtime/runtime_intrinsics.cc b/runtime/runtime_intrinsics.cc
index 40e6ace958..278854d9e7 100644
--- a/runtime/runtime_intrinsics.cc
+++ b/runtime/runtime_intrinsics.cc
@@ -63,10 +63,10 @@ bool InitializeIntrinsic(Thread* self,
 
   CHECK_EQ(method->GetInvokeType(), invoke_type);
   if (method->IsIntrinsic()) {
-    CHECK_EQ(method->GetIntrinsic(), static_cast<uint32_t>(intrinsic));
+    CHECK_EQ(method->GetIntrinsic(), intrinsic);
     return true;
   } else {
-    method->SetIntrinsic(static_cast<uint32_t>(intrinsic));
+    method->SetIntrinsic(intrinsic);
     return false;
   }
 }
@@ -83,7 +83,7 @@ bool IsIntrinsicInitialized(Thread* self,
 
   CHECK_EQ(method->GetInvokeType(), invoke_type);
   if (method->IsIntrinsic()) {
-    CHECK_EQ(method->GetIntrinsic(), static_cast<uint32_t>(intrinsic));
+    CHECK_EQ(method->GetIntrinsic(), intrinsic);
     return true;
   } else {
     return false;
diff --git a/runtime/runtime_test.cc b/runtime/runtime_test.cc
index cd0c862d82..1faecf36a8 100644
--- a/runtime/runtime_test.cc
+++ b/runtime/runtime_test.cc
@@ -109,4 +109,32 @@ TEST_F(RuntimeTest, ElfAlignmentMismatch) {
   EXPECT_EQ(kElfSegmentAlignment, elf_file->GetElfSegmentAlignmentFromFile());
 }
 
+class RuntimeInitMetricsDefaultTest : public CommonRuntimeTest {};
+
+TEST_F(RuntimeInitMetricsDefaultTest, MetricsAreNotInitialized) {
+  ASSERT_FALSE(runtime_->AreMetricsInitialized());
+}
+
+class RuntimeInitMetricsZygoteTest : public CommonRuntimeTest {
+  void SetUpRuntimeOptions(RuntimeOptions* options) override {
+    CommonRuntimeTest::SetUpRuntimeOptions(options);
+    options->emplace_back(std::make_pair("-Xzygote", nullptr));
+  }
+};
+
+TEST_F(RuntimeInitMetricsZygoteTest, MetricsAreInitialized) {
+  ASSERT_TRUE(runtime_->AreMetricsInitialized());
+}
+
+class RuntimeInitMetricsForceEnableTest : public CommonRuntimeTest {
+  void SetUpRuntimeOptions(RuntimeOptions* options) override {
+    CommonRuntimeTest::SetUpRuntimeOptions(options);
+    options->emplace_back(std::make_pair("-Xmetrics-force-enable:true", nullptr));
+  }
+};
+
+TEST_F(RuntimeInitMetricsForceEnableTest, MetricsAreInitialized) {
+  ASSERT_TRUE(runtime_->AreMetricsInitialized());
+}
+
 }  // namespace art
diff --git a/runtime/scoped_assert_no_transaction_checks.h b/runtime/scoped_assert_no_transaction_checks.h
new file mode 100644
index 0000000000..cbdff5955b
--- /dev/null
+++ b/runtime/scoped_assert_no_transaction_checks.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_SCOPED_ASSERT_NO_TRANSACTION_CHECKS_H_
+#define ART_RUNTIME_SCOPED_ASSERT_NO_TRANSACTION_CHECKS_H_
+
+#include "thread-current-inl.h"
+
+namespace art {
+
+class ScopedAssertNoTransactionChecks {
+ public:
+  explicit ScopedAssertNoTransactionChecks(const char* cause)
+      : self_(kIsDebugBuild ? Thread::Current() : nullptr),
+        old_cause_(self_ != nullptr ? self_->tlsPtr_.last_no_transaction_checks_cause : nullptr) {
+    DCHECK(cause != nullptr);
+    if (kIsDebugBuild && self_ != nullptr) {
+      self_->tlsPtr_.last_no_transaction_checks_cause = cause;
+    }
+  }
+
+  ~ScopedAssertNoTransactionChecks() {
+    if (kIsDebugBuild && self_ != nullptr) {
+      self_->tlsPtr_.last_no_transaction_checks_cause = old_cause_;
+    }
+  }
+
+ private:
+  Thread* const self_;
+  const char* const old_cause_;
+};
+
+}  // namespace art
+
+#endif  // ART_RUNTIME_SCOPED_ASSERT_NO_TRANSACTION_CHECKS_H_
diff --git a/runtime/stack.cc b/runtime/stack.cc
index bcc1da7d60..5670b12415 100644
--- a/runtime/stack.cc
+++ b/runtime/stack.cc
@@ -23,6 +23,7 @@
 #include "art_method-inl.h"
 #include "base/callee_save_type.h"
 #include "base/hex_dump.h"
+#include "base/indenter.h"
 #include "base/pointer_size.h"
 #include "base/utils.h"
 #include "dex/dex_file_types.h"
@@ -130,7 +131,19 @@ uint32_t StackVisitor::GetDexPc(bool abort_on_failure) const {
           GetCurrentQuickFrame(), cur_quick_frame_pc_, abort_on_failure);
     } else if (cur_oat_quick_method_header_->IsOptimized()) {
       StackMap* stack_map = GetCurrentStackMap();
-      CHECK(stack_map->IsValid()) << "StackMap not found for " << std::hex << cur_quick_frame_pc_;
+      if (!stack_map->IsValid()) {
+        // Debugging code for b/361916648.
+        CodeInfo code_info(cur_oat_quick_method_header_);
+        std::stringstream os;
+        VariableIndentationOutputStream vios(&os);
+        code_info.Dump(&vios, /* code_offset= */ 0u, /* verbose= */ true, kRuntimeISA);
+        LOG(FATAL) << os.str() << '\n'
+                   << "StackMap not found for "
+                   << std::hex << cur_quick_frame_pc_ << " in "
+                   << GetMethod()->PrettyMethod()
+                   << " @" << std::hex
+                   << reinterpret_cast<uintptr_t>(cur_oat_quick_method_header_->GetCode());
+      }
       return stack_map->GetDexPc();
     } else {
       DCHECK(cur_oat_quick_method_header_->IsNterpMethodHeader());
diff --git a/runtime/startup_completed_task.cc b/runtime/startup_completed_task.cc
index b84c3107f3..6f52734abf 100644
--- a/runtime/startup_completed_task.cc
+++ b/runtime/startup_completed_task.cc
@@ -121,7 +121,7 @@ void StartupCompletedTask::DeleteStartupDexCaches(Thread* self, bool called_by_g
 
   // If this isn't the GC calling `DeleteStartupDexCaches` and a GC may be
   // running, wait for it to be complete. We don't want it to see these dex
-  // caches.
+  // caches. Since we are runnable, a GC started after this cannot get far.
   if (!called_by_gc) {
     runtime->GetHeap()->WaitForGcToComplete(gc::kGcCauseDeletingDexCacheArrays, self);
   }
diff --git a/runtime/thread.cc b/runtime/thread.cc
index 8c77bd3db3..dcbe1382e0 100644
--- a/runtime/thread.cc
+++ b/runtime/thread.cc
@@ -133,8 +133,6 @@ namespace art HIDDEN {
 using android::base::StringAppendV;
 using android::base::StringPrintf;
 
-extern "C" NO_RETURN void artDeoptimize(Thread* self, bool skip_method_exit_callbacks);
-
 bool Thread::is_started_ = false;
 pthread_key_t Thread::pthread_key_self_;
 ConditionVariable* Thread::resume_cond_ = nullptr;
@@ -957,8 +955,8 @@ bool Thread::Init(ThreadList* thread_list, JavaVMExt* java_vm, JNIEnvExt* jni_en
   // thread hasn't been through here already...
   CHECK(Thread::Current() == nullptr);
 
-  // Set pthread_self_ ahead of pthread_setspecific, that makes Thread::Current function, this
-  // avoids pthread_self_ ever being invalid when discovered from Thread::Current().
+  // Set pthread_self ahead of pthread_setspecific, that makes Thread::Current function, this
+  // avoids pthread_self ever being invalid when discovered from Thread::Current().
   tlsPtr_.pthread_self = pthread_self();
   CHECK(is_started_);
 
@@ -1266,8 +1264,14 @@ void Thread::SetCachedThreadName(const char* name) {
 }
 
 void Thread::SetThreadName(const char* name) {
+  DCHECK(this == Thread::Current() || IsSuspended());  // O.w. `this` may disappear.
   SetCachedThreadName(name);
-  ::art::SetThreadName(name);
+  if (!IsStillStarting() || this == Thread::Current()) {
+    // The RI is documented to do this only in the this == self case, which would avoid the
+    // IsStillStarting() issue below. We instead use a best effort approach.
+    ::art::SetThreadName(tlsPtr_.pthread_self /* Not necessarily current thread! */, name);
+  }  // O.w. this will normally be set when we finish starting. We can rarely fail to set the
+     // pthread name. See TODO in IsStillStarting().
   Dbg::DdmSendThreadNotification(this, CHUNK_TYPE("THNM"));
 }
 
@@ -2540,6 +2544,13 @@ bool Thread::IsStillStarting() const {
   // assigned fairly early on, and needs to be.
   // It turns out that the last thing to change is the thread name; that's a good proxy for "has
   // this thread _ever_ entered kRunnable".
+  // TODO: I believe that SetThreadName(), ThreadGroup::GetThreads() and many jvmti functions can
+  // call this while the thread is in the process of starting. Thus we appear to have data races
+  // here on opeer and jpeer, and our result may be obsolete by the time we return. Aside from the
+  // data races, it is not immediately clear whether clients are robust against this behavior.  It
+  // may make sense to acquire a per-thread lock during the transition, and have this function
+  // REQUIRE that. `runtime_shutdown_lock_` might almost work, but is global and currently not
+  // held long enough.
   return (tlsPtr_.jpeer == nullptr && tlsPtr_.opeer == nullptr) ||
       (tlsPtr_.name.load() == kThreadNameDuringStartup);
 }
@@ -2684,10 +2695,6 @@ Thread::~Thread() {
   delete wait_cond_;
   delete wait_mutex_;
 
-  if (tlsPtr_.long_jump_context != nullptr) {
-    delete tlsPtr_.long_jump_context;
-  }
-
   if (initialized) {
     CleanupCpu();
   }
@@ -3070,7 +3077,8 @@ class BuildInternalStackTraceVisitor : public StackVisitor {
   DISALLOW_COPY_AND_ASSIGN(BuildInternalStackTraceVisitor);
 };
 
-jobject Thread::CreateInternalStackTrace(const ScopedObjectAccessAlreadyRunnable& soa) const {
+ObjPtr<mirror::ObjectArray<mirror::Object>> Thread::CreateInternalStackTrace(
+    const ScopedObjectAccessAlreadyRunnable& soa) const {
   // Compute depth of stack, save frames if possible to avoid needing to recompute many.
   constexpr size_t kMaxSavedFrames = 256;
   std::unique_ptr<ArtMethodDexPcPair[]> saved_frames(new ArtMethodDexPcPair[kMaxSavedFrames]);
@@ -3107,7 +3115,7 @@ jobject Thread::CreateInternalStackTrace(const ScopedObjectAccessAlreadyRunnable
       CHECK(method != nullptr);
     }
   }
-  return soa.AddLocalReference<jobject>(trace);
+  return trace;
 }
 
 bool Thread::IsExceptionThrownByCurrentMethod(ObjPtr<mirror::Throwable> exception) const {
@@ -3660,9 +3668,9 @@ void Thread::ThrowNewWrappedException(const char* exception_class_descriptor,
     if (cause.get() != nullptr) {
       exception->SetCause(DecodeJObject(cause.get())->AsThrowable());
     }
-    ScopedLocalRef<jobject> trace(GetJniEnv(), CreateInternalStackTrace(soa));
-    if (trace.get() != nullptr) {
-      exception->SetStackState(DecodeJObject(trace.get()).Ptr());
+    ObjPtr<mirror::ObjectArray<mirror::Object>> trace = CreateInternalStackTrace(soa);
+    if (trace != nullptr) {
+      exception->SetStackState(trace.Ptr());
     }
     SetException(exception.Get());
   } else {
@@ -3859,6 +3867,7 @@ void Thread::DumpThreadOffset(std::ostream& os, uint32_t offset) {
   QUICK_ENTRY_POINT_INFO(pInvokeSuperTrampolineWithAccessCheck)
   QUICK_ENTRY_POINT_INFO(pInvokeVirtualTrampolineWithAccessCheck)
   QUICK_ENTRY_POINT_INFO(pInvokePolymorphic)
+  QUICK_ENTRY_POINT_INFO(pInvokePolymorphicWithHiddenReceiver)
   QUICK_ENTRY_POINT_INFO(pTestSuspend)
   QUICK_ENTRY_POINT_INFO(pDeliverException)
   QUICK_ENTRY_POINT_INFO(pThrowArrayBounds)
@@ -3924,7 +3933,7 @@ void Thread::DumpThreadOffset(std::ostream& os, uint32_t offset) {
   os << offset;
 }
 
-void Thread::QuickDeliverException(bool skip_method_exit_callbacks) {
+std::unique_ptr<Context> Thread::QuickDeliverException(bool skip_method_exit_callbacks) {
   // Get exception from thread.
   ObjPtr<mirror::Throwable> exception = GetException();
   CHECK(exception != nullptr);
@@ -3932,8 +3941,9 @@ void Thread::QuickDeliverException(bool skip_method_exit_callbacks) {
     // This wasn't a real exception, so just clear it here. If there was an actual exception it
     // will be recorded in the DeoptimizationContext and it will be restored later.
     ClearException();
-    artDeoptimize(this, skip_method_exit_callbacks);
-    UNREACHABLE();
+    return Deoptimize(DeoptimizationKind::kFullFrame,
+                      /*single_frame=*/ false,
+                      skip_method_exit_callbacks);
   }
 
   ReadBarrier::MaybeAssertToSpaceInvariant(exception.Ptr());
@@ -3975,8 +3985,9 @@ void Thread::QuickDeliverException(bool skip_method_exit_callbacks) {
             exception,
             /* from_code= */ false,
             method_type);
-        artDeoptimize(this, skip_method_exit_callbacks);
-        UNREACHABLE();
+        return Deoptimize(DeoptimizationKind::kFullFrame,
+                          /*single_frame=*/ false,
+                          skip_method_exit_callbacks);
       } else {
         LOG(WARNING) << "Got a deoptimization request on un-deoptimizable method "
                      << visitor.caller->PrettyMethod();
@@ -4001,18 +4012,39 @@ void Thread::QuickDeliverException(bool skip_method_exit_callbacks) {
     // Check the to-space invariant on the re-installed exception (if applicable).
     ReadBarrier::MaybeAssertToSpaceInvariant(GetException());
   }
-  exception_handler.DoLongJump();
+  return exception_handler.PrepareLongJump();
 }
 
-Context* Thread::GetLongJumpContext() {
-  Context* result = tlsPtr_.long_jump_context;
-  if (result == nullptr) {
-    result = Context::Create();
+std::unique_ptr<Context> Thread::Deoptimize(DeoptimizationKind kind,
+                                            bool single_frame,
+                                            bool skip_method_exit_callbacks) {
+  Runtime::Current()->IncrementDeoptimizationCount(kind);
+  if (VLOG_IS_ON(deopt)) {
+    if (single_frame) {
+      // Deopt logging will be in DeoptimizeSingleFrame. It is there to take advantage of the
+      // specialized visitor that will show whether a method is Quick or Shadow.
+    } else {
+      LOG(INFO) << "Deopting:";
+      Dump(LOG_STREAM(INFO));
+    }
+  }
+
+  AssertHasDeoptimizationContext();
+  QuickExceptionHandler exception_handler(this, true);
+  if (single_frame) {
+    exception_handler.DeoptimizeSingleFrame(kind);
   } else {
-    tlsPtr_.long_jump_context = nullptr;  // Avoid context being shared.
-    result->Reset();
+    exception_handler.DeoptimizeStack(skip_method_exit_callbacks);
+  }
+  if (exception_handler.IsFullFragmentDone()) {
+    return exception_handler.PrepareLongJump(/*smash_caller_saves=*/ true);
+  } else {
+    exception_handler.DeoptimizePartialFragmentFixup();
+    // We cannot smash the caller-saves, as we need the ArtMethod in a parameter register that would
+    // be caller-saved. This has the downside that we cannot track incorrect register usage down the
+    // line.
+    return exception_handler.PrepareLongJump(/*smash_caller_saves=*/ false);
   }
-  return result;
 }
 
 ArtMethod* Thread::GetCurrentMethod(uint32_t* dex_pc_out,
@@ -4182,8 +4214,7 @@ class ReferenceMapVisitor : public StackVisitor {
     if (m->IsNative()) {
       // TODO: Spill the `this` reference in the AOT-compiled String.charAt()
       // slow-path for throwing SIOOBE, so that we can remove this carve-out.
-      if (UNLIKELY(m->IsIntrinsic()) &&
-          m->GetIntrinsic() == enum_cast<uint32_t>(Intrinsics::kStringCharAt)) {
+      if (UNLIKELY(m->IsIntrinsic()) && m->GetIntrinsic() == Intrinsics::kStringCharAt) {
         // The String.charAt() method is AOT-compiled with an intrinsic implementation
         // instead of a JNI stub. It has a slow path that constructs a runtime frame
         // for throwing SIOOBE and in that path we do not get the `this` pointer
@@ -4817,20 +4848,6 @@ void Thread::ClearAllInterpreterCaches() {
   Runtime::Current()->GetThreadList()->RunCheckpoint(&closure);
 }
 
-
-void Thread::ReleaseLongJumpContextInternal() {
-  // Each QuickExceptionHandler gets a long jump context and uses
-  // it for doing the long jump, after finding catch blocks/doing deoptimization.
-  // Both finding catch blocks and deoptimization can trigger another
-  // exception such as a result of class loading. So there can be nested
-  // cases of exception handling and multiple contexts being used.
-  // ReleaseLongJumpContext tries to save the context in tlsPtr_.long_jump_context
-  // for reuse so there is no need to always allocate a new one each time when
-  // getting a context. Since we only keep one context for reuse, delete the
-  // existing one since the passed in context is yet to be used for longjump.
-  delete tlsPtr_.long_jump_context;
-}
-
 void Thread::SetNativePriority(int new_priority) {
   palette_status_t status = PaletteSchedSetPriority(GetTid(), new_priority);
   CHECK(status == PALETTE_STATUS_OK || status == PALETTE_STATUS_CHECK_ERRNO);
diff --git a/runtime/thread.h b/runtime/thread.h
index 35e8fe8716..da9a70d8b1 100644
--- a/runtime/thread.h
+++ b/runtime/thread.h
@@ -548,6 +548,11 @@ class EXPORT Thread {
 
   void AssertThreadSuspensionIsAllowable(bool check_locks = true) const;
 
+  void AssertNoTransactionCheckAllowed() const {
+    CHECK(tlsPtr_.last_no_transaction_checks_cause == nullptr)
+        << tlsPtr_.last_no_transaction_checks_cause;
+  }
+
   // Return true if thread suspension is allowable.
   bool IsThreadSuspensionAllowable() const;
 
@@ -679,20 +684,18 @@ class EXPORT Thread {
   // that needs to be dealt with, false otherwise.
   bool ObserveAsyncException() REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Find catch block and perform long jump to appropriate exception handle. When
-  // is_method_exit_exception is true, the exception was thrown by the method exit callback and we
-  // should not send method unwind for the method on top of the stack since method exit callback was
-  // already called.
-  NO_RETURN void QuickDeliverException(bool is_method_exit_exception = false)
+  // Find catch block then prepare and return the long jump context to the appropriate exception
+  // handler. When is_method_exit_exception is true, the exception was thrown by the method exit
+  // callback and we should not send method unwind for the method on top of the stack since method
+  // exit callback was already called.
+  std::unique_ptr<Context> QuickDeliverException(bool is_method_exit_exception = false)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  Context* GetLongJumpContext();
-  void ReleaseLongJumpContext(Context* context) {
-    if (tlsPtr_.long_jump_context != nullptr) {
-      ReleaseLongJumpContextInternal();
-    }
-    tlsPtr_.long_jump_context = context;
-  }
+  // Perform deoptimization. Return a `Context` prepared for a long jump.
+  std::unique_ptr<Context> Deoptimize(DeoptimizationKind kind,
+                                      bool single_frame,
+                                      bool skip_method_exit_callbacks)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Get the current method and dex pc. If there are errors in retrieving the dex pc, this will
   // abort the runtime iff abort_on_error is true.
@@ -860,7 +863,8 @@ class EXPORT Thread {
 
   // Create the internal representation of a stack trace, that is more time
   // and space efficient to compute than the StackTraceElement[].
-  jobject CreateInternalStackTrace(const ScopedObjectAccessAlreadyRunnable& soa) const
+  ObjPtr<mirror::ObjectArray<mirror::Object>> CreateInternalStackTrace(
+      const ScopedObjectAccessAlreadyRunnable& soa) const
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Convert an internal stack trace representation (returned by CreateInternalStackTrace) to a
@@ -1093,9 +1097,9 @@ class EXPORT Thread {
   }
 
   template <PointerSize pointer_size>
-  static constexpr ThreadOffset<pointer_size> TraceBufferIndexOffset() {
+  static constexpr ThreadOffset<pointer_size> TraceBufferCurrPtrOffset() {
     return ThreadOffsetFromTlsPtr<pointer_size>(
-        OFFSETOF_MEMBER(tls_ptr_sized_values, method_trace_buffer_index));
+        OFFSETOF_MEMBER(tls_ptr_sized_values, method_trace_buffer_curr_entry));
   }
 
   template <PointerSize pointer_size>
@@ -1358,10 +1362,21 @@ class EXPORT Thread {
 
   uintptr_t* GetMethodTraceBuffer() { return tlsPtr_.method_trace_buffer; }
 
-  size_t* GetMethodTraceIndexPtr() { return &tlsPtr_.method_trace_buffer_index; }
+  uintptr_t** GetTraceBufferCurrEntryPtr() { return &tlsPtr_.method_trace_buffer_curr_entry; }
 
-  uintptr_t* SetMethodTraceBuffer(uintptr_t* buffer) {
-    return tlsPtr_.method_trace_buffer = buffer;
+  void SetMethodTraceBuffer(uintptr_t* buffer, int init_index) {
+    tlsPtr_.method_trace_buffer = buffer;
+    SetMethodTraceBufferCurrentEntry(init_index);
+  }
+
+  void SetMethodTraceBufferCurrentEntry(int index) {
+    uintptr_t* buffer = tlsPtr_.method_trace_buffer;
+    if (buffer == nullptr) {
+      tlsPtr_.method_trace_buffer_curr_entry = nullptr;
+    } else {
+      DCHECK(buffer != nullptr);
+      tlsPtr_.method_trace_buffer_curr_entry = buffer + index;
+    }
   }
 
   uint64_t GetTraceClockBase() const {
@@ -1818,8 +1833,6 @@ class EXPORT Thread {
 
   static bool IsAotCompiler();
 
-  void ReleaseLongJumpContextInternal();
-
   void SetCachedThreadName(const char* name);
 
   // Helper class for manipulating the 32 bits of atomically changed state and flags.
@@ -1937,7 +1950,7 @@ class EXPORT Thread {
                                         StateAndFlags old_state_and_flags = StateAndFlags(0),
                                         ThreadExitFlag* tef = nullptr,
                                         /*out*/ bool* finished = nullptr)
-      TRY_ACQUIRE_SHARED(true, Locks::mutator_lock_);
+      REQUIRES(!Locks::thread_list_lock_) TRY_ACQUIRE_SHARED(true, Locks::mutator_lock_);
 
   static void ThreadExitCallback(void* arg);
 
@@ -2124,13 +2137,11 @@ class EXPORT Thread {
                                monitor_enter_object(nullptr),
                                top_handle_scope(nullptr),
                                class_loader_override(nullptr),
-                               long_jump_context(nullptr),
                                stacked_shadow_frame_record(nullptr),
                                deoptimization_context_stack(nullptr),
                                frame_id_to_shadow_frame(nullptr),
                                name(nullptr),
                                pthread_self(0),
-                               last_no_thread_suspension_cause(nullptr),
                                active_suspendall_barrier(nullptr),
                                active_suspend1_barriers(nullptr),
                                thread_local_pos(nullptr),
@@ -2147,8 +2158,10 @@ class EXPORT Thread {
                                async_exception(nullptr),
                                top_reflective_handle_scope(nullptr),
                                method_trace_buffer(nullptr),
-                               method_trace_buffer_index(0),
-                               thread_exit_flags(nullptr) {
+                               method_trace_buffer_curr_entry(nullptr),
+                               thread_exit_flags(nullptr),
+                               last_no_thread_suspension_cause(nullptr),
+                               last_no_transaction_checks_cause(nullptr) {
       std::fill(held_mutexes, held_mutexes + kLockLevelCount, nullptr);
     }
 
@@ -2222,9 +2235,6 @@ class EXPORT Thread {
     // useful for testing.
     jobject class_loader_override;
 
-    // Thread local, lazily allocated, long jump context. Used to deliver exceptions.
-    Context* long_jump_context;
-
     // For gc purpose, a shadow frame record stack that keeps track of:
     // 1) shadow frames under construction.
     // 2) deoptimization shadow frames.
@@ -2247,9 +2257,6 @@ class EXPORT Thread {
     // A cached pthread_t for the pthread underlying this Thread*.
     pthread_t pthread_self;
 
-    // If no_thread_suspension_ is > 0, what is causing that assertion.
-    const char* last_no_thread_suspension_cause;
-
     // After a thread observes a suspend request and enters a suspended state,
     // it notifies the requestor by arriving at a "suspend barrier". This consists of decrementing
     // the atomic integer representing the barrier. (This implementation was introduced in 2015 to
@@ -2323,11 +2330,18 @@ class EXPORT Thread {
     // Pointer to a thread-local buffer for method tracing.
     uintptr_t* method_trace_buffer;
 
-    // The index of the next free entry in method_trace_buffer.
-    size_t method_trace_buffer_index;
+    // Pointer to the current entry in the buffer.
+    uintptr_t* method_trace_buffer_curr_entry;
 
     // Pointer to the first node of an intrusively doubly-linked list of ThreadExitFlags.
     ThreadExitFlag* thread_exit_flags GUARDED_BY(Locks::thread_list_lock_);
+
+    // If no_thread_suspension_ is > 0, what is causing that assertion.
+    const char* last_no_thread_suspension_cause;
+
+    // If the thread is asserting that there should be no transaction checks,
+    // what is causing that assertion (debug builds only).
+    const char* last_no_transaction_checks_cause;
   } tlsPtr_;
 
   // Small thread-local cache to be used from the interpreter.
@@ -2386,6 +2400,7 @@ class EXPORT Thread {
   friend class gc::collector::SemiSpace;  // For getting stack traces.
   friend class Runtime;  // For CreatePeer.
   friend class QuickExceptionHandler;  // For dumping the stack.
+  friend class ScopedAssertNoTransactionChecks;
   friend class ScopedThreadStateChange;
   friend class StubTest;  // For accessing entrypoints.
   friend class ThreadList;  // For ~Thread, Destroy and EnsureFlipFunctionStarted.
diff --git a/runtime/thread_list.cc b/runtime/thread_list.cc
index d5e201352e..3665b34cd5 100644
--- a/runtime/thread_list.cc
+++ b/runtime/thread_list.cc
@@ -203,11 +203,8 @@ class DumpCheckpoint final : public Closure {
     Thread* self = Thread::Current();
     CHECK(self != nullptr);
     std::ostringstream local_os;
-    Thread::DumpOrder dump_order;
-    {
-      ScopedObjectAccess soa(self);
-      dump_order = thread->Dump(local_os, unwinder_, dump_native_stack_);
-    }
+    Locks::mutator_lock_->AssertSharedHeld(self);
+    Thread::DumpOrder dump_order = thread->Dump(local_os, unwinder_, dump_native_stack_);
     {
       MutexLock mu(self, lock_);
       // Sort, so that the most interesting threads for ANR are printed first (ANRs can be trimmed).
@@ -257,12 +254,12 @@ void ThreadList::Dump(std::ostream& os, bool dump_native_stack) {
   }
   if (self != nullptr) {
     DumpCheckpoint checkpoint(dump_native_stack);
-    size_t threads_running_checkpoint;
-    {
-      // Use SOA to prevent deadlocks if multiple threads are calling Dump() at the same time.
-      ScopedObjectAccess soa(self);
-      threads_running_checkpoint = RunCheckpoint(&checkpoint);
-    }
+    // Acquire mutator lock separately for each thread, to avoid long runnable code sequence
+    // without suspend checks.
+    size_t threads_running_checkpoint = RunCheckpoint(&checkpoint,
+                                                      nullptr,
+                                                      true,
+                                                      /* acquire_mutator_lock= */ true);
     if (threads_running_checkpoint != 0) {
       checkpoint.WaitForThreadsToRunThroughCheckpoint(threads_running_checkpoint);
     }
@@ -305,81 +302,99 @@ NO_RETURN static void UnsafeLogFatalForThreadSuspendAllTimeout() {
 
 size_t ThreadList::RunCheckpoint(Closure* checkpoint_function,
                                  Closure* callback,
-                                 bool allow_lock_checking) {
+                                 bool allow_lock_checking,
+                                 bool acquire_mutator_lock) {
   Thread* self = Thread::Current();
   Locks::mutator_lock_->AssertNotExclusiveHeld(self);
   Locks::thread_list_lock_->AssertNotHeld(self);
   Locks::thread_suspend_count_lock_->AssertNotHeld(self);
+  if (kIsDebugBuild && allow_lock_checking && !acquire_mutator_lock) {
+    // TODO: Consider better checking with acquire_mutator_lock.
+    self->DisallowPreMonitorMutexes();
+  }
 
-  std::vector<Thread*> suspended_count_modified_threads;
+  std::vector<Thread*> remaining_threads;
   size_t count = 0;
-  {
-    // Call a checkpoint function for each thread. We directly invoke the function on behalf of
-    // suspended threads.
-    MutexLock mu(self, *Locks::thread_list_lock_);
-    if (kIsDebugBuild && allow_lock_checking) {
-      self->DisallowPreMonitorMutexes();
-    }
-    MutexLock mu2(self, *Locks::thread_suspend_count_lock_);
-    count = list_.size();
-    for (const auto& thread : list_) {
-      if (thread != self) {
-        bool requested_suspend = false;
-        while (true) {
-          if (thread->RequestCheckpoint(checkpoint_function)) {
-            // This thread will run its checkpoint some time in the near future.
-            if (requested_suspend) {
-              // The suspend request is now unnecessary.
-              thread->DecrementSuspendCount(self);
-              Thread::resume_cond_->Broadcast(self);
-              requested_suspend = false;
-            }
-            break;
-          } else {
-            // The thread was, and probably still is, suspended.
-            if (!requested_suspend) {
-              // This does not risk suspension cycles: We may have a pending suspension request,
-              // but it cannot block us: Checkpoint Run() functions may not suspend, thus we cannot
-              // be blocked from decrementing the count again.
-              thread->IncrementSuspendCount(self);
-              requested_suspend = true;
-            }
-            if (thread->IsSuspended()) {
-              // We saw it suspended after incrementing suspend count, so it will stay that way.
-              break;
-            }
-          }
-          // We only get here if the thread entered kRunnable again. Retry immediately.
-        }
-        // At this point, either the thread was runnable, and will run the checkpoint itself,
-        // or requested_suspend is true, and the thread is safely suspended.
-        if (requested_suspend) {
-          DCHECK(thread->IsSuspended());
-          suspended_count_modified_threads.push_back(thread);
-        }
+  bool mutator_lock_held = Locks::mutator_lock_->IsSharedHeld(self);
+  ThreadState old_thread_state = self->GetState();
+  DCHECK(!(mutator_lock_held && acquire_mutator_lock));
+
+  // Thread-safety analysis wants the lock state to always be the same at every program point.
+  // Allow us to pretend it is.
+  auto fake_mutator_lock = []() SHARED_LOCK_FUNCTION(Locks::mutator_lock_)
+                               NO_THREAD_SAFETY_ANALYSIS {};
+  auto fake_mutator_unlock = []() UNLOCK_FUNCTION(Locks::mutator_lock_)
+                                 NO_THREAD_SAFETY_ANALYSIS {};
+
+  if (acquire_mutator_lock) {
+    self->TransitionFromSuspendedToRunnable();
+  } else {
+    fake_mutator_lock();
+  }
+  Locks::thread_list_lock_->Lock(self);
+  Locks::thread_suspend_count_lock_->Lock(self);
+
+  // First try to install checkpoint function in each thread. This will succeed only for
+  // runnable threads. Track others in remaining_threads.
+  count = list_.size();
+  for (const auto& thread : list_) {
+    if (thread != self) {
+      if (thread->RequestCheckpoint(checkpoint_function)) {
+        // This thread will run its checkpoint some time in the near future.
+      } else {
+        remaining_threads.push_back(thread);
       }
-      // Thread either has honored or will honor the checkpoint, or it has been added to
-      // suspended_count_modified_threads.
-    }
-    // Run the callback to be called inside this critical section.
-    if (callback != nullptr) {
-      callback->Run(self);
     }
+    // Thread either has honored or will honor the checkpoint, or it has been added to
+    // remaining_threads.
   }
 
-  // Run the checkpoint on ourself while we wait for threads to suspend.
-  checkpoint_function->Run(self);
+  // ith entry corresponds to remaining_threads[i]:
+  std::unique_ptr<ThreadExitFlag[]> tefs(new ThreadExitFlag[remaining_threads.size()]);
 
-  bool mutator_lock_held = Locks::mutator_lock_->IsSharedHeld(self);
-  bool repeat = true;
-  // Run the checkpoint on the suspended threads.
-  while (repeat) {
-    repeat = false;
-    for (auto& thread : suspended_count_modified_threads) {
-      if (thread != nullptr) {
-        // We know for sure that the thread is suspended at this point.
-        DCHECK(thread->IsSuspended());
-        if (mutator_lock_held) {
+  // Register a ThreadExitFlag for each remaining thread.
+  for (size_t i = 0; i < remaining_threads.size(); ++i) {
+    remaining_threads[i]->NotifyOnThreadExit(&tefs[i]);
+  }
+
+  // Run the callback to be called inside this critical section.
+  if (callback != nullptr) {
+    callback->Run(self);
+  }
+
+  size_t nthreads = remaining_threads.size();
+  size_t starting_thread = 0;
+  size_t next_starting_thread;  // First possible remaining non-null entry in remaining_threads.
+  // Run the checkpoint for the suspended threads.
+  do {
+    // We hold mutator_lock_ (if desired), thread_list_lock_, and suspend_count_lock_
+    next_starting_thread = nthreads;
+    for (size_t i = 0; i < nthreads; ++i) {
+      Thread* thread = remaining_threads[i];
+      if (thread == nullptr) {
+        continue;
+      }
+      if (tefs[i].HasExited()) {
+        remaining_threads[i] = nullptr;
+        --count;
+        continue;
+      }
+      bool was_runnable = thread->RequestCheckpoint(checkpoint_function);
+      if (was_runnable) {
+        // Thread became runnable, and will run the checkpoint; we're done.
+        thread->UnregisterThreadExitFlag(&tefs[i]);
+        remaining_threads[i] = nullptr;
+        continue;
+      }
+      // Thread was still suspended, as expected.
+      // We need to run the checkpoint ourselves. Suspend thread so it stays suspended.
+      thread->IncrementSuspendCount(self);
+      if (LIKELY(thread->IsSuspended())) {
+        // Run the checkpoint function ourselves.
+        // We need to run the checkpoint function without the thread_list and suspend_count locks.
+        Locks::thread_suspend_count_lock_->Unlock(self);
+        Locks::thread_list_lock_->Unlock(self);
+        if (mutator_lock_held || acquire_mutator_lock) {
           // Make sure there is no pending flip function before running Java-heap-accessing
           // checkpoint on behalf of thread.
           Thread::EnsureFlipFunctionStarted(self, thread);
@@ -387,34 +402,70 @@ size_t ThreadList::RunCheckpoint(Closure* checkpoint_function,
                   .IsAnyOfFlagsSet(Thread::FlipFunctionFlags())) {
             // There is another thread running the flip function for 'thread'.
             // Instead of waiting for it to complete, move to the next thread.
-            repeat = true;
+            // Retry this one later from scratch.
+            next_starting_thread = std::min(next_starting_thread, i);
+            Locks::thread_list_lock_->Lock(self);
+            Locks::thread_suspend_count_lock_->Lock(self);
+            thread->DecrementSuspendCount(self);
+            Thread::resume_cond_->Broadcast(self);
             continue;
           }
         }  // O.w. the checkpoint will not access Java data structures, and doesn't care whether
            // the flip function has been called.
         checkpoint_function->Run(thread);
-        {
-          MutexLock mu2(self, *Locks::thread_suspend_count_lock_);
+        if (acquire_mutator_lock) {
+          {
+            MutexLock mu3(self, *Locks::thread_suspend_count_lock_);
+            thread->DecrementSuspendCount(self);
+            // In the case of a thread waiting for IO or the like, there will be no waiters
+            // on resume_cond_, so Broadcast() will not enter the kernel, and thus be cheap.
+            Thread::resume_cond_->Broadcast(self);
+          }
+          {
+            // Allow us to run checkpoints, or be suspended between checkpoint invocations.
+            ScopedThreadSuspension sts(self, old_thread_state);
+          }
+          Locks::thread_list_lock_->Lock(self);
+          Locks::thread_suspend_count_lock_->Lock(self);
+        } else {
+          Locks::thread_list_lock_->Lock(self);
+          Locks::thread_suspend_count_lock_->Lock(self);
           thread->DecrementSuspendCount(self);
+          Thread::resume_cond_->Broadcast(self);
         }
-        // We are done with 'thread' so set it to nullptr so that next outer
-        // loop iteration, if any, skips 'thread'.
-        thread = nullptr;
+        thread->UnregisterThreadExitFlag(&tefs[i]);
+        remaining_threads[i] = nullptr;
+      } else {
+        // Thread may have become runnable between the time we last checked and
+        // the time we incremented the suspend count. We defer to the next attempt, rather than
+        // waiting for it to suspend. Note that this may still unnecessarily trigger a signal
+        // handler, but it should be exceedingly rare.
+        thread->DecrementSuspendCount(self);
+        Thread::resume_cond_->Broadcast(self);
+        next_starting_thread = std::min(next_starting_thread, i);
       }
     }
-  }
-  DCHECK(std::all_of(suspended_count_modified_threads.cbegin(),
-                     suspended_count_modified_threads.cend(),
-                     [](Thread* thread) { return thread == nullptr; }));
+    starting_thread = next_starting_thread;
+  } while (starting_thread != nthreads);
 
-  {
-    // Imitate ResumeAll, threads may be waiting on Thread::resume_cond_ since we raised their
-    // suspend count. Now the suspend_count_ is lowered so we must do the broadcast.
-    MutexLock mu2(self, *Locks::thread_suspend_count_lock_);
-    Thread::resume_cond_->Broadcast(self);
+  // Finally run the checkpoint on ourself. We will already have run the flip function, if we're
+  // runnable.
+  Locks::thread_list_lock_->Unlock(self);
+  Locks::thread_suspend_count_lock_->Unlock(self);
+  checkpoint_function->Run(self);
+
+  if (acquire_mutator_lock) {
+    self->TransitionFromRunnableToSuspended(old_thread_state);
+  } else {
+    fake_mutator_unlock();
   }
 
-  if (kIsDebugBuild && allow_lock_checking) {
+  DCHECK(std::all_of(remaining_threads.cbegin(), remaining_threads.cend(), [](Thread* thread) {
+    return thread == nullptr;
+  }));
+  Thread::DCheckUnregisteredEverywhere(&tefs[0], &tefs[nthreads - 1]);
+
+  if (kIsDebugBuild && allow_lock_checking & !acquire_mutator_lock) {
     self->AllowPreMonitorMutexes();
   }
   return count;
@@ -717,15 +768,22 @@ std::optional<std::string> ThreadList::WaitForSuspendBarrier(AtomicInteger* barr
 #endif
   uint64_t timeout_ns =
       attempt_of_4 == 0 ? thread_suspend_timeout_ns_ : thread_suspend_timeout_ns_ / 4;
-  if (attempt_of_4 != 1 && getpriority(PRIO_PROCESS, 0 /* this thread */) > 0) {
-    // We're a low priority thread, and thus have a longer ANR timeout. Double the suspend
-    // timeout. To avoid the getpriority system call in the common case, we fail to double the
-    // first of 4 waits, but then triple the third one to compensate.
-    if (attempt_of_4 == 3) {
-      timeout_ns *= 3;
-    } else {
-      timeout_ns *= 2;
+
+  uint64_t avg_wait_multiplier = 1;
+  uint64_t wait_multiplier = 1;
+  if (attempt_of_4 != 1) {
+    // TODO: RequestSynchronousCheckpoint routinely passes attempt_of_4 = 0. Can
+    // we avoid the getpriority() call?
+    if (getpriority(PRIO_PROCESS, 0 /* this thread */) > 0) {
+      // We're a low priority thread, and thus have a longer ANR timeout. Increase the suspend
+      // timeout.
+      avg_wait_multiplier = 3;
     }
+    // To avoid the system calls in the common case, we fail to increase the first of 4 waits, but
+    // then compensate during the last one. This also allows somewhat longer thread monitoring
+    // before we time out.
+    wait_multiplier = attempt_of_4 == 4 ? 2 * avg_wait_multiplier - 1 : avg_wait_multiplier;
+    timeout_ns *= wait_multiplier;
   }
   bool collect_state = (t != 0 && (attempt_of_4 == 0 || attempt_of_4 == 4));
   int32_t cur_val = barrier->load(std::memory_order_acquire);
@@ -760,9 +818,14 @@ std::optional<std::string> ThreadList::WaitForSuspendBarrier(AtomicInteger* barr
       return std::nullopt;
     }
   }
+  uint64_t final_wait_time = NanoTime() - start_time;
+  uint64_t total_wait_time = attempt_of_4 == 0 ?
+                                 final_wait_time :
+                                 4 * final_wait_time * avg_wait_multiplier / wait_multiplier;
   return collect_state ? "Target states: [" + sampled_state + ", " + GetOsThreadStatQuick(t) + "]" +
-                             std::to_string(cur_val) + "@" + std::to_string((uintptr_t)barrier) +
-                             " Final wait time: " + PrettyDuration(NanoTime() - start_time) :
+                             (cur_val == 0 ? "(barrier now passed)" : "") +
+                             " Final wait time: " + PrettyDuration(final_wait_time) +
+                             "; appr. total wait time: " + PrettyDuration(total_wait_time) :
                          "";
 }
 
@@ -921,7 +984,7 @@ void ThreadList::SuspendAllInternal(Thread* self, SuspendReason reason) {
       // Second to the last attempt; Try to gather more information in case we time out.
       MutexLock mu(self, *Locks::thread_list_lock_);
       MutexLock mu2(self, *Locks::thread_suspend_count_lock_);
-      oss << "Unsuspended threads: ";
+      oss << "remaining threads: ";
       for (const auto& thread : list_) {
         if (thread != self && !thread->IsSuspended()) {
           culprit = thread;
@@ -938,16 +1001,15 @@ void ThreadList::SuspendAllInternal(Thread* self, SuspendReason reason) {
       } else {
         std::string name;
         culprit->GetThreadName(name);
-        oss << "Info for " << *culprit << ":";
+        oss << "Info for " << name << ": ";
         std::string thr_descr =
-            StringPrintf("%s tid: %d, state&flags: 0x%x, priority: %d,  barrier value: %d, ",
-                         name.c_str(),
-                         tid,
+            StringPrintf("state&flags: 0x%x, Java/native priority: %d/%d, barrier value: %d, ",
                          culprit->GetStateAndFlags(std::memory_order_relaxed).GetValue(),
                          culprit->GetNativePriority(),
+                         getpriority(PRIO_PROCESS /* really thread */, culprit->GetTid()),
                          pending_threads.load());
         oss << thr_descr << result.value();
-        culprit->AbortInThis("SuspendAll timeout: " + oss.str());
+        culprit->AbortInThis("SuspendAll timeout; " + oss.str());
       }
     }
   }
@@ -1153,13 +1215,13 @@ bool ThreadList::SuspendThread(Thread* self,
     // 'thread' should still have a suspend request pending, and hence stick around. Try to abort
     // there, since its stack trace is much more interesting than ours.
     std::string message = StringPrintf(
-        "%s timed out: %d (%s), state&flags: 0x%x, priority: %d,"
+        "%s timed out: %s: state&flags: 0x%x, Java/native priority: %d/%d,"
         " barriers: %p, ours: %p, barrier value: %d, nsusps: %d, ncheckpts: %d, thread_info: %s",
         func_name,
-        thread->GetTid(),
         name.c_str(),
         thread->GetStateAndFlags(std::memory_order_relaxed).GetValue(),
         thread->GetNativePriority(),
+        getpriority(PRIO_PROCESS /* really thread */, thread->GetTid()),
         first_barrier,
         &wrapped_barrier,
         wrapped_barrier.barrier_.load(),
@@ -1503,6 +1565,7 @@ void ThreadList::Unregister(Thread* self, bool should_run_callbacks) {
   if (UNLIKELY(self->GetMethodTraceBuffer() != nullptr)) {
     Trace::ReleaseThreadBuffer(self);
   }
+  CHECK_EQ(self->GetMethodTraceBuffer(), nullptr) << Trace::GetDebugInformation();
   delete self;
 
   // Release the thread ID after the thread is finished and deleted to avoid cases where we can
diff --git a/runtime/thread_list.h b/runtime/thread_list.h
index a48209e5cf..1cf28989fb 100644
--- a/runtime/thread_list.h
+++ b/runtime/thread_list.h
@@ -115,18 +115,34 @@ class ThreadList {
 
   // Run a checkpoint on all threads. Return the total number of threads for which the checkpoint
   // function has been or will be called.
+  //
   // Running threads are not suspended but run the checkpoint inside of the suspend check. The
   // return value includes already suspended threads for b/24191051. Runs or requests the
-  // callback, if non-null, inside the thread_list_lock critical section after determining the
-  // runnable/suspended states of the threads. Does not wait for completion of the checkpoint
-  // function in running threads. If the caller holds the mutator lock, then all instances of the
-  // checkpoint function are run with the mutator lock. If the caller does not hold the mutator
-  // lock (see mutator_gc_coord.md) then, since the checkpoint code may not acquire or release the
-  // mutator lock, the checkpoint will have no way to access Java data.
-  // TODO: Is it possible to just require the mutator lock here?
+  // callback, if non-null, inside the thread_list_lock critical section after capturing the list
+  // of threads needing to run the checkpoint.
+  //
+  // Does not wait for completion of the checkpoint function in running threads.
+  //
+  // If the caller holds the mutator lock, or acquire_mutator_lock is true, then all instances of
+  // the checkpoint function are run with the mutator lock. Otherwise, since the checkpoint code
+  // may not acquire or release the mutator lock, the checkpoint will have no way to access Java
+  // data.
+  //
+  // If acquire_mutator_lock is true, it may be acquired repeatedly to avoid holding it for an
+  // extended period without checking for suspension requests.
+  //
+  // We capture a set of threads that simultaneously existed at one point in time, and ensure that
+  // they all run the checkpoint function. We make no guarantees about threads created after this
+  // set of threads was captured. If newly created threads require the effect of the checkpoint,
+  // the caller may update global state indicating that this is necessary, and newly created
+  // threads must act on that. It is possible that on return there will be threads which have not,
+  // and will not, run the checkpoint_function, and neither have/will any of their ancestors.
+  //
+  // TODO: Is it possible to simplify mutator_lock handling here? Should this wait for completion?
   EXPORT size_t RunCheckpoint(Closure* checkpoint_function,
-                       Closure* callback = nullptr,
-                       bool allow_lock_checking = true)
+                              Closure* callback = nullptr,
+                              bool allow_lock_checking = true,
+                              bool acquire_mutator_lock = false)
       REQUIRES(!Locks::thread_list_lock_, !Locks::thread_suspend_count_lock_);
 
   // Convenience version of the above to disable lock checking inside Run function. Hopefully this
diff --git a/runtime/thread_pool.h b/runtime/thread_pool.h
index 6d176546c3..96317ad13d 100644
--- a/runtime/thread_pool.h
+++ b/runtime/thread_pool.h
@@ -192,10 +192,10 @@ class AbstractThreadPool {
   Mutex task_queue_lock_;
   ConditionVariable task_queue_condition_ GUARDED_BY(task_queue_lock_);
   ConditionVariable completion_condition_ GUARDED_BY(task_queue_lock_);
-  volatile bool started_ GUARDED_BY(task_queue_lock_);
-  volatile bool shutting_down_ GUARDED_BY(task_queue_lock_);
+  bool started_ GUARDED_BY(task_queue_lock_);
+  bool shutting_down_ GUARDED_BY(task_queue_lock_);
   // How many worker threads are waiting on the condition.
-  volatile size_t waiting_count_ GUARDED_BY(task_queue_lock_);
+  size_t waiting_count_ GUARDED_BY(task_queue_lock_);
   std::vector<ThreadPoolWorker*> threads_;
   // Work balance detection.
   uint64_t start_time_ GUARDED_BY(task_queue_lock_);
diff --git a/runtime/trace.cc b/runtime/trace.cc
index a9c62b7a9e..c3fc6fd138 100644
--- a/runtime/trace.cc
+++ b/runtime/trace.cc
@@ -50,6 +50,7 @@
 #include "stack.h"
 #include "thread.h"
 #include "thread_list.h"
+#include "trace_profile.h"
 
 namespace art HIDDEN {
 
@@ -77,21 +78,6 @@ static const uint16_t kTraceRecordSizeSingleClock = 10;  // using v2
 static const uint16_t kTraceRecordSizeDualClock   = 14;  // using v3 with two timestamps
 static const size_t kNumTracePoolBuffers = 32;
 
-// Packet type encoding for the new method tracing format.
-static const int kThreadInfoHeaderV2 = 0;
-static const int kMethodInfoHeaderV2 = 1;
-static const int kEntryHeaderV2 = 2;
-static const int kSummaryHeaderV2 = 3;
-
-// Packet sizes for the new method trace format.
-static const uint16_t kTraceHeaderLengthV2 = 32;
-static const uint16_t kTraceRecordSizeSingleClockV2 = 6;
-static const uint16_t kTraceRecordSizeDualClockV2 = kTraceRecordSizeSingleClockV2 + 2;
-static const uint16_t kEntryHeaderSizeSingleClockV2 = 21;
-static const uint16_t kEntryHeaderSizeDualClockV2 = kEntryHeaderSizeSingleClockV2 + 4;
-
-static const uint16_t kTraceVersionSingleClockV2 = 4;
-static const uint16_t kTraceVersionDualClockV2 = 5;
 
 static constexpr size_t kMinBufSize = 18U;  // Trace header is up to 18B.
 // Size of per-thread buffer size. The value is chosen arbitrarily. This value
@@ -262,6 +248,18 @@ int GetTraceFormatVersionFromFlags(int flags) {
 
 }  // namespace
 
+// Temporary code for debugging b/342768977
+int num_trace_starts_ GUARDED_BY(Locks::trace_lock_);
+int num_trace_stops_initiated_ GUARDED_BY(Locks::trace_lock_);
+std::atomic<int> num_trace_stops_finished_;
+std::string Trace::GetDebugInformation() {
+  MutexLock mu(Thread::Current(), *Locks::trace_lock_);
+  std::stringstream debug_info;
+  debug_info << "start:" << num_trace_starts_ << "stop:" << num_trace_stops_initiated_ << "done:"
+             << num_trace_stops_finished_ << "trace:" << the_trace_;
+  return debug_info.str();
+}
+
 bool TraceWriter::HasMethodEncoding(ArtMethod* method) {
   return art_method_id_map_.find(method) != art_method_id_map_.end();
 }
@@ -447,32 +445,6 @@ uint32_t Trace::GetClockOverheadNanoSeconds() {
   return static_cast<uint32_t>(elapsed_us / 32);
 }
 
-// TODO: put this somewhere with the big-endian equivalent used by JDWP.
-static void Append2LE(uint8_t* buf, uint16_t val) {
-  *buf++ = static_cast<uint8_t>(val);
-  *buf++ = static_cast<uint8_t>(val >> 8);
-}
-
-// TODO: put this somewhere with the big-endian equivalent used by JDWP.
-static void Append4LE(uint8_t* buf, uint32_t val) {
-  *buf++ = static_cast<uint8_t>(val);
-  *buf++ = static_cast<uint8_t>(val >> 8);
-  *buf++ = static_cast<uint8_t>(val >> 16);
-  *buf++ = static_cast<uint8_t>(val >> 24);
-}
-
-// TODO: put this somewhere with the big-endian equivalent used by JDWP.
-static void Append8LE(uint8_t* buf, uint64_t val) {
-  *buf++ = static_cast<uint8_t>(val);
-  *buf++ = static_cast<uint8_t>(val >> 8);
-  *buf++ = static_cast<uint8_t>(val >> 16);
-  *buf++ = static_cast<uint8_t>(val >> 24);
-  *buf++ = static_cast<uint8_t>(val >> 32);
-  *buf++ = static_cast<uint8_t>(val >> 40);
-  *buf++ = static_cast<uint8_t>(val >> 48);
-  *buf++ = static_cast<uint8_t>(val >> 56);
-}
-
 static void GetSample(Thread* thread, void* arg) REQUIRES_SHARED(Locks::mutator_lock_) {
   std::vector<ArtMethod*>* const stack_trace = Trace::AllocStackTrace();
   StackVisitor::WalkStack(
@@ -656,6 +628,10 @@ void TraceWriter::RecordMethodInfoV2(mirror::Class* klass, uint8_t** buffer, siz
 
   std::string class_name_current = klass->PrettyDescriptor();
   const char* source_file_current = klass->GetSourceFile();
+  if (source_file_current == nullptr) {
+    // Generated classes have no source file.
+    source_file_current = "";
+  }
   for (ArtMethod& method : klass->GetMethods(kRuntimePointerSize)) {
     if (!method.IsInvokable()) {
       continue;
@@ -817,51 +793,58 @@ void Trace::Start(std::unique_ptr<File>&& trace_file_in,
                                     gc::kCollectorTypeInstrumentation);
     ScopedSuspendAll ssa(__FUNCTION__);
     MutexLock mu(self, *Locks::trace_lock_);
-    if (the_trace_ != nullptr) {
+    if (TraceProfiler::IsTraceProfileInProgress()) {
+      LOG(ERROR) << "On-demand profile in progress, ignoring this request";
+      return;
+    }
+
+    if (Trace::IsTracingEnabledLocked()) {
       LOG(ERROR) << "Trace already in progress, ignoring this request";
+      return;
+    }
+
+    enable_stats = (flags & kTraceCountAllocs) != 0;
+    bool is_trace_format_v2 = GetTraceFormatVersionFromFlags(flags) == Trace::kFormatV2;
+    the_trace_ = new Trace(trace_file.release(), buffer_size, flags, output_mode, trace_mode);
+    num_trace_starts_++;
+    if (is_trace_format_v2) {
+      // Record all the methods that are currently loaded. We log all methods when any new class
+      // is loaded. This will allow us to process the trace entries without requiring a mutator
+      // lock.
+      RecordMethodInfoClassVisitor visitor(the_trace_);
+      runtime->GetClassLinker()->VisitClasses(&visitor);
+      visitor.FlushBuffer();
+    }
+    if (trace_mode == TraceMode::kSampling) {
+      CHECK_PTHREAD_CALL(pthread_create, (&sampling_pthread_, nullptr, &RunSamplingThread,
+                                          reinterpret_cast<void*>(interval_us)),
+                         "Sampling profiler thread");
+      the_trace_->interval_us_ = interval_us;
     } else {
-      enable_stats = (flags & kTraceCountAllocs) != 0;
-      int trace_format_version = GetTraceFormatVersionFromFlags(flags);
-      the_trace_ = new Trace(trace_file.release(), buffer_size, flags, output_mode, trace_mode);
-      if (trace_format_version == Trace::kFormatV2) {
-        // Record all the methods that are currently loaded. We log all methods when any new class
-        // is loaded. This will allow us to process the trace entries without requiring a mutator
-        // lock.
-        RecordMethodInfoClassVisitor visitor(the_trace_);
-        runtime->GetClassLinker()->VisitClasses(&visitor);
-        visitor.FlushBuffer();
-      }
-      if (trace_mode == TraceMode::kSampling) {
-        CHECK_PTHREAD_CALL(pthread_create, (&sampling_pthread_, nullptr, &RunSamplingThread,
-                                            reinterpret_cast<void*>(interval_us)),
-                                            "Sampling profiler thread");
-        the_trace_->interval_us_ = interval_us;
-      } else {
-        if (!runtime->IsJavaDebuggable()) {
-          art::jit::Jit* jit = runtime->GetJit();
-          if (jit != nullptr) {
-            jit->GetCodeCache()->InvalidateAllCompiledCode();
-            jit->GetCodeCache()->TransitionToDebuggable();
-            jit->GetJitCompiler()->SetDebuggableCompilerOption(true);
-          }
-          runtime->SetRuntimeDebugState(art::Runtime::RuntimeDebugState::kJavaDebuggable);
-          runtime->GetInstrumentation()->UpdateEntrypointsForDebuggable();
-          runtime->DeoptimizeBootImage();
-        }
-        if (trace_format_version == Trace::kFormatV2) {
-          // Add ClassLoadCallback to record methods on class load.
-          runtime->GetRuntimeCallbacks()->AddClassLoadCallback(the_trace_);
+      if (!runtime->IsJavaDebuggable()) {
+        art::jit::Jit* jit = runtime->GetJit();
+        if (jit != nullptr) {
+          jit->GetCodeCache()->InvalidateAllCompiledCode();
+          jit->GetCodeCache()->TransitionToDebuggable();
+          jit->GetJitCompiler()->SetDebuggableCompilerOption(true);
         }
-        runtime->GetInstrumentation()->AddListener(
-            the_trace_,
-            instrumentation::Instrumentation::kMethodEntered |
-                instrumentation::Instrumentation::kMethodExited |
-                instrumentation::Instrumentation::kMethodUnwind,
-            UseFastTraceListeners(the_trace_->GetClockSource()));
-        runtime->GetInstrumentation()->EnableMethodTracing(kTracerInstrumentationKey,
-                                                           the_trace_,
-                                                           /*needs_interpreter=*/false);
+        runtime->SetRuntimeDebugState(art::Runtime::RuntimeDebugState::kJavaDebuggable);
+        runtime->GetInstrumentation()->UpdateEntrypointsForDebuggable();
+        runtime->DeoptimizeBootImage();
       }
+      if (is_trace_format_v2) {
+        // Add ClassLoadCallback to record methods on class load.
+        runtime->GetRuntimeCallbacks()->AddClassLoadCallback(the_trace_);
+      }
+      runtime->GetInstrumentation()->AddListener(
+          the_trace_,
+          instrumentation::Instrumentation::kMethodEntered |
+              instrumentation::Instrumentation::kMethodExited |
+              instrumentation::Instrumentation::kMethodUnwind,
+          UseFastTraceListeners(the_trace_->GetClockSource()));
+      runtime->GetInstrumentation()->EnableMethodTracing(kTracerInstrumentationKey,
+                                                         the_trace_,
+                                                         /*needs_interpreter=*/false);
     }
   }
 
@@ -878,8 +861,10 @@ void Trace::StopTracing(bool flush_entries) {
   pthread_t sampling_pthread = 0U;
   {
     MutexLock mu(self, *Locks::trace_lock_);
-    if (the_trace_ == nullptr) {
-      LOG(ERROR) << "Trace stop requested, but no trace currently running";
+    num_trace_stops_initiated_++;
+    if (the_trace_ == nullptr || the_trace_->stop_tracing_) {
+      LOG(ERROR) << "Trace stop requested, but no trace currently running or trace is being"
+                 << " stopped concurrently on another thread";
       return;
     }
     // Tell sampling_pthread_ to stop tracing.
@@ -951,6 +936,7 @@ void Trace::StopTracing(bool flush_entries) {
   // are now visible.
   the_trace->trace_writer_->FinishTracing(the_trace->flags_, flush_entries);
   delete the_trace;
+  num_trace_stops_finished_++;
 
   if (stop_alloc_counting) {
     // Can be racy since SetStatsEnabled is not guarded by any locks.
@@ -993,6 +979,7 @@ void Trace::ReleaseThreadBuffer(Thread* self) {
     return;
   }
   the_trace_->trace_writer_->ReleaseBufferForThread(self);
+  self->SetMethodTraceBuffer(nullptr, 0);
 }
 
 void Trace::Abort() {
@@ -1084,7 +1071,7 @@ TraceWriter::TraceWriter(File* trace_file,
     cur_offset_ = kTraceHeaderLengthV2;
   }
 
-  if (output_mode == TraceOutputMode::kStreaming) {
+  if (output_mode == TraceOutputMode::kStreaming || trace_format_version_ == Trace::kFormatV2) {
     // Flush the header information to the file. We use a per thread buffer, so
     // it is easier to just write the header information directly to file.
     if (!trace_file_->WriteFully(buf_.get(), kTraceHeaderLength)) {
@@ -1136,125 +1123,139 @@ Trace::Trace(File* trace_file,
                                       GetClockOverheadNanoSeconds()));
 }
 
-void TraceWriter::FinishTracing(int flags, bool flush_entries) {
-  Thread* self = Thread::Current();
-  if (flush_entries) {
-    if (thread_pool_ != nullptr) {
-      // Wait for any workers to be created. If we are stopping tracing as a part of runtime
-      // shutdown, any unstarted workers can create problems if they try attaching while shutting
-      // down.
-      thread_pool_->WaitForWorkersToBeCreated();
-      // Wait for any outstanding writer tasks to finish. Let the thread pool worker finish the
-      // tasks to avoid any re-ordering when processing tasks.
-      thread_pool_->Wait(self, /* do_work= */ false, /* may_hold_locks= */ true);
-      DCHECK_EQ(thread_pool_->GetTaskCount(self), 0u);
-      thread_pool_->StopWorkers(self);
-    }
-
-    size_t final_offset = 0;
-    if (trace_output_mode_ != TraceOutputMode::kStreaming) {
-      MutexLock mu(Thread::Current(), trace_writer_lock_);
-      final_offset = cur_offset_;
+std::string TraceWriter::CreateSummary(int flags) {
+  std::ostringstream os;
+  // Compute elapsed time.
+  uint64_t elapsed = GetMicroTime(GetTimestamp()) - start_time_;
+  os << StringPrintf("%cversion\n", kTraceTokenChar);
+  os << StringPrintf("%d\n", GetTraceVersion(clock_source_, trace_format_version_));
+  os << StringPrintf("data-file-overflow=%s\n", overflow_ ? "true" : "false");
+  if (UseThreadCpuClock(clock_source_)) {
+    if (UseWallClock(clock_source_)) {
+      os << StringPrintf("clock=dual\n");
+    } else {
+      os << StringPrintf("clock=thread-cpu\n");
     }
+  } else {
+    os << StringPrintf("clock=wall\n");
+  }
+  os << StringPrintf("elapsed-time-usec=%" PRIu64 "\n", elapsed);
+  if (trace_output_mode_ != TraceOutputMode::kStreaming) {
+    os << StringPrintf("num-method-calls=%zd\n", num_records_);
+  }
+  os << StringPrintf("clock-call-overhead-nsec=%d\n", clock_overhead_ns_);
+  os << StringPrintf("vm=art\n");
+  os << StringPrintf("pid=%d\n", getpid());
+  if ((flags & Trace::kTraceCountAllocs) != 0) {
+    os << "alloc-count=" << Runtime::Current()->GetStat(KIND_ALLOCATED_OBJECTS) << "\n";
+    os << "alloc-size=" << Runtime::Current()->GetStat(KIND_ALLOCATED_BYTES) << "\n";
+    os << "gc-count=" << Runtime::Current()->GetStat(KIND_GC_INVOCATIONS) << "\n";
+  }
 
-    // Compute elapsed time.
-    uint64_t elapsed = GetMicroTime(GetTimestamp()) - start_time_;
+  if (trace_format_version_ == Trace::kFormatV1) {
+    os << StringPrintf("%cthreads\n", kTraceTokenChar);
+    DumpThreadList(os);
+    os << StringPrintf("%cmethods\n", kTraceTokenChar);
+    DumpMethodList(os);
+  }
+  os << StringPrintf("%cend\n", kTraceTokenChar);
+  return os.str();
+}
 
-    std::ostringstream os;
+void TraceWriter::FinishTracing(int flags, bool flush_entries) {
+  Thread* self = Thread::Current();
 
-    os << StringPrintf("%cversion\n", kTraceTokenChar);
-    os << StringPrintf("%d\n", GetTraceVersion(clock_source_, trace_format_version_));
-    os << StringPrintf("data-file-overflow=%s\n", overflow_ ? "true" : "false");
-    if (UseThreadCpuClock(clock_source_)) {
-      if (UseWallClock(clock_source_)) {
-        os << StringPrintf("clock=dual\n");
-      } else {
-        os << StringPrintf("clock=thread-cpu\n");
-      }
-    } else {
-      os << StringPrintf("clock=wall\n");
-    }
-    os << StringPrintf("elapsed-time-usec=%" PRIu64 "\n", elapsed);
-    if (trace_output_mode_ != TraceOutputMode::kStreaming) {
-      os << StringPrintf("num-method-calls=%zd\n", num_records_);
-    }
-    os << StringPrintf("clock-call-overhead-nsec=%d\n", clock_overhead_ns_);
-    os << StringPrintf("vm=art\n");
-    os << StringPrintf("pid=%d\n", getpid());
-    if ((flags & Trace::kTraceCountAllocs) != 0) {
-      os << "alloc-count=" << Runtime::Current()->GetStat(KIND_ALLOCATED_OBJECTS) << "\n";
-      os << "alloc-size=" << Runtime::Current()->GetStat(KIND_ALLOCATED_BYTES) << "\n";
-      os << "gc-count=" <<  Runtime::Current()->GetStat(KIND_GC_INVOCATIONS) << "\n";
+  if (!flush_entries) {
+    // This is only called from the child process post fork to abort the trace.
+    // We shouldn't have any workers in the thread pool here.
+    DCHECK_EQ(thread_pool_, nullptr);
+    trace_file_->MarkUnchecked();  // Do not trigger guard.
+    if (trace_file_->Close() != 0) {
+      PLOG(ERROR) << "Could not close trace file.";
     }
+    return;
+  }
 
-    if (trace_format_version_ == Trace::kFormatV1) {
-      os << StringPrintf("%cthreads\n", kTraceTokenChar);
-      DumpThreadList(os);
-      os << StringPrintf("%cmethods\n", kTraceTokenChar);
-      DumpMethodList(os);
-    }
-    os << StringPrintf("%cend\n", kTraceTokenChar);
-    std::string header(os.str());
+  if (thread_pool_ != nullptr) {
+    // Wait for any workers to be created. If we are stopping tracing as a part of runtime
+    // shutdown, any unstarted workers can create problems if they try attaching while shutting
+    // down.
+    thread_pool_->WaitForWorkersToBeCreated();
+    // Wait for any outstanding writer tasks to finish. Let the thread pool worker finish the
+    // tasks to avoid any re-ordering when processing tasks.
+    thread_pool_->Wait(self, /* do_work= */ false, /* may_hold_locks= */ true);
+    DCHECK_EQ(thread_pool_->GetTaskCount(self), 0u);
+    thread_pool_->StopWorkers(self);
+  }
 
+  size_t final_offset = 0;
+  if (trace_output_mode_ != TraceOutputMode::kStreaming) {
+    MutexLock mu(Thread::Current(), trace_writer_lock_);
+    final_offset = cur_offset_;
+  }
+
+  std::string summary = CreateSummary(flags);
+  if (trace_format_version_ == Trace::kFormatV1) {
     if (trace_output_mode_ == TraceOutputMode::kStreaming) {
       DCHECK_NE(trace_file_.get(), nullptr);
       // It is expected that this method is called when all other threads are suspended, so there
       // cannot be any writes to trace_file_ after finish tracing.
       // Write a special token to mark the end of trace records and the start of
       // trace summary.
-      if (trace_format_version_ == Trace::kFormatV1) {
-        uint8_t buf[7];
-        Append2LE(buf, 0);
-        buf[2] = kOpTraceSummary;
-        Append4LE(buf + 3, static_cast<uint32_t>(header.length()));
-        // Write the trace summary. The summary is identical to the file header when
-        // the output mode is not streaming (except for methods).
-        if (!trace_file_->WriteFully(buf, sizeof(buf)) ||
-            !trace_file_->WriteFully(header.c_str(), header.length())) {
-          PLOG(WARNING) << "Failed streaming a tracing event.";
-        }
-      } else {
-        uint8_t buf[3];
-        buf[0] = kSummaryHeaderV2;
-        Append2LE(buf + 1, static_cast<uint32_t>(header.length()));
-        // Write the trace summary. Reports information about tracing mode, number of records and
-        // clock overhead in plain text format.
-        if (!trace_file_->WriteFully(buf, sizeof(buf)) ||
-            !trace_file_->WriteFully(header.c_str(), header.length())) {
-          PLOG(WARNING) << "Failed streaming a tracing event.";
-        }
+      uint8_t buf[7];
+      Append2LE(buf, 0);
+      buf[2] = kOpTraceSummary;
+      Append4LE(buf + 3, static_cast<uint32_t>(summary.length()));
+      // Write the trace summary. The summary is identical to the file header when
+      // the output mode is not streaming (except for methods).
+      if (!trace_file_->WriteFully(buf, sizeof(buf)) ||
+          !trace_file_->WriteFully(summary.c_str(), summary.length())) {
+        PLOG(WARNING) << "Failed streaming a tracing event.";
       }
-    } else {
-      if (trace_file_.get() == nullptr) {
-        std::vector<uint8_t> data;
-        data.resize(header.length() + final_offset);
-        memcpy(data.data(), header.c_str(), header.length());
-        memcpy(data.data() + header.length(), buf_.get(), final_offset);
-        Runtime::Current()->GetRuntimeCallbacks()->DdmPublishChunk(CHUNK_TYPE("MPSE"),
-                                                                   ArrayRef<const uint8_t>(data));
-      } else {
-        if (!trace_file_->WriteFully(header.c_str(), header.length()) ||
-            !trace_file_->WriteFully(buf_.get(), final_offset)) {
-          std::string detail(StringPrintf("Trace data write failed: %s", strerror(errno)));
-          PLOG(ERROR) << detail;
-          ThrowRuntimeException("%s", detail.c_str());
-        }
+    } else if (trace_output_mode_ == TraceOutputMode::kFile) {
+      DCHECK_NE(trace_file_.get(), nullptr);
+      if (!trace_file_->WriteFully(summary.c_str(), summary.length()) ||
+          !trace_file_->WriteFully(buf_.get(), final_offset)) {
+        std::string detail(StringPrintf("Trace data write failed: %s", strerror(errno)));
+        PLOG(ERROR) << detail;
+        ThrowRuntimeException("%s", detail.c_str());
       }
+    } else {
+      DCHECK_EQ(trace_file_.get(), nullptr);
+      DCHECK(trace_output_mode_ == TraceOutputMode::kDDMS);
+      std::vector<uint8_t> data;
+      data.resize(summary.length() + final_offset);
+      memcpy(data.data(), summary.c_str(), summary.length());
+      memcpy(data.data() + summary.length(), buf_.get(), final_offset);
+      Runtime::Current()->GetRuntimeCallbacks()->DdmPublishChunk(CHUNK_TYPE("MPSE"),
+                                                                 ArrayRef<const uint8_t>(data));
     }
   } else {
-    // This is only called from the child process post fork to abort the trace.
-    // We shouldn't have any workers in the thread pool here.
-    DCHECK_EQ(thread_pool_, nullptr);
+    DCHECK(trace_format_version_ == Trace::kFormatV2);
+    DCHECK(trace_output_mode_ != TraceOutputMode::kDDMS);
+
+    if (trace_output_mode_ == TraceOutputMode::kFile) {
+      if (!trace_file_->WriteFully(buf_.get(), final_offset)) {
+        PLOG(WARNING) << "Failed to write trace output";
+      }
+    }
+
+    // Write the summary packet
+    uint8_t buf[3];
+    buf[0] = kSummaryHeaderV2;
+    Append2LE(buf + 1, static_cast<uint32_t>(summary.length()));
+    // Write the trace summary. Reports information about tracing mode, number of records and
+    // clock overhead in plain text format.
+    if (!trace_file_->WriteFully(buf, sizeof(buf)) ||
+        !trace_file_->WriteFully(summary.c_str(), summary.length())) {
+      PLOG(WARNING) << "Failed streaming a tracing event.";
+    }
   }
 
   if (trace_file_.get() != nullptr) {
     // Do not try to erase, so flush and close explicitly.
-    if (flush_entries) {
-      if (trace_file_->Flush() != 0) {
-        PLOG(WARNING) << "Could not flush trace file.";
-      }
-    } else {
-      trace_file_->MarkUnchecked();  // Do not trigger guard.
+    if (trace_file_->Flush() != 0) {
+      PLOG(WARNING) << "Could not flush trace file.";
     }
     if (trace_file_->Close() != 0) {
       PLOG(ERROR) << "Could not close trace file.";
@@ -1382,7 +1383,8 @@ void TraceWriter::RecordThreadInfo(Thread* thread) {
   }
 
   MutexLock mu(Thread::Current(), trace_writer_lock_);
-  if (trace_output_mode_ != TraceOutputMode::kStreaming) {
+  if (trace_format_version_ == Trace::kFormatV1 &&
+      trace_output_mode_ != TraceOutputMode::kStreaming) {
     threads_list_.Overwrite(GetThreadEncoding(thread->GetTid()), thread_name);
     return;
   }
@@ -1427,7 +1429,7 @@ void TraceWriter::PreProcessTraceForMethodInfos(
     uintptr_t method_and_action = method_trace_entries[entry_index];
     ArtMethod* method = reinterpret_cast<ArtMethod*>(method_and_action & kMaskTraceAction);
     if (!HasMethodEncoding(method) && method_infos.find(method) == method_infos.end()) {
-      method_infos.emplace(method, std::move(GetMethodInfoLine(method)));
+      method_infos.emplace(method, GetMethodInfoLine(method));
     }
   }
 }
@@ -1620,25 +1622,25 @@ int TraceWriter::GetMethodTraceIndex(uintptr_t* current_buffer) {
 
 void TraceWriter::FlushBuffer(Thread* thread, bool is_sync, bool release) {
   uintptr_t* method_trace_entries = thread->GetMethodTraceBuffer();
-  size_t* current_offset = thread->GetMethodTraceIndexPtr();
+  uintptr_t** current_entry_ptr = thread->GetTraceBufferCurrEntryPtr();
+  size_t current_offset = *current_entry_ptr - method_trace_entries;
   size_t tid = thread->GetTid();
   DCHECK(method_trace_entries != nullptr);
 
   if (is_sync || thread_pool_ == nullptr) {
     std::unordered_map<ArtMethod*, std::string> method_infos;
     if (trace_format_version_ == Trace::kFormatV1) {
-      PreProcessTraceForMethodInfos(method_trace_entries, *current_offset, method_infos);
+      PreProcessTraceForMethodInfos(method_trace_entries, current_offset, method_infos);
     }
-    FlushBuffer(method_trace_entries, *current_offset, tid, method_infos);
+    FlushBuffer(method_trace_entries, current_offset, tid, method_infos);
 
     // This is a synchronous flush, so no need to allocate a new buffer. This is used either
     // when the tracing has finished or in non-streaming mode.
     // Just reset the buffer pointer to the initial value, so we can reuse the same buffer.
     if (release) {
-      thread->SetMethodTraceBuffer(nullptr);
-      *current_offset = 0;
+      thread->SetMethodTraceBuffer(nullptr, 0);
     } else {
-      *current_offset = kPerThreadBufSize;
+      thread->SetMethodTraceBufferCurrentEntry(kPerThreadBufSize);
     }
   } else {
     int old_index = GetMethodTraceIndex(method_trace_entries);
@@ -1646,13 +1648,11 @@ void TraceWriter::FlushBuffer(Thread* thread, bool is_sync, bool release) {
     // entries are flushed.
     thread_pool_->AddTask(
         Thread::Current(),
-        new TraceEntriesWriterTask(this, old_index, method_trace_entries, *current_offset, tid));
+        new TraceEntriesWriterTask(this, old_index, method_trace_entries, current_offset, tid));
     if (release) {
-      thread->SetMethodTraceBuffer(nullptr);
-      *current_offset = 0;
+      thread->SetMethodTraceBuffer(nullptr, 0);
     } else {
-      thread->SetMethodTraceBuffer(AcquireTraceBuffer(tid));
-      *current_offset = kPerThreadBufSize;
+      thread->SetMethodTraceBuffer(AcquireTraceBuffer(tid), kPerThreadBufSize);
     }
   }
 
@@ -1729,17 +1729,17 @@ void TraceWriter::FlushEntriesFormatV2(
     size_t num_records,
     size_t* current_index,
     uint8_t* init_buffer_ptr) {
+  uint8_t* current_buffer_ptr = init_buffer_ptr;
+
+  EncodeEventBlockHeader(current_buffer_ptr, tid, num_records);
+  current_buffer_ptr += kEntryHeaderSizeV2;
+
   bool has_thread_cpu_clock = UseThreadCpuClock(clock_source_);
   bool has_wall_clock = UseWallClock(clock_source_);
   size_t num_entries = GetNumEntries(clock_source_);
   uint32_t prev_wall_timestamp = 0;
   uint32_t prev_thread_timestamp = 0;
   uint64_t prev_method_action_encoding = 0;
-  bool is_first_entry = true;
-  uint8_t* current_buffer_ptr = init_buffer_ptr;
-  uint32_t header_size = (clock_source_ == TraceClockSource::kDual) ? kEntryHeaderSizeDualClockV2 :
-                                                                      kEntryHeaderSizeSingleClockV2;
-
   size_t entry_index = kPerThreadBufSize;
   for (size_t i = 0; i < num_records; i++) {
     entry_index -= num_entries;
@@ -1755,41 +1755,26 @@ void TraceWriter::FlushEntriesFormatV2(
     uint64_t method_id = reinterpret_cast<uintptr_t>(record.method);
     uint64_t method_action_encoding = method_id | record.action;
 
-    if (is_first_entry) {
+    int64_t method_diff = method_action_encoding - prev_method_action_encoding;
+    current_buffer_ptr = EncodeSignedLeb128(current_buffer_ptr, method_diff);
+    prev_method_action_encoding = method_action_encoding;
+
+    if (has_wall_clock) {
+      current_buffer_ptr =
+          EncodeUnsignedLeb128(current_buffer_ptr, (record.wall_clock_time - prev_wall_timestamp));
       prev_wall_timestamp = record.wall_clock_time;
-      prev_thread_timestamp = record.thread_cpu_time;
-      prev_method_action_encoding = method_action_encoding;
-      is_first_entry = false;
-
-      EncodeEventBlockHeader(init_buffer_ptr,
-                             tid,
-                             method_action_encoding,
-                             prev_thread_timestamp,
-                             prev_wall_timestamp,
-                             num_records);
-      current_buffer_ptr += header_size;
-    } else {
-      int64_t method_diff = method_action_encoding - prev_method_action_encoding;
-      current_buffer_ptr = EncodeSignedLeb128(current_buffer_ptr, method_diff);
-      prev_method_action_encoding = method_action_encoding;
-
-      if (has_wall_clock) {
-        current_buffer_ptr =
-            EncodeUnsignedLeb128(current_buffer_ptr, (record.wall_clock_time - prev_wall_timestamp));
-        prev_wall_timestamp = record.wall_clock_time;
-      }
+    }
 
-      if (has_thread_cpu_clock) {
-        current_buffer_ptr =
-            EncodeUnsignedLeb128(current_buffer_ptr, (record.thread_cpu_time - prev_thread_timestamp));
-        prev_thread_timestamp = record.thread_cpu_time;
-      }
+    if (has_thread_cpu_clock) {
+      current_buffer_ptr = EncodeUnsignedLeb128(current_buffer_ptr,
+                                                (record.thread_cpu_time - prev_thread_timestamp));
+      prev_thread_timestamp = record.thread_cpu_time;
     }
   }
 
   // Update the total size of the block excluding header size.
-  uint8_t* total_size_loc = init_buffer_ptr + header_size - 2;
-  Append2LE(total_size_loc, current_buffer_ptr - (init_buffer_ptr + header_size));
+  uint8_t* total_size_loc = init_buffer_ptr + kEntryHeaderSizeV2 - 4;
+  Append4LE(total_size_loc, current_buffer_ptr - (init_buffer_ptr + kEntryHeaderSizeV2));
   *current_index += current_buffer_ptr - init_buffer_ptr;
 }
 
@@ -1829,7 +1814,8 @@ void TraceWriter::FlushBuffer(uintptr_t* method_trace_entries,
     FlushEntriesFormatV1(
         method_trace_entries, tid, method_infos, current_offset, &current_index, buffer_ptr);
   } else {
-    FlushEntriesFormatV2(method_trace_entries, tid, num_records, &current_index, buffer_ptr);
+    FlushEntriesFormatV2(
+        method_trace_entries, tid, num_records, &current_index, buffer_ptr + current_index);
   }
 
   if (trace_output_mode_ == TraceOutputMode::kStreaming) {
@@ -1855,53 +1841,51 @@ void Trace::LogMethodTraceEvent(Thread* thread,
   // concurrently.
 
   uintptr_t* method_trace_buffer = thread->GetMethodTraceBuffer();
-  size_t* current_index = thread->GetMethodTraceIndexPtr();
+  uintptr_t** current_entry_ptr = thread->GetTraceBufferCurrEntryPtr();
   // Initialize the buffer lazily. It's just simpler to keep the creation at one place.
   if (method_trace_buffer == nullptr) {
     method_trace_buffer = trace_writer_->AcquireTraceBuffer(thread->GetTid());
     DCHECK(method_trace_buffer != nullptr);
-    thread->SetMethodTraceBuffer(method_trace_buffer);
-    *current_index = kPerThreadBufSize;
+    thread->SetMethodTraceBuffer(method_trace_buffer, kPerThreadBufSize);
     trace_writer_->RecordThreadInfo(thread);
   }
 
   if (trace_writer_->HasOverflow()) {
     // In non-streaming modes, we stop recoding events once the buffer is full. Just reset the
     // index, so we don't go to runtime for each method.
-    *current_index = kPerThreadBufSize;
+    thread->SetMethodTraceBufferCurrentEntry(kPerThreadBufSize);
     return;
   }
 
   size_t required_entries = GetNumEntries(clock_source_);
-  if (*current_index < required_entries) {
+  if (*current_entry_ptr - required_entries < method_trace_buffer) {
     // This returns nullptr in non-streaming mode if there's an overflow and we cannot record any
     // more entries. In streaming mode, it returns nullptr if it fails to allocate a new buffer.
     method_trace_buffer = trace_writer_->PrepareBufferForNewEntries(thread);
     if (method_trace_buffer == nullptr) {
-      *current_index = kPerThreadBufSize;
+      thread->SetMethodTraceBufferCurrentEntry(kPerThreadBufSize);
       return;
     }
   }
+  *current_entry_ptr = *current_entry_ptr - required_entries;
 
   // Record entry in per-thread trace buffer.
-  // Update the offset
-  int new_entry_index = *current_index - required_entries;
-  *current_index = new_entry_index;
-
+  int entry_index = 0;
+  uintptr_t* current_entry = *current_entry_ptr;
   // Ensure we always use the non-obsolete version of the method so that entry/exit events have the
   // same pointer value.
   method = method->GetNonObsoleteMethod();
-  method_trace_buffer[new_entry_index++] = reinterpret_cast<uintptr_t>(method) | action;
+  current_entry[entry_index++] = reinterpret_cast<uintptr_t>(method) | action;
   if (UseThreadCpuClock(clock_source_)) {
-    method_trace_buffer[new_entry_index++] = thread_clock_diff;
+    current_entry[entry_index++] = thread_clock_diff;
   }
   if (UseWallClock(clock_source_)) {
     if (art::kRuntimePointerSize == PointerSize::k32) {
       // On 32-bit architectures store timestamp counter as two 32-bit values.
-      method_trace_buffer[new_entry_index++] = static_cast<uint32_t>(timestamp_counter);
-      method_trace_buffer[new_entry_index++] = timestamp_counter >> 32;
+      current_entry[entry_index++] = static_cast<uint32_t>(timestamp_counter);
+      current_entry[entry_index++] = timestamp_counter >> 32;
     } else {
-      method_trace_buffer[new_entry_index++] = timestamp_counter;
+      current_entry[entry_index++] = timestamp_counter;
     }
   }
 }
@@ -1929,28 +1913,12 @@ void TraceWriter::EncodeEventEntry(uint8_t* ptr,
   static_assert(kPacketSize == 2 + 4 + 4 + 4, "Packet size incorrect.");
 }
 
-void TraceWriter::EncodeEventBlockHeader(uint8_t* ptr,
-                                         uint32_t thread_id,
-                                         uint64_t init_method_index,
-                                         uint32_t init_thread_clock,
-                                         uint32_t init_wall_clock,
-                                         uint16_t num_records) {
+void TraceWriter::EncodeEventBlockHeader(uint8_t* ptr, uint32_t thread_id, uint32_t num_records) {
   ptr[0] = kEntryHeaderV2;
   Append4LE(ptr + 1, thread_id);
-  Append8LE(ptr + 5, init_method_index);
-  ptr += 13;
-
-  if (UseThreadCpuClock(clock_source_)) {
-    Append4LE(ptr, init_thread_clock);
-    ptr += 4;
-  }
-  if (UseWallClock(clock_source_)) {
-    Append4LE(ptr, init_wall_clock);
-    ptr += 4;
-  }
-  // This specifies the total number of records encoded in the block using lebs. We encode the first
-  // entry in the header, so the block contains one less than num_records.
-  Append2LE(ptr, num_records - 1);
+  // This specifies the total number of records encoded in the block using lebs.
+  DCHECK_LT(num_records, 1u << 24);
+  Append3LE(ptr + 5, num_records);
 }
 
 void TraceWriter::EnsureSpace(uint8_t* buffer,
@@ -2016,4 +1984,8 @@ bool Trace::IsTracingEnabled() {
   return the_trace_ != nullptr;
 }
 
+bool Trace::IsTracingEnabledLocked() {
+  return the_trace_ != nullptr;
+}
+
 }  // namespace art
diff --git a/runtime/trace.h b/runtime/trace.h
index 46b66303c4..445cd7e3af 100644
--- a/runtime/trace.h
+++ b/runtime/trace.h
@@ -124,6 +124,56 @@ static constexpr int32_t kHighTimestampOffsetInBytes =
 
 static constexpr uintptr_t kMaskTraceAction = ~0b11;
 
+// Packet type encoding for the new method tracing format.
+static constexpr int kThreadInfoHeaderV2 = 0;
+static constexpr int kMethodInfoHeaderV2 = 1;
+static constexpr int kEntryHeaderV2 = 2;
+static constexpr int kSummaryHeaderV2 = 3;
+
+// Packet sizes for the new method tracing format.
+static constexpr uint16_t kTraceHeaderLengthV2 = 32;
+static constexpr uint16_t kTraceRecordSizeSingleClockV2 = 6;
+static constexpr uint16_t kTraceRecordSizeDualClockV2 = kTraceRecordSizeSingleClockV2 + 2;
+static constexpr uint16_t kEntryHeaderSizeV2 = 12;
+
+static constexpr uint16_t kTraceVersionSingleClockV2 = 4;
+static constexpr uint16_t kTraceVersionDualClockV2 = 5;
+
+// TODO(mythria): Consider adding checks to guard agaist OOB access for Append*LE methods.
+// Currently the onus is on the callers to ensure there is sufficient space in the buffer.
+// TODO: put this somewhere with the big-endian equivalent used by JDWP.
+static inline void Append2LE(uint8_t* buf, uint16_t val) {
+  *buf++ = static_cast<uint8_t>(val);
+  *buf++ = static_cast<uint8_t>(val >> 8);
+}
+
+// TODO: put this somewhere with the big-endian equivalent used by JDWP.
+static inline void Append3LE(uint8_t* buf, uint16_t val) {
+  *buf++ = static_cast<uint8_t>(val);
+  *buf++ = static_cast<uint8_t>(val >> 8);
+  *buf++ = static_cast<uint8_t>(val >> 16);
+}
+
+// TODO: put this somewhere with the big-endian equivalent used by JDWP.
+static inline void Append4LE(uint8_t* buf, uint32_t val) {
+  *buf++ = static_cast<uint8_t>(val);
+  *buf++ = static_cast<uint8_t>(val >> 8);
+  *buf++ = static_cast<uint8_t>(val >> 16);
+  *buf++ = static_cast<uint8_t>(val >> 24);
+}
+
+// TODO: put this somewhere with the big-endian equivalent used by JDWP.
+static inline void Append8LE(uint8_t* buf, uint64_t val) {
+  *buf++ = static_cast<uint8_t>(val);
+  *buf++ = static_cast<uint8_t>(val >> 8);
+  *buf++ = static_cast<uint8_t>(val >> 16);
+  *buf++ = static_cast<uint8_t>(val >> 24);
+  *buf++ = static_cast<uint8_t>(val >> 32);
+  *buf++ = static_cast<uint8_t>(val >> 40);
+  *buf++ = static_cast<uint8_t>(val >> 48);
+  *buf++ = static_cast<uint8_t>(val >> 56);
+}
+
 class TraceWriterThreadPool : public ThreadPool {
  public:
   static TraceWriterThreadPool* Create(const char* name) {
@@ -172,6 +222,11 @@ class TraceWriter {
   uintptr_t* PrepareBufferForNewEntries(Thread* thread) REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!trace_writer_lock_);
 
+  // Creates a summary packet which includes some meta information like number of events, clock
+  // overhead, trace version in human readable form. This is used to dump the summary at the end
+  // of tracing..
+  std::string CreateSummary(int flags) REQUIRES(!trace_writer_lock_)
+      REQUIRES_SHARED(Locks::mutator_lock_);
   // Flushes all per-thread buffer and also write a summary entry.
   void FinishTracing(int flags, bool flush_entries) REQUIRES(!trace_writer_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
@@ -293,12 +348,8 @@ class TraceWriter {
 
   // Encodes the header for the events block. This assumes that there is enough space reserved to
   // encode the entry.
-  void EncodeEventBlockHeader(uint8_t* ptr,
-                              uint32_t thread_id,
-                              uint64_t method_index,
-                              uint32_t init_thread_clock_time,
-                              uint32_t init_wall_clock_time,
-                              uint16_t num_records) REQUIRES(trace_writer_lock_);
+  void EncodeEventBlockHeader(uint8_t* ptr, uint32_t thread_id, uint32_t num_records)
+      REQUIRES(trace_writer_lock_);
 
   // Ensures there is sufficient space in the buffer to record the requested_size. If there is not
   // enough sufficient space the current contents of the buffer are written to the file and
@@ -407,6 +458,9 @@ class Trace final : public instrumentation::InstrumentationListener, public Clas
     kSampling
   };
 
+  // Temporary code for debugging b/342768977
+  static std::string GetDebugInformation();
+
   static void SetDefaultClockSource(TraceClockSource clock_source);
 
   static void Start(const char* trace_filename,
@@ -526,6 +580,9 @@ class Trace final : public instrumentation::InstrumentationListener, public Clas
   // Used by class linker to prevent class unloading.
   static bool IsTracingEnabled() REQUIRES(!Locks::trace_lock_);
 
+  // Used by the profiler to see if there is any ongoing tracing.
+  static bool IsTracingEnabledLocked() REQUIRES(Locks::trace_lock_);
+
   // Callback for each class prepare event to record information about the newly created methods.
   static void ClassPrepare(Handle<mirror::Class> klass) REQUIRES_SHARED(Locks::mutator_lock_);
 
diff --git a/runtime/trace_profile.cc b/runtime/trace_profile.cc
new file mode 100644
index 0000000000..c1000d2095
--- /dev/null
+++ b/runtime/trace_profile.cc
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "trace_profile.h"
+
+#include "base/leb128.h"
+#include "base/mutex.h"
+#include "base/unix_file/fd_file.h"
+#include "com_android_art_flags.h"
+#include "runtime.h"
+#include "thread-current-inl.h"
+#include "thread.h"
+#include "thread_list.h"
+#include "trace.h"
+
+namespace art_flags = com::android::art::flags;
+
+namespace art HIDDEN {
+
+// This specifies the maximum number of bits we need for encoding one entry. Each entry just
+// consists of a SLEB encoded value of method and action encodig which is a maximum of
+// sizeof(uintptr_t).
+static constexpr size_t kMaxBytesPerTraceEntry = sizeof(uintptr_t);
+
+// We don't handle buffer overflows when processing the raw trace entries. We have a maximum of
+// kAlwaysOnTraceBufSize raw entries and we need a maximum of kMaxBytesPerTraceEntry to encode
+// each entry. To avoid overflow, we ensure that there are at least kMinBufSizeForEncodedData
+// bytes free space in the buffer.
+static constexpr size_t kMinBufSizeForEncodedData = kAlwaysOnTraceBufSize * kMaxBytesPerTraceEntry;
+
+// TODO(mythria): 10 is a randomly chosen value. Tune it if required.
+static constexpr size_t kBufSizeForEncodedData = kMinBufSizeForEncodedData * 10;
+
+static constexpr size_t kAlwaysOnTraceHeaderSize = 8;
+
+bool TraceProfiler::profile_in_progress_ = false;
+
+void TraceProfiler::Start() {
+  if (!art_flags::always_enable_profile_code()) {
+    LOG(ERROR) << "Feature not supported. Please build with ART_ALWAYS_ENABLE_PROFILE_CODE.";
+    return;
+  }
+
+  Thread* self = Thread::Current();
+  MutexLock mu(self, *Locks::trace_lock_);
+  if (profile_in_progress_) {
+    LOG(ERROR) << "Profile already in progress. Ignoring this request";
+    return;
+  }
+
+  if (Trace::IsTracingEnabledLocked()) {
+    LOG(ERROR) << "Cannot start a profile when method tracing is in progress";
+    return;
+  }
+
+  profile_in_progress_ = true;
+
+  ScopedSuspendAll ssa(__FUNCTION__);
+  MutexLock tl(self, *Locks::thread_list_lock_);
+  for (Thread* thread : Runtime::Current()->GetThreadList()->GetList()) {
+    auto buffer = new uintptr_t[kAlwaysOnTraceBufSize];
+    memset(buffer, 0, kAlwaysOnTraceBufSize * sizeof(uintptr_t));
+    thread->SetMethodTraceBuffer(buffer, kAlwaysOnTraceBufSize);
+  }
+}
+
+void TraceProfiler::Stop() {
+  if (!art_flags::always_enable_profile_code()) {
+    LOG(ERROR) << "Feature not supported. Please build with ART_ALWAYS_ENABLE_PROFILE_CODE.";
+    return;
+  }
+
+  Thread* self = Thread::Current();
+  MutexLock mu(self, *Locks::trace_lock_);
+  if (!profile_in_progress_) {
+    LOG(ERROR) << "No Profile in progress but a stop was requested";
+    return;
+  }
+
+  ScopedSuspendAll ssa(__FUNCTION__);
+  MutexLock tl(self, *Locks::thread_list_lock_);
+  for (Thread* thread : Runtime::Current()->GetThreadList()->GetList()) {
+    auto buffer = thread->GetMethodTraceBuffer();
+    if (buffer != nullptr) {
+      delete[] buffer;
+      thread->SetMethodTraceBuffer(/* buffer= */ nullptr, /* offset= */ 0);
+    }
+  }
+
+  profile_in_progress_ = false;
+}
+
+uint8_t* TraceProfiler::DumpBuffer(uint32_t thread_id,
+                                   uintptr_t* method_trace_entries,
+                                   uint8_t* buffer,
+                                   std::unordered_set<ArtMethod*>& methods) {
+  // Encode header at the end once we compute the number of records.
+  uint8_t* curr_buffer_ptr = buffer + kAlwaysOnTraceHeaderSize;
+
+  int num_records = 0;
+  uintptr_t prev_method_action_encoding = 0;
+  for (size_t i = 0; i < kAlwaysOnTraceBufSize; i++) {
+    uintptr_t method_action_encoding = method_trace_entries[num_records];
+    // 0 value indicates the rest of the entries are empty.
+    if (method_action_encoding == 0) {
+      break;
+    }
+
+    int64_t method_diff = method_action_encoding - prev_method_action_encoding;
+    curr_buffer_ptr = EncodeSignedLeb128(curr_buffer_ptr, method_diff);
+
+    ArtMethod* method = reinterpret_cast<ArtMethod*>(method_action_encoding & kMaskTraceAction);
+    methods.insert(method);
+    num_records++;
+    prev_method_action_encoding = method_action_encoding;
+  }
+
+  // Fill in header information:
+  // 1 byte of header identifier
+  // 4 bytes of thread_id
+  // 3 bytes of number of records
+  buffer[0] = kEntryHeaderV2;
+  Append4LE(buffer + 1, thread_id);
+  Append3LE(buffer + 5, num_records);
+  return curr_buffer_ptr;
+}
+
+void TraceProfiler::Dump(int fd) {
+  if (!art_flags::always_enable_profile_code()) {
+    LOG(ERROR) << "Feature not supported. Please build with ART_ALWAYS_ENABLE_PROFILE_CODE.";
+    return;
+  }
+
+  std::unique_ptr<File> trace_file(new File(fd, /*check_usage=*/true));
+  Dump(std::move(trace_file));
+}
+
+void TraceProfiler::Dump(const char* filename) {
+  if (!art_flags::always_enable_profile_code()) {
+    LOG(ERROR) << "Feature not supported. Please build with ART_ALWAYS_ENABLE_PROFILE_CODE.";
+    return;
+  }
+
+  std::unique_ptr<File> trace_file(OS::CreateEmptyFileWriteOnly(filename));
+  if (trace_file == nullptr) {
+    PLOG(ERROR) << "Unable to open trace file " << filename;
+    return;
+  }
+
+  Dump(std::move(trace_file));
+}
+
+void TraceProfiler::Dump(std::unique_ptr<File>&& trace_file) {
+  Thread* self = Thread::Current();
+  std::unordered_set<ArtMethod*> traced_methods;
+  MutexLock mu(self, *Locks::trace_lock_);
+  if (!profile_in_progress_) {
+    LOG(ERROR) << "No Profile in progress. Nothing to dump.";
+    return;
+  }
+
+  ScopedSuspendAll ssa(__FUNCTION__);
+  MutexLock tl(self, *Locks::thread_list_lock_);
+  uint8_t* buffer_ptr = new uint8_t[kBufSizeForEncodedData];
+  uint8_t* curr_buffer_ptr = buffer_ptr;
+  for (Thread* thread : Runtime::Current()->GetThreadList()->GetList()) {
+    auto method_trace_entries = thread->GetMethodTraceBuffer();
+    if (method_trace_entries == nullptr) {
+      continue;
+    }
+
+    size_t offset = curr_buffer_ptr - buffer_ptr;
+    if (offset >= kMinBufSizeForEncodedData) {
+      if (!trace_file->WriteFully(buffer_ptr, offset)) {
+        PLOG(WARNING) << "Failed streaming a tracing event.";
+      }
+      curr_buffer_ptr = buffer_ptr;
+    }
+    curr_buffer_ptr =
+        DumpBuffer(thread->GetTid(), method_trace_entries, curr_buffer_ptr, traced_methods);
+    // Reset the buffer and continue profiling. We need to set the buffer to
+    // zeroes, since we use a circular buffer and detect empty entries by
+    // checking for zeroes.
+    memset(method_trace_entries, 0, kAlwaysOnTraceBufSize * sizeof(uintptr_t));
+    // Reset the current pointer.
+    thread->SetMethodTraceBufferCurrentEntry(kAlwaysOnTraceBufSize);
+  }
+}
+
+bool TraceProfiler::IsTraceProfileInProgress() {
+  return profile_in_progress_;
+}
+
+}  // namespace art
diff --git a/runtime/trace_profile.h b/runtime/trace_profile.h
new file mode 100644
index 0000000000..7118cd5882
--- /dev/null
+++ b/runtime/trace_profile.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_TRACE_PROFILE_H_
+#define ART_RUNTIME_TRACE_PROFILE_H_
+
+#include <unordered_set>
+
+#include "base/locks.h"
+#include "base/macros.h"
+#include "base/os.h"
+
+namespace art HIDDEN {
+
+class ArtMethod;
+
+// TODO(mythria): A randomly chosen value. Tune it later based on the number of
+// entries required in the buffer.
+static constexpr size_t kAlwaysOnTraceBufSize = 2048;
+
+// This class implements low-overhead tracing. This feature is available only when
+// always_enable_profile_code is enabled which is a build time flag defined in
+// build/flags/art-flags.aconfig. When this flag is enabled, AOT and JITed code can record events
+// on each method execution. When a profile is started, method entry / exit events are recorded in
+// a per-thread circular buffer. When requested the recorded events in the buffer are dumped into a
+// file. The buffers are released when the profile is stopped.
+class TraceProfiler {
+ public:
+  // Starts profiling by allocating a per-thread buffer for all the threads.
+  static void Start();
+
+  // Releases all the buffers.
+  static void Stop();
+
+  // Dumps the recorded events in the buffer from all threads in the specified file.
+  static void Dump(int fd);
+  static void Dump(const char* trace_filename);
+
+  static bool IsTraceProfileInProgress() REQUIRES(Locks::trace_lock_);
+
+ private:
+  // Dumps the events from all threads into the trace_file.
+  static void Dump(std::unique_ptr<File>&& trace_file);
+
+  // This method goes over all the events in the thread_buffer and stores the encoded event in the
+  // buffer. It returns the pointer to the next free entry in the buffer.
+  // This also records the ArtMethods from the events in the thread_buffer in a set. This set is
+  // used to dump the information about the methods once buffers from all threads have been
+  // processed.
+  static uint8_t* DumpBuffer(uint32_t thread_id,
+                             uintptr_t* thread_buffer,
+                             uint8_t* buffer /* out */,
+                             std::unordered_set<ArtMethod*>& methods /* out */);
+
+  static bool profile_in_progress_ GUARDED_BY(Locks::trace_lock_);
+  DISALLOW_COPY_AND_ASSIGN(TraceProfiler);
+};
+
+}  // namespace art
+
+#endif  // ART_RUNTIME_TRACE_PROFILE_H_
diff --git a/runtime/var_handles.cc b/runtime/var_handles.cc
index 872e780612..6040ab303e 100644
--- a/runtime/var_handles.cc
+++ b/runtime/var_handles.cc
@@ -16,6 +16,7 @@
 
 #include "var_handles.h"
 
+#include "art_method.h"
 #include "common_throws.h"
 #include "dex/dex_instruction.h"
 #include "handle.h"
@@ -155,4 +156,79 @@ bool VarHandleInvokeAccessor(Thread* self,
       self, shadow_frame, var_handle, callsite_type, access_mode, operands, result);
 }
 
+bool VarHandleInvokeAccessor(Thread* self,
+                             ShadowFrame& shadow_frame,
+                             Handle<mirror::VarHandle> var_handle,
+                             ArtMethod* caller_method,
+                             const dex::ProtoIndex callsite_type_id,
+                             const mirror::VarHandle::AccessMode access_mode,
+                             const InstructionOperands* const operands,
+                             JValue* result) {
+  StackHandleScope<3> hs(self);
+  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
+
+  Handle<mirror::DexCache> dex_cache = hs.NewHandle(caller_method->GetDexCache());
+  Handle<mirror::ClassLoader> class_loader = hs.NewHandle(caller_method->GetClassLoader());
+
+  // If the `ThreadLocalRandom` class is not yet initialized, do the `VarHandle` operation
+  // without creating a managed `MethodType` object. This avoids a circular initialization
+  // issue when `ThreadLocalRandom.<clinit>` indirectly calls `AtomicLong.compareAndSet()`
+  // (implemented with a `VarHandle`) and the `MethodType` caching circles back to the
+  // `ThreadLocalRandom` with uninitialized `seeder` and throws NPE.
+  //
+  // Do a quick test for "visibly initialized" without a read barrier and, if that fails,
+  // do a thorough test for "initialized" (including load acquire) with the read barrier.
+  ArtField* field = WellKnownClasses::java_util_concurrent_ThreadLocalRandom_seeder;
+  if (LIKELY(field->GetDeclaringClass<kWithoutReadBarrier>()->IsVisiblyInitialized()) ||
+      field->GetDeclaringClass()->IsInitialized()) {
+    Handle<mirror::MethodType> callsite_type(hs.NewHandle(
+        class_linker->ResolveMethodType(self, callsite_type_id, dex_cache, class_loader)));
+
+    if (LIKELY(callsite_type != nullptr)) {
+      return VarHandleInvokeAccessor(self,
+                                     shadow_frame,
+                                     var_handle,
+                                     callsite_type,
+                                     access_mode,
+                                     operands,
+                                     result);
+    }
+    // This implies we couldn't resolve one or more types in this VarHandle,
+    // or we could not allocate the `MethodType` object.
+    CHECK(self->IsExceptionPending());
+    if (self->GetException()->GetClass() != WellKnownClasses::java_lang_OutOfMemoryError.Get()) {
+      return false;
+    }
+    // Clear the OOME and retry without creating an actual `MethodType` object.
+    // This prevents unexpected OOME for trivial `VarHandle` operations.
+    // It also prevents odd situations where a `VarHandle` operation succeeds but the same
+    // operation fails later because the `MethodType` object was evicted from the `DexCache`
+    // and we suddenly run out of memory to allocate a new one.
+    //
+    // We have previously seen OOMEs in the run-test `183-rmw-stress-test` with
+    // `--optimizng --no-image` (boot class path methods run in interpreter without JIT)
+    // but it probably happened on the first execution of a trivial `VarHandle` operation
+    // and not due to the `DexCache` eviction mentioned above.
+    self->ClearException();
+  }
+
+  VariableSizedHandleScope callsite_type_hs(self);
+  mirror::RawMethodType callsite_type(&callsite_type_hs);
+  if (!class_linker->ResolveMethodType(self,
+                                       callsite_type_id,
+                                       dex_cache,
+                                       class_loader,
+                                       callsite_type)) {
+    CHECK(self->IsExceptionPending());
+    return false;
+  }
+  return VarHandleInvokeAccessor(self,
+                                 shadow_frame,
+                                 var_handle,
+                                 callsite_type,
+                                 access_mode,
+                                 operands,
+                                 result);
+}
+
 }  // namespace art
diff --git a/runtime/var_handles.h b/runtime/var_handles.h
index 82056ca153..d056d16ab6 100644
--- a/runtime/var_handles.h
+++ b/runtime/var_handles.h
@@ -18,6 +18,10 @@
 #define ART_RUNTIME_VAR_HANDLES_H_
 
 #include "base/macros.h"
+#include "dex/dex_file_types.h"
+#include "dex/dex_instruction.h"
+#include "interpreter/shadow_frame.h"
+#include "jvalue.h"
 #include "mirror/var_handle.h"
 
 namespace art HIDDEN {
@@ -44,6 +48,16 @@ bool VarHandleInvokeAccessor(Thread* self,
                              JValue* result)
     REQUIRES_SHARED(Locks::mutator_lock_);
 
+bool VarHandleInvokeAccessor(Thread* self,
+                             ShadowFrame& shadow_frame,
+                             Handle<mirror::VarHandle> var_handle,
+                             ArtMethod* caller_method,
+                             const dex::ProtoIndex callsite_type,
+                             const mirror::VarHandle::AccessMode access_mode,
+                             const InstructionOperands* const operands,
+                             JValue* result)
+    REQUIRES_SHARED(Locks::mutator_lock_);
+
 }  // namespace art
 
 #endif  // ART_RUNTIME_VAR_HANDLES_H_
diff --git a/runtime/verifier/method_verifier.cc b/runtime/verifier/method_verifier.cc
index 383785387a..fccb60b3e6 100644
--- a/runtime/verifier/method_verifier.cc
+++ b/runtime/verifier/method_verifier.cc
@@ -4311,6 +4311,10 @@ void MethodVerifier<kVerifierDebug>::VerifyNewArray(const Instruction* inst,
       for (size_t ui = 0; ui < arg_count; ui++) {
         uint32_t get_reg = is_range ? inst->VRegC_3rc() + ui : arg[ui];
         work_line_->VerifyRegisterType(this, get_reg, expected_type);
+        if (flags_.have_pending_hard_failure_) {
+          // Don't continue on hard failures.
+          return;
+        }
       }
       // filled-array result goes into "result" register
       const RegType& precise_type = reg_types_.FromUninitialized(res_type);
diff --git a/runtime/well_known_classes.cc b/runtime/well_known_classes.cc
index cd2d8a4ea3..5c1d9e9da0 100644
--- a/runtime/well_known_classes.cc
+++ b/runtime/well_known_classes.cc
@@ -95,6 +95,7 @@ ArtMethod* WellKnownClasses::java_lang_ThreadGroup_add;
 ArtMethod* WellKnownClasses::java_lang_ThreadGroup_threadTerminated;
 ArtMethod* WellKnownClasses::java_lang_invoke_MethodHandle_asType;
 ArtMethod* WellKnownClasses::java_lang_invoke_MethodHandle_invokeExact;
+ArtMethod* WellKnownClasses::java_lang_invoke_MethodHandleImpl_init;
 ArtMethod* WellKnownClasses::java_lang_invoke_MethodHandles_lookup;
 ArtMethod* WellKnownClasses::java_lang_invoke_MethodHandles_makeIdentity;
 ArtMethod* WellKnownClasses::java_lang_invoke_MethodHandles_Lookup_findConstructor;
@@ -417,7 +418,7 @@ void WellKnownClasses::InitFieldsAndMethodsOnly(JNIEnv* env) {
   java_lang_Long_value = CacheValueInBoxField(
       class_linker, self, "Ljava/lang/Long;", "J");
 
-  StackHandleScope<44u> hs(self);
+  StackHandleScope<45u> hs(self);
   Handle<mirror::Class> d_s_bdcl =
       hs.NewHandle(FindSystemClass(class_linker, self, "Ldalvik/system/BaseDexClassLoader;"));
   Handle<mirror::Class> d_s_dlcl =
@@ -464,6 +465,8 @@ void WellKnownClasses::InitFieldsAndMethodsOnly(JNIEnv* env) {
       hs.NewHandle(FindSystemClass(class_linker, self, "Ljava/lang/ThreadGroup;"));
   Handle<mirror::Class> j_l_i_MethodHandle =
       hs.NewHandle(FindSystemClass(class_linker, self, "Ljava/lang/invoke/MethodHandle;"));
+  Handle<mirror::Class> j_l_i_MethodHandleImpl =
+      hs.NewHandle(FindSystemClass(class_linker, self, "Ljava/lang/invoke/MethodHandleImpl;"));
   Handle<mirror::Class> j_l_i_MethodHandles =
       hs.NewHandle(FindSystemClass(class_linker, self, "Ljava/lang/invoke/MethodHandles;"));
   Handle<mirror::Class> j_l_i_MethodHandles_Lookup =
@@ -630,6 +633,12 @@ void WellKnownClasses::InitFieldsAndMethodsOnly(JNIEnv* env) {
       "invokeExact",
       "([Ljava/lang/Object;)Ljava/lang/Object;",
       pointer_size);
+  java_lang_invoke_MethodHandleImpl_init = CacheMethod(
+      j_l_i_MethodHandleImpl.Get(),
+      /*is_static=*/ false,
+      "<init>",
+      "(JILjava/lang/invoke/MethodType;)V",
+      pointer_size);
   java_lang_invoke_MethodHandles_lookup = CacheMethod(
       j_l_i_MethodHandles.Get(),
       /*is_static=*/ true,
@@ -923,6 +932,7 @@ void WellKnownClasses::Clear() {
   java_lang_ThreadGroup_threadTerminated = nullptr;
   java_lang_invoke_MethodHandle_asType = nullptr;
   java_lang_invoke_MethodHandle_invokeExact = nullptr;
+  java_lang_invoke_MethodHandleImpl_init = nullptr;
   java_lang_invoke_MethodHandles_lookup = nullptr;
   java_lang_invoke_MethodHandles_makeIdentity = nullptr;
   java_lang_invoke_MethodHandles_Lookup_findConstructor = nullptr;
diff --git a/runtime/well_known_classes.h b/runtime/well_known_classes.h
index bd8bbe0108..6d5c9781ef 100644
--- a/runtime/well_known_classes.h
+++ b/runtime/well_known_classes.h
@@ -141,6 +141,7 @@ struct EXPORT WellKnownClasses {
   static ArtMethod* java_lang_ThreadGroup_threadTerminated;
   static ArtMethod* java_lang_invoke_MethodHandle_asType;
   static ArtMethod* java_lang_invoke_MethodHandle_invokeExact;
+  static ArtMethod* java_lang_invoke_MethodHandleImpl_init;
   static ArtMethod* java_lang_invoke_MethodHandles_lookup;
   static ArtMethod* java_lang_invoke_MethodHandles_makeIdentity;
   static ArtMethod* java_lang_invoke_MethodHandles_Lookup_findConstructor;
@@ -251,6 +252,10 @@ struct EXPORT WellKnownClasses {
       java_lang_StackOverflowError;
   static constexpr ClassFromField<&java_lang_Thread_daemon> java_lang_Thread;
   static constexpr ClassFromField<&java_lang_ThreadGroup_groups> java_lang_ThreadGroup;
+  static constexpr ClassFromMethod<&java_lang_invoke_MethodHandle_invokeExact>
+      java_lang_invoke_MethodHandle;
+  static constexpr ClassFromMethod<&java_lang_invoke_MethodType_makeImpl>
+      java_lang_invoke_MethodType;
   static constexpr ClassFromMethod<&java_lang_reflect_InvocationTargetException_init>
       java_lang_reflect_InvocationTargetException;
   static constexpr ClassFromMethod<&java_lang_reflect_Parameter_init>
diff --git a/simulator/code_simulator_arm64.h b/simulator/code_simulator_arm64.h
index e726500452..dee6b32c34 100644
--- a/simulator/code_simulator_arm64.h
+++ b/simulator/code_simulator_arm64.h
@@ -19,9 +19,10 @@
 
 #include "memory"
 
-// TODO(VIXL): Make VIXL compile with -Wshadow.
+// TODO(VIXL): Make VIXL compile cleanly with -Wshadow, -Wdeprecated-declarations.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
 #include "aarch64/simulator-aarch64.h"
 #pragma GCC diagnostic pop
 
diff --git a/test/011-array-copy2/Android.bp b/test/011-array-copy2/Android.bp
new file mode 100644
index 0000000000..d223d7ea61
--- /dev/null
+++ b/test/011-array-copy2/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `011-array-copy2`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-011-array-copy2",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-011-array-copy2-expected-stdout",
+        ":art-run-test-011-array-copy2-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-011-array-copy2-expected-stdout",
+    out: ["art-run-test-011-array-copy2-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-011-array-copy2-expected-stderr",
+    out: ["art-run-test-011-array-copy2-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2239-varhandle-perf/expected-stderr.txt b/test/011-array-copy2/expected-stderr.txt
similarity index 100%
rename from test/2239-varhandle-perf/expected-stderr.txt
rename to test/011-array-copy2/expected-stderr.txt
diff --git a/test/011-array-copy2/expected-stdout.txt b/test/011-array-copy2/expected-stdout.txt
new file mode 100644
index 0000000000..203323f75a
--- /dev/null
+++ b/test/011-array-copy2/expected-stdout.txt
@@ -0,0 +1,3 @@
+[ByteArrayTests]: passed
+[CharArrayTests]: passed
+[IntArrayTests]: passed
diff --git a/test/011-array-copy2/info.txt b/test/011-array-copy2/info.txt
new file mode 100644
index 0000000000..540486c134
--- /dev/null
+++ b/test/011-array-copy2/info.txt
@@ -0,0 +1 @@
+Test additional corner cases of SystemArrayCopy.
diff --git a/test/011-array-copy2/src/Main.java b/test/011-array-copy2/src/Main.java
new file mode 100644
index 0000000000..fd8f9a1451
--- /dev/null
+++ b/test/011-array-copy2/src/Main.java
@@ -0,0 +1,483 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class Main {
+
+    private static class ByteArrayTests {
+        public static byte[] init(byte[] arr) {
+            for (byte i = 0; i < arr.length; i++) {
+                arr[i] = (byte) i;
+            }
+            return arr;
+        }
+
+        public static void assertEquals(int expected, int actual) {
+            if (expected != actual) {
+                throw new Error("Expected " + expected + ", got " + actual);
+            }
+        }
+
+        public static byte[] createArrayOfZeroes(int size) {
+            byte[] arr = new byte[size];
+            return arr;
+        }
+
+        public static byte[] createIncrementedArray(int size) {
+            byte[] arr = new byte[size];
+            init(arr);
+            return arr;
+        }
+
+        public static void checkIncrementedArray(byte[] dst) {
+            for (byte i = 0; i < dst.length; i++) {
+                assertEquals(i, dst[i]);
+            }
+        }
+
+        public static void $noinline$test1(byte[] src, byte[] dst) {
+            System.arraycopy(src, 0, dst, 0, 15);
+        }
+
+        public static void $noinline$test2(byte[] src, byte[] dst) {
+            System.arraycopy(src, 0, dst, 0, 127);
+        }
+
+        public static byte[] $noinline$test3() {
+            byte size = 15;
+            byte[] src = new byte[size];
+            src = init(src);
+            byte[] dst = new byte[size];
+
+            System.arraycopy(src, 0, dst, 0, size);
+            return dst;
+        }
+
+        public static byte[] $noinline$test4() {
+            int size = 127;
+            byte[] src = new byte[size];
+            src = init(src);
+            byte[] dst = new byte[size];
+
+            System.arraycopy(src, 0, dst, 0, size);
+            return dst;
+        }
+
+        public static byte[] $noinline$test5() {
+            byte[] src = new byte[80];
+            src = init(src);
+            byte[] dst = new byte[80];
+
+            System.arraycopy(src, 0, dst, 0, 80);
+            return dst;
+        }
+
+        public static byte[] $noinline$test6() {
+            byte[] src = new byte[127];
+            src = init(src);
+            byte[] dst = new byte[127];
+
+            System.arraycopy(src, 0, dst, 100, 27);
+            return dst;
+        }
+        public static void check6(byte[] dst) {
+            for (byte i = 0; i < 100; i++) {
+                assertEquals(0, dst[i]);
+            }
+            for (byte i = 100; i < 127; i++) {
+                assertEquals(i - 100, dst[i]);
+            }
+        }
+
+        public static byte[] $noinline$test7() {
+            byte[] src = new byte[127];
+            src = init(src);
+
+            System.arraycopy(src, 0, src, 100, 27);
+            return src;
+        }
+        public static void check7(byte[] dst) {
+            for (byte i = 0; i < 100; i++) {
+                assertEquals(i, dst[i]);
+            }
+            for (byte i = 100; i < 127; i++) {
+                assertEquals(i - 100, dst[i]);
+            }
+        }
+
+        public static byte[] $noinline$test8() {
+            byte[] src = new byte[127];
+            src = init(src);
+
+            System.arraycopy(src, 100, src, 0, 27);
+            return src;
+        }
+        public static void check8(byte[] dst) {
+            for (byte i = 0; i < 27; i++) {
+                assertEquals(100 + i, dst[i]);
+            }
+            for (byte i = 27; i < 127; i++) {
+                assertEquals(i, dst[i]);
+            }
+        }
+
+        public static void $noinline$test9(byte[] src, byte[] dst, byte i) {
+            System.arraycopy(src, 0, dst, 0, i);
+        }
+
+        public static void runTests() {
+            System.out.print("[ByteArrayTests]: ");
+
+            byte[] src15 = createIncrementedArray(15);
+            byte[] dst15 = createArrayOfZeroes(15);
+            $noinline$test1(src15, dst15);
+            checkIncrementedArray(dst15);
+
+            byte[] src150 = createIncrementedArray(127);
+            byte[] dst150 = createArrayOfZeroes(127);
+            $noinline$test2(src150, dst150);
+            checkIncrementedArray(dst150);
+
+            checkIncrementedArray($noinline$test3());
+            checkIncrementedArray($noinline$test4());
+            checkIncrementedArray($noinline$test5());
+
+            check6($noinline$test6());
+            check7($noinline$test7());
+            check8($noinline$test8());
+
+            for (byte i = 1; i < 127; i++) {
+                byte[] src = createIncrementedArray(i);
+                byte[] dst = createArrayOfZeroes(i);
+                $noinline$test9(src, dst, i);
+                checkIncrementedArray(dst);
+            }
+            System.out.println("passed");
+        }
+    }
+
+    private static class CharArrayTests {
+
+        public static char[] init(char[] arr) {
+            for (int i = 0; i < arr.length; i++) {
+                arr[i] = (char) i;
+            }
+            return arr;
+        }
+
+        public static void assertEquals(int expected, int actual) {
+            if (expected != actual) {
+                throw new Error("Expected " + expected + ", got " + actual);
+            }
+        }
+
+        public static char[] createArrayOfZeroes(int size) {
+            char[] arr = new char[size];
+            return arr;
+        }
+
+        public static char[] createIncrementedArray(int size) {
+            char[] arr = new char[size];
+            init(arr);
+            return arr;
+        }
+
+        public static void checkIncrementedArray(char[] dst) {
+            for (int i = 0; i < dst.length; i++) {
+                assertEquals(i, dst[i]);
+            }
+        }
+
+        public static void $noinline$test1(char[] src, char[] dst) {
+            System.arraycopy(src, 0, dst, 0, 15);
+        }
+
+        public static void $noinline$test2(char[] src, char[] dst) {
+            System.arraycopy(src, 0, dst, 0, 150);
+        }
+
+        public static char[] $noinline$test3() {
+            int size = 15;
+            char[] src = new char[size];
+            src = init(src);
+            char[] dst = new char[size];
+
+            System.arraycopy(src, 0, dst, 0, size);
+            return dst;
+        }
+
+        public static char[] $noinline$test4() {
+            int size = 150;
+            char[] src = new char[size];
+            src = init(src);
+            char[] dst = new char[size];
+
+            System.arraycopy(src, 0, dst, 0, size);
+            return dst;
+        }
+
+        public static char[] $noinline$test5() {
+            char[] src = new char[80];
+            src = init(src);
+            char[] dst = new char[80];
+
+            System.arraycopy(src, 0, dst, 0, 80);
+            return dst;
+        }
+
+        public static char[] $noinline$test6() {
+            char[] src = new char[150];
+            src = init(src);
+            char[] dst = new char[150];
+
+            System.arraycopy(src, 0, dst, 100, 50);
+            return dst;
+        }
+        public static void check6(char[] dst) {
+            for (int i = 0; i < 100; i++) {
+                assertEquals(0, dst[i]);
+            }
+            for (int i = 100; i < 150; i++) {
+                assertEquals(i-100, dst[i]);
+            }
+        }
+
+        public static char[] $noinline$test7() {
+            char[] src = new char[150];
+            src = init(src);
+
+            System.arraycopy(src, 0, src, 100, 50);
+            return src;
+        }
+        public static void check7(char[] dst) {
+            for (int i = 0; i < 100; i++) {
+                assertEquals(i, dst[i]);
+            }
+            for (int i = 100; i < 150; i++) {
+                assertEquals(i - 100, dst[i]);
+            }
+        }
+
+        public static char[] $noinline$test8() {
+            char[] src = new char[150];
+            src = init(src);
+
+            System.arraycopy(src, 100, src, 0, 50);
+            return src;
+        }
+        public static void check8(char[] dst) {
+            for (int i = 0; i < 50; i++) {
+                assertEquals(100 + i, dst[i]);
+            }
+            for (int i = 50; i < 150; i++) {
+                assertEquals(i, dst[i]);
+            }
+        }
+
+        public static void $noinline$test9(char[] src, char[] dst, int i) {
+            System.arraycopy(src, 0, dst, 0, i);
+        }
+
+        public static void runTests() {
+            System.out.print("[CharArrayTests]: ");
+
+            char[] src15 = createIncrementedArray(15);
+            char[] dst15 = createArrayOfZeroes(15);
+            $noinline$test1(src15, dst15);
+            checkIncrementedArray(dst15);
+
+            char[] src150 = createIncrementedArray(150);
+            char[] dst150 = createArrayOfZeroes(150);
+            $noinline$test2(src150, dst150);
+            checkIncrementedArray(dst150);
+
+            checkIncrementedArray($noinline$test3());
+            checkIncrementedArray($noinline$test4());
+            checkIncrementedArray($noinline$test5());
+
+            check6($noinline$test6());
+            check7($noinline$test7());
+            check8($noinline$test8());
+
+            for (int i = 1; i < 256; i++) {
+                char[] src = createIncrementedArray(i);
+                char[] dst = createArrayOfZeroes(i);
+                $noinline$test9(src, dst, i);
+                checkIncrementedArray(dst);
+            }
+
+            System.out.println("passed");
+        }
+    }
+
+    private static class IntArrayTests {
+        public static int[] init(int[] arr) {
+            for (int i = 0; i < arr.length; i++) {
+                arr[i] = (int) i;
+            }
+            return arr;
+        }
+
+        public static void assertEquals(int expected, int actual) {
+            if (expected != actual) {
+                throw new Error("Expected " + expected + ", got " + actual);
+            }
+        }
+
+        public static int[] createArrayOfZeroes(int size) {
+            int[] arr = new int[size];
+            return arr;
+        }
+
+        public static int[] createIncrementedArray(int size) {
+            int[] arr = new int[size];
+            init(arr);
+            return arr;
+        }
+
+        public static void checkIncrementedArray(int[] dst) {
+            for (int i = 0; i < dst.length; i++) {
+                assertEquals(i, dst[i]);
+            }
+        }
+
+        public static void $noinline$test1(int[] src, int[] dst) {
+            System.arraycopy(src, 0, dst, 0, 15);
+        }
+
+        public static void $noinline$test2(int[] src, int[] dst) {
+            System.arraycopy(src, 0, dst, 0, 150);
+        }
+
+        public static int[] $noinline$test3() {
+            int size = 15;
+            int[] src = new int[size];
+            src = init(src);
+            int[] dst = new int[size];
+
+            System.arraycopy(src, 0, dst, 0, size);
+            return dst;
+        }
+
+        public static int[] $noinline$test4() {
+            int size = 150;
+            int[] src = new int[size];
+            src = init(src);
+            int[] dst = new int[size];
+
+            System.arraycopy(src, 0, dst, 0, size);
+            return dst;
+        }
+
+        public static int[] $noinline$test5() {
+            int[] src = new int[80];
+            src = init(src);
+            int[] dst = new int[80];
+
+            System.arraycopy(src, 0, dst, 0, 80);
+            return dst;
+        }
+
+        public static int[] $noinline$test6() {
+            int[] src = new int[150];
+            src = init(src);
+            int[] dst = new int[150];
+
+            System.arraycopy(src, 0, dst, 100, 50);
+            return dst;
+        }
+        public static void check6(int[] dst) {
+            for (int i = 0; i < 100; i++) {
+                assertEquals(0, dst[i]);
+            }
+            for (int i = 100; i < 150; i++) {
+                assertEquals(i-100, dst[i]);
+            }
+        }
+
+        public static int[] $noinline$test7() {
+            int[] src = new int[150];
+            src = init(src);
+
+            System.arraycopy(src, 0, src, 100, 50);
+            return src;
+        }
+        public static void check7(int[] dst) {
+            for (int i = 0; i < 100; i++) {
+                assertEquals(i, dst[i]);
+            }
+            for (int i = 100; i < 150; i++) {
+                assertEquals(i - 100, dst[i]);
+            }
+        }
+
+        public static int[] $noinline$test8() {
+            int[] src = new int[150];
+            src = init(src);
+
+            System.arraycopy(src, 100, src, 0, 50);
+            return src;
+        }
+        public static void check8(int[] dst) {
+            for (int i = 0; i < 50; i++) {
+                assertEquals(100 + i, dst[i]);
+            }
+            for (int i = 50; i < 150; i++) {
+                assertEquals(i, dst[i]);
+            }
+        }
+
+        public static void $noinline$test9(int[] src, int[] dst, int i) {
+            System.arraycopy(src, 0, dst, 0, i);
+        }
+
+        public static void runTests() {
+            System.out.print("[IntArrayTests]: ");
+
+            int[] src15 = createIncrementedArray(15);
+            int[] dst15 = createArrayOfZeroes(15);
+            $noinline$test1(src15, dst15);
+            checkIncrementedArray(dst15);
+
+            int[] src150 = createIncrementedArray(150);
+            int[] dst150 = createArrayOfZeroes(150);
+            $noinline$test2(src150, dst150);
+            checkIncrementedArray(dst150);
+
+            checkIncrementedArray($noinline$test3());
+            checkIncrementedArray($noinline$test4());
+            checkIncrementedArray($noinline$test5());
+
+            check6($noinline$test6());
+            check7($noinline$test7());
+            check8($noinline$test8());
+
+            for (int i = 1; i < 256; i++) {
+                int[] src = createIncrementedArray(i);
+                int[] dst = createArrayOfZeroes(i);
+                $noinline$test9(src, dst, i);
+                checkIncrementedArray(dst);
+            }
+
+            System.out.println("passed");
+        }
+    }
+
+    public static void main(String[] args) {
+        ByteArrayTests.runTests();
+        CharArrayTests.runTests();
+        IntArrayTests.runTests();
+    }
+}
diff --git a/test/057-math-intrinsics/Android.bp b/test/057-math-intrinsics/Android.bp
new file mode 100644
index 0000000000..a48b868e95
--- /dev/null
+++ b/test/057-math-intrinsics/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `057-math-intrinsics`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-057-math-intrinsics",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-057-math-intrinsics-expected-stdout",
+        ":art-run-test-057-math-intrinsics-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-057-math-intrinsics-expected-stdout",
+    out: ["art-run-test-057-math-intrinsics-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-057-math-intrinsics-expected-stderr",
+    out: ["art-run-test-057-math-intrinsics-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2269-checker-constant-folding-instrinsics/expected-stderr.txt b/test/057-math-intrinsics/expected-stderr.txt
similarity index 100%
rename from test/2269-checker-constant-folding-instrinsics/expected-stderr.txt
rename to test/057-math-intrinsics/expected-stderr.txt
diff --git a/test/2239-varhandle-perf/expected-stdout.txt b/test/057-math-intrinsics/expected-stdout.txt
similarity index 100%
rename from test/2239-varhandle-perf/expected-stdout.txt
rename to test/057-math-intrinsics/expected-stdout.txt
diff --git a/test/057-math-intrinsics/info.txt b/test/057-math-intrinsics/info.txt
new file mode 100644
index 0000000000..f96b45f6f7
--- /dev/null
+++ b/test/057-math-intrinsics/info.txt
@@ -0,0 +1,3 @@
+Tests for math intrinsics:
+  - signum {float|double},
+  - copySign {float|double}.
diff --git a/test/057-math-intrinsics/src/CopySignTest.java b/test/057-math-intrinsics/src/CopySignTest.java
new file mode 100644
index 0000000000..3f7d6ecfe2
--- /dev/null
+++ b/test/057-math-intrinsics/src/CopySignTest.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Note that $opt$ is a marker for the optimizing compiler to test
+// it does compile the method, and that $noinline$ is a marker to
+// test that it does not inline it.
+
+public class CopySignTest {
+
+  public static void main() {
+    copySignFloat();
+    copySignDouble();
+  }
+
+  private static float $opt$noinline$copySignFloat(float a, float b) {
+    return Math.copySign(a, b);
+  }
+
+  private static void copySignFloat() {
+    float testCases [][] = {
+      { +0.0f,
+         Float.MIN_VALUE,
+         0x0.fffffcP-126f,
+         0x0.fffffeP-126f,
+         Float.MIN_NORMAL,
+         1.0f,
+         3.0f,
+         0x1.fffffcP+127f,
+         Float.MAX_VALUE,
+         Float.POSITIVE_INFINITY,
+         Float.NaN
+      },
+      {  Float.NEGATIVE_INFINITY,
+        -Float.MAX_VALUE,
+        -3.0f,
+        -1.0f,
+        -Float.MIN_NORMAL,
+        -0x0.fffffcP-126f,
+        -0x0.fffffeP-126f,
+        -Float.MIN_VALUE,
+        -0.0f,
+         Float.intBitsToFloat(0xFFC00000),  // "negative" NaN
+        -0x1.fffffcP+127f
+      }
+    };
+
+    for (int i = 0; i < 2; i++) {
+      for (int j = 0; j < 2; j++) {
+        for (int m = 0; m < testCases[i].length; m++) {
+          for (int n = 0; n < testCases[j].length; n++) {
+            float expected = (j == 0 ? 1.0f : -1.0f) * Math.abs(testCases[i][m]);
+
+            float calculated = Math.copySign(testCases[i][m], testCases[j][n]);
+            if (Float.isNaN(testCases[i][m])) {
+              assertEquals(calculated, Float.NaN);
+            } else if (Float.isNaN(testCases[j][n])) {
+              assertEquals(Math.abs(calculated), Math.abs(testCases[i][m]));
+            } else {
+              assertEquals(calculated, expected);
+            }
+
+            calculated = $opt$noinline$copySignFloat(testCases[i][m], testCases[j][n]);
+            if (Float.isNaN(testCases[i][m])) {
+              assertEquals(calculated, Float.NaN);
+            } else if (Float.isNaN(testCases[j][n])) {
+              assertEquals(Math.abs(calculated), Math.abs(testCases[i][m]));
+            } else {
+              assertEquals(calculated, expected);
+            }
+          }
+        }
+      }
+    }
+  }
+
+  private static double $opt$noinline$copySignDouble(double a, double b) {
+    return Math.copySign(a, b);
+  }
+
+  private static void copySignDouble() {
+    double testCases [][] = {
+      { +0.0d,
+         Double.MIN_VALUE,
+         0x0.ffffffffffffeP-1022,
+         0x0.fffffffffffffP-1022,
+         Double.MIN_NORMAL,
+         1.0d,
+         3.0d,
+         0x1.ffffffffffffeP+1023,
+         Double.MAX_VALUE,
+         Double.POSITIVE_INFINITY,
+         Double.NaN
+      },
+      {  Double.NEGATIVE_INFINITY,
+        -Double.MAX_VALUE,
+        -3.0d,
+        -1.0d,
+        -Double.MIN_NORMAL,
+        -0x0.ffffffffffffeP-1022,
+        -0x0.fffffffffffffP-1022,
+        -Double.MIN_VALUE,
+        -0.0d,
+         Double.longBitsToDouble(0xfff8000000000000L),  // "negative" NaN
+        -0x1.ffffffffffffeP+1023
+      }
+    };
+
+    for (int i = 0; i < 2; i++) {
+      for (int j = 0; j < 2; j++) {
+        for (int m = 0; m < testCases[i].length; m++) {
+          for (int n = 0; n < testCases[j].length; n++) {
+            double expected = (j == 0 ? 1.0f : -1.0f) * Math.abs(testCases[i][m]);
+
+            double calculated = Math.copySign(testCases[i][m], testCases[j][n]);
+            if (Double.isNaN(testCases[i][m])) {
+              assertEquals(calculated, Double.NaN);
+            } else if (Double.isNaN(testCases[j][n])) {
+              assertEquals(Math.abs(calculated), Math.abs(testCases[i][m]));
+            } else {
+              assertEquals(calculated, expected);
+            }
+
+            calculated = $opt$noinline$copySignDouble(testCases[i][m], testCases[j][n]);
+            if (Double.isNaN(testCases[i][m])) {
+              assertEquals(calculated, Double.NaN);
+            } else if (Double.isNaN(testCases[j][n])) {
+              assertEquals(Math.abs(calculated), Math.abs(testCases[i][m]));
+            } else {
+              assertEquals(calculated, expected);
+            }
+          }
+        }
+      }
+    }
+  }
+
+  private static void assertEquals(float calculated, float expected) {
+    if (0 != Float.compare(calculated, expected)) {
+      throw new Error("Expected: " + expected + ", found: " + calculated);
+    }
+  }
+
+  private static void assertEquals(double calculated, double expected) {
+    if (0 != Double.compare(calculated, expected)) {
+      throw new Error("Expected: " + expected + ", found: " + calculated);
+    }
+  }
+
+}
diff --git a/test/057-math-intrinsics/src/Main.java b/test/057-math-intrinsics/src/Main.java
new file mode 100644
index 0000000000..32f90ef79e
--- /dev/null
+++ b/test/057-math-intrinsics/src/Main.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+  public static void main(String args[]) {
+    SignumTest.main();
+    CopySignTest.main();
+  }
+}
diff --git a/test/057-math-intrinsics/src/SignumTest.java b/test/057-math-intrinsics/src/SignumTest.java
new file mode 100644
index 0000000000..eff200bc51
--- /dev/null
+++ b/test/057-math-intrinsics/src/SignumTest.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Note that $opt$ is a marker for the optimizing compiler to test
+// it does compile the method, and that $noinline$ is a marker to
+// test that it does not inline it.
+
+public class SignumTest {
+
+  public static void main() {
+    signumFloat();
+    signumFloat_noinline();
+    signumDouble();
+    signumDouble_noinline();
+  }
+
+  private static void signumFloat() {
+    assertEquals(Math.signum(123.4f), 1.0f);
+    assertEquals(Math.signum(-56.7f), -1.0f);
+    assertEquals(Math.signum(7e30f), 1.0f);
+    assertEquals(Math.signum(-0.3e30f), -1.0f);
+    assertEquals(Math.signum(Float.MAX_VALUE), 1.0f);
+    assertEquals(Math.signum(-Float.MAX_VALUE), -1.0f);
+    assertEquals(Math.signum(Float.MIN_VALUE), 1.0f);
+    assertEquals(Math.signum(-Float.MIN_VALUE), -1.0f);
+    assertEquals(Math.signum(0.0f), 0.0f);
+    assertEquals(Math.signum(-0.0f), -0.0f);
+    assertEquals(Math.signum(Float.POSITIVE_INFINITY), 1.0f);
+    assertEquals(Math.signum(Float.NEGATIVE_INFINITY), -1.0f);
+    assertEquals(Math.signum(Float.NaN), Float.NaN);
+    assertEquals(Math.signum(Float.MIN_NORMAL), 1.0f);
+    assertEquals(Math.signum(-Float.MIN_NORMAL), -1.0f);
+    assertEquals(Math.signum(0x0.0002P-126f), 1.0f);
+    assertEquals(Math.signum(-0x0.0002P-126f), -1.0f);
+  }
+
+  private static float $opt$noinline$signumFloat(float a) {
+    return Math.signum(a);
+  }
+
+  private static void signumFloat_noinline() {
+    assertEquals($opt$noinline$signumFloat(123.4f), 1.0f);
+    assertEquals($opt$noinline$signumFloat(-56.7f), -1.0f);
+    assertEquals($opt$noinline$signumFloat(7e30f), 1.0f);
+    assertEquals($opt$noinline$signumFloat(-0.3e30f), -1.0f);
+    assertEquals($opt$noinline$signumFloat(Float.MAX_VALUE), 1.0f);
+    assertEquals($opt$noinline$signumFloat(-Float.MAX_VALUE), -1.0f);
+    assertEquals($opt$noinline$signumFloat(Float.MIN_VALUE), 1.0f);
+    assertEquals($opt$noinline$signumFloat(-Float.MIN_VALUE), -1.0f);
+    assertEquals($opt$noinline$signumFloat(0.0f), 0.0f);
+    assertEquals($opt$noinline$signumFloat(-0.0f), -0.0f);
+    assertEquals($opt$noinline$signumFloat(Float.POSITIVE_INFINITY), 1.0f);
+    assertEquals($opt$noinline$signumFloat(Float.NEGATIVE_INFINITY), -1.0f);
+    assertEquals($opt$noinline$signumFloat(Float.NaN), Float.NaN);
+    assertEquals($opt$noinline$signumFloat(Float.MIN_NORMAL), 1.0f);
+    assertEquals($opt$noinline$signumFloat(-Float.MIN_NORMAL), -1.0f);
+    assertEquals($opt$noinline$signumFloat(0x0.0002P-126f), 1.0f);
+    assertEquals($opt$noinline$signumFloat(-0x0.0002P-126f), -1.0f);
+  }
+
+  private static void signumDouble() {
+    assertEquals(Math.signum(123.4d), 1.0d);
+    assertEquals(Math.signum(-56.7d), -1.0d);
+    assertEquals(Math.signum(7e30d), 1.0d);
+    assertEquals(Math.signum(-0.3e30d), -1.0d);
+    assertEquals(Math.signum(Double.MAX_VALUE), 1.0d);
+    assertEquals(Math.signum(-Double.MAX_VALUE), -1.0d);
+    assertEquals(Math.signum(Double.MIN_VALUE), 1.0d);
+    assertEquals(Math.signum(-Double.MIN_VALUE), -1.0d);
+    assertEquals(Math.signum(0.0d), 0.0d);
+    assertEquals(Math.signum(-0.0d), -0.0d);
+    assertEquals(Math.signum(Double.POSITIVE_INFINITY), 1.0d);
+    assertEquals(Math.signum(Double.NEGATIVE_INFINITY), -1.0d);
+    assertEquals(Math.signum(Double.NaN), Double.NaN);
+    assertEquals(Math.signum(Double.MIN_NORMAL), 1.0d);
+    assertEquals(Math.signum(-Double.MIN_NORMAL), -1.0d);
+    assertEquals(Math.signum(0x0.00000001P-1022), 1.0d);
+    assertEquals(Math.signum(-0x0.00000001P-1022), -1.0d);
+  }
+
+  private static double $opt$noinline$signumDouble(double a) {
+    return Math.signum(a);
+  }
+
+  private static void signumDouble_noinline() {
+    assertEquals($opt$noinline$signumDouble(123.4d), 1.0d);
+    assertEquals($opt$noinline$signumDouble(-56.7d), -1.0d);
+    assertEquals($opt$noinline$signumDouble(7e30d), 1.0d);
+    assertEquals($opt$noinline$signumDouble(-0.3e30d), -1.0d);
+    assertEquals($opt$noinline$signumDouble(Double.MAX_VALUE), 1.0d);
+    assertEquals($opt$noinline$signumDouble(-Double.MAX_VALUE), -1.0d);
+    assertEquals($opt$noinline$signumDouble(Double.MIN_VALUE), 1.0d);
+    assertEquals($opt$noinline$signumDouble(-Double.MIN_VALUE), -1.0d);
+    assertEquals($opt$noinline$signumDouble(0.0d), 0.0d);
+    assertEquals($opt$noinline$signumDouble(-0.0d), -0.0d);
+    assertEquals($opt$noinline$signumDouble(Double.POSITIVE_INFINITY), 1.0d);
+    assertEquals($opt$noinline$signumDouble(Double.NEGATIVE_INFINITY), -1.0d);
+    assertEquals($opt$noinline$signumDouble(Double.NaN), Double.NaN);
+    assertEquals($opt$noinline$signumDouble(Double.MIN_NORMAL), 1.0d);
+    assertEquals($opt$noinline$signumDouble(-Double.MIN_NORMAL), -1.0d);
+    assertEquals($opt$noinline$signumDouble(0x0.00000001P-1022), 1.0d);
+    assertEquals($opt$noinline$signumDouble(-0x0.00000001P-1022), -1.0d);
+  }
+
+  private static void assertEquals(float calculated, float expected) {
+    if (0 != Float.compare(calculated, expected)) {
+      throw new Error("Expected: " + expected + ", found: " + calculated);
+    }
+  }
+
+  private static void assertEquals(double calculated, double expected) {
+    if (0 != Double.compare(calculated, expected)) {
+      throw new Error("Expected: " + expected + ", found: " + calculated);
+    }
+  }
+
+}
diff --git a/test/080-oom-throw/Android.bp b/test/080-oom-throw/Android.bp
index 840a49c648..6e07adcd9f 100644
--- a/test/080-oom-throw/Android.bp
+++ b/test/080-oom-throw/Android.bp
@@ -15,7 +15,7 @@ package {
 java_test {
     name: "art-run-test-080-oom-throw",
     defaults: ["art-run-test-defaults"],
-    test_config_template: ":art-run-test-target-template",
+    test_config_template: ":art-run-test-target-slow-template",
     srcs: ["src/**/*.java"],
     data: [
         ":art-run-test-080-oom-throw-expected-stdout",
diff --git a/test/099-vmdebug/Android.bp b/test/099-vmdebug/Android.bp
index b83cf96320..a2ba9b40cc 100644
--- a/test/099-vmdebug/Android.bp
+++ b/test/099-vmdebug/Android.bp
@@ -15,7 +15,7 @@ package {
 java_test {
     name: "art-run-test-099-vmdebug",
     defaults: ["art-run-test-defaults"],
-    test_config_template: ":art-run-test-target-template",
+    test_config_template: ":art-run-test-target-slow-template",
     srcs: ["src/**/*.java"],
     data: [
         ":art-run-test-099-vmdebug-expected-stdout",
diff --git a/test/100-reflect2/expected-stdout.txt b/test/100-reflect2/expected-stdout.txt
index d152468a4b..7c548e8fa6 100644
--- a/test/100-reflect2/expected-stdout.txt
+++ b/test/100-reflect2/expected-stdout.txt
@@ -32,8 +32,8 @@ z (class java.lang.Character)
 62 (class java.lang.Long)
 14 (class java.lang.Short)
 [java.lang.String(byte[],byte), java.lang.String(int,int,char[]), public java.lang.String(), public java.lang.String(byte[]), public java.lang.String(byte[],int), public java.lang.String(byte[],int,int), public java.lang.String(byte[],int,int,int), public java.lang.String(byte[],int,int,java.lang.String) throws java.io.UnsupportedEncodingException, public java.lang.String(byte[],int,int,java.nio.charset.Charset), public java.lang.String(byte[],java.lang.String) throws java.io.UnsupportedEncodingException, public java.lang.String(byte[],java.nio.charset.Charset), public java.lang.String(char[]), public java.lang.String(char[],int,int), public java.lang.String(int[],int,int), public java.lang.String(java.lang.String), public java.lang.String(java.lang.StringBuffer), public java.lang.String(java.lang.StringBuilder)]
-[private final int java.lang.String.count, private int java.lang.String.hash, private static final java.io.ObjectStreamField[] java.lang.String.serialPersistentFields, private static final long java.lang.String.serialVersionUID, public static final java.lang.String java.lang.String.EMPTY, public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER, static final boolean java.lang.String.COMPACT_STRINGS, static final byte java.lang.String.LATIN1, static final byte java.lang.String.UTF16]
-[byte java.lang.String.coder(), native void java.lang.String.getCharsNoCheck(int,int,char[],int), private boolean java.lang.String.nonSyncContentEquals(java.lang.AbstractStringBuilder), private int java.lang.String.indexOfNonWhitespace(), private int java.lang.String.indexOfSupplementary(int,int), private int java.lang.String.lastIndexOfNonWhitespace(), private int java.lang.String.lastIndexOfSupplementary(int,int), private native java.lang.String java.lang.String.doRepeat(int), private native java.lang.String java.lang.String.doReplace(char,char), private native java.lang.String java.lang.String.fastSubstring(int,int), private native void java.lang.String.fillBytesLatin1(byte[],int), private native void java.lang.String.fillBytesUTF16(byte[],int), private static int java.lang.String.indexOf(java.lang.String,java.lang.String,int), private static int java.lang.String.lastIndexOf(java.lang.String,java.lang.String,int), private static int java.lang.String.outdent(java.util.List), public boolean java.lang.String.contains(java.lang.CharSequence), public boolean java.lang.String.contentEquals(java.lang.CharSequence), public boolean java.lang.String.contentEquals(java.lang.StringBuffer), public boolean java.lang.String.endsWith(java.lang.String), public boolean java.lang.String.equals(java.lang.Object), public boolean java.lang.String.equalsIgnoreCase(java.lang.String), public boolean java.lang.String.isBlank(), public boolean java.lang.String.isEmpty(), public boolean java.lang.String.matches(java.lang.String), public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int), public boolean java.lang.String.regionMatches(int,java.lang.String,int,int), public boolean java.lang.String.startsWith(java.lang.String), public boolean java.lang.String.startsWith(java.lang.String,int), public byte[] java.lang.String.getBytes(), public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingException, public byte[] java.lang.String.getBytes(java.nio.charset.Charset), public int java.lang.String.codePointAt(int), public int java.lang.String.codePointBefore(int), public int java.lang.String.codePointCount(int,int), public int java.lang.String.compareTo(java.lang.Object), public int java.lang.String.compareToIgnoreCase(java.lang.String), public int java.lang.String.hashCode(), public int java.lang.String.indexOf(int), public int java.lang.String.indexOf(int,int), public int java.lang.String.indexOf(java.lang.String), public int java.lang.String.indexOf(java.lang.String,int), public int java.lang.String.lastIndexOf(int), public int java.lang.String.lastIndexOf(int,int), public int java.lang.String.lastIndexOf(java.lang.String), public int java.lang.String.lastIndexOf(java.lang.String,int), public int java.lang.String.length(), public int java.lang.String.offsetByCodePoints(int,int), public java.lang.CharSequence java.lang.String.subSequence(int,int), public java.lang.Object java.lang.String.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException, public java.lang.Object java.lang.String.transform(java.util.function.Function), public java.lang.String java.lang.String.formatted(java.lang.Object[]), public java.lang.String java.lang.String.indent(int), public java.lang.String java.lang.String.repeat(int), public java.lang.String java.lang.String.replace(char,char), public java.lang.String java.lang.String.replace(java.lang.CharSequence,java.lang.CharSequence), public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String), public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String), public java.lang.String java.lang.String.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup), public java.lang.String java.lang.String.strip(), public java.lang.String java.lang.String.stripIndent(), public java.lang.String java.lang.String.stripLeading(), public java.lang.String java.lang.String.stripTrailing(), public java.lang.String java.lang.String.substring(int), public java.lang.String java.lang.String.substring(int,int), public java.lang.String java.lang.String.toLowerCase(), public java.lang.String java.lang.String.toLowerCase(java.util.Locale), public java.lang.String java.lang.String.toString(), public java.lang.String java.lang.String.toUpperCase(), public java.lang.String java.lang.String.toUpperCase(java.util.Locale), public java.lang.String java.lang.String.translateEscapes(), public java.lang.String java.lang.String.trim(), public java.lang.String[] java.lang.String.split(java.lang.String), public java.lang.String[] java.lang.String.split(java.lang.String,int), public java.util.Optional java.lang.String.describeConstable(), public java.util.stream.IntStream java.lang.String.chars(), public java.util.stream.IntStream java.lang.String.codePoints(), public java.util.stream.Stream java.lang.String.lines(), public native char java.lang.String.charAt(int), public native char[] java.lang.String.toCharArray(), public native int java.lang.String.compareTo(java.lang.String), public native java.lang.String java.lang.String.concat(java.lang.String), public native java.lang.String java.lang.String.intern(), public static java.lang.String java.lang.String.copyValueOf(char[]), public static java.lang.String java.lang.String.copyValueOf(char[],int,int), public static java.lang.String java.lang.String.format(java.lang.String,java.lang.Object[]), public static java.lang.String java.lang.String.format(java.util.Locale,java.lang.String,java.lang.Object[]), public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence[]), public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.Iterable), public static java.lang.String java.lang.String.valueOf(boolean), public static java.lang.String java.lang.String.valueOf(char), public static java.lang.String java.lang.String.valueOf(char[]), public static java.lang.String java.lang.String.valueOf(char[],int,int), public static java.lang.String java.lang.String.valueOf(double), public static java.lang.String java.lang.String.valueOf(float), public static java.lang.String java.lang.String.valueOf(int), public static java.lang.String java.lang.String.valueOf(java.lang.Object), public static java.lang.String java.lang.String.valueOf(long), public void java.lang.String.getBytes(int,int,byte[],int), public void java.lang.String.getChars(int,int,char[],int), static int java.lang.String.indexOf(byte[],byte,int,java.lang.String,int), static int java.lang.String.lastIndexOf(byte[],byte,int,java.lang.String,int), static int java.lang.String.lastIndexOf(char[],int,int,char[],int,int,int), static java.lang.String java.lang.String.lambda$indent$0(java.lang.String,java.lang.String), static java.lang.String java.lang.String.lambda$indent$1(java.lang.String), static java.lang.String java.lang.String.lambda$indent$2(int,java.lang.String), static java.lang.String java.lang.String.lambda$stripIndent$3(int,java.lang.String), static java.lang.String java.lang.String.valueOfCodePoint(int), static void java.lang.String.checkBoundsBeginEnd(int,int,int), static void java.lang.String.checkBoundsOffCount(int,int,int), static void java.lang.String.checkIndex(int,int), static void java.lang.String.checkOffset(int,int), void java.lang.String.getBytes(byte[],int,byte), void java.lang.String.getChars(char[],int)]
+[private final int java.lang.String.count, private int java.lang.String.hash, private static final java.io.ObjectStreamField[] java.lang.String.serialPersistentFields, private static final long java.lang.String.serialVersionUID, public static final java.lang.String java.lang.String.EMPTY, public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER, static final boolean java.lang.String.COMPACT_STRINGS, static final byte java.lang.String.CODER_LATIN1, static final byte java.lang.String.CODER_UTF16]
+[byte java.lang.String.coder(), native void java.lang.String.getCharsNoCheck(int,int,char[],int), private boolean java.lang.String.nonSyncContentEquals(java.lang.AbstractStringBuilder), private int java.lang.String.indexOfNonWhitespace(), private int java.lang.String.indexOfSupplementary(int,int), private int java.lang.String.lastIndexOfNonWhitespace(), private int java.lang.String.lastIndexOfSupplementary(int,int), private native java.lang.String java.lang.String.doRepeat(int), private native java.lang.String java.lang.String.doReplace(char,char), private native java.lang.String java.lang.String.fastSubstring(int,int), private native void java.lang.String.fillBytesLatin1(byte[],int), private native void java.lang.String.fillBytesUTF16(byte[],int), private static int java.lang.String.indexOf(java.lang.String,java.lang.String,int), private static int java.lang.String.lastIndexOf(java.lang.String,java.lang.String,int), private static int java.lang.String.outdent(java.util.List), public boolean java.lang.String.contains(java.lang.CharSequence), public boolean java.lang.String.contentEquals(java.lang.CharSequence), public boolean java.lang.String.contentEquals(java.lang.StringBuffer), public boolean java.lang.String.endsWith(java.lang.String), public boolean java.lang.String.equals(java.lang.Object), public boolean java.lang.String.equalsIgnoreCase(java.lang.String), public boolean java.lang.String.isBlank(), public boolean java.lang.String.isEmpty(), public boolean java.lang.String.matches(java.lang.String), public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int), public boolean java.lang.String.regionMatches(int,java.lang.String,int,int), public boolean java.lang.String.startsWith(java.lang.String), public boolean java.lang.String.startsWith(java.lang.String,int), public byte[] java.lang.String.getBytes(), public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingException, public byte[] java.lang.String.getBytes(java.nio.charset.Charset), public int java.lang.String.codePointAt(int), public int java.lang.String.codePointBefore(int), public int java.lang.String.codePointCount(int,int), public int java.lang.String.compareTo(java.lang.Object), public int java.lang.String.compareToIgnoreCase(java.lang.String), public int java.lang.String.hashCode(), public int java.lang.String.indexOf(int), public int java.lang.String.indexOf(int,int), public int java.lang.String.indexOf(java.lang.String), public int java.lang.String.indexOf(java.lang.String,int), public int java.lang.String.lastIndexOf(int), public int java.lang.String.lastIndexOf(int,int), public int java.lang.String.lastIndexOf(java.lang.String), public int java.lang.String.lastIndexOf(java.lang.String,int), public int java.lang.String.length(), public int java.lang.String.offsetByCodePoints(int,int), public java.lang.CharSequence java.lang.String.subSequence(int,int), public java.lang.Object java.lang.String.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException, public java.lang.Object java.lang.String.transform(java.util.function.Function), public java.lang.String java.lang.String.formatted(java.lang.Object[]), public java.lang.String java.lang.String.indent(int), public java.lang.String java.lang.String.repeat(int), public java.lang.String java.lang.String.replace(char,char), public java.lang.String java.lang.String.replace(java.lang.CharSequence,java.lang.CharSequence), public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String), public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String), public java.lang.String java.lang.String.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup), public java.lang.String java.lang.String.strip(), public java.lang.String java.lang.String.stripIndent(), public java.lang.String java.lang.String.stripLeading(), public java.lang.String java.lang.String.stripTrailing(), public java.lang.String java.lang.String.substring(int), public java.lang.String java.lang.String.substring(int,int), public java.lang.String java.lang.String.toLowerCase(), public java.lang.String java.lang.String.toLowerCase(java.util.Locale), public java.lang.String java.lang.String.toString(), public java.lang.String java.lang.String.toUpperCase(), public java.lang.String java.lang.String.toUpperCase(java.util.Locale), public java.lang.String java.lang.String.translateEscapes(), public java.lang.String java.lang.String.trim(), public java.lang.String[] java.lang.String.split(java.lang.String), public java.lang.String[] java.lang.String.split(java.lang.String,int), public java.util.Optional java.lang.String.describeConstable(), public java.util.stream.IntStream java.lang.String.chars(), public java.util.stream.IntStream java.lang.String.codePoints(), public java.util.stream.Stream java.lang.String.lines(), public native char java.lang.String.charAt(int), public native char[] java.lang.String.toCharArray(), public native int java.lang.String.compareTo(java.lang.String), public native java.lang.String java.lang.String.concat(java.lang.String), public native java.lang.String java.lang.String.intern(), public static java.lang.String java.lang.String.copyValueOf(char[]), public static java.lang.String java.lang.String.copyValueOf(char[],int,int), public static java.lang.String java.lang.String.format(java.lang.String,java.lang.Object[]), public static java.lang.String java.lang.String.format(java.util.Locale,java.lang.String,java.lang.Object[]), public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence[]), public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.Iterable), public static java.lang.String java.lang.String.valueOf(boolean), public static java.lang.String java.lang.String.valueOf(char), public static java.lang.String java.lang.String.valueOf(char[]), public static java.lang.String java.lang.String.valueOf(char[],int,int), public static java.lang.String java.lang.String.valueOf(double), public static java.lang.String java.lang.String.valueOf(float), public static java.lang.String java.lang.String.valueOf(int), public static java.lang.String java.lang.String.valueOf(java.lang.Object), public static java.lang.String java.lang.String.valueOf(long), public void java.lang.String.getBytes(int,int,byte[],int), public void java.lang.String.getChars(int,int,char[],int), static int java.lang.String.indexOf(byte[],byte,int,java.lang.String,int), static int java.lang.String.lastIndexOf(byte[],byte,int,java.lang.String,int), static int java.lang.String.lastIndexOf(char[],int,int,char[],int,int,int), static java.lang.String java.lang.String.lambda$indent$0(java.lang.String,java.lang.String), static java.lang.String java.lang.String.lambda$indent$1(java.lang.String), static java.lang.String java.lang.String.lambda$indent$2(int,java.lang.String), static java.lang.String java.lang.String.lambda$stripIndent$3(int,java.lang.String), static java.lang.String java.lang.String.valueOfCodePoint(int), static void java.lang.String.checkBoundsBeginEnd(int,int,int), static void java.lang.String.checkBoundsOffCount(int,int,int), static void java.lang.String.checkIndex(int,int), static void java.lang.String.checkOffset(int,int), void java.lang.String.fillBytes(byte[],int,byte), void java.lang.String.getChars(char[],int)]
 []
 [interface java.io.Serializable, interface java.lang.Comparable, interface java.lang.CharSequence, interface java.lang.constant.Constable, interface java.lang.constant.ConstantDesc]
 0
diff --git a/test/109-suspend-check/Android.bp b/test/109-suspend-check/Android.bp
index 133d965459..4312e151c9 100644
--- a/test/109-suspend-check/Android.bp
+++ b/test/109-suspend-check/Android.bp
@@ -15,7 +15,7 @@ package {
 java_test {
     name: "art-run-test-109-suspend-check",
     defaults: ["art-run-test-defaults"],
-    test_config_template: ":art-run-test-target-template",
+    test_config_template: ":art-run-test-target-slow-template",
     srcs: ["src/**/*.java"],
     data: [
         ":art-run-test-109-suspend-check-expected-stdout",
diff --git a/test/115-native-bridge/nativebridge.cc b/test/115-native-bridge/nativebridge.cc
index be3a2011d9..1d89997711 100644
--- a/test/115-native-bridge/nativebridge.cc
+++ b/test/115-native-bridge/nativebridge.cc
@@ -628,13 +628,6 @@ extern "C" bool native_bridge_isPathSupported([[maybe_unused]] const char* libra
   return false;
 }
 
-extern "C" bool native_bridge_initAnonymousNamespace(
-    [[maybe_unused]] const char* public_ns_sonames,
-    [[maybe_unused]] const char* anon_ns_library_path) {
-  printf("Initializing anonymous namespace in native bridge.\n");
-  return false;
-}
-
 extern "C" android::native_bridge_namespace_t*
 native_bridge_createNamespace([[maybe_unused]] const char* name,
                               [[maybe_unused]] const char* ld_library_path,
@@ -664,23 +657,23 @@ extern "C" void* native_bridge_loadLibraryExt(
 
 // "NativeBridgeItf" is effectively an API (it is the name of the symbol that will be loaded
 // by the native bridge library).
-android::NativeBridgeCallbacks NativeBridgeItf {
-  // v1
-  .version = 3,
-  .initialize = &native_bridge_initialize,
-  .loadLibrary = &native_bridge_loadLibrary,
-  .getTrampoline = &native_bridge_getTrampoline,
-  .isSupported = &native_bridge_isSupported,
-  .getAppEnv = &native_bridge_getAppEnv,
-  // v2
-  .isCompatibleWith = &native_bridge_isCompatibleWith,
-  .getSignalHandler = &native_bridge_getSignalHandler,
-  // v3
-  .unloadLibrary = &native_bridge_unloadLibrary,
-  .getError = &native_bridge_getError,
-  .isPathSupported = &native_bridge_isPathSupported,
-  .initAnonymousNamespace = &native_bridge_initAnonymousNamespace,
-  .createNamespace = &native_bridge_createNamespace,
-  .linkNamespaces = &native_bridge_linkNamespaces,
-  .loadLibraryExt = &native_bridge_loadLibraryExt
+android::NativeBridgeCallbacks NativeBridgeItf{
+    // v1
+    .version = 3,
+    .initialize = &native_bridge_initialize,
+    .loadLibrary = &native_bridge_loadLibrary,
+    .getTrampoline = &native_bridge_getTrampoline,
+    .isSupported = &native_bridge_isSupported,
+    .getAppEnv = &native_bridge_getAppEnv,
+    // v2
+    .isCompatibleWith = &native_bridge_isCompatibleWith,
+    .getSignalHandler = &native_bridge_getSignalHandler,
+    // v3
+    .unloadLibrary = &native_bridge_unloadLibrary,
+    .getError = &native_bridge_getError,
+    .isPathSupported = &native_bridge_isPathSupported,
+    .unused_initAnonymousNamespace = nullptr,
+    .createNamespace = &native_bridge_createNamespace,
+    .linkNamespaces = &native_bridge_linkNamespaces,
+    .loadLibraryExt = &native_bridge_loadLibraryExt,
 };
diff --git a/test/182-method-linking/expected-stdout.txt b/test/182-method-linking/expected-stdout.txt
index 56ad59d046..f97da754f4 100644
--- a/test/182-method-linking/expected-stdout.txt
+++ b/test/182-method-linking/expected-stdout.txt
@@ -48,3 +48,5 @@ Calling pkg1.I1.foo on pkg2.DXI1
 Caught IllegalAccessError
 Calling pkg2.I2.foo on pkg2.DXI2
 Caught IllegalAccessError
+Calling pkg1.I1.foo on InheritingProtectedAbstract
+Caught IllegalAccessError
diff --git a/test/182-method-linking/src/InheritingProtectedAbstract.java b/test/182-method-linking/src/InheritingProtectedAbstract.java
new file mode 100644
index 0000000000..33740af460
--- /dev/null
+++ b/test/182-method-linking/src/InheritingProtectedAbstract.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import pkg1.I1;
+
+class InheritingProtectedAbstract extends ProtectedAbstract implements I1 {
+}
diff --git a/test/182-method-linking/src/Main.java b/test/182-method-linking/src/Main.java
index 638ff654a3..178b0b90ed 100644
--- a/test/182-method-linking/src/Main.java
+++ b/test/182-method-linking/src/Main.java
@@ -110,32 +110,39 @@ public class Main {
         D2I2 d2i2 = new D2I2();
         I2.callI2Foo(d2i2);  // pkg1.D2.foo
 
+        CXI1 cxi1 = new CXI1();
         try {
-            CXI1 cxi1 = new CXI1();
             I1.callI1Foo(cxi1);
         } catch (IllegalAccessError expected) {
             System.out.println("Caught IllegalAccessError");
         }
 
+        CXI2 cxi2 = new CXI2();
         try {
-            CXI2 cxi2 = new CXI2();
             I2.callI2Foo(cxi2);
         } catch (IllegalAccessError expected) {
             System.out.println("Caught IllegalAccessError");
         }
 
+        DXI1 dxi1 = new DXI1();
         try {
-            DXI1 dxi1 = new DXI1();
             I1.callI1Foo(dxi1);
         } catch (IllegalAccessError expected) {
             System.out.println("Caught IllegalAccessError");
         }
 
+        DXI2 dxi2 = new DXI2();
         try {
-            DXI2 dxi2 = new DXI2();
             I2.callI2Foo(dxi2);
         } catch (IllegalAccessError expected) {
             System.out.println("Caught IllegalAccessError");
         }
+
+        InheritingProtectedAbstract ipa = new InheritingProtectedAbstract();
+        try {
+            I1.callI1Foo(ipa);
+        } catch (IllegalAccessError expected) {
+            System.out.println("Caught IllegalAccessError");
+        }
     }
 }
diff --git a/test/182-method-linking/src/ProtectedAbstract.java b/test/182-method-linking/src/ProtectedAbstract.java
new file mode 100644
index 0000000000..c276eebc9b
--- /dev/null
+++ b/test/182-method-linking/src/ProtectedAbstract.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// This definition is used for compiling but the class used at runtime is in src2/.
+public abstract class ProtectedAbstract {
+    protected /*abstract*/ void foo() {
+        // No body in src2/.
+        throw new Error("Unreachable");
+    }
+}
diff --git a/test/182-method-linking/src2/ProtectedAbstract.java b/test/182-method-linking/src2/ProtectedAbstract.java
new file mode 100644
index 0000000000..0c6468c117
--- /dev/null
+++ b/test/182-method-linking/src2/ProtectedAbstract.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// This is the class ProtectedAbstract used at runtime.
+public abstract class ProtectedAbstract {
+    protected abstract void foo();
+}
diff --git a/test/1960-checker-bounds-codegen/src/Main.java b/test/1960-checker-bounds-codegen/src/Main.java
index a84d67f694..40acee3477 100644
--- a/test/1960-checker-bounds-codegen/src/Main.java
+++ b/test/1960-checker-bounds-codegen/src/Main.java
@@ -24,7 +24,7 @@ public class Main {
   /// CHECK:                     cmp {{w\d+}}, #0x0
   /// CHECK:                     b.ls #+0x{{[0-9a-f]+}} (addr 0x<<SLOW:[0-9a-f]+>>)
   /// CHECK:                     BoundsCheckSlowPathARM64
-  /// CHECK-NEXT:                0x{{0*}}<<SLOW>>:
+  /// CHECK-NEXT:                0x<<SLOW>>:
   /// CHECK-START-ARM: int Main.constantIndex(int[]) disassembly (after)
   /// CHECK:                     BoundsCheck
   /// CHECK:                     cmp {{r\d+}}, #0
@@ -46,7 +46,7 @@ public class Main {
   /// CHECK:                     cmp {{w\d+}}, #0xa
   /// CHECK:                     b.hs #+0x{{[0-9a-f]+}} (addr 0x<<SLOW:[0-9a-f]+>>)
   /// CHECK:                     BoundsCheckSlowPathARM64
-  /// CHECK-NEXT:                0x{{0*}}<<SLOW>>:
+  /// CHECK-NEXT:                0x<<SLOW>>:
   /// CHECK-START-ARM: int Main.constantLength(int) disassembly (after)
   /// CHECK:                     BoundsCheck
   /// CHECK:                     cmp {{r\d+}}, #10
@@ -70,7 +70,7 @@ public class Main {
   /// CHECK-NOT:                 cmp
   /// CHECK:                     b #+0x{{[0-9a-f]+}} (addr 0x<<SLOW:[0-9a-f]+>>)
   /// CHECK:                     BoundsCheckSlowPathARM64
-  /// CHECK-NEXT:                0x{{0*}}<<SLOW>>:
+  /// CHECK-NEXT:                0x<<SLOW>>:
   /// CHECK-START-ARM: int Main.constantIndexAndLength() disassembly (after)
   /// CHECK:                     BoundsCheck
   /// CHECK-NOT:                 cmp
diff --git a/test/2029-contended-monitors/expected-stdout.txt b/test/2029-contended-monitors/expected-stdout.txt
index 4fa00bcb24..0691378f99 100644
--- a/test/2029-contended-monitors/expected-stdout.txt
+++ b/test/2029-contended-monitors/expected-stdout.txt
@@ -1,3 +1,4 @@
+JNI_OnLoad called
 Starting
 Atomic increments
 Hold time 2, shared lock
@@ -5,11 +6,9 @@ Hold time 20, shared lock
 Hold time 200, shared lock
 Hold time 2000, shared lock
 Hold time 20000, shared lock
-Hold time 200000, shared lock
 Hold time 2, pause time 18, shared lock
 Hold time 20, pause time 180, shared lock
 Hold time 200, pause time 1800, shared lock
 Hold time 2000, pause time 18000, shared lock
-Hold time 20000, pause time 180000, shared lock
 Hold for 2 msecs while sleeping, shared lock
 Hold for 2 msecs while sleeping, private lock
diff --git a/test/2029-contended-monitors/src/Main.java b/test/2029-contended-monitors/src/Main.java
index ffe8e73a76..5b0c16a69e 100644
--- a/test/2029-contended-monitors/src/Main.java
+++ b/test/2029-contended-monitors/src/Main.java
@@ -20,9 +20,12 @@ public class Main {
   private final boolean PRINT_TIMES = false;  // False for use as run test.
 
   // Number of increments done by each thread.  Must be multiple of largest hold time below,
-  // times any possible thread count. Finishes much faster when used as run test.
-  private final int TOTAL_ITERS = PRINT_TIMES? 16_000_000 : 1_600_000;
-  private final int MAX_HOLD_TIME = PRINT_TIMES? 2_000_000 : 200_000;
+  // times any possible thread count. We reduce this below if PRINT_TIMES is not set, and
+  // even more in debuggable mode.
+  private final int UNSCALED_TOTAL_ITERS  = 16_000_000;
+  private final int UNSCALED_MAX_HOLD_TIME = 2_000_000;
+  private int totalIters;
+  private int maxHoldTime;
 
   private int counter;
 
@@ -32,6 +35,8 @@ public class Main {
 
   private int currentThreadCount = 0;
 
+  private static boolean debuggable = false;  // Running in a debuggable ART environment.
+
   // A function such that if we repeatedly apply it to -1, the value oscillates
   // between -1 and 3. Thus the average value is 1.
   // This is designed to make it hard for the compiler to predict the values in
@@ -78,7 +83,7 @@ public class Main {
     @Override
     public void run() {
       Object myLock = sharedLock ? lock : new Object();
-      int nIters = TOTAL_ITERS / currentThreadCount / holdTime;
+      int nIters = totalIters / currentThreadCount / holdTime;
       for (int i = 0; i < nIters; ++i) {
         holdFor(myLock, holdTime);
       }
@@ -95,7 +100,12 @@ public class Main {
     @Override
     public void run() {
       Object myLock = sharedLock ? lock : new Object();
-      int nIters = TOTAL_ITERS / 10 / currentThreadCount / holdTime;
+      int iter_divisor = 10 * currentThreadCount * holdTime;
+      int nIters = totalIters / iter_divisor;
+      if (totalIters % iter_divisor != 0 || holdTime % 2 == 1) {
+        System.err.println("Misconfigured: totalIters = " + totalIters
+            + " iter_divisor = "  + iter_divisor);
+      }
       for (int i = 0; i < nIters; ++i) {
         spinFor(9 * holdTime);
         holdFor(myLock, holdTime);
@@ -112,7 +122,7 @@ public class Main {
     @Override
     public void run() {
       Object myLock = sharedLock ? lock : new Object();
-      int nIters = TOTAL_ITERS / currentThreadCount / 10_000;
+      int nIters = totalIters / currentThreadCount / 10_000;
       for (int i = 0; i < nIters; ++i) {
         synchronized(myLock) {
           try {
@@ -132,7 +142,7 @@ public class Main {
     @Override
     public void run() {
       int y = -1;
-      int nIters = TOTAL_ITERS / currentThreadCount;
+      int nIters = totalIters / currentThreadCount;
       for (int i = 0; i < nIters; ++i) {
         atomicCounter.addAndGet(y);
         y = nextInt(y);
@@ -178,7 +188,7 @@ public class Main {
   private class CheckAtomicCounter implements Runnable {
     @Override
     public void run() {
-      if (atomicCounter.get() != TOTAL_ITERS) {
+      if (atomicCounter.get() != totalIters) {
         throw new AssertionError("Failed atomicCounter postcondition check for "
             + currentThreadCount + " threads");
       }
@@ -200,39 +210,57 @@ public class Main {
   }
 
   private void run() {
+    int scale = PRINT_TIMES ? 1 : (debuggable ? 20 : 10);
+    totalIters = UNSCALED_TOTAL_ITERS / scale;
+    maxHoldTime = UNSCALED_MAX_HOLD_TIME / scale;
     if (PRINT_TIMES) {
       System.out.println("All times in milliseconds for 1, 2, 4 and 8 threads");
     }
     System.out.println("Atomic increments");
     runAll(new RepeatedIncrementer(), () -> { atomicCounter.set(0); }, new CheckAtomicCounter());
-    for (int i = 2; i <= MAX_HOLD_TIME; i *= 10) {
-      // i * 8 (max thread count) divides TOTAL_ITERS
+    for (int i = 2; i <= UNSCALED_MAX_HOLD_TIME / 100; i *= 10) {
+      // i * 8 (max thread count) divides totalIters
       System.out.println("Hold time " + i + ", shared lock");
       runAll(new RepeatedLockHolder(true, i), () -> { counter = 0; },
-          new CheckCounter(TOTAL_ITERS));
+          new CheckCounter(totalIters));
     }
-    for (int i = 2; i <= MAX_HOLD_TIME / 10; i *= 10) {
-      // i * 8 (max thread count) divides TOTAL_ITERS
+    for (int i = 2; i <= UNSCALED_MAX_HOLD_TIME / 1000; i *= 10) {
+      // i * 8 (max thread count) divides totalIters
       System.out.println("Hold time " + i + ", pause time " + (9 * i) + ", shared lock");
       runAll(new RepeatedIntermittentLockHolder(true, i), () -> { counter = 0; },
-          new CheckCounter(TOTAL_ITERS / 10));
+          new CheckCounter(totalIters / 10));
     }
     if (PRINT_TIMES) {
-      for (int i = 2; i <= MAX_HOLD_TIME; i *= 1000) {
-        // i divides TOTAL_ITERS
+      for (int i = 2; i <= maxHoldTime; i *= 1000) {
+        // i divides totalIters
         System.out.println("Hold time " + i + ", private lock");
         // Since there is no mutual exclusion final counter value is unpredictable.
         runAll(new RepeatedLockHolder(false, i), () -> { counter = 0; }, () -> {});
       }
     }
     System.out.println("Hold for 2 msecs while sleeping, shared lock");
-    runAll(new SleepyLockHolder(true), () -> { counter = 0; }, new CheckCounter(TOTAL_ITERS));
+    runAll(new SleepyLockHolder(true), () -> { counter = 0; }, new CheckCounter(totalIters));
     System.out.println("Hold for 2 msecs while sleeping, private lock");
     runAll(new SleepyLockHolder(false), () -> { counter = 0; }, () -> {});
   }
 
   public static void main(String[] args) {
+    if (System.getProperty("java.vm.name").equalsIgnoreCase("Dalvik")) {
+      try {
+        System.loadLibrary(args[0]);
+        debuggable = isDebuggable();
+      } catch (Throwable t) {
+        // Conservatively assume we might be debuggable, and pretend we loaded the library.
+        // As of June 2024, we seem to get here with atest.
+        debuggable = true;
+        System.out.println("JNI_OnLoad called");
+      }
+    } else {
+      System.out.println("JNI_OnLoad called");  // Not really, but match expected output.
+    }
     System.out.println("Starting");
     new Main().run();
   }
+
+  private static native boolean isDebuggable();
 }
diff --git a/test/2232-write-metrics-to-log/run.py b/test/2232-write-metrics-to-log/run.py
index 89fe040087..72e263aab7 100644
--- a/test/2232-write-metrics-to-log/run.py
+++ b/test/2232-write-metrics-to-log/run.py
@@ -21,7 +21,9 @@ def run(ctx, args):
       android_log_tags="*:i",
       diff_min_log_tag="i",
       runtime_option=[
-          "-Xmetrics-write-to-logcat:true", "-Xmetrics-reporting-mods:100"
+          "-Xmetrics-force-enable:true",
+          "-Xmetrics-write-to-logcat:true",
+          "-Xmetrics-reporting-mods:100",
       ])
 
   # Check that one of the metrics appears in stderr.
diff --git a/test/2233-metrics-background-thread/run.py b/test/2233-metrics-background-thread/run.py
index e0d86ac13d..9a87c69db2 100644
--- a/test/2233-metrics-background-thread/run.py
+++ b/test/2233-metrics-background-thread/run.py
@@ -18,7 +18,11 @@ def run(ctx, args):
     args,
     android_log_tags="*:d",
     diff_min_log_tag="d",
-    runtime_option=["-Xmetrics-reporting-mods:100",]
+    runtime_option=[
+      "-Xmetrics-force-enable:true",
+      "-Xmetrics-write-to-logcat:true",
+      "-Xmetrics-reporting-mods:100",
+    ]
   )
 
   # Check that log messages from the metrics reporting thread appear in stderr.
diff --git a/test/2239-varhandle-perf/build.py b/test/2239-varhandle-perf-vh-cae/build.py
similarity index 100%
rename from test/2239-varhandle-perf/build.py
rename to test/2239-varhandle-perf-vh-cae/build.py
diff --git a/test/2269-checker-constant-folding-instrinsics/expected-stdout.txt b/test/2239-varhandle-perf-vh-cae/expected-stderr.txt
similarity index 100%
rename from test/2269-checker-constant-folding-instrinsics/expected-stdout.txt
rename to test/2239-varhandle-perf-vh-cae/expected-stderr.txt
diff --git a/tools/fuzzer/corpus/empty.dex b/test/2239-varhandle-perf-vh-cae/expected-stdout.txt
similarity index 100%
rename from tools/fuzzer/corpus/empty.dex
rename to test/2239-varhandle-perf-vh-cae/expected-stdout.txt
diff --git a/test/2239-varhandle-perf/generate-sources b/test/2239-varhandle-perf-vh-cae/generate-sources
similarity index 89%
rename from test/2239-varhandle-perf/generate-sources
rename to test/2239-varhandle-perf-vh-cae/generate-sources
index 310ad06f46..37d3173dba 100755
--- a/test/2239-varhandle-perf/generate-sources
+++ b/test/2239-varhandle-perf-vh-cae/generate-sources
@@ -27,4 +27,5 @@ GENERATED_SRC=src2
 mkdir -p src2
 
 # Generate tests and Main that covers both the generated tests and manual tests
-python3 ./util-src/generate_java.py "${GENERATED_SRC}"
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 4
diff --git a/test/2239-varhandle-perf/info.txt b/test/2239-varhandle-perf-vh-cae/info.txt
similarity index 100%
rename from test/2239-varhandle-perf/info.txt
rename to test/2239-varhandle-perf-vh-cae/info.txt
diff --git a/test/2239-varhandle-perf/run.py b/test/2239-varhandle-perf-vh-cae/run.py
similarity index 100%
rename from test/2239-varhandle-perf/run.py
rename to test/2239-varhandle-perf-vh-cae/run.py
diff --git a/test/2239-varhandle-perf/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-cae/src/BenchmarkBase.java
similarity index 100%
rename from test/2239-varhandle-perf/src/BenchmarkBase.java
rename to test/2239-varhandle-perf-vh-cae/src/BenchmarkBase.java
diff --git a/test/2239-varhandle-perf/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-cae/src/MicroBenchmark.java
similarity index 100%
rename from test/2239-varhandle-perf/src/MicroBenchmark.java
rename to test/2239-varhandle-perf-vh-cae/src/MicroBenchmark.java
diff --git a/test/2239-varhandle-perf/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-cae/src/UnsafeMicroBenchmark.java
similarity index 100%
rename from test/2239-varhandle-perf/src/UnsafeMicroBenchmark.java
rename to test/2239-varhandle-perf-vh-cae/src/UnsafeMicroBenchmark.java
diff --git a/test/2239-varhandle-perf-vh-cas-weak/build.py b/test/2239-varhandle-perf-vh-cas-weak/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-cas-weak/expected-stderr.txt b/test/2239-varhandle-perf-vh-cas-weak/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-cas-weak/expected-stdout.txt b/test/2239-varhandle-perf-vh-cas-weak/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-cas-weak/generate-sources b/test/2239-varhandle-perf-vh-cas-weak/generate-sources
new file mode 100755
index 0000000000..c35a2046c6
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 3
diff --git a/test/2239-varhandle-perf-vh-cas-weak/info.txt b/test/2239-varhandle-perf-vh-cas-weak/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-cas-weak/run.py b/test/2239-varhandle-perf-vh-cas-weak/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-cas-weak/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-cas-weak/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-cas-weak/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-cas-weak/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-cas-weak/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-cas-weak/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas-weak/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-cas/build.py b/test/2239-varhandle-perf-vh-cas/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-cas/expected-stderr.txt b/test/2239-varhandle-perf-vh-cas/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-cas/expected-stdout.txt b/test/2239-varhandle-perf-vh-cas/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-cas/generate-sources b/test/2239-varhandle-perf-vh-cas/generate-sources
new file mode 100755
index 0000000000..e525622dbd
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 2
diff --git a/test/2239-varhandle-perf-vh-cas/info.txt b/test/2239-varhandle-perf-vh-cas/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-cas/run.py b/test/2239-varhandle-perf-vh-cas/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-cas/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-cas/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-cas/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-cas/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-cas/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-cas/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-cas/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-gaa/build.py b/test/2239-varhandle-perf-vh-gaa/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-gaa/expected-stderr.txt b/test/2239-varhandle-perf-vh-gaa/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-gaa/expected-stdout.txt b/test/2239-varhandle-perf-vh-gaa/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-gaa/generate-sources b/test/2239-varhandle-perf-vh-gaa/generate-sources
new file mode 100755
index 0000000000..d1e0825282
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 6
diff --git a/test/2239-varhandle-perf-vh-gaa/info.txt b/test/2239-varhandle-perf-vh-gaa/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-gaa/run.py b/test/2239-varhandle-perf-vh-gaa/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-gaa/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-gaa/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-gaa/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-gaa/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-gaa/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-gaa/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gaa/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-gab/build.py b/test/2239-varhandle-perf-vh-gab/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-gab/expected-stderr.txt b/test/2239-varhandle-perf-vh-gab/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-gab/expected-stdout.txt b/test/2239-varhandle-perf-vh-gab/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-gab/generate-sources b/test/2239-varhandle-perf-vh-gab/generate-sources
new file mode 100755
index 0000000000..783ca2d10f
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 7
diff --git a/test/2239-varhandle-perf-vh-gab/info.txt b/test/2239-varhandle-perf-vh-gab/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-gab/run.py b/test/2239-varhandle-perf-vh-gab/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-gab/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-gab/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-gab/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-gab/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-gab/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-gab/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gab/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-gas/build.py b/test/2239-varhandle-perf-vh-gas/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-gas/expected-stderr.txt b/test/2239-varhandle-perf-vh-gas/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-gas/expected-stdout.txt b/test/2239-varhandle-perf-vh-gas/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-gas/generate-sources b/test/2239-varhandle-perf-vh-gas/generate-sources
new file mode 100755
index 0000000000..7d43ccac15
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 5
diff --git a/test/2239-varhandle-perf-vh-gas/info.txt b/test/2239-varhandle-perf-vh-gas/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-gas/run.py b/test/2239-varhandle-perf-vh-gas/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-gas/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-gas/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-gas/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-gas/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-gas/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-gas/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-gas/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-get-a/build.py b/test/2239-varhandle-perf-vh-get-a/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-get-a/expected-stderr.txt b/test/2239-varhandle-perf-vh-get-a/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-get-a/expected-stdout.txt b/test/2239-varhandle-perf-vh-get-a/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-get-a/generate-sources b/test/2239-varhandle-perf-vh-get-a/generate-sources
new file mode 100755
index 0000000000..a42ba79bc7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 8
diff --git a/test/2239-varhandle-perf-vh-get-a/info.txt b/test/2239-varhandle-perf-vh-get-a/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-get-a/run.py b/test/2239-varhandle-perf-vh-get-a/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-get-a/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-get-a/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-get-a/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-get-a/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-get-a/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-get-a/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-a/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-get-bav/build.py b/test/2239-varhandle-perf-vh-get-bav/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-get-bav/expected-stderr.txt b/test/2239-varhandle-perf-vh-get-bav/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-get-bav/expected-stdout.txt b/test/2239-varhandle-perf-vh-get-bav/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-get-bav/generate-sources b/test/2239-varhandle-perf-vh-get-bav/generate-sources
new file mode 100755
index 0000000000..dfa73f776c
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 10
diff --git a/test/2239-varhandle-perf-vh-get-bav/info.txt b/test/2239-varhandle-perf-vh-get-bav/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-get-bav/run.py b/test/2239-varhandle-perf-vh-get-bav/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-get-bav/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-get-bav/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-get-bav/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-get-bav/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-get-bav/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-get-bav/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get-bav/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-get/build.py b/test/2239-varhandle-perf-vh-get/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-get/expected-stderr.txt b/test/2239-varhandle-perf-vh-get/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-get/expected-stdout.txt b/test/2239-varhandle-perf-vh-get/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-get/generate-sources b/test/2239-varhandle-perf-vh-get/generate-sources
new file mode 100755
index 0000000000..adc1384a29
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 0
diff --git a/test/2239-varhandle-perf-vh-get/info.txt b/test/2239-varhandle-perf-vh-get/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-get/run.py b/test/2239-varhandle-perf-vh-get/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-get/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-get/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-get/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-get/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-get/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-get/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-get/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-reflect-get/build.py b/test/2239-varhandle-perf-vh-reflect-get/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-reflect-get/expected-stderr.txt b/test/2239-varhandle-perf-vh-reflect-get/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-reflect-get/expected-stdout.txt b/test/2239-varhandle-perf-vh-reflect-get/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-reflect-get/generate-sources b/test/2239-varhandle-perf-vh-reflect-get/generate-sources
new file mode 100755
index 0000000000..35cb71dad8
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 12
diff --git a/test/2239-varhandle-perf-vh-reflect-get/info.txt b/test/2239-varhandle-perf-vh-reflect-get/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-reflect-get/run.py b/test/2239-varhandle-perf-vh-reflect-get/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-reflect-get/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-reflect-get/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-reflect-get/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-reflect-get/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-reflect-get/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-reflect-get/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-get/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-reflect-set/build.py b/test/2239-varhandle-perf-vh-reflect-set/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-reflect-set/expected-stderr.txt b/test/2239-varhandle-perf-vh-reflect-set/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-reflect-set/expected-stdout.txt b/test/2239-varhandle-perf-vh-reflect-set/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-reflect-set/generate-sources b/test/2239-varhandle-perf-vh-reflect-set/generate-sources
new file mode 100755
index 0000000000..3424c2eccb
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 13
diff --git a/test/2239-varhandle-perf-vh-reflect-set/info.txt b/test/2239-varhandle-perf-vh-reflect-set/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-reflect-set/run.py b/test/2239-varhandle-perf-vh-reflect-set/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-reflect-set/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-reflect-set/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-reflect-set/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-reflect-set/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-reflect-set/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-reflect-set/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-reflect-set/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-set-a/build.py b/test/2239-varhandle-perf-vh-set-a/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-set-a/expected-stderr.txt b/test/2239-varhandle-perf-vh-set-a/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-set-a/expected-stdout.txt b/test/2239-varhandle-perf-vh-set-a/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-set-a/generate-sources b/test/2239-varhandle-perf-vh-set-a/generate-sources
new file mode 100755
index 0000000000..e839f958b1
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 9
diff --git a/test/2239-varhandle-perf-vh-set-a/info.txt b/test/2239-varhandle-perf-vh-set-a/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-set-a/run.py b/test/2239-varhandle-perf-vh-set-a/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-set-a/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-set-a/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-set-a/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-set-a/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-set-a/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-set-a/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-a/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-set-bav/build.py b/test/2239-varhandle-perf-vh-set-bav/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-set-bav/expected-stderr.txt b/test/2239-varhandle-perf-vh-set-bav/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-set-bav/expected-stdout.txt b/test/2239-varhandle-perf-vh-set-bav/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-set-bav/generate-sources b/test/2239-varhandle-perf-vh-set-bav/generate-sources
new file mode 100755
index 0000000000..25fc18071e
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 11
diff --git a/test/2239-varhandle-perf-vh-set-bav/info.txt b/test/2239-varhandle-perf-vh-set-bav/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-set-bav/run.py b/test/2239-varhandle-perf-vh-set-bav/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-set-bav/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-set-bav/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-set-bav/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-set-bav/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-set-bav/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-set-bav/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set-bav/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-set/build.py b/test/2239-varhandle-perf-vh-set/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-set/expected-stderr.txt b/test/2239-varhandle-perf-vh-set/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-set/expected-stdout.txt b/test/2239-varhandle-perf-vh-set/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-set/generate-sources b/test/2239-varhandle-perf-vh-set/generate-sources
new file mode 100755
index 0000000000..280169c167
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 1
diff --git a/test/2239-varhandle-perf-vh-set/info.txt b/test/2239-varhandle-perf-vh-set/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-set/run.py b/test/2239-varhandle-perf-vh-set/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-set/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-set/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-set/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-set/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-set/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-set/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-set/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/build.py b/test/2239-varhandle-perf-vh-unsafe-cas/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/expected-stderr.txt b/test/2239-varhandle-perf-vh-unsafe-cas/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/expected-stdout.txt b/test/2239-varhandle-perf-vh-unsafe-cas/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/generate-sources b/test/2239-varhandle-perf-vh-unsafe-cas/generate-sources
new file mode 100755
index 0000000000..18fdc5fccf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 16
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/info.txt b/test/2239-varhandle-perf-vh-unsafe-cas/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/run.py b/test/2239-varhandle-perf-vh-unsafe-cas/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-unsafe-cas/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-unsafe-cas/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-unsafe-cas/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-unsafe-cas/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-cas/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/build.py b/test/2239-varhandle-perf-vh-unsafe-get/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/expected-stderr.txt b/test/2239-varhandle-perf-vh-unsafe-get/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/expected-stdout.txt b/test/2239-varhandle-perf-vh-unsafe-get/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/generate-sources b/test/2239-varhandle-perf-vh-unsafe-get/generate-sources
new file mode 100755
index 0000000000..84c2f702cd
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 14
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/info.txt b/test/2239-varhandle-perf-vh-unsafe-get/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/run.py b/test/2239-varhandle-perf-vh-unsafe-get/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-unsafe-get/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-unsafe-get/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-unsafe-get/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-unsafe-get/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-get/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/build.py b/test/2239-varhandle-perf-vh-unsafe-put/build.py
new file mode 100644
index 0000000000..3466dfece7
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  if ctx.jvm:
+    return  # The test does not build on JVM
+
+  ctx.default_build(api_level="var-handles")
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/expected-stderr.txt b/test/2239-varhandle-perf-vh-unsafe-put/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/expected-stdout.txt b/test/2239-varhandle-perf-vh-unsafe-put/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/generate-sources b/test/2239-varhandle-perf-vh-unsafe-put/generate-sources
new file mode 100755
index 0000000000..b5abcbf29b
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/generate-sources
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Make us exit on a failure
+set -e
+
+# Set variables for source directories. Using src-art so we use
+# VarHandles in the bootclasspath and can compile with the Java 8
+# compiler.
+MANUAL_SRC=src
+GENERATED_SRC=src2
+
+# Build the Java files
+mkdir -p src2
+
+# Generate tests and Main that covers both the generated tests and manual tests
+python3 ${ANDROID_BUILD_TOP}/art/test/utils/python/generate_java_varhandle_perf.py \
+"${GENERATED_SRC}" 15
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/info.txt b/test/2239-varhandle-perf-vh-unsafe-put/info.txt
new file mode 100644
index 0000000000..943303dfaf
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/info.txt
@@ -0,0 +1 @@
+Temporary benchmarks for VarHandle accessors and some alternatives.
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/run.py b/test/2239-varhandle-perf-vh-unsafe-put/run.py
new file mode 100644
index 0000000000..4e8755dbda
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/run.py
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Copyright 2022 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args)
+
+  # Dump the output of the benchmarks that run and report success. The
+  # benchmarks ran successfully if we get as far as this script.
+  ctx.run(fr"cat '{args.stdout_file}'")
+
+  # Delete all output to make the diff unconditionally pass.
+  ctx.run(fr"> '{args.stdout_file}'")
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/src/BenchmarkBase.java b/test/2239-varhandle-perf-vh-unsafe-put/src/BenchmarkBase.java
new file mode 100644
index 0000000000..ee390b46ad
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/src/BenchmarkBase.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BenchmarkBase {
+  public final String name;
+
+  // Empty constructor.
+  public BenchmarkBase(String name) {
+    this.name = name;
+  }
+
+  // The benchmark code.
+  // This function is not used, if both [warmup] and [exercise] are overwritten.
+  public void run() throws Throwable { }
+
+  // Runs a short version of the benchmark. By default invokes [run] once.
+  public void warmup() throws Throwable {
+    run();
+  }
+
+  // Exercises the benchmark. By default invokes [run] 10 times.
+  public void exercise() throws Throwable {
+    for (int i = 0; i < 10; ++i) {
+      run();
+    }
+  }
+
+  // Not measured setup code executed prior to the benchmark runs.
+  public void setup() throws Throwable { }
+
+  // Not measures teardown code executed after the benchark runs.
+  public void teardown() throws Throwable { }
+
+  // Measures the score for this benchmark by executing it repeatedly until
+  // time minimum has been reached.
+  protected double measureFor(boolean doWarmup, long timeMinimum) throws Throwable {
+    int iter = 0;
+    long startTime = System.currentTimeMillis();
+    long elapsed = 0;
+    while (elapsed < timeMinimum) {
+      if (doWarmup) {
+        warmup();
+      } else {
+        exercise();
+      }
+      elapsed = System.currentTimeMillis() - startTime;
+      iter++;
+    }
+    return 1000.0 * elapsed / iter;
+  }
+
+  // Measures the score for the benchmark and returns it.
+  public double measure() throws Throwable {
+    setup();
+    // Warmup for at least 100ms. Discard result.
+    measureFor(true, 100);
+    // Run the benchmark for at least 1000ms.
+    double result = measureFor(false, 1000);
+    teardown();
+    return result;
+  }
+
+  // Allow subclasses to override how the name is printed.
+  public String getName() {
+    return name;
+  }
+
+  public void report() throws Throwable {
+    double score = measure();
+    System.out.println(getName() + "(RunTime): " + score + " us.");
+  }
+}
\ No newline at end of file
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/src/MicroBenchmark.java b/test/2239-varhandle-perf-vh-unsafe-put/src/MicroBenchmark.java
new file mode 100644
index 0000000000..bd72f58842
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/src/MicroBenchmark.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.PrintStream;
+
+class MicroBenchmark extends BenchmarkBase {
+  private static final int EXERCISE_ITERATIONS = 1000;
+
+  MicroBenchmark() {
+    super(null);
+  }
+
+  @Override
+  public String getName() {
+    return getClass().getSimpleName();
+  }
+
+  @Override
+  public void exercise() throws Throwable {
+    for (int i = 0; i < EXERCISE_ITERATIONS; ++i) {
+      run();
+    }
+  }
+
+  public int innerIterations() {
+      return 1;
+  }
+
+  @Override
+  public void report() {
+    try {
+      double microseconds = measure() / (EXERCISE_ITERATIONS * innerIterations());
+      System.out.println(getName() + "(RunTimeRaw): " + microseconds + " us.");
+    } catch (Throwable t) {
+      System.err.println("Exception during the execution of " + getName());
+      System.err.println(t);
+      t.printStackTrace(new PrintStream(System.err));
+      System.exit(1);
+    }
+  }
+}
diff --git a/test/2239-varhandle-perf-vh-unsafe-put/src/UnsafeMicroBenchmark.java b/test/2239-varhandle-perf-vh-unsafe-put/src/UnsafeMicroBenchmark.java
new file mode 100644
index 0000000000..1b8c0af959
--- /dev/null
+++ b/test/2239-varhandle-perf-vh-unsafe-put/src/UnsafeMicroBenchmark.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import jdk.internal.misc.Unsafe;
+
+class UnsafeMicroBenchmark extends MicroBenchmark {
+  protected Unsafe theUnsafe;
+
+  UnsafeMicroBenchmark() throws Throwable {
+    Field f = Unsafe.class.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    theUnsafe = (Unsafe) f.get(null);
+  }
+
+  protected long getFieldOffset(Field field) throws Throwable {
+    return theUnsafe.objectFieldOffset(field);
+  }
+
+  protected long getStaticFieldOffset(Field staticField) throws Throwable {
+    if (System.getProperty("java.vm.name").equals("Dalvik")) {
+        // field.getOffset(); ()J
+        Method m = Field.class.getDeclaredMethod("getOffset");
+        return (Integer) m.invoke(staticField);
+    } else {
+        // theUnsafe.staticFieldOffset(field) (Ljava/lang/Field;)J
+        Method m = Unsafe.class.getDeclaredMethod("staticFieldOffset", Field.class);
+        return (Long) m.invoke(theUnsafe, staticField);
+    }
+  }
+}
\ No newline at end of file
diff --git a/test/2246-trace-v2/dump_trace.cc b/test/2246-trace-v2/dump_trace.cc
index c7eea0ddd5..4dfc42ef4b 100644
--- a/test/2246-trace-v2/dump_trace.cc
+++ b/test/2246-trace-v2/dump_trace.cc
@@ -28,7 +28,8 @@ namespace art {
 namespace {
 
 static const int kMagicValue = 0x574f4c53;
-static const int kVersionDualClock = 0xf5;
+static const int kVersionDualClockStreaming = 0xf5;
+static const int kVersionDualClock = 0x05;
 static const int kThreadInfo = 0;
 static const int kMethodInfo = 1;
 static const int kTraceEntries = 2;
@@ -147,35 +148,22 @@ bool ProcessTraceEntries(std::unique_ptr<File>& file,
                          const char* thread_name_filter,
                          std::map<uint64_t, std::string>& ignored_method_map,
                          std::map<int64_t, int>& ignored_method_depth_map) {
-  uint8_t header[24];
-  int header_size = is_dual_clock ? 24 : 20;
-  if (!file->ReadFully(header, header_size)) {
+  uint8_t header[11];
+  if (!file->ReadFully(header, sizeof(header))) {
     return false;
   }
 
   uint32_t thread_id = ReadNumber(4, header);
-  uint64_t method_value = ReadNumber(8, header + 4);
-  int offset = 12;
-  if (is_dual_clock) {
-    // Read timestamp.
-    ReadNumber(4, header + offset);
-    offset += 4;
-  }
-  // Read timestamp.
-  ReadNumber(4, header + offset);
-  offset += 4;
-  int num_records = ReadNumber(2, header + offset);
-  offset += 2;
-  int total_size = ReadNumber(2, header + offset);
+  int offset = 4;
+  int num_records = ReadNumber(3, header + offset);
+  offset += 3;
+  int total_size = ReadNumber(4, header + offset);
   uint8_t* buffer = new uint8_t[total_size];
   if (!file->ReadFully(buffer, total_size)) {
     delete[] buffer;
     return false;
   }
 
-  const uint8_t* current_buffer_ptr = buffer;
-  uint8_t event_type = method_value & 0x3;
-  uint64_t method_id = (method_value >> kTraceActionBits) << kTraceActionBits;
   int current_depth = 0;
   if (current_depth_map.find(thread_id) != current_depth_map.end()) {
     // Get the current call stack depth. If it is the first method we are seeing on this thread
@@ -192,28 +180,18 @@ bool ProcessTraceEntries(std::unique_ptr<File>& file,
 
   std::string thread_name = thread_map[thread_id];
   bool print_thread_events = (thread_name.compare(thread_name_filter) == 0);
-  if (method_map.find(method_id) == method_map.end()) {
-    LOG(FATAL) << "No entry for init method " << std::hex << method_id << " " << method_value;
-  }
-  if (print_thread_events) {
-    PrintTraceEntry(thread_name,
-                    method_map[method_id],
-                    event_type,
-                    &current_depth,
-                    ignored_method,
-                    &ignored_method_depth);
-  }
-  int64_t prev_method_value = method_value;
+
+  const uint8_t* current_buffer_ptr = buffer;
+  int64_t prev_method_value = 0;
   for (int i = 0; i < num_records; i++) {
     int64_t diff = 0;
-    auto buffer_ptr = current_buffer_ptr;
     if (!DecodeSignedLeb128Checked(&current_buffer_ptr, buffer + total_size - 1, &diff)) {
       LOG(FATAL) << "Reading past the buffer???";
     }
     int64_t curr_method_value = prev_method_value + diff;
     prev_method_value = curr_method_value;
-    event_type = curr_method_value & 0x3;
-    method_id = (curr_method_value >> kTraceActionBits) << kTraceActionBits;
+    uint8_t event_type = curr_method_value & 0x3;
+    uint64_t method_id = (curr_method_value >> kTraceActionBits) << kTraceActionBits;
     if (method_map.find(method_id) == method_map.end()) {
       LOG(FATAL) << "No entry for method " << std::hex << method_id;
     }
@@ -264,13 +242,13 @@ extern "C" JNIEXPORT void JNICALL Java_Main_dumpTrace(JNIEnv* env,
   }
   int magic_value = ReadNumber(4, header);
   if (magic_value != kMagicValue) {
-    printf("Incorrect magic value\n");
+    printf("Incorrect magic value got:%0x expected:%0x\n", magic_value, kMagicValue);
     return;
   }
   int version = ReadNumber(2, header + 4);
   printf("version=%0x\n", version);
 
-  bool is_dual_clock = (version == kVersionDualClock);
+  bool is_dual_clock = (version == kVersionDualClock) || (version == kVersionDualClockStreaming);
   bool has_entries = true;
   while (has_entries) {
     uint8_t entry_header;
diff --git a/test/2246-trace-v2/expected-stdout.txt b/test/2246-trace-v2/expected-stdout.txt
index 53430a6195..697a3393bb 100644
--- a/test/2246-trace-v2/expected-stdout.txt
+++ b/test/2246-trace-v2/expected-stdout.txt
@@ -189,7 +189,7 @@ version=f5
 ......>> TestThread2246 dalvik.system.VMDebug stopMethodTracing ()V VMDebug.java
 version=f5
 .>> main Main main ([Ljava/lang/String;)V Main.java
-..>> main Main testTracing (ZII)V Main.java
+..>> main Main testTracing (ZI)V Main.java
 ...>> main Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
 ....>> main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
 .....>> main dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
@@ -575,7 +575,779 @@ version=f4
 ......>> TestThread2246 dalvik.system.VMDebug stopMethodTracing ()V VMDebug.java
 version=f4
 .>> main Main main ([Ljava/lang/String;)V Main.java
-..>> main Main testTracing (ZII)V Main.java
+..>> main Main testTracing (ZI)V Main.java
+...>> main Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+....>> main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+.....>> main dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+......>> main dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+......<< main dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+.....<< main dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+....<< main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+...<< main Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+...>> main Main $noinline$doSomeWork ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWork ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main doSomeWorkThrow ()V Main.java
+....>> main Main callThrowFunction ()V Main.java
+.....>> main java.lang.Exception <init> (Ljava/lang/String;)V Exception.java
+......>> main java.lang.Throwable <init> (Ljava/lang/String;)V Throwable.java
+.......>> main java.lang.Object <init> ()V Object.java
+.......<< main java.lang.Object <init> ()V Object.java
+.......>> main java.util.Collections emptyList ()Ljava/util/List; Collections.java
+.......<< main java.util.Collections emptyList ()Ljava/util/List; Collections.java
+.......>> main java.lang.Throwable fillInStackTrace ()Ljava/lang/Throwable; Throwable.java
+........>> main java.lang.Throwable nativeFillInStackTrace ()Ljava/lang/Object; Throwable.java
+........<< main java.lang.Throwable nativeFillInStackTrace ()Ljava/lang/Object; Throwable.java
+.......<< main java.lang.Throwable fillInStackTrace ()Ljava/lang/Throwable; Throwable.java
+......<< main java.lang.Throwable <init> (Ljava/lang/String;)V Throwable.java
+.....<< main java.lang.Exception <init> (Ljava/lang/String;)V Exception.java
+....<<E main Main callThrowFunction ()V Main.java
+...<< main Main doSomeWorkThrow ()V Main.java
+...>> main Main$VMDebug $noinline$stopMethodTracing ()V Main.java
+....>> main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+.....>> main dalvik.system.VMDebug stopMethodTracing ()V VMDebug.java
+***** non-streaming test - dual clock *******
+version=5
+.>> TestThread2246 java.lang.Thread run ()V Thread.java
+..>> TestThread2246 Main$$ExternalSyntheticLambda0 run ()V D8$$SyntheticClass
+...>> TestThread2246 Main lambda$testTracing$0 (IZLMain;)V Main.java
+....>> TestThread2246 Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+.....>> TestThread2246 java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+......>> TestThread2246 dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+.......>> TestThread2246 dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+.......<< TestThread2246 dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+......<< TestThread2246 dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+.....<< TestThread2246 java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+....<< TestThread2246 Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+....>> TestThread2246 Main <init> ()V Main.java
+.....>> TestThread2246 java.lang.Object <init> ()V Object.java
+.....<< TestThread2246 java.lang.Object <init> ()V Object.java
+....<< TestThread2246 Main <init> ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWork ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWork ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main$VMDebug $noinline$stopMethodTracing ()V Main.java
+.....>> TestThread2246 java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+......>> TestThread2246 dalvik.system.VMDebug stopMethodTracing ()V VMDebug.java
+version=5
+.>> main Main main ([Ljava/lang/String;)V Main.java
+..>> main Main testTracing (ZI)V Main.java
+...>> main Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+....>> main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+.....>> main dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+......>> main dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+......<< main dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+.....<< main dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+....<< main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+...<< main Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+...>> main Main $noinline$doSomeWork ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWork ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main $noinline$doSomeWorkJIT ()V Main.java
+....>> main Main callOuterFunction ()V Main.java
+.....>> main Main callLeafFunction ()V Main.java
+.....<< main Main callLeafFunction ()V Main.java
+....<< main Main callOuterFunction ()V Main.java
+....>> main Main callLeafFunction ()V Main.java
+....<< main Main callLeafFunction ()V Main.java
+...<< main Main $noinline$doSomeWorkJIT ()V Main.java
+...>> main Main doSomeWorkThrow ()V Main.java
+....>> main Main callThrowFunction ()V Main.java
+.....>> main java.lang.Exception <init> (Ljava/lang/String;)V Exception.java
+......>> main java.lang.Throwable <init> (Ljava/lang/String;)V Throwable.java
+.......>> main java.lang.Object <init> ()V Object.java
+.......<< main java.lang.Object <init> ()V Object.java
+.......>> main java.util.Collections emptyList ()Ljava/util/List; Collections.java
+.......<< main java.util.Collections emptyList ()Ljava/util/List; Collections.java
+.......>> main java.lang.Throwable fillInStackTrace ()Ljava/lang/Throwable; Throwable.java
+........>> main java.lang.Throwable nativeFillInStackTrace ()Ljava/lang/Object; Throwable.java
+........<< main java.lang.Throwable nativeFillInStackTrace ()Ljava/lang/Object; Throwable.java
+.......<< main java.lang.Throwable fillInStackTrace ()Ljava/lang/Throwable; Throwable.java
+......<< main java.lang.Throwable <init> (Ljava/lang/String;)V Throwable.java
+.....<< main java.lang.Exception <init> (Ljava/lang/String;)V Exception.java
+....<<E main Main callThrowFunction ()V Main.java
+...<< main Main doSomeWorkThrow ()V Main.java
+...>> main Main$VMDebug $noinline$stopMethodTracing ()V Main.java
+....>> main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+.....>> main dalvik.system.VMDebug stopMethodTracing ()V VMDebug.java
+***** non-streaming test - wall clock *******
+version=4
+.>> TestThread2246 java.lang.Thread run ()V Thread.java
+..>> TestThread2246 Main$$ExternalSyntheticLambda0 run ()V D8$$SyntheticClass
+...>> TestThread2246 Main lambda$testTracing$0 (IZLMain;)V Main.java
+....>> TestThread2246 Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+.....>> TestThread2246 java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+......>> TestThread2246 dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+.......>> TestThread2246 dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+.......<< TestThread2246 dalvik.system.VMDebug startMethodTracingFd (Ljava/lang/String;IIIZIZ)V VMDebug.java
+......<< TestThread2246 dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
+.....<< TestThread2246 java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+....<< TestThread2246 Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
+....>> TestThread2246 Main <init> ()V Main.java
+.....>> TestThread2246 java.lang.Object <init> ()V Object.java
+.....<< TestThread2246 java.lang.Object <init> ()V Object.java
+....<< TestThread2246 Main <init> ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWork ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWork ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+.....>> TestThread2246 Main callOuterFunction ()V Main.java
+......>> TestThread2246 Main callLeafFunction ()V Main.java
+......<< TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callOuterFunction ()V Main.java
+.....>> TestThread2246 Main callLeafFunction ()V Main.java
+.....<< TestThread2246 Main callLeafFunction ()V Main.java
+....<< TestThread2246 Main $noinline$doSomeWorkJIT ()V Main.java
+....>> TestThread2246 Main$VMDebug $noinline$stopMethodTracing ()V Main.java
+.....>> TestThread2246 java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
+......>> TestThread2246 dalvik.system.VMDebug stopMethodTracing ()V VMDebug.java
+version=4
+.>> main Main main ([Ljava/lang/String;)V Main.java
+..>> main Main testTracing (ZI)V Main.java
 ...>> main Main$VMDebug startMethodTracingV2 (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V Main.java
 ....>> main java.lang.reflect.Method invoke (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; Method.java
 .....>> main dalvik.system.VMDebug startMethodTracing (Ljava/lang/String;Ljava/io/FileDescriptor;IIZIZ)V VMDebug.java
diff --git a/test/2246-trace-v2/src/Main.java b/test/2246-trace-v2/src/Main.java
index b5ccb9d0ec..97541be1b3 100644
--- a/test/2246-trace-v2/src/Main.java
+++ b/test/2246-trace-v2/src/Main.java
@@ -40,16 +40,19 @@ public class Main {
         ensureJitCompiled(Main.class, "$noinline$doSomeWorkJIT");
 
         System.out.println("***** streaming test - dual clock *******");
-        testTracing(
-                /* streaming=*/true, /* flags= */ 0, STREAMING_DUAL_CLOCK_VERSION);
+        testTracing(/* streaming=*/true, /* flags= */ 0);
 
         System.out.println("***** streaming test - wall clock *******");
-        testTracing(
-                /* streaming=*/true, /* flags= */ WALL_CLOCK_FLAG, STREAMING_WALL_CLOCK_VERSION);
+        testTracing(/* streaming=*/true, /* flags= */ WALL_CLOCK_FLAG);
+
+        System.out.println("***** non-streaming test - dual clock *******");
+        testTracing(/* streaming=*/false, /* flags= */ 0);
+
+        System.out.println("***** non-streaming test - wall clock *******");
+        testTracing(/* streaming=*/false, /* flags= */ WALL_CLOCK_FLAG);
     }
 
-    public static void testTracing(boolean streaming, int flags, int expected_version)
-            throws Exception {
+    public static void testTracing(boolean streaming, int flags) throws Exception {
         Main m = new Main();
         Thread t = new Thread(() -> {
             try {
diff --git a/test/2269-checker-constant-folding-instrinsics/Android.bp b/test/2269-checker-constant-folding-intrinsics/Android.bp
similarity index 65%
rename from test/2269-checker-constant-folding-instrinsics/Android.bp
rename to test/2269-checker-constant-folding-intrinsics/Android.bp
index 09d7d12797..cc4545f865 100644
--- a/test/2269-checker-constant-folding-instrinsics/Android.bp
+++ b/test/2269-checker-constant-folding-intrinsics/Android.bp
@@ -1,6 +1,6 @@
 // Generated by `regen-test-files`. Do not edit manually.
 
-// Build rules for ART run-test `2269-checker-constant-folding-instrinsics`.
+// Build rules for ART run-test `2269-checker-constant-folding-intrinsics`.
 
 package {
     // See: http://go/android-license-faq
@@ -13,13 +13,13 @@ package {
 
 // Test's Dex code.
 java_test {
-    name: "art-run-test-2269-checker-constant-folding-instrinsics",
+    name: "art-run-test-2269-checker-constant-folding-intrinsics",
     defaults: ["art-run-test-defaults"],
     test_config_template: ":art-run-test-target-template",
     srcs: ["src/**/*.java"],
     data: [
-        ":art-run-test-2269-checker-constant-folding-instrinsics-expected-stdout",
-        ":art-run-test-2269-checker-constant-folding-instrinsics-expected-stderr",
+        ":art-run-test-2269-checker-constant-folding-intrinsics-expected-stdout",
+        ":art-run-test-2269-checker-constant-folding-intrinsics-expected-stderr",
     ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
@@ -28,16 +28,16 @@ java_test {
 
 // Test's expected standard output.
 genrule {
-    name: "art-run-test-2269-checker-constant-folding-instrinsics-expected-stdout",
-    out: ["art-run-test-2269-checker-constant-folding-instrinsics-expected-stdout.txt"],
+    name: "art-run-test-2269-checker-constant-folding-intrinsics-expected-stdout",
+    out: ["art-run-test-2269-checker-constant-folding-intrinsics-expected-stdout.txt"],
     srcs: ["expected-stdout.txt"],
     cmd: "cp -f $(in) $(out)",
 }
 
 // Test's expected standard error.
 genrule {
-    name: "art-run-test-2269-checker-constant-folding-instrinsics-expected-stderr",
-    out: ["art-run-test-2269-checker-constant-folding-instrinsics-expected-stderr.txt"],
+    name: "art-run-test-2269-checker-constant-folding-intrinsics-expected-stderr",
+    out: ["art-run-test-2269-checker-constant-folding-intrinsics-expected-stderr.txt"],
     srcs: ["expected-stderr.txt"],
     cmd: "cp -f $(in) $(out)",
 }
diff --git a/test/2269-checker-constant-folding-intrinsics/expected-stderr.txt b/test/2269-checker-constant-folding-intrinsics/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2269-checker-constant-folding-intrinsics/expected-stdout.txt b/test/2269-checker-constant-folding-intrinsics/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2269-checker-constant-folding-instrinsics/info.txt b/test/2269-checker-constant-folding-intrinsics/info.txt
similarity index 100%
rename from test/2269-checker-constant-folding-instrinsics/info.txt
rename to test/2269-checker-constant-folding-intrinsics/info.txt
diff --git a/test/2269-checker-constant-folding-instrinsics/src/Main.java b/test/2269-checker-constant-folding-intrinsics/src/Main.java
similarity index 100%
rename from test/2269-checker-constant-folding-instrinsics/src/Main.java
rename to test/2269-checker-constant-folding-intrinsics/src/Main.java
diff --git a/test/2274-checker-bitwise-gvn/Android.bp b/test/2274-checker-bitwise-gvn/Android.bp
new file mode 100644
index 0000000000..b2d0fd2742
--- /dev/null
+++ b/test/2274-checker-bitwise-gvn/Android.bp
@@ -0,0 +1,43 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2274-checker-bitwise-gvn`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2274-checker-bitwise-gvn",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2274-checker-bitwise-gvn-expected-stdout",
+        ":art-run-test-2274-checker-bitwise-gvn-expected-stderr",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2274-checker-bitwise-gvn-expected-stdout",
+    out: ["art-run-test-2274-checker-bitwise-gvn-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2274-checker-bitwise-gvn-expected-stderr",
+    out: ["art-run-test-2274-checker-bitwise-gvn-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2275-checker-empty-loops/Android.bp b/test/2275-checker-empty-loops/Android.bp
new file mode 100644
index 0000000000..95c18bd196
--- /dev/null
+++ b/test/2275-checker-empty-loops/Android.bp
@@ -0,0 +1,43 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2275-checker-empty-loops`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2275-checker-empty-loops",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2275-checker-empty-loops-expected-stdout",
+        ":art-run-test-2275-checker-empty-loops-expected-stderr",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2275-checker-empty-loops-expected-stdout",
+    out: ["art-run-test-2275-checker-empty-loops-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2275-checker-empty-loops-expected-stderr",
+    out: ["art-run-test-2275-checker-empty-loops-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2275-checker-empty-loops/expected-stderr.txt b/test/2275-checker-empty-loops/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2275-checker-empty-loops/expected-stdout.txt b/test/2275-checker-empty-loops/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2275-checker-empty-loops/info.txt b/test/2275-checker-empty-loops/info.txt
new file mode 100644
index 0000000000..72fc2d9013
--- /dev/null
+++ b/test/2275-checker-empty-loops/info.txt
@@ -0,0 +1 @@
+Tests that we eliminate never taken loops.
diff --git a/test/2275-checker-empty-loops/src/Main.java b/test/2275-checker-empty-loops/src/Main.java
new file mode 100644
index 0000000000..00cd47de27
--- /dev/null
+++ b/test/2275-checker-empty-loops/src/Main.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+    static int static_int = 0;
+    static long static_long = 0;
+
+    public static void main(String[] args) {
+        $noinline$testSameStartEndInt();
+        assertIntEquals(0, static_int);
+        $noinline$testStartBiggerThanEndInt();
+        assertIntEquals(0, static_int);
+        $noinline$testUnknownParameterValuesInt(10, 1);
+        assertIntEquals(0, static_int);
+        $noinline$testKnownParameterValuesInt();
+        assertIntEquals(0, static_int);
+        $noinline$testKnownParameterValuesInt_WithOverflow();
+        assertIntEquals(0, static_int);
+
+        $noinline$testSameStartEndLong();
+        assertLongEquals(0L, static_long);
+        $noinline$testStartBiggerThanEndLong();
+        assertLongEquals(0L, static_long);
+        $noinline$testUnknownParameterValuesLong(10L, 1L);
+        assertLongEquals(0L, static_long);
+        $noinline$testKnownParameterValuesLong();
+        assertLongEquals(0L, static_long);
+        $noinline$testKnownParameterValuesLong_WithOverflow();
+        assertLongEquals(0L, static_long);
+    }
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndInt() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndInt() loop_optimization (after)
+    /// CHECK: <<Const1:i\d+>> IntConstant 1
+    /// CHECK:                 If [<<Const1>>]
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndInt() dead_code_elimination$after_loop_opt (before)
+    /// CHECK:     Phi
+    /// CHECK:     GreaterThanOrEqual
+    /// CHECK:     If
+    /// CHECK:     StaticFieldSet
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndInt() dead_code_elimination$after_loop_opt (after)
+    /// CHECK-NOT: Phi
+    /// CHECK-NOT: GreaterThanOrEqual
+    /// CHECK-NOT: If
+    /// CHECK-NOT: StaticFieldSet
+    private static void $noinline$testSameStartEndInt() {
+        for (int i = 2; i < 2; i++) {
+            static_int = 24;
+        }
+    }
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndInt() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndInt() loop_optimization (after)
+    /// CHECK: <<Const1:i\d+>> IntConstant 1
+    /// CHECK:                 If [<<Const1>>]
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndInt() dead_code_elimination$after_loop_opt (before)
+    /// CHECK:     Phi
+    /// CHECK:     GreaterThanOrEqual
+    /// CHECK:     If
+    /// CHECK:     StaticFieldSet
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndInt() dead_code_elimination$after_loop_opt (after)
+    /// CHECK-NOT: Phi
+    /// CHECK-NOT: GreaterThanOrEqual
+    /// CHECK-NOT: If
+    /// CHECK-NOT: StaticFieldSet
+    public static void $noinline$testStartBiggerThanEndInt() {
+        for (int i = 2; i < 1; i++) {
+            static_int = 24;
+        }
+    }
+
+    // Since the parameters are unknown, we have to keep the loop.
+
+    /// CHECK-START: void Main.$noinline$testUnknownParameterValuesInt(int, int) loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testUnknownParameterValuesInt(int, int) loop_optimization (after)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+    public static void $noinline$testUnknownParameterValuesInt(int start, int end) {
+        for (int i = start; i < end; i++) {
+            static_int = 24;
+        }
+    }
+
+    public static void $inline$unknownParameterValuesInt(int start, int end) {
+        for (int i = start; i < end; i++) {
+            static_int = 24;
+        }
+    }
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesInt() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesInt() loop_optimization (after)
+    /// CHECK: <<Const1:i\d+>> IntConstant 1
+    /// CHECK:                 If [<<Const1>>]
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesInt() dead_code_elimination$after_loop_opt (before)
+    /// CHECK:     Phi
+    /// CHECK:     GreaterThanOrEqual
+    /// CHECK:     If
+    /// CHECK:     StaticFieldSet
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesInt() dead_code_elimination$after_loop_opt (after)
+    /// CHECK-NOT: Phi
+    /// CHECK-NOT: GreaterThanOrEqual
+    /// CHECK-NOT: If
+    /// CHECK-NOT: StaticFieldSet
+    public static void $noinline$testKnownParameterValuesInt() {
+        $inline$unknownParameterValuesInt(10, 1);
+    }
+
+    // Known limitatation: The loop count calculation would overflow so loop optimization doesn't
+    // know how many trips there are.
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesInt_WithOverflow() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesInt_WithOverflow() loop_optimization (after)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+    public static void $noinline$testKnownParameterValuesInt_WithOverflow() {
+        $inline$unknownParameterValuesInt(Integer.MAX_VALUE, Integer.MIN_VALUE);
+    }
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndLong() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndLong() loop_optimization (after)
+    /// CHECK: <<Const1:i\d+>> IntConstant 1
+    /// CHECK:                 If [<<Const1>>]
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndLong() dead_code_elimination$after_loop_opt (before)
+    /// CHECK:     Phi
+    /// CHECK:     GreaterThanOrEqual
+    /// CHECK:     If
+    /// CHECK:     StaticFieldSet
+
+    /// CHECK-START: void Main.$noinline$testSameStartEndLong() dead_code_elimination$after_loop_opt (after)
+    /// CHECK-NOT: Phi
+    /// CHECK-NOT: GreaterThanOrEqual
+    /// CHECK-NOT: If
+    /// CHECK-NOT: StaticFieldSet
+    private static void $noinline$testSameStartEndLong() {
+        for (long i = 2; i < 2; i++) {
+            static_long = 24;
+        }
+    }
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndLong() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndLong() loop_optimization (after)
+    /// CHECK: <<Const1:i\d+>> IntConstant 1
+    /// CHECK:                 If [<<Const1>>]
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndLong() dead_code_elimination$after_loop_opt (before)
+    /// CHECK:     Phi
+    /// CHECK:     GreaterThanOrEqual
+    /// CHECK:     If
+    /// CHECK:     StaticFieldSet
+
+    /// CHECK-START: void Main.$noinline$testStartBiggerThanEndLong() dead_code_elimination$after_loop_opt (after)
+    /// CHECK-NOT: Phi
+    /// CHECK-NOT: GreaterThanOrEqual
+    /// CHECK-NOT: If
+    /// CHECK-NOT: StaticFieldSet
+    public static void $noinline$testStartBiggerThanEndLong() {
+        for (long i = 2; i < 1; i++) {
+            static_long = 24;
+        }
+    }
+
+    // Since the parameters are unknown, we have to keep the loop.
+
+    /// CHECK-START: void Main.$noinline$testUnknownParameterValuesLong(long, long) loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testUnknownParameterValuesLong(long, long) loop_optimization (after)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+    public static void $noinline$testUnknownParameterValuesLong(long start, long end) {
+        for (long i = start; i < end; i++) {
+            static_long = 24;
+        }
+    }
+
+    public static void $inline$unknownParameterValuesLong(long start, long end) {
+        for (long i = start; i < end; i++) {
+            static_long = 24;
+        }
+    }
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesLong() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesLong() loop_optimization (after)
+    /// CHECK: <<Const1:i\d+>> IntConstant 1
+    /// CHECK:                 If [<<Const1>>]
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesLong() dead_code_elimination$after_loop_opt (before)
+    /// CHECK:     Phi
+    /// CHECK:     GreaterThanOrEqual
+    /// CHECK:     If
+    /// CHECK:     StaticFieldSet
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesLong() dead_code_elimination$after_loop_opt (after)
+    /// CHECK-NOT: Phi
+    /// CHECK-NOT: GreaterThanOrEqual
+    /// CHECK-NOT: If
+    /// CHECK-NOT: StaticFieldSet
+    public static void $noinline$testKnownParameterValuesLong() {
+        $inline$unknownParameterValuesLong(10L, 1L);
+    }
+
+    // Known limitatation: The loop count calculation would overflow so loop optimization doesn't
+    // know how many trips there are.
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesLong_WithOverflow() loop_optimization (before)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+
+    /// CHECK-START: void Main.$noinline$testKnownParameterValuesLong_WithOverflow() loop_optimization (after)
+    /// CHECK: <<Comp:z\d+>> GreaterThanOrEqual
+    /// CHECK:               If [<<Comp>>]
+    public static void $noinline$testKnownParameterValuesLong_WithOverflow() {
+        $inline$unknownParameterValuesLong(Long.MAX_VALUE, Long.MIN_VALUE);
+    }
+
+    public static void assertIntEquals(int expected, int result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+
+    public static void assertLongEquals(long expected, long result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+}
diff --git a/test/2275-integral-unsigned-arithmetic/Android.bp b/test/2275-integral-unsigned-arithmetic/Android.bp
new file mode 100644
index 0000000000..00770c8133
--- /dev/null
+++ b/test/2275-integral-unsigned-arithmetic/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2275-integral-unsigned-arithmetic`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2275-integral-unsigned-arithmetic",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2275-integral-unsigned-arithmetic-expected-stdout",
+        ":art-run-test-2275-integral-unsigned-arithmetic-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2275-integral-unsigned-arithmetic-expected-stdout",
+    out: ["art-run-test-2275-integral-unsigned-arithmetic-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2275-integral-unsigned-arithmetic-expected-stderr",
+    out: ["art-run-test-2275-integral-unsigned-arithmetic-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2275-integral-unsigned-arithmetic/src/Main.java b/test/2275-integral-unsigned-arithmetic/src/Main.java
index c434ebf7bc..82785309f3 100644
--- a/test/2275-integral-unsigned-arithmetic/src/Main.java
+++ b/test/2275-integral-unsigned-arithmetic/src/Main.java
@@ -28,6 +28,14 @@ public class Main {
     test_Long_remainderUnsigned_no_fold();
     test_Integer_remainderUnsigned();
     test_Long_remainderUnsigned();
+
+    test_Integer_compareUnsigned_in_condition();
+    test_Long_compareUnsigned_in_condition();
+
+    assertEquals($noinline$compareSignedSameOperands(300), IF_TRUE_VALUE);
+
+    test_Integer_doubleUnsignedCompare();
+    test_Integer_doubleUnsignedCompare_Xored();
   }
 
   public static int $noinline$cmpUnsignedInt(int a, int b) {
@@ -348,4 +356,249 @@ public class Main {
           throw new Error("Expected: " + expected + ", found: " + actual);
       }
   }
+
+  public static void assertEquals(boolean expected, boolean actual) {
+      if (expected != actual) {
+          throw new Error("Expected: " + expected + ", found: " + actual);
+      }
+  }
+
+  static final int IF_TRUE_VALUE = -55555;
+  static final int IF_FALSE_VALUE = 99999;
+
+  public static int $noinline$compareUnsignedInt_LT(int a, int b) {
+    return Integer.compareUnsigned(a, b) < 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedInt_LE(int a, int b) {
+    return Integer.compareUnsigned(a, b) <= 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedInt_GT(int a, int b) {
+    return Integer.compareUnsigned(a, b) > 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedInt_GE(int a, int b) {
+    return Integer.compareUnsigned(a, b) >= 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedInt_EQ(int a, int b) {
+    return Integer.compareUnsigned(a, b) == 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedInt_NE(int a, int b) {
+    return Integer.compareUnsigned(a, b) != 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedLong_LT(long a, long b) {
+    return Long.compareUnsigned(a, b) < 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedLong_LE(long a, long b) {
+    return Long.compareUnsigned(a, b) <= 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedLong_GT(long a, long b) {
+    return Long.compareUnsigned(a, b) > 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedLong_GE(long a, long b) {
+    return Long.compareUnsigned(a, b) >= 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedLong_EQ(long a, long b) {
+    return Long.compareUnsigned(a, b) == 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareUnsignedLong_NE(long a, long b) {
+    return Long.compareUnsigned(a, b) != 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static int $noinline$compareSignedSameOperands(long a) {
+    return Long.compare(a, a) >= 0 ? IF_TRUE_VALUE : IF_FALSE_VALUE;
+  }
+
+  public static void test_Integer_compareUnsigned_in_condition() {
+    // <
+    assertEquals($noinline$compareUnsignedInt_LT(10, 20), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_LT(Integer.MIN_VALUE, 0), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_LT(0, 0), IF_FALSE_VALUE);
+
+    // <=
+    assertEquals($noinline$compareUnsignedInt_LE(10, 20), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_LE(Integer.MIN_VALUE, 0), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_LE(0, 0), IF_TRUE_VALUE);
+
+    // >
+    assertEquals($noinline$compareUnsignedInt_GT(10, 20), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_GT(Integer.MIN_VALUE, 0), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_GT(0, 0), IF_FALSE_VALUE);
+
+    // =>
+    assertEquals($noinline$compareUnsignedInt_GE(10, 20), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_GE(Integer.MIN_VALUE, 0), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_GE(0, 0), IF_TRUE_VALUE);
+
+    // ==
+    assertEquals($noinline$compareUnsignedInt_EQ(10, 20), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_EQ(Integer.MIN_VALUE, 0), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_EQ(0, 0), IF_TRUE_VALUE);
+
+    // !=
+    assertEquals($noinline$compareUnsignedInt_NE(10, 20), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_NE(Integer.MIN_VALUE, 0), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedInt_NE(0, 0), IF_FALSE_VALUE);
+  }
+
+  public static void test_Long_compareUnsigned_in_condition() {
+    // <
+    assertEquals($noinline$compareUnsignedLong_LT(10L, 20L), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_LT(Long.MIN_VALUE, 0L), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_LT(0L, 0L), IF_FALSE_VALUE);
+
+    // <=
+    assertEquals($noinline$compareUnsignedLong_LE(10L, 20L), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_LE(Long.MIN_VALUE, 0L), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_LE(0L, 0L), IF_TRUE_VALUE);
+
+    // >
+    assertEquals($noinline$compareUnsignedLong_GT(10L, 20L), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_GT(Long.MIN_VALUE, 0L), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_GT(0L, 0L), IF_FALSE_VALUE);
+
+    // =>
+    assertEquals($noinline$compareUnsignedLong_GE(10L, 20L), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_GE(Long.MIN_VALUE, 0L), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_GE(0L, 0L), IF_TRUE_VALUE);
+
+    // ==
+    assertEquals($noinline$compareUnsignedLong_EQ(10L, 20L), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_EQ(Long.MIN_VALUE, 0L), IF_FALSE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_EQ(0L, 0L), IF_TRUE_VALUE);
+
+    // !=
+    assertEquals($noinline$compareUnsignedLong_NE(10L, 20L), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_NE(Long.MIN_VALUE, 0L), IF_TRUE_VALUE);
+    assertEquals($noinline$compareUnsignedLong_NE(0L, 0L), IF_FALSE_VALUE);
+  }
+
+  private static int $inline$hidden_zero() {
+    return "1".indexOf('1');
+  }
+
+  public static boolean $inline$BelowInteger(int x, int y) {
+    return Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE) < 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_B(int x, int y) {
+    int cmp = Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE);
+    return $inline$BelowInteger(cmp, $inline$hidden_zero());
+  }
+
+  public static boolean $inline$BelowOrEqualInteger(int x, int y) {
+    return Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE) <= 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_BE(int x, int y) {
+    int cmp = Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE);
+    return $inline$BelowOrEqualInteger(cmp, $inline$hidden_zero());
+  }
+
+  public static boolean $inline$AboveInteger(int x, int y) {
+    return Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE) > 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_A(int x, int y) {
+    int cmp = Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE);
+    return $inline$AboveInteger(cmp, $inline$hidden_zero());
+  }
+
+  public static boolean $inline$AboveOrEqualInteger(int x, int y) {
+    return Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE) >= 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_AE(int x, int y) {
+    int cmp = Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE);
+    return $inline$AboveOrEqualInteger(cmp, $inline$hidden_zero());
+  }
+
+  public static void test_Integer_doubleUnsignedCompare() {
+    // <
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_B(0, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_B(Integer.MIN_VALUE, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_B(0, Integer.MIN_VALUE), false);
+
+    // <=
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BE(0, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BE(Integer.MIN_VALUE, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BE(0, Integer.MIN_VALUE), false);
+
+    // >
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_A(0, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_A(Integer.MIN_VALUE, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_A(0, Integer.MIN_VALUE), true);
+
+    // =>
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AE(0, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AE(Integer.MIN_VALUE, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AE(0, Integer.MIN_VALUE), true);
+  }
+
+  public static boolean $inline$BelowInteger_Xored(int x, int y) {
+    return Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE) < 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_BT_Xored(int x, int y) {
+    int cmp = Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE);
+    return $inline$BelowInteger_Xored(cmp, $inline$hidden_zero());
+  }
+
+  public static boolean $inline$BelowOrEqualInteger_Xored(int x, int y) {
+    return Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE) <= 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_BE_Xored(int x, int y) {
+    int cmp = Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE);
+    return $inline$BelowOrEqualInteger_Xored(cmp, $inline$hidden_zero());
+  }
+
+  public static boolean $inline$AboveInteger_Xored(int x, int y) {
+    return Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE) > 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_AT_Xored(int x, int y) {
+    int cmp = Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE);
+    return $inline$AboveInteger_Xored(cmp, $inline$hidden_zero());
+  }
+
+  public static boolean $inline$AboveOrEqualInteger_Xored(int x, int y) {
+    return Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE) >= 0;
+  }
+
+  public static boolean $noinline$testDoubleUnsignedCompareInteger_AE_Xored(int x, int y) {
+    int cmp = Integer.compare(x ^ Integer.MIN_VALUE, y ^ Integer.MIN_VALUE);
+    return $inline$AboveOrEqualInteger_Xored(cmp, $inline$hidden_zero());
+  }
+
+  public static void test_Integer_doubleUnsignedCompare_Xored() {
+    // <
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BT_Xored(0, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BT_Xored(Integer.MIN_VALUE, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BT_Xored(0, Integer.MIN_VALUE), false);
+
+    // <=
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BE_Xored(0, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BE_Xored(Integer.MIN_VALUE, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_BE_Xored(0, Integer.MIN_VALUE), false);
+
+    // >
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AT_Xored(0, 0), false);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AT_Xored(Integer.MIN_VALUE, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AT_Xored(0, Integer.MIN_VALUE), true);
+
+    // =>
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AE_Xored(0, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AE_Xored(Integer.MIN_VALUE, 0), true);
+    assertEquals($noinline$testDoubleUnsignedCompareInteger_AE_Xored(0, Integer.MIN_VALUE), true);
+  }
 }
diff --git a/test/2275-pthread-name/Android.bp b/test/2275-pthread-name/Android.bp
new file mode 100644
index 0000000000..25ddfe7039
--- /dev/null
+++ b/test/2275-pthread-name/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2275-pthread-name`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2275-pthread-name",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-no-test-suite-tag-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2275-pthread-name-expected-stdout",
+        ":art-run-test-2275-pthread-name-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2275-pthread-name-expected-stdout",
+    out: ["art-run-test-2275-pthread-name-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2275-pthread-name-expected-stderr",
+    out: ["art-run-test-2275-pthread-name-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2275-pthread-name/expected-stderr.txt b/test/2275-pthread-name/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2275-pthread-name/expected-stdout.txt b/test/2275-pthread-name/expected-stdout.txt
new file mode 100644
index 0000000000..baf819ce94
--- /dev/null
+++ b/test/2275-pthread-name/expected-stdout.txt
@@ -0,0 +1,10 @@
+JNI_OnLoad called
+Main Started; java name: main
+Pthread name: main
+Child's Java name: birth name
+Setting name from main
+Name was set
+Final child Java name: new name
+Final child pthread name: new name
+Final parent Java name: main
+Final parent pthread name: main
diff --git a/test/2275-pthread-name/info.txt b/test/2275-pthread-name/info.txt
new file mode 100644
index 0000000000..7cdaa631b4
--- /dev/null
+++ b/test/2275-pthread-name/info.txt
@@ -0,0 +1,2 @@
+Check that Thread.setName() and Thread.getName() generally behave reasonably,
+and particularly that the pthread name gets set as expected.
diff --git a/test/2275-pthread-name/native_getname.cc b/test/2275-pthread-name/native_getname.cc
new file mode 100644
index 0000000000..8c2f7ffacd
--- /dev/null
+++ b/test/2275-pthread-name/native_getname.cc
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include "jni.h"
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+
+extern "C" JNIEXPORT void JNICALL Java_Main_printPthreadName(
+    [[maybe_unused]] JNIEnv* env, [[maybe_unused]] jclass klass) {
+  constexpr size_t kBufSize = 20;  // Thread names are at most 16 characters.
+  char name[kBufSize];
+  int ret = pthread_getname_np(pthread_self(), name, kBufSize);
+  if (ret == 0) {
+    printf("%s\n", name);
+  } else {
+    fprintf(stderr, "pthread_getname_np failed: %s\n", strerror(ret));
+  }
+}
diff --git a/test/2275-pthread-name/src/Main.java b/test/2275-pthread-name/src/Main.java
new file mode 100644
index 0000000000..4385bc309f
--- /dev/null
+++ b/test/2275-pthread-name/src/Main.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+public class Main {
+  static volatile boolean name_was_set = false;
+  static final String BIRTH_NAME = "birth name";
+  static final String NEW_NAME = "new name";
+  static final CountDownLatch child_started = new CountDownLatch(1);
+
+  private static class Child implements Runnable {
+    @Override
+    public void run() {
+      String bname = Thread.currentThread().getName();
+      if (!name_was_set && !bname.equals(BIRTH_NAME)) {
+        System.err.println("Wrong birth name: " + bname);
+      }
+      child_started.countDown();
+      while (!name_was_set) {
+        try {
+          Thread.sleep(10);
+        } catch (InterruptedException e) {
+          System.out.println("Unexpected interrupt in child");
+        }
+      }
+      System.out.println("Name was set");
+      System.out.println("Final child Java name: " + Thread.currentThread().getName());
+      System.out.print("Final child pthread name: ");
+      printPthreadName();
+    }
+  }
+
+  public static void main(String[] args) {
+    System.loadLibrary(args[0]);
+    System.out.print("Main Started; java name: ");
+    System.out.println(Thread.currentThread().getName());
+    System.out.print("Pthread name: ");
+    printPthreadName();
+    Thread t = new Thread(new Child(), BIRTH_NAME);
+    System.out.print("Child's Java name: ");
+    System.out.println(t.getName());
+    t.start();
+    try {
+      if (!child_started.await(2, TimeUnit.SECONDS)) {
+        System.out.println("Latch wait timed out");
+      }
+    } catch (InterruptedException e) {
+      System.out.println("Unexpected interrupt in parent");
+    }
+    System.out.println("Setting name from " + Thread.currentThread().getName());
+    t.setName(NEW_NAME);
+    if (!t.getName().equals(NEW_NAME)) {
+      System.err.println("Wrong new name from main thread: " + t.getName());
+    }
+    name_was_set = true;
+    try {
+      t.join();
+    } catch (InterruptedException e) {
+      System.out.println("Unexpected interrupt in join()");
+    }
+    System.out.println("Final parent Java name: " + Thread.currentThread().getName());
+    System.out.print("Final parent pthread name: ");
+    printPthreadName();
+  }
+
+  private static native void printPthreadName();
+}
diff --git a/test/2276-const-method-type-gc-cleanup/build.py b/test/2276-const-method-type-gc-cleanup/build.py
new file mode 100644
index 0000000000..021c3f0827
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/build.py
@@ -0,0 +1,19 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  ctx.default_build(api_level="const-method-type")
diff --git a/test/2276-const-method-type-gc-cleanup/expected-stderr.txt b/test/2276-const-method-type-gc-cleanup/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2276-const-method-type-gc-cleanup/expected-stdout.txt b/test/2276-const-method-type-gc-cleanup/expected-stdout.txt
new file mode 100644
index 0000000000..a49566ef55
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/expected-stdout.txt
@@ -0,0 +1,21 @@
+JNI_OnLoad called
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
+doWork()
+ClassLoader was unloaded
diff --git a/test/2276-const-method-type-gc-cleanup/generate-sources b/test/2276-const-method-type-gc-cleanup/generate-sources
new file mode 100755
index 0000000000..6ac92e3788
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/generate-sources
@@ -0,0 +1,29 @@
+#!/bin/bash
+#
+# Copyright 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# make us exit on a failure
+set -e
+
+export ASM_JAR="${ANDROID_BUILD_TOP}/prebuilts/misc/common/asm/asm-9.6.jar"
+
+# Build the transformer to apply to compiled classes.
+mkdir classes
+${JAVAC:-javac} ${JAVAC_ARGS} -cp "${ASM_JAR}" -d classes $(find src-util -name '*.java')
+${SOONG_ZIP} --jar -o transformer.jar -C classes -D classes
+rm -rf classes
+
+# Add annotation src files to our compiler inputs.
+cp -r src-util/annotations src-ex/
diff --git a/test/2276-const-method-type-gc-cleanup/info.txt b/test/2276-const-method-type-gc-cleanup/info.txt
new file mode 100644
index 0000000000..4d6d3790e8
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/info.txt
@@ -0,0 +1,2 @@
+Calls a method with const-method-type instructions which will be JIT-ed from a class soon to be
+garbage collected.
diff --git a/test/2276-const-method-type-gc-cleanup/javac_post.sh b/test/2276-const-method-type-gc-cleanup/javac_post.sh
new file mode 100755
index 0000000000..d0699d3cd7
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/javac_post.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -e
+
+export ASM_JAR="${ANDROID_BUILD_TOP}/prebuilts/misc/common/asm/asm-9.6.jar"
+
+# Move original classes to intermediate location.
+mv $1 $1-intermediate-classes
+mkdir $1
+
+# Transform intermediate classes.
+transformer_args="-cp ${ASM_JAR}:$PWD/transformer.jar transformer.ConstantTransformer"
+for class in $1-intermediate-classes/*.class ; do
+  transformed_class=$1/$(basename ${class})
+  ${JAVA:-java} ${transformer_args} ${class} ${transformed_class}
+done
+
diff --git a/test/2276-const-method-type-gc-cleanup/run.py b/test/2276-const-method-type-gc-cleanup/run.py
new file mode 100644
index 0000000000..29fe6fe1a7
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/run.py
@@ -0,0 +1,18 @@
+#!/bin/bash
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def run(ctx, args):
+  ctx.default_run(args, secondary_app_image=False)
diff --git a/test/2276-const-method-type-gc-cleanup/src-art/Main.java b/test/2276-const-method-type-gc-cleanup/src-art/Main.java
new file mode 100644
index 0000000000..5563a3f549
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/src-art/Main.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodType;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+public class Main {
+    private static final String DEX_FILE =
+        System.getenv("DEX_LOCATION") + "/2276-const-method-type-gc-cleanup-ex.jar";
+    private static final String LIBRARY_SEARCH_PATH = System.getProperty("java.library.path");
+
+    public static void main(String[] args) throws Throwable {
+        System.loadLibrary(args[0]);
+
+        Class<?> pathClassLoader = Class.forName("dalvik.system.PathClassLoader");
+        if (pathClassLoader == null) {
+            throw new AssertionError("Couldn't find path class loader class");
+        }
+        Constructor<?> constructor =
+            pathClassLoader.getDeclaredConstructor(String.class, String.class, ClassLoader.class);
+
+        // Identical to Worker.returnStringMethodType() and is captured by JIT-ed code.
+        MethodType returnStringMethodType = MethodType.methodType(String.class);
+
+        for (int i = 0; i < 10; ++i) {
+            callDoWork(constructor);
+        }
+
+        Reference.reachabilityFence(returnStringMethodType);
+    }
+
+    private static void callDoWork(Constructor constructor) throws Throwable {
+        WeakReference loaderRef = $noinline$doRealWork(constructor);
+
+        doUnload();
+
+        if (loaderRef.refersTo(null)) {
+            System.out.println("ClassLoader was unloaded");
+        }
+    }
+
+    private static WeakReference $noinline$doRealWork(Constructor constructor) throws Throwable {
+        ClassLoader loader = (ClassLoader) constructor.newInstance(
+                DEX_FILE, LIBRARY_SEARCH_PATH, ClassLoader.getSystemClassLoader());
+
+        Class workerClass = loader.loadClass("Worker");
+
+        if (workerClass.getClassLoader() != loader) {
+            throw new AssertionError("The class was loaded by a wrong ClassLoader");
+        }
+
+        ensureJitCompiled(workerClass, "doWork");
+
+        Method m = workerClass.getDeclaredMethod("doWork");
+        m.invoke(null);
+
+        WeakReference loaderRef = new WeakReference(loader);
+
+        m = null;
+        workerClass = null;
+        loader = null;
+
+        return loaderRef;
+    }
+
+    private static void doUnload() {
+        for (int i = 0; i < 3; ++i) {
+            Runtime.getRuntime().gc();
+            System.runFinalization();
+        }
+    }
+
+    public static native void ensureJitCompiled(Class<?> cls, String methodName);
+}
diff --git a/test/2276-const-method-type-gc-cleanup/src-ex/Worker.java b/test/2276-const-method-type-gc-cleanup/src-ex/Worker.java
new file mode 100644
index 0000000000..e6c9287323
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/src-ex/Worker.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import annotations.ConstantMethodType;
+import annotations.ConstantMethodHandle;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+
+public class Worker {
+
+    private static void unreachable() {
+        throw new Error("unreachable!");
+    }
+
+    private static void assertSame(Object lhs, Object rhs) {
+        if (lhs != rhs) {
+            throw new AssertionError(lhs + " is not equal to " + rhs);
+        }
+    }
+
+    private static void assertNonNull(Object object) {
+        if (object == null) {
+            throw new AssertionError("object is null");
+        }
+    }
+
+    public static String workerToString(Worker worker) {
+        return worker.toString();
+    }
+
+    @ConstantMethodType(
+        returnType = String.class,
+        parameterTypes = {Worker.class})
+    private static MethodType methodType() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodType(
+        returnType = String.class,
+        parameterTypes = {})
+    private static MethodType returnStringMethodType() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "Worker",
+        fieldOrMethodName = "workerToString",
+        descriptor = "(LWorker;)Ljava/lang/String;")
+    private static MethodHandle methodHandle() {
+        unreachable();
+        return null;
+    }
+
+    public static void doWork() {
+        System.out.println("doWork()");
+        MethodType methodType = methodType();
+        MethodHandle methodHandle = methodHandle();
+
+        assertNonNull(methodType);
+        assertNonNull(methodHandle);
+        assertSame(methodType, methodHandle.type());
+
+        assertNonNull(returnStringMethodType());
+    }
+}
diff --git a/test/2276-const-method-type-gc-cleanup/src-util/annotations/ConstantMethodHandle.java b/test/2276-const-method-type-gc-cleanup/src-util/annotations/ConstantMethodHandle.java
new file mode 100644
index 0000000000..40785ebc6e
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/src-util/annotations/ConstantMethodHandle.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation can be set on method to specify that if this method
+ * is statically invoked then the invocation is replaced by a
+ * load-constant bytecode with the MethodHandle constant described by
+ * the annotation.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ConstantMethodHandle {
+    /* Method handle kinds */
+    public static final int STATIC_PUT = 0;
+    public static final int STATIC_GET = 1;
+    public static final int INSTANCE_PUT = 2;
+    public static final int INSTANCE_GET = 3;
+    public static final int INVOKE_STATIC = 4;
+    public static final int INVOKE_VIRTUAL = 5;
+    public static final int INVOKE_SPECIAL = 6;
+    public static final int NEW_INVOKE_SPECIAL = 7;
+    public static final int INVOKE_INTERFACE = 8;
+
+    /** Kind of method handle. */
+    int kind();
+
+    /** Class name owning the field or method. */
+    String owner();
+
+    /** The field or method name addressed by the MethodHandle. */
+    String fieldOrMethodName();
+
+    /** Descriptor for the field (type) or method (method-type) */
+    String descriptor();
+
+    /** Whether the owner is an interface. */
+    boolean ownerIsInterface() default false;
+}
diff --git a/test/2276-const-method-type-gc-cleanup/src-util/annotations/ConstantMethodType.java b/test/2276-const-method-type-gc-cleanup/src-util/annotations/ConstantMethodType.java
new file mode 100644
index 0000000000..c89fa013fe
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/src-util/annotations/ConstantMethodType.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation can be set on method to specify that if this method
+ * is statically invoked then the invocation is replaced by a
+ * load-constant bytecode with the MethodType constant described by
+ * the annotation.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ConstantMethodType {
+    /** Return type of method() or field getter() */
+    Class<?> returnType() default void.class;
+
+    /** Types of parameters for method or field setter() */
+    Class<?>[] parameterTypes() default {};
+}
diff --git a/test/2276-const-method-type-gc-cleanup/src-util/transformer/ConstantTransformer.java b/test/2276-const-method-type-gc-cleanup/src-util/transformer/ConstantTransformer.java
new file mode 100644
index 0000000000..771a2671c3
--- /dev/null
+++ b/test/2276-const-method-type-gc-cleanup/src-util/transformer/ConstantTransformer.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package transformer;
+
+import annotations.ConstantMethodHandle;
+import annotations.ConstantMethodType;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+
+/**
+ * Class for transforming invoke static bytecodes into constant method handle loads and and constant
+ * method type loads.
+ *
+ * <p>When a parameterless private static method returning a MethodHandle is defined and annotated
+ * with {@code ConstantMethodHandle}, this transformer will replace static invocations of the method
+ * with a load constant bytecode with a method handle in the constant pool.
+ *
+ * <p>Suppose a method is annotated as: <code>
+ *  @ConstantMethodHandle(
+ *      kind = ConstantMethodHandle.STATIC_GET,
+ *      owner = "java/lang/Math",
+ *      fieldOrMethodName = "E",
+ *      descriptor = "D"
+ *  )
+ *  private static MethodHandle getMathE() {
+ *      unreachable();
+ *      return null;
+ *  }
+ * </code> Then invocations of {@code getMathE} will be replaced by a load from the constant pool
+ * with the constant method handle described in the {@code ConstantMethodHandle} annotation.
+ *
+ * <p>Similarly, a parameterless private static method returning a {@code MethodType} and annotated
+ * with {@code ConstantMethodType}, will have invocations replaced by a load constant bytecode with
+ * a method type in the constant pool.
+ */
+class ConstantTransformer {
+    static class ConstantBuilder extends ClassVisitor {
+        private final Map<String, ConstantMethodHandle> constantMethodHandles;
+        private final Map<String, ConstantMethodType> constantMethodTypes;
+
+        ConstantBuilder(
+                int api,
+                ClassVisitor cv,
+                Map<String, ConstantMethodHandle> constantMethodHandles,
+                Map<String, ConstantMethodType> constantMethodTypes) {
+            super(api, cv);
+            this.constantMethodHandles = constantMethodHandles;
+            this.constantMethodTypes = constantMethodTypes;
+        }
+
+        @Override
+        public MethodVisitor visitMethod(
+                int access, String name, String desc, String signature, String[] exceptions) {
+            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
+            return new MethodVisitor(this.api, mv) {
+                @Override
+                public void visitMethodInsn(
+                        int opcode, String owner, String name, String desc, boolean itf) {
+                    if (opcode == org.objectweb.asm.Opcodes.INVOKESTATIC) {
+                        ConstantMethodHandle constantMethodHandle = constantMethodHandles.get(name);
+                        if (constantMethodHandle != null) {
+                            insertConstantMethodHandle(constantMethodHandle);
+                            return;
+                        }
+                        ConstantMethodType constantMethodType = constantMethodTypes.get(name);
+                        if (constantMethodType != null) {
+                            insertConstantMethodType(constantMethodType);
+                            return;
+                        }
+                    }
+                    mv.visitMethodInsn(opcode, owner, name, desc, itf);
+                }
+
+                private Type buildMethodType(Class<?> returnType, Class<?>[] parameterTypes) {
+                    Type rType = Type.getType(returnType);
+                    Type[] pTypes = new Type[parameterTypes.length];
+                    for (int i = 0; i < pTypes.length; ++i) {
+                        pTypes[i] = Type.getType(parameterTypes[i]);
+                    }
+                    return Type.getMethodType(rType, pTypes);
+                }
+
+                private int getHandleTag(int kind) {
+                    switch (kind) {
+                        case ConstantMethodHandle.STATIC_PUT:
+                            return Opcodes.H_PUTSTATIC;
+                        case ConstantMethodHandle.STATIC_GET:
+                            return Opcodes.H_GETSTATIC;
+                        case ConstantMethodHandle.INSTANCE_PUT:
+                            return Opcodes.H_PUTFIELD;
+                        case ConstantMethodHandle.INSTANCE_GET:
+                            return Opcodes.H_GETFIELD;
+                        case ConstantMethodHandle.INVOKE_STATIC:
+                            return Opcodes.H_INVOKESTATIC;
+                        case ConstantMethodHandle.INVOKE_VIRTUAL:
+                            return Opcodes.H_INVOKEVIRTUAL;
+                        case ConstantMethodHandle.INVOKE_SPECIAL:
+                            return Opcodes.H_INVOKESPECIAL;
+                        case ConstantMethodHandle.NEW_INVOKE_SPECIAL:
+                            return Opcodes.H_NEWINVOKESPECIAL;
+                        case ConstantMethodHandle.INVOKE_INTERFACE:
+                            return Opcodes.H_INVOKEINTERFACE;
+                    }
+                    throw new Error("Unhandled kind " + kind);
+                }
+
+                private void insertConstantMethodHandle(ConstantMethodHandle constantMethodHandle) {
+                    Handle handle =
+                            new Handle(
+                                    getHandleTag(constantMethodHandle.kind()),
+                                    constantMethodHandle.owner(),
+                                    constantMethodHandle.fieldOrMethodName(),
+                                    constantMethodHandle.descriptor(),
+                                    constantMethodHandle.ownerIsInterface());
+                    mv.visitLdcInsn(handle);
+                }
+
+                private void insertConstantMethodType(ConstantMethodType constantMethodType) {
+                    Type methodType =
+                            buildMethodType(
+                                    constantMethodType.returnType(),
+                                    constantMethodType.parameterTypes());
+                    mv.visitLdcInsn(methodType);
+                }
+            };
+        }
+    }
+
+    private static void throwAnnotationError(
+            Method method, Class<?> annotationClass, String reason) {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Error in annotation ")
+                .append(annotationClass)
+                .append(" on method ")
+                .append(method)
+                .append(": ")
+                .append(reason);
+        throw new Error(sb.toString());
+    }
+
+    private static void checkMethodToBeReplaced(
+            Method method, Class<?> annotationClass, Class<?> returnType) {
+        final int PRIVATE_STATIC = Modifier.STATIC | Modifier.PRIVATE;
+        if ((method.getModifiers() & PRIVATE_STATIC) != PRIVATE_STATIC) {
+            throwAnnotationError(method, annotationClass, " method is not private and static");
+        }
+        if (method.getTypeParameters().length != 0) {
+            throwAnnotationError(method, annotationClass, " method expects parameters");
+        }
+        if (!method.getReturnType().equals(returnType)) {
+            throwAnnotationError(method, annotationClass, " wrong return type");
+        }
+    }
+
+    private static void transform(Path inputClassPath, Path outputClassPath) throws Throwable {
+        Path classLoadPath = inputClassPath.toAbsolutePath().getParent();
+        URLClassLoader classLoader =
+                new URLClassLoader(new URL[] {classLoadPath.toUri().toURL()},
+                                   ClassLoader.getSystemClassLoader());
+        String inputClassName = inputClassPath.getFileName().toString().replace(".class", "");
+        Class<?> inputClass = classLoader.loadClass(inputClassName);
+
+        final Map<String, ConstantMethodHandle> constantMethodHandles = new HashMap<>();
+        final Map<String, ConstantMethodType> constantMethodTypes = new HashMap<>();
+
+        for (Method m : inputClass.getDeclaredMethods()) {
+            ConstantMethodHandle constantMethodHandle = m.getAnnotation(ConstantMethodHandle.class);
+            if (constantMethodHandle != null) {
+                checkMethodToBeReplaced(m, ConstantMethodHandle.class, MethodHandle.class);
+                constantMethodHandles.put(m.getName(), constantMethodHandle);
+                continue;
+            }
+
+            ConstantMethodType constantMethodType = m.getAnnotation(ConstantMethodType.class);
+            if (constantMethodType != null) {
+                checkMethodToBeReplaced(m, ConstantMethodType.class, MethodType.class);
+                constantMethodTypes.put(m.getName(), constantMethodType);
+                continue;
+            }
+        }
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+        try (InputStream is = Files.newInputStream(inputClassPath)) {
+            ClassReader cr = new ClassReader(is);
+            ConstantBuilder cb =
+                    new ConstantBuilder(
+                            Opcodes.ASM7, cw, constantMethodHandles, constantMethodTypes);
+            cr.accept(cb, 0);
+        }
+        try (OutputStream os = Files.newOutputStream(outputClassPath)) {
+            os.write(cw.toByteArray());
+        }
+    }
+
+    public static void main(String[] args) throws Throwable {
+        transform(Paths.get(args[0]), Paths.get(args[1]));
+    }
+}
diff --git a/test/2277-methodhandle-invokeexact/build.py b/test/2277-methodhandle-invokeexact/build.py
new file mode 100644
index 0000000000..d71324961b
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/build.py
@@ -0,0 +1,4 @@
+def build(ctx):
+  # To allow private interface methods.
+  ctx.default_build(javac_source_arg="17",
+                    javac_target_arg="17")
diff --git a/test/2277-methodhandle-invokeexact/expected-stderr.txt b/test/2277-methodhandle-invokeexact/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2277-methodhandle-invokeexact/expected-stdout.txt b/test/2277-methodhandle-invokeexact/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2277-methodhandle-invokeexact/info.txt b/test/2277-methodhandle-invokeexact/info.txt
new file mode 100644
index 0000000000..a1aebb4d77
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/info.txt
@@ -0,0 +1,2 @@
+More MethodHandle.invokeExact tests.
+Here we also add multidex calls to verify implementation details.
diff --git a/test/2277-methodhandle-invokeexact/src-multidex/Multi.java b/test/2277-methodhandle-invokeexact/src-multidex/Multi.java
new file mode 100644
index 0000000000..5f2dcf0093
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src-multidex/Multi.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.WrongMethodTypeException;
+import java.util.Objects;
+import java.util.Optional;
+
+public class Multi {
+    public static MethodHandle $noinline$getMethodHandle() {
+        return OPTIONAL_GET;
+    }
+
+    // MethodHandle comes from a different dex file.
+    public static void $noinline$testMHFromMain(MethodHandle mh) throws Throwable {
+        Optional<Integer> nonEmpty = Optional.<Integer>of(1001);
+        Object result = (Object) mh.invokeExact(nonEmpty);
+        assertEquals("Expected 1001, but got " + result, 1001, result);
+
+        try {
+            mh.invokeExact(nonEmpty);
+            fail("mh.type() is (Optional)Object, but callsite is (Optional)V");
+        } catch (WrongMethodTypeException expected) {}
+    }
+
+    private static void assertEquals(String msg, Object expected, Object actual) {
+        if (!Objects.equals(expected, actual)) {
+            fail(msg);
+        }
+    }
+
+    private static void fail(String msg) {
+      throw new AssertionError(msg);
+    }
+
+    private static final MethodHandle OPTIONAL_GET;
+
+    static {
+        try {
+            OPTIONAL_GET = MethodHandles.lookup()
+                .findVirtual(Optional.class, "get", MethodType.methodType(Object.class));
+        } catch (Throwable t) {
+            throw new RuntimeException(t);
+        }
+    }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Main.java b/test/2277-methodhandle-invokeexact/src/Main.java
new file mode 100644
index 0000000000..bb8c5fec01
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Main.java
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+ import static java.lang.invoke.MethodType.methodType;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.WrongMethodTypeException;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.Optional;
+
+public class Main {
+
+    private static String STATUS = "";
+
+    public static void main(String[] args) throws Throwable {
+      $noinline$testNoArgsCalls();
+      $noinline$testMethodHandleFromOtherDex();
+      Multi.$noinline$testMHFromMain(OPTIONAL_GET);
+      $noinline$testWithArgs();
+      $noinline$nullchecks();
+    }
+
+    private static void $noinline$nullchecks() throws Throwable {
+      try {
+        VOID_METHOD.invokeExact((A) null);
+        unreachable("Receiver is null, should throw NPE");
+      } catch (NullPointerException expected) {}
+
+      try {
+        VOID_METHOD.invokeExact((Main) null);
+        unreachable("Should throw WMTE: input is of wrong type");
+      } catch (WrongMethodTypeException expected) {}
+
+      try {
+        MethodHandle mh = null;
+        mh.invokeExact();
+        unreachable("MethodHandle object is null, should throw NPE");
+      } catch (NullPointerException expected) {}
+    }
+
+    private static void $noinline$testMethodHandleFromOtherDex() throws Throwable {
+      MethodHandle mh = Multi.$noinline$getMethodHandle();
+      Optional<String> nonEmpty = Optional.<String>of("hello");
+      Object returnedObject = mh.invokeExact(nonEmpty);
+      assertEquals("hello", returnedObject);
+
+      try {
+        mh.invokeExact(nonEmpty);
+        unreachable("mh.type() is (Optional)Object, but callsite is (Optional)V");
+      } catch (WrongMethodTypeException expected) {}
+    }
+
+    private static void $noinline$testNoArgsCalls() throws Throwable {
+      VOID_METHOD.invokeExact(new A());
+      assertEquals("A.voidMethod", STATUS);
+
+      int returnedInt = (int) RETURN_INT.invokeExact(new A());
+      assertEquals(42, returnedInt);
+
+      double returnedDouble = (double) RETURN_DOUBLE.invokeExact(new A());
+      assertEquals(42.0d, returnedDouble);
+
+      try {
+        INTERFACE_DEFAULT_METHOD.invokeExact(new A());
+        unreachable("MethodHandle's type is (Main$I)V, but callsite is (Main$A)V");
+      } catch (WrongMethodTypeException expected) {}
+
+      INTERFACE_DEFAULT_METHOD.invokeExact((I) new A());
+      assertEquals("I.defaultMethod", STATUS);
+
+      OVERWRITTEN_INTERFACE_DEFAULT_METHOD.invokeExact((I) new A());
+      assertEquals("A.overrideMe", STATUS);
+
+      assertEquals("boo", (String) PRIVATE_INTERFACE_METHOD.invokeExact((I) new A()));
+
+      int privateIntA = (int) A_PRIVATE_RETURN_INT.invokeExact(new A());
+      assertEquals(1042, privateIntA);
+
+      int privateIntB = (int) B_PRIVATE_RETURN_INT.invokeExact(new B());
+      assertEquals(9999, privateIntB);
+
+      privateIntB = (int) B_PRIVATE_RETURN_INT.invokeExact((B) new A());
+      assertEquals(9999, privateIntB);
+
+      try {
+        EXCEPTION_THROWING_METHOD.invokeExact(new A());
+        unreachable("Target method always throws");
+      } catch (MyRuntimeException expected) {
+        assertEquals("A.throwException", STATUS);
+      }
+
+      try {
+        RETURN_INT.invokeExact(new A());
+        unreachable("MethodHandle's type is (Main$A)I, but callsite type is (Main$A)V");
+      } catch (WrongMethodTypeException expected) {}
+
+      String returnedString = (String) STATIC_METHOD.invokeExact(new A());
+      assertEquals("staticMethod", returnedString);
+    }
+
+    private static void $noinline$testWithArgs() throws Throwable {
+      int sum = (int) SUM_I.invokeExact(new Sums(), 1);
+      assertEquals(1, sum);
+
+      sum = (int) SUM_2I.invokeExact(new Sums(), 1, 2);
+      assertEquals(3, sum);
+
+      sum = (int) SUM_3I.invokeExact(new Sums(), 1, 2, 3);
+      assertEquals(6, sum);
+
+      sum = (int) SUM_4I.invokeExact(new Sums(), 1, 2, 3, 4);
+      assertEquals(10, sum);
+
+      sum = (int) SUM_5I.invokeExact(new Sums(), 1, 2, 3, 4, 5);
+      assertEquals(15, sum);
+
+      sum = (int) SUM_6I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6);
+      assertEquals(21, sum);
+
+      sum = (int) SUM_7I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7);
+      assertEquals(28, sum);
+
+      sum = (int) SUM_8I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8);
+      assertEquals(36, sum);
+
+      sum = (int) SUM_9I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8, 9);
+      assertEquals(45, sum);
+
+      sum = (int) SUM_10I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+      assertEquals(55, sum);
+
+      long lsum = (long) SUM_IJ.invokeExact(new Sums(), 1, 2L);
+      assertEquals(3L, lsum);
+
+      lsum = (long) SUM_2IJ.invokeExact(new Sums(), 1, 2L, 3, 4L);
+      assertEquals(10L, lsum);
+
+      lsum = (long) SUM_3IJ.invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L);
+      assertEquals(21L, lsum);
+
+      lsum = (long) SUM_4IJ.invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L, 7, 8L);
+      assertEquals(36L, lsum);
+
+      lsum = (long) SUM_5IJ.invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L, 7, 8L, 9, 10L);
+      assertEquals(55L, lsum);
+    }
+
+    private static void assertEquals(Object expected, Object actual) {
+      if (!Objects.equals(expected, actual)) {
+        throw new AssertionError("Expected: " + expected + ", got: " + actual);
+      }
+    }
+
+    private static void assertEquals(int expected, int actual) {
+      if (expected != actual) {
+        throw new AssertionError("Expected: " + expected + ", got: " + actual);
+      }
+    }
+
+    private static void assertEquals(long expected, long actual) {
+      if (expected != actual) {
+        throw new AssertionError("Expected: " + expected + ", got: " + actual);
+      }
+    }
+
+    private static void assertEquals(double expected, double actual) {
+      if (expected != actual) {
+        throw new AssertionError("Expected: " + expected + ", got: " + actual);
+      }
+    }
+
+    private static void unreachable(String msg) {
+      throw new AssertionError("Unexpectedly reached this point, but shouldn't: " + msg);
+    }
+
+    private static final MethodHandle VOID_METHOD;
+    private static final MethodHandle RETURN_DOUBLE;
+    private static final MethodHandle RETURN_INT;
+    private static final MethodHandle PRIVATE_INTERFACE_METHOD;
+    private static final MethodHandle B_PRIVATE_RETURN_INT;
+    private static final MethodHandle A_PRIVATE_RETURN_INT;
+    private static final MethodHandle STATIC_METHOD;
+    private static final MethodHandle EXCEPTION_THROWING_METHOD;
+    private static final MethodHandle INTERFACE_DEFAULT_METHOD;
+    private static final MethodHandle OVERWRITTEN_INTERFACE_DEFAULT_METHOD;
+    private static final MethodHandle OPTIONAL_GET;
+
+    private static final MethodHandle SUM_I;
+    private static final MethodHandle SUM_2I;
+    private static final MethodHandle SUM_3I;
+    private static final MethodHandle SUM_4I;
+    private static final MethodHandle SUM_5I;
+    private static final MethodHandle SUM_6I;
+    private static final MethodHandle SUM_7I;
+    private static final MethodHandle SUM_8I;
+    private static final MethodHandle SUM_9I;
+    private static final MethodHandle SUM_10I;
+
+    private static final MethodHandle SUM_IJ;
+    private static final MethodHandle SUM_2IJ;
+    private static final MethodHandle SUM_3IJ;
+    private static final MethodHandle SUM_4IJ;
+    private static final MethodHandle SUM_5IJ;
+
+    static {
+      try {
+        VOID_METHOD = MethodHandles.lookup()
+            .findVirtual(A.class, "voidMethod", methodType(void.class));
+        RETURN_DOUBLE = MethodHandles.lookup()
+            .findVirtual(A.class, "returnDouble", methodType(double.class));
+        RETURN_INT = MethodHandles.lookup()
+            .findVirtual(A.class, "returnInt", methodType(int.class));
+        PRIVATE_INTERFACE_METHOD = MethodHandles.privateLookupIn(I.class, MethodHandles.lookup())
+            .findVirtual(I.class, "innerPrivateMethod", methodType(String.class));
+        A_PRIVATE_RETURN_INT = MethodHandles.privateLookupIn(A.class, MethodHandles.lookup())
+            .findVirtual(A.class, "privateReturnInt", methodType(int.class));
+        B_PRIVATE_RETURN_INT = MethodHandles.privateLookupIn(B.class, MethodHandles.lookup())
+            .findVirtual(B.class, "privateReturnInt", methodType(int.class));
+        STATIC_METHOD = MethodHandles.lookup()
+            .findStatic(A.class, "staticMethod", methodType(String.class, A.class));
+        EXCEPTION_THROWING_METHOD = MethodHandles.lookup()
+            .findVirtual(A.class, "throwException", methodType(void.class));
+        INTERFACE_DEFAULT_METHOD = MethodHandles.lookup()
+            .findVirtual(I.class, "defaultMethod", methodType(void.class));
+        OVERWRITTEN_INTERFACE_DEFAULT_METHOD = MethodHandles.lookup()
+            .findVirtual(I.class, "overrideMe", methodType(void.class));
+        OPTIONAL_GET = MethodHandles.lookup()
+            .findVirtual(Optional.class, "get", methodType(Object.class));
+
+        SUM_I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(1, int.class)));
+        SUM_2I = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(2, int.class)));
+        SUM_3I = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(3, int.class)));
+        SUM_4I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(4, int.class)));
+        SUM_5I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(5, int.class)));
+        SUM_6I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(6, int.class)));
+        SUM_7I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(7, int.class)));
+        SUM_8I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(8, int.class)));
+        SUM_9I  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(9, int.class)));
+        SUM_10I = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(10, int.class)));
+
+        SUM_IJ  = MethodHandles.lookup()
+            .findVirtual(Sums.class, "sum", methodType(long.class, int.class, long.class));
+        SUM_2IJ  = MethodHandles.lookup()
+            .findVirtual(Sums.class,
+                         "sum",
+                         methodType(long.class, repeat(2, int.class, long.class)));
+        SUM_3IJ  = MethodHandles.lookup()
+            .findVirtual(Sums.class,
+                         "sum",
+                         methodType(long.class, repeat(3, int.class, long.class)));
+        SUM_4IJ  = MethodHandles.lookup()
+            .findVirtual(Sums.class,
+                         "sum",
+                         methodType(long.class, repeat(4, int.class, long.class)));
+        SUM_5IJ  = MethodHandles.lookup()
+            .findVirtual(Sums.class,
+                         "sum",
+                         methodType(long.class, repeat(5, int.class, long.class)));
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static Class<?>[] repeat(int times, Class<?> clazz) {
+      Class<?>[] classes = new Class<?>[times];
+      Arrays.fill(classes, clazz);
+      return classes;
+    }
+
+    private static Class<?>[] repeat(int times, Class<?> first, Class<?> second) {
+      Class<?>[] classes = new Class<?>[times * 2];
+      for (int i = 0; i < 2 * times;) {
+        classes[i++] = first;
+        classes[i++] = second;
+      }
+      return classes;
+    }
+
+    static interface I {
+      public default void defaultMethod() {
+        STATUS = "I.defaultMethod";
+      }
+
+      public default void overrideMe() {
+        throw new RuntimeException("should be overwritten");
+      }
+
+      private String innerPrivateMethod() {
+        return "boo";
+      }
+    }
+
+    static class MyRuntimeException extends RuntimeException {}
+
+    static class A extends B implements I {
+        public int field;
+        public void voidMethod() {
+          STATUS = "A.voidMethod";
+        }
+
+        @Override
+        public void overrideMe() {
+          STATUS = "A.overrideMe";
+        }
+
+        public void throwException() {
+          STATUS = "A.throwException";
+          throw new MyRuntimeException();
+        }
+
+        public double returnDouble() {
+          return 42.0d;
+        }
+
+        public int returnInt() {
+          return 42;
+        }
+
+        private int privateReturnInt() {
+          return 1042;
+        }
+
+        public static String staticMethod(A a) {
+          return "staticMethod";
+        }
+
+        public static double staticMethod() {
+          return 41.0d;
+        }
+    }
+
+    static class B {
+      private int privateReturnInt() {
+        return 9999;
+      }
+    }
+
+    static class Sums {
+        public int sum(int a) {
+          return a;
+        }
+
+        public int sum(int a1, int a2) {
+          return a1 + a2;
+        }
+
+        public int sum(int a1, int a2, int a3) {
+          return a1 + a2 + a3;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4) {
+          return a1 + a2 + a3 + a4;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4, int a5) {
+          return a1 + a2 + a3 + a4 + a5;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4, int a5, int a6) {
+          return a1 + a2 + a3 + a4 + a5 + a6;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
+          return a1 + a2 + a3 + a4 + a5 + a6 + a7;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8) {
+          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9) {
+          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9;
+        }
+
+        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9,
+                       int a10) {
+          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
+        }
+
+        public long sum(int a1, long a2) {
+          return a1 + a2;
+        }
+
+        public long sum(int a1, long a2, int a3, long a4) {
+          return a1 + a2 + a3 + a4;
+        }
+
+        public long sum(int a1, long a2, int a3, long a4, int a5, long a6) {
+          return a1 + a2 + a3 + a4 + a5 + a6;
+        }
+
+        public long sum(int a1, long a2, int a3, long a4, int a5, long a6, int a7, long a8) {
+          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
+        }
+
+        public long sum(int a1, long a2, int a3, long a4, int a5, long a6, int a7, long a8, int a9,
+                        long a10) {
+          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
+        }
+    }
+}
diff --git a/test/2278-nested-loops/Android.bp b/test/2278-nested-loops/Android.bp
new file mode 100644
index 0000000000..99120fe4fe
--- /dev/null
+++ b/test/2278-nested-loops/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2278-nested-loops`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2278-nested-loops",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2278-nested-loops-expected-stdout",
+        ":art-run-test-2278-nested-loops-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2278-nested-loops-expected-stdout",
+    out: ["art-run-test-2278-nested-loops-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2278-nested-loops-expected-stderr",
+    out: ["art-run-test-2278-nested-loops-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2278-nested-loops/expected-stderr.txt b/test/2278-nested-loops/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2278-nested-loops/expected-stdout.txt b/test/2278-nested-loops/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2278-nested-loops/info.txt b/test/2278-nested-loops/info.txt
new file mode 100644
index 0000000000..bc49582801
--- /dev/null
+++ b/test/2278-nested-loops/info.txt
@@ -0,0 +1 @@
+Tests that we correctly calculate nested loops.
diff --git a/test/2278-nested-loops/src/Main.java b/test/2278-nested-loops/src/Main.java
new file mode 100644
index 0000000000..48b9a925f1
--- /dev/null
+++ b/test/2278-nested-loops/src/Main.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+    // Numbers have to be inlined for the bug to trigger: we cannot define this as a generic method
+    // that takes e.g. 12 as a parameter. We can define some methods to test different cases. Each
+    // method is the same as doing:
+    //   result = initial_value;
+    //   for (int i = start; i < end; ++i) { result += i * 10; }
+    //   return result;
+    // As long as `end` is 5 or less
+
+    private static int $noinline$nestedLoopCalculation_0_2_12() {
+        int result = 12;
+        for (int outer = 0; outer < 2; ++outer) {
+            int first_inner;
+            for (first_inner = 5; first_inner > outer; first_inner--) {}
+            for (int second_inner = 0; second_inner < 10; second_inner++) {
+                result += first_inner;
+            }
+        }
+        return result;
+    }
+
+    private static int $noinline$nestedLoopCalculation_1_3_12() {
+        int result = 12;
+        for (int outer = 1; outer < 3; ++outer) {
+            int first_inner;
+            for (first_inner = 5; first_inner > outer; first_inner--) {}
+            for (int second_inner = 0; second_inner < 10; second_inner++) {
+                result += first_inner;
+            }
+        }
+        return result;
+    }
+
+    private static int $noinline$nestedLoopCalculation_minus2_2_12() {
+        int result = 12;
+        for (int outer = -2; outer < 2; ++outer) {
+            int first_inner;
+            for (first_inner = 5; first_inner > outer; first_inner--) {}
+            for (int second_inner = 0; second_inner < 10; second_inner++) {
+                result += first_inner;
+            }
+        }
+        return result;
+    }
+
+    private static int $noinline$nestedLoopCalculation_0_5_12() {
+        int result = 12;
+        for (int outer = 0; outer < 5; ++outer) {
+            int first_inner;
+            for (first_inner = 5; first_inner > outer; first_inner--) {}
+            for (int second_inner = 0; second_inner < 10; second_inner++) {
+                result += first_inner;
+            }
+        }
+        return result;
+    }
+
+    public static void main(String[] f) {
+        // 12 + 0 + 10 = 22
+        assertIntEquals(22, $noinline$nestedLoopCalculation_0_2_12());
+        // 12 + 10 + 20 = 42
+        assertIntEquals(42, $noinline$nestedLoopCalculation_1_3_12());
+        // 12 + (-20) + (-10) + 0 + 10 = -8
+        assertIntEquals(-8, $noinline$nestedLoopCalculation_minus2_2_12());
+        // 12 + 0 + 10 + 20 + 30 + 40 = 112
+        assertIntEquals(112, $noinline$nestedLoopCalculation_0_5_12());
+    }
+
+    public static void assertIntEquals(int expected, int result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+}
diff --git a/test/2279-aconfig-flags/Android.bp b/test/2279-aconfig-flags/Android.bp
new file mode 100644
index 0000000000..6b1fcb49ee
--- /dev/null
+++ b/test/2279-aconfig-flags/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2279-aconfig-flags`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2279-aconfig-flags",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2279-aconfig-flags-expected-stdout",
+        ":art-run-test-2279-aconfig-flags-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2279-aconfig-flags-expected-stdout",
+    out: ["art-run-test-2279-aconfig-flags-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2279-aconfig-flags-expected-stderr",
+    out: ["art-run-test-2279-aconfig-flags-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2279-aconfig-flags/build.py b/test/2279-aconfig-flags/build.py
new file mode 100644
index 0000000000..abe80d8bbb
--- /dev/null
+++ b/test/2279-aconfig-flags/build.py
@@ -0,0 +1,20 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  if ctx.jvm:
+    return  # The test does not build on JVM
+  ctx.default_build()
diff --git a/test/2279-aconfig-flags/expected-stderr.txt b/test/2279-aconfig-flags/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2279-aconfig-flags/expected-stdout.txt b/test/2279-aconfig-flags/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2279-aconfig-flags/info.txt b/test/2279-aconfig-flags/info.txt
new file mode 100644
index 0000000000..7cae0c0d9d
--- /dev/null
+++ b/test/2279-aconfig-flags/info.txt
@@ -0,0 +1 @@
+Tests for trunk stable flags
diff --git a/test/2279-aconfig-flags/src/Main.java b/test/2279-aconfig-flags/src/Main.java
new file mode 100644
index 0000000000..4a282db04d
--- /dev/null
+++ b/test/2279-aconfig-flags/src/Main.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import com.android.libcore.Flags;
+
+public class Main {
+    public static void main(String[] args) {
+        if (!isVTrunkStableFlagEnabled()) {
+            throw new AssertionError(
+                    "The value of com.android.libcore.v_apis flag is expected to be true.");
+        }
+    }
+
+    private static boolean isVTrunkStableFlagEnabled() {
+        // The Flags class definition is expected to be in core-libart.jar.
+        return Flags.vApis();
+    }
+
+}
diff --git a/test/2279-aconfig-flags/test-metadata.json b/test/2279-aconfig-flags/test-metadata.json
new file mode 100644
index 0000000000..75f6c0270f
--- /dev/null
+++ b/test/2279-aconfig-flags/test-metadata.json
@@ -0,0 +1,5 @@
+{
+  "build-param": {
+    "jvm-supported": "false"
+  }
+}
diff --git a/test/2279-second-inner-loop-references-first/Android.bp b/test/2279-second-inner-loop-references-first/Android.bp
new file mode 100644
index 0000000000..c9ea73dcf2
--- /dev/null
+++ b/test/2279-second-inner-loop-references-first/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2279-second-inner-loop-references-first`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2279-second-inner-loop-references-first",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2279-second-inner-loop-references-first-expected-stdout",
+        ":art-run-test-2279-second-inner-loop-references-first-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2279-second-inner-loop-references-first-expected-stdout",
+    out: ["art-run-test-2279-second-inner-loop-references-first-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2279-second-inner-loop-references-first-expected-stderr",
+    out: ["art-run-test-2279-second-inner-loop-references-first-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2279-second-inner-loop-references-first/expected-stderr.txt b/test/2279-second-inner-loop-references-first/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2279-second-inner-loop-references-first/expected-stdout.txt b/test/2279-second-inner-loop-references-first/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2279-second-inner-loop-references-first/info.txt b/test/2279-second-inner-loop-references-first/info.txt
new file mode 100644
index 0000000000..8a3a0eb52c
--- /dev/null
+++ b/test/2279-second-inner-loop-references-first/info.txt
@@ -0,0 +1,2 @@
+Tests that we don't crash when optimizing a second inner loop that
+references a deleted instruction from the first one.
diff --git a/test/2279-second-inner-loop-references-first/src/Main.java b/test/2279-second-inner-loop-references-first/src/Main.java
new file mode 100644
index 0000000000..122e370d8c
--- /dev/null
+++ b/test/2279-second-inner-loop-references-first/src/Main.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class Main {
+    public static void main(String[] h) {
+        assertIntEquals(50, $noinline$SecondInnerLoopReferencesFirst());
+    }
+
+    static int $noinline$SecondInnerLoopReferencesFirst() {
+        int f = 0;
+        for (int outer = 0; outer < 5; outer++) {
+            // This will create a Phi[const_3, const_1] that we eliminate in loop optimization
+            byte ab = 3;
+            // This loop will be eliminated but the next loop will be referencing this one as the
+            // `ab` is used in the addition below, which used to lead to a crash. The reason for the
+            // crash is that we are not updating the induction variables correctly and they are
+            // pointing to a deleted instruction.
+            for (int first_inner = 0; first_inner < 5; first_inner++) {
+                ab = 1;
+            }
+            byte i = 0;
+            for (int second_inner = 0; second_inner < 10; second_inner++) {
+                i += ab;
+            }
+            f += (int) i;
+        }
+        return f;
+    }
+
+    public static void assertIntEquals(int expected, int result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+}
diff --git a/test/2281-method-handle-invoke-static-class-unload/build.py b/test/2281-method-handle-invoke-static-class-unload/build.py
new file mode 100644
index 0000000000..7064e56aa6
--- /dev/null
+++ b/test/2281-method-handle-invoke-static-class-unload/build.py
@@ -0,0 +1,18 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.default_build(api_level="const-method-type")
diff --git a/test/2281-method-handle-invoke-static-class-unload/expected-stderr.txt b/test/2281-method-handle-invoke-static-class-unload/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2281-method-handle-invoke-static-class-unload/expected-stdout.txt b/test/2281-method-handle-invoke-static-class-unload/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2281-method-handle-invoke-static-class-unload/info.txt b/test/2281-method-handle-invoke-static-class-unload/info.txt
new file mode 100644
index 0000000000..a8c176cc9f
--- /dev/null
+++ b/test/2281-method-handle-invoke-static-class-unload/info.txt
@@ -0,0 +1 @@
+Ensure that target class of a MethodHandle won't be unloaded.
diff --git a/test/2281-method-handle-invoke-static-class-unload/src-art/Main.java b/test/2281-method-handle-invoke-static-class-unload/src-art/Main.java
new file mode 100644
index 0000000000..8e03fe04bf
--- /dev/null
+++ b/test/2281-method-handle-invoke-static-class-unload/src-art/Main.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import dalvik.system.InMemoryDexClassLoader;
+
+import static java.lang.invoke.MethodType.methodType;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+import java.util.Base64;
+import java.util.List;
+import java.util.function.Consumer;
+
+public class Main {
+    // src-ex/ClassWithAMethod.java
+    private static final String DEX_FILE =
+        "ZGV4CjA0MQC4x9/g6TtIcd5240Zevdlr1D/wRBHV4Tv0BAAAeAAAAHhWNBIAAAAAAAAAADAEAAAW" +
+        "AAAAeAAAAAcAAADQAAAABAAAAOwAAAAAAAAAAAAAAAcAAAAcAQAAAQAAAFQBAAAAAAAAAAAAAPQE" +
+        "AAAAAAAAGgIAAB8CAAAnAgAAOQIAAFACAABTAgAAVgIAAGoCAACOAgAAqgIAAL4CAADfAgAA4gIA" +
+        "AOYCAAD5AgAABQMAABgDAAAeAwAAJgMAADQDAAA7AwAASAMAAAQAAAAGAAAABwAAAAgAAAAJAAAA" +
+        "CgAAAAsAAAAEAAAAAAAAAAAAAAAFAAAABQAAAAAAAAALAAAABgAAAAAAAAAMAAAABgAAABQCAAAB" +
+        "AAIAAQAAAAEAAQANAAAAAQAAABEAAAABAAEAEgAAAAEAAgAUAAAAAwADAAEAAAAEAAIAAQAAAAEA" +
+        "AAABAAAABAAAAAAAAAADAAAAGAQAAPYDAAAAAAAABAAAAAIAAAABAAAAAAAAAPwBAAACAAAAEhAP" +
+        "AAEAAAAAAAAAAAIAAAMAAAD+AAAAEQAAAAEAAAAAAAAABAIAAAUAAABxAAQAAAASABEAAAABAAEA" +
+        "AQAAAAkCAAAEAAAAcBAGAAAADgACAAAAAgAAAA0CAAAIAAAAIgADABoBFABwIAUAEAAnABoADgAs" +
+        "AA4AJwAOPAAYAA4AHgAOAAAAAAEAAAAEAAMoKUkABjxpbml0PgAQQ2xhc3NXaXRoQU1ldGhvZAAV" +
+        "Q2xhc3NXaXRoQU1ldGhvZC5qYXZhAAFJAAFMABJMQ2xhc3NXaXRoQU1ldGhvZDsAIkxhbm5vdGF0" +
+        "aW9ucy9Db25zdGFudE1ldGhvZEhhbmRsZTsAGkxqYXZhL2xhbmcvQXNzZXJ0aW9uRXJyb3I7ABJM" +
+        "amF2YS9sYW5nL09iamVjdDsAH0xqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZTsAAVYAAlZM" +
+        "ABFjb25zdE1ldGhvZEhhbmRsZQAKZGVzY3JpcHRvcgARZmllbGRPck1ldGhvZE5hbWUABGtpbmQA" +
+        "Bm1ldGhvZAAMbWV0aG9kSGFuZGxlAAVvd25lcgALdW5yZWFjaGFibGUAnAF+fkQ4eyJiYWNrZW5k" +
+        "IjoiZGV4IiwiY29tcGlsYXRpb24tbW9kZSI6ImRlYnVnIiwiaGFzLWNoZWNrc3VtcyI6ZmFsc2Us" +
+        "Im1pbi1hcGkiOjI4LCJzaGEtMSI6IjdkZTM3N2E4MGI1MzQ1MGY1Y2ExYTNmYzUwZjZkYzk5M2U3" +
+        "ZThhM2UiLCJ2ZXJzaW9uIjoiOC44LjQtZGV2In0AAQIEDhcADxcREAQEExcCAAAFAACBgATEAwEJ" +
+        "kAMBCfwCAQqoAwEK3AMBAAAA5wMAAAAAAAAAAAAAAQAAAAAAAAADAAAAEAQAABAAAAAAAAAAAQAA" +
+        "AAAAAAABAAAAFgAAAHgAAAACAAAABwAAANAAAAADAAAABAAAAOwAAAAFAAAABwAAABwBAAAGAAAA" +
+        "AQAAAFQBAAAIAAAAAQAAAHQBAAABIAAABQAAAHwBAAADIAAABQAAAPwBAAABEAAAAQAAABQCAAAC" +
+        "IAAAFgAAABoCAAAEIAAAAQAAAOcDAAAAIAAAAQAAAPYDAAADEAAAAQAAABAEAAAGIAAAAQAAABgE" +
+        "AAAAEAAAAQAAADAEAAA=";
+
+    private static final int ITERATIONS = 5;
+
+    public static void main(String[] args) throws Throwable {
+        verify($noinline$getJavaApiMethodHandle());
+        verify($noinline$getConstMethodHandle());
+    }
+
+    private static void verify(MethodHandle mh) {
+        int result = 0;
+        for (int i = 0; i < ITERATIONS; ++i) {
+            try {
+                result += (int) mh.invokeWithArguments(List.of());
+            } catch (Throwable t) {
+                throw new RuntimeException(t);
+            }
+            Runtime.getRuntime().gc();
+            System.runFinalization();
+        }
+
+        if (result != ITERATIONS) {
+            throw new AssertionError();
+        }
+    }
+
+    private static MethodHandle $noinline$getJavaApiMethodHandle() throws Throwable {
+        ClassLoader loader = new InMemoryDexClassLoader(
+            ByteBuffer.wrap(Base64.getDecoder().decode(DEX_FILE)),
+            ClassLoader.getSystemClassLoader());
+        Class<?> clazz = loader.loadClass("ClassWithAMethod");
+        return MethodHandles.publicLookup().findStatic(clazz, "method", methodType(int.class));
+    }
+
+    private static MethodHandle $noinline$getConstMethodHandle() throws Throwable {
+        ClassLoader loader = new InMemoryDexClassLoader(
+            ByteBuffer.wrap(Base64.getDecoder().decode(DEX_FILE)),
+            ClassLoader.getSystemClassLoader());
+        Class<?> clazz = loader.loadClass("ClassWithAMethod");
+
+        return (MethodHandle) clazz.getDeclaredMethod("constMethodHandle").invoke(null);
+    }
+}
\ No newline at end of file
diff --git a/test/2281-method-handle-invoke-static-class-unload/src-ex/ClassWithAMethod.java b/test/2281-method-handle-invoke-static-class-unload/src-ex/ClassWithAMethod.java
new file mode 100644
index 0000000000..a35a3c2967
--- /dev/null
+++ b/test/2281-method-handle-invoke-static-class-unload/src-ex/ClassWithAMethod.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import static java.lang.invoke.MethodType.methodType;
+
+public class ClassWithAMethod {
+    public static int method() {
+        return 1;
+    }
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable");
+    }
+
+    // @ConstantMethodHandle(
+    //     kind = ConstantMethodHandle.INVOKE_STATIC,
+    //     owner = "ClassWithAMethod",
+    //     fieldOrMethodName = "method",
+    //     descriptor = "()I")
+    private static MethodHandle methodHandle() {
+        unreachable();
+        return null;
+    }
+
+    public static MethodHandle constMethodHandle() {
+        return methodHandle();
+    }
+
+}
diff --git a/test/458-checker-riscv64-shift-add/Android.bp b/test/458-checker-riscv64-shift-add/Android.bp
new file mode 100644
index 0000000000..aafc079d24
--- /dev/null
+++ b/test/458-checker-riscv64-shift-add/Android.bp
@@ -0,0 +1,43 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `458-checker-riscv64-shift-add`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-458-checker-riscv64-shift-add",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-458-checker-riscv64-shift-add-expected-stdout",
+        ":art-run-test-458-checker-riscv64-shift-add-expected-stderr",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-458-checker-riscv64-shift-add-expected-stdout",
+    out: ["art-run-test-458-checker-riscv64-shift-add-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-458-checker-riscv64-shift-add-expected-stderr",
+    out: ["art-run-test-458-checker-riscv64-shift-add-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/458-checker-riscv64-shift-add/src/Main.java b/test/458-checker-riscv64-shift-add/src/Main.java
index b78b9551b8..f000c0ce4e 100644
--- a/test/458-checker-riscv64-shift-add/src/Main.java
+++ b/test/458-checker-riscv64-shift-add/src/Main.java
@@ -207,6 +207,20 @@ public class Main {
     return (a << 1) + (b << 4);
   }
 
+  /// CHECK-START-RISCV64: long Main.$noinline$longShiftTooLittleDistance(long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                        Riscv64ShiftAdd
+
+  public static long $noinline$longShiftTooLittleDistance(long a, long b) {
+    return (a << 0) + b;
+  }
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longShiftTooGreatDistance(long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                        Riscv64ShiftAdd
+
+  public static long $noinline$longShiftTooGreatDistance(long a, long b) {
+    return (a << 4) + b;
+  }
+
   /// CHECK-START-RISCV64: long Main.$noinline$longTwoSimplifications(long, long) instruction_simplifier_riscv64 (before)
   /// CHECK:          <<A:j\d+>>         ParameterValue
   /// CHECK:          <<B:j\d+>>         ParameterValue
@@ -234,6 +248,99 @@ public class Main {
     return x ^ y;
   }
 
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsUseShl(long, long, long) instruction_simplifier_riscv64 (before)
+  /// CHECK:          <<A:j\d+>>         ParameterValue
+  /// CHECK:          <<B:j\d+>>         ParameterValue
+  /// CHECK:          <<C:j\d+>>         ParameterValue
+  /// CHECK:          <<One:i\d+>>       IntConstant 1
+  /// CHECK:          <<Shl:j\d+>>       Shl [<<A>>,<<One>>]
+  /// CHECK:          <<X:j\d+>>         Add [<<B>>,<<Shl>>]
+  /// CHECK:          <<Y:j\d+>>         Add [<<C>>,<<Shl>>]
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsUseShl(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK:          <<A:j\d+>>         ParameterValue
+  /// CHECK:          <<B:j\d+>>         ParameterValue
+  /// CHECK:          <<C:j\d+>>         ParameterValue
+  /// CHECK-DAG:      <<ShAdd1:j\d+>>    Riscv64ShiftAdd [<<A>>,<<B>>] distance:1
+  /// CHECK-DAG:      <<ShAdd2:j\d+>>    Riscv64ShiftAdd [<<A>>,<<C>>] distance:1
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsUseShl(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                         Shl
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsUseShl(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                         Add
+
+  public static long $noinline$longTwoAddsUseShl(long a, long b, long c) {
+    long shl = a << 1;
+    long x = shl + b;
+    long y = shl + c;
+    return x ^ y;
+  }
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsMixedOrderUseShl(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-DAG:                         Riscv64ShiftAdd
+  /// CHECK-DAG:                         Riscv64ShiftAdd
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsMixedOrderUseShl(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                         Shl
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoAddsMixedOrderUseShl(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                         Add
+
+  public static long $noinline$longTwoAddsMixedOrderUseShl(long a, long b, long c) {
+    long x = (a << 1) + b;
+    long y = c + (a << 1);
+    return x ^ y;
+  }
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longOneAddSharesShlUse(long, long, long) instruction_simplifier_riscv64 (before)
+  /// CHECK:          <<A:j\d+>>         ParameterValue
+  /// CHECK:          <<B:j\d+>>         ParameterValue
+  /// CHECK:          <<C:j\d+>>         ParameterValue
+  /// CHECK:          <<One:i\d+>>       IntConstant 1
+  /// CHECK:          <<Shl:j\d+>>       Shl [<<A>>,<<One>>]
+  /// CHECK:          <<X:j\d+>>         Add [<<B>>,<<Shl>>]
+  /// CHECK:          <<Y:j\d+>>         Sub [<<Shl>>,<<C>>]
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longOneAddSharesShlUse(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK:          <<A:j\d+>>         ParameterValue
+  /// CHECK:          <<B:j\d+>>         ParameterValue
+  /// CHECK:          <<C:j\d+>>         ParameterValue
+  /// CHECK:          <<One:i\d+>>       IntConstant 1
+  /// CHECK:          <<Shl:j\d+>>       Shl [<<A>>,<<One>>]
+  /// CHECK-DAG:      <<ShAdd:j\d+>>     Riscv64ShiftAdd [<<A>>,<<B>>] distance:1
+  /// CHECK:          <<Y:j\d+>>         Sub [<<Shl>>,<<C>>]
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longOneAddSharesShlUse(long, long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                         Add
+
+  public static long $noinline$longOneAddSharesShlUse(long a, long b, long c) {
+    long shl = a << 1;
+    long x = shl + b;
+    long y = shl - c;
+    return x ^ y;
+  }
+
+  public static void $noinline$returnVoid(long a) {}
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longOneAddSharesShlEnvironmentUse(long, long) instruction_simplifier_riscv64 (after)
+  /// CHECK:                             Shl
+  /// CHECK-DAG:                         Riscv64ShiftAdd
+
+  public static long $noinline$longOneAddSharesShlEnvironmentUse(long a, long b) {
+    long shl = a << 1;
+    long x = shl + b;
+    $noinline$returnVoid(shl);
+    return x;
+  }
+
+  /// CHECK-START-RISCV64: long Main.$noinline$longTwoTheSameShl(long) instruction_simplifier_riscv64 (after)
+  /// CHECK-NOT:                        Riscv64ShiftAdd
+
+  public static long $noinline$longTwoTheSameShl(long a) {
+    return (a << 1) + (a << 1);
+  }
+
   public static void main(String[] args) {
     assertIntEquals(0, $noinline$intRiscvShift1Add(0, 0));
 
@@ -270,6 +377,30 @@ public class Main {
     assertLongEquals(2L, $noinline$longLeftShift(1L, 0L));
     assertLongEquals(4L, $noinline$longLeftShift(2L, 0L));
 
+    assertLongEquals(1L, $noinline$longShiftTooLittleDistance(1L, 0L));
+    assertLongEquals(2L, $noinline$longShiftTooLittleDistance(2L, 0L));
+
+    assertLongEquals(17L, $noinline$longShiftTooGreatDistance(1L, 1L));
+    assertLongEquals(32L, $noinline$longShiftTooGreatDistance(2L, 0L));
+
     assertLongEquals(6L, $noinline$longTwoSimplifications(1L, 1L));
+
+    assertLongEquals(0L, $noinline$longTwoAddsUseShl(1L, 1L, 1L));
+    assertLongEquals(1L, $noinline$longTwoAddsUseShl(1L, 0L, 1L));
+    assertLongEquals(3L, $noinline$longTwoAddsUseShl(0L, 1L, 2L));
+    assertLongEquals(7L, $noinline$longTwoAddsUseShl(1L, 2L, 1L));
+
+    assertLongEquals(0L, $noinline$longTwoAddsMixedOrderUseShl(1L, 1L, 1L));
+    assertLongEquals(1L, $noinline$longTwoAddsMixedOrderUseShl(1L, 0L, 1L));
+    assertLongEquals(3L, $noinline$longTwoAddsMixedOrderUseShl(0L, 1L, 2L));
+
+    assertLongEquals(2L, $noinline$longOneAddSharesShlUse(1L, 1L, 1L));
+    assertLongEquals(3L, $noinline$longOneAddSharesShlUse(1L, 0L, 1L));
+    assertLongEquals(-1L, $noinline$longOneAddSharesShlUse(0L, 1L, 2L));
+    assertLongEquals(5L, $noinline$longOneAddSharesShlUse(1L, 2L, 1L));
+
+    assertLongEquals(3L, $noinline$longOneAddSharesShlEnvironmentUse(1L, 1L));
+
+    assertLongEquals(4L, $noinline$longTwoTheSameShl(1L));
   }
 }
diff --git a/test/567-checker-builder-intrinsics/src/TestRotate.java b/test/567-checker-builder-intrinsics/src/TestRotate.java
index 2037ccf655..40abb1b1d1 100644
--- a/test/567-checker-builder-intrinsics/src/TestRotate.java
+++ b/test/567-checker-builder-intrinsics/src/TestRotate.java
@@ -16,76 +16,163 @@
 
 public class TestRotate {
 
-  /// CHECK-START: int TestRotate.rotateLeftByte(byte, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftByte(byte, int) builder (after)
   /// CHECK:         <<ArgVal:b\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftByte(byte, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftByte(byte, int) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  private static int rotateLeftByte(byte value, int distance) {
+  private static int $inline$rotateLeftByte(byte value, int distance) {
     return Integer.rotateLeft(value, distance);
   }
 
-  /// CHECK-START: int TestRotate.rotateLeftShort(short, int) builder (after)
+  private static int $noinline$rotateLeftByte(byte value, int distance) {
+    return Integer.rotateLeft(value, distance);
+  }
+
+  /// CHECK-START: int TestRotate.$inline$rotateLeftShort(short, int) builder (after)
   /// CHECK:         <<ArgVal:s\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftShort(short, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftShort(short, int) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  private static int rotateLeftShort(short value, int distance) {
+  private static int $inline$rotateLeftShort(short value, int distance) {
     return Integer.rotateLeft(value, distance);
   }
 
-  /// CHECK-START: int TestRotate.rotateLeftChar(char, int) builder (after)
+  private static int $noinline$rotateLeftShort(short value, int distance) {
+    return Integer.rotateLeft(value, distance);
+  }
+
+  /// CHECK-START: int TestRotate.$inline$rotateLeftChar(char, int) builder (after)
   /// CHECK:         <<ArgVal:c\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftChar(char, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftChar(char, int) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  private static int rotateLeftChar(char value, int distance) {
+  private static int $inline$rotateLeftChar(char value, int distance) {
+    return Integer.rotateLeft(value, distance);
+  }
+
+  private static int $noinline$rotateLeftChar(char value, int distance) {
     return Integer.rotateLeft(value, distance);
   }
 
-  /// CHECK-START: int TestRotate.rotateLeftInt(int, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftInt(int, int) builder (after)
   /// CHECK:         <<ArgVal:i\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftInt(int, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftInt(int, int) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  private static int rotateLeftInt(int value, int distance) {
+  private static int $inline$rotateLeftInt(int value, int distance) {
+    return Integer.rotateLeft(value, distance);
+  }
+
+  /// CHECK-START-ARM64: int TestRotate.$noinline$rotateLeftInt(int, int) instruction_simplifier_arm64 (after)
+  /// CHECK:         <<ArgVal:i\d+>>  ParameterValue
+  /// CHECK:         <<ArgDist:i\d+>> ParameterValue
+  /// CHECK-DAG:     <<neg:i\d+>>     Neg [<<ArgDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<neg>>]
+  /// CHECK-DAG:                      Return [<<Result>>]
+
+  /// CHECK-START-ARM64: int TestRotate.$noinline$rotateLeftInt(int, int) disassembly (after)
+  /// CHECK:                           neg {{w\d+}}, {{w\d+}}
+  /// CHECK:                           ror {{w\d+}}, {{w\d+}}, {{w\d+}}
+
+  /// CHECK-START-RISCV64: int TestRotate.$noinline$rotateLeftInt(int, int) disassembly (after)
+  /// CHECK:                           rolw {{a\d+}}, {{a\d+}}, {{a\d+}}
+
+  private static int $noinline$rotateLeftInt(int value, int distance) {
     return Integer.rotateLeft(value, distance);
   }
 
-  /// CHECK-START: long TestRotate.rotateLeftLong(long, int) builder (after)
+  /// CHECK-START-ARM64: int TestRotate.$noinline$rotateLeftIntMulNegDistance(int, int) scheduler (before)
+  /// CHECK:         <<ArgVal:i\d+>>  ParameterValue
+  /// CHECK:         <<ArgDist:i\d+>> ParameterValue
+  /// CHECK-DAG:     <<neg:i\d+>>     Neg [<<ArgDist>>]
+  /// CHECK-DAG:     <<ror:i\d+>>     Ror [<<ArgVal>>,<<neg>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Mul [<<neg>>,<<ror>>]
+  /// CHECK-DAG:                      Return [<<Result>>]
+
+  private static int $noinline$rotateLeftIntMulNegDistance(int value, int distance) {
+    return Integer.rotateLeft(value, distance) * -distance;
+  }
+
+  /// CHECK-START: int TestRotate.$noinline$rotateLeftIntConstant(int) builder (after)
+  /// CHECK:         <<ArgVal:i\d+>>   ParameterValue
+  /// CHECK:         <<Constant:i\d+>> IntConstant 31
+  /// CHECK-DAG:     <<Result:i\d+>>   Rol [<<ArgVal>>,<<Constant>>]
+  /// CHECK-DAG:                       Return [<<Result>>]
+
+  /// CHECK-START-ARM64: int TestRotate.$noinline$rotateLeftIntConstant(int) disassembly (after)
+  /// CHECK:                           ror {{w\d+}}, {{w\d+}}, #1
+
+  /// CHECK-START-RISCV64: int TestRotate.$noinline$rotateLeftIntConstant(int) disassembly (after)
+  /// CHECK:                           roriw {{a\d+}}, {{a\d+}}, 1
+
+  private static int $noinline$rotateLeftIntConstant(int value) {
+    return Integer.rotateLeft(value, 31);
+  }
+
+  /// CHECK-START: long TestRotate.$inline$rotateLeftLong(long, int) builder (after)
   /// CHECK:         <<ArgVal:j\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:j\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:j\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: long TestRotate.rotateLeftLong(long, int) builder (after)
+  /// CHECK-START: long TestRotate.$inline$rotateLeftLong(long, int) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  private static long rotateLeftLong(long value, int distance) {
+  private static long $inline$rotateLeftLong(long value, int distance) {
     return Long.rotateLeft(value, distance);
   }
 
+  /// CHECK-START-ARM64: long TestRotate.$noinline$rotateLeftLong(long, int) instruction_simplifier_arm64 (after)
+  /// CHECK:         <<ArgVal:j\d+>>  ParameterValue
+  /// CHECK:         <<ArgDist:i\d+>> ParameterValue
+  /// CHECK-DAG:     <<neg:i\d+>>     Neg [<<ArgDist>>]
+  /// CHECK-DAG:     <<Result:j\d+>>  Ror [<<ArgVal>>,<<neg>>]
+  /// CHECK-DAG:                      Return [<<Result>>]
+
+  /// CHECK-START-ARM64: long TestRotate.$noinline$rotateLeftLong(long, int) disassembly (after)
+  /// CHECK:                           neg {{w\d+}}, {{w\d+}}
+  /// CHECK:                           ror {{x\d+}}, {{x\d+}}, {{x\d+}}
+
+  /// CHECK-START-RISCV64: long TestRotate.$noinline$rotateLeftLong(long, int) disassembly (after)
+  /// CHECK:                           rol {{a\d+}}, {{a\d+}}, {{a\d+}}
+
+  private static long $noinline$rotateLeftLong(long value, int distance) {
+    return Long.rotateLeft(value, distance);
+  }
+
+  /// CHECK-START: long TestRotate.$noinline$rotateLeftLongConstant(long) builder (after)
+  /// CHECK:         <<ArgVal:j\d+>>   ParameterValue
+  /// CHECK:         <<Constant:i\d+>> IntConstant 63
+  /// CHECK-DAG:     <<Result:j\d+>>   Rol [<<ArgVal>>,<<Constant>>]
+  /// CHECK-DAG:                       Return [<<Result>>]
+
+  /// CHECK-START-ARM64: long TestRotate.$noinline$rotateLeftLongConstant(long) disassembly (after)
+  /// CHECK:                           ror {{x\d+}}, {{x\d+}}, #1
+
+  /// CHECK-START-RISCV64: long TestRotate.$noinline$rotateLeftLongConstant(long) disassembly (after)
+  /// CHECK:                           rori {{a\d+}}, {{a\d+}}, 1
+
+  private static long $noinline$rotateLeftLongConstant(long value) {
+    return Long.rotateLeft(value, 63);
+  }
+
   /// CHECK-START: int TestRotate.rotateRightByte(byte, int) builder (after)
   /// CHECK:         <<ArgVal:b\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
@@ -152,17 +239,20 @@ public class TestRotate {
   }
 
 
-  /// CHECK-START: int TestRotate.rotateLeftIntWithByteDistance(int, byte) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftIntWithByteDistance(int, byte) builder (after)
   /// CHECK:         <<ArgVal:i\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:b\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftIntWithByteDistance(int, byte) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftIntWithByteDistance(int, byte) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  private static int rotateLeftIntWithByteDistance(int value, byte distance) {
+  private static int $inline$rotateLeftIntWithByteDistance(int value, byte distance) {
+    return Integer.rotateLeft(value, distance);
+  }
+
+  private static int $noinline$rotateLeftIntWithByteDistance(int value, byte distance) {
     return Integer.rotateLeft(value, distance);
   }
 
@@ -179,43 +269,52 @@ public class TestRotate {
     return Integer.rotateRight(value, distance);
   }
 
-  /// CHECK-START: int TestRotate.rotateLeftBoolean(boolean, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftBoolean(boolean, int) builder (after)
   /// CHECK:         <<ArgVal:z\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
   /// CHECK-DAG:     <<Zero:i\d+>>    IntConstant 0
   /// CHECK-DAG:     <<One:i\d+>>     IntConstant 1
   /// CHECK-DAG:     <<Val:i\d+>>     Phi [<<One>>,<<Zero>>]
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<Val>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<Val>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftBoolean(boolean, int) builder (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftBoolean(boolean, int) builder (after)
   /// CHECK-NOT:                      InvokeStaticOrDirect
 
-  /// CHECK-START: int TestRotate.rotateLeftBoolean(boolean, int) select_generator (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftBoolean(boolean, int) select_generator (after)
   /// CHECK:         <<ArgVal:z\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
   /// CHECK-DAG:     <<Zero:i\d+>>    IntConstant 0
   /// CHECK-DAG:     <<One:i\d+>>     IntConstant 1
   /// CHECK-DAG:     <<SelVal:i\d+>>  Select [<<Zero>>,<<One>>,<<ArgVal>>]
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<SelVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<SelVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftBoolean(boolean, int) select_generator (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftBoolean(boolean, int) select_generator (after)
   /// CHECK-NOT:                      Phi
 
-  /// CHECK-START: int TestRotate.rotateLeftBoolean(boolean, int) instruction_simplifier$before_codegen (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftBoolean(boolean, int) instruction_simplifier$before_codegen (after)
   /// CHECK:         <<ArgVal:z\d+>>  ParameterValue
   /// CHECK:         <<ArgDist:i\d+>> ParameterValue
-  /// CHECK-DAG:     <<NegDist:i\d+>> Neg [<<ArgDist>>]
-  /// CHECK-DAG:     <<Result:i\d+>>  Ror [<<ArgVal>>,<<NegDist>>]
+  /// CHECK-DAG:     <<Result:i\d+>>  Rol [<<ArgVal>>,<<ArgDist>>]
   /// CHECK-DAG:                      Return [<<Result>>]
 
-  /// CHECK-START: int TestRotate.rotateLeftBoolean(boolean, int) instruction_simplifier$before_codegen (after)
+  /// CHECK-START: int TestRotate.$inline$rotateLeftBoolean(boolean, int) instruction_simplifier$before_codegen (after)
   /// CHECK-NOT:                      Select
 
-  private static int rotateLeftBoolean(boolean value, int distance) {
+  private static int $inline$rotateLeftBoolean(boolean value, int distance) {
+    // Note: D8 would replace the ternary expression `value ? 1 : 0` with `value`
+    // but explicit `if` is preserved.
+    int src;
+    if (value) {
+      src = 1;
+    } else {
+      src = 0;
+    }
+    return Integer.rotateLeft(src, distance);
+  }
+
+  private static int $noinline$rotateLeftBoolean(boolean value, int distance) {
     // Note: D8 would replace the ternary expression `value ? 1 : 0` with `value`
     // but explicit `if` is preserved.
     int src;
@@ -230,99 +329,184 @@ public class TestRotate {
   public static void testRotateLeftBoolean() {
     for (int i = 0; i < 40; i++) {  // overshoot a bit
       int j = i & 31;
-      expectEqualsInt(0, rotateLeftBoolean(false, i));
-      expectEqualsInt(1 << j, rotateLeftBoolean(true, i));
+      expectEqualsInt(0, $inline$rotateLeftBoolean(false, i));
+      expectEqualsInt(1 << j, $inline$rotateLeftBoolean(true, i));
+
+      expectEqualsInt(0, $noinline$rotateLeftBoolean(false, i));
+      expectEqualsInt(1 << j, $noinline$rotateLeftBoolean(true, i));
     }
   }
 
   public static void testRotateLeftByte() {
-    expectEqualsInt(0x00000001, rotateLeftByte((byte)0x01, 0));
-    expectEqualsInt(0x00000002, rotateLeftByte((byte)0x01, 1));
-    expectEqualsInt(0x80000000, rotateLeftByte((byte)0x01, 31));
-    expectEqualsInt(0x00000001, rotateLeftByte((byte)0x01, 32));  // overshoot
-    expectEqualsInt(0xFFFFFF03, rotateLeftByte((byte)0x81, 1));
-    expectEqualsInt(0xFFFFFE07, rotateLeftByte((byte)0x81, 2));
-    expectEqualsInt(0x00000120, rotateLeftByte((byte)0x12, 4));
-    expectEqualsInt(0xFFFF9AFF, rotateLeftByte((byte)0x9A, 8));
+    expectEqualsInt(0x00000001, $inline$rotateLeftByte((byte)0x01, 0));
+    expectEqualsInt(0x00000002, $inline$rotateLeftByte((byte)0x01, 1));
+    expectEqualsInt(0x80000000, $inline$rotateLeftByte((byte)0x01, 31));
+    expectEqualsInt(0x00000001, $inline$rotateLeftByte((byte)0x01, 32));  // overshoot
+    expectEqualsInt(0xFFFFFF03, $inline$rotateLeftByte((byte)0x81, 1));
+    expectEqualsInt(0xFFFFFE07, $inline$rotateLeftByte((byte)0x81, 2));
+    expectEqualsInt(0x00000120, $inline$rotateLeftByte((byte)0x12, 4));
+    expectEqualsInt(0xFFFF9AFF, $inline$rotateLeftByte((byte)0x9A, 8));
+
+    expectEqualsInt(0x00000001, $noinline$rotateLeftByte((byte)0x01, 0));
+    expectEqualsInt(0x00000002, $noinline$rotateLeftByte((byte)0x01, 1));
+    expectEqualsInt(0x80000000, $noinline$rotateLeftByte((byte)0x01, 31));
+    expectEqualsInt(0x00000001, $noinline$rotateLeftByte((byte)0x01, 32));  // overshoot
+    expectEqualsInt(0xFFFFFF03, $noinline$rotateLeftByte((byte)0x81, 1));
+    expectEqualsInt(0xFFFFFE07, $noinline$rotateLeftByte((byte)0x81, 2));
+    expectEqualsInt(0x00000120, $noinline$rotateLeftByte((byte)0x12, 4));
+    expectEqualsInt(0xFFFF9AFF, $noinline$rotateLeftByte((byte)0x9A, 8));
+
     for (int i = 0; i < 40; i++) {  // overshoot a bit
       int j = i & 31;
-      expectEqualsInt(0x00000000, rotateLeftByte((byte)0x0000, i));
-      expectEqualsInt(0xFFFFFFFF, rotateLeftByte((byte)0xFFFF, i));
-      expectEqualsInt((1 << j), rotateLeftByte((byte)0x0001, i));
-      expectEqualsInt((0x12 << j) | (0x12 >>> -j), rotateLeftByte((byte)0x12, i));
+      expectEqualsInt(0x00000000, $inline$rotateLeftByte((byte)0x0000, i));
+      expectEqualsInt(0xFFFFFFFF, $inline$rotateLeftByte((byte)0xFFFF, i));
+      expectEqualsInt((1 << j), $inline$rotateLeftByte((byte)0x0001, i));
+      expectEqualsInt((0x12 << j) | (0x12 >>> -j), $inline$rotateLeftByte((byte)0x12, i));
+
+      expectEqualsInt(0x00000000, $noinline$rotateLeftByte((byte)0x0000, i));
+      expectEqualsInt(0xFFFFFFFF, $noinline$rotateLeftByte((byte)0xFFFF, i));
+      expectEqualsInt((1 << j), $noinline$rotateLeftByte((byte)0x0001, i));
+      expectEqualsInt((0x12 << j) | (0x12 >>> -j), $noinline$rotateLeftByte((byte)0x12, i));
     }
   }
 
   public static void testRotateLeftShort() {
-    expectEqualsInt(0x00000001, rotateLeftShort((short)0x0001, 0));
-    expectEqualsInt(0x00000002, rotateLeftShort((short)0x0001, 1));
-    expectEqualsInt(0x80000000, rotateLeftShort((short)0x0001, 31));
-    expectEqualsInt(0x00000001, rotateLeftShort((short)0x0001, 32));  // overshoot
-    expectEqualsInt(0xFFFF0003, rotateLeftShort((short)0x8001, 1));
-    expectEqualsInt(0xFFFE0007, rotateLeftShort((short)0x8001, 2));
-    expectEqualsInt(0x00012340, rotateLeftShort((short)0x1234, 4));
-    expectEqualsInt(0xFF9ABCFF, rotateLeftShort((short)0x9ABC, 8));
+    expectEqualsInt(0x00000001, $inline$rotateLeftShort((short)0x0001, 0));
+    expectEqualsInt(0x00000002, $inline$rotateLeftShort((short)0x0001, 1));
+    expectEqualsInt(0x80000000, $inline$rotateLeftShort((short)0x0001, 31));
+    expectEqualsInt(0x00000001, $inline$rotateLeftShort((short)0x0001, 32));  // overshoot
+    expectEqualsInt(0xFFFF0003, $inline$rotateLeftShort((short)0x8001, 1));
+    expectEqualsInt(0xFFFE0007, $inline$rotateLeftShort((short)0x8001, 2));
+    expectEqualsInt(0x00012340, $inline$rotateLeftShort((short)0x1234, 4));
+    expectEqualsInt(0xFF9ABCFF, $inline$rotateLeftShort((short)0x9ABC, 8));
+
+    expectEqualsInt(0x00000001, $noinline$rotateLeftShort((short)0x0001, 0));
+    expectEqualsInt(0x00000002, $noinline$rotateLeftShort((short)0x0001, 1));
+    expectEqualsInt(0x80000000, $noinline$rotateLeftShort((short)0x0001, 31));
+    expectEqualsInt(0x00000001, $noinline$rotateLeftShort((short)0x0001, 32));  // overshoot
+    expectEqualsInt(0xFFFF0003, $noinline$rotateLeftShort((short)0x8001, 1));
+    expectEqualsInt(0xFFFE0007, $noinline$rotateLeftShort((short)0x8001, 2));
+    expectEqualsInt(0x00012340, $noinline$rotateLeftShort((short)0x1234, 4));
+    expectEqualsInt(0xFF9ABCFF, $noinline$rotateLeftShort((short)0x9ABC, 8));
+
     for (int i = 0; i < 40; i++) {  // overshoot a bit
       int j = i & 31;
-      expectEqualsInt(0x00000000, rotateLeftShort((short)0x0000, i));
-      expectEqualsInt(0xFFFFFFFF, rotateLeftShort((short)0xFFFF, i));
-      expectEqualsInt((1 << j), rotateLeftShort((short)0x0001, i));
-      expectEqualsInt((0x1234 << j) | (0x1234 >>> -j), rotateLeftShort((short)0x1234, i));
+      expectEqualsInt(0x00000000, $inline$rotateLeftShort((short)0x0000, i));
+      expectEqualsInt(0xFFFFFFFF, $inline$rotateLeftShort((short)0xFFFF, i));
+      expectEqualsInt((1 << j), $inline$rotateLeftShort((short)0x0001, i));
+      expectEqualsInt((0x1234 << j) | (0x1234 >>> -j), $inline$rotateLeftShort((short)0x1234, i));
+
+      expectEqualsInt(0x00000000, $noinline$rotateLeftShort((short)0x0000, i));
+      expectEqualsInt(0xFFFFFFFF, $noinline$rotateLeftShort((short)0xFFFF, i));
+      expectEqualsInt((1 << j), $noinline$rotateLeftShort((short)0x0001, i));
+      expectEqualsInt((0x1234 << j) | (0x1234 >>> -j), $noinline$rotateLeftShort((short)0x1234, i));
     }
   }
 
   public static void testRotateLeftChar() {
-    expectEqualsInt(0x00000001, rotateLeftChar((char)0x0001, 0));
-    expectEqualsInt(0x00000002, rotateLeftChar((char)0x0001, 1));
-    expectEqualsInt(0x80000000, rotateLeftChar((char)0x0001, 31));
-    expectEqualsInt(0x00000001, rotateLeftChar((char)0x0001, 32));  // overshoot
-    expectEqualsInt(0x00010002, rotateLeftChar((char)0x8001, 1));
-    expectEqualsInt(0x00020004, rotateLeftChar((char)0x8001, 2));
-    expectEqualsInt(0x00012340, rotateLeftChar((char)0x1234, 4));
-    expectEqualsInt(0x009ABC00, rotateLeftChar((char)0x9ABC, 8));
-    expectEqualsInt(0x00FF0000, rotateLeftChar((char)0xFF00, 8));
+    expectEqualsInt(0x00000001, $inline$rotateLeftChar((char)0x0001, 0));
+    expectEqualsInt(0x00000002, $inline$rotateLeftChar((char)0x0001, 1));
+    expectEqualsInt(0x80000000, $inline$rotateLeftChar((char)0x0001, 31));
+    expectEqualsInt(0x00000001, $inline$rotateLeftChar((char)0x0001, 32));  // overshoot
+    expectEqualsInt(0x00010002, $inline$rotateLeftChar((char)0x8001, 1));
+    expectEqualsInt(0x00020004, $inline$rotateLeftChar((char)0x8001, 2));
+    expectEqualsInt(0x00012340, $inline$rotateLeftChar((char)0x1234, 4));
+    expectEqualsInt(0x009ABC00, $inline$rotateLeftChar((char)0x9ABC, 8));
+    expectEqualsInt(0x00FF0000, $inline$rotateLeftChar((char)0xFF00, 8));
+
+    expectEqualsInt(0x00000001, $noinline$rotateLeftChar((char)0x0001, 0));
+    expectEqualsInt(0x00000002, $noinline$rotateLeftChar((char)0x0001, 1));
+    expectEqualsInt(0x80000000, $noinline$rotateLeftChar((char)0x0001, 31));
+    expectEqualsInt(0x00000001, $noinline$rotateLeftChar((char)0x0001, 32));  // overshoot
+    expectEqualsInt(0x00010002, $noinline$rotateLeftChar((char)0x8001, 1));
+    expectEqualsInt(0x00020004, $noinline$rotateLeftChar((char)0x8001, 2));
+    expectEqualsInt(0x00012340, $noinline$rotateLeftChar((char)0x1234, 4));
+    expectEqualsInt(0x009ABC00, $noinline$rotateLeftChar((char)0x9ABC, 8));
+    expectEqualsInt(0x00FF0000, $noinline$rotateLeftChar((char)0xFF00, 8));
+
     for (int i = 0; i < 40; i++) {  // overshoot a bit
       int j = i & 31;
-      expectEqualsInt(0x00000000, rotateLeftChar((char)0x0000, i));
-      expectEqualsInt((1 << j), rotateLeftChar((char)0x0001, i));
-      expectEqualsInt((0x1234 << j) | (0x1234 >>> -j), rotateLeftChar((char)0x1234, i));
+      expectEqualsInt(0x00000000, $inline$rotateLeftChar((char)0x0000, i));
+      expectEqualsInt((1 << j), $inline$rotateLeftChar((char)0x0001, i));
+      expectEqualsInt((0x1234 << j) | (0x1234 >>> -j), $inline$rotateLeftChar((char)0x1234, i));
+
+      expectEqualsInt(0x00000000, $noinline$rotateLeftChar((char)0x0000, i));
+      expectEqualsInt((1 << j), $noinline$rotateLeftChar((char)0x0001, i));
+      expectEqualsInt((0x1234 << j) | (0x1234 >>> -j), $noinline$rotateLeftChar((char)0x1234, i));
     }
   }
 
   public static void testRotateLeftInt() {
-    expectEqualsInt(0x00000001, rotateLeftInt(0x00000001, 0));
-    expectEqualsInt(0x00000002, rotateLeftInt(0x00000001, 1));
-    expectEqualsInt(0x80000000, rotateLeftInt(0x00000001, 31));
-    expectEqualsInt(0x00000001, rotateLeftInt(0x00000001, 32));  // overshoot
-    expectEqualsInt(0x00000003, rotateLeftInt(0x80000001, 1));
-    expectEqualsInt(0x00000006, rotateLeftInt(0x80000001, 2));
-    expectEqualsInt(0x23456781, rotateLeftInt(0x12345678, 4));
-    expectEqualsInt(0xBCDEF09A, rotateLeftInt(0x9ABCDEF0, 8));
+    expectEqualsInt(0x00000001, $inline$rotateLeftInt(0x00000001, 0));
+    expectEqualsInt(0x00000002, $inline$rotateLeftInt(0x00000001, 1));
+    expectEqualsInt(0x80000000, $inline$rotateLeftInt(0x00000001, 31));
+    expectEqualsInt(0x00000001, $inline$rotateLeftInt(0x00000001, 32));  // overshoot
+    expectEqualsInt(0x00000003, $inline$rotateLeftInt(0x80000001, 1));
+    expectEqualsInt(0x00000006, $inline$rotateLeftInt(0x80000001, 2));
+    expectEqualsInt(0x23456781, $inline$rotateLeftInt(0x12345678, 4));
+    expectEqualsInt(0xBCDEF09A, $inline$rotateLeftInt(0x9ABCDEF0, 8));
+
+    expectEqualsInt(0x00000001, $noinline$rotateLeftInt(0x00000001, 0));
+    expectEqualsInt(0x00000002, $noinline$rotateLeftInt(0x00000001, 1));
+    expectEqualsInt(0x80000000, $noinline$rotateLeftInt(0x00000001, 31));
+    expectEqualsInt(0x00000001, $noinline$rotateLeftInt(0x00000001, 32));  // overshoot
+    expectEqualsInt(0x00000003, $noinline$rotateLeftInt(0x80000001, 1));
+    expectEqualsInt(0x00000006, $noinline$rotateLeftInt(0x80000001, 2));
+    expectEqualsInt(0x23456781, $noinline$rotateLeftInt(0x12345678, 4));
+    expectEqualsInt(0xBCDEF09A, $noinline$rotateLeftInt(0x9ABCDEF0, 8));
+    expectEqualsInt(0x80000000, $noinline$rotateLeftIntConstant(0x00000001));
+    expectEqualsInt(Integer.MIN_VALUE, $noinline$rotateLeftIntMulNegDistance(1, -2));
+
     for (int i = 0; i < 40; i++) {  // overshoot a bit
       int j = i & 31;
-      expectEqualsInt(0x00000000, rotateLeftInt(0x00000000, i));
-      expectEqualsInt(0xFFFFFFFF, rotateLeftInt(0xFFFFFFFF, i));
-      expectEqualsInt(1 << j, rotateLeftInt(0x00000001, i));
-      expectEqualsInt((0x12345678 << j) | (0x12345678 >>> -j), rotateLeftInt(0x12345678, i));
+      expectEqualsInt(0x00000000, $inline$rotateLeftInt(0x00000000, i));
+      expectEqualsInt(0xFFFFFFFF, $inline$rotateLeftInt(0xFFFFFFFF, i));
+      expectEqualsInt(1 << j, $inline$rotateLeftInt(0x00000001, i));
+      expectEqualsInt((0x12345678 << j) | (0x12345678 >>> -j),
+                      $inline$rotateLeftInt(0x12345678, i));
+
+      expectEqualsInt(0x00000000, $noinline$rotateLeftInt(0x00000000, i));
+      expectEqualsInt(0xFFFFFFFF, $noinline$rotateLeftInt(0xFFFFFFFF, i));
+      expectEqualsInt(1 << j, $noinline$rotateLeftInt(0x00000001, i));
+      expectEqualsInt((0x12345678 << j) | (0x12345678 >>> -j),
+                      $noinline$rotateLeftInt(0x12345678, i));
     }
   }
 
   public static void testRotateLeftLong() {
-    expectEqualsLong(0x0000000000000001L, rotateLeftLong(0x0000000000000001L, 0));
-    expectEqualsLong(0x0000000000000002L, rotateLeftLong(0x0000000000000001L, 1));
-    expectEqualsLong(0x8000000000000000L, rotateLeftLong(0x0000000000000001L, 63));
-    expectEqualsLong(0x0000000000000001L, rotateLeftLong(0x0000000000000001L, 64));  // overshoot
-    expectEqualsLong(0x0000000000000003L, rotateLeftLong(0x8000000000000001L, 1));
-    expectEqualsLong(0x0000000000000006L, rotateLeftLong(0x8000000000000001L, 2));
-    expectEqualsLong(0x23456789ABCDEF01L, rotateLeftLong(0x123456789ABCDEF0L, 4));
-    expectEqualsLong(0x3456789ABCDEF012L, rotateLeftLong(0x123456789ABCDEF0L, 8));
+    expectEqualsLong(0x0000000000000001L, $inline$rotateLeftLong(0x0000000000000001L, 0));
+    expectEqualsLong(0x0000000000000002L, $inline$rotateLeftLong(0x0000000000000001L, 1));
+    expectEqualsLong(0x8000000000000000L, $inline$rotateLeftLong(0x0000000000000001L, 63));
+    expectEqualsLong(0x8000000000000000L, $noinline$rotateLeftLongConstant(0x0000000000000001L));
+    expectEqualsLong(0x0000000000000001L,
+                     $inline$rotateLeftLong(0x0000000000000001L, 64));  // overshoot
+    expectEqualsLong(0x0000000000000003L, $inline$rotateLeftLong(0x8000000000000001L, 1));
+    expectEqualsLong(0x0000000000000006L, $inline$rotateLeftLong(0x8000000000000001L, 2));
+    expectEqualsLong(0x23456789ABCDEF01L, $inline$rotateLeftLong(0x123456789ABCDEF0L, 4));
+    expectEqualsLong(0x3456789ABCDEF012L, $inline$rotateLeftLong(0x123456789ABCDEF0L, 8));
+
+    expectEqualsLong(0x0000000000000001L, $noinline$rotateLeftLong(0x0000000000000001L, 0));
+    expectEqualsLong(0x0000000000000002L, $noinline$rotateLeftLong(0x0000000000000001L, 1));
+    expectEqualsLong(0x8000000000000000L, $noinline$rotateLeftLong(0x0000000000000001L, 63));
+    expectEqualsLong(0x0000000000000001L,
+                     $noinline$rotateLeftLong(0x0000000000000001L, 64));  // overshoot
+    expectEqualsLong(0x0000000000000003L, $noinline$rotateLeftLong(0x8000000000000001L, 1));
+    expectEqualsLong(0x0000000000000006L, $noinline$rotateLeftLong(0x8000000000000001L, 2));
+    expectEqualsLong(0x23456789ABCDEF01L, $noinline$rotateLeftLong(0x123456789ABCDEF0L, 4));
+    expectEqualsLong(0x3456789ABCDEF012L, $noinline$rotateLeftLong(0x123456789ABCDEF0L, 8));
     for (int i = 0; i < 70; i++) {  // overshoot a bit
       int j = i & 63;
-      expectEqualsLong(0x0000000000000000L, rotateLeftLong(0x0000000000000000L, i));
-      expectEqualsLong(0xFFFFFFFFFFFFFFFFL, rotateLeftLong(0xFFFFFFFFFFFFFFFFL, i));
-      expectEqualsLong(1L << j, rotateLeftLong(0x0000000000000001, i));
+      expectEqualsLong(0x0000000000000000L, $inline$rotateLeftLong(0x0000000000000000L, i));
+      expectEqualsLong(0xFFFFFFFFFFFFFFFFL, $inline$rotateLeftLong(0xFFFFFFFFFFFFFFFFL, i));
+      expectEqualsLong(1L << j, $inline$rotateLeftLong(0x0000000000000001, i));
+      expectEqualsLong((0x123456789ABCDEF0L << j) | (0x123456789ABCDEF0L >>> -j),
+                       $inline$rotateLeftLong(0x123456789ABCDEF0L, i));
+
+      expectEqualsLong(0x0000000000000000L, $noinline$rotateLeftLong(0x0000000000000000L, i));
+      expectEqualsLong(0xFFFFFFFFFFFFFFFFL, $noinline$rotateLeftLong(0xFFFFFFFFFFFFFFFFL, i));
+      expectEqualsLong(1L << j, $noinline$rotateLeftLong(0x0000000000000001, i));
       expectEqualsLong((0x123456789ABCDEF0L << j) | (0x123456789ABCDEF0L >>> -j),
-                       rotateLeftLong(0x123456789ABCDEF0L, i));
+                       $noinline$rotateLeftLong(0x123456789ABCDEF0L, i));
     }
   }
 
@@ -471,21 +655,39 @@ public class TestRotate {
 
 
   public static void testRotateLeftIntWithByteDistance() {
-    expectEqualsInt(0x00000001, rotateLeftIntWithByteDistance(0x00000001, (byte)0));
-    expectEqualsInt(0x00000002, rotateLeftIntWithByteDistance(0x00000001, (byte)1));
-    expectEqualsInt(0x80000000, rotateLeftIntWithByteDistance(0x00000001, (byte)31));
-    expectEqualsInt(0x00000001, rotateLeftIntWithByteDistance(0x00000001, (byte)32));  // overshoot
-    expectEqualsInt(0x00000003, rotateLeftIntWithByteDistance(0x80000001, (byte)1));
-    expectEqualsInt(0x00000006, rotateLeftIntWithByteDistance(0x80000001, (byte)2));
-    expectEqualsInt(0x23456781, rotateLeftIntWithByteDistance(0x12345678, (byte)4));
-    expectEqualsInt(0xBCDEF09A, rotateLeftIntWithByteDistance(0x9ABCDEF0, (byte)8));
+    expectEqualsInt(0x00000001, $inline$rotateLeftIntWithByteDistance(0x00000001, (byte)0));
+    expectEqualsInt(0x00000002, $inline$rotateLeftIntWithByteDistance(0x00000001, (byte)1));
+    expectEqualsInt(0x80000000, $inline$rotateLeftIntWithByteDistance(0x00000001, (byte)31));
+    expectEqualsInt(0x00000001,
+                    $inline$rotateLeftIntWithByteDistance(0x00000001, (byte)32));  // overshoot
+    expectEqualsInt(0x00000003, $inline$rotateLeftIntWithByteDistance(0x80000001, (byte)1));
+    expectEqualsInt(0x00000006, $inline$rotateLeftIntWithByteDistance(0x80000001, (byte)2));
+    expectEqualsInt(0x23456781, $inline$rotateLeftIntWithByteDistance(0x12345678, (byte)4));
+    expectEqualsInt(0xBCDEF09A, $inline$rotateLeftIntWithByteDistance(0x9ABCDEF0, (byte)8));
+
+    expectEqualsInt(0x00000001, $noinline$rotateLeftIntWithByteDistance(0x00000001, (byte)0));
+    expectEqualsInt(0x00000002, $noinline$rotateLeftIntWithByteDistance(0x00000001, (byte)1));
+    expectEqualsInt(0x80000000, $noinline$rotateLeftIntWithByteDistance(0x00000001, (byte)31));
+    expectEqualsInt(0x00000001,
+                    $noinline$rotateLeftIntWithByteDistance(0x00000001, (byte)32));  // overshoot
+    expectEqualsInt(0x00000003, $noinline$rotateLeftIntWithByteDistance(0x80000001, (byte)1));
+    expectEqualsInt(0x00000006, $noinline$rotateLeftIntWithByteDistance(0x80000001, (byte)2));
+    expectEqualsInt(0x23456781, $noinline$rotateLeftIntWithByteDistance(0x12345678, (byte)4));
+    expectEqualsInt(0xBCDEF09A, $noinline$rotateLeftIntWithByteDistance(0x9ABCDEF0, (byte)8));
+
     for (byte i = 0; i < 40; i++) {  // overshoot a bit
       byte j = (byte)(i & 31);
-      expectEqualsInt(0x00000000, rotateLeftIntWithByteDistance(0x00000000, i));
-      expectEqualsInt(0xFFFFFFFF, rotateLeftIntWithByteDistance(0xFFFFFFFF, i));
-      expectEqualsInt(1 << j, rotateLeftIntWithByteDistance(0x00000001, i));
+      expectEqualsInt(0x00000000, $inline$rotateLeftIntWithByteDistance(0x00000000, i));
+      expectEqualsInt(0xFFFFFFFF, $inline$rotateLeftIntWithByteDistance(0xFFFFFFFF, i));
+      expectEqualsInt(1 << j, $inline$rotateLeftIntWithByteDistance(0x00000001, i));
+      expectEqualsInt((0x12345678 << j) | (0x12345678 >>> -j),
+                      $inline$rotateLeftIntWithByteDistance(0x12345678, i));
+
+      expectEqualsInt(0x00000000, $noinline$rotateLeftIntWithByteDistance(0x00000000, i));
+      expectEqualsInt(0xFFFFFFFF, $noinline$rotateLeftIntWithByteDistance(0xFFFFFFFF, i));
+      expectEqualsInt(1 << j, $noinline$rotateLeftIntWithByteDistance(0x00000001, i));
       expectEqualsInt((0x12345678 << j) | (0x12345678 >>> -j),
-                      rotateLeftIntWithByteDistance(0x12345678, i));
+                      $noinline$rotateLeftIntWithByteDistance(0x12345678, i));
     }
   }
 
@@ -493,7 +695,8 @@ public class TestRotate {
     expectEqualsInt(0x80000000, rotateRightIntWithByteDistance(0x80000000, (byte)0));
     expectEqualsInt(0x40000000, rotateRightIntWithByteDistance(0x80000000, (byte)1));
     expectEqualsInt(0x00000001, rotateRightIntWithByteDistance(0x80000000, (byte)31));
-    expectEqualsInt(0x80000000, rotateRightIntWithByteDistance(0x80000000, (byte)32));  // overshoot
+    expectEqualsInt(0x80000000,
+                    rotateRightIntWithByteDistance(0x80000000, (byte)32));  // overshoot
     expectEqualsInt(0xC0000000, rotateRightIntWithByteDistance(0x80000001, (byte)1));
     expectEqualsInt(0x60000000, rotateRightIntWithByteDistance(0x80000001, (byte)2));
     expectEqualsInt(0x81234567, rotateRightIntWithByteDistance(0x12345678, (byte)4));
diff --git a/test/663-checker-select-generator/src/Main.java b/test/663-checker-select-generator/src/Main.java
index be2344fa24..1a185fbc62 100644
--- a/test/663-checker-select-generator/src/Main.java
+++ b/test/663-checker-select-generator/src/Main.java
@@ -15,8 +15,8 @@
  */
 
 public class Main {
-  // Check that we don't generate a select since we don't have no Phi (not even at the builder
-  // stage) since both values are the same.
+  // Check that we don't generate a select since we don't have a Phi (not even at
+  // the builder stage) since both values are the same.
 
   /// CHECK-START: int Main.$noinline$testSimpleDiamondSameValue(boolean) builder (after)
   /// CHECK-NOT: Phi
@@ -193,16 +193,25 @@ public class Main {
     }
   }
 
-  // Check that we don't generate a select since we only have a single return.
+  // Check that we generate a select, which we collapse into a single return.
 
   /// CHECK-START: int Main.$noinline$testSimpleDiamondSameValueWithReturn(boolean) builder (after)
   /// CHECK:       <<Const10:i\d+>> IntConstant 10
   /// CHECK:       Return [<<Const10>>]
+  /// CHECK:       Return [<<Const10>>]
 
-  /// CHECK-START: int Main.$noinline$testSimpleDiamondSameValueWithReturn(boolean) builder (after)
+  /// CHECK-START: int Main.$noinline$testSimpleDiamondSameValueWithReturn(boolean) select_generator (after)
+  /// CHECK-DAG:   <<Bool:z\d+>>   ParameterValue
+  /// CHECK-DAG:   <<Const10:i\d+>> IntConstant 10
+  /// CHECK-DAG:   <<Select:i\d+>>  Select [<<Const10>>,<<Const10>>,<<Bool>>]
+
+  /// CHECK-START: int Main.$noinline$testSimpleDiamondSameValueWithReturn(boolean) instruction_simplifier$after_gvn (after)
+  /// CHECK:       <<Const10:i\d+>> IntConstant 10
+  /// CHECK:       Return [<<Const10>>]
+
+  /// CHECK-START: int Main.$noinline$testSimpleDiamondSameValueWithReturn(boolean) instruction_simplifier$after_gvn (after)
   /// CHECK:       Return
   /// CHECK-NOT:   Return
-
   private static int $noinline$testSimpleDiamondSameValueWithReturn(boolean bool_param) {
     if (bool_param) {
       return 10;
@@ -233,13 +242,26 @@ public class Main {
     }
   }
 
-  // Check that we don't generate a select since we only have a single return.
+  // Check that we generate a select, which we collapse into a single return.
 
   /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueWithReturn(boolean, boolean) builder (after)
   /// CHECK:       <<Const10:i\d+>> IntConstant 10
   /// CHECK:       Return [<<Const10>>]
+  /// CHECK:       Return [<<Const10>>]
 
-  /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueWithReturn(boolean, boolean) builder (after)
+  /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueWithReturn(boolean, boolean) select_generator (after)
+  /// CHECK-DAG:   <<Bool1:z\d+>>   ParameterValue
+  /// CHECK-DAG:   <<Bool2:z\d+>>   ParameterValue
+  /// CHECK-DAG:   <<Const10:i\d+>> IntConstant 10
+  /// CHECK-DAG:   <<Select:i\d+>>  Select [<<Const10>>,<<Const10>>,<<Bool2>>]
+  /// CHECK-DAG:   <<Select2:i\d+>> Select [<<Select>>,<<Const10>>,<<Bool1>>]
+  /// CHECK-DAG:                    Return [<<Select2>>]
+
+  /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueWithReturn(boolean, boolean) instruction_simplifier$after_gvn (after)
+  /// CHECK:       <<Const10:i\d+>> IntConstant 10
+  /// CHECK:       Return [<<Const10>>]
+
+  /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueWithReturn(boolean, boolean) instruction_simplifier$after_gvn (after)
   /// CHECK:       Return
   /// CHECK-NOT:   Return
   private static int $noinline$testDoubleDiamondSameValueWithReturn(boolean bool_param_1, boolean bool_param_2) {
@@ -261,18 +283,21 @@ public class Main {
   /// CHECK-DAG:   <<Const20:i\d+>> IntConstant 20
   /// CHECK-DAG:                    Return [<<Const10>>]
   /// CHECK-DAG:                    Return [<<Const20>>]
+  /// CHECK-DAG:                    Return [<<Const20>>]
 
-  // Note that we have 2 returns instead of 3 as the two `return 20;` get merged into one before `select_generator`.
+  // Note that we have 3 returns as D8 only merges when the line positions are equal.
   /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueButNotAllOuterWithReturn(boolean, boolean) select_generator (before)
   /// CHECK:                    Return
   /// CHECK:                    Return
-  /// CHECK-NOT:                Return
+  /// CHECK:                    Return
 
   /// CHECK-START: int Main.$noinline$testDoubleDiamondSameValueButNotAllOuterWithReturn(boolean, boolean) select_generator (after)
   /// CHECK-DAG:   <<Bool1:z\d+>>   ParameterValue
+  /// CHECK-DAG:   <<Bool2:z\d+>>   ParameterValue
   /// CHECK-DAG:   <<Const10:i\d+>> IntConstant 10
   /// CHECK-DAG:   <<Const20:i\d+>> IntConstant 20
-  /// CHECK-DAG:   <<Select2:i\d+>> Select [<<Const20>>,<<Const10>>,<<Bool1>>]
+  /// CHECK-DAG:   <<Select:i\d+>>  Select [<<Const20>>,<<Const20>>,<<Bool2>>]
+  /// CHECK-DAG:   <<Select2:i\d+>> Select [<<Select>>,<<Const10>>,<<Bool1>>]
   /// CHECK-DAG:                    Return [<<Select2>>]
   private static int $noinline$testDoubleDiamondSameValueButNotAllOuterWithReturn(boolean bool_param_1, boolean bool_param_2) {
     if (bool_param_1) {
diff --git a/test/855-native/Android.bp b/test/855-native/Android.bp
new file mode 100644
index 0000000000..0f1529d6c8
--- /dev/null
+++ b/test/855-native/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `855-native`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-855-native",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-no-test-suite-tag-template",
+    srcs: ["src-art/**/*.java"],
+    data: [
+        ":art-run-test-855-native-expected-stdout",
+        ":art-run-test-855-native-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-855-native-expected-stdout",
+    out: ["art-run-test-855-native-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-855-native-expected-stderr",
+    out: ["art-run-test-855-native-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/856-clone/Android.bp b/test/856-clone/Android.bp
new file mode 100644
index 0000000000..00e47b727b
--- /dev/null
+++ b/test/856-clone/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `856-clone`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-856-clone",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-856-clone-expected-stdout",
+        ":art-run-test-856-clone-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-856-clone-expected-stdout",
+    out: ["art-run-test-856-clone-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-856-clone-expected-stderr",
+    out: ["art-run-test-856-clone-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/857-default-access/Android.bp b/test/857-default-access/Android.bp
new file mode 100644
index 0000000000..48e21b9f77
--- /dev/null
+++ b/test/857-default-access/Android.bp
@@ -0,0 +1,50 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `857-default-access`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Library with src/ sources for the test.
+java_library {
+    name: "art-run-test-857-default-access-src",
+    defaults: ["art-run-test-defaults"],
+    srcs: ["src/**/*.java"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-857-default-access",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src2/**/*.java"],
+    static_libs: [
+        "art-run-test-857-default-access-src",
+    ],
+    data: [
+        ":art-run-test-857-default-access-expected-stdout",
+        ":art-run-test-857-default-access-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-857-default-access-expected-stdout",
+    out: ["art-run-test-857-default-access-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-857-default-access-expected-stderr",
+    out: ["art-run-test-857-default-access-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/858-checker-unsafe/expected-stderr.txt b/test/858-checker-unsafe/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/858-checker-unsafe/expected-stdout.txt b/test/858-checker-unsafe/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/858-checker-unsafe/info.txt b/test/858-checker-unsafe/info.txt
new file mode 100644
index 0000000000..2c91897412
--- /dev/null
+++ b/test/858-checker-unsafe/info.txt
@@ -0,0 +1 @@
+Test optimizations we generate for Unsafe.put.
diff --git a/test/858-checker-unsafe/src/Main.java b/test/858-checker-unsafe/src/Main.java
new file mode 100644
index 0000000000..dbd96a7ac9
--- /dev/null
+++ b/test/858-checker-unsafe/src/Main.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import sun.misc.Unsafe;
+
+public class Main {
+  private static Unsafe getUnsafe() throws NoSuchFieldException, IllegalAccessException {
+    Class<?> unsafeClass = Unsafe.class;
+    Field f = unsafeClass.getDeclaredField("theUnsafe");
+    f.setAccessible(true);
+    return (Unsafe) f.get(null);
+  }
+
+  private static Unsafe unsafe;
+
+  static void assertEquals(int expected, int actual) {
+    if (expected != actual) {
+      throw new Error("Expected " + expected + ", got " + actual);
+    }
+  }
+
+  public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
+    unsafe = getUnsafe();
+    testPutZero();
+    testPutFixedOffset();
+    assertEquals(0, testGet());
+    assertEquals(42, testGetFar());
+  }
+
+  /// CHECK-START-ARM64: void Main.testPutZero() disassembly (after)
+  /// CHECK:                  str wzr, [x{{[0-9]+}}, #12]
+  private static void testPutZero() {
+    int[] object = new int[42];
+    unsafe.putInt(object, unsafe.arrayBaseOffset(int[].class), 0);
+  }
+
+  /// CHECK-START-ARM64: void Main.testPutFixedOffset() disassembly (after)
+  /// CHECK:                  stur w{{[0-9]+}}, [x{{[0-9]+}}, #38]
+  private static void testPutFixedOffset() {
+    int[] object = new int[42];
+    unsafe.putInt(object, 38, 12);
+  }
+
+  /// CHECK-START-ARM64: int Main.testGet() disassembly (after)
+  /// CHECK:                  ldur w{{[0-9]+}}, [x{{[0-9]+}}, #38]
+  private static int testGet() {
+    int[] object = new int[42];
+    return unsafe.getInt(object, 38);
+  }
+
+  private static int testGetFar() {
+    int offset = 32 * 1024;
+    int arraySize = offset / 4;
+    int[] object = new int[arraySize];
+    unsafe.putInt(object, offset, 42);
+    return unsafe.getInt(object, offset);
+  }
+
+  /// CHECK-START: int Main.testArrayBaseOffsetObject() instruction_simplifier (after)
+  /// CHECK:                  IntConstant 12
+  private static int testArrayBaseOffsetObject() {
+    return unsafe.arrayBaseOffset(Object[].class);
+  }
+
+  /// CHECK-START: int Main.testArrayBaseOffsetInt() instruction_simplifier (after)
+  /// CHECK:                  IntConstant 12
+  private static int testArrayBaseOffsetInt() {
+    return unsafe.arrayBaseOffset(int[].class);
+  }
+
+  /// CHECK-START: int Main.testArrayBaseOffsetDouble() instruction_simplifier (after)
+  /// CHECK:                  IntConstant 16
+  private static int testArrayBaseOffsetDouble() {
+    return unsafe.arrayBaseOffset(double[].class);
+  }
+}
diff --git a/test/979-const-method-handle/src/Main.java b/test/979-const-method-handle/src/Main.java
index 72d529b68b..17d5d91c50 100644
--- a/test/979-const-method-handle/src/Main.java
+++ b/test/979-const-method-handle/src/Main.java
@@ -29,7 +29,7 @@ class Main {
      * Number of iterations run to attempt to trigger JIT compilation. These tests run on ART and
      * the RI so they iterate rather than using the ART only native method ensureJitCompiled().
      */
-    private static final int ITERATIONS_FOR_JIT = 12000;
+    private static final int ITERATIONS_FOR_JIT = 30000;
 
     /** A static field updated by method handle getters and setters. */
     private static String name = "default";
diff --git a/test/988-method-trace/expected-stdout.txt b/test/988-method-trace/expected-stdout.txt
index 9460503286..a2e5acf8f0 100644
--- a/test/988-method-trace/expected-stdout.txt
+++ b/test/988-method-trace/expected-stdout.txt
@@ -118,16 +118,14 @@ fibonacci(5)=5
 ......<= final byte java.lang.AbstractStringBuilder.getCoder() -> <class java.lang.Byte: 0>
 ......=> byte java.lang.String.coder()
 ......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
-......=> void java.lang.String.getBytes(byte[],int,byte)
-.......=> byte java.lang.String.coder()
-.......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
+......=> void java.lang.String.fillBytes(byte[],int,byte)
 .......=> public int java.lang.String.length()
 .......<= public int java.lang.String.length() -> <class java.lang.Integer: 14>
 .......=> static void java.lang.String.checkBoundsOffCount(int,int,int)
 .......<= static void java.lang.String.checkBoundsOffCount(int,int,int) -> <null: null>
 .......=> private void java.lang.String.fillBytesLatin1(byte[],int)
 .......<= private void java.lang.String.fillBytesLatin1(byte[],int) -> <null: null>
-......<= void java.lang.String.getBytes(byte[],int,byte) -> <null: null>
+......<= void java.lang.String.fillBytes(byte[],int,byte) -> <null: null>
 .....<= private final void java.lang.AbstractStringBuilder.putStringAt(int,java.lang.String) -> <null: null>
 ....<= public java.lang.AbstractStringBuilder java.lang.AbstractStringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
 ...<= public java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
@@ -162,16 +160,14 @@ fibonacci(5)=5
 ......<= final byte java.lang.AbstractStringBuilder.getCoder() -> <class java.lang.Byte: 0>
 ......=> byte java.lang.String.coder()
 ......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
-......=> void java.lang.String.getBytes(byte[],int,byte)
-.......=> byte java.lang.String.coder()
-.......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
+......=> void java.lang.String.fillBytes(byte[],int,byte)
 .......=> public int java.lang.String.length()
 .......<= public int java.lang.String.length() -> <class java.lang.Integer: 4>
 .......=> static void java.lang.String.checkBoundsOffCount(int,int,int)
 .......<= static void java.lang.String.checkBoundsOffCount(int,int,int) -> <null: null>
 .......=> private void java.lang.String.fillBytesLatin1(byte[],int)
 .......<= private void java.lang.String.fillBytesLatin1(byte[],int) -> <null: null>
-......<= void java.lang.String.getBytes(byte[],int,byte) -> <null: null>
+......<= void java.lang.String.fillBytes(byte[],int,byte) -> <null: null>
 .....<= private final void java.lang.AbstractStringBuilder.putStringAt(int,java.lang.String) -> <null: null>
 ....<= public java.lang.AbstractStringBuilder java.lang.AbstractStringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
 ...<= public java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
@@ -246,16 +242,14 @@ fibonacci(-19) -> java.lang.Error: Bad argument: -19 < 0
 ......<= final byte java.lang.AbstractStringBuilder.getCoder() -> <class java.lang.Byte: 0>
 ......=> byte java.lang.String.coder()
 ......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
-......=> void java.lang.String.getBytes(byte[],int,byte)
-.......=> byte java.lang.String.coder()
-.......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
+......=> void java.lang.String.fillBytes(byte[],int,byte)
 .......=> public int java.lang.String.length()
 .......<= public int java.lang.String.length() -> <class java.lang.Integer: 14>
 .......=> static void java.lang.String.checkBoundsOffCount(int,int,int)
 .......<= static void java.lang.String.checkBoundsOffCount(int,int,int) -> <null: null>
 .......=> private void java.lang.String.fillBytesLatin1(byte[],int)
 .......<= private void java.lang.String.fillBytesLatin1(byte[],int) -> <null: null>
-......<= void java.lang.String.getBytes(byte[],int,byte) -> <null: null>
+......<= void java.lang.String.fillBytes(byte[],int,byte) -> <null: null>
 .....<= private final void java.lang.AbstractStringBuilder.putStringAt(int,java.lang.String) -> <null: null>
 ....<= public java.lang.AbstractStringBuilder java.lang.AbstractStringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
 ...<= public java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
@@ -290,16 +284,14 @@ fibonacci(-19) -> java.lang.Error: Bad argument: -19 < 0
 ......<= final byte java.lang.AbstractStringBuilder.getCoder() -> <class java.lang.Byte: 0>
 ......=> byte java.lang.String.coder()
 ......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
-......=> void java.lang.String.getBytes(byte[],int,byte)
-.......=> byte java.lang.String.coder()
-.......<= byte java.lang.String.coder() -> <class java.lang.Byte: 0>
+......=> void java.lang.String.fillBytes(byte[],int,byte)
 .......=> public int java.lang.String.length()
 .......<= public int java.lang.String.length() -> <class java.lang.Integer: 4>
 .......=> static void java.lang.String.checkBoundsOffCount(int,int,int)
 .......<= static void java.lang.String.checkBoundsOffCount(int,int,int) -> <null: null>
 .......=> private void java.lang.String.fillBytesLatin1(byte[],int)
 .......<= private void java.lang.String.fillBytesLatin1(byte[],int) -> <null: null>
-......<= void java.lang.String.getBytes(byte[],int,byte) -> <null: null>
+......<= void java.lang.String.fillBytes(byte[],int,byte) -> <null: null>
 .....<= private final void java.lang.AbstractStringBuilder.putStringAt(int,java.lang.String) -> <null: null>
 ....<= public java.lang.AbstractStringBuilder java.lang.AbstractStringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
 ...<= public java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String) -> <class java.lang.StringBuilder: Bad argument: -19 < 0>
diff --git a/test/Android.bp b/test/Android.bp
index 988dd3e5d7..eef30336e3 100644
--- a/test/Android.bp
+++ b/test/Android.bp
@@ -141,12 +141,19 @@ filegroup {
 }
 
 // Test configuration template for standalone ART gtests on target (not bundled with the ART APEX)
-// which are part of CTS.
+// which are part of CTS and MCTS.
 filegroup {
     name: "art-gtests-target-standalone-cts-template",
     srcs: ["art-gtests-target-standalone-cts-template.xml"],
 }
 
+// Test configuration template for standalone ART gtests on target (not bundled with the ART APEX)
+// which don't support multilib.
+filegroup {
+    name: "art-gtests-target-standalone-non-multilib-template",
+    srcs: ["art-gtests-target-standalone-non-multilib-template.xml"],
+}
+
 // Test configuration template for standalone ART gtests run with a boot image on target (not
 // bundled with the ART APEX).
 filegroup {
@@ -188,6 +195,7 @@ filegroup {
 cc_library_static {
     name: "standalone_test_lib_check",
     srcs: ["standalone_test_lib_check.cc"],
+    header_libs: ["art_libartbase_headers"],
     static_libs: [
         "libbase",
         "libelf",
@@ -217,9 +225,10 @@ art_cc_defaults {
 
     // Support multilib variants (using different suffix per sub-architecture),
     // which is needed on build targets with secondary architectures, as the
-    // CTS/MTS/etc test suite packaging logic flattens all test artifacts into a
-    // single `testcases` directory. Also, there is CI testing that expects
-    // 64-bit multilib test suites to work for 32-bit devices (b/233550842).
+    // CTS/MCTS/MTS/etc. test suite packaging logic may flatten all test artifacts
+    // into a single `testcases` directory. Also, there is CI testing that
+    // expects 64-bit multilib test suites to work for 32-bit devices
+    // (b/233550842).
     compile_multilib: "both",
     multilib: {
         lib32: {
@@ -490,7 +499,7 @@ filegroup {
 }
 
 // Same as `art-run-test-target-template`, but contains additional
-// options to also make the test part of ART CTS.
+// options to also make the test part of CTS and MCTS.
 filegroup {
     name: "art-run-test-target-cts-template",
     srcs: [
@@ -968,6 +977,7 @@ cc_defaults {
         "2246-trace-v2/dump_trace.cc",
         "2262-miranda-methods/jni_invoke.cc",
         "2270-mh-internal-hiddenapi-use/mh-internal-hidden-api.cc",
+        "2275-pthread-name/native_getname.cc",
         "common/runtime_state.cc",
         "common/stack_inspect.cc",
     ],
diff --git a/test/README.chroot_vm.md b/test/README.chroot_vm.md
index ed80ec0841..dd23d348bc 100644
--- a/test/README.chroot_vm.md
+++ b/test/README.chroot_vm.md
@@ -16,15 +16,16 @@ Create the VM (download it and do some initial setup):
 ```
 art/tools/buildbot-vm.sh create
 ```
-Boot the VM (login is `$ART_TEST_SSH_USER`, password is `ubuntu`):
+Install SSH keys on the VM:
 ```
-art/tools/buildbot-vm.sh boot
+art/tools/buildbot-vm.sh install-keys
 ```
-Configure SSH (enter `yes` to add VM to `known_hosts` and then the password):
+Boot the VM (login is `$ART_TEST_SSH_USER`, password is `ubuntu`):
 ```
-art/tools/buildbot-vm.sh setup-ssh
+art/tools/buildbot-vm.sh boot
 ```
-Now you have the shell (no need to enter password every time):
+Now you have the shell (no need to enter password every time as we've installed
+SSH keys on the VM):
 ```
 art/tools/buildbot-vm.sh connect
 ```
diff --git a/test/art-gtests-target-standalone-cts-template.xml b/test/art-gtests-target-standalone-cts-template.xml
index 42ad284978..a8a04ac5a6 100644
--- a/test/art-gtests-target-standalone-cts-template.xml
+++ b/test/art-gtests-target-standalone-cts-template.xml
@@ -23,14 +23,13 @@
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.art.apex" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.android.art.apex" />
 
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
         <option name="cleanup" value="true" />
-        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}/{MODULE}" />
-        <option name="append-bitness" value="true" />
+        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
     </target_preparer>
 
     <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/{MODULE}" />
+        <option name="native-test-device-path" value="/data/local/tmp" />
         <option name="module-name" value="{MODULE}" />
     </test>
 
diff --git a/libprofile/art_standalone_libprofile_tests.xml b/test/art-gtests-target-standalone-non-multilib-template.xml
similarity index 61%
rename from libprofile/art_standalone_libprofile_tests.xml
rename to test/art-gtests-target-standalone-non-multilib-template.xml
index 8a4cf8d627..9aa3f3685c 100644
--- a/libprofile/art_standalone_libprofile_tests.xml
+++ b/test/art-gtests-target-standalone-non-multilib-template.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2021 The Android Open Source Project
+<!-- Copyright (C) 2024 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,26 +13,20 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<configuration description="Runs art_standalone_libprofile_tests.">
+<!-- Note: This test config file for {MODULE} is generated from a template. -->
+<configuration description="Runs {MODULE} in non-multilib mode.">
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.art.apex" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.android.art.apex" />
 
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
         <option name="cleanup" value="true" />
-        <option name="push" value="art_standalone_libprofile_tests->/data/local/tmp/art_standalone_libprofile_tests/art_standalone_libprofile_tests" />
-        <option name="append-bitness" value="true" />
-    </target_preparer>
-
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-        <option name="cleanup" value="true" />
-        <option name="push" value="art-gtest-jars-ManyMethods.jar->/data/local/tmp/art_standalone_libprofile_tests/art-gtest-jars-ManyMethods.jar" />
-        <option name="push" value="art-gtest-jars-MultiDex.jar->/data/local/tmp/art_standalone_libprofile_tests/art-gtest-jars-MultiDex.jar" />
-        <option name="push" value="art-gtest-jars-ProfileTestMultiDex.jar->/data/local/tmp/art_standalone_libprofile_tests/art-gtest-jars-ProfileTestMultiDex.jar" />
+        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
     </target_preparer>
 
     <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/art_standalone_libprofile_tests" />
-        <option name="module-name" value="art_standalone_libprofile_tests" />
+        <option name="native-test-device-path" value="/data/local/tmp" />
+        <option name="module-name" value="{MODULE}" />
     </test>
 
     <!-- When this test is run in a Mainline context (e.g. with `mts-tradefed`), only enable it if
diff --git a/test/art-gtests-target-standalone-template.xml b/test/art-gtests-target-standalone-template.xml
index 1c21620342..3c3f11c5cf 100644
--- a/test/art-gtests-target-standalone-template.xml
+++ b/test/art-gtests-target-standalone-template.xml
@@ -18,14 +18,13 @@
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.art.apex" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.android.art.apex" />
 
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
         <option name="cleanup" value="true" />
-        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}/{MODULE}" />
-        <option name="append-bitness" value="true" />
+        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
     </target_preparer>
 
     <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/{MODULE}" />
+        <option name="native-test-device-path" value="/data/local/tmp" />
         <option name="module-name" value="{MODULE}" />
     </test>
 
diff --git a/test/default_run.py b/test/default_run.py
index 25b94b3f09..01b7542476 100755
--- a/test/default_run.py
+++ b/test/default_run.py
@@ -712,6 +712,10 @@ def default_run(ctx, args, **kwargs):
     # these binaries.
     ANDROID_ART_BIN_DIR = f"{ANDROID_ART_ROOT}/bin"
 
+  # Disable metrics reporting to StatsD for chroot tests.
+  if CHROOT:
+    FLAGS += " -Xmetrics-write-to-statsd:false"
+
   profman_cmdline = "true"
   dex2oat_cmdline = "true"
   vdex_cmdline = "true"
@@ -799,6 +803,10 @@ def default_run(ctx, args, **kwargs):
       dex2oat_cmdline += f"gdb {GDB_DEX2OAT_EXTRA_ARGS} \
                           -d '{ANDROID_BUILD_TOP}' --args "
 
+    dex2oat_logger = ""
+    if ON_VM:
+      dex2oat_logger = "--runtime-arg -Xuse-stderr-logger"
+
     dex2oat_cmdline += f"'{ANDROID_ART_BIN_DIR}/{dex2oat_binary}' \
                         {COMPILE_FLAGS} \
                         --boot-image={BOOT_IMAGE} \
@@ -807,6 +815,7 @@ def default_run(ctx, args, **kwargs):
                         {app_image} \
                         --generate-mini-debug-info \
                         --instruction-set={ISA} \
+                        {dex2oat_logger} \
                         {class_loader_context}"
 
     if INSTRUCTION_SET_FEATURES != "":
@@ -823,6 +832,9 @@ def default_run(ctx, args, **kwargs):
       # Use SIGRTMIN+2 to try to dump threads.
       # Use -k 1m to SIGKILL it a minute later if it hasn't ended.
       dex2oat_cmdline = f"timeout -k {DEX2OAT_TIMEOUT}s -s SIGRTMIN+2 {DEX2OAT_RT_TIMEOUT}s {dex2oat_cmdline} --watchdog-timeout={DEX2OAT_TIMEOUT}000"
+    elif ON_VM:
+      # Increase dex2oat timeout for VM testing environment, as some checker tests are slow.
+      dex2oat_cmdline = f"{dex2oat_cmdline} --watchdog-timeout={5 * DEX2OAT_TIMEOUT}000"
     if PROFILE or RANDOM_PROFILE:
       vdex_cmdline = f"{dex2oat_cmdline} {VDEX_ARGS} --input-vdex={DEX_LOCATION}/oat/{ISA}/{name}.vdex --output-vdex={DEX_LOCATION}/oat/{ISA}/{name}.vdex"
     elif TEST_VDEX:
diff --git a/test/dexpreopt/art_standalone_dexpreopt_tests.xml b/test/dexpreopt/art_standalone_dexpreopt_tests.xml
index cf459e65af..283d4161ba 100644
--- a/test/dexpreopt/art_standalone_dexpreopt_tests.xml
+++ b/test/dexpreopt/art_standalone_dexpreopt_tests.xml
@@ -26,14 +26,13 @@
 
     <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
 
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
         <option name="cleanup" value="true" />
-        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}/{MODULE}" />
-        <option name="append-bitness" value="true" />
+        <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
     </target_preparer>
 
     <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp/{MODULE}" />
+        <option name="native-test-device-path" value="/data/local/tmp" />
         <option name="module-name" value="{MODULE}" />
     </test>
 
diff --git a/test/knownfailures.json b/test/knownfailures.json
index dff43c55e8..e58a6cd4a2 100644
--- a/test/knownfailures.json
+++ b/test/knownfailures.json
@@ -243,7 +243,8 @@
     },
     {
         "tests": ["087-gc-after-link",
-                  "141-class-unload"],
+                  "141-class-unload",
+                  "2276-const-method-type-gc-cleanup"],
         "variant": "trace | stream"
     },
     {
@@ -645,18 +646,6 @@
         "variant": "target",
         "env_vars": {"SANITIZE_TARGET": "hwaddress"}
     },
-    {
-        "tests": "202-thread-oome",
-        "description": "ASAN aborts when large thread stacks are requested.",
-        "variant": "host",
-        "env_vars": {"SANITIZE_HOST": "address"}
-    },
-    {
-        "tests": "202-thread-oome",
-        "description": "ASAN aborts when large thread stacks are requested.",
-        "variant": "target",
-        "env_vars": {"SANITIZE_TARGET": "address"}
-    },
     {
         "tests": [
             "018-stack-overflow",
@@ -1085,12 +1074,19 @@
           "2245-checker-smali-instance-of-comparison",
           "2251-checker-irreducible-loop-do-not-inline",
           "2264-throwing-systemcleaner",
-          "2267-class-implements-itself"
+          "2267-class-implements-itself",
+          "2276-const-method-type-gc-cleanup",
+          "2281-method-handle-invoke-static-class-unload"
         ],
         "variant": "jvm",
         "bug": "b/73888836",
         "description": ["Failing on RI. Needs further investigating. Some of these use smali."]
     },
+    {
+        "tests": ["2275-pthread-name"],
+        "variant": "jvm",
+        "description": ["ART specific. We try harder to set pthread thread name."]
+    },
     {
         "tests": ["2042-reference-processing",
                   "2043-reference-pauses"],
@@ -1239,7 +1235,8 @@
                   "2261-badcleaner-in-systemcleaner",
                   "2263-method-trace-jit",
                   "2270-mh-internal-hiddenapi-use",
-                  "2271-profile-inline-cache"],
+                  "2271-profile-inline-cache",
+                  "2279-aconfig-flags"],
         "variant": "jvm",
         "description": ["Doesn't run on RI."]
     },
@@ -1465,7 +1462,23 @@
     {
         "tests": ["2235-JdkUnsafeTest",
                   "2236-JdkUnsafeGetLong-regression",
-                  "2239-varhandle-perf"],
+                  "2239-varhandle-perf-vh-cae",
+                  "2239-varhandle-perf-vh-cas",
+                  "2239-varhandle-perf-vh-cas-weak",
+                  "2239-varhandle-perf-vh-gaa",
+                  "2239-varhandle-perf-vh-gab",
+                  "2239-varhandle-perf-vh-gas",
+                  "2239-varhandle-perf-vh-get",
+                  "2239-varhandle-perf-vh-get-a",
+                  "2239-varhandle-perf-vh-get-bav",
+                  "2239-varhandle-perf-vh-reflect-get",
+                  "2239-varhandle-perf-vh-reflect-set",
+                  "2239-varhandle-perf-vh-set",
+                  "2239-varhandle-perf-vh-set-a",
+                  "2239-varhandle-perf-vh-set-bav",
+                  "2239-varhandle-perf-vh-unsafe-cas",
+                  "2239-varhandle-perf-vh-unsafe-get",
+                  "2239-varhandle-perf-vh-unsafe-put"],
         "variant": "jvm",
         "bug": "b/195387473",
         "description": ["Depends on using language level 11."]
@@ -1587,7 +1600,23 @@
                 "989-method-trace-throw",
                 "2029-contended-monitors",
                 "2043-reference-pauses",
-                "2239-varhandle-perf"],
+                "2239-varhandle-perf-vh-cae",
+                "2239-varhandle-perf-vh-cas",
+                "2239-varhandle-perf-vh-cas-weak",
+                "2239-varhandle-perf-vh-gaa",
+                "2239-varhandle-perf-vh-gab",
+                "2239-varhandle-perf-vh-gas",
+                "2239-varhandle-perf-vh-get",
+                "2239-varhandle-perf-vh-get-a",
+                "2239-varhandle-perf-vh-get-bav",
+                "2239-varhandle-perf-vh-reflect-get",
+                "2239-varhandle-perf-vh-reflect-set",
+                "2239-varhandle-perf-vh-set",
+                "2239-varhandle-perf-vh-set-a",
+                "2239-varhandle-perf-vh-set-bav",
+                "2239-varhandle-perf-vh-unsafe-cas",
+                "2239-varhandle-perf-vh-unsafe-get",
+                "2239-varhandle-perf-vh-unsafe-put"],
       "bug": "b/328023607",
       "description": ["Fails on QEMU"],
       "env_vars": {"ART_TEST_ON_VM": "true"}
diff --git a/test/odsign/Android.bp b/test/odsign/Android.bp
index ca1da53323..5aa0f4d25a 100644
--- a/test/odsign/Android.bp
+++ b/test/odsign/Android.bp
@@ -39,6 +39,7 @@ java_test_host {
     test_suites: [
         "general-tests",
         "cts",
+        "mcts-art",
     ],
 }
 
diff --git a/test/odsign/test-src/com/android/tests/odsign/DeviceState.java b/test/odsign/test-src/com/android/tests/odsign/DeviceState.java
index 7362d89ff3..f83df3c1ae 100644
--- a/test/odsign/test-src/com/android/tests/odsign/DeviceState.java
+++ b/test/odsign/test-src/com/android/tests/odsign/DeviceState.java
@@ -230,10 +230,15 @@ public class DeviceState {
             mMountPoints.remove(remotePath);
         }
 
+        String fileContext = getFileContext(remotePath);
+        mTestUtils.assertCommandSucceeds(String.format("chcon %s %s", fileContext, tempFile));
         mTestUtils.assertCommandSucceeds(
                 String.format("mount --bind '%s' '%s'", tempFile, remotePath));
         mMountPoints.add(remotePath);
-        mTestUtils.assertCommandSucceeds(String.format("restorecon '%s'", remotePath));
+    }
+
+    private String getFileContext(String remotePath) throws Exception {
+        return mTestUtils.assertCommandSucceeds(String.format("stat -c %%C %s", remotePath));
     }
 
     /** A helper class for mutating an XML file. */
diff --git a/test/run_test_build.py b/test/run_test_build.py
index 4929f05447..ca4634d5ce 100755
--- a/test/run_test_build.py
+++ b/test/run_test_build.py
@@ -192,7 +192,7 @@ class BuildTestContext:
     output = relpath(Path(args[args.index("--output") + 1]), self.rbe_exec_root)
     return self.rbe_wrap([
       "--output_files" if output.endswith(".jar") else "--output_directories", output,
-      "--toolchain_inputs=prebuilts/jdk/jdk17/linux-x86/bin/java",
+      "--toolchain_inputs=prebuilts/jdk/jdk21/linux-x86/bin/java",
       d8_path] + args, inputs)
 
   def rbe_smali(self, smali_path:Path, args):
@@ -224,7 +224,7 @@ class BuildTestContext:
     ])
     res = self.rbe_wrap([
       "--output_files", relpath(output, self.rbe_exec_root),
-      "--toolchain_inputs=prebuilts/jdk/jdk17/linux-x86/bin/java",
+      "--toolchain_inputs=prebuilts/jdk/jdk21/linux-x86/bin/java",
       "/bin/bash", wrapper] + args, inputs)
     wrapper.unlink()
     return res
diff --git a/test/standalone_test_lib_check.cc b/test/standalone_test_lib_check.cc
index e5c5baa3c6..426a302f54 100644
--- a/test/standalone_test_lib_check.cc
+++ b/test/standalone_test_lib_check.cc
@@ -23,6 +23,7 @@
 #include <libelf.h>
 
 #include <algorithm>
+#include <filesystem>
 #include <string>
 #include <vector>
 
@@ -31,6 +32,7 @@
 #include "android-base/scopeguard.h"
 #include "android-base/strings.h"
 #include "android-base/unique_fd.h"
+#include "base/stl_util.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 
@@ -154,13 +156,28 @@ TEST(StandaloneTestAllowedLibDeps, test) {
   Result<std::vector<std::string>> dyn_lib_deps = GetDynamicLibDeps(path_to_self.value());
   ASSERT_RESULT_OK(dyn_lib_deps);
 
+  // Allow .so files in the same directory as the test binary, for shared libs
+  // pushed with the test using `data_libs`.
+  std::filesystem::path self_dir = std::filesystem::path(path_to_self.value()).parent_path();
+  std::vector<std::string> test_libs;
+  for (const std::filesystem::directory_entry& entry :
+       std::filesystem::directory_iterator(self_dir)) {
+    if (entry.is_regular_file() && entry.path().extension() == ".so") {
+      test_libs.push_back(entry.path().filename());
+    }
+  }
+
   std::vector<std::string> disallowed_libs;
   for (const std::string& dyn_lib_dep : dyn_lib_deps.value()) {
     if (std::find(std::begin(kAllowedDynamicLibDeps),
                   std::end(kAllowedDynamicLibDeps),
-                  dyn_lib_dep) == std::end(kAllowedDynamicLibDeps)) {
-      disallowed_libs.push_back(dyn_lib_dep);
+                  dyn_lib_dep) != std::end(kAllowedDynamicLibDeps)) {
+      continue;
+    }
+    if (art::ContainsElement(test_libs, dyn_lib_dep)) {
+      continue;
     }
+    disallowed_libs.push_back(dyn_lib_dep);
   }
 
   EXPECT_THAT(disallowed_libs, testing::IsEmpty())
diff --git a/test/testing/art_fake_com.android.os.statsd/Android.bp b/test/testing/art_fake_com.android.os.statsd/Android.bp
new file mode 100644
index 0000000000..a9cdf4421e
--- /dev/null
+++ b/test/testing/art_fake_com.android.os.statsd/Android.bp
@@ -0,0 +1,60 @@
+//
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+cc_defaults {
+    name: "art_fake_statslib_defaults",
+    installable: false,
+    min_sdk_version: "30",
+    stl: "none",
+    apex_available: ["art_fake_com.android.os.statsd"],
+    visibility: ["//visibility:private"],
+}
+
+cc_library_shared {
+    name: "art_fake_libstatspull",
+    defaults: ["art_fake_statslib_defaults"],
+    srcs: ["libstatspull.c"],
+    stem: "libstatspull",
+}
+
+cc_library_shared {
+    name: "art_fake_libstatssocket",
+    defaults: ["art_fake_statslib_defaults"],
+    srcs: ["libstatssocket.c"],
+    stem: "libstatssocket",
+}
+
+// A fake StatsD apex only used for ART chroot testing.
+apex {
+    name: "art_fake_com.android.os.statsd",
+    defaults: [
+        "s-launched-apex-module",
+    ],
+    compile_multilib: "both",
+    native_shared_libs: [
+        "art_fake_libstatspull",
+        "art_fake_libstatssocket",
+    ],
+    key: "com.android.art.key",
+    certificate: ":com.android.art.certificate",
+    file_contexts: ":com.android.os.statsd-file_contexts",
+    min_sdk_version: "30",
+    visibility: ["//visibility:private"],
+}
diff --git a/test/testing/art_fake_com.android.os.statsd/apex_manifest.json b/test/testing/art_fake_com.android.os.statsd/apex_manifest.json
new file mode 100644
index 0000000000..8ea66b7d7b
--- /dev/null
+++ b/test/testing/art_fake_com.android.os.statsd/apex_manifest.json
@@ -0,0 +1,13 @@
+{
+  // A fake StatsD apex only used for ART chroot testing.
+  "name": "com.android.os.statsd",
+
+  // Placeholder module version to be replaced during build.
+  // Do not change!
+  "version": 0,
+
+  "provideNativeLibs": [
+    "libstatspull.so",
+    "libstatssocket.so"
+  ]
+}
diff --git a/test/testing/art_fake_com.android.os.statsd/libstatspull.c b/test/testing/art_fake_com.android.os.statsd/libstatspull.c
new file mode 100644
index 0000000000..194c695219
--- /dev/null
+++ b/test/testing/art_fake_com.android.os.statsd/libstatspull.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+
+#include "android/set_abort_message.h"
+
+#define FAKE(method_name)               \
+  void method_name() {                  \
+    android_set_abort_message("Fake!"); \
+    abort();                            \
+  }
+
+FAKE(AStatsManager_PullAtomMetadata_obtain);
+FAKE(AStatsManager_PullAtomMetadata_release);
+FAKE(AStatsManager_PullAtomMetadata_setCoolDownMillis);
+FAKE(AStatsManager_PullAtomMetadata_getCoolDownMillis);
+FAKE(AStatsManager_PullAtomMetadata_setTimeoutMillis);
+FAKE(AStatsManager_PullAtomMetadata_getTimeoutMillis);
+FAKE(AStatsManager_PullAtomMetadata_setAdditiveFields);
+FAKE(AStatsManager_PullAtomMetadata_getNumAdditiveFields);
+FAKE(AStatsManager_PullAtomMetadata_getAdditiveFields);
+FAKE(AStatsEventList_addStatsEvent);
+FAKE(AStatsManager_setPullAtomCallback);
+FAKE(AStatsManager_clearPullAtomCallback);
+FAKE(AStatsManager_addSubscription);
+FAKE(AStatsManager_removeSubscription);
+FAKE(AStatsManager_flushSubscription);
diff --git a/test/testing/art_fake_com.android.os.statsd/libstatssocket.c b/test/testing/art_fake_com.android.os.statsd/libstatssocket.c
new file mode 100644
index 0000000000..4bc4e4ab91
--- /dev/null
+++ b/test/testing/art_fake_com.android.os.statsd/libstatssocket.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+
+#include "android/set_abort_message.h"
+
+#define FAKE(method_name)               \
+  void method_name() {                  \
+    android_set_abort_message("Fake!"); \
+    abort();                            \
+  }
+
+FAKE(AStatsEvent_obtain);
+FAKE(AStatsEvent_build);
+FAKE(AStatsEvent_write);
+FAKE(AStatsEvent_release);
+FAKE(AStatsEvent_setAtomId);
+FAKE(AStatsEvent_writeInt32);
+FAKE(AStatsEvent_writeInt64);
+FAKE(AStatsEvent_writeFloat);
+FAKE(AStatsEvent_writeBool);
+FAKE(AStatsEvent_writeByteArray);
+FAKE(AStatsEvent_writeString);
+FAKE(AStatsEvent_writeAttributionChain);
+FAKE(AStatsEvent_writeInt32Array);
+FAKE(AStatsEvent_writeInt64Array);
+FAKE(AStatsEvent_writeFloatArray);
+FAKE(AStatsEvent_writeBoolArray);
+FAKE(AStatsEvent_writeStringArray);
+FAKE(AStatsEvent_addBoolAnnotation);
+FAKE(AStatsEvent_addInt32Annotation);
+FAKE(AStatsSocket_close);
diff --git a/test/testing/art_fake_heapprofd_client_api/Android.bp b/test/testing/art_fake_heapprofd_client_api/Android.bp
new file mode 100644
index 0000000000..ef033016b4
--- /dev/null
+++ b/test/testing/art_fake_heapprofd_client_api/Android.bp
@@ -0,0 +1,29 @@
+//
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+cc_library_shared {
+    name: "art_fake_heapprofd_client_api",
+    srcs: ["heapprofd_client_api.c"],
+    stem: "heapprofd_client_api",
+    relative_install_path: "art_fake", // Avoid conflict with the real lib.
+    stl: "none",
+    compile_multilib: "both",
+    visibility: ["//visibility:private"],
+}
diff --git a/test/testing/art_fake_heapprofd_client_api/heapprofd_client_api.c b/test/testing/art_fake_heapprofd_client_api/heapprofd_client_api.c
new file mode 100644
index 0000000000..9d2445bf4a
--- /dev/null
+++ b/test/testing/art_fake_heapprofd_client_api/heapprofd_client_api.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+
+#include "android/set_abort_message.h"
+
+#define FAKE(method_name)               \
+  void method_name() {                  \
+    android_set_abort_message("Fake!"); \
+    abort();                            \
+  }
+
+FAKE(AHeapProfileEnableCallbackInfo_getSamplingInterval);
+FAKE(AHeapProfile_reportSample);
+FAKE(AHeapProfile_reportFree);
+FAKE(AHeapProfile_reportAllocation);
+FAKE(AHeapProfile_registerHeap);
+FAKE(AHeapInfo_setEnabledCallback);
+FAKE(AHeapInfo_setDisabledCallback);
+FAKE(AHeapInfo_create);
diff --git a/test/testrunner/testrunner.py b/test/testrunner/testrunner.py
index c6ebe36dab..c92f18369b 100755
--- a/test/testrunner/testrunner.py
+++ b/test/testrunner/testrunner.py
@@ -35,7 +35,7 @@ dependencies:
 There are various options to invoke the script which are:
 -t: Either the test name as in art/test or the test name including the variant
     information. Eg, "-t 001-HelloWorld",
-    "-t test-art-host-run-test-debug-prebuild-optimizing-relocate-ntrace-cms-checkjni-picimage-ndebuggable-001-HelloWorld32"
+    "-t test-art-host-run-test-debug-prebuild-optimizing-relocate-ntrace-cms-checkjni-picimage-ndebuggable-no-jvmti-001-HelloWorld32"
 -j: Number of thread workers to be used. Eg - "-j64"
 --dry-run: Instead of running the test name, just print its name.
 --verbose
@@ -996,7 +996,7 @@ def extract_test_name(test_name):
     test_name_matcher = re.compile(regex)
   match = test_name_matcher.match(test_name)
   if match:
-    return list(match.group(i) for i in range(1,15))
+    return list(match.groups())
   raise ValueError(test_name + " is not a valid test")
 
 def parse_test_name(test_name):
@@ -1004,7 +1004,7 @@ def parse_test_name(test_name):
   It supports two types of test_name:
   1) Like 001-HelloWorld. In this case, it will just verify if the test actually
   exists and if it does, it returns the testname.
-  2) Like test-art-host-run-test-debug-prebuild-interpreter-no-relocate-ntrace-cms-checkjni-pointer-ids-picimage-ndebuggable-001-HelloWorld32
+  2) Like test-art-host-run-test-debug-prebuild-interpreter-no-relocate-ntrace-cms-checkjni-picimage-ndebuggable-no-jvmti-001-HelloWorld32
   In this case, it will parse all the variants and check if they are placed
   correctly. If yes, it will set the various VARIANT_TYPES to use the
   variants required to run the test. Again, it returns the test_name
diff --git a/test/2239-varhandle-perf/util-src/generate_java.py b/test/utils/python/generate_java_varhandle_perf.py
similarity index 71%
rename from test/2239-varhandle-perf/util-src/generate_java.py
rename to test/utils/python/generate_java_varhandle_perf.py
index 4c58c32501..e911800d5d 100644
--- a/test/2239-varhandle-perf/util-src/generate_java.py
+++ b/test/utils/python/generate_java_varhandle_perf.py
@@ -15,7 +15,7 @@
 # limitations under the License.
 
 """
-Generate java benchmarks for 2238-varhandle-perf
+Generate java benchmarks for 2239-varhandle-perf
 """
 # TODO: fix constants when converting the test to a Golem benchmark
 
@@ -397,92 +397,105 @@ UNSAFE_CAS = UNSAFE_START + """
       theUnsafe.{method}({this_comma}offset, {value1}, {value2});
       theUnsafe.{method}({this_comma}offset, {value2}, {value1});""" * REPEAT_HALF + END
 
-
-ALL_BENCHMARKS = (
-    [BenchVHField(VH_GET, static, vartype, flavour, "get")
-        for flavour in ["", "Acquire", "Opaque", "Volatile"]
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchVHField(VH_SET, static, vartype, flavour, "set")
-        for flavour in ["", "Volatile", "Opaque", "Release"]
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchVHField(VH_CAS, static, vartype, flavour, "compareAndSet")
-        for flavour in [""]
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchVHField(VH_CAS, static, vartype, flavour, "weakCompareAndSet")
-        for flavour in ["", "Plain", "Acquire", "Release"]
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchVHField(VH_CAE, static, vartype, flavour, "compareAndExchange")
-        for flavour in ["", "Acquire", "Release"]
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchVHField(VH_GAS, static, vartype, flavour, "getAndSet")
-        for flavour in ["", "Acquire", "Release"]
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchVHField(VH_GAA, static, vartype, flavour, "getAndAdd")
-        for flavour in ["", "Acquire", "Release"]
-        for static in [True, False]
-        for vartype in ["int", "float"]] +
-    [BenchVHField(VH_GAB, static, vartype, flavour, "getAndBitwise")
-        for flavour in [oper + mode
-            for oper in ["Or", "Xor", "And"]
-            for mode in ["", "Acquire", "Release"]]
-        for static in [True, False]
-        for vartype in ["int"]] +
-    [BenchVHArray(VH_GET_A, vartype, flavour, "get")
-        for flavour in [""]
-        for vartype in ["int", "String"]] +
-    [BenchVHArray(VH_SET_A, vartype, flavour, "set")
-        for flavour in [""]
-        for vartype in ["int", "String"]] +
-    [BenchVHByteArrayView(VH_GET_BAV, byteorder, vartype, flavour, "get")
-        for flavour in [""]
-        for byteorder in ["BIG_ENDIAN", "LITTLE_ENDIAN"]
-        for vartype in ["int"]] +
-    [BenchVHByteArrayView(VH_SET_BAV, byteorder, vartype, flavour, "set")
-        for flavour in [""]
-        for byteorder in ["BIG_ENDIAN", "LITTLE_ENDIAN"]
-        for vartype in ["int"]] +
-    [BenchReflect(REFLECT_GET, static, vartype, "get")
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchReflect(REFLECT_SET, static, vartype, "set")
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchUnsafe(UNSAFE_GET, static, vartype, "get")
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchUnsafe(UNSAFE_PUT, static, vartype, "put")
-        for static in [True, False]
-        for vartype in ["int", "String"]] +
-    [BenchUnsafe(UNSAFE_CAS, static, vartype, method)
-        for method in ["compareAndSwap", "compareAndSet"]
-        for static in [True, False]
-        for vartype in ["int", "String"]])
-
-
-MAIN = BANNER + """
-public class Main {
-  static MicroBenchmark[] benchmarks;
-
-  private static void initialize() throws Throwable {
-    benchmarks = new MicroBenchmark[] {""" + "".join(["""
-      new {}(),""".format(b.fullname()) for b in ALL_BENCHMARKS]) + """
-    };
-  }
-
-  public static void main(String[] args) throws Throwable {
-    initialize();
-    for (MicroBenchmark benchmark : benchmarks) {
-      benchmark.report();
-    }
-  }
-}"""
-
+def benchmark_selector(benchmark_to_run):
+  if benchmark_to_run == '0':
+    return (
+        [BenchVHField(VH_GET, static, vartype, flavour, "get")
+            for flavour in ["", "Acquire", "Opaque", "Volatile"]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '1':
+    return (
+        [BenchVHField(VH_SET, static, vartype, flavour, "set")
+            for flavour in ["", "Volatile", "Opaque", "Release"]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '2':
+    return (
+        [BenchVHField(VH_CAS, static, vartype, flavour, "compareAndSet")
+            for flavour in [""]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '3':
+    return (
+        [BenchVHField(VH_CAS, static, vartype, flavour, "weakCompareAndSet")
+            for flavour in ["", "Plain", "Acquire", "Release"]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '4':
+    return (
+        [BenchVHField(VH_CAE, static, vartype, flavour, "compareAndExchange")
+            for flavour in ["", "Acquire", "Release"]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '5':
+    return (
+        [BenchVHField(VH_GAS, static, vartype, flavour, "getAndSet")
+            for flavour in ["", "Acquire", "Release"]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '6':
+    return (
+        [BenchVHField(VH_GAA, static, vartype, flavour, "getAndAdd")
+            for flavour in ["", "Acquire", "Release"]
+            for static in [True, False]
+            for vartype in ["int", "float"]])
+  elif benchmark_to_run == '7':
+    return (
+        [BenchVHField(VH_GAB, static, vartype, flavour, "getAndBitwise")
+            for flavour in [oper + mode
+                for oper in ["Or", "Xor", "And"]
+                for mode in ["", "Acquire", "Release"]]
+            for static in [True, False]
+            for vartype in ["int"]])
+  elif benchmark_to_run == '8':
+    return (
+        [BenchVHArray(VH_GET_A, vartype, flavour, "get")
+            for flavour in [""]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '9':
+    return (
+        [BenchVHArray(VH_SET_A, vartype, flavour, "set")
+            for flavour in [""]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '10':
+    return (
+        [BenchVHByteArrayView(VH_GET_BAV, byteorder, vartype, flavour, "get")
+            for flavour in [""]
+            for byteorder in ["BIG_ENDIAN", "LITTLE_ENDIAN"]
+            for vartype in ["int"]])
+  elif benchmark_to_run == '11':
+    return (
+        [BenchVHByteArrayView(VH_SET_BAV, byteorder, vartype, flavour, "set")
+            for flavour in [""]
+            for byteorder in ["BIG_ENDIAN", "LITTLE_ENDIAN"]
+            for vartype in ["int"]])
+  elif benchmark_to_run == '12':
+    return (
+        [BenchReflect(REFLECT_GET, static, vartype, "get")
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '13':
+    return (
+        [BenchReflect(REFLECT_SET, static, vartype, "set")
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '14':
+    return (
+        [BenchUnsafe(UNSAFE_GET, static, vartype, "get")
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  elif benchmark_to_run == '15':
+    return (
+        [BenchUnsafe(UNSAFE_PUT, static, vartype, "put")
+            for static in [True, False]
+            for vartype in ["int", "String"]])
+  else:
+    return (
+        [BenchUnsafe(UNSAFE_CAS, static, vartype, method)
+            for method in ["compareAndSwap", "compareAndSet"]
+            for static in [True, False]
+            for vartype in ["int", "String"]])
 
 def main(argv):
     final_java_dir = Path(argv[1])
@@ -490,6 +503,27 @@ def main(argv):
         print("{} is not a valid java dir".format(final_java_dir), file=sys.stderr)
         sys.exit(1)
 
+    benchmark_to_run = argv[2]
+    ALL_BENCHMARKS = benchmark_selector(benchmark_to_run)
+
+    MAIN = BANNER + """
+    public class Main {
+      static MicroBenchmark[] benchmarks;
+
+      private static void initialize() throws Throwable {
+        benchmarks = new MicroBenchmark[] {""" + "".join(["""
+          new {}(),""".format(b.fullname()) for b in ALL_BENCHMARKS]) + """
+        };
+      }
+
+      public static void main(String[] args) throws Throwable {
+        initialize();
+        for (MicroBenchmark benchmark : benchmarks) {
+          benchmark.report();
+        }
+      }
+    }"""
+
     for bench in ALL_BENCHMARKS:
         file_path = final_java_dir / "{}.java".format(bench.fullname())
         with file_path.open("w") as f:
diff --git a/test/utils/regen-test-files b/test/utils/regen-test-files
index 09bae93679..c91bfbf18a 100755
--- a/test/utils/regen-test-files
+++ b/test/utils/regen-test-files
@@ -83,6 +83,15 @@ ART_RUN_TEST_MODULE_NAME_PREFIX = "art-run-test-"
 # Number of shards used to declare ART run-tests in the sharded ART MTS test plan.
 NUM_MTS_ART_RUN_TEST_SHARDS = 1
 
+# Name of the ART MTS test list containing "eng-only" test modules,
+# which require a device-under-test running a `userdebug` or `eng`
+# build.
+ENG_ONLY_TEST_LIST_NAME = "mts-art-tests-list-eng-only"
+
+# Name of Lint baseline filename used in certain ART run-tests,
+# e.g. for the `NewApi` check (see e.g. b/268261262).
+LINT_BASELINE_FILENAME = "lint-baseline.xml"
+
 # Curated list of tests that have a custom `run` script, but that are
 # known to work fine with the default test execution strategy (i.e.
 # when ignoring their `run` script), even if not exactly as they would
@@ -91,9 +100,7 @@ runnable_test_exceptions = frozenset([
   "055-enum-performance",
   "059-finalizer-throw",
   "080-oom-throw",
-  "1004-checker-volatile-ref-load",
   "133-static-invoke-super",
-  "1338-gc-no-los",
   "159-app-image-fields",
   "160-read-barrier-stress",
   "163-app-image-methods",
@@ -108,9 +115,15 @@ runnable_test_exceptions = frozenset([
   "678-quickening",
   "818-clinit-nterp",
   "821-madvise-willneed",
+  "1004-checker-volatile-ref-load",
+  "1338-gc-no-los",
 ])
 
+# Known slow tests, for which the timeout value is raised.
 known_slow_tests = frozenset([
+  "080-oom-throw",
+  "099-vmdebug",
+  "109-suspend-check",
   "175-alloc-big-bignums",
 ])
 
@@ -122,10 +135,6 @@ known_failing_tests = frozenset([
   "051-thread",
   "086-null-super",
   "087-gc-after-link",
-  # 1002-notify-startup: Dependency on `libarttest` + custom `check` script.
-  "1002-notify-startup",
-  "1337-gc-coverage",
-  "1339-dead-reference-safe",
   "136-daemon-jni-shutdown",
   "139-register-natives",
   "148-multithread-gc-annotations",
@@ -135,19 +144,7 @@ known_failing_tests = frozenset([
   "169-threadgroup-jni",
   "177-visibly-initialized-deadlock",
   "179-nonvirtual-jni",
-  "1945-proxy-method-arguments",
-  "2011-stack-walk-concurrent-instrument",
-  # 2040-huge-native-alloc: Fails with:
-  #
-  #   Test command execution failed with status FAILED: CommandResult: exit code=1, out=, err=Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: length=0; index=0
-  #           at Main.main(Main.java:56)
-  #
-  "2040-huge-native-alloc",
   "203-multi-checkpoint",
-  "2033-shutdown-mechanics",
-  "2036-jni-filechannel",
-  "2037-thread-name-inherit",
-  "2235-JdkUnsafeTest",
   "305-other-fault-handler",
   # 449-checker-bce: Dependency on `libarttest`.
   "449-checker-bce",
@@ -213,9 +210,27 @@ known_failing_tests = frozenset([
   "966-default-conflict",
   # These tests need native code.
   "993-breakpoints-non-debuggable",
+  # 1002-notify-startup: Dependency on `libarttest` + custom `check` script.
+  "1002-notify-startup",
+  "1337-gc-coverage",
+  "1339-dead-reference-safe",
+  "1945-proxy-method-arguments",
+  "2011-stack-walk-concurrent-instrument",
+  "2033-shutdown-mechanics",
+  "2036-jni-filechannel",
+  "2037-thread-name-inherit",
+  # 2040-huge-native-alloc: Fails with:
+  #
+  #   Test command execution failed with status FAILED: CommandResult: exit code=1, out=, err=Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: length=0; index=0
+  #           at Main.main(Main.java:56)
+  #
+  "2040-huge-native-alloc",
+  "2235-JdkUnsafeTest",
   "2243-single-step-default",
   "2262-miranda-methods",
   "2262-default-conflict-methods",
+  # 2275-pthread-name: Dependency on `libarttest`.
+  "2275-pthread-name",
 ])
 
 # These ART run-tests are new and have not had enough post-submit runs
@@ -223,8 +238,7 @@ known_failing_tests = frozenset([
 # removing them from this set (in order to promote them to
 # presubmits).
 postsubmit_only_tests = frozenset([
-  "2247-checker-write-barrier-elimination",
-  "2273-checker-unreachable-intrinsics",
+    "057-math-intrinsics",
 ])
 
 known_failing_on_hwasan_tests = frozenset([
@@ -239,6 +253,7 @@ art_gtest_user_module_names = [
     "art_standalone_artd_tests",
     "art_standalone_cmdline_tests",
     "art_standalone_compiler_tests",
+    "art_standalone_dex2oat_cts_tests",
     "art_standalone_dex2oat_tests",
     "art_standalone_dexdump_tests",
     "art_standalone_dexlist_tests",
@@ -273,10 +288,18 @@ art_gtest_module_names = sorted(art_gtest_user_module_names + art_gtest_eng_only
 # removing them from this set (in order to promote them to
 # presubmits).
 art_gtest_postsubmit_only_module_names = [
+    "art_standalone_dex2oat_cts_tests",
+]
+
+# ART gtests not supported in MTS.
+art_gtest_modules_excluded_from_mts = [
+    # TODO(b/347717488): Consider adding this test to ART MTS.
+    "libnativebridge-tests",
 ]
 
 # ART gtests supported in MTS that do not need root access to the device.
-art_gtest_mts_user_module_names = copy.copy(art_gtest_user_module_names)
+art_gtest_mts_user_module_names = [t for t in art_gtest_user_module_names
+                                   if t not in art_gtest_modules_excluded_from_mts]
 
 # ART gtests supported in presubmits.
 art_gtest_presubmit_module_names = [t for t in art_gtest_module_names
@@ -364,6 +387,60 @@ failing_tests_excluded_from_mainline_presubmits = (
 def is_checker_test(run_test):
   return re.match("^[0-9]+-checker-", run_test)
 
+def gen_mts_test_list_file(tests, test_list_file, copyright_year, configuration_description,
+                           tests_description, comments = []):
+  """Generate an ART MTS test list file."""
+  root = xml.dom.minidom.Document()
+
+  advisory_header = root.createComment(f" {ADVISORY} ")
+  root.appendChild(advisory_header)
+  copyright_header = root.createComment(copyright_header_text(copyright_year))
+  root.appendChild(copyright_header)
+
+  configuration = root.createElement("configuration")
+  root.appendChild(configuration)
+  configuration.setAttribute("description", configuration_description)
+
+  def append_option(name, value):
+    option = root.createElement("option")
+    option.setAttribute("name", name)
+    option.setAttribute("value", value)
+    configuration.appendChild(option)
+
+  def append_comment(comment):
+    xml_comment = root.createComment(f" {comment} ")
+    configuration.appendChild(xml_comment)
+
+  # Test declarations.
+  # ------------------
+
+  test_declarations_comments = [tests_description + "."]
+  test_declarations_comments.extend(comments)
+  for c in test_declarations_comments:
+    append_comment(c)
+  for t in tests:
+    append_option("compatibility:include-filter", t)
+
+  # `MainlineTestModuleController` configurations.
+  # ----------------------------------------------
+
+  module_controller_configuration_comments = [
+      f"Enable MainlineTestModuleController for {tests_description}."]
+  module_controller_configuration_comments.extend(comments)
+  for c in module_controller_configuration_comments:
+    append_comment(c)
+  for t in tests:
+    append_option("compatibility:module-arg", f"{t}:enable:true")
+  for t in tests:
+    if t in ["CtsLibcoreTestCases", "CtsLibcoreOjTestCases"]:
+      append_comment("core-test-mode=mts tells ExpectationBasedFilter to exclude @NonMts Tests")
+      append_option("compatibility:module-arg", f"{t}:instrumentation-arg:core-test-mode:=mts")
+
+  xml_str = root.toprettyxml(indent = XML_INDENT, encoding = "utf-8")
+
+  with open(test_list_file, "wb") as f:
+    logging.debug(f"Writing `{test_list_file}`.")
+    f.write(xml_str)
 
 class Generator:
   def __init__(self, top_dir):
@@ -372,17 +449,27 @@ class Generator:
     self.top_dir = top_dir
     # Path to the ART directory
     self.art_dir = os.path.join(top_dir, "art")
-    # Path to the ART tests directory.
+    # Path to the ART tests top-level directory.
     self.art_test_dir = os.path.join(self.art_dir, "test")
     # Path to the MTS configuration directory.
     self.mts_config_dir = os.path.join(
         top_dir, "test", "mts", "tools", "mts-tradefed", "res", "config")
+    # Path to the ART JVM TI CTS tests top-level directory.
+    self.jvmti_cts_test_dir = os.path.join(top_dir, "cts/hostsidetests/jvmti/run-tests")
 
+  # Return the list of ART run-tests (in short form, i.e. `001-HelloWorld`,
+  # not `art-run-test-001-HelloWorld`).
   def enumerate_run_tests(self):
     return sorted([run_test
                    for run_test in os.listdir(self.art_test_dir)
                    if re.match("^[0-9]{3,}-", run_test)])
 
+  # Return the list of ART JVM TI CTS tests.
+  def enumerate_jvmti_cts_tests(self):
+    return sorted([re.sub(r"test-(\d+)", r"CtsJvmtiRunTest\1HostTestCases", cts_jvmti_test_dir)
+                   for cts_jvmti_test_dir in os.listdir(self.jvmti_cts_test_dir)
+                   if re.match(r"^test-\d+$", cts_jvmti_test_dir)])
+
   # Return the metadata of a test, if any.
   def get_test_metadata(self, run_test):
     run_test_path = os.path.join(self.art_test_dir, run_test)
@@ -476,6 +563,26 @@ class Generator:
       return True
     return False
 
+  # Generate a Blueprint property group as a string, i.e. something looking like
+  # this:
+  #
+  #   ```
+  #       <group_name>: {
+  #         <key0>: "<value0>",
+  #         ...
+  #         <keyN>: "<valueN>",
+  #       }
+  #   ```
+  #
+  # where `(key0, value0), ..., (keyN, valueN)` are key-value pairs in `props`.
+  def gen_prop_group(self, group_name, props):
+    props_joined = """,
+            """.join([f"{k}: \"{v}\"" for (k, v) in props.items()])
+    return f"""
+          {group_name}: {{
+              {props_joined},
+          }},"""
+
   def gen_libs_list_impl(self, library_type, libraries):
     if len(libraries) == 0:
       return ""
@@ -492,7 +599,7 @@ class Generator:
   def gen_static_libs_list(self, libraries):
     return self.gen_libs_list_impl("static_libs", libraries);
 
-  def gen_java_library_rule(self, name, src_dir, libraries):
+  def gen_java_library_rule(self, name, src_dir, libraries, extra_props):
     return f"""\
 
 
@@ -500,7 +607,7 @@ class Generator:
       java_library {{
           name: "{name}",
           defaults: ["art-run-test-defaults"],{self.gen_libs_list(libraries)}
-          srcs: ["{src_dir}/**/*.java"],
+          srcs: ["{src_dir}/**/*.java"],{extra_props}
       }}"""
 
   # Is (successfully) running `run_test` supported?
@@ -541,7 +648,17 @@ class Generator:
 
     # Optional test metadata (JSON file).
     metadata = self.get_test_metadata(run_test)
-    is_cts_test = "cts" in metadata.get("test_suites", [])
+    test_suites = metadata.get("test_suites", [])
+    is_cts_test = "cts" in test_suites
+    is_mcts_test = "mcts-art" in test_suites
+
+    # For now we make it mandatory for an ART CTS test to be an ART
+    # MCTS test and vice versa.
+    if is_cts_test != is_mcts_test:
+      (present, absent) = ("mts", "mcts-art") if is_cts_test else ("mcts-art", "mts")
+      logging.error(f"Inconsistent test suites state in metadata for ART run-test `{run_test}`: " +
+                    f"`test_suites` contains `{present}` but not `{absent}`")
+      sys.exit(1)
 
     run_test_module_name = ART_RUN_TEST_MODULE_NAME_PREFIX + run_test
 
@@ -558,11 +675,10 @@ class Generator:
 
     # Define the `test_suites` property, if test suites are present in
     # the test's metadata.
-    test_suites_list = metadata.get("test_suites")
     test_suites_prop = ""
-    if test_suites_list:
+    if test_suites:
       test_suites_joined = """,
-              """.join([f"\"{s}\"" for s in test_suites_list])
+              """.join([f"\"{s}\"" for s in test_suites])
       test_suites_prop = f"""\
 
           test_suites: [
@@ -581,9 +697,9 @@ class Generator:
     # against, if needed.
     sdk_version_prop = ""
     if is_cts_test:
-      # Have CTS test modules use the test API (`test_current`) so
-      # that they do not depend on the framework private platform API
-      # (`private`), which is the default.
+      # Have CTS and MCTS test modules use the test API
+      # (`test_current`) so that they do not depend on the framework
+      # private platform API (`private`), which is the default.
       sdk_version_prop = """
           sdk_version: "test_current","""
 
@@ -595,9 +711,14 @@ class Generator:
 
     src_library_rules = []
     test_libraries = []
+    extra_props = ""
+    # Honor the Lint baseline file, if present.
+    if os.path.isfile(os.path.join(run_test_path, LINT_BASELINE_FILENAME)):
+      extra_props += self.gen_prop_group("lint", {"baseline_filename": LINT_BASELINE_FILENAME})
     if os.path.isdir(os.path.join(run_test_path, "src2")):
       test_library = f"{run_test_module_name}-{source_dir}"
-      src_library_rules.append(self.gen_java_library_rule(test_library, source_dir, test_libraries))
+      src_library_rules.append(
+          self.gen_java_library_rule(test_library, source_dir, test_libraries, extra_props))
       test_libraries.append(f"\"{test_library}\"")
       source_dir = "src2"
 
@@ -766,17 +887,19 @@ class Generator:
       f.write(test_mapping_contents)
       f.write("\n")
 
-  def create_mts_test_shard(self, description, tests, shard_num, copyright_year, comments = []):
+  def create_mts_test_shard(self, tests_description, tests, shard_num, copyright_year,
+                            comments = []):
     """Factory method instantiating an `MtsTestShard`."""
-    return self.MtsTestShard(self.mts_config_dir,
-                             description, tests, shard_num, copyright_year, comments)
+    return self.MtsTestShard(self.mts_config_dir, tests_description, tests, shard_num,
+                             copyright_year, comments)
 
   class MtsTestShard:
     """Class encapsulating data and generation logic for an ART MTS test shard."""
 
-    def __init__(self, mts_config_dir, description, tests, shard_num, copyright_year, comments):
+    def __init__(self, mts_config_dir, tests_description, tests, shard_num, copyright_year,
+                 comments):
       self.mts_config_dir = mts_config_dir
-      self.description = description
+      self.tests_description = tests_description
       self.tests = tests
       self.shard_num = shard_num
       self.copyright_year = copyright_year
@@ -804,10 +927,17 @@ class Generator:
       root.appendChild(configuration)
       configuration.setAttribute(
           "description",
-          f"Run mts-art-shard-{self.shard_id()} from a preexisting MTS installation.")
+          f"Run {self.test_plan_name()} from a preexisting MTS installation.")
 
       # Included XML files.
       included_xml_files = ["mts", self.test_list_name()]
+      # Special case for the test plan of shard 03 (ART gtests), where we also
+      # include ART MTS eng-only tests.
+      #
+      # TODO(rpl): Restucture the MTS generation logic to avoid special-casing
+      # at that level of the generator.
+      if self.shard_num == 3:
+        included_xml_files.append(ENG_ONLY_TEST_LIST_NAME)
       for xml_file in included_xml_files:
         include = root.createElement("include")
         include.setAttribute("name", xml_file)
@@ -828,70 +958,11 @@ class Generator:
 
     def regen_test_list_file(self):
       """Regenerate ART MTS test list file (`mts-art-tests-list-user-shard-<shard_num>.xml`)."""
-      root = xml.dom.minidom.Document()
-
-      advisory_header = root.createComment(f" {ADVISORY} ")
-      root.appendChild(advisory_header)
-      copyright_header = root.createComment(copyright_header_text(self.copyright_year))
-      root.appendChild(copyright_header)
-
-      configuration = root.createElement("configuration")
-      root.appendChild(configuration)
-      configuration.setAttribute(
-          "description",
-          f"List of ART MTS tests that do not need root access (shard {self.shard_id()})"
-      )
-
-      # Test declarations.
-      # ------------------
-
-      def append_test_declaration(test):
-        option = root.createElement("option")
-        option.setAttribute("name", "compatibility:include-filter")
-        option.setAttribute("value", test)
-        configuration.appendChild(option)
-
-      test_declarations_comments = [self.description + "."]
-      test_declarations_comments.extend(self.comments)
-      for c in test_declarations_comments:
-        xml_comment = root.createComment(f" {c} ")
-        configuration.appendChild(xml_comment)
-      for t in self.tests:
-        append_test_declaration(t)
-
-      # `MainlineTestModuleController` configurations.
-      # ----------------------------------------------
-
-      def append_module_controller_configuration(test):
-        option = root.createElement("option")
-        option.setAttribute("name", "compatibility:module-arg")
-        option.setAttribute("value", f"{test}:enable:true")
-        configuration.appendChild(option)
-
-      module_controller_configuration_comments = [
-          f"Enable MainlineTestModuleController for {self.description}."]
-      module_controller_configuration_comments.extend(self.comments)
-      for c in module_controller_configuration_comments:
-        xml_comment = root.createComment(f" {c} ")
-        configuration.appendChild(xml_comment)
-      for t in self.tests:
-        append_module_controller_configuration(t)
-      for t in self.tests:
-        if t in ["CtsLibcoreTestCases", "CtsLibcoreOjTestCases"]:
-          xml_comment = root.createComment(
-            " core-test-mode=mts tells ExpectationBasedFilter to exclude @NonMts Tests ")
-          configuration.appendChild(xml_comment)
-          option = root.createElement("option")
-          option.setAttribute("name", "compatibility:module-arg")
-          option.setAttribute("value", f"{t}:instrumentation-arg:core-test-mode:=mts")
-          configuration.appendChild(option)
-
-      xml_str = root.toprettyxml(indent = XML_INDENT, encoding = "utf-8")
-
+      configuration_description = \
+        f"List of ART MTS tests that do not need root access (shard {self.shard_id()})"
       test_list_file = os.path.join(self.mts_config_dir, self.test_list_name() + ".xml")
-      with open(test_list_file, "wb") as f:
-        logging.debug(f"Writing `{test_list_file}`.")
-        f.write(xml_str)
+      gen_mts_test_list_file(self.tests, test_list_file, self.copyright_year,
+                             configuration_description, self.tests_description, self.comments)
 
   def regen_mts_art_tests_list_user_file(self, num_mts_art_run_test_shards):
     """Regenerate ART MTS test list file (`mts-art-tests-list-user.xml`)."""
@@ -939,7 +1010,7 @@ class Generator:
       logging.debug(f"Writing `{mts_art_tests_list_user_file}`.")
       f.write(xml_str)
 
-  def regen_art_mts_files(self, art_run_tests):
+  def regen_art_mts_files(self, art_run_tests, art_jvmti_cts_tests):
     """Regenerate ART MTS definition files."""
 
     # Remove any previously MTS ART test plan shard (`mts-art-shard-[0-9]+.xml`)
@@ -972,8 +1043,8 @@ class Generator:
         "CTS Libcore non-OJ tests", ["CtsLibcoreTestCases"], cts_libcore_tests_shard_num, 2020)
     mts_test_shards.append(cts_libcore_tests_shard)
 
-    # Other CTS Libcore tests shard.
-    other_cts_libcore_tests_shard_num = len(mts_test_shards)
+    # Other CTS tests shard.
+    other_cts_tests_shard_num = len(mts_test_shards)
     other_cts_libcore_tests_shard_tests = [
         "CtsLibcoreApiEvolutionTestCases",
         "CtsLibcoreFileIOTestCases",
@@ -984,14 +1055,12 @@ class Generator:
         "MtsLibcoreOkHttpTestCases",
         "MtsLibcoreBouncyCastleTestCases",
     ]
-    other_cts_libcore_tests_shard = self.create_mts_test_shard(
-        "CTS Libcore OJ tests", other_cts_libcore_tests_shard_tests,
-        other_cts_libcore_tests_shard_num, 2021)
-    mts_test_shards.append(other_cts_libcore_tests_shard)
+    other_cts_tests_shard_tests = art_jvmti_cts_tests + other_cts_libcore_tests_shard_tests
+    other_cts_tests_shard = self.create_mts_test_shard(
+        "Other CTS tests", other_cts_tests_shard_tests, other_cts_tests_shard_num, 2021)
+    mts_test_shards.append(other_cts_tests_shard)
 
     # ART gtests shard.
-    # TODO: Also handle the case of gtests requiring root access to the device
-    # (`art_gtest_eng_only_module_names`).
     art_gtests_shard_num = len(mts_test_shards)
     art_gtests_shard_tests = art_gtest_mts_user_module_names
     art_gtests_shard = self.create_mts_test_shard(
@@ -1002,6 +1071,20 @@ class Generator:
       s.regen_test_plan_file()
       s.regen_test_list_file()
 
+    # Generate the MTS test list file of "eng-only" tests (tests that
+    # need root access to the device-under-test and are not part of
+    # "user" test plans).
+    #
+    # TODO(rpl): Refactor the MTS file generation logic to better
+    # handle the special case of "eng-only" tests, which do not play
+    # well with `MtsTestShard` at the moment).
+    eng_only_test_list_file = os.path.join(self.mts_config_dir, ENG_ONLY_TEST_LIST_NAME + ".xml")
+    gen_mts_test_list_file(
+        art_gtest_eng_only_module_names, eng_only_test_list_file,
+        copyright_year = 2020,
+        configuration_description = "List of ART MTS tests that need root access.",
+        tests_description = "ART gtests")
+
     self.regen_mts_art_tests_list_user_file(len(mts_test_shards))
 
   def regen_test_files(self, regen_art_mts):
@@ -1092,7 +1175,7 @@ class Generator:
     # -----------------------------------------
 
     if regen_art_mts:
-      self.regen_art_mts_files(expected_succeeding_tests)
+      self.regen_art_mts_files(expected_succeeding_tests, self.enumerate_jvmti_cts_tests())
       print(f"Generated ART MTS entries for {num_expected_succeeding_tests} ART run-tests out"
             f" of {len(run_tests)} ({expected_succeeding_tests_percentage}%).")
 
diff --git a/tools/ahat/Android.bp b/tools/ahat/Android.bp
index 540ce6670c..e1c7314605 100644
--- a/tools/ahat/Android.bp
+++ b/tools/ahat/Android.bp
@@ -56,6 +56,12 @@ java_test_helper_library {
     host_supported: true,
     device_supported: false,
     name: "ahat-ri-test-dump",
-    java_version: "17",
     srcs: ["src/ri-test-dump/**/*.java"],
 }
+
+cc_library_shared {
+    name: "libahat-test-jni",
+    srcs: ["src/test/jni/**/*.cpp"],
+    header_libs: ["jni_headers"],
+    host_supported: true,
+}
diff --git a/tools/ahat/Android.mk b/tools/ahat/Android.mk
index 9d7b1c0426..5db78e2765 100644
--- a/tools/ahat/Android.mk
+++ b/tools/ahat/Android.mk
@@ -27,6 +27,7 @@ ifneq ($(EMMA_INSTRUMENT),true)
 # Determine the location of the test-dump.jar, test-dump.hprof, and proguard
 AHAT_TEST_DUMP_JAR := $(call intermediates-dir-for,JAVA_LIBRARIES,ahat-test-dump)/javalib.jar
 AHAT_TEST_DUMP_COMMON := $(call intermediates-dir-for,JAVA_LIBRARIES,ahat-test-dump,,COMMON)
+AHAT_TEST_DUMP_JNI := $(ART_HOST_OUT_SHARED_LIBRARIES)/libahat-test-jni$(ART_HOST_SHLIB_EXTENSION)
 AHAT_TEST_DUMP_HPROF := $(AHAT_TEST_DUMP_COMMON)/test-dump.hprof
 AHAT_TEST_DUMP_BASE_HPROF := $(AHAT_TEST_DUMP_COMMON)/test-dump-base.hprof
 AHAT_TEST_DUMP_PROGUARD_MAP := $(AHAT_TEST_DUMP_COMMON)/test-dump.map
@@ -56,6 +57,7 @@ endif
 # The scripts below are run with --no-compile to avoid dependency on dex2oat.
 AHAT_TEST_DUMP_DEPENDENCIES := \
   $(AHAT_TEST_DALVIKVM_DEP) \
+  $(AHAT_TEST_DUMP_JNI) \
   $(ART_HOST_SHARED_LIBRARY_DEPENDENCIES) \
   $(ART_HOST_SHARED_LIBRARY_DEBUG_DEPENDENCIES) \
   $(ART_HOST_DEX_DEPENDENCIES) \
@@ -91,11 +93,10 @@ AHAT_RI_TEST_DUMP_COMMON := $(call intermediates-dir-for,JAVA_LIBRARIES,ahat-ri-
 AHAT_RI_TEST_DUMP_HPROF := $(AHAT_RI_TEST_DUMP_COMMON)/ri-test-dump.hprof
 
 # Run ahat-ri-test-dump.jar to generate ri-test-dump.hprof
-# b/329817005: Hardcode JDK 17 for running the test dump
 $(AHAT_RI_TEST_DUMP_HPROF): PRIVATE_AHAT_RI_TEST_DUMP_JAR := $(AHAT_RI_TEST_DUMP_JAR)
 $(AHAT_RI_TEST_DUMP_HPROF): $(AHAT_RI_TEST_DUMP_JAR)
 	rm -rf $@
-	./prebuilts/jdk/jdk17/linux-x86/bin/java -cp $(PRIVATE_AHAT_RI_TEST_DUMP_JAR) Main $@
+	java -cp $(PRIVATE_AHAT_RI_TEST_DUMP_JAR) Main $@
 
 # --- ahat-tests.jar --------------
 # To run these tests, use: atest ahat-tests --host
@@ -128,6 +129,7 @@ endif # linux
 # Clean up local variables.
 AHAT_TEST_JAR :=
 AHAT_TEST_DUMP_JAR :=
+AHAT_TEST_DUMP_JNI :=
 AHAT_TEST_DUMP_COMMON :=
 AHAT_TEST_DUMP_HPROF :=
 AHAT_TEST_DUMP_BASE_HPROF :=
diff --git a/tools/ahat/README.txt b/tools/ahat/README.txt
index da97c10a5b..b799e481e5 100644
--- a/tools/ahat/README.txt
+++ b/tools/ahat/README.txt
@@ -55,6 +55,11 @@ Known Issues:
  * Line number decoding for allocations in proguarded classes.
 
 Release History:
+ 1.7.3 June 27, 2024
+   Add support to display bitmaps included in heapdump. To use this
+   functionality, collect the heapdump with `adb shell am dumpheap -b <fmt>`,
+   <fmt> can be `png`, `jpg` or `webp`.
+
  1.7.2 March 2, 2022
    Fix ahat parsing to allow leading whitespaces for comments.
    Hide Value class constructor.
diff --git a/tools/ahat/etc/ahat.mf b/tools/ahat/etc/ahat.mf
index 53bb4acf9e..43bc17db37 100644
--- a/tools/ahat/etc/ahat.mf
+++ b/tools/ahat/etc/ahat.mf
@@ -1,4 +1,4 @@
 Name: ahat/
 Implementation-Title: ahat
-Implementation-Version: 1.7.2
+Implementation-Version: 1.7.3
 Main-Class: com.android.ahat.Main
diff --git a/tools/ahat/src/main/com/android/ahat/heapdump/AhatBitmapInstance.java b/tools/ahat/src/main/com/android/ahat/heapdump/AhatBitmapInstance.java
index 982591d1e4..30631784ab 100644
--- a/tools/ahat/src/main/com/android/ahat/heapdump/AhatBitmapInstance.java
+++ b/tools/ahat/src/main/com/android/ahat/heapdump/AhatBitmapInstance.java
@@ -25,14 +25,13 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.ArrayListMultimap;
+import java.util.stream.Collectors;
+import com.google.common.collect.TreeMultimap;
 
 /**
  * A java object that has `android.graphics.Bitmap` as its base class.
  */
-public class AhatBitmapInstance extends AhatClassInstance {
+public class AhatBitmapInstance extends AhatClassInstance implements Comparable<AhatBitmapInstance> {
 
   private BitmapInfo mBitmapInfo = null;
 
@@ -50,6 +49,13 @@ public class AhatBitmapInstance extends AhatClassInstance {
     return this;
   }
 
+  /**
+   * simple order for all bitmap instances on TreeMultimap
+   */
+  public int compareTo(AhatBitmapInstance other) {
+    return Long.compare(this.getId(), other.getId());
+  }
+
   /**
    * Parsed information for bitmap contents dumped in the heapdump
    */
@@ -60,14 +66,14 @@ public class AhatBitmapInstance extends AhatClassInstance {
     private int format;
     private Map<Long, byte[]> buffers;
     private Set<Long> referenced;
-    private ListMultimap<BitmapInfo, AhatBitmapInstance> instances;
+    private TreeMultimap<BitmapInfo, AhatBitmapInstance> instances;
 
     BitmapDumpData(int count, int format) {
       this.count = count;
       this.format = format;
       this.buffers = new HashMap<Long, byte[]>(count);
       this.referenced = new HashSet<Long>(count);
-      this.instances = ArrayListMultimap.create();
+      this.instances = TreeMultimap.create();
     }
   };
 
@@ -176,25 +182,15 @@ public class AhatBitmapInstance extends AhatClassInstance {
    */
   public static List<List<AhatBitmapInstance>> findDuplicates(BitmapDumpData bitmapDumpData) {
     if (bitmapDumpData != null) {
-      List<List<AhatBitmapInstance>> result = new ArrayList<>();
-      for (BitmapInfo info : bitmapDumpData.instances.keySet()) {
-        List<AhatBitmapInstance> list = bitmapDumpData.instances.get(info);
-        if (list != null && list.size() > 1) {
-          result.add(list);
-        }
-      }
-      // sort by size in descend order
-      if (result.size() > 1) {
-        result.sort((List<AhatBitmapInstance> l1, List<AhatBitmapInstance> l2) -> {
-          return l2.get(0).getSize().compareTo(l1.get(0).getSize());
-        });
-      }
-      return result;
+      return bitmapDumpData.instances.keySet().stream()
+          .filter(k -> bitmapDumpData.instances.get(k).size() > 1)
+          .map(k -> new ArrayList<>(bitmapDumpData.instances.get(k)))
+          .collect(Collectors.toList());
     }
     return null;
   }
 
-  private static class BitmapInfo {
+  private static class BitmapInfo implements Comparable<BitmapInfo> {
     private final int width;
     private final int height;
     private final int format;
@@ -214,6 +210,27 @@ public class AhatBitmapInstance extends AhatClassInstance {
       return Objects.hash(width, height, format, bufferHash);
     }
 
+    /**
+     * order bitmaps by their size (dimension WxH), format, and buffer hash,
+     * by default in descending order so large bitmaps are more significant
+     */
+    @Override
+    public int compareTo(BitmapInfo other) {
+      if (other == this) {
+        return 0;
+      }
+      if (other.width * other.height != this.width * this.height) {
+        return other.width * other.height - this.width * this.height;
+      }
+      if (other.format != this.format) {
+        return other.format - this.format;
+      }
+      if (other.bufferHash != this.bufferHash) {
+        return other.bufferHash - this.bufferHash;
+      }
+      return 0;
+    }
+
     @Override
     public boolean equals(Object o) {
       if (o == this) {
diff --git a/tools/ahat/src/main/com/android/ahat/heapdump/AhatClassInstance.java b/tools/ahat/src/main/com/android/ahat/heapdump/AhatClassInstance.java
index d193f08848..72ef976106 100644
--- a/tools/ahat/src/main/com/android/ahat/heapdump/AhatClassInstance.java
+++ b/tools/ahat/src/main/com/android/ahat/heapdump/AhatClassInstance.java
@@ -307,6 +307,14 @@ public class AhatClassInstance extends AhatInstance {
       return null;
     }
 
+    Value next = getField("next");
+    if (next != null && next.isAhatInstance() && next.asAhatInstance().getId() == getId()) {
+      // sun.misc.Cleaner.next points to this sun.misc.Cleaner instance,
+      // indicating that sun.misc.Cleaner.clean() has already been called and
+      // associated native allocations have been freed.
+      return null;
+    }
+
     RegisteredNativeAllocation rna = new RegisteredNativeAllocation();
     rna.referent = referent.asAhatInstance();
     rna.size = size.asLong();
diff --git a/tools/ahat/src/main/com/android/ahat/heapdump/AhatSnapshot.java b/tools/ahat/src/main/com/android/ahat/heapdump/AhatSnapshot.java
index 8f205bfb55..1c36448337 100644
--- a/tools/ahat/src/main/com/android/ahat/heapdump/AhatSnapshot.java
+++ b/tools/ahat/src/main/com/android/ahat/heapdump/AhatSnapshot.java
@@ -213,6 +213,11 @@ public class AhatSnapshot implements Diffable<AhatSnapshot> {
     return false;
   }
 
+  /**
+   * Returns duplicated bitmaps in this snapshot
+   *
+   * @return list of duplicated bitmaps
+   */
   public List<List<AhatBitmapInstance>> findDuplicateBitmaps() {
     return AhatBitmapInstance.findDuplicates(mBitmapDumpData);
   }
diff --git a/tools/ahat/src/main/com/android/ahat/heapdump/Parser.java b/tools/ahat/src/main/com/android/ahat/heapdump/Parser.java
index f28792b53d..3c16ce1ae6 100644
--- a/tools/ahat/src/main/com/android/ahat/heapdump/Parser.java
+++ b/tools/ahat/src/main/com/android/ahat/heapdump/Parser.java
@@ -582,6 +582,11 @@ public class Parser {
 
     // Sort roots and instances by id in preparation for the fixup pass.
     Instances<AhatInstance> mInstances = new Instances<AhatInstance>(instances);
+    // Ensure that no invalid classes are kept. In hprof dumps of RI it has been seen that two class
+    // objects would be stored for the same class name, but with different IDs. Only one of the IDs
+    // is present in the class dump data.
+    mInstances.removeIf(x -> x instanceof AhatClassObj && x.getTemporaryUserData() == null);
+
     roots.sort(new Comparator<RootData>() {
       @Override
       public int compare(RootData a, RootData b) {
diff --git a/tools/ahat/src/test-dump/DumpedStuff.java b/tools/ahat/src/test-dump/DumpedStuff.java
index 2b58ab68d9..f8d74dc27e 100644
--- a/tools/ahat/src/test-dump/DumpedStuff.java
+++ b/tools/ahat/src/test-dump/DumpedStuff.java
@@ -51,11 +51,16 @@ public class DumpedStuff extends SuperDumpedStuff {
       bigArray[i] = (byte)((i * i) & 0xFF);
     }
 
-    // 0x12345, 50000, and 0xABCDABCD are arbitrary values.
-    NativeAllocationRegistry registry = new NativeAllocationRegistry(
-        Main.class.getClassLoader(), 0x12345, 50000);
+    // 50000, 0xABCDABCD, and 0xBCDABCDA are arbitrary values.
+    NativeAllocationRegistry registry =
+        new NativeAllocationRegistry(Main.class.getClassLoader(), getNoopFreeFunction(), 50000);
     registry.registerNativeAllocation(anObject, 0xABCDABCD);
 
+    {
+      aCleanerThunk = registry.registerNativeAllocation(aCleanedObject, 0xBCDABCDA);
+      aCleanerThunk.run();
+    }
+
     {
       Object object = new Object();
       aLongStrongPathToSamplePathObject = new Reference(new Reference(new Reference(object)));
@@ -175,6 +180,8 @@ public class DumpedStuff extends SuperDumpedStuff {
   public char[] charArray = "char thing".toCharArray();
   public String nullString = null;
   public Object anObject = new Object();
+  public Object aCleanedObject = new Object();
+  public Runnable aCleanerThunk;
   public Reference aReference = new Reference(anObject);
   public ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
   public PhantomReference aPhantomReference = new PhantomReference(anObject, referenceQueue);
@@ -227,4 +234,10 @@ public class DumpedStuff extends SuperDumpedStuff {
         new SoftReference(
         new PhantomReference(new Object(), referenceQueue))))));
   }
+
+  static {
+    System.loadLibrary("ahat-test-jni");
+  }
+
+  private static native long getNoopFreeFunction();
 }
diff --git a/tools/ahat/src/test/com/android/ahat/NativeAllocationTest.java b/tools/ahat/src/test/com/android/ahat/NativeAllocationTest.java
index 7436be8311..29c7c507f2 100644
--- a/tools/ahat/src/test/com/android/ahat/NativeAllocationTest.java
+++ b/tools/ahat/src/test/com/android/ahat/NativeAllocationTest.java
@@ -33,5 +33,12 @@ public class NativeAllocationTest {
     AhatInstance referent = dump.getDumpedAhatInstance("anObject");
     assertEquals(50000, referent.getSize().getRegisteredNativeSize());
   }
-}
 
+  @Test
+  public void nativeAllocationCleaned() throws IOException {
+    TestDump dump = TestDump.getTestDump();
+
+    AhatInstance referent = dump.getDumpedAhatInstance("aCleanedObject");
+    assertEquals(0, referent.getSize().getRegisteredNativeSize());
+  }
+}
diff --git a/tools/ahat/src/test/jni/ahat_test_jni.cpp b/tools/ahat/src/test/jni/ahat_test_jni.cpp
new file mode 100644
index 0000000000..f7e8dd6573
--- /dev/null
+++ b/tools/ahat/src/test/jni/ahat_test_jni.cpp
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+namespace {
+// Stub impl for testing, do nothing.
+void NoopFreeFunction(void*) {}
+}  // namespace
+
+extern "C" {
+
+JNIEXPORT jlong JNICALL Java_DumpedStuff_getNoopFreeFunction(JNIEnv*, jclass) {
+  return reinterpret_cast<uint64_t>(NoopFreeFunction);
+}
+
+}  // extern "C"
diff --git a/tools/buildbot-build.sh b/tools/buildbot-build.sh
index e07dca6b7c..bdd311d6af 100755
--- a/tools/buildbot-build.sh
+++ b/tools/buildbot-build.sh
@@ -61,7 +61,7 @@ if [[ $TARGET_ARCH = "riscv64" && ! ( -d frameworks/base ) ]]; then
 fi
 
 java_libraries_dir=${out_dir}/target/common/obj/JAVA_LIBRARIES
-common_targets="vogar core-tests core-ojtests apache-harmony-jdwp-tests-hostdex jsr166-tests libartpalette-system mockito-target desugar"
+common_targets="vogar core-tests core-ojtests apache-harmony-jdwp-tests-hostdex jsr166-tests mockito-target desugar"
 # These build targets have different names on device and host.
 specific_targets="libjavacoretests libwrapagentproperties libwrapagentpropertiesd"
 build_host="no"
@@ -108,21 +108,10 @@ if [[ $build_host == "no" ]] && [[ $build_target == "no" ]]; then
   build_target="yes"
 fi
 
-implementation_libs=(
-  "heapprofd_client_api"
-  "libandroid_runtime_lazy"
-  "libartpalette-system"
-  "libbinder"
-  "libbinder_ndk"
-  "libcutils"
-  "libutils"
-  "libvndksupport"
-)
-
 if [ -d frameworks/base ]; then
   # In full manifest branches, build the implementation libraries from source
   # instead of using prebuilts.
-  common_targets="$common_targets ${implementation_libs[*]}"
+  common_targets="$common_targets"
 else
   # Necessary to build successfully in master-art.
   extra_args="SOONG_ALLOW_MISSING_DEPENDENCIES=true"
@@ -136,9 +125,19 @@ apexes=(
   "com.android.i18n"
   "com.android.runtime"
   "com.android.tzdata"
-  "com.android.os.statsd"
+  "art_fake_com.android.os.statsd"
 )
 
+override_apex_name() {
+  if [[ $1 == "com.android.art.testing" ]]; then
+    echo "com.android.art"
+  elif [[ $1 == "art_fake_com.android.os.statsd" ]]; then
+    echo "com.android.os.statsd"
+  else
+    echo $1
+  fi
+}
+
 make_command="build/soong/soong_ui.bash --make-mode $j_arg $extra_args $showcommands $common_targets"
 if [[ $build_host == "yes" ]]; then
   make_command+=" build-art-host-gtests"
@@ -156,10 +155,12 @@ if [[ $build_target == "yes" ]]; then
   make_command+=" build-art-target-gtests"
   test $skip_run_tests_build == "yes" || make_command+=" build-art-target-run-tests"
   make_command+=" debuggerd sh su toybox"
-  # Indirect dependencies in the platform, e.g. through heapprofd_client_api.
-  # These are built to go into system/lib(64) to be part of the system linker
-  # namespace.
-  make_command+=" libnetd_client-target libprocinfo libtombstoned_client libunwindstack"
+  make_command+=" libartpalette_fake art_fake_heapprofd_client_api"
+  # Runtime dependencies in the platform.
+  # These are built to go into system/lib(64) to be dlopen'ed.
+  # "libnetd_client.so" is used by bionic to perform network operations, which
+  # is needed in Libcore tests.
+  make_command+=" libnetd_client-target"
   # Stubs for other APEX SDKs, for use by vogar. Referenced from DEVICE_JARS in
   # external/vogar/src/vogar/ModeId.java.
   # Note these go into out/target/common/obj/JAVA_LIBRARIES which isn't removed
@@ -175,8 +176,6 @@ if [[ $build_target == "yes" ]]; then
   make_command+=" deapexer"
   # Needed to generate the primary boot image for testing.
   make_command+=" generate-boot-image"
-  # Data file needed by the `ArtExecTest.SetTaskProfiles` test.
-  make_command+=" task_profiles.json"
   # Build/install the required APEXes.
   make_command+=" ${apexes[*]}"
   make_command+=" ${specific_targets}"
@@ -204,6 +203,19 @@ if [[ $build_target == "yes" ]]; then
     ANDROID_HOST_OUT=$out_dir/host/linux-x86
   fi
 
+  # Use fake implementations to prevent chroot tests from talking to the platform (e.g., through
+  # libartpalette).
+  for l in lib lib64; do
+    if [ ! -d "$ANDROID_PRODUCT_OUT/system/$l/art_fake" ]; then
+      continue
+    fi
+    for lib in libartpalette-system heapprofd_client_api; do
+      cmd="cp -p \"$ANDROID_PRODUCT_OUT/system/$l/art_fake/$lib.so\" \"$ANDROID_PRODUCT_OUT/system/$l/$lib.so\""
+      msginfo "Executing" "$cmd"
+      eval "$cmd"
+    done
+  done
+
   # Extract prebuilt APEXes.
   debugfs=$ANDROID_HOST_OUT/bin/debugfs_static
   fsckerofs=$ANDROID_HOST_OUT/bin/fsck.erofs
@@ -225,35 +237,6 @@ if [[ $build_target == "yes" ]]; then
     fi
   done
 
-  # Replace stub libraries with implementation libraries: because we do chroot
-  # testing, we need to install an implementation of the libraries (and cannot
-  # rely on the one already installed on the device, if the device is post R and
-  # has it).
-  if [ -d prebuilts/runtime/mainline/platform/impl -a ! -d frameworks/base ]; then
-    if [[ $TARGET_ARCH = arm* ]]; then
-      arch32=arm
-      arch64=arm64
-    elif [[ $TARGET_ARCH = riscv64 ]]; then
-      arch32=none # there is no 32-bit arch for RISC-V
-      arch64=riscv64
-    else
-      arch32=x86
-      arch64=x86_64
-    fi
-    for so in ${implementation_libs[@]}; do
-      if [ -d "$ANDROID_PRODUCT_OUT/system/lib" -a $arch32 != none ]; then
-        cmd="cp -p prebuilts/runtime/mainline/platform/impl/$arch32/${so}.so $ANDROID_PRODUCT_OUT/system/lib/${so}.so"
-        msginfo "Executing" "$cmd"
-        eval "$cmd"
-      fi
-      if [ -d "$ANDROID_PRODUCT_OUT/system/lib64" -a $arch64 != none ]; then
-        cmd="cp -p prebuilts/runtime/mainline/platform/impl/$arch64/${so}.so $ANDROID_PRODUCT_OUT/system/lib64/${so}.so"
-        msginfo "Executing" "$cmd"
-        eval "$cmd"
-      fi
-    done
-  fi
-
   # Create canonical name -> file name symlink in the symbol directory for the
   # Testing ART APEX.
   #
@@ -349,11 +332,7 @@ if [[ $build_target == "yes" ]]; then
   mkdir -p $linkerconfig_root/apex
   for apex in ${apexes[@]}; do
     src="$ANDROID_PRODUCT_OUT/system/apex/${apex}"
-    if [[ $apex == com.android.art.* ]]; then
-      dst="$linkerconfig_root/apex/com.android.art"
-    else
-      dst="$linkerconfig_root/apex/${apex}"
-    fi
+    dst="$linkerconfig_root/apex/$(override_apex_name $apex)"
     msginfo "Copying APEX directory" "from $src to $dst"
     rm -rf $dst
     cp -r $src $dst
@@ -367,7 +346,7 @@ if [[ $build_target == "yes" ]]; then
 <apex-info-list>
 EOF
   for apex in ${apexes[@]}; do
-    [[ $apex == com.android.art.* ]] && apex=com.android.art
+    apex=$(override_apex_name $apex)
     cat <<EOF >> $apex_xml_file
     <apex-info moduleName="${apex}" modulePath="/system/apex/${apex}.apex" preinstalledModulePath="/system/apex/${apex}.apex" versionCode="1" versionName="" isFactory="true" isActive="true">
     </apex-info>
diff --git a/tools/buildbot-cleanup-device.sh b/tools/buildbot-cleanup-device.sh
index 45d0d45bb2..52117145ed 100755
--- a/tools/buildbot-cleanup-device.sh
+++ b/tools/buildbot-cleanup-device.sh
@@ -16,6 +16,14 @@
 
 . "$(dirname $0)/buildbot-utils.sh"
 
+# Clean up local changes to avoid failing incremental `repo sync`.
+# TODO(b/286551985): Remove this after riscv64 support is added to mainline.
+if [[ $TARGET_ARCH = "riscv64" && ! ( -d frameworks/base ) ]]; then
+    msginfo "Reverting local changes to conscrypt and StatsD"
+    (cd $ANDROID_BUILD_TOP/prebuilts/module_sdk/conscrypt && git reset --hard )
+    (cd $ANDROID_BUILD_TOP/prebuilts/module_sdk/StatsD && git reset --hard )
+fi
+
 # Testing on a Linux VM requires special cleanup.
 if [[ -n "$ART_TEST_ON_VM" ]]; then
   [[ -d "$ART_TEST_VM_DIR" ]] || { msgfatal "no VM found in $ART_TEST_VM_DIR"; }
diff --git a/tools/buildbot-sync.sh b/tools/buildbot-sync.sh
index 62e320b0d9..872ec283f9 100755
--- a/tools/buildbot-sync.sh
+++ b/tools/buildbot-sync.sh
@@ -126,7 +126,7 @@ activate_apex com.android.i18n
 activate_apex com.android.runtime
 activate_apex com.android.tzdata
 activate_apex com.android.conscrypt
-activate_apex com.android.os.statsd
+activate_apex art_fake_com.android.os.statsd com.android.os.statsd
 
 # Generate primary boot images on device for testing.
 for b in {32,64}; do
diff --git a/tools/buildbot-vm.sh b/tools/buildbot-vm.sh
index 0ab7e9ccaf..a801b589ea 100755
--- a/tools/buildbot-vm.sh
+++ b/tools/buildbot-vm.sh
@@ -37,6 +37,8 @@ get_stable_binary() {
     cd .. && rm -rf tmp
 }
 
+qemu_path="$ANDROID_BUILD_TOP/device/google/cuttlefish_vmm/qemu/x86_64-linux-gnu/bin"
+
 if [[ $action = create ]]; then
 (
     rm -rf "$ART_TEST_VM_DIR"
@@ -104,14 +106,14 @@ elif [[ $action = boot ]]; then
     cp "$(dirname $0)/user-data.img" "$ART_TEST_VM_DIR/user-data.img"
     cd "$ART_TEST_VM_DIR"
     if [[ "$TARGET_ARCH" = "riscv64" ]]; then
-        (qemu-system-riscv64 \
-            -m 16G \
-            -smp 8 \
+        ("$qemu_path/qemu-system-riscv64" \
             -M virt \
             -nographic \
+            -m 16G \
+            -smp 8 \
+            -cpu rv64,v=true,elen=64,vlen=128,zba=true,zbb=true,zbs=true \
             -bios fw_jump.elf \
             -kernel uboot.elf \
-            -cpu rv64,v=true,vlen=128,vext_spec=v1.0 \
             -drive file="$ART_TEST_VM_IMG",if=virtio \
             -drive file=user-data.img,format=raw,if=virtio \
             -device virtio-net-device,netdev=usernet \
@@ -132,7 +134,7 @@ elif [[ $action = boot ]]; then
         done < <(tail -f $SCRIPT_DIR/boot.out)
 
     elif [[ "$TARGET_ARCH" = "arm64" ]]; then
-        (qemu-system-aarch64 \
+        ("$qemu_path/qemu-system-aarch64" \
             -m 16G \
             -smp 8 \
             -cpu cortex-a710,sve=on \
diff --git a/tools/check_cfi.py b/tools/check_cfi.py
index 55b622d422..7d23821932 100755
--- a/tools/check_cfi.py
+++ b/tools/check_cfi.py
@@ -33,8 +33,8 @@ ARCHES = ["i386", "x86_64", "arm", "aarch64", "riscv64"]
 IGNORE : Dict[str, List[str]] = {
     # Aligns stack.
     "art_quick_osr_stub": ["i386"],
-    # Intermediate invalid CFI while loading all registers.
-    "art_quick_do_long_jump": ["x86_64"],
+    # Unverifiable intermediate CFI after loading the stack pointer from context.
+    "art_quick_do_long_jump": ["arm", "aarch64", "i386", "x86_64", "riscv64"],
     # Saves/restores SP in other register.
     "art_quick_generic_jni_trampoline": ["arm", "i386", "x86_64"],
     # Starts with non-zero offset at the start of the method.
@@ -57,8 +57,8 @@ def get_inst_semantics(arch: str) -> List[Any]:
     ptr_size = {"i386": 4, "x86_64": 8}[arch]
     add(r"push. .*", lambda m: ptr_size)
     add(r"pop. .*", lambda m: -ptr_size)
-    add(r"sub. \$(\w+), (?:%esp|%rsp)", lambda m: int(m[1], 0))
-    add(r"add. \$(\w+), (?:%esp|%rsp)", lambda m: -int(m[1], 0))
+    add(r"sub. \$(\w+), (?:%esp|%rsp)( # imm = \w+)?", lambda m: int(m[1], 0))
+    add(r"add. \$(\w+), (?:%esp|%rsp)( # imm = \w+)?", lambda m: -int(m[1], 0))
     add(r"call. (0x\w+) <.*", lambda m: ptr_size, adjust_pc=lambda m: int(m[1], 0))
     add(r"j[a-z]* (0x\w+) <.*", adjust_pc=lambda m: int(m[1], 0))
   if arch in ["arm", "aarch64"]:
diff --git a/tools/cpp-define-generator/code_item.def b/tools/cpp-define-generator/code_item.def
index 24d62a8fa2..01b0e85adf 100644
--- a/tools/cpp-define-generator/code_item.def
+++ b/tools/cpp-define-generator/code_item.def
@@ -16,7 +16,6 @@
 
 #if ASM_DEFINE_INCLUDE_DEPENDENCIES
 #include "dex/standard_dex_file.h"
-#include "dex/compact_dex_file.h"
 #endif
 
 ASM_DEFINE(CODE_ITEM_REGISTERS_SIZE_OFFSET,
@@ -27,37 +26,3 @@ ASM_DEFINE(CODE_ITEM_OUTS_SIZE_OFFSET,
            art::StandardDexFile::CodeItem::OutsSizeOffset())
 ASM_DEFINE(CODE_ITEM_INSNS_OFFSET,
            art::StandardDexFile::CodeItem::InsnsOffset())
-
-ASM_DEFINE(COMPACT_CODE_ITEM_FIELDS_OFFSET,
-           art::CompactDexFile::CodeItem::FieldsOffset())
-ASM_DEFINE(COMPACT_CODE_ITEM_FLAGS_OFFSET,
-           art::CompactDexFile::CodeItem::InsnsCountAndFlagsOffset())
-ASM_DEFINE(COMPACT_CODE_ITEM_INSNS_OFFSET,
-           art::CompactDexFile::CodeItem::InsnsOffset())
-
-ASM_DEFINE(COMPACT_CODE_ITEM_REGISTERS_INS_OUTS_FLAGS,
-           art::CompactDexFile::CodeItem::kFlagPreHeaderRegistersSize |
-           art::CompactDexFile::CodeItem::kFlagPreHeaderInsSize |
-           art::CompactDexFile::CodeItem::kFlagPreHeaderOutsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_REGISTERS_FLAG,
-           art::CompactDexFile::CodeItem::kFlagPreHeaderRegistersSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_INS_FLAG,
-           art::CompactDexFile::CodeItem::kFlagPreHeaderInsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_OUTS_FLAG,
-           art::CompactDexFile::CodeItem::kFlagPreHeaderOutsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_INSNS_FLAG,
-           art::CompactDexFile::CodeItem::kFlagPreHeaderInsnsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_REGISTERS_BIT,
-           art::CompactDexFile::CodeItem::kBitPreHeaderRegistersSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_INS_BIT,
-           art::CompactDexFile::CodeItem::kBitPreHeaderInsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_OUTS_BIT,
-           art::CompactDexFile::CodeItem::kBitPreHeaderOutsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_INSNS_BIT,
-           art::CompactDexFile::CodeItem::kBitPreHeaderInsnsSize)
-ASM_DEFINE(COMPACT_CODE_ITEM_REGISTERS_SIZE_SHIFT,
-           art::CompactDexFile::CodeItem::kRegistersSizeShift)
-ASM_DEFINE(COMPACT_CODE_ITEM_INS_SIZE_SHIFT,
-           art::CompactDexFile::CodeItem::kInsSizeShift)
-ASM_DEFINE(COMPACT_CODE_ITEM_OUTS_SIZE_SHIFT,
-           art::CompactDexFile::CodeItem::kOutsSizeShift)
diff --git a/tools/cpp-define-generator/thread.def b/tools/cpp-define-generator/thread.def
index 5cc5f7106e..aa621697c8 100644
--- a/tools/cpp-define-generator/thread.def
+++ b/tools/cpp-define-generator/thread.def
@@ -17,6 +17,7 @@
 #if ASM_DEFINE_INCLUDE_DEPENDENCIES
 #include "entrypoints/quick/quick_entrypoints_enum.h"
 #include "thread.h"
+#include "trace_profile.h"
 #endif
 
 ASM_DEFINE(THREAD_CARD_TABLE_OFFSET,
@@ -71,3 +72,8 @@ ASM_DEFINE(THREAD_SHARED_METHOD_HOTNESS_OFFSET,
            art::Thread::SharedMethodHotnessOffset<art::kRuntimePointerSize>().Int32Value())
 ASM_DEFINE(THREAD_TID_OFFSET,
            art::Thread::TidOffset<art::kRuntimePointerSize>().Int32Value())
+ASM_DEFINE(TRACE_BUFFER_INIT_OFFSET,
+           art::Thread::TraceBufferPtrOffset<art::kRuntimePointerSize>().Int32Value())
+ASM_DEFINE(TRACE_BUFFER_CURRENT_OFFSET,
+           art::Thread::TraceBufferCurrPtrOffset<art::kRuntimePointerSize>().Int32Value())
+ASM_DEFINE(TRACE_BUFFER_SIZE, (art::kAlwaysOnTraceBufSize - 1) * sizeof(uintptr_t))
diff --git a/tools/create_minidebuginfo/create_minidebuginfo.cc b/tools/create_minidebuginfo/create_minidebuginfo.cc
index f13b62579e..d9e8a6eb91 100644
--- a/tools/create_minidebuginfo/create_minidebuginfo.cc
+++ b/tools/create_minidebuginfo/create_minidebuginfo.cc
@@ -14,8 +14,16 @@
  * limitations under the License.
  */
 
-#include "android-base/logging.h"
+#include <algorithm>
+#include <deque>
+#include <map>
+#include <memory>
+#include <string>
+#include <string_view>
+#include <unordered_map>
+#include <vector>
 
+#include "android-base/logging.h"
 #include "base/os.h"
 #include "base/unix_file/fd_file.h"
 #include "elf/elf_builder.h"
@@ -24,14 +32,6 @@
 #include "stream/file_output_stream.h"
 #include "stream/vector_output_stream.h"
 
-#include <algorithm>
-#include <deque>
-#include <map>
-#include <memory>
-#include <string>
-#include <string_view>
-#include <vector>
-
 namespace art {
 
 static constexpr size_t kBlockSize = 32 * KB;
@@ -64,19 +64,57 @@ static void WriteMinidebugInfo(const std::vector<uint8_t>& input, std::vector<ui
   auto* symtab = builder->GetSymTab();
   strtab->Start();
   {
+    std::unordered_map<uint64_t, uint64_t> dyn_funcs_by_offset;
+    reader.VisitDynamicSymbols([&](Elf_Sym sym, const char*) {
+      // Keep track of all of the dynamic function symbols.
+      if (ELF32_ST_TYPE(sym.st_info) == STT_FUNC && sym.st_size != 0) {
+        auto it = dyn_funcs_by_offset.find(sym.st_value);
+        if (it == dyn_funcs_by_offset.end() || it->second < sym.st_size) {
+          dyn_funcs_by_offset[sym.st_value] = sym.st_size;
+        }
+      }
+    });
+    std::unordered_map<uint64_t, std::string_view> funcs_by_offset;
     std::multimap<std::string_view, Elf_Sym> syms;
     reader.VisitFunctionSymbols([&](Elf_Sym sym, const char* name) {
       // Exclude non-function or empty symbols.
-      if (ELF32_ST_TYPE(sym.st_info) == STT_FUNC && sym.st_size != 0) {
-        syms.emplace(name, sym);
+      if (ELF32_ST_TYPE(sym.st_info) != STT_FUNC || sym.st_size == 0) {
+        return;
       }
-    });
-    reader.VisitDynamicSymbols([&](Elf_Sym sym, const char* name) {
-      // Exclude symbols which will be preserved in the dynamic table anyway.
-      auto it = syms.find(name);
-      if (it != syms.end() && it->second.st_value == sym.st_value) {
+
+      // Exclude symbols at the same offset as a symbol in the set of
+      // dynamic symbols.
+      auto dyn_it = dyn_funcs_by_offset.find(sym.st_value);
+      if (dyn_it != dyn_funcs_by_offset.end()) {
+        CHECK(dyn_it->second >= sym.st_size);
+        return;
+      }
+
+      // Exclude symbols with the same offset as a previous symbol.
+      if (funcs_by_offset.contains(sym.st_value)) {
+        const std::string_view& previous_name = funcs_by_offset[sym.st_value];
+
+        // Find the previous symbol entry.
+        auto it = syms.find(previous_name);
+        while (it != syms.end() && it->second.st_value != sym.st_value) {
+          ++it;
+        }
+        CHECK(it != syms.end());
+
+        // When there is a duplicate, always choose the symbol with the
+        // largest size.
+        // In order to produce the same symbol table every time, if the
+        // symbol has the same size choose the symbol with the shortest
+        // name, or the symbol first according to ascii comparison.
+        if (sym.st_size < it->second.st_size ||
+            (sym.st_size == it->second.st_size &&
+             (previous_name.size() < strlen(name) || previous_name.compare(name) <= 0))) {
+          return;
+        }
         syms.erase(it);
       }
+      funcs_by_offset[sym.st_value] = name;
+      syms.emplace(name, sym);
     });
     if (!syms.empty()) {
       symtab->Add(strtab->Write(kSortedSymbolName), nullptr, 0, 0, STB_GLOBAL, STT_NOTYPE);
diff --git a/tools/fuzzer/Android.bp b/tools/fuzzer/Android.bp
index dff2847e8a..d2a4e25f09 100644
--- a/tools/fuzzer/Android.bp
+++ b/tools/fuzzer/Android.bp
@@ -24,8 +24,7 @@ package {
 }
 
 cc_defaults {
-    name: "libart_verify_dex_fuzzer-defaults",
-    srcs: ["libart_verify_dex_fuzzer.cc"],
+    name: "libart_fuzzer-defaults",
 
     // Build and run on x86 too.
     host_supported: true,
@@ -53,6 +52,43 @@ cc_defaults {
     },
 }
 
+cc_defaults {
+    name: "libart_verify_dex_fuzzer-defaults",
+    srcs: ["libart_verify_dex_fuzzer.cc"],
+
+    defaults: [
+        "libart_fuzzer-defaults",
+    ],
+}
+
+cc_defaults {
+    name: "libart_verify_classes_fuzzer-defaults",
+    srcs: ["libart_verify_classes_fuzzer.cc"],
+
+    defaults: [
+        "art_defaults",
+        "libart_fuzzer-defaults",
+    ],
+
+    target: {
+        android: {
+            shared_libs: [
+                "libdl_android",
+            ],
+        },
+    },
+
+    data: [
+        ":core-oj",
+        ":core-libart",
+        ":okhttp",
+        ":bouncycastle",
+        ":apache-xml",
+        ":core-icu4j",
+        ":conscrypt-fuzzer",
+    ],
+}
+
 cc_fuzz {
     name: "libart_verify_dex_fuzzer",
     defaults: [
@@ -62,7 +98,7 @@ cc_fuzz {
     // Can not be in defaults due to soong limitations.
     corpus: [
         ":art_runtest_corpus",
-        "corpus/*",
+        "dex-verifier-corpus/*",
     ],
 }
 
@@ -75,7 +111,21 @@ cc_fuzz {
     // Can not be in defaults due to soong limitations.
     corpus: [
         ":art_runtest_corpus",
-        "corpus/*",
+        "dex-verifier-corpus/*",
+    ],
+}
+
+cc_fuzz {
+    // TODO Add a debug version
+    name: "libart_verify_classes_fuzzer",
+    defaults: [
+        "libart_verify_classes_fuzzer-defaults",
+        "libart_static_defaults",
+    ],
+    // Can not be in defaults due to soong limitations.
+    corpus: [
+        ":art_runtest_corpus",
+        "class-verifier-corpus/*",
     ],
 }
 
@@ -576,7 +626,23 @@ genrule {
         "host_2237-checker-inline-multidex_classes.dex",
         "host_2237-checker-inline-multidex_classes2.dex",
         "host_2238-checker-polymorphic-recursive-inlining_classes.dex",
-        "host_2239-varhandle-perf_classes.dex",
+        "host_2239-varhandle-perf-vh-cae_classes.dex",
+        "host_2239-varhandle-perf-vh-cas_classes.dex",
+        "host_2239-varhandle-perf-vh-cas-weak_classes.dex",
+        "host_2239-varhandle-perf-vh-gaa_classes.dex",
+        "host_2239-varhandle-perf-vh-gab_classes.dex",
+        "host_2239-varhandle-perf-vh-gas_classes.dex",
+        "host_2239-varhandle-perf-vh-get_classes.dex",
+        "host_2239-varhandle-perf-vh-get-a_classes.dex",
+        "host_2239-varhandle-perf-vh-get-bav_classes.dex",
+        "host_2239-varhandle-perf-vh-reflect-get_classes.dex",
+        "host_2239-varhandle-perf-vh-reflect-set_classes.dex",
+        "host_2239-varhandle-perf-vh-set_classes.dex",
+        "host_2239-varhandle-perf-vh-set-a_classes.dex",
+        "host_2239-varhandle-perf-vh-set-bav_classes.dex",
+        "host_2239-varhandle-perf-vh-unsafe-cas_classes.dex",
+        "host_2239-varhandle-perf-vh-unsafe-get_classes.dex",
+        "host_2239-varhandle-perf-vh-unsafe-put_classes.dex",
         "host_2240-tracing-non-invokable-method_classes.dex",
         "host_2241-checker-inline-try-catch_classes.dex",
         "host_2242-checker-lse-acquire-release-operations_classes.dex",
@@ -1267,12 +1333,23 @@ genrule {
 }
 
 genrule {
-    name: "art-gtest-jars-DexFuzzerFolder",
-    // Zip the corpus folder. To get the folder, we grab the first file
+    name: "art-gtest-jars-DexVerificationFuzzerFolder",
+    // Zip the dex-verifier-corpus folder. To get the folder, we grab the first file
+    // from `in` and use its directory.
+    cmd: "FILES=($(in)) &&" +
+        "$(location soong_zip) -j -L 0 -o $(out) -D $$(dirname $${FILES[0]})",
+    srcs: ["dex-verifier-corpus/*"],
+    out: ["dex_verification_fuzzer_corpus.zip"],
+    tools: ["soong_zip"],
+}
+
+genrule {
+    name: "art-gtest-jars-ClassVerificationFuzzerFolder",
+    // Zip the class-verifier-corpus folder. To get the folder, we grab the first file
     // from `in` and use its directory.
     cmd: "FILES=($(in)) &&" +
         "$(location soong_zip) -j -L 0 -o $(out) -D $$(dirname $${FILES[0]})",
-    srcs: ["corpus/*"],
-    out: ["fuzzer_corpus.zip"],
+    srcs: ["class-verifier-corpus/*"],
+    out: ["class_verification_fuzzer_corpus.zip"],
     tools: ["soong_zip"],
 }
diff --git a/tools/fuzzer/README.md b/tools/fuzzer/README.md
new file mode 100644
index 0000000000..9ea64809a8
--- /dev/null
+++ b/tools/fuzzer/README.md
@@ -0,0 +1,109 @@
+# Building the ART Fuzzer
+
+There are two ways to run one of the existing fuzzers: on host or on device.
+The building and running takes place in the full Android platform
+tree (aosp-main-with-phones). For host there's the possibility of using a
+smaller AOSP Android manifest (master-art). The latter is faster to build,
+because it only has the sources and dependencies required for the module.
+
+In the following tutorial we use the class verification fuzzer. We set a shell
+variable with the fuzzer's name for convenience. Their names can be found in
+the Android.bp file, under the cc_fuzz build rules.
+
+```
+FUZZER_NAME=libart_verify_classes_fuzzer
+```
+
+## Common steps for host and device
+
+1. Navigate to the root directory of the android repository.
+
+2. From the console, set up the development environment.
+
+    ```
+    source build/envsetup.sh
+    ```
+
+3. Build the fuzzer for host/device
+
+    The command is composed of:
+
+    ```
+    lunch <product>-trunk_staging-<variant>
+    SANITIZE_HOST=address make ${FUZZER_NAME}
+    ```
+
+    For host you can use any valid lunch target, for example:
+
+    ```
+    lunch silvermont-trunk_staging-eng
+    ```
+
+    For device, you have to select your target according to the device
+    you are using it to run the fuzzer.
+
+    ```
+    lunch aosp_husky-trunk_staging-userdebug
+    ```
+
+## Host
+
+4. Run the fuzzer
+
+    In this example we assume an x86_64 host architecture:
+
+    ```
+    out/host/linux-x86/fuzz/x86_64/${FUZZER_NAME}/${FUZZER_NAME} \
+    out/host/linux-x86/fuzz/x86_64/${FUZZER_NAME}/corpus
+    ```
+
+    The first part of the command is the path to the fuzzer's binary, followed by the
+    corpus. See [llvm.org/docs/LibFuzzer](https://llvm.org/docs/LibFuzzer.html#options)
+    for more valid flags. For example, you can add the flag `-print_pcs=1` which makes
+    it more verbose.
+
+## Device
+
+4. Add the fuzzer's files on the device
+
+    ```
+    adb root
+    adb sync data
+    ```
+
+5. Run the fuzzer
+
+    Any supported architecture can be used. For example, for arm64:
+
+    ```
+    adb shell /data/fuzz/arm64/${FUZZER_NAME}/${FUZZER_NAME} \
+    /data/fuzz/arm64/${FUZZER_NAME}/corpus
+    ```
+
+    The first part of the command is the path to the fuzzer's binary and the next
+    one is the corpus.
+
+## Corpus
+
+The fuzzer uses a corpus as a starting point in order to generate new inputs
+representing DEX files. Our current corpus contains a mix of hand-created DEX
+files, regression tests, and DEX files from our test suite. Also, when the fuzzer
+generates a new input and it proves that it offers more code coverage,
+it is added to the existing corpus as a DEX file.
+
+If you want to run with the initial corpus, it needs to be removed and built again.
+
+For host, assuming an x86_64 host architecture:
+
+```
+rm -rf out/host/linux-x86/fuzz/x86_64/${FUZZER_NAME}/corpus
+SANITIZE_HOST=address make ${FUZZER_NAME}
+```
+
+For device, you also need to sync the data. For example, for arm64:
+
+```
+adb shell rm -rf /data/fuzz/arm64/${FUZZER_NAME}/corpus
+SANITIZE_HOST=address make ${FUZZER_NAME}
+adb sync data
+```
diff --git a/tools/fuzzer/corpus/Main.dex b/tools/fuzzer/class-verifier-corpus/Main.dex
similarity index 100%
rename from tools/fuzzer/corpus/Main.dex
rename to tools/fuzzer/class-verifier-corpus/Main.dex
diff --git a/tools/fuzzer/class-verifier-corpus/b360767178.dex b/tools/fuzzer/class-verifier-corpus/b360767178.dex
new file mode 100644
index 0000000000..29f02a7d5f
Binary files /dev/null and b/tools/fuzzer/class-verifier-corpus/b360767178.dex differ
diff --git a/tools/fuzzer/class-verifier-corpus/b365807384.dex b/tools/fuzzer/class-verifier-corpus/b365807384.dex
new file mode 100644
index 0000000000..ad88b174ab
Binary files /dev/null and b/tools/fuzzer/class-verifier-corpus/b365807384.dex differ
diff --git a/tools/fuzzer/corpus/hello_world.dex b/tools/fuzzer/class-verifier-corpus/hello_world.dex
similarity index 100%
rename from tools/fuzzer/corpus/hello_world.dex
rename to tools/fuzzer/class-verifier-corpus/hello_world.dex
diff --git a/tools/fuzzer/dex-verifier-corpus/Main.dex b/tools/fuzzer/dex-verifier-corpus/Main.dex
new file mode 100644
index 0000000000..ec29035983
Binary files /dev/null and b/tools/fuzzer/dex-verifier-corpus/Main.dex differ
diff --git a/tools/fuzzer/corpus/b323685074.dex b/tools/fuzzer/dex-verifier-corpus/b323685074.dex
similarity index 100%
rename from tools/fuzzer/corpus/b323685074.dex
rename to tools/fuzzer/dex-verifier-corpus/b323685074.dex
diff --git a/tools/fuzzer/dex-verifier-corpus/b365768956.dex b/tools/fuzzer/dex-verifier-corpus/b365768956.dex
new file mode 100644
index 0000000000..2771d3cb9a
Binary files /dev/null and b/tools/fuzzer/dex-verifier-corpus/b365768956.dex differ
diff --git a/tools/fuzzer/corpus/code_item_padding.dex b/tools/fuzzer/dex-verifier-corpus/code_item_padding.dex
similarity index 100%
rename from tools/fuzzer/corpus/code_item_padding.dex
rename to tools/fuzzer/dex-verifier-corpus/code_item_padding.dex
diff --git a/tools/fuzzer/dex-verifier-corpus/empty.dex b/tools/fuzzer/dex-verifier-corpus/empty.dex
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tools/fuzzer/corpus/encoded_array_value.dex b/tools/fuzzer/dex-verifier-corpus/encoded_array_value.dex
similarity index 100%
rename from tools/fuzzer/corpus/encoded_array_value.dex
rename to tools/fuzzer/dex-verifier-corpus/encoded_array_value.dex
diff --git a/tools/fuzzer/corpus/encoded_array_value2.dex b/tools/fuzzer/dex-verifier-corpus/encoded_array_value2.dex
similarity index 100%
rename from tools/fuzzer/corpus/encoded_array_value2.dex
rename to tools/fuzzer/dex-verifier-corpus/encoded_array_value2.dex
diff --git a/tools/fuzzer/dex-verifier-corpus/hello_world.dex b/tools/fuzzer/dex-verifier-corpus/hello_world.dex
new file mode 100644
index 0000000000..6e59dd76ad
Binary files /dev/null and b/tools/fuzzer/dex-verifier-corpus/hello_world.dex differ
diff --git a/tools/fuzzer/corpus/recursive_encoded_array.dex b/tools/fuzzer/dex-verifier-corpus/recursive_encoded_array.dex
similarity index 100%
rename from tools/fuzzer/corpus/recursive_encoded_array.dex
rename to tools/fuzzer/dex-verifier-corpus/recursive_encoded_array.dex
diff --git a/tools/fuzzer/libart_verify_classes_fuzzer.cc b/tools/fuzzer/libart_verify_classes_fuzzer.cc
new file mode 100644
index 0000000000..d066ef4b6e
--- /dev/null
+++ b/tools/fuzzer/libart_verify_classes_fuzzer.cc
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+
+#include "android-base/file.h"
+#include "android-base/strings.h"
+#include "base/file_utils.h"
+#include "base/mem_map.h"
+#include "dex/class_accessor-inl.h"
+#include "dex/dex_file_verifier.h"
+#include "dex/standard_dex_file.h"
+#include "handle_scope-inl.h"
+#include "interpreter/unstarted_runtime.h"
+#include "jni/java_vm_ext.h"
+#include "noop_compiler_callbacks.h"
+#include "runtime.h"
+#include "scoped_thread_state_change-inl.h"
+#include "verifier/class_verifier.h"
+#include "well_known_classes.h"
+
+// Global variable to count how many DEX files passed DEX file verification and they were
+// registered, since these are the cases for which we would be running the GC. In case of
+// scheduling multiple fuzzer jobs, using the -jobs flag, this is not shared among the threads.
+int skipped_gc_iterations = 0;
+// Global variable to call the GC once every maximum number of iterations.
+// TODO: These values were obtained from local experimenting. They can be changed after
+// further investigation.
+static constexpr int kMaxSkipGCIterations = 100;
+// Global variable to signal LSAN that we are not leaking memory.
+uint8_t* allocated_signal_stack = nullptr;
+
+namespace art {
+// A class to be friends with ClassLinker and access the internal FindDexCacheDataLocked method.
+class VerifyClassesFuzzerHelper {
+ public:
+  static const ClassLinker::DexCacheData* GetDexCacheData(Runtime* runtime, const DexFile* dex_file)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    Thread* self = Thread::Current();
+    ReaderMutexLock mu(self, *Locks::dex_lock_);
+    ClassLinker* class_linker = runtime->GetClassLinker();
+    const ClassLinker::DexCacheData* cached_data = class_linker->FindDexCacheDataLocked(*dex_file);
+    return cached_data;
+  }
+};
+}  // namespace art
+
+std::string GetDexFileName(const std::string& jar_name) {
+  // The jar files are located in the data directory within the directory of the fuzzer's binary.
+  std::string executable_dir = android::base::GetExecutableDirectory();
+
+  std::string result =
+      android::base::StringPrintf("%s/data/%s.jar", executable_dir.c_str(), jar_name.c_str());
+
+  return result;
+}
+
+std::vector<std::string> GetLibCoreDexFileNames() {
+  std::vector<std::string> result;
+  const std::vector<std::string> modules = {
+      "core-oj",
+      "core-libart",
+      "okhttp",
+      "bouncycastle",
+      "apache-xml",
+      "core-icu4j",
+      "conscrypt",
+  };
+  result.reserve(modules.size());
+  for (const std::string& module : modules) {
+    result.push_back(GetDexFileName(module));
+  }
+  return result;
+}
+
+std::string GetClassPathOption(const char* option, const std::vector<std::string>& class_path) {
+  return option + android::base::Join(class_path, ':');
+}
+
+jobject RegisterDexFileAndGetClassLoader(art::Runtime* runtime, art::StandardDexFile* dex_file)
+    REQUIRES_SHARED(art::Locks::mutator_lock_) {
+  art::Thread* self = art::Thread::Current();
+  art::ClassLinker* class_linker = runtime->GetClassLinker();
+  const std::vector<const art::DexFile*> dex_files = {dex_file};
+  jobject class_loader = class_linker->CreatePathClassLoader(self, dex_files);
+  art::ObjPtr<art::mirror::ClassLoader> cl = self->DecodeJObject(class_loader)->AsClassLoader();
+  class_linker->RegisterDexFile(*dex_file, cl);
+  return class_loader;
+}
+
+extern "C" int LLVMFuzzerInitialize([[maybe_unused]] int* argc, [[maybe_unused]] char*** argv) {
+  // Set logging to error and above to avoid warnings about unexpected checksums.
+  android::base::SetMinimumLogSeverity(android::base::ERROR);
+
+  // Create runtime.
+  art::RuntimeOptions options;
+  {
+    static art::NoopCompilerCallbacks callbacks;
+    options.push_back(std::make_pair("compilercallbacks", &callbacks));
+  }
+
+  std::string boot_class_path_string =
+      GetClassPathOption("-Xbootclasspath:", GetLibCoreDexFileNames());
+  options.push_back(std::make_pair(boot_class_path_string, nullptr));
+
+  // Instruction set.
+  options.push_back(
+      std::make_pair("imageinstructionset",
+                     reinterpret_cast<const void*>(GetInstructionSetString(art::kRuntimeISA))));
+
+  // No need for sig chain.
+  options.push_back(std::make_pair("-Xno-sig-chain", nullptr));
+
+  if (!art::Runtime::Create(options, false)) {
+    LOG(FATAL) << "We should always be able to create the runtime";
+    UNREACHABLE();
+  }
+
+  // Need well-known-classes.
+  art::WellKnownClasses::Init(art::Thread::Current()->GetJniEnv());
+  // Need a class loader. Fake that we're a compiler.
+  // Note: this will run initializers through the unstarted runtime, so make sure it's
+  //       initialized.
+  art::interpreter::UnstartedRuntime::Initialize();
+
+  art::Thread::Current()->TransitionFromRunnableToSuspended(art::ThreadState::kNative);
+
+  // Query the current stack and add it to the global variable. Otherwise LSAN complains about a
+  // non-existing leak.
+  stack_t ss;
+  if (sigaltstack(nullptr, &ss) == -1) {
+    PLOG(FATAL) << "sigaltstack failed";
+  }
+  allocated_signal_stack = reinterpret_cast<uint8_t*>(ss.ss_sp);
+
+  return 0;
+}
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+  // Do not verify the checksum as we only care about the DEX file contents,
+  // and know that the checksum would probably be erroneous (i.e. random).
+  constexpr bool kVerify = false;
+
+  auto container = std::make_shared<art::MemoryDexFileContainer>(data, size);
+  art::StandardDexFile dex_file(data,
+                                /*location=*/"fuzz.dex",
+                                /*location_checksum=*/0,
+                                /*oat_dex_file=*/nullptr,
+                                container);
+  std::string error_msg;
+  const bool verify_result =
+      art::dex::Verify(&dex_file, dex_file.GetLocation().c_str(), kVerify, &error_msg);
+
+  if (!verify_result) {
+    // DEX file couldn't be verified, don't save it in the corpus.
+    return -1;
+  }
+
+  art::Runtime* runtime = art::Runtime::Current();
+  CHECK(runtime != nullptr);
+
+  art::ScopedObjectAccess soa(art::Thread::Current());
+  art::ClassLinker* class_linker = runtime->GetClassLinker();
+  jobject class_loader = RegisterDexFileAndGetClassLoader(runtime, &dex_file);
+
+  // Scope for the handles
+  {
+    art::StackHandleScope<3> scope(soa.Self());
+    art::Handle<art::mirror::ClassLoader> h_loader =
+        scope.NewHandle(soa.Decode<art::mirror::ClassLoader>(class_loader));
+    art::MutableHandle<art::mirror::Class> h_klass(scope.NewHandle<art::mirror::Class>(nullptr));
+    art::MutableHandle<art::mirror::DexCache> h_dex_cache(
+        scope.NewHandle<art::mirror::DexCache>(nullptr));
+
+    for (art::ClassAccessor accessor : dex_file.GetClasses()) {
+      const char* descriptor = accessor.GetDescriptor();
+      h_klass.Assign(class_linker->FindClass(soa.Self(), descriptor, h_loader));
+      // Ignore classes that couldn't be loaded since we are looking for crashes during
+      // class/method verification.
+      if (h_klass == nullptr || h_klass->IsErroneous()) {
+        soa.Self()->ClearException();
+        continue;
+      }
+      h_dex_cache.Assign(h_klass->GetDexCache());
+      art::verifier::ClassVerifier::VerifyClass(soa.Self(),
+                                                /* verifier_deps= */ nullptr,
+                                                h_dex_cache->GetDexFile(),
+                                                h_klass,
+                                                h_dex_cache,
+                                                h_loader,
+                                                *h_klass->GetClassDef(),
+                                                runtime->GetCompilerCallbacks(),
+                                                art::verifier::HardFailLogMode::kLogWarning,
+                                                /* api_level= */ 0,
+                                                &error_msg);
+    }
+  }
+
+  skipped_gc_iterations++;
+
+  // Delete weak root to the DexCache before removing a DEX file from the cache. This is usually
+  // handled by the GC, but since we are not calling it every iteration, we need to delete them
+  // manually.
+  const art::ClassLinker::DexCacheData* dex_cache_data =
+      art::VerifyClassesFuzzerHelper::GetDexCacheData(runtime, &dex_file);
+  soa.Env()->GetVm()->DeleteWeakGlobalRef(soa.Self(), dex_cache_data->weak_root);
+
+  class_linker->RemoveDexFromCaches(dex_file);
+
+  // Delete global ref and unload class loader to free RAM.
+  soa.Env()->GetVm()->DeleteGlobalRef(soa.Self(), class_loader);
+
+  if (skipped_gc_iterations == kMaxSkipGCIterations) {
+    runtime->GetHeap()->CollectGarbage(/* clear_soft_references */ true);
+    skipped_gc_iterations = 0;
+  }
+
+  return 0;
+}
diff --git a/tools/libcore_failures.txt b/tools/libcore_failures.txt
index a3c07ccdcf..8dc525d44a 100644
--- a/tools/libcore_failures.txt
+++ b/tools/libcore_failures.txt
@@ -351,5 +351,11 @@
    names: ["libcore.java.lang.RecordTest",
            "crossvmtest.java.lang.RecordComponentTest",
            "crossvmtest.java.lang.RecordTest"]
+},
+{
+   description: "Test should run only on device as it depends on compat check and Android specific behavior",
+   result: EXEC_FAILED,
+   modes: [host],
+   names: ["test.java.util.concurrent.tck.ScheduledExecutorTest#testFixedRateSequenceSkipMultipleMissedFixedRateTasksDisabled"]
 }
 ]
diff --git a/tools/libcore_gcstress_failures.txt b/tools/libcore_gcstress_failures.txt
index de9e520eaa..97098926aa 100644
--- a/tools/libcore_gcstress_failures.txt
+++ b/tools/libcore_gcstress_failures.txt
@@ -46,6 +46,7 @@
           "org.apache.harmony.tests.java.util.TimerTest#testOverdueTaskExecutesImmediately",
           "org.apache.harmony.tests.java.util.WeakHashMapTest#test_keySet_hasNext",
           "test.java.math.BigDecimal.DivideMcTests#mcDivideTests",
+          "test.java.math.BigInteger.BigIntegerTest#testConstructor",
           "test.java.util.Collections.RacingCollections#main"]
 },
 {
diff --git a/tools/luci/config/generated/cr-buildbucket.cfg b/tools/luci/config/generated/cr-buildbucket.cfg
index 95fc366eb3..722a36e1ef 100644
--- a/tools/luci/config/generated/cr-buildbucket.cfg
+++ b/tools/luci/config/generated/cr-buildbucket.cfg
@@ -17,6 +17,7 @@ buckets {
     builders {
       name: "angler-armv7-debug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -48,6 +49,7 @@ buckets {
     builders {
       name: "angler-armv7-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -78,7 +80,7 @@ buckets {
     builders {
       name: "angler-armv7-non-gen-cc"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_type:oriole"
+      dimensions: "device_os:A"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -108,6 +110,7 @@ buckets {
     builders {
       name: "angler-armv8-debug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -139,6 +142,7 @@ buckets {
     builders {
       name: "angler-armv8-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -169,7 +173,7 @@ buckets {
     builders {
       name: "angler-armv8-non-gen-cc"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_type:oriole"
+      dimensions: "device_os:A"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -199,6 +203,7 @@ buckets {
     builders {
       name: "bullhead-armv7-gcstress-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -230,6 +235,7 @@ buckets {
     builders {
       name: "bullhead-armv8-gcstress-debug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -262,6 +268,7 @@ buckets {
     builders {
       name: "bullhead-armv8-gcstress-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -293,7 +300,7 @@ buckets {
     builders {
       name: "host-x86-cms"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -320,7 +327,7 @@ buckets {
     builders {
       name: "host-x86-debug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -349,7 +356,7 @@ buckets {
     builders {
       name: "host-x86-gcstress-debug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -379,7 +386,7 @@ buckets {
     builders {
       name: "host-x86-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -407,7 +414,7 @@ buckets {
     builders {
       name: "host-x86-poison-debug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -437,7 +444,7 @@ buckets {
     builders {
       name: "host-x86_64-cms"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -464,7 +471,7 @@ buckets {
     builders {
       name: "host-x86_64-debug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -493,7 +500,7 @@ buckets {
     builders {
       name: "host-x86_64-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -521,7 +528,7 @@ buckets {
     builders {
       name: "host-x86_64-non-gen-cc"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -549,7 +556,187 @@ buckets {
     builders {
       name: "host-x86_64-poison-debug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "os:Ubuntu-20"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:64"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "debug:true"
+        properties_j: "generational_cc:true"
+        properties_j: "heap_poisoning:true"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "host.x86.debug.32"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu-22"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:32"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "debug:true"
+        properties_j: "generational_cc:true"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "host.x86.debug.64"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu-22"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:64"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "debug:true"
+        properties_j: "generational_cc:true"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "host.x86.ndebug.32"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu-22"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:32"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "generational_cc:true"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--ndebug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "host.x86.ndebug.64"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu-22"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:64"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "generational_cc:true"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--ndebug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "host.x86.poison.debug.32"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu-22"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:32"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "debug:true"
+        properties_j: "generational_cc:true"
+        properties_j: "heap_poisoning:true"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "host.x86.poison.debug.64"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu-22"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -579,7 +766,8 @@ buckets {
     builders {
       name: "qemu-armv8-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "cores:16"
+      dimensions: "os:Ubuntu-22"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -610,7 +798,8 @@ buckets {
     builders {
       name: "qemu-riscv64-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "cores:16"
+      dimensions: "os:Ubuntu-22"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -639,22 +828,120 @@ buckets {
       }
     }
     builders {
-      name: "qemu-riscv64-ndebug-build_only"
+      name: "target.arm.poison.debug.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Linux"
+      dimensions: "device_os:S"
+      dimensions: "os:Android"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:32"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "debug:true"
+        properties_j: "device:\"target.arm.poison.debug.32\""
+        properties_j: "generational_cc:true"
+        properties_j: "heap_poisoning:true"
+        properties_j: "product:\"arm_krait\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "target.arm.poison.debug.64"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
+      dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
         properties_j: "bitness:64"
-        properties_j: "build_only:true"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
-        properties_j: "device:\"qemu-riscv64\""
+        properties_j: "debug:true"
+        properties_j: "device:\"target.arm.poison.debug.64\""
         properties_j: "generational_cc:true"
-        properties_j: "on_virtual_machine:true"
-        properties_j: "product:\"riscv64\""
+        properties_j: "heap_poisoning:true"
+        properties_j: "product:\"armv8\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "target.arm.poison.ndebug.32"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
+      dimensions: "os:Android"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:32"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "device:\"target.arm.poison.ndebug.32\""
+        properties_j: "generational_cc:true"
+        properties_j: "heap_poisoning:true"
+        properties_j: "product:\"arm_krait\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
+      }
+      execution_timeout_secs: 108000
+      expiration_secs: 61200
+      caches {
+        name: "art"
+        path: "art"
+      }
+      build_numbers: YES
+      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "luci.recipes.use_python3"
+        value: 100
+      }
+    }
+    builders {
+      name: "target.arm.poison.ndebug.64"
+      swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
+      dimensions: "os:Android"
+      dimensions: "pool:luci.art.ci"
+      recipe {
+        name: "art"
+        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
+        cipd_version: "refs/heads/main"
+        properties_j: "bitness:64"
+        properties_j: "builder_group:\"client.art\""
+        properties_j: "concurrent_collector:true"
+        properties_j: "device:\"target.arm.poison.ndebug.64\""
+        properties_j: "generational_cc:true"
+        properties_j: "heap_poisoning:true"
+        properties_j: "product:\"armv8\""
         properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
       }
       execution_timeout_secs: 108000
@@ -673,6 +960,7 @@ buckets {
     builders {
       name: "walleye-armv7-poison-debug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -705,6 +993,7 @@ buckets {
     builders {
       name: "walleye-armv8-poison-debug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -737,6 +1026,7 @@ buckets {
     builders {
       name: "walleye-armv8-poison-ndebug"
       swarming_host: "chromium-swarm.appspot.com"
+      dimensions: "device_os:S"
       dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
@@ -766,4 +1056,20 @@ buckets {
       }
     }
   }
+  shadow: "ci.shadow"
+}
+buckets {
+  name: "ci.shadow"
+  acls {
+    role: WRITER
+    group: "project-art-admins"
+  }
+  acls {
+    group: "all"
+  }
+  constraints {
+    pools: "luci.art.ci"
+    service_accounts: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+  }
+  dynamic_builder_template {}
 }
diff --git a/tools/luci/config/generated/luci-milo.cfg b/tools/luci/config/generated/luci-milo.cfg
index b09f6f7382..a1a06892ff 100644
--- a/tools/luci/config/generated/luci-milo.cfg
+++ b/tools/luci/config/generated/luci-milo.cfg
@@ -126,9 +126,9 @@ consoles {
     short_name: "ndbg"
   }
   builders {
-    name: "buildbucket/luci.art.ci/qemu-riscv64-ndebug-build_only"
+    name: "buildbucket/luci.art.ci/qemu-riscv64-ndebug"
     category: "qemu|riscv64"
-    short_name: "bo"
+    short_name: "ndbg"
   }
   include_experimental_builds: true
 }
diff --git a/tools/luci/config/generated/luci-notify.cfg b/tools/luci/config/generated/luci-notify.cfg
index 1d4aec2f65..e99b2f4ae1 100644
--- a/tools/luci/config/generated/luci-notify.cfg
+++ b/tools/luci/config/generated/luci-notify.cfg
@@ -277,19 +277,6 @@ notifiers {
     name: "qemu-riscv64-ndebug"
   }
 }
-notifiers {
-  notifications {
-    on_new_status: FAILURE
-    on_new_status: INFRA_FAILURE
-    email {
-      recipients: "art-team+chromium-buildbot@google.com"
-    }
-  }
-  builders {
-    bucket: "ci"
-    name: "qemu-riscv64-ndebug-build_only"
-  }
-}
 notifiers {
   notifications {
     on_new_status: FAILURE
diff --git a/tools/luci/config/generated/luci-scheduler.cfg b/tools/luci/config/generated/luci-scheduler.cfg
index 9056e597dd..7f4a6bab88 100644
--- a/tools/luci/config/generated/luci-scheduler.cfg
+++ b/tools/luci/config/generated/luci-scheduler.cfg
@@ -194,6 +194,66 @@ job {
     builder: "host-x86_64-poison-debug"
   }
 }
+job {
+  id: "host.x86.debug.32"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "host.x86.debug.32"
+  }
+}
+job {
+  id: "host.x86.debug.64"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "host.x86.debug.64"
+  }
+}
+job {
+  id: "host.x86.ndebug.32"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "host.x86.ndebug.32"
+  }
+}
+job {
+  id: "host.x86.ndebug.64"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "host.x86.ndebug.64"
+  }
+}
+job {
+  id: "host.x86.poison.debug.32"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "host.x86.poison.debug.32"
+  }
+}
+job {
+  id: "host.x86.poison.debug.64"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "host.x86.poison.debug.64"
+  }
+}
 job {
   id: "qemu-armv8-ndebug"
   realm: "ci"
@@ -215,13 +275,43 @@ job {
   }
 }
 job {
-  id: "qemu-riscv64-ndebug-build_only"
+  id: "target.arm.poison.debug.32"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "target.arm.poison.debug.32"
+  }
+}
+job {
+  id: "target.arm.poison.debug.64"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "target.arm.poison.debug.64"
+  }
+}
+job {
+  id: "target.arm.poison.ndebug.32"
+  realm: "ci"
+  acl_sets: "ci"
+  buildbucket {
+    server: "cr-buildbucket.appspot.com"
+    bucket: "ci"
+    builder: "target.arm.poison.ndebug.32"
+  }
+}
+job {
+  id: "target.arm.poison.ndebug.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "qemu-riscv64-ndebug-build_only"
+    builder: "target.arm.poison.ndebug.64"
   }
 }
 job {
@@ -277,9 +367,18 @@ trigger {
   triggers: "host-x86_64-ndebug"
   triggers: "host-x86_64-non-gen-cc"
   triggers: "host-x86_64-poison-debug"
+  triggers: "host.x86.debug.32"
+  triggers: "host.x86.debug.64"
+  triggers: "host.x86.ndebug.32"
+  triggers: "host.x86.ndebug.64"
+  triggers: "host.x86.poison.debug.32"
+  triggers: "host.x86.poison.debug.64"
   triggers: "qemu-armv8-ndebug"
   triggers: "qemu-riscv64-ndebug"
-  triggers: "qemu-riscv64-ndebug-build_only"
+  triggers: "target.arm.poison.debug.32"
+  triggers: "target.arm.poison.debug.64"
+  triggers: "target.arm.poison.ndebug.32"
+  triggers: "target.arm.poison.ndebug.64"
   triggers: "walleye-armv7-poison-debug"
   triggers: "walleye-armv8-poison-debug"
   triggers: "walleye-armv8-poison-ndebug"
@@ -311,9 +410,18 @@ trigger {
   triggers: "host-x86_64-ndebug"
   triggers: "host-x86_64-non-gen-cc"
   triggers: "host-x86_64-poison-debug"
+  triggers: "host.x86.debug.32"
+  triggers: "host.x86.debug.64"
+  triggers: "host.x86.ndebug.32"
+  triggers: "host.x86.ndebug.64"
+  triggers: "host.x86.poison.debug.32"
+  triggers: "host.x86.poison.debug.64"
   triggers: "qemu-armv8-ndebug"
   triggers: "qemu-riscv64-ndebug"
-  triggers: "qemu-riscv64-ndebug-build_only"
+  triggers: "target.arm.poison.debug.32"
+  triggers: "target.arm.poison.debug.64"
+  triggers: "target.arm.poison.ndebug.32"
+  triggers: "target.arm.poison.ndebug.64"
   triggers: "walleye-armv7-poison-debug"
   triggers: "walleye-armv8-poison-debug"
   triggers: "walleye-armv8-poison-ndebug"
@@ -345,9 +453,18 @@ trigger {
   triggers: "host-x86_64-ndebug"
   triggers: "host-x86_64-non-gen-cc"
   triggers: "host-x86_64-poison-debug"
+  triggers: "host.x86.debug.32"
+  triggers: "host.x86.debug.64"
+  triggers: "host.x86.ndebug.32"
+  triggers: "host.x86.ndebug.64"
+  triggers: "host.x86.poison.debug.32"
+  triggers: "host.x86.poison.debug.64"
   triggers: "qemu-armv8-ndebug"
   triggers: "qemu-riscv64-ndebug"
-  triggers: "qemu-riscv64-ndebug-build_only"
+  triggers: "target.arm.poison.debug.32"
+  triggers: "target.arm.poison.debug.64"
+  triggers: "target.arm.poison.ndebug.32"
+  triggers: "target.arm.poison.ndebug.64"
   triggers: "walleye-armv7-poison-debug"
   triggers: "walleye-armv8-poison-debug"
   triggers: "walleye-armv8-poison-ndebug"
@@ -379,9 +496,18 @@ trigger {
   triggers: "host-x86_64-ndebug"
   triggers: "host-x86_64-non-gen-cc"
   triggers: "host-x86_64-poison-debug"
+  triggers: "host.x86.debug.32"
+  triggers: "host.x86.debug.64"
+  triggers: "host.x86.ndebug.32"
+  triggers: "host.x86.ndebug.64"
+  triggers: "host.x86.poison.debug.32"
+  triggers: "host.x86.poison.debug.64"
   triggers: "qemu-armv8-ndebug"
   triggers: "qemu-riscv64-ndebug"
-  triggers: "qemu-riscv64-ndebug-build_only"
+  triggers: "target.arm.poison.debug.32"
+  triggers: "target.arm.poison.debug.64"
+  triggers: "target.arm.poison.ndebug.32"
+  triggers: "target.arm.poison.ndebug.64"
   triggers: "walleye-armv7-poison-debug"
   triggers: "walleye-armv8-poison-debug"
   triggers: "walleye-armv8-poison-ndebug"
diff --git a/tools/luci/config/generated/project.cfg b/tools/luci/config/generated/project.cfg
index ff295f5c6a..90bdf85851 100644
--- a/tools/luci/config/generated/project.cfg
+++ b/tools/luci/config/generated/project.cfg
@@ -7,7 +7,7 @@
 name: "art"
 access: "group:all"
 lucicfg {
-  version: "1.43.6"
+  version: "1.43.13"
   package_dir: ".."
   config_dir: "generated"
   entry_point: "main.star"
diff --git a/tools/luci/config/generated/realms.cfg b/tools/luci/config/generated/realms.cfg
index c45317659a..d439ea168c 100644
--- a/tools/luci/config/generated/realms.cfg
+++ b/tools/luci/config/generated/realms.cfg
@@ -58,6 +58,21 @@ realms {
     principals: "user:art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
   }
 }
+realms {
+  name: "ci.shadow"
+  bindings {
+    role: "role/buildbucket.builderServiceAccount"
+    principals: "user:art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+  }
+  bindings {
+    role: "role/buildbucket.creator"
+    principals: "user:art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+  }
+  bindings {
+    role: "role/buildbucket.triggerer"
+    principals: "user:art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+  }
+}
 realms {
   name: "pools/ci"
 }
diff --git a/tools/luci/config/main.star b/tools/luci/config/main.star
index 2296a5e7ee..56cb4c1900 100755
--- a/tools/luci/config/main.star
+++ b/tools/luci/config/main.star
@@ -102,6 +102,27 @@ luci.binding(
 luci.realm(name = "pools/ci")
 luci.bucket(name = "ci")
 
+# Shadow bucket is needed for LED.
+luci.bucket(
+    name = "ci.shadow",
+    shadows = "ci",
+    bindings = [
+        luci.binding(
+            roles = "role/buildbucket.creator",
+            users = ["art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"],
+        ),
+        luci.binding(
+            roles = "role/buildbucket.triggerer",
+            users = ["art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"],
+        ),
+    ],
+    constraints = luci.bucket_constraints(
+        pools = ["luci.art.ci"],
+        service_accounts = ["art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"],
+    ),
+    dynamic = True,
+)
+
 luci.notifier_template(
     name = "default",
     body = io.read_file("luci-notify.template"),
@@ -154,7 +175,7 @@ luci.gitiles_poller(
     refs = ["refs/heads/master-art"],
 )
 
-def ci_builder(name, category, short_name, dimensions, properties={}, is_fyi=False):
+def ci_builder(name, category, short_name, dimensions, properties={}, hidden=False):
     luci.builder(
         name = name,
         bucket = "ci",
@@ -182,7 +203,7 @@ def ci_builder(name, category, short_name, dimensions, properties={}, is_fyi=Fal
             # We can checkout and build in this directory to get fast incremental builds.
             swarming.cache("art", name = "art"),
         ],
-        notifies = ["art-team+chromium-buildbot"],
+        notifies = ["art-team+chromium-buildbot"] if not hidden else [],
         triggered_by = [
             "art",
             "libcore",
@@ -190,7 +211,7 @@ def ci_builder(name, category, short_name, dimensions, properties={}, is_fyi=Fal
             "vogar",
         ],
     )
-    if not is_fyi:
+    if not hidden:
         luci.console_view_entry(
             console_view = "luci",
             builder = name,
@@ -214,9 +235,18 @@ def add_builder(name,
     check_arg(arch, ["arm", "x86", "riscv"])
     check_arg(bitness, [32, 64])
 
+    # Automatically create name based on the configuaration.
+    default_name = mode + '.' + arch
+    default_name += '.gsctress' if gcstress else ''
+    default_name += '.poison' if heap_poisoning else ''
+    default_name += '' if cc else '.ncc'
+    default_name += '' if gen_cc else '.ngen'
+    default_name += '.debug' if debug else '.ndebug'
+    default_name += '.' + str(bitness)
+
     # Create abbreviated named which is used to create the LUCI console header.
     # TODO: Rename the builders to remove old device names and make it more uniform.
-    short_name = name
+    short_name = name or default_name.replace(".", "-")
     short_name = short_name.replace("-x86-poison-debug", "-x86-psn")
     short_name = short_name.replace("-x86-gcstress-debug", "-x86-gcs")
     short_name = short_name.replace("-x86_64-poison-debug", "-x86_64-psn")
@@ -233,14 +263,38 @@ def add_builder(name,
       product = "riscv64"
 
     dimensions = {"os": "Android" if mode == "target" else "Linux"}
-    if mode == "target" and not cc:
-      # userfault-GC configurations must be run on Pixel 6.
-      dimensions |= {"device_type": "oriole"}
+    if mode == "target":
+      if not cc:
+        # Request devices running Android 24Q3 (`AP1A` builds) for
+        # (`userfaultfd`-based) Concurrent Mark-Compact GC configurations.
+        # Currently (as of 2024-08-22), the only devices within the device pool
+        # allocated to ART that are running `AP1A` builds are Pixel 6 devices
+        # (all other device types are running older Android versions), which are
+        # also the only device model supporting `userfaultfd` among that pool.
+        dimensions |= {"device_os": "A"}
+      else:
+        # Run all other configurations on Android S since it is the oldest we support.
+        # Other than the `AP1A` builds above, all other devices are flashed to `SP2A`.
+        # This avoids allocating `userfaultfd` devices for tests that don't need it.
+        dimensions |= {"device_os": "S"}
+    elif mode == "host":
+      if name:
+        dimensions |= {"os": "Ubuntu-20"}
+      else:
+        # Test the new host builders with new ubuntu.
+        dimensions |= {"os": "Ubuntu-22"}
+        dimensions |= {"cores": "8"}
+    elif mode == "qemu":
+      dimensions |= {"os": "Ubuntu-22"}
+      dimensions |= {"cores": "16"}
 
     testrunner_args = ['--verbose', '--host'] if mode == 'host' else ['--target', '--verbose']
     testrunner_args += ['--debug'] if debug else ['--ndebug']
     testrunner_args += ['--gcstress'] if gcstress else []
 
+    hidden = not name  # Hide the new builders for now.
+    name = name or default_name
+
     properties = {
         "builder_group": "client.art",
         "bitness": bitness,
@@ -256,14 +310,12 @@ def add_builder(name,
         "testrunner_args": testrunner_args,
     }
 
-    is_fyi = (name == "qemu-riscv64-ndebug")
-
     ci_builder(name,
                category="|".join(short_name.split("-")[:-1]),
                short_name=short_name.split("-")[-1],
                dimensions=dimensions,
                properties={k:v for k, v in properties.items() if v},
-               is_fyi=is_fyi)
+               hidden=hidden)
 
 add_builder("angler-armv7-debug", 'target', 'arm', 32, debug=True)
 add_builder("angler-armv7-non-gen-cc", 'target', 'arm', 32, debug=True, cc=False, gen_cc=False)
@@ -289,4 +341,13 @@ add_builder("host-x86_64-ndebug", 'host', 'x86', 64)
 add_builder("host-x86_64-poison-debug", 'host', 'x86', 64, debug=True, heap_poisoning=True)
 add_builder("qemu-armv8-ndebug", 'qemu', 'arm', 64)
 add_builder("qemu-riscv64-ndebug", 'qemu', 'riscv', 64)
-add_builder("qemu-riscv64-ndebug-build_only", 'qemu', 'riscv', 64)
\ No newline at end of file
+
+def add_builders():
+  for bitness in [32, 64]:
+    add_builder('', 'target', 'arm', bitness, debug=True, heap_poisoning=True)
+    add_builder('', 'target', 'arm', bitness, heap_poisoning=True)
+    add_builder('', 'host', 'x86', bitness, debug=True)
+    add_builder('', 'host', 'x86', bitness)
+    add_builder('', 'host', 'x86', bitness, debug=True, heap_poisoning=True)
+
+add_builders()
\ No newline at end of file
diff --git a/tools/public.libraries.buildbot.txt b/tools/public.libraries.buildbot.txt
index 9b0dc6858a..fdd8b71393 100644
--- a/tools/public.libraries.buildbot.txt
+++ b/tools/public.libraries.buildbot.txt
@@ -3,4 +3,3 @@ libc++.so
 libdl.so
 libm.so
 libnativehelper.so
-libunwindstack.so
diff --git a/tools/run-jdwp-tests.sh b/tools/run-jdwp-tests.sh
index 699a2e569d..deeab44d18 100755
--- a/tools/run-jdwp-tests.sh
+++ b/tools/run-jdwp-tests.sh
@@ -20,7 +20,7 @@ if [ ! -d libcore ]; then
 fi
 
 source build/envsetup.sh >&/dev/null # for get_build_var, setpaths
-setpaths # include platform prebuilt java, javac, etc in $PATH.
+set_lunch_paths # include platform prebuilt java, javac, etc in $PATH.
 
 if [ -z "$ANDROID_HOST_OUT" ] ; then
   ANDROID_HOST_OUT=${OUT_DIR-$ANDROID_BUILD_TOP/out}/host/linux-x86
diff --git a/tools/run-libjdwp-tests.sh b/tools/run-libjdwp-tests.sh
index bb9c300836..0748140c15 100755
--- a/tools/run-libjdwp-tests.sh
+++ b/tools/run-libjdwp-tests.sh
@@ -118,7 +118,7 @@ if [[ "$has_jdwp_path" = "no" ]]; then
       echo "Please set ANDROID_BUILD_TOP"
       exit 1
     fi
-    args+=(--jdwp-path  $ANDROID_BUILD_TOP/"prebuilts/jdk/jdk17/linux-x86/lib/libjdwp.so")
+    args+=(--jdwp-path  $ANDROID_BUILD_TOP/"prebuilts/jdk/jdk21/linux-x86/lib/libjdwp.so")
   else
     args+=(--jdwp-path  "libjdwp.so")
   fi
diff --git a/tools/run-prebuilt-libjdwp-tests.sh b/tools/run-prebuilt-libjdwp-tests.sh
index e7f028ae63..43f0fd8f9c 100755
--- a/tools/run-prebuilt-libjdwp-tests.sh
+++ b/tools/run-prebuilt-libjdwp-tests.sh
@@ -20,7 +20,7 @@ if [[ ! -d libcore ]];  then
 fi
 
 source build/envsetup.sh >&/dev/null # for get_build_var, setpaths
-setpaths # include platform prebuilt java, javac, etc in $PATH.
+set_lunch_paths # include platform prebuilt java, javac, etc in $PATH.
 
 if [[ `uname` != 'Linux' ]];  then
   echo "Script cannot be run on $(uname). It is Linux only."
```

