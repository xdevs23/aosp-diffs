```diff
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_not_pre_installed_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_not_pre_installed_apex.asciipb
index 7aec0c4e..847cf1b7 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_not_pre_installed_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_not_pre_installed_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim_not_pre_installed.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v1_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v1_apex.asciipb
index c7c5d96f..3dd19219 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v1_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v1_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v1.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_add_apk_to_apex_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_add_apk_to_apex_apex.asciipb
new file mode 100644
index 00000000..5ff4eeee
--- /dev/null
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_add_apk_to_apex_apex.asciipb
@@ -0,0 +1,15 @@
+drops {
+  android_build_drop {
+    build_id: "11947186"
+    target: "CtsShim"
+    source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_add_apk_to_apex.apex"
+  }
+  dest_file: "shim/prebuilts//riscv64/com.android.apex.cts.shim.v2_add_apk_to_apex.apex"
+  version: ""
+  version_group: ""
+  git_project: "platform/system/apex"
+  git_branch: "main"
+  transform: TRANSFORM_NONE
+  transform_options {
+  }
+}
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_file_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_file_apex.asciipb
index 6da96c9e..77e50925 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_file_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_file_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_additional_file.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_folder_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_folder_apex.asciipb
index 402c1bf4..31a0a74c 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_folder_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_additional_folder_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_additional_folder.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apex.asciipb
index f0ee12d4..c9245180 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_sdk_target_p_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_sdk_target_p_apex.asciipb
index 3379860d..07fa0cfd 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_sdk_target_p_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_sdk_target_p_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_apk_in_apex_sdk_target_p.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_upgrades_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_upgrades_apex.asciipb
index d6ee9025..97505a19 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_upgrades_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_apk_in_apex_upgrades_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_apk_in_apex_upgrades.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_certificate_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_certificate_apex.asciipb
index eb2a8f98..812e33b0 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_certificate_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_certificate_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_different_certificate.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_package_name_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_package_name_apex.asciipb
index c61e71ad..c3510036 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_package_name_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_different_package_name_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_different_package_name.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_empty_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_empty_apex.asciipb
index 9716a421..393775ee 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_empty_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_empty_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_install_constraints_empty.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_invalid_fingerprint_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_invalid_fingerprint_apex.asciipb
index 5301d7a0..f2b7823e 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_invalid_fingerprint_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_invalid_fingerprint_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_install_constraints_invalid_fingerprint.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_no_value_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_no_value_apex.asciipb
index febef875..c5b47587 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_no_value_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_install_constraints_no_value_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_install_constraints_no_value.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_no_hashtree_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_no_hashtree_apex.asciipb
index 1b332b9a..bda95887 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_no_hashtree_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_no_hashtree_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_no_hashtree.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_rebootless_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_rebootless_apex.asciipb
index b420f8b3..d529c185 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_rebootless_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_rebootless_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_rebootless.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sdk_target_p_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sdk_target_p_apex.asciipb
index 019749ef..26ab2aff 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sdk_target_p_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sdk_target_p_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_sdk_target_p.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sign_payload_with_different_key_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sign_payload_with_different_key_apex.asciipb
index 4439653c..3f98c33b 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sign_payload_with_different_key_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_sign_payload_with_different_key_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_sign_payload_with_different_key.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_apex.asciipb
index 3abbfcaa..112ed904 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_signed_bob.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_apex.asciipb
index a7daf2cc..c62127dc 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_signed_bob_rot.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_rollback_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_rollback_apex.asciipb
index d77dde79..96bd303c 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_rollback_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_signed_bob_rot_rollback_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_apk_container_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_apk_container_apex.asciipb
index 2b38588f..e542215e 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_apk_container_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_apk_container_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_unsigned_apk_container.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_payload_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_payload_apex.asciipb
index d2a28642..3dea12f4 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_payload_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_unsigned_payload_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_unsigned_payload.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_post_install_hook_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_post_install_hook_apex.asciipb
index c377c9ad..9777cbaa 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_post_install_hook_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_post_install_hook_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_with_post_install_hook.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_pre_install_hook_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_pre_install_hook_apex.asciipb
index 61134be3..31234306 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_pre_install_hook_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_with_pre_install_hook_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_with_pre_install_hook.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_without_apk_in_apex_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_without_apk_in_apex_apex.asciipb
index 5947ed83..e2f685b4 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_without_apk_in_apex_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_without_apk_in_apex_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_without_apk_in_apex.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_wrong_sha_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_wrong_sha_apex.asciipb
index c23dcb2b..8bc8084d 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_wrong_sha_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v2_wrong_sha_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v2_wrong_sha.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_apex.asciipb
index 6d82a531..ac2a88cb 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v3.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_rebootless_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_rebootless_apex.asciipb
index 47cc8e94..6d9c9baa 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_rebootless_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_rebootless_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v3_rebootless.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_apex.asciipb
index 4c3db42f..07cd844e 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v3_signed_bob.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_rot_apex.asciipb b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_rot_apex.asciipb
index 747285aa..8ce72171 100644
--- a/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_rot_apex.asciipb
+++ b/.prebuilt_info/prebuilt_info_shim_prebuilts__riscv64_com_android_apex_cts_shim_v3_signed_bob_rot_apex.asciipb
@@ -1,6 +1,6 @@
 drops {
   android_build_drop {
-    build_id: "9653376"
+    build_id: "11947186"
     target: "CtsShim"
     source_file: "aosp_riscv64/com.android.apex.cts.shim.v3_signed_bob_rot.apex"
   }
@@ -8,7 +8,7 @@ drops {
   version: ""
   version_group: ""
   git_project: "platform/system/apex"
-  git_branch: "master"
+  git_branch: "main"
   transform: TRANSFORM_NONE
   transform_options {
   }
diff --git a/apexd/Android.bp b/apexd/Android.bp
index f9927118..261d882c 100644
--- a/apexd/Android.bp
+++ b/apexd/Android.bp
@@ -63,7 +63,10 @@ cc_defaults {
         "-Wunreachable-code-return",
         "-Wunused",
         "-Wused-but-marked-unused",
-    ],
+    ] + select(release_flag("RELEASE_AVF_ENABLE_EARLY_VM"), {
+        true: ["-DRELEASE_AVF_ENABLE_EARLY_VM"],
+        default: [],
+    }),
     tidy: true,
     tidy_checks: tidy_errors,
     tidy_checks_as_errors: tidy_errors,
@@ -187,8 +190,10 @@ cc_library_static {
         "apex_database.cpp",
         "apex_file_repository.cpp",
         "apexd.cpp",
+        "apexd_dm.cpp",
         "apexd_lifecycle.cpp",
         "apexd_loop.cpp",
+        "apexd_metrics.cpp",
         "apexd_private.cpp",
         "apexd_session.cpp",
         "apexd_verity.cpp",
@@ -250,7 +255,6 @@ cc_defaults {
         "lib_apex_session_state_proto",
         "lib_apex_manifest_proto",
         "libavb",
-        "libverity_tree",
     ],
     cpp_std: "experimental",
 }
@@ -303,26 +307,6 @@ genrule {
         "$(genDir)/apex.apexd_test_manifest_mismatch.apex",
 }
 
-genrule {
-    // Generates an apex which has a different manifest outside the filesystem
-    // image.
-    name: "gen_manifest_mismatch_apex_no_hashtree",
-    out: ["apex.apexd_test_no_hashtree_manifest_mismatch.apex"],
-    srcs: [":apex.apexd_test_no_hashtree"],
-    tools: [
-        "soong_zip",
-        "zipalign",
-        "conv_apex_manifest",
-    ],
-    cmd: "unzip -q $(in) -d $(genDir) && " +
-        "$(location conv_apex_manifest) setprop version 137 $(genDir)/apex_manifest.pb && " +
-        "$(location soong_zip) -d -C $(genDir) -D $(genDir) " +
-        "-s apex_manifest.pb -s apex_payload.img -s apex_pubkey " +
-        "-o $(genDir)/unaligned.apex && " +
-        "$(location zipalign) -f 4096 $(genDir)/unaligned.apex " +
-        "$(genDir)/apex.apexd_test_no_hashtree_manifest_mismatch.apex",
-}
-
 genrule {
     // Generates an apex with a corrupted filesystem superblock, which should cause
     // Apex::Open to fail
@@ -495,8 +479,6 @@ cc_test {
         ":apex.apexd_test_f2fs_digest",
         ":apex.apexd_test_classpath",
         ":apex.apexd_test_different_app",
-        ":apex.apexd_test_no_hashtree",
-        ":apex.apexd_test_no_hashtree_2",
         ":apex.apexd_test_no_inst_key",
         ":apex.apexd_test_f2fs_no_inst_key",
         ":apex.apexd_test_nocode",
@@ -507,7 +489,6 @@ cc_test {
         ":gen_key_mismatch_apex_v2",
         ":gen_key_mismatch_capex",
         ":gen_manifest_mismatch_apex",
-        ":gen_manifest_mismatch_apex_no_hashtree",
         ":gen_corrupt_superblock_apex",
         ":gen_corrupt_apex",
         ":gen_capex_not_decompressible",
@@ -535,7 +516,6 @@ cc_test {
         ":com.android.apex.test.sharedlibs_generated.v2.libvY_prebuilt",
         ":test.rebootless_apex_v1",
         ":test.rebootless_apex_v2",
-        ":test.rebootless_apex_v2_no_hashtree",
         ":test.rebootless_apex_service_v1",
         ":test.rebootless_apex_service_v2",
         ":gen_manifest_mismatch_rebootless_apex",
@@ -557,7 +537,6 @@ cc_test {
         "apex_manifest_test.cpp",
         "apexd_test.cpp",
         "apexd_session_test.cpp",
-        "apexd_verity_test.cpp",
         "apexd_utils_test.cpp",
     ],
     host_supported: false,
@@ -602,8 +581,6 @@ cc_test {
         ":apex.apexd_test_f2fs_digest",
         ":apex.apexd_test_classpath",
         ":apex.apexd_test_different_app",
-        ":apex.apexd_test_no_hashtree",
-        ":apex.apexd_test_no_hashtree_2",
         ":apex.apexd_test_no_inst_key",
         ":apex.apexd_test_f2fs_no_inst_key",
         ":apex.apexd_test_nocode",
@@ -614,7 +591,6 @@ cc_test {
         ":gen_key_mismatch_apex_v2",
         ":gen_key_mismatch_capex",
         ":gen_manifest_mismatch_apex",
-        ":gen_manifest_mismatch_apex_no_hashtree",
         ":gen_corrupt_superblock_apex",
         ":gen_corrupt_apex",
         ":gen_capex_not_decompressible",
@@ -642,7 +618,6 @@ cc_test {
         ":com.android.apex.test.sharedlibs_generated.v2.libvY_prebuilt",
         ":test.rebootless_apex_v1",
         ":test.rebootless_apex_v2",
-        ":test.rebootless_apex_v2_no_hashtree",
         ":test.rebootless_apex_service_v1",
         ":test.rebootless_apex_service_v2",
         ":gen_manifest_mismatch_rebootless_apex",
diff --git a/apexd/TEST_MAPPING b/apexd/TEST_MAPPING
index 8daa9018..1a301314 100644
--- a/apexd/TEST_MAPPING
+++ b/apexd/TEST_MAPPING
@@ -14,6 +14,9 @@
     {
       "path": "system/apex/tests"
     },
+    {
+      "path": "system/apex/tools"
+    },
     {
       "path": "vendor/xts/gts-tests/hostsidetests/stagedinstall"
     },
diff --git a/apexd/apex_constants.h b/apexd/apex_constants.h
index 522f4f8f..aea592f3 100644
--- a/apexd/apex_constants.h
+++ b/apexd/apex_constants.h
@@ -26,18 +26,15 @@ namespace apex {
 static constexpr const char* kApexDataDir = "/data/apex";
 static constexpr const char* kActiveApexPackagesDataDir = "/data/apex/active";
 static constexpr const char* kApexBackupDir = "/data/apex/backup";
-static constexpr const char* kApexHashTreeDir = "/data/apex/hashtree";
 static constexpr const char* kApexDecompressedDir = "/data/apex/decompressed";
 static constexpr const char* kOtaReservedDir = "/data/apex/ota_reserved";
 static constexpr const char* kApexPackageSystemDir = "/system/apex";
 static constexpr const char* kApexPackageSystemExtDir = "/system_ext/apex";
 static constexpr const char* kApexPackageVendorDir = "/vendor/apex";
+static constexpr const char* kApexPackageOdmDir = "/odm/apex";
 static const std::vector<std::string> kApexPackageBuiltinDirs = {
-    kApexPackageSystemDir,
-    kApexPackageSystemExtDir,
-    "/product/apex",
-    kApexPackageVendorDir,
-};
+    kApexPackageSystemDir, kApexPackageSystemExtDir, "/product/apex",
+    kApexPackageVendorDir, kApexPackageOdmDir};
 static constexpr const char* kApexRoot = "/apex";
 static constexpr const char* kStagedSessionsDir = "/data/app-staging";
 
diff --git a/apexd/apex_database.cpp b/apexd/apex_database.cpp
index 1395c13d..bee8fc6f 100644
--- a/apexd/apex_database.cpp
+++ b/apexd/apex_database.cpp
@@ -126,54 +126,33 @@ bool IsActiveMountPoint(const std::string& mount_point) {
   return (mount_point.find('@') == std::string::npos);
 }
 
+bool IsTempMountPoint(const std::string& mount_point) {
+  return EndsWith(mount_point, ".tmp");
+}
+
 Result<void> PopulateLoopInfo(const BlockDevice& top_device,
                               const std::vector<std::string>& data_dirs,
-                              const std::string& apex_hash_tree_dir,
                               MountedApexData* apex_data) {
   std::vector<BlockDevice> slaves = top_device.GetSlaves();
-  if (slaves.size() != 1 && slaves.size() != 2) {
+  if (slaves.size() != 1) {
     return Error() << "dm device " << top_device.DevPath()
-                   << " has unexpected number of slaves : " << slaves.size();
-  }
-  std::vector<std::string> backing_files;
-  backing_files.reserve(slaves.size());
-  for (const auto& dev : slaves) {
-    if (dev.GetType() != LoopDevice) {
-      return Error() << dev.DevPath() << " is not a loop device";
-    }
-    auto backing_file = dev.GetProperty("loop/backing_file");
-    if (!backing_file.ok()) {
-      return backing_file.error();
-    }
-    backing_files.push_back(std::move(*backing_file));
+                   << " has unexpected number of slaves (should be 1) : "
+                   << slaves.size();
   }
-  // Enforce following invariant:
-  //  * slaves[0] always represents a data loop device
-  //  * if size = 2 then slaves[1] represents an external hashtree loop device
-  auto is_data_loop_device = [&](const std::string& backing_file) {
-    return std::any_of(
-        data_dirs.begin(), data_dirs.end(),
-        [&](const std::string& dir) { return StartsWith(backing_file, dir); });
-  };
-  if (slaves.size() == 2) {
-    if (!is_data_loop_device(backing_files[0])) {
-      std::swap(slaves[0], slaves[1]);
-      std::swap(backing_files[0], backing_files[1]);
-    }
+  if (slaves[0].GetType() != LoopDevice) {
+    return Error() << slaves[0].DevPath() << " is not a loop device";
   }
-  if (!is_data_loop_device(backing_files[0])) {
+  std::string backing_file =
+      OR_RETURN(slaves[0].GetProperty("loop/backing_file"));
+  bool is_data_loop_device = std::any_of(
+      data_dirs.begin(), data_dirs.end(),
+      [&](const std::string& dir) { return StartsWith(backing_file, dir); });
+  if (!is_data_loop_device) {
     return Error() << "Data loop device " << slaves[0].DevPath()
-                   << " has unexpected backing file " << backing_files[0];
-  }
-  if (slaves.size() == 2) {
-    if (!StartsWith(backing_files[1], apex_hash_tree_dir)) {
-      return Error() << "Hashtree loop device " << slaves[1].DevPath()
-                     << " has unexpected backing file " << backing_files[1];
-    }
-    apex_data->hashtree_loop_name = slaves[1].DevPath();
+                   << " has unexpected backing file " << backing_file;
   }
   apex_data->loop_name = slaves[0].DevPath();
-  apex_data->full_path = backing_files[0];
+  apex_data->full_path = backing_file;
   return {};
 }
 
@@ -198,9 +177,7 @@ void NormalizeIfDeleted(MountedApexData* apex_data) {
 
 Result<MountedApexData> ResolveMountInfo(
     const BlockDevice& block, const std::string& mount_point,
-    const std::vector<std::string>& data_dirs,
-    const std::string& apex_hash_tree_dir) {
-  bool temp_mount = EndsWith(mount_point, ".tmp");
+    const std::vector<std::string>& data_dirs) {
   // Now, see if it is dm-verity or loop mounted
   switch (block.GetType()) {
     case LoopDevice: {
@@ -212,7 +189,6 @@ Result<MountedApexData> ResolveMountInfo(
       result.loop_name = block.DevPath();
       result.full_path = *backing_file;
       result.mount_point = mount_point;
-      result.is_temp_mount = temp_mount;
       NormalizeIfDeleted(&result);
       return result;
     }
@@ -224,9 +200,7 @@ Result<MountedApexData> ResolveMountInfo(
       MountedApexData result;
       result.mount_point = mount_point;
       result.device_name = *name;
-      result.is_temp_mount = temp_mount;
-      auto status =
-          PopulateLoopInfo(block, data_dirs, apex_hash_tree_dir, &result);
+      auto status = PopulateLoopInfo(block, data_dirs, &result);
       if (!status.ok()) {
         return status.error();
       }
@@ -261,8 +235,8 @@ Result<MountedApexData> ResolveMountInfo(
 // Need to read /proc/mounts on startup since apexd can start
 // at any time (It's a lazy service).
 void MountedApexDatabase::PopulateFromMounts(
-    const std::vector<std::string>& data_dirs,
-    const std::string& apex_hash_tree_dir) REQUIRES(!mounted_apexes_mutex_) {
+    const std::vector<std::string>& data_dirs)
+    REQUIRES(!mounted_apexes_mutex_) {
   LOG(INFO) << "Populating APEX database from mounts...";
 
   std::ifstream mounts("/proc/mounts");
@@ -277,9 +251,11 @@ void MountedApexDatabase::PopulateFromMounts(
     if (IsActiveMountPoint(mount_point)) {
       continue;
     }
-
-    auto mount_data = ResolveMountInfo(BlockDevice(block), mount_point,
-                                       data_dirs, apex_hash_tree_dir);
+    if (IsTempMountPoint(mount_point)) {
+      continue;
+    }
+    auto mount_data =
+        ResolveMountInfo(BlockDevice(block), mount_point, data_dirs);
     if (!mount_data.ok()) {
       LOG(WARNING) << "Can't resolve mount info " << mount_data.error();
       continue;
diff --git a/apexd/apex_database.h b/apexd/apex_database.h
index 041323c0..8277c4f8 100644
--- a/apexd/apex_database.h
+++ b/apexd/apex_database.h
@@ -41,60 +41,22 @@ class MountedApexDatabase {
     std::string full_path;  // Full path to the apex file.
     std::string mount_point;  // Path this apex is mounted on.
     std::string device_name;  // Name of the dm verity device.
-    // Name of the loop device backing up hashtree or empty string in case
-    // hashtree is embedded inside an APEX.
-    std::string hashtree_loop_name;
     // Whenever apex file specified in full_path was deleted.
-    bool deleted;
-    // Whether the mount is a temp mount or not.
-    bool is_temp_mount;
+    bool deleted = false;
 
-    MountedApexData() : deleted(false), is_temp_mount(false) {}
+    MountedApexData() = default;
     MountedApexData(int version, const std::string& loop_name,
                     const std::string& full_path,
                     const std::string& mount_point,
-                    const std::string& device_name,
-                    const std::string& hashtree_loop_name,
-                    bool is_temp_mount = false)
+                    const std::string& device_name)
         : version(version),
           loop_name(loop_name),
           full_path(full_path),
           mount_point(mount_point),
           device_name(device_name),
-          hashtree_loop_name(hashtree_loop_name),
-          deleted(false),
-          is_temp_mount(is_temp_mount) {}
+          deleted(false) {}
 
-    inline bool operator<(const MountedApexData& rhs) const {
-      if (version != rhs.version) {
-        return version < rhs.version;
-      }
-      int compare_val = loop_name.compare(rhs.loop_name);
-      if (compare_val < 0) {
-        return true;
-      } else if (compare_val > 0) {
-        return false;
-      }
-      compare_val = full_path.compare(rhs.full_path);
-      if (compare_val < 0) {
-        return true;
-      } else if (compare_val > 0) {
-        return false;
-      }
-      compare_val = mount_point.compare(rhs.mount_point);
-      if (compare_val < 0) {
-        return true;
-      } else if (compare_val > 0) {
-        return false;
-      }
-      compare_val = device_name.compare(rhs.device_name);
-      if (compare_val < 0) {
-        return true;
-      } else if (compare_val > 0) {
-        return false;
-      }
-      return hashtree_loop_name < rhs.hashtree_loop_name;
-    }
+    inline auto operator<=>(const MountedApexData& rhs) const = default;
   };
 
   template <typename... Args>
@@ -123,8 +85,7 @@ class MountedApexDatabase {
   }
 
   inline void RemoveMountedApex(const std::string& package,
-                                const std::string& full_path,
-                                bool match_temp_mounts = false)
+                                const std::string& full_path)
       REQUIRES(!mounted_apexes_mutex_) {
     std::lock_guard lock(mounted_apexes_mutex_);
     auto it = mounted_apexes_.find(package);
@@ -135,8 +96,7 @@ class MountedApexDatabase {
     auto& pkg_set = it->second;
 
     for (auto pkg_it = pkg_set.begin(); pkg_it != pkg_set.end(); ++pkg_it) {
-      if (pkg_it->full_path == full_path &&
-          pkg_it->is_temp_mount == match_temp_mounts) {
+      if (pkg_it->full_path == full_path) {
         pkg_set.erase(pkg_it);
         return;
       }
@@ -161,8 +121,8 @@ class MountedApexDatabase {
   }
 
   template <typename T>
-  inline void ForallMountedApexes(const std::string& package, const T& handler,
-                                  bool match_temp_mounts = false) const
+  inline void ForallMountedApexes(const std::string& package,
+                                  const T& handler) const
       REQUIRES(!mounted_apexes_mutex_) {
     std::lock_guard lock(mounted_apexes_mutex_);
     auto outer_it = mounted_apexes_.find(package);
@@ -171,25 +131,20 @@ class MountedApexDatabase {
     }
     for (auto it = outer_it->second.rbegin(), end = outer_it->second.rend();
          it != end; it++) {
-      if (it->is_temp_mount == match_temp_mounts) {
-        bool latest = (it == outer_it->second.rbegin());
-        handler(*it, latest);
-      }
+      bool latest = (it == outer_it->second.rbegin());
+      handler(*it, latest);
     }
   }
 
   template <typename T>
-  inline void ForallMountedApexes(const T& handler,
-                                  bool match_temp_mounts = false) const
+  inline void ForallMountedApexes(const T& handler) const
       REQUIRES(!mounted_apexes_mutex_) {
     std::lock_guard lock(mounted_apexes_mutex_);
     for (const auto& pkg : mounted_apexes_) {
       for (auto it = pkg.second.rbegin(), end = pkg.second.rend(); it != end;
            it++) {
-        if (it->is_temp_mount == match_temp_mounts) {
-          bool latest = (it == pkg.second.rbegin());
-          handler(pkg.first, *it, latest);
-        }
+        bool latest = (it == pkg.second.rbegin());
+        handler(pkg.first, *it, latest);
       }
     }
   }
@@ -206,8 +161,7 @@ class MountedApexDatabase {
     return ret;
   }
 
-  void PopulateFromMounts(const std::vector<std::string>& data_dirs,
-                          const std::string& apex_hash_tree_dir);
+  void PopulateFromMounts(const std::vector<std::string>& data_dirs);
 
   // Resets state of the database. Should only be used in testing.
   inline void Reset() REQUIRES(!mounted_apexes_mutex_) {
@@ -246,10 +200,6 @@ class MountedApexDatabase {
           CHECK(dm_devices.insert(mount.device_name).second)
               << "Duplicate dm device: " << mount.device_name;
         }
-        if (mount.hashtree_loop_name != "") {
-          CHECK(loop_devices.insert(mount.hashtree_loop_name).second)
-              << "Duplicate loop device: " << mount.hashtree_loop_name;
-        }
       }
     }
   }
diff --git a/apexd/apex_database_test.cpp b/apexd/apex_database_test.cpp
index c3735e13..9af9a646 100644
--- a/apexd/apex_database_test.cpp
+++ b/apexd/apex_database_test.cpp
@@ -36,71 +36,6 @@ namespace {
 
 using MountedApexData = MountedApexDatabase::MountedApexData;
 
-TEST(MountedApexDataTest, LinearOrder) {
-  constexpr const char* kLoopName[] = {"loop1", "loop2", "loop3"};
-  constexpr const char* kPath[] = {"path1", "path2", "path3"};
-  constexpr const char* kMount[] = {"mount1", "mount2", "mount3"};
-  constexpr const char* kDm[] = {"dm1", "dm2", "dm3"};
-  constexpr const char* kHashtreeLoopName[] = {"hash-loop1", "hash-loop2",
-                                               "hash-loop3"};
-  // NOLINTNEXTLINE(bugprone-sizeof-expression)
-  constexpr size_t kCount = arraysize(kLoopName) * arraysize(kPath) *
-                            arraysize(kMount) * arraysize(kDm);
-
-  auto index_fn = [&](size_t i) {
-    const size_t loop_index = i % arraysize(kLoopName);
-    const size_t loop_rest = i / arraysize(kLoopName);
-    const size_t path_index = loop_rest % arraysize(kPath);
-    const size_t path_rest = loop_rest / arraysize(kPath);
-    const size_t mount_index = path_rest % arraysize(kMount);
-    const size_t mount_rest = path_rest / arraysize(kMount);
-    const size_t dm_index = mount_rest % arraysize(kDm);
-    const size_t dm_rest = mount_rest / arraysize(kHashtreeLoopName);
-    const size_t hashtree_loop_index = dm_rest % arraysize(kHashtreeLoopName);
-    CHECK_EQ(dm_rest / arraysize(kHashtreeLoopName), 0u);
-    return std::make_tuple(loop_index, path_index, mount_index, dm_index,
-                           hashtree_loop_index);
-  };
-
-  MountedApexData data[kCount];
-  for (size_t i = 0; i < kCount; ++i) {
-    size_t loop_idx, path_idx, mount_idx, dm_idx, hash_loop_idx;
-    std::tie(loop_idx, path_idx, mount_idx, dm_idx, hash_loop_idx) =
-        index_fn(i);
-    data[i] = MountedApexData(0, kLoopName[loop_idx], kPath[path_idx],
-                              kMount[mount_idx], kDm[dm_idx],
-                              kHashtreeLoopName[hash_loop_idx]);
-  }
-
-  for (size_t i = 0; i < kCount; ++i) {
-    size_t loop_idx_i, path_idx_i, mount_idx_i, dm_idx_i, hash_loop_idx_i;
-    std::tie(loop_idx_i, path_idx_i, mount_idx_i, dm_idx_i, hash_loop_idx_i) =
-        index_fn(i);
-    for (size_t j = i; j < kCount; ++j) {
-      size_t loop_idx_j, path_idx_j, mount_idx_j, dm_idx_j, hash_loop_idx_j;
-      std::tie(loop_idx_j, path_idx_j, mount_idx_j, dm_idx_j, hash_loop_idx_j) =
-          index_fn(j);
-      if (loop_idx_i != loop_idx_j) {
-        EXPECT_EQ(loop_idx_i < loop_idx_j, data[i] < data[j]);
-        continue;
-      }
-      if (path_idx_i != path_idx_j) {
-        EXPECT_EQ(path_idx_i < path_idx_j, data[i] < data[j]);
-        continue;
-      }
-      if (mount_idx_i != mount_idx_j) {
-        EXPECT_EQ(mount_idx_i < mount_idx_j, data[i] < data[j]);
-        continue;
-      }
-      if (dm_idx_i != dm_idx_j) {
-        EXPECT_EQ(dm_idx_i < dm_idx_j, data[i] < data[j]);
-        continue;
-      }
-      EXPECT_EQ(hash_loop_idx_i < hash_loop_idx_j, data[i] < data[j]);
-    }
-  }
-}
-
 size_t CountPackages(const MountedApexDatabase& db) {
   size_t ret = 0;
   db.ForallMountedApexes([&ret](const std::string& a ATTRIBUTE_UNUSED,
@@ -110,15 +45,11 @@ size_t CountPackages(const MountedApexDatabase& db) {
 }
 
 bool Contains(const MountedApexDatabase& db, const std::string& package,
-              const std::string& loop_name, const std::string& full_path,
-              const std::string& mount_point, const std::string& device_name,
-              const std::string& hashtree_loop_name) {
+              const MountedApexData& data) {
   bool found = false;
   db.ForallMountedApexes([&](const std::string& p, const MountedApexData& d,
                              bool b ATTRIBUTE_UNUSED) {
-    if (package == p && loop_name == d.loop_name && full_path == d.full_path &&
-        mount_point == d.mount_point && device_name == d.device_name &&
-        hashtree_loop_name == d.hashtree_loop_name) {
+    if (package == p && data == d) {
       found = true;
     }
   });
@@ -126,14 +57,11 @@ bool Contains(const MountedApexDatabase& db, const std::string& package,
 }
 
 bool ContainsPackage(const MountedApexDatabase& db, const std::string& package,
-                     const std::string& loop_name, const std::string& full_path,
-                     const std::string& dm,
-                     const std::string& hashtree_loop_name) {
+                     const MountedApexData& data) {
   bool found = false;
   db.ForallMountedApexes(
       package, [&](const MountedApexData& d, bool b ATTRIBUTE_UNUSED) {
-        if (loop_name == d.loop_name && full_path == d.full_path &&
-            dm == d.device_name && hashtree_loop_name == d.hashtree_loop_name) {
+        if (data == d) {
           found = true;
         }
       });
@@ -146,23 +74,18 @@ TEST(ApexDatabaseTest, AddRemovedMountedApex) {
   constexpr const char* kPath = "path";
   constexpr const char* kMountPoint = "mount";
   constexpr const char* kDeviceName = "dev";
-  constexpr const char* kHashtreeLoopName = "hash-loop";
 
   MountedApexDatabase db;
   ASSERT_EQ(CountPackages(db), 0u);
 
-  db.AddMountedApex(kPackage, 0, kLoopName, kPath, kMountPoint, kDeviceName,
-                    kHashtreeLoopName);
-  ASSERT_TRUE(Contains(db, kPackage, kLoopName, kPath, kMountPoint, kDeviceName,
-                       kHashtreeLoopName));
-  ASSERT_TRUE(ContainsPackage(db, kPackage, kLoopName, kPath, kDeviceName,
-                              kHashtreeLoopName));
+  MountedApexData data(0, kLoopName, kPath, kMountPoint, kDeviceName);
+  db.AddMountedApex(kPackage, data);
+  ASSERT_TRUE(Contains(db, kPackage, data));
+  ASSERT_TRUE(ContainsPackage(db, kPackage, data));
 
   db.RemoveMountedApex(kPackage, kPath);
-  EXPECT_FALSE(Contains(db, kPackage, kLoopName, kPath, kMountPoint,
-                        kDeviceName, kHashtreeLoopName));
-  EXPECT_FALSE(ContainsPackage(db, kPackage, kLoopName, kPath, kDeviceName,
-                               kHashtreeLoopName));
+  EXPECT_FALSE(Contains(db, kPackage, data));
+  EXPECT_FALSE(ContainsPackage(db, kPackage, data));
 }
 
 TEST(ApexDatabaseTest, MountMultiple) {
@@ -172,41 +95,32 @@ TEST(ApexDatabaseTest, MountMultiple) {
   constexpr const char* kPath[] = {"path", "path2", "path", "path4"};
   constexpr const char* kMountPoint[] = {"mount", "mount2", "mount", "mount4"};
   constexpr const char* kDeviceName[] = {"dev", "dev2", "dev3", "dev4"};
-  constexpr const char* kHashtreeLoopName[] = {"hash-loop", "hash-loop2",
-                                               "hash-loop3", "hash-loop4"};
+
   MountedApexDatabase db;
   ASSERT_EQ(CountPackages(db), 0u);
 
+  MountedApexData data[arraysize(kPackage)];
   for (size_t i = 0; i < arraysize(kPackage); ++i) {
-    db.AddMountedApex(kPackage[i], 0, kLoopName[i], kPath[i], kMountPoint[i],
-                      kDeviceName[i], kHashtreeLoopName[i]);
+    data[i] = MountedApexData(0, kLoopName[i], kPath[i], kMountPoint[i],
+                              kDeviceName[i]);
+    db.AddMountedApex(kPackage[i], data[i]);
   }
 
   ASSERT_EQ(CountPackages(db), 4u);
   for (size_t i = 0; i < arraysize(kPackage); ++i) {
-    ASSERT_TRUE(Contains(db, kPackage[i], kLoopName[i], kPath[i],
-                         kMountPoint[i], kDeviceName[i], kHashtreeLoopName[i]));
-    ASSERT_TRUE(ContainsPackage(db, kPackage[i], kLoopName[i], kPath[i],
-                                kDeviceName[i], kHashtreeLoopName[i]));
+    ASSERT_TRUE(Contains(db, kPackage[i], data[i]));
+    ASSERT_TRUE(ContainsPackage(db, kPackage[i], data[i]));
   }
 
   db.RemoveMountedApex(kPackage[0], kPath[0]);
-  EXPECT_FALSE(Contains(db, kPackage[0], kLoopName[0], kPath[0], kMountPoint[0],
-                        kDeviceName[0], kHashtreeLoopName[0]));
-  EXPECT_FALSE(ContainsPackage(db, kPackage[0], kLoopName[0], kPath[0],
-                               kDeviceName[0], kHashtreeLoopName[0]));
-  EXPECT_TRUE(Contains(db, kPackage[1], kLoopName[1], kPath[1], kMountPoint[1],
-                       kDeviceName[1], kHashtreeLoopName[1]));
-  EXPECT_TRUE(ContainsPackage(db, kPackage[1], kLoopName[1], kPath[1],
-                              kDeviceName[1], kHashtreeLoopName[1]));
-  EXPECT_TRUE(Contains(db, kPackage[2], kLoopName[2], kPath[2], kMountPoint[2],
-                       kDeviceName[2], kHashtreeLoopName[2]));
-  EXPECT_TRUE(ContainsPackage(db, kPackage[2], kLoopName[2], kPath[2],
-                              kDeviceName[2], kHashtreeLoopName[2]));
-  EXPECT_TRUE(Contains(db, kPackage[3], kLoopName[3], kPath[3], kMountPoint[3],
-                       kDeviceName[3], kHashtreeLoopName[3]));
-  EXPECT_TRUE(ContainsPackage(db, kPackage[3], kLoopName[3], kPath[3],
-                              kDeviceName[3], kHashtreeLoopName[3]));
+  EXPECT_FALSE(Contains(db, kPackage[0], data[0]));
+  EXPECT_FALSE(ContainsPackage(db, kPackage[0], data[0]));
+  EXPECT_TRUE(Contains(db, kPackage[1], data[1]));
+  EXPECT_TRUE(ContainsPackage(db, kPackage[1], data[1]));
+  EXPECT_TRUE(Contains(db, kPackage[2], data[2]));
+  EXPECT_TRUE(ContainsPackage(db, kPackage[2], data[2]));
+  EXPECT_TRUE(Contains(db, kPackage[3], data[3]));
+  EXPECT_TRUE(ContainsPackage(db, kPackage[3], data[3]));
 }
 
 TEST(ApexDatabaseTest, DoIfLatest) {
@@ -217,12 +131,12 @@ TEST(ApexDatabaseTest, DoIfLatest) {
   MountedApexDatabase db;
 
   // With apex: [{version=0,path=path}]
-  db.AddMountedApex("package", 0, "loop", "path", "mount", "dev", "hash");
+  db.AddMountedApex("package", 0, "loop", "path", "mount", "dev");
   ASSERT_THAT(db.DoIfLatest("package", "path", returnError),
               HasError(WithMessage("expected")));
 
   // With apexes: [{version=0,path=path}, {version=5,path=path5}]
-  db.AddMountedApex("package", 5, "loop5", "path5", "mount5", "dev5", "hash5");
+  db.AddMountedApex("package", 5, "loop5", "path5", "mount5", "dev5");
   ASSERT_THAT(db.DoIfLatest("package", "path", returnError), Ok());
   ASSERT_THAT(db.DoIfLatest("package", "path5", returnError),
               HasError(WithMessage("expected")));
@@ -234,23 +148,16 @@ TEST(ApexDatabaseTest, GetLatestMountedApex) {
   constexpr const char* kPath = "path";
   constexpr const char* kMountPoint = "mount";
   constexpr const char* kDeviceName = "dev";
-  constexpr const char* kHashtreeLoopName = "hash-loop";
 
   MountedApexDatabase db;
   ASSERT_EQ(CountPackages(db), 0u);
 
-  db.AddMountedApex(kPackage, 0, kLoopName, kPath, kMountPoint, kDeviceName,
-                    kHashtreeLoopName);
+  MountedApexData data(0, kLoopName, kPath, kMountPoint, kDeviceName);
+  db.AddMountedApex(kPackage, data);
 
   auto ret = db.GetLatestMountedApex(kPackage);
-  MountedApexData expected(0, kLoopName, kPath, kMountPoint, kDeviceName,
-                           kHashtreeLoopName);
   ASSERT_TRUE(ret.has_value());
-  ASSERT_EQ(ret->loop_name, std::string(kLoopName));
-  ASSERT_EQ(ret->full_path, std::string(kPath));
-  ASSERT_EQ(ret->mount_point, std::string(kMountPoint));
-  ASSERT_EQ(ret->device_name, std::string(kDeviceName));
-  ASSERT_EQ(ret->hashtree_loop_name, std::string(kHashtreeLoopName));
+  ASSERT_EQ(ret.value(), data);
 }
 
 TEST(ApexDatabaseTest, GetLatestMountedApexReturnsNullopt) {
@@ -268,34 +175,8 @@ TEST(MountedApexDataTest, NoDuplicateLoopDataLoopDevices) {
   ASSERT_DEATH(
       {
         MountedApexDatabase db;
-        db.AddMountedApex("package", 0, "loop", "path", "mount", "dm",
-                          "hashtree-loop1");
-        db.AddMountedApex("package2", 0, "loop", "path2", "mount2", "dm2",
-                          "hashtree-loop2");
-      },
-      "Duplicate loop device: loop");
-}
-
-TEST(MountedApexDataTest, NoDuplicateLoopHashtreeLoopDevices) {
-  ASSERT_DEATH(
-      {
-        MountedApexDatabase db;
-        db.AddMountedApex("package", 0, "loop1", "path", "mount", "dm",
-                          "hashtree-loop");
-        db.AddMountedApex("package2", 0, "loop2", "path2", "mount2", "dm2",
-                          "hashtree-loop");
-      },
-      "Duplicate loop device: hashtree-loop");
-}
-
-TEST(MountedApexDataTest, NoDuplicateLoopHashtreeAndDataLoopDevices) {
-  ASSERT_DEATH(
-      {
-        MountedApexDatabase db;
-        db.AddMountedApex("package", 0, "loop", "path", "mount", "dm",
-                          "hashtree-loop1");
-        db.AddMountedApex("package2", 0, "loop2", "path2", "mount2", "dm2",
-                          "loop");
+        db.AddMountedApex("package", 0, "loop", "path", "mount", "dm");
+        db.AddMountedApex("package2", 0, "loop", "path2", "mount2", "dm2");
       },
       "Duplicate loop device: loop");
 }
@@ -304,10 +185,8 @@ TEST(MountedApexDataTest, NoDuplicateDm) {
   ASSERT_DEATH(
       {
         MountedApexDatabase db;
-        db.AddMountedApex("package", 0, "loop", "path", "mount", "dm",
-                          /* hashtree_loop_name= */ "");
-        db.AddMountedApex("package2", 0, "loop2", "path2", "mount2", "dm",
-                          /* hashtree_loop_name= */ "");
+        db.AddMountedApex("package", 0, "loop", "path", "mount", "dm");
+        db.AddMountedApex("package2", 0, "loop2", "path2", "mount2", "dm");
       },
       "Duplicate dm device: dm");
 }
diff --git a/apexd/apex_file_repository.cpp b/apexd/apex_file_repository.cpp
index c66e9d69..45b48492 100644
--- a/apexd/apex_file_repository.cpp
+++ b/apexd/apex_file_repository.cpp
@@ -28,6 +28,7 @@
 #include "apex_constants.h"
 #include "apex_file.h"
 #include "apexd_utils.h"
+#include "apexd_vendor_apex.h"
 #include "apexd_verity.h"
 
 using android::base::EndsWith;
@@ -95,10 +96,10 @@ Result<void> ApexFileRepository::ScanBuiltInDir(const std::string& dir) {
                    << apex_file->GetPath();
         continue;
       }
-      if (enforce_multi_install_partition_ &&
-          !android::base::StartsWith(path, "/vendor/apex/")) {
+      if (enforce_multi_install_partition_ && !InVendorPartition(path) &&
+          !InOdmPartition(path)) {
         LOG(ERROR) << "Multi-install APEX " << path
-                   << " can only be preinstalled on /vendor/apex/.";
+                   << " can only be preinstalled on /{odm,vendor}/apex/.";
         continue;
       }
 
@@ -475,7 +476,7 @@ std::vector<ApexFileRef> ApexFileRepository::GetPreInstalledApexFiles() const {
   for (const auto& it : pre_installed_store_) {
     result.emplace_back(std::cref(it.second));
   }
-  return std::move(result);
+  return result;
 }
 
 std::vector<ApexFileRef> ApexFileRepository::GetDataApexFiles() const {
@@ -484,7 +485,7 @@ std::vector<ApexFileRef> ApexFileRepository::GetDataApexFiles() const {
   for (const auto& it : data_store_) {
     result.emplace_back(std::cref(it.second));
   }
-  return std::move(result);
+  return result;
 }
 
 // Group pre-installed APEX and data APEX by name
@@ -510,7 +511,7 @@ ApexFileRepository::AllApexFilesByName() const {
     result[package_name].emplace_back(apex_file_ref);
   }
 
-  return std::move(result);
+  return result;
 }
 
 ApexFileRef ApexFileRepository::GetDataApex(const std::string& name) const {
diff --git a/apexd/apexd.cpp b/apexd/apexd.cpp
index 6b9e9b95..b1c16acb 100644
--- a/apexd/apexd.cpp
+++ b/apexd/apexd.cpp
@@ -80,8 +80,10 @@
 #include "apex_sha.h"
 #include "apex_shim.h"
 #include "apexd_checkpoint.h"
+#include "apexd_dm.h"
 #include "apexd_lifecycle.h"
 #include "apexd_loop.h"
+#include "apexd_metrics.h"
 #include "apexd_private.h"
 #include "apexd_rollback_utils.h"
 #include "apexd_session.h"
@@ -148,12 +150,16 @@ std::set<std::string> gChangedActiveApexes;
 
 static constexpr size_t kLoopDeviceSetupAttempts = 3u;
 
-// Please DO NOT add new modules to this list without contacting mainline-modularization@ first.
+// Please DO NOT add new modules to this list without contacting
+// mainline-modularization@ first.
 static const std::vector<std::string> kBootstrapApexes = ([]() {
   std::vector<std::string> ret = {
       "com.android.i18n",
       "com.android.runtime",
       "com.android.tzdata",
+#ifdef RELEASE_AVF_ENABLE_EARLY_VM
+      "com.android.virt",
+#endif
   };
 
   auto vendor_vndk_ver = GetProperty("ro.vndk.version", "");
@@ -214,21 +220,22 @@ void ReleaseF2fsCompressedBlocks(const std::string& file_path) {
 
 std::unique_ptr<DmTable> CreateVerityTable(const ApexVerityData& verity_data,
                                            const std::string& block_device,
-                                           const std::string& hash_device,
                                            bool restart_on_corruption) {
   AvbHashtreeDescriptor* desc = verity_data.desc.get();
   auto table = std::make_unique<DmTable>();
 
-  uint32_t hash_start_block = 0;
-  if (hash_device == block_device) {
-    hash_start_block = desc->tree_offset / desc->hash_block_size;
-  }
+  const uint64_t start = 0;
+  const uint64_t length = desc->image_size / 512;  // in sectors
+
+  const std::string& hash_device = block_device;
+  const uint32_t num_data_blocks = desc->image_size / desc->data_block_size;
+  const uint32_t hash_start_block = desc->tree_offset / desc->hash_block_size;
 
   auto target = std::make_unique<DmTargetVerity>(
-      0, desc->image_size / 512, desc->dm_verity_version, block_device,
-      hash_device, desc->data_block_size, desc->hash_block_size,
-      desc->image_size / desc->data_block_size, hash_start_block,
-      verity_data.hash_algorithm, verity_data.root_digest, verity_data.salt);
+      start, length, desc->dm_verity_version, block_device, hash_device,
+      desc->data_block_size, desc->hash_block_size, num_data_blocks,
+      hash_start_block, verity_data.hash_algorithm, verity_data.root_digest,
+      verity_data.salt);
 
   target->IgnoreZeroBlocks();
   if (restart_on_corruption) {
@@ -239,128 +246,8 @@ std::unique_ptr<DmTable> CreateVerityTable(const ApexVerityData& verity_data,
   table->set_readonly(true);
 
   return table;
-}
-
-// Deletes a dm-verity device with a given name and path
-// Synchronizes on the device actually being deleted from userspace.
-Result<void> DeleteVerityDevice(const std::string& name, bool deferred) {
-  DeviceMapper& dm = DeviceMapper::Instance();
-  if (deferred) {
-    if (!dm.DeleteDeviceDeferred(name)) {
-      return ErrnoError() << "Failed to issue deferred delete of verity device "
-                          << name;
-    }
-    return {};
-  }
-  auto timeout = std::chrono::milliseconds(
-      android::sysprop::ApexProperties::dm_delete_timeout().value_or(750));
-  if (!dm.DeleteDevice(name, timeout)) {
-    return Error() << "Failed to delete dm-device " << name;
-  }
-  return {};
-}
-
-class DmVerityDevice {
- public:
-  DmVerityDevice() : cleared_(true) {}
-  explicit DmVerityDevice(std::string name)
-      : name_(std::move(name)), cleared_(false) {}
-  DmVerityDevice(std::string name, std::string dev_path)
-      : name_(std::move(name)),
-        dev_path_(std::move(dev_path)),
-        cleared_(false) {}
-
-  DmVerityDevice(DmVerityDevice&& other) noexcept
-      : name_(std::move(other.name_)),
-        dev_path_(std::move(other.dev_path_)),
-        cleared_(other.cleared_) {
-    other.cleared_ = true;
-  }
-
-  DmVerityDevice& operator=(DmVerityDevice&& other) noexcept {
-    name_ = other.name_;
-    dev_path_ = other.dev_path_;
-    cleared_ = other.cleared_;
-    other.cleared_ = true;
-    return *this;
-  }
-
-  ~DmVerityDevice() {
-    if (!cleared_) {
-      Result<void> ret = DeleteVerityDevice(name_, /* deferred= */ false);
-      if (!ret.ok()) {
-        LOG(ERROR) << ret.error();
-      }
-    }
-  }
-
-  const std::string& GetName() const { return name_; }
-  const std::string& GetDevPath() const { return dev_path_; }
-
-  void Release() { cleared_ = true; }
-
- private:
-  std::string name_;
-  std::string dev_path_;
-  bool cleared_;
 };
 
-Result<DmVerityDevice> CreateVerityDevice(
-    DeviceMapper& dm, const std::string& name, const DmTable& table,
-    const std::chrono::milliseconds& timeout) {
-  std::string dev_path;
-  if (!dm.CreateDevice(name, table, &dev_path, timeout)) {
-    return Errorf("Couldn't create verity device.");
-  }
-  return DmVerityDevice(name, dev_path);
-}
-
-Result<DmVerityDevice> CreateVerityDevice(const std::string& name,
-                                          const DmTable& table,
-                                          bool reuse_device) {
-  ATRACE_NAME("CreateVerityDevice");
-  LOG(VERBOSE) << "Creating verity device " << name;
-  auto timeout = std::chrono::milliseconds(
-      android::sysprop::ApexProperties::dm_create_timeout().value_or(1000));
-
-  DeviceMapper& dm = DeviceMapper::Instance();
-
-  auto state = dm.GetState(name);
-  if (state == DmDeviceState::INVALID) {
-    return CreateVerityDevice(dm, name, table, timeout);
-  }
-
-  if (reuse_device) {
-    if (state == DmDeviceState::ACTIVE) {
-      LOG(WARNING) << "Deleting existing active dm device " << name;
-      if (auto r = DeleteVerityDevice(name, /* deferred= */ false); !r.ok()) {
-        return r.error();
-      }
-      return CreateVerityDevice(dm, name, table, timeout);
-    }
-    if (!dm.LoadTableAndActivate(name, table)) {
-      dm.DeleteDevice(name);
-      return Error() << "Failed to activate dm device " << name;
-    }
-    std::string path;
-    if (!dm.WaitForDevice(name, timeout, &path)) {
-      dm.DeleteDevice(name);
-      return Error() << "Failed waiting for dm device " << name;
-    }
-    return DmVerityDevice(name, path);
-  } else {
-    if (state != DmDeviceState::INVALID) {
-      // Delete dangling dm-device. This can happen if apexd fails to delete it
-      // while unmounting an apex.
-      LOG(WARNING) << "Deleting existing dm device " << name;
-      if (auto r = DeleteVerityDevice(name, /* deferred= */ false); !r.ok()) {
-        return r.error();
-      }
-    }
-    return CreateVerityDevice(dm, name, table, timeout);
-  }
-}
-
 /**
  * When we create hardlink for a new apex package in kActiveApexPackagesDataDir,
  * there might be an older version of the same package already present in there.
@@ -457,9 +344,7 @@ Result<void> VerifyMountedImage(const ApexFile& apex,
 Result<MountedApexData> MountPackageImpl(const ApexFile& apex,
                                          const std::string& mount_point,
                                          const std::string& device_name,
-                                         const std::string& hashtree_file,
-                                         bool verify_image, bool reuse_device,
-                                         bool temp_mount = false) {
+                                         bool verify_image, bool reuse_device) {
   auto tag = "MountPackageImpl: " + apex.GetManifest().name();
   ATRACE_NAME(tag.c_str());
   if (apex.IsCompressed()) {
@@ -542,9 +427,7 @@ Result<MountedApexData> MountPackageImpl(const ApexFile& apex,
   std::string block_device = loopback_device.name;
   MountedApexData apex_data(apex.GetManifest().version(), loopback_device.name,
                             apex.GetPath(), mount_point,
-                            /* device_name = */ "",
-                            /* hashtree_loop_name = */ "",
-                            /* is_temp_mount */ temp_mount);
+                            /* device_name = */ "");
 
   // for APEXes in immutable partitions, we don't need to mount them on
   // dm-verity because they are already in the dm-verity protected partition;
@@ -556,31 +439,13 @@ Result<MountedApexData> MountPackageImpl(const ApexFile& apex,
                                // block apexes are from host
                                instance.IsBlockApex(apex);
 
-  DmVerityDevice verity_dev;
-  loop::LoopbackDeviceUniqueFd loop_for_hash;
+  DmDevice verity_dev;
   if (mount_on_verity) {
-    std::string hash_device = loopback_device.name;
-    if (verity_data->desc->tree_size == 0) {
-      if (auto st = PrepareHashTree(apex, *verity_data, hashtree_file);
-          !st.ok()) {
-        return st.error();
-      }
-      auto create_loop_status =
-          loop::CreateAndConfigureLoopDevice(hashtree_file,
-                                             /* image_offset= */ 0,
-                                             /* image_size= */ 0);
-      if (!create_loop_status.ok()) {
-        return create_loop_status.error();
-      }
-      loop_for_hash = std::move(*create_loop_status);
-      hash_device = loop_for_hash.name;
-      apex_data.hashtree_loop_name = hash_device;
-    }
     auto verity_table =
-        CreateVerityTable(*verity_data, loopback_device.name, hash_device,
+        CreateVerityTable(*verity_data, loopback_device.name,
                           /* restart_on_corruption = */ !verify_image);
-    Result<DmVerityDevice> verity_dev_res =
-        CreateVerityDevice(device_name, *verity_table, reuse_device);
+    Result<DmDevice> verity_dev_res =
+        CreateDmDevice(device_name, *verity_table, reuse_device);
     if (!verity_dev_res.ok()) {
       return Error() << "Failed to create Apex Verity device " << full_path
                      << ": " << verity_dev_res.error();
@@ -615,7 +480,8 @@ Result<MountedApexData> MountPackageImpl(const ApexFile& apex,
   if (mount(block_device.c_str(), mount_point.c_str(),
             apex.GetFsType().value().c_str(), mount_flags, nullptr) == 0) {
     auto time_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-        boot_clock::now() - time_started).count();
+                            boot_clock::now() - time_started)
+                            .count();
     LOG(INFO) << "Successfully mounted package " << full_path << " on "
               << mount_point << " duration=" << time_elapsed;
     auto status = VerifyMountedImage(apex, mount_point);
@@ -629,7 +495,6 @@ Result<MountedApexData> MountPackageImpl(const ApexFile& apex,
     // Time to accept the temporaries as good.
     verity_dev.Release();
     loopback_device.CloseGood();
-    loop_for_hash.CloseGood();
 
     scope_guard.Disable();  // Accept the mount.
     return apex_data;
@@ -638,38 +503,13 @@ Result<MountedApexData> MountPackageImpl(const ApexFile& apex,
   }
 }
 
-std::string GetHashTreeFileName(const ApexFile& apex, bool is_new) {
-  const std::string& id = GetPackageId(apex.GetManifest());
-  std::string ret =
-      StringPrintf("%s/%s", gConfig->apex_hash_tree_dir, id.c_str());
-  return is_new ? ret + ".new" : ret;
-}
-
 Result<MountedApexData> VerifyAndTempMountPackage(
     const ApexFile& apex, const std::string& mount_point) {
   const std::string& package_id = GetPackageId(apex.GetManifest());
   LOG(DEBUG) << "Temp mounting " << package_id << " to " << mount_point;
   const std::string& temp_device_name = package_id + ".tmp";
-  std::string hashtree_file = GetHashTreeFileName(apex, /* is_new = */ true);
-  if (access(hashtree_file.c_str(), F_OK) == 0) {
-    LOG(DEBUG) << hashtree_file << " already exists. Deleting it";
-    if (TEMP_FAILURE_RETRY(unlink(hashtree_file.c_str())) != 0) {
-      return ErrnoError() << "Failed to unlink " << hashtree_file;
-    }
-  }
-  auto ret =
-      MountPackageImpl(apex, mount_point, temp_device_name, hashtree_file,
-                       /* verify_image = */ true, /* reuse_device= */ false,
-                       /* temp_mount = */ true);
-  if (!ret.ok()) {
-    LOG(DEBUG) << "Cleaning up " << hashtree_file;
-    if (TEMP_FAILURE_RETRY(unlink(hashtree_file.c_str())) != 0) {
-      PLOG(ERROR) << "Failed to unlink " << hashtree_file;
-    }
-  } else {
-    gMountedApexes.AddMountedApex(apex.GetManifest().name(), *ret);
-  }
-  return ret;
+  return MountPackageImpl(apex, mount_point, temp_device_name,
+                          /* verify_image = */ true, /* reuse_device= */ false);
 }
 
 }  // namespace
@@ -691,7 +531,7 @@ Result<void> Unmount(const MountedApexData& data, bool deferred) {
 
   // Try to free up the device-mapper device.
   if (!data.device_name.empty()) {
-    const auto& result = DeleteVerityDevice(data.device_name, deferred);
+    const auto& result = DeleteDmDevice(data.device_name, deferred);
     if (!result.ok()) {
       return result;
     }
@@ -710,77 +550,15 @@ Result<void> Unmount(const MountedApexData& data, bool deferred) {
   if (!data.loop_name.empty() && !deferred) {
     loop::DestroyLoopDevice(data.loop_name, log_fn);
   }
-  if (!data.hashtree_loop_name.empty() && !deferred) {
-    loop::DestroyLoopDevice(data.hashtree_loop_name, log_fn);
-  }
 
   return {};
 }
 
 namespace {
 
-void SendApexInstallationRequestedAtom(const std::string& package_path,
-                                       const bool is_rollback,
-                                       const unsigned int install_type) {
-  if (!statssocket::lazy::IsAvailable()) {
-    LOG(WARNING) << "Unable to send Apex Atom; libstatssocket is not available";
-    return;
-  }
-  auto apex_file = ApexFile::Open(package_path);
-  if (!apex_file.ok()) {
-    LOG(WARNING) << "Unable to send Apex Atom; Failed to open ApexFile "
-                 << package_path << ": " << apex_file.error();
-    return;
-  }
-  const std::string& module_name = apex_file->GetManifest().name();
-  struct stat stat_buf;
-  intmax_t apex_file_size;
-  if (stat(package_path.c_str(), &stat_buf) == 0) {
-    apex_file_size = stat_buf.st_size;
-  } else {
-    PLOG(WARNING) << "Failed to stat " << package_path;
-    apex_file_size = 0;
-  }
-  Result<std::string> apex_file_sha256_str = CalculateSha256(package_path);
-  if (!apex_file_sha256_str.ok()) {
-    LOG(WARNING) << "Unable to get sha256 of ApexFile: "
-                 << apex_file_sha256_str.error();
-  }
-  const std::vector<const char*> hal_cstr_list;
-  int ret = stats::apex::stats_write(
-      stats::apex::APEX_INSTALLATION_REQUESTED, module_name.c_str(),
-      apex_file->GetManifest().version(), apex_file_size,
-      apex_file_sha256_str->c_str(), GetPreinstallPartitionEnum(*apex_file),
-      install_type, is_rollback,
-      apex_file->GetManifest().providesharedapexlibs(), hal_cstr_list);
-  if (ret < 0) {
-    LOG(WARNING) << "Failed to report apex_installation_requested stats";
-  }
-}
-
-void SendApexInstallationEndedAtom(const std::string& package_path,
-                                   int install_result) {
-  if (!statssocket::lazy::IsAvailable()) {
-    LOG(WARNING) << "Unable to send Apex Atom; libstatssocket is not available";
-    return;
-  }
-  Result<std::string> apex_file_sha256_str = CalculateSha256(package_path);
-  if (!apex_file_sha256_str.ok()) {
-    LOG(WARNING) << "Unable to get sha256 of ApexFile: "
-                 << apex_file_sha256_str.error();
-  }
-  int ret =
-      stats::apex::stats_write(stats::apex::APEX_INSTALLATION_ENDED,
-                               apex_file_sha256_str->c_str(), install_result);
-  if (ret < 0) {
-    LOG(WARNING) << "Failed to report apex_installation_ended stats";
-  }
-}
-
 template <typename VerifyFn>
 Result<void> RunVerifyFnInsideTempMount(const ApexFile& apex,
-                                        const VerifyFn& verify_fn,
-                                        bool unmount_during_cleanup) {
+                                        const VerifyFn& verify_fn) {
   // Temp mount image of this apex to validate it was properly signed;
   // this will also read the entire block device through dm-verity, so
   // we can be sure there is no corruption.
@@ -801,18 +579,9 @@ Result<void> RunVerifyFnInsideTempMount(const ApexFile& apex,
       LOG(WARNING) << "Failed to unmount " << temp_mount_point << " : "
                    << result.error();
     }
-    gMountedApexes.RemoveMountedApex(apex.GetManifest().name(), apex.GetPath(),
-                                     true);
   };
   auto scope_guard = android::base::make_scope_guard(cleaner);
-  auto result = verify_fn(temp_mount_point);
-  if (!result.ok()) {
-    return result.error();
-  }
-  if (!unmount_during_cleanup) {
-    scope_guard.Disable();
-  }
-  return {};
+  return verify_fn(temp_mount_point);
 }
 
 // Converts a list of apex file paths into a list of ApexFile objects
@@ -844,7 +613,7 @@ Result<void> ValidateStagingShimApex(const ApexFile& to) {
   auto verify_fn = [&](const std::string& system_apex_path) {
     return shim::ValidateUpdate(system_apex_path, to.GetPath());
   };
-  return RunVerifyFnInsideTempMount(*system_shim, verify_fn, true);
+  return RunVerifyFnInsideTempMount(*system_shim, verify_fn);
 }
 
 Result<void> VerifyVndkVersion(const ApexFile& apex_file) {
@@ -860,9 +629,8 @@ Result<void> VerifyVndkVersion(const ApexFile& apex_file) {
   const auto& instance = ApexFileRepository::GetInstance();
   const auto& preinstalled =
       instance.GetPreInstalledApex(apex_file.GetManifest().name());
-  const auto& preinstalled_path = preinstalled.get().GetPath();
-  if (StartsWith(preinstalled_path, "/vendor/apex/") ||
-      StartsWith(preinstalled_path, "/system/vendor/apex/")) {
+  const auto& path = preinstalled.get().GetPath();
+  if (InVendorPartition(path) || InOdmPartition(path)) {
     if (vndk_version != vendor_vndk_version) {
       return Error() << "vndkVersion(" << vndk_version
                      << ") doesn't match with device VNDK version("
@@ -870,8 +638,8 @@ Result<void> VerifyVndkVersion(const ApexFile& apex_file) {
     }
     return {};
   }
-  if (StartsWith(preinstalled_path, "/product/apex/") ||
-      StartsWith(preinstalled_path, "/system/product/apex/")) {
+  if (StartsWith(path, "/product/apex/") ||
+      StartsWith(path, "/system/product/apex/")) {
     if (vndk_version != product_vndk_version) {
       return Error() << "vndkVersion(" << vndk_version
                      << ") doesn't match with device VNDK version("
@@ -930,7 +698,7 @@ Result<void> VerifyPackageStagedInstall(const ApexFile& apex_file) {
     }
     return Result<void>{};
   };
-  return RunVerifyFnInsideTempMount(apex_file, validate_fn, false);
+  return RunVerifyFnInsideTempMount(apex_file, validate_fn);
 }
 
 template <typename VerifyApexFn>
@@ -952,7 +720,8 @@ Result<std::vector<ApexFile>> VerifyPackages(
   return std::move(*apex_files);
 }
 
-Result<ApexFile> VerifySessionDir(int session_id) {
+// VerifySessionDir verifies and returns the apex file in a session
+Result<ApexFile> VerifySessionDir(int session_id, const bool is_rollback) {
   std::string session_dir_path =
       StringPrintf("%s/session_%d", gConfig->staged_session_dir, session_id);
   LOG(INFO) << "Scanning " << session_dir_path
@@ -969,8 +738,21 @@ Result<ApexFile> VerifySessionDir(int session_id) {
         "More than one APEX package found in the same session directory.");
   }
 
+  // Report ApexInstallRequests here, so we can track apexes that
+  // do not pass the VerifyPackages() and thus won't return for tracking.
+  // SubmitStagedSession() performs the remaining apex metrics with valid
+  // instances. VerifySessionDir is only called by SubmitStagedSession(), so we
+  // can surmise that a staged apex installation is occurring.
+  SendApexInstallationRequestedAtom(
+      (*scan)[0], is_rollback,
+      stats::apex::APEX_INSTALLATION_REQUESTED__INSTALLATION_TYPE__STAGED);
+
   auto verified = VerifyPackages(*scan, VerifyPackageStagedInstall);
   if (!verified.ok()) {
+    SendApexInstallationEndedAtom(
+        (*scan)[0],
+        stats::apex::
+            APEX_INSTALLATION_ENDED__INSTALLATION_RESULT__INSTALL_FAILURE_APEX_INSTALLATION);
     return verified.error();
   }
   return std::move((*verified)[0]);
@@ -1147,12 +929,9 @@ Result<void> UnmountPackage(const ApexFile& apex, bool allow_latest,
 void SetConfig(const ApexdConfig& config) { gConfig = config; }
 
 Result<void> MountPackage(const ApexFile& apex, const std::string& mount_point,
-                          const std::string& device_name, bool reuse_device,
-                          bool temp_mount) {
-  auto ret =
-      MountPackageImpl(apex, mount_point, device_name,
-                       GetHashTreeFileName(apex, /* is_new= */ false),
-                       /* verify_image = */ false, reuse_device, temp_mount);
+                          const std::string& device_name, bool reuse_device) {
+  auto ret = MountPackageImpl(apex, mount_point, device_name,
+                              /* verify_image = */ false, reuse_device);
   if (!ret.ok()) {
     return ret.error();
   }
@@ -1163,43 +942,6 @@ Result<void> MountPackage(const ApexFile& apex, const std::string& mount_point,
 
 namespace apexd_private {
 
-Result<void> UnmountTempMount(const ApexFile& apex) {
-  const ApexManifest& manifest = apex.GetManifest();
-  LOG(VERBOSE) << "Unmounting all temp mounts for package " << manifest.name();
-
-  bool finished_unmounting = false;
-  // If multiple temp mounts exist, ensure that all are unmounted.
-  while (!finished_unmounting) {
-    Result<MountedApexData> data =
-        apexd_private::GetTempMountedApexData(manifest.name());
-    if (!data.ok()) {
-      finished_unmounting = true;
-    } else {
-      gMountedApexes.RemoveMountedApex(manifest.name(), data->full_path, true);
-      Unmount(*data, /* deferred= */ false);
-    }
-  }
-  return {};
-}
-
-Result<MountedApexData> GetTempMountedApexData(const std::string& package) {
-  bool found = false;
-  Result<MountedApexData> mount_data;
-  gMountedApexes.ForallMountedApexes(
-      package,
-      [&](const MountedApexData& data, [[maybe_unused]] bool latest) {
-        if (!found) {
-          mount_data = data;
-          found = true;
-        }
-      },
-      true);
-  if (found) {
-    return mount_data;
-  }
-  return Error() << "No temp mount data found for " << package;
-}
-
 bool IsMounted(const std::string& full_path) {
   bool found_mounted = false;
   gMountedApexes.ForallMountedApexes([&](const std::string&,
@@ -1413,8 +1155,8 @@ Result<void> ActivatePackageImpl(const ApexFile& apex_file,
       apexd_private::GetPackageMountPoint(manifest);
 
   if (!version_found_mounted) {
-    auto mount_status = MountPackage(apex_file, mount_point, device_name,
-                                     reuse_device, /*temp_mount=*/false);
+    auto mount_status =
+        MountPackage(apex_file, mount_point, device_name, reuse_device);
     if (!mount_status.ok()) {
       return mount_status;
     }
@@ -1508,9 +1250,10 @@ Result<std::vector<ApexFile>> GetStagedApexFiles(
 
 Result<ClassPath> MountAndDeriveClassPath(
     const std::vector<ApexFile>& apex_files) {
+  std::vector<MountedApexData> mounted_data;
   auto guard = android::base::make_scope_guard([&]() {
-    for (const auto& apex : apex_files) {
-      apexd_private::UnmountTempMount(apex);
+    for (const auto& data : mounted_data) {
+      Unmount(data, /*deferred=*/false);
     }
   });
 
@@ -1519,15 +1262,12 @@ Result<ClassPath> MountAndDeriveClassPath(
   for (const auto& apex : apex_files) {
     const std::string& temp_mount_point =
         apexd_private::GetPackageTempMountPoint(apex.GetManifest());
-    const std::string& package_id = GetPackageId(apex.GetManifest());
-    const std::string& temp_device_name = package_id + ".tmp";
-    auto mount_status =
-        MountPackage(apex, temp_mount_point, temp_device_name,
-                     /*reuse_device=*/false, /*temp_mount=*/true);
+    auto mount_status = VerifyAndTempMountPackage(apex, temp_mount_point);
     if (!mount_status.ok()) {
       return mount_status.error();
     }
     temp_mounted_apex_paths.push_back(temp_mount_point);
+    mounted_data.push_back(*mount_status);
   }
 
   // Calculate classpaths of temp mounted staged apexs
@@ -1563,7 +1303,7 @@ std::vector<ApexFile> CalculateInactivePackages(
                            });
       });
   inactive.erase(new_end, inactive.end());
-  return std::move(inactive);
+  return inactive;
 }
 
 Result<void> EmitApexInfoList(bool is_bootstrap) {
@@ -2126,9 +1866,7 @@ void DeleteDePreRestoreSnapshots(const ApexSession& session) {
   }
 }
 
-void OnBootCompleted() {
-  ApexdLifecycle::GetInstance().MarkBootCompleted();
-}
+void OnBootCompleted() { ApexdLifecycle::GetInstance().MarkBootCompleted(); }
 
 // Returns true if any session gets staged
 void ScanStagedSessionsDirAndStage() {
@@ -2232,6 +1970,19 @@ void ScanStagedSessionsDirAndStage() {
         continue;
       }
       staged_apex_names.push_back(apex_file->GetManifest().name());
+
+      // Collect apex's file hash now to assist sending metrics later. With
+      // successful installs, when we want to send the metric message, we are
+      // unable to read the session's apex to compute the sha for the message
+      Result<std::string> apex_file_sha256_str =
+          CalculateSha256(apex_file->GetPath());
+      if (!apex_file_sha256_str.ok()) {
+        LOG(WARNING) << "Unable to get sha256 of ApexFile "
+                     << apex_file->GetPath() << " : "
+                     << apex_file_sha256_str.error();
+      } else {
+        RegisterSessionApexSha(session_id, *apex_file_sha256_str);
+      }
     }
 
     const Result<void> result = StagePackages(apexes);
@@ -2268,11 +2019,11 @@ std::string StageDestPath(const ApexFile& apex_file) {
 
 }  // namespace
 
-Result<void> StagePackages(const std::vector<std::string>& tmp_paths) {
+Result<void> StagePackagesImpl(const std::vector<std::string>& tmp_paths) {
   if (tmp_paths.empty()) {
     return Errorf("Empty set of inputs");
   }
-  LOG(DEBUG) << "StagePackages() for " << Join(tmp_paths, ',');
+  LOG(DEBUG) << "StagePackagesImpl() for " << Join(tmp_paths, ',');
 
   // Note: this function is temporary. As such the code is not optimized, e.g.,
   //       it will open ApexFiles multiple times.
@@ -2304,38 +2055,18 @@ Result<void> StagePackages(const std::vector<std::string>& tmp_paths) {
 
   // Ensure the APEX gets removed on failure.
   std::unordered_set<std::string> staged_files;
-  std::vector<std::string> changed_hashtree_files;
-  auto deleter = [&staged_files, &changed_hashtree_files]() {
+  auto deleter = [&staged_files]() {
     for (const std::string& staged_path : staged_files) {
       if (TEMP_FAILURE_RETRY(unlink(staged_path.c_str())) != 0) {
         PLOG(ERROR) << "Unable to unlink " << staged_path;
       }
     }
-    for (const std::string& hashtree_file : changed_hashtree_files) {
-      if (TEMP_FAILURE_RETRY(unlink(hashtree_file.c_str())) != 0) {
-        PLOG(ERROR) << "Unable to unlink " << hashtree_file;
-      }
-    }
   };
   auto scope_guard = android::base::make_scope_guard(deleter);
 
   std::unordered_set<std::string> staged_packages;
   for (const ApexFile& apex_file : *apex_files) {
-    // First promote new hashtree file to the one that will be used when
-    // mounting apex.
-    std::string new_hashtree_file = GetHashTreeFileName(apex_file,
-                                                        /* is_new = */ true);
-    std::string old_hashtree_file = GetHashTreeFileName(apex_file,
-                                                        /* is_new = */ false);
-    if (access(new_hashtree_file.c_str(), F_OK) == 0) {
-      if (TEMP_FAILURE_RETRY(rename(new_hashtree_file.c_str(),
-                                    old_hashtree_file.c_str())) != 0) {
-        return ErrnoError() << "Failed to move " << new_hashtree_file << " to "
-                            << old_hashtree_file;
-      }
-      changed_hashtree_files.emplace_back(std::move(old_hashtree_file));
-    }
-    // And only then move apex to /data/apex/active.
+    // move apex to /data/apex/active.
     std::string dest_path = StageDestPath(apex_file);
     if (access(dest_path.c_str(), F_OK) == 0) {
       LOG(DEBUG) << dest_path << " already exists. Deleting";
@@ -2360,6 +2091,14 @@ Result<void> StagePackages(const std::vector<std::string>& tmp_paths) {
   return RemovePreviouslyActiveApexFiles(staged_packages, staged_files);
 }
 
+Result<void> StagePackages(const std::vector<std::string>& tmp_paths) {
+  Result<void> ret = StagePackagesImpl(tmp_paths);
+  if (!ret.ok()) {
+    ;  // TODO(b/366068337, Queue atoms)
+  }
+  return ret;
+}
+
 Result<void> UnstagePackages(const std::vector<std::string>& paths) {
   if (paths.empty()) {
     return Errorf("Empty set of inputs");
@@ -2593,7 +2332,8 @@ int OnBootstrap() {
 
   OnAllPackagesActivated(/*is_bootstrap=*/true);
   auto time_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-    boot_clock::now() - time_started).count();
+                          boot_clock::now() - time_started)
+                          .count();
   LOG(INFO) << "OnBootstrap done, duration=" << time_elapsed;
   return 0;
 }
@@ -2649,8 +2389,7 @@ void Initialize(CheckpointInterface* checkpoint_service) {
   }
 
   gMountedApexes.PopulateFromMounts(
-      {gConfig->active_apex_data_dir, gConfig->decompression_dir},
-      gConfig->apex_hash_tree_dir);
+      {gConfig->active_apex_data_dir, gConfig->decompression_dir});
 }
 
 // Note: Pre-installed apex are initialized in Initialize(CheckpointInterface*)
@@ -2934,7 +2673,7 @@ std::vector<ApexFile> ProcessCompressedApex(
     LOG(ERROR) << "Failed to process compressed APEX: "
                << decompressed_apex.error();
   }
-  return std::move(decompressed_apex_list);
+  return decompressed_apex_list;
 }
 
 Result<void> ValidateDecompressedApex(const ApexFile& capex,
@@ -2957,8 +2696,8 @@ Result<void> ValidateDecompressedApex(const ApexFile& capex,
       capex.GetManifest().capexmetadata().originalapexdigest() !=
           apex_verity->root_digest) {
     return Error() << "Root digest of " << apex.GetPath()
-                   << " does not match with"
-                   << " expected root digest in " << capex.GetPath();
+                   << " does not match with" << " expected root digest in "
+                   << capex.GetPath();
   }
   return {};
 }
@@ -3061,7 +2800,8 @@ void OnStart() {
   SnapshotOrRestoreDeSysData();
 
   auto time_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
-    boot_clock::now() - time_started).count();
+                          boot_clock::now() - time_started)
+                          .count();
   LOG(INFO) << "OnStart done, duration=" << time_elapsed;
 }
 
@@ -3134,11 +2874,14 @@ Result<std::vector<ApexFile>> SubmitStagedSession(
   std::vector<ApexFile> ret;
   auto guard = android::base::make_scope_guard([&]() {
     for (const auto& apex : ret) {
-      apexd_private::UnmountTempMount(apex);
+      SendApexInstallationEndedAtom(
+          apex.GetPath(),
+          stats::apex::
+              APEX_INSTALLATION_ENDED__INSTALLATION_RESULT__INSTALL_FAILURE_APEX_INSTALLATION);
     }
   });
   for (int id_to_scan : ids_to_scan) {
-    auto verified = VerifySessionDir(id_to_scan);
+    auto verified = VerifySessionDir(id_to_scan, is_rollback);
     if (!verified.ok()) {
       return verified.error();
     }
@@ -3175,13 +2918,8 @@ Result<std::vector<ApexFile>> SubmitStagedSession(
     ReleaseF2fsCompressedBlocks(apex.GetPath());
   }
 
-  // The scope guard above uses lambda that captures ret by reference.
-  // Unfortunately, for the capture by-reference, lifetime of the captured
-  // reference ends together with the lifetime of the closure object. This means
-  // that we need to manually call UnmountTempMount here.
-  for (const auto& apex : ret) {
-    apexd_private::UnmountTempMount(apex);
-  }
+  // Disabling scope guard to stop Failure atoms from being sent
+  guard.Disable();
 
   return ret;
 }
@@ -3215,6 +2953,13 @@ Result<void> MarkStagedSessionSuccessful(const int session_id) {
   if (session->GetState() == SessionState::SUCCESS) {
     return {};
   } else if (session->GetState() == SessionState::ACTIVATED) {
+    // TODO: Handle activated apexes still unavailable to apexd at this time.
+    // This is because apexd is started before this activation with a linker
+    // configuration which doesn't know about statsd
+    SendSessionApexInstallationEndedAtom(
+        session_id,
+        stats::apex::
+            APEX_INSTALLATION_ENDED__INSTALLATION_RESULT__INSTALL_SUCCESSFUL);
     auto cleanup_status = DeleteBackup();
     if (!cleanup_status.ok()) {
       return Error() << "Failed to mark session " << *session
@@ -3285,7 +3030,7 @@ void DeleteUnusedVerityDevices() {
     auto state = dm.GetState(dev.name());
     if (state == DmDeviceState::SUSPENDED && IsApexDevice(dev.name())) {
       LOG(INFO) << "Deleting unused dm device " << dev.name();
-      auto res = DeleteVerityDevice(dev.name(), /* deferred= */ false);
+      auto res = DeleteDmDevice(dev.name(), /* deferred= */ false);
       if (!res.ok()) {
         LOG(WARNING) << res.error();
       }
@@ -3294,17 +3039,7 @@ void DeleteUnusedVerityDevices() {
 }
 
 void BootCompletedCleanup() {
-  auto sessions = gSessionManager->GetSessions();
-  for (const ApexSession& session : sessions) {
-    if (!session.IsFinalized()) {
-      continue;
-    }
-    auto result = session.DeleteSession();
-    if (!result.ok()) {
-      LOG(WARNING) << "Failed to delete finalized session: " << session.GetId();
-    }
-  }
-
+  gSessionManager->DeleteFinalizedSessions();
   DeleteUnusedVerityDevices();
 }
 
@@ -3322,7 +3057,7 @@ int UnmountAll(bool also_include_staged_apexes) {
     }
   }
 
-  gMountedApexes.PopulateFromMounts(data_dirs, gConfig->apex_hash_tree_dir);
+  gMountedApexes.PopulateFromMounts(data_dirs);
   int ret = 0;
   gMountedApexes.ForallMountedApexes([&](const std::string& /*package*/,
                                          const MountedApexData& data,
@@ -3340,13 +3075,13 @@ int UnmountAll(bool also_include_staged_apexes) {
       auto pos = data.mount_point.find('@');
       CHECK(pos != std::string::npos);
       std::string bind_mount = data.mount_point.substr(0, pos);
-      if (umount2(bind_mount.c_str(), UMOUNT_NOFOLLOW) != 0) {
+      if (umount2(bind_mount.c_str(), UMOUNT_NOFOLLOW | MNT_DETACH) != 0) {
         PLOG(ERROR) << "Failed to unmount bind-mount " << bind_mount;
         ret = 1;
         return;
       }
     }
-    if (auto status = Unmount(data, /* deferred= */ false); !status.ok()) {
+    if (auto status = Unmount(data, /* deferred= */ true); !status.ok()) {
       LOG(ERROR) << "Failed to unmount " << data.mount_point << " : "
                  << status.error();
       ret = 1;
@@ -3768,7 +3503,7 @@ Result<void> VerifyPackageNonStagedInstall(const ApexFile& apex_file,
     }
     return Result<void>{};
   };
-  return RunVerifyFnInsideTempMount(apex_file, check_fn, true);
+  return RunVerifyFnInsideTempMount(apex_file, check_fn);
 }
 
 Result<void> CheckSupportsNonStagedInstall(const ApexFile& new_apex,
@@ -3815,12 +3550,6 @@ Result<void> CheckSupportsNonStagedInstall(const ApexFile& new_apex,
   if (!verity_data.ok()) {
     return verity_data.error();
   }
-  // Supporting non-staged install of APEXes without a hashtree is additional
-  // hassle, it's easier not to support it.
-  if (verity_data->desc->tree_size == 0) {
-    return Error() << new_apex.GetPath()
-                   << " does not have an embedded hash tree";
-  }
   return {};
 }
 
@@ -3897,7 +3626,7 @@ Result<void> UnloadApexFromInit(const std::string& apex_name) {
     // When failed to SetProperty(), there's nothing we can do here.
     // Log error and return early to avoid indefinite waiting for ack.
     return Error() << "Failed to set " << kCtlApexUnloadSysprop << " to "
-                << apex_name;
+                   << apex_name;
   }
   SetProperty("apex." + apex_name + ".ready", "false");
   return {};
@@ -3909,7 +3638,7 @@ Result<void> LoadApexFromInit(const std::string& apex_name) {
     // When failed to SetProperty(), there's nothing we can do here.
     // Log error and return early to avoid indefinite waiting for ack.
     return Error() << "Failed to set " << kCtlApexLoadSysprop << " to "
-                << apex_name;
+                   << apex_name;
   }
   SetProperty("apex." + apex_name + ".ready", "true");
   return {};
@@ -3965,8 +3694,8 @@ Result<ApexFile> InstallPackageImpl(const std::string& package_path,
   // And then reload it from the init process whether it succeeds or not.
   auto reload_apex = android::base::make_scope_guard([&]() {
     if (auto status = LoadApexFromInit(module_name); !status.ok()) {
-      LOG(ERROR) << "Failed to load apex " << module_name
-                  << " : " << status.error().message();
+      LOG(ERROR) << "Failed to load apex " << module_name << " : "
+                 << status.error().message();
     }
   });
 
@@ -4065,5 +3794,7 @@ std::set<std::string>& GetChangedActiveApexesForTesting() {
   return gChangedActiveApexes;
 }
 
+ApexSessionManager* GetSessionManager() { return gSessionManager; }
+
 }  // namespace apex
 }  // namespace android
diff --git a/apexd/apexd.h b/apexd/apexd.h
index 77dc7ddb..8d5dbdf4 100644
--- a/apexd/apexd.h
+++ b/apexd/apexd.h
@@ -46,7 +46,6 @@ struct ApexdConfig {
   const char* active_apex_data_dir;
   const char* decompression_dir;
   const char* ota_reserved_dir;
-  const char* apex_hash_tree_dir;
   const char* staged_session_dir;
   // Overrides the path to the "metadata" partition which is by default
   // /dev/block/by-name/payload-metadata It should be a path pointing the first
@@ -63,7 +62,6 @@ static const ApexdConfig kDefaultConfig = {
     kActiveApexPackagesDataDir,
     kApexDecompressedDir,
     kOtaReservedDir,
-    kApexHashTreeDir,
     kStagedSessionsDir,
     kVmPayloadMetadataPartitionProp,
     "u:object_r:staging_data_file",
@@ -232,6 +230,8 @@ bool IsActiveApexChanged(const ApexFile& apex);
 // Shouldn't be used outside of apexd_test.cpp
 std::set<std::string>& GetChangedActiveApexesForTesting();
 
+ApexSessionManager* GetSessionManager();
+
 }  // namespace apex
 }  // namespace android
 
diff --git a/apexd/apexd_checkpoint.h b/apexd/apexd_checkpoint.h
index 2b4c3a12..0b052830 100644
--- a/apexd/apexd_checkpoint.h
+++ b/apexd/apexd_checkpoint.h
@@ -32,7 +32,6 @@ class CheckpointInterface {
 
   virtual android::base::Result<bool> NeedsCheckpoint() = 0;
   virtual android::base::Result<bool> NeedsRollback() = 0;
-  virtual android::base::Result<void> StartCheckpoint(int32_t num_retries) = 0;
 
   virtual android::base::Result<void> AbortChanges(const std::string& msg,
                                                    bool retry) = 0;
diff --git a/apexd/apexd_checkpoint_vold.cpp b/apexd/apexd_checkpoint_vold.cpp
index a9c522ce..22ebe785 100644
--- a/apexd/apexd_checkpoint_vold.cpp
+++ b/apexd/apexd_checkpoint_vold.cpp
@@ -89,18 +89,6 @@ Result<bool> VoldCheckpointInterface::NeedsRollback() {
   return false;
 }
 
-Result<void> VoldCheckpointInterface::StartCheckpoint(int32_t num_retries) {
-  if (supports_fs_checkpoints_) {
-    android::binder::Status status =
-        vold_service_->startCheckpoint(num_retries);
-    if (!status.isOk()) {
-      return Error() << status.toString8().c_str();
-    }
-    return {};
-  }
-  return Errorf("Device does not support filesystem checkpointing");
-}
-
 Result<void> VoldCheckpointInterface::AbortChanges(const std::string& msg,
                                                    bool retry) {
   vold_service_->abortChanges(msg, retry);
diff --git a/apexd/apexd_checkpoint_vold.h b/apexd/apexd_checkpoint_vold.h
index b0601234..e18d77bb 100644
--- a/apexd/apexd_checkpoint_vold.h
+++ b/apexd/apexd_checkpoint_vold.h
@@ -41,7 +41,6 @@ class VoldCheckpointInterface : public CheckpointInterface {
 
   android::base::Result<bool> NeedsCheckpoint() override;
   android::base::Result<bool> NeedsRollback() override;
-  android::base::Result<void> StartCheckpoint(int32_t num_retries) override;
 
   android::base::Result<void> AbortChanges(const std::string& msg,
                                            bool retry) override;
diff --git a/apexd/apexd_dm.cpp b/apexd/apexd_dm.cpp
new file mode 100644
index 00000000..0d2e8358
--- /dev/null
+++ b/apexd/apexd_dm.cpp
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "apexd_dm.h"
+
+#include <ApexProperties.sysprop.h>
+#include <android-base/logging.h>
+#include <utils/Trace.h>
+
+using android::base::ErrnoError;
+using android::base::Error;
+using android::base::Result;
+using android::dm::DeviceMapper;
+using android::dm::DmDeviceState;
+using android::dm::DmTable;
+
+namespace android::apex {
+
+DmDevice::~DmDevice() {
+  if (!cleared_) {
+    Result<void> ret = DeleteDmDevice(name_, /* deferred= */ false);
+    if (!ret.ok()) {
+      LOG(ERROR) << ret.error();
+    }
+  }
+}
+
+static Result<DmDevice> CreateDmDeviceInternal(
+    DeviceMapper& dm, const std::string& name, const DmTable& table,
+    const std::chrono::milliseconds& timeout) {
+  std::string dev_path;
+  if (!dm.CreateDevice(name, table, &dev_path, timeout)) {
+    return Error() << "Couldn't create dm-device.";
+  }
+  return DmDevice(name, dev_path);
+}
+
+Result<DmDevice> CreateDmDevice(const std::string& name, const DmTable& table,
+                                bool reuse_device) {
+  ATRACE_NAME("CreateDmDevice");
+  LOG(VERBOSE) << "Creating dm-device " << name;
+
+  auto timeout = std::chrono::milliseconds(
+      android::sysprop::ApexProperties::dm_create_timeout().value_or(1000));
+
+  DeviceMapper& dm = DeviceMapper::Instance();
+
+  auto state = dm.GetState(name);
+  if (state == DmDeviceState::INVALID) {
+    return CreateDmDeviceInternal(dm, name, table, timeout);
+  }
+
+  if (reuse_device) {
+    if (state == DmDeviceState::ACTIVE) {
+      LOG(WARNING) << "Deleting existing active dm-device " << name;
+      OR_RETURN(DeleteDmDevice(name, /* deferred= */ false));
+      return CreateDmDeviceInternal(dm, name, table, timeout);
+    }
+    if (!dm.LoadTableAndActivate(name, table)) {
+      dm.DeleteDevice(name);
+      return Error() << "Failed to activate dm-device " << name;
+    }
+    std::string path;
+    if (!dm.WaitForDevice(name, timeout, &path)) {
+      dm.DeleteDevice(name);
+      return Error() << "Failed waiting for dm-device " << name;
+    }
+    return DmDevice(name, path);
+  } else {
+    // Delete dangling dm-device. This can happen if apexd fails to delete it
+    // while unmounting an apex.
+    LOG(WARNING) << "Deleting existing dm-device " << name;
+    OR_RETURN(DeleteDmDevice(name, /* deferred= */ false));
+    return CreateDmDeviceInternal(dm, name, table, timeout);
+  }
+}
+
+// Deletes a device-mapper device with a given name and path
+// Synchronizes on the device actually being deleted from userspace.
+Result<void> DeleteDmDevice(const std::string& name, bool deferred) {
+  DeviceMapper& dm = DeviceMapper::Instance();
+  if (deferred) {
+    if (!dm.DeleteDeviceDeferred(name)) {
+      return ErrnoError() << "Failed to issue deferred delete of dm-device "
+                          << name;
+    }
+    return {};
+  }
+  auto timeout = std::chrono::milliseconds(
+      android::sysprop::ApexProperties::dm_delete_timeout().value_or(750));
+  if (!dm.DeleteDevice(name, timeout)) {
+    return Error() << "Failed to delete dm-device " << name;
+  }
+  return {};
+}
+
+}  // namespace android::apex
\ No newline at end of file
diff --git a/apexd/apexd_dm.h b/apexd/apexd_dm.h
new file mode 100644
index 00000000..8f7c9d32
--- /dev/null
+++ b/apexd/apexd_dm.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/result.h>
+#include <libdm/dm.h>
+
+#include <string>
+
+namespace android::apex {
+
+class DmDevice {
+ public:
+  DmDevice() : cleared_(true) {}
+  explicit DmDevice(const std::string& name) : name_(name), cleared_(false) {}
+  DmDevice(const std::string& name, const std::string& dev_path)
+      : name_(name), dev_path_(dev_path), cleared_(false) {}
+
+  DmDevice(DmDevice&& other) noexcept
+      : name_(std::move(other.name_)),
+        dev_path_(std::move(other.dev_path_)),
+        cleared_(other.cleared_) {
+    other.cleared_ = true;
+  }
+
+  DmDevice& operator=(DmDevice&& other) noexcept {
+    name_ = other.name_;
+    dev_path_ = other.dev_path_;
+    cleared_ = other.cleared_;
+    other.cleared_ = true;
+    return *this;
+  }
+
+  ~DmDevice();
+
+  const std::string& GetName() const { return name_; }
+  const std::string& GetDevPath() const { return dev_path_; }
+
+  void Release() { cleared_ = true; }
+
+ private:
+  std::string name_;
+  std::string dev_path_;
+  bool cleared_;
+};
+
+base::Result<DmDevice> CreateDmDevice(const std::string& name,
+                                      const dm::DmTable& table,
+                                      bool reuse_device);
+
+base::Result<void> DeleteDmDevice(const std::string& name, bool deferred);
+
+}  // namespace android::apex
diff --git a/apexd/apexd_lifecycle.cpp b/apexd/apexd_lifecycle.cpp
index c59d7416..f18b3822 100644
--- a/apexd/apexd_lifecycle.cpp
+++ b/apexd/apexd_lifecycle.cpp
@@ -17,6 +17,7 @@
 #include <chrono>
 #include <thread>
 
+#include "apexd.h"
 #include "apexd_lifecycle.h"
 
 #include <android-base/logging.h>
@@ -28,6 +29,10 @@ using android::base::GetProperty;
 using android::base::Result;
 using android::base::WaitForProperty;
 
+constexpr int MAX_WAIT_COUNT = 60;
+constexpr int WAIT_DURATION_SECONDS = 10;
+static const char* BOOT_TIMEOUT = "BootTimeout"; // NOLINT
+
 namespace android {
 namespace apex {
 
@@ -36,8 +41,25 @@ bool ApexdLifecycle::IsBooting() {
   return status != kApexStatusReady && status != kApexStatusActivated;
 }
 
-void ApexdLifecycle::WaitForBootStatus(
-    Result<void> (&revert_fn)(const std::string&, const std::string&)) {
+void ApexdLifecycle::RevertActiveSessions(const std::string& process,
+                                          const std::string& error) {
+  auto result = RevertActiveSessionsAndReboot(process, error);
+  if (!result.ok()) {
+    if (error != BOOT_TIMEOUT) {
+      LOG(ERROR) << "Revert failed : " << result.error();
+      // Can not anything more but loop until boot successfully
+      while (!boot_completed_) {
+        std::this_thread::sleep_for(std::chrono::seconds(1));
+      }
+      return;
+    }
+  }
+  // This should never be reached
+  LOG(FATAL) << "Active sessions were reverted, but reboot wasn't triggered.";
+}
+
+void ApexdLifecycle::WaitForBootStatus(const bool has_active_session) {
+  int wait_count = 0;
   while (!boot_completed_) {
     // Check for change in either crashing property or sys.boot_completed
     // Wait for updatable_crashing property change for most of the time
@@ -46,27 +68,19 @@ void ApexdLifecycle::WaitForBootStatus(
     // We use this strategy so that we can quickly detect if an updatable
     // process is crashing.
     if (WaitForProperty("sys.init.updatable_crashing", "1",
-                        std::chrono::seconds(10))) {
+                        std::chrono::seconds(WAIT_DURATION_SECONDS))) {
       auto name = GetProperty("sys.init.updatable_crashing_process_name", "");
       LOG(ERROR) << "Native process '" << (name.empty() ? "[unknown]" : name)
                  << "' is crashing. Attempting a revert";
-      auto result = revert_fn(name, "");
-      if (!result.ok()) {
-        LOG(ERROR) << "Revert failed : " << result.error();
-        return WaitForBootStatus();
-      } else {
-        // This should never be reached, since revert_fn should've rebooted
-        // the device.
-        LOG(FATAL) << "Active sessions were reverted, but reboot wasn't "
-                      "triggered.";
-      }
+      RevertActiveSessions(name, "");
+    }
+    // Check if system stuck in boot screen and revert the staging apex once
+    if (has_active_session && ++wait_count == MAX_WAIT_COUNT) {
+      LOG(ERROR) << "System didn't finish boot in "
+                 << (WAIT_DURATION_SECONDS * MAX_WAIT_COUNT)
+                 << " seconds. Attempting a revert";
+      RevertActiveSessions("", BOOT_TIMEOUT);
     }
-  }
-}
-
-void ApexdLifecycle::WaitForBootStatus() {
-  while (!boot_completed_) {
-    std::this_thread::sleep_for(std::chrono::seconds(1));
   }
 }
 
diff --git a/apexd/apexd_lifecycle.h b/apexd/apexd_lifecycle.h
index be99834c..75dc7612 100644
--- a/apexd/apexd_lifecycle.h
+++ b/apexd/apexd_lifecycle.h
@@ -32,8 +32,8 @@ class ApexdLifecycle {
   ApexdLifecycle& operator=(const ApexdLifecycle&) = delete;
   ApexdLifecycle& operator=(ApexdLifecycle&&) = delete;
 
-  void WaitForBootStatus();
-
+  void RevertActiveSessions(const std::string& process,
+                            const std::string& error);
  public:
   static ApexdLifecycle& GetInstance() {
     static ApexdLifecycle instance;
@@ -41,8 +41,7 @@ class ApexdLifecycle {
   }
   bool IsBooting();
   void MarkBootCompleted();
-  void WaitForBootStatus(android::base::Result<void> (&rollback_fn)(
-      const std::string&, const std::string&));
+  void WaitForBootStatus(const bool has_active_session);
 };
 }  // namespace apex
 }  // namespace android
diff --git a/apexd/apexd_loop.cpp b/apexd/apexd_loop.cpp
index e15a7fa8..49f32869 100644
--- a/apexd/apexd_loop.cpp
+++ b/apexd/apexd_loop.cpp
@@ -30,6 +30,7 @@
 #include <libdm/dm.h>
 #include <linux/fs.h>
 #include <linux/loop.h>
+#include <string>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
@@ -64,7 +65,7 @@ namespace loop {
 static constexpr const char* kApexLoopIdPrefix = "apex:";
 
 // 128 kB read-ahead, which we currently use for /system as well
-static constexpr const char* kReadAheadKb = "128";
+static constexpr const unsigned int kReadAheadKb = 128;
 
 void LoopbackDeviceUniqueFd::MaybeCloseBad() {
   if (device_fd.get() != -1) {
@@ -259,8 +260,11 @@ Result<void> ConfigureReadAhead(const std::string& device_path) {
     return ErrnoError() << "Failed to open " << sysfs_device;
   }
 
+  std::string readAheadKb = std::to_string(
+      android::sysprop::ApexProperties::loopback_readahead().value_or(kReadAheadKb));
+
   int ret = TEMP_FAILURE_RETRY(
-      write(sysfs_fd.get(), kReadAheadKb, strlen(kReadAheadKb) + 1));
+      write(sysfs_fd.get(), readAheadKb.c_str(), readAheadKb.length()));
   if (ret < 0) {
     return ErrnoError() << "Failed to write to " << sysfs_device;
   }
diff --git a/apexd/apexd_main.cpp b/apexd/apexd_main.cpp
index c7d89194..d216bc8d 100644
--- a/apexd/apexd_main.cpp
+++ b/apexd/apexd_main.cpp
@@ -204,7 +204,7 @@ int main(int argc, char** argv) {
     // the "--snapshotde" subcommand is received and snapshot/restore is
     // complete.
     android::apex::OnAllPackagesActivated(/*is_bootstrap=*/false);
-    lifecycle.WaitForBootStatus(android::apex::RevertActiveSessionsAndReboot);
+    lifecycle.WaitForBootStatus(session_manager->HasActiveSession());
     // Run cleanup routine on boot complete.
     // This should run before AllowServiceShutdown() to prevent
     // service_manager killing apexd in the middle of the cleanup.
diff --git a/apexd/apexd_metrics.cpp b/apexd/apexd_metrics.cpp
new file mode 100644
index 00000000..4922091f
--- /dev/null
+++ b/apexd/apexd_metrics.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <statssocket_lazy.h>
+#include <sys/stat.h>
+
+#include "apex_sha.h"
+#include "apexd.h"
+#include "apexd_vendor_apex.h"
+#include "statslog_apex.h"
+
+using android::base::Result;
+
+namespace android::apex {
+
+// Ties sessions to their apex file, assists reporting installation metrics
+std::unordered_map<int, std::vector<std::string>> gSessionApexSha;
+
+void SendApexInstallationRequestedAtom(const std::string& package_path,
+                                       bool is_rollback,
+                                       unsigned int install_type) {
+  if (!statssocket::lazy::IsAvailable()) {
+    LOG(WARNING) << "Unable to send Apex Install Atom for " << package_path
+                 << " ; libstatssocket is not available";
+    return;
+  }
+  auto apex_file = ApexFile::Open(package_path);
+  if (!apex_file.ok()) {
+    LOG(WARNING) << "Unable to send Apex Atom; Failed to open ApexFile "
+                 << package_path << ": " << apex_file.error();
+    return;
+  }
+  const std::string& module_name = apex_file->GetManifest().name();
+  struct stat stat_buf;
+  intmax_t apex_file_size;
+  if (stat(package_path.c_str(), &stat_buf) == 0) {
+    apex_file_size = stat_buf.st_size;
+  } else {
+    PLOG(WARNING) << "Failed to stat " << package_path;
+    apex_file_size = 0;
+  }
+  Result<std::string> apex_file_sha256_str = CalculateSha256(package_path);
+  if (!apex_file_sha256_str.ok()) {
+    LOG(WARNING) << "Unable to get sha256 of ApexFile: "
+                 << apex_file_sha256_str.error();
+    return;
+  }
+  const std::vector<const char*>
+      hal_cstr_list;  // TODO(b/366217822): Populate HAL information
+  int ret = stats::apex::stats_write(
+      stats::apex::APEX_INSTALLATION_REQUESTED, module_name.c_str(),
+      apex_file->GetManifest().version(), apex_file_size,
+      apex_file_sha256_str->c_str(), GetPreinstallPartitionEnum(*apex_file),
+      install_type, is_rollback,
+      apex_file->GetManifest().providesharedapexlibs(), hal_cstr_list);
+  if (ret < 0) {
+    LOG(WARNING) << "Failed to report apex_installation_requested stats";
+  }
+}
+
+void SendApexInstallationStagedAtom(const std::string& package_path) {
+  if (!statssocket::lazy::IsAvailable()) {
+    LOG(WARNING) << "Unable to send Apex Staged Atom for " << package_path
+                 << " ; libstatssocket is not available";
+    return;
+  }
+  Result<std::string> apex_file_sha256_str = CalculateSha256(package_path);
+  if (!apex_file_sha256_str.ok()) {
+    LOG(WARNING) << "Unable to get sha256 of ApexFile: "
+                 << apex_file_sha256_str.error();
+    return;
+  }
+  int ret = stats::apex::stats_write(stats::apex::APEX_INSTALLATION_STAGED,
+                                     apex_file_sha256_str->c_str());
+  if (ret < 0) {
+    LOG(WARNING) << "Failed to report apex_installation_staged stats";
+  }
+}
+
+void SendApexInstallationEndedAtom(const std::string& package_path,
+                                   int install_result) {
+  if (!statssocket::lazy::IsAvailable()) {
+    LOG(WARNING) << "Unable to send Apex Ended Atom for " << package_path
+                 << " ; libstatssocket is not available";
+    return;
+  }
+  Result<std::string> apex_file_sha256_str = CalculateSha256(package_path);
+  if (!apex_file_sha256_str.ok()) {
+    LOG(WARNING) << "Unable to get sha256 of ApexFile: "
+                 << apex_file_sha256_str.error();
+    return;
+  }
+  int ret =
+      stats::apex::stats_write(stats::apex::APEX_INSTALLATION_ENDED,
+                               apex_file_sha256_str->c_str(), install_result);
+  if (ret < 0) {
+    LOG(WARNING) << "Failed to report apex_installation_ended stats";
+  }
+}
+
+void SendSessionApexInstallationEndedAtom(int session_id, int install_result) {
+  if (!statssocket::lazy::IsAvailable()) {
+    LOG(WARNING) << "Unable to send Apex Ended Atom for session " << session_id
+                 << " ; libstatssocket is not available";
+    return;
+  }
+  if (gSessionApexSha.find(session_id) == gSessionApexSha.end()) {
+    LOG(WARNING) << "Unable to send Apex Ended Atom for session " << session_id
+                 << " ; apex_sha for session was not found";
+    return;
+  }
+  for (const auto& apex_sha : gSessionApexSha[session_id]) {
+    int ret = stats::apex::stats_write(stats::apex::APEX_INSTALLATION_ENDED,
+                                       apex_sha.c_str(), install_result);
+    if (ret < 0) {
+      LOG(WARNING) << "Failed to report apex_installation_ended stats";
+    }
+  }
+}
+
+void SendApexInstallationStagedAtoms(
+    const std::vector<std::string>& package_paths) {
+  for (const std::string& path : package_paths) {
+    SendApexInstallationStagedAtom(path);
+  }
+}
+
+void SendApexInstallationEndedAtoms(
+    const std::vector<std::string>& package_paths, int install_result) {
+  for (const std::string& path : package_paths) {
+    SendApexInstallationEndedAtom(path, install_result);
+  }
+}
+
+void RegisterSessionApexSha(int session_id, const std::string apex_file_sha) {
+  gSessionApexSha[session_id].push_back(apex_file_sha);
+}
+
+}  // namespace android::apex
diff --git a/apexd/apexd_metrics.h b/apexd/apexd_metrics.h
new file mode 100644
index 00000000..e46f9a8b
--- /dev/null
+++ b/apexd/apexd_metrics.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+namespace android::apex {
+
+void RegisterSessionApexSha(int session_id, const std::string apex_file_sha);
+
+void SendApexInstallationRequestedAtom(const std::string& package_path,
+                                       bool is_rollback,
+                                       unsigned int install_type);
+
+void SendApexInstallationStagedAtom(const std::string& package_path);
+
+void SendApexInstallationEndedAtom(const std::string& package_path,
+                                   int install_result);
+
+void SendSessionApexInstallationEndedAtom(int session_id, int install_result);
+
+void SendApexInstallationStagedAtoms(
+    const std::vector<std::string>& package_paths);
+void SendApexInstallationEndedAtoms(
+    const std::vector<std::string>& package_paths, int install_result);
+
+void SendApexInstallationFailedAtoms(const std::vector<ApexFile>& apexes);
+
+}  // namespace android::apex
diff --git a/apexd/apexd_microdroid.cpp b/apexd/apexd_microdroid.cpp
index d95b8ef2..15b540e3 100644
--- a/apexd/apexd_microdroid.cpp
+++ b/apexd/apexd_microdroid.cpp
@@ -32,7 +32,6 @@ static const android::apex::ApexdConfig kMicrodroidConfig = {
     nullptr, /* active_apex_data_dir */
     nullptr, /* decompression_dir */
     nullptr, /* ota_reserved_dir */
-    nullptr, /* apex_hashtree_dir */
     nullptr, /* staged_session_dir */
     android::apex::kVmPayloadMetadataPartitionProp,
     nullptr, /* active_apex_selinux_ctx */
diff --git a/apexd/apexd_private.h b/apexd/apexd_private.h
index b3108cff..ea8d1504 100644
--- a/apexd/apexd_private.h
+++ b/apexd/apexd_private.h
@@ -40,9 +40,6 @@ std::string GetActiveMountPoint(const ::apex::proto::ApexManifest& manifest);
 
 android::base::Result<void> BindMount(const std::string& target,
                                       const std::string& source);
-android::base::Result<MountedApexDatabase::MountedApexData>
-GetTempMountedApexData(const std::string& package);
-android::base::Result<void> UnmountTempMount(const ApexFile& apex);
 
 }  // namespace apexd_private
 }  // namespace apex
diff --git a/apexd/apexd_session.cpp b/apexd/apexd_session.cpp
index 05fd8394..69ac1d93 100644
--- a/apexd/apexd_session.cpp
+++ b/apexd/apexd_session.cpp
@@ -77,75 +77,6 @@ std::string GetSessionsDir() {
 ApexSession::ApexSession(SessionState state, std::string session_dir)
     : state_(std::move(state)), session_dir_(std::move(session_dir)) {}
 
-Result<void> ApexSession::MigrateToMetadataSessionsDir() {
-  return MoveDir(kOldApexSessionsDir, kNewApexSessionsDir);
-}
-
-Result<ApexSession> ApexSession::CreateSession(int session_id) {
-  SessionState state;
-  // Create session directory
-  std::string session_dir = GetSessionsDir() + "/" + std::to_string(session_id);
-  if (auto status = CreateDirIfNeeded(session_dir, 0700); !status.ok()) {
-    return status.error();
-  }
-  state.set_id(session_id);
-
-  return ApexSession(state, std::move(session_dir));
-}
-
-Result<ApexSession> ApexSession::GetSessionFromDir(
-    const std::string& session_dir) {
-  auto state = ParseSessionState(session_dir);
-  if (!state.ok()) {
-    return state.error();
-  }
-  return ApexSession(*state, session_dir);
-}
-
-Result<ApexSession> ApexSession::GetSession(int session_id) {
-  auto session_dir =
-      StringPrintf("%s/%d", GetSessionsDir().c_str(), session_id);
-
-  return GetSessionFromDir(session_dir);
-}
-
-std::vector<ApexSession> ApexSession::GetSessions() {
-  std::vector<ApexSession> sessions;
-
-  Result<std::vector<std::string>> session_paths = ReadDir(
-      GetSessionsDir(), [](const std::filesystem::directory_entry& entry) {
-        std::error_code ec;
-        return entry.is_directory(ec);
-      });
-
-  if (!session_paths.ok()) {
-    return sessions;
-  }
-
-  for (const std::string& session_dir_path : *session_paths) {
-    // Try to read session state
-    auto session = GetSessionFromDir(session_dir_path);
-    if (!session.ok()) {
-      LOG(WARNING) << session.error();
-      continue;
-    }
-    sessions.push_back(std::move(*session));
-  }
-
-  return sessions;
-}
-
-std::vector<ApexSession> ApexSession::GetSessionsInState(
-    SessionState::State state) {
-  auto sessions = GetSessions();
-  sessions.erase(
-      std::remove_if(sessions.begin(), sessions.end(),
-                     [&](const ApexSession &s) { return s.GetState() != state; }),
-      sessions.end());
-
-  return sessions;
-}
-
 SessionState::State ApexSession::GetState() const { return state_.state(); }
 
 int ApexSession::GetId() const { return state_.id(); }
@@ -263,19 +194,6 @@ std::ostream& operator<<(std::ostream& out, const ApexSession& session) {
              << "; session_dir = " << session.GetSessionDir() << "]";
 }
 
-void ApexSession::DeleteFinalizedSessions() {
-  auto sessions = GetSessions();
-  for (const ApexSession& session : sessions) {
-    if (!session.IsFinalized()) {
-      continue;
-    }
-    auto result = session.DeleteSession();
-    if (!result.ok()) {
-      LOG(WARNING) << "Failed to delete finalized session: " << session.GetId();
-    }
-  }
-}
-
 std::vector<std::string> ApexSession::GetStagedApexDirs(
     const std::string& staged_session_dir) const {
   const google::protobuf::RepeatedField<int>& child_session_ids =
@@ -350,10 +268,10 @@ std::vector<ApexSession> ApexSessionManager::GetSessions() const {
 
   if (!walk_status.ok()) {
     LOG(WARNING) << walk_status.error();
-    return std::move(sessions);
+    return sessions;
   }
 
-  return std::move(sessions);
+  return sessions;
 }
 
 std::vector<ApexSession> ApexSessionManager::GetSessionsInState(
@@ -380,5 +298,28 @@ Result<void> ApexSessionManager::MigrateFromOldSessionsDir(
   return MoveDir(old_sessions_base_dir, sessions_base_dir_);
 }
 
+bool ApexSessionManager::HasActiveSession() {
+  for (auto& s : GetSessions()) {
+    if (!s.IsFinalized() &&
+        s.GetState() != ::apex::proto::SessionState::UNKNOWN) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void ApexSessionManager::DeleteFinalizedSessions() {
+  auto sessions = GetSessions();
+  for (const ApexSession& session : sessions) {
+    if (!session.IsFinalized()) {
+      continue;
+    }
+    auto result = session.DeleteSession();
+    if (!result.ok()) {
+      LOG(WARNING) << "Failed to delete finalized session: " << session.GetId();
+    }
+  }
+}
+
 }  // namespace apex
 }  // namespace android
diff --git a/apexd/apexd_session.h b/apexd/apexd_session.h
index c497aadb..d95ab7eb 100644
--- a/apexd/apexd_session.h
+++ b/apexd/apexd_session.h
@@ -44,16 +44,6 @@ std::string GetSessionsDir();
 // TODO(b/288309411): remove static functions in this class.
 class ApexSession {
  public:
-  // Migrates content of /data/apex/sessions to /metadata/apex/sessions.
-  // If device doesn't have /metadata partition this call will be a no-op.
-  // If /data/apex/sessions this call will also be a no-op.
-  static android::base::Result<void> MigrateToMetadataSessionsDir();
-
-  static android::base::Result<ApexSession> CreateSession(int session_id);
-  static android::base::Result<ApexSession> GetSession(int session_id);
-  static std::vector<ApexSession> GetSessions();
-  static std::vector<ApexSession> GetSessionsInState(
-      ::apex::proto::SessionState::State state);
   ApexSession() = delete;
 
   const google::protobuf::RepeatedField<int> GetChildSessionIds() const;
@@ -82,7 +72,6 @@ class ApexSession {
       const ::apex::proto::SessionState::State& state);
 
   android::base::Result<void> DeleteSession() const;
-  static void DeleteFinalizedSessions();
 
   // Returns the directories containing the apexes staged for this session.
   std::vector<std::string> GetStagedApexDirs(
@@ -94,9 +83,6 @@ class ApexSession {
   ApexSession(::apex::proto::SessionState state, std::string session_dir);
   ::apex::proto::SessionState state_;
   std::string session_dir_;
-
-  static android::base::Result<ApexSession> GetSessionFromDir(
-      const std::string& session_dir);
 };
 
 class ApexSessionManager {
@@ -116,6 +102,9 @@ class ApexSessionManager {
   android::base::Result<void> MigrateFromOldSessionsDir(
       const std::string& old_sessions_base_dir);
 
+  bool HasActiveSession();
+  void DeleteFinalizedSessions();
+
  private:
   explicit ApexSessionManager(std::string sessions_base_dir);
   ApexSessionManager(const ApexSessionManager&) = delete;
diff --git a/apexd/apexd_session_test.cpp b/apexd/apexd_session_test.cpp
index 3061e80a..233bbc11 100644
--- a/apexd/apexd_session_test.cpp
+++ b/apexd/apexd_session_test.cpp
@@ -66,67 +66,6 @@ TEST(ApexdSessionTest, GetSessionsDirNoMetadataPartitionFallbackToData) {
   ASSERT_EQ(result, "/data/apex/sessions");
 }
 
-TEST(ApexdSessionTest, MigrateToMetadataSessionsDir) {
-  namespace fs = std::filesystem;
-
-  if (access("/metadata", F_OK) != 0) {
-    GTEST_SKIP() << "Device doesn't have /metadata partition";
-  }
-
-  // This is ugly, but does the job. To have a truly hermetic unit tests we
-  // need to refactor ApexSession class.
-  for (const auto& entry : fs::directory_iterator("/metadata/apex/sessions")) {
-    fs::remove_all(entry.path());
-  }
-
-  // This is a very ugly test set up, but to have something better we need to
-  // refactor ApexSession class.
-  class TestApexSession {
-   public:
-    TestApexSession(int id, const SessionState::State& state) {
-      path_ = "/data/apex/sessions/" + std::to_string(id);
-      if (auto status = CreateDirIfNeeded(path_, 0700); !status.ok()) {
-        ADD_FAILURE() << "Failed to create " << path_ << " : "
-                      << status.error();
-      }
-      SessionState session;
-      session.set_id(id);
-      session.set_state(state);
-      std::fstream state_file(
-          path_ + "/state", std::ios::out | std::ios::trunc | std::ios::binary);
-      if (!session.SerializeToOstream(&state_file)) {
-        ADD_FAILURE() << "Failed to write to " << path_;
-      }
-    }
-
-    ~TestApexSession() { fs::remove_all(path_); }
-
-   private:
-    std::string path_;
-  };
-
-  auto deleter = make_scope_guard([&]() {
-    fs::remove_all("/metadata/apex/sessions/239");
-    fs::remove_all("/metadata/apex/sessions/1543");
-  });
-
-  TestApexSession session1(239, SessionState::SUCCESS);
-  TestApexSession session2(1543, SessionState::ACTIVATION_FAILED);
-
-  ASSERT_RESULT_OK(ApexSession::MigrateToMetadataSessionsDir());
-
-  auto sessions = ApexSession::GetSessions();
-  ASSERT_EQ(2u, sessions.size()) << Join(sessions, ',');
-
-  auto migrated_session_1 = ApexSession::GetSession(239);
-  ASSERT_RESULT_OK(migrated_session_1);
-  ASSERT_EQ(SessionState::SUCCESS, migrated_session_1->GetState());
-
-  auto migrated_session_2 = ApexSession::GetSession(1543);
-  ASSERT_RESULT_OK(migrated_session_2);
-  ASSERT_EQ(SessionState::ACTIVATION_FAILED, migrated_session_2->GetState());
-}
-
 TEST(ApexSessionManagerTest, CreateSession) {
   TemporaryDir td;
   auto manager = ApexSessionManager::Create(std::string(td.path));
diff --git a/apexd/apexd_test.cpp b/apexd/apexd_test.cpp
index ad0f9cc8..0c4919f0 100644
--- a/apexd/apexd_test.cpp
+++ b/apexd/apexd_test.cpp
@@ -28,10 +28,13 @@
 #include <microdroid/metadata.h>
 #include <selinux/selinux.h>
 #include <sys/stat.h>
+#include <unistd.h>
 
+#include <chrono>
 #include <functional>
 #include <optional>
 #include <string>
+#include <thread>
 #include <tuple>
 #include <unordered_set>
 #include <vector>
@@ -70,6 +73,7 @@ using android::base::WriteStringToFile;
 using android::base::testing::HasError;
 using android::base::testing::HasValue;
 using android::base::testing::Ok;
+using android::base::testing::WithCode;
 using android::base::testing::WithMessage;
 using android::dm::DeviceMapper;
 using ::apex::proto::SessionState;
@@ -121,8 +125,6 @@ class MockCheckpointInterface : public CheckpointInterface {
 
   Result<bool> NeedsRollback() override { return needs_rollback_; }
 
-  Result<void> StartCheckpoint(int32_t num_retries) override { return {}; }
-
   Result<void> AbortChanges(const std::string& msg, bool retry) override {
     return {};
   }
@@ -152,7 +154,6 @@ class ApexdUnitTest : public ::testing::Test {
     data_dir_ = StringPrintf("%s/data-apex", td_.path);
     decompression_dir_ = StringPrintf("%s/decompressed-apex", td_.path);
     ota_reserved_dir_ = StringPrintf("%s/ota-reserved", td_.path);
-    hash_tree_dir_ = StringPrintf("%s/apex-hash-tree", td_.path);
     staged_session_dir_ = StringPrintf("%s/staged-session-dir", td_.path);
 
     sessions_metadata_dir_ =
@@ -164,7 +165,6 @@ class ApexdUnitTest : public ::testing::Test {
                data_dir_.c_str(),
                decompression_dir_.c_str(),
                ota_reserved_dir_.c_str(),
-               hash_tree_dir_.c_str(),
                staged_session_dir_.c_str(),
                kTestVmPayloadMetadataPartitionProp,
                kTestActiveApexSelinuxCtx};
@@ -174,7 +174,6 @@ class ApexdUnitTest : public ::testing::Test {
   const std::string& GetDataDir() { return data_dir_; }
   const std::string& GetDecompressionDir() { return decompression_dir_; }
   const std::string& GetOtaReservedDir() { return ota_reserved_dir_; }
-  const std::string& GetHashTreeDir() { return hash_tree_dir_; }
   const std::string GetStagedDir(int session_id) {
     return StringPrintf("%s/session_%d", staged_session_dir_.c_str(),
                         session_id);
@@ -262,7 +261,6 @@ class ApexdUnitTest : public ::testing::Test {
     ASSERT_EQ(mkdir(data_dir_.c_str(), 0755), 0);
     ASSERT_EQ(mkdir(decompression_dir_.c_str(), 0755), 0);
     ASSERT_EQ(mkdir(ota_reserved_dir_.c_str(), 0755), 0);
-    ASSERT_EQ(mkdir(hash_tree_dir_.c_str(), 0755), 0);
     ASSERT_EQ(mkdir(staged_session_dir_.c_str(), 0755), 0);
     ASSERT_EQ(mkdir(sessions_metadata_dir_.c_str(), 0755), 0);
 
@@ -282,7 +280,6 @@ class ApexdUnitTest : public ::testing::Test {
   std::string data_dir_;
   std::string decompression_dir_;
   std::string ota_reserved_dir_;
-  std::string hash_tree_dir_;
 
   std::string staged_session_dir_;
   std::string sessions_metadata_dir_;
@@ -988,21 +985,6 @@ TEST_F(ApexdMountTest, InstallPackageRejectsNoPreInstalledApex) {
                "No active version found for package test.apex.rebootless"))));
 }
 
-TEST_F(ApexdMountTest, InstallPackageRejectsNoHashtree) {
-  std::string file_path = AddPreInstalledApex("test.rebootless_apex_v1.apex");
-  ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
-
-  ASSERT_THAT(ActivatePackage(file_path), Ok());
-  UnmountOnTearDown(file_path);
-
-  auto ret =
-      InstallPackage(GetTestFile("test.rebootless_apex_v2_no_hashtree.apex"),
-                     /* force= */ false);
-  ASSERT_THAT(
-      ret,
-      HasError(WithMessage(HasSubstr(" does not have an embedded hash tree"))));
-}
-
 TEST_F(ApexdMountTest, InstallPackageRejectsNoActiveApex) {
   std::string file_path = AddPreInstalledApex("test.rebootless_apex_v1.apex");
   ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
@@ -1670,73 +1652,18 @@ TEST_F(ApexdMountTest, ActivatePackageShowsUpInMountedApexDatabase) {
       << "mounted apexes";
 }
 
-TEST_F(ApexdMountTest, ActivatePackageNoHashtree) {
-  AddPreInstalledApex("apex.apexd_test.apex");
-  ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
-
-  std::string file_path = AddDataApex("apex.apexd_test_no_hashtree.apex");
-  ASSERT_THAT(ActivatePackage(file_path), Ok());
-  UnmountOnTearDown(file_path);
-
-  // Check that hashtree was generated
-  std::string hashtree_path =
-      GetHashTreeDir() + "/com.android.apex.test_package@1";
-  ASSERT_EQ(0, access(hashtree_path.c_str(), F_OK));
-
-  // Check that block device can be read.
-  auto block_device = GetBlockDeviceForApex("com.android.apex.test_package@1");
-  ASSERT_THAT(block_device, Ok());
-  ASSERT_THAT(ReadDevice(*block_device), Ok());
-}
-
-TEST_F(ApexdMountTest, ActivatePackageNoHashtreeShowsUpInMountedDatabase) {
-  AddPreInstalledApex("apex.apexd_test.apex");
-  ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
-
-  std::string file_path = AddDataApex("apex.apexd_test_no_hashtree.apex");
-  ASSERT_THAT(ActivatePackage(file_path), Ok());
-  UnmountOnTearDown(file_path);
-
-  // Get loop devices that were used to mount APEX.
-  auto children = ListChildLoopDevices("com.android.apex.test_package@1");
-  ASSERT_THAT(children, Ok());
-  ASSERT_EQ(2u, children->size())
-      << "Unexpected number of children: " << Join(*children, ",");
-
-  auto& db = GetApexDatabaseForTesting();
-  std::optional<MountedApexData> mounted_apex;
-  db.ForallMountedApexes("com.android.apex.test_package",
-                         [&](const MountedApexData& d, bool active) {
-                           if (active) {
-                             mounted_apex.emplace(d);
-                           }
-                         });
-  ASSERT_TRUE(mounted_apex)
-      << "Haven't found com.android.apex.test_package@1  in the database of "
-      << "mounted apexes";
-
-  ASSERT_EQ(file_path, mounted_apex->full_path);
-  ASSERT_EQ("/apex/com.android.apex.test_package@1", mounted_apex->mount_point);
-  ASSERT_EQ("com.android.apex.test_package@1", mounted_apex->device_name);
-  // For loops we only check that both loop_name and hashtree_loop_name are
-  // children of the top device mapper device.
-  ASSERT_THAT(*children, Contains(mounted_apex->loop_name));
-  ASSERT_THAT(*children, Contains(mounted_apex->hashtree_loop_name));
-  ASSERT_NE(mounted_apex->loop_name, mounted_apex->hashtree_loop_name);
-}
-
 TEST_F(ApexdMountTest, DeactivePackageFreesLoopDevices) {
   AddPreInstalledApex("apex.apexd_test.apex");
   ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
 
-  std::string file_path = AddDataApex("apex.apexd_test_no_hashtree.apex");
+  std::string file_path = AddDataApex("apex.apexd_test_v2.apex");
   ASSERT_THAT(ActivatePackage(file_path), Ok());
   UnmountOnTearDown(file_path);
 
   // Get loop devices that were used to mount APEX.
-  auto children = ListChildLoopDevices("com.android.apex.test_package@1");
+  auto children = ListChildLoopDevices("com.android.apex.test_package@2");
   ASSERT_THAT(children, Ok());
-  ASSERT_EQ(2u, children->size())
+  ASSERT_EQ(1u, children->size())
       << "Unexpected number of children: " << Join(*children, ",");
 
   ASSERT_THAT(DeactivatePackage(file_path), Ok());
@@ -1751,103 +1678,6 @@ TEST_F(ApexdMountTest, DeactivePackageFreesLoopDevices) {
   }
 }
 
-TEST_F(ApexdMountTest, NoHashtreeApexNewSessionDoesNotImpactActivePackage) {
-  MockCheckpointInterface checkpoint_interface;
-  checkpoint_interface.SetSupportsCheckpoint(true);
-  InitializeVold(&checkpoint_interface);
-
-  AddPreInstalledApex("apex.apexd_test_no_hashtree.apex");
-  ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
-
-  std::string file_path = AddDataApex("apex.apexd_test_no_hashtree.apex");
-  ASSERT_THAT(ActivatePackage(file_path), Ok());
-  UnmountOnTearDown(file_path);
-
-  ASSERT_THAT(CreateStagedSession("apex.apexd_test_no_hashtree_2.apex", 239),
-              Ok());
-  auto status =
-      SubmitStagedSession(239, {}, /* has_rollback_enabled= */ false,
-                          /* is_rollback= */ false, /* rollback_id= */ -1);
-  ASSERT_THAT(status, Ok());
-
-  // Check that new hashtree file was created.
-  {
-    std::string hashtree_path =
-        GetHashTreeDir() + "/com.android.apex.test_package@1.new";
-    ASSERT_THAT(PathExists(hashtree_path), HasValue(true))
-        << hashtree_path << " does not exist";
-  }
-  // Check that active hashtree is still there.
-  {
-    std::string hashtree_path =
-        GetHashTreeDir() + "/com.android.apex.test_package@1";
-    ASSERT_THAT(PathExists(hashtree_path), HasValue(true))
-        << hashtree_path << " does not exist";
-  }
-
-  // Check that block device of active APEX can still be read.
-  auto block_device = GetBlockDeviceForApex("com.android.apex.test_package@1");
-  ASSERT_THAT(block_device, Ok());
-  ASSERT_THAT(ReadDevice(*block_device), Ok());
-}
-
-TEST_F(ApexdMountTest, NoHashtreeApexStagePackagesMovesHashtree) {
-  MockCheckpointInterface checkpoint_interface;
-  checkpoint_interface.SetSupportsCheckpoint(true);
-  InitializeVold(&checkpoint_interface);
-
-  AddPreInstalledApex("apex.apexd_test_no_hashtree.apex");
-  ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
-
-  auto read_fn = [](const std::string& path) -> std::vector<uint8_t> {
-    static constexpr size_t kBufSize = 4096;
-    std::vector<uint8_t> buffer(kBufSize);
-    unique_fd fd(TEMP_FAILURE_RETRY(open(path.c_str(), O_RDONLY | O_CLOEXEC)));
-    if (fd.get() == -1) {
-      PLOG(ERROR) << "Failed to open " << path;
-      ADD_FAILURE();
-      return buffer;
-    }
-    if (!ReadFully(fd.get(), buffer.data(), kBufSize)) {
-      PLOG(ERROR) << "Failed to read " << path;
-      ADD_FAILURE();
-    }
-    return buffer;
-  };
-
-  ASSERT_THAT(CreateStagedSession("apex.apexd_test_no_hashtree_2.apex", 37),
-              Ok());
-  auto status =
-      SubmitStagedSession(37, {}, /* has_rollback_enabled= */ false,
-                          /* is_rollback= */ false, /* rollback_id= */ -1);
-  ASSERT_THAT(status, Ok());
-  auto staged_apex = std::move((*status)[0]);
-
-  // Check that new hashtree file was created.
-  std::vector<uint8_t> original_hashtree_data;
-  {
-    std::string hashtree_path =
-        GetHashTreeDir() + "/com.android.apex.test_package@1.new";
-    ASSERT_THAT(PathExists(hashtree_path), HasValue(true));
-    original_hashtree_data = read_fn(hashtree_path);
-  }
-
-  ASSERT_THAT(StagePackages({staged_apex.GetPath()}), Ok());
-  // Check that hashtree file was moved.
-  {
-    std::string hashtree_path =
-        GetHashTreeDir() + "/com.android.apex.test_package@1.new";
-    ASSERT_THAT(PathExists(hashtree_path), HasValue(false));
-  }
-  {
-    std::string hashtree_path =
-        GetHashTreeDir() + "/com.android.apex.test_package@1";
-    ASSERT_THAT(PathExists(hashtree_path), HasValue(true));
-    std::vector<uint8_t> moved_hashtree_data = read_fn(hashtree_path);
-    ASSERT_EQ(moved_hashtree_data, original_hashtree_data);
-  }
-}
-
 TEST_F(ApexdMountTest, DeactivePackageTearsDownVerityDevice) {
   AddPreInstalledApex("apex.apexd_test.apex");
   ApexFileRepository::GetInstance().AddPreInstalledApex({GetBuiltInDir()});
@@ -3973,8 +3803,7 @@ TEST_F(ApexdMountTest, PopulateFromMountsChecksPathPrefix) {
   db.Reset();
 
   // Populate from mount
-  db.PopulateFromMounts({GetDataDir(), GetDecompressionDir()},
-                        GetHashTreeDir());
+  db.PopulateFromMounts({GetDataDir(), GetDecompressionDir()});
 
   // Count number of package and collect package names
   int package_count = 0;
@@ -4070,7 +3899,7 @@ TEST_F(ApexdMountTest, UnmountAllSharedLibsApex) {
   ASSERT_EQ(new_apex_mounts.size(), 0u);
 }
 
-TEST_F(ApexdMountTest, UnmountAllRetry) {
+TEST_F(ApexdMountTest, UnmountAllDeferred) {
   AddPreInstalledApex("apex.apexd_test.apex");
   std::string apex_path_2 =
       AddPreInstalledApex("apex.apexd_test_different_app.apex");
@@ -4084,32 +3913,49 @@ TEST_F(ApexdMountTest, UnmountAllRetry) {
   UnmountOnTearDown(apex_path_2);
   UnmountOnTearDown(apex_path_3);
 
-  auto apex_mounts = GetApexMounts();
-  ASSERT_THAT(apex_mounts,
+  ASSERT_THAT(GetApexMounts(),
               UnorderedElementsAre("/apex/com.android.apex.test_package",
                                    "/apex/com.android.apex.test_package@2",
                                    "/apex/com.android.apex.test_package_2",
                                    "/apex/com.android.apex.test_package_2@1"));
 
-  // Open a file. This should make `UnmountAll` fail.
+  const std::string kDeviceName = "com.android.apex.test_package@2";
+  Result<std::vector<std::string>> loop_devices =
+      ListChildLoopDevices(kDeviceName);
+  ASSERT_THAT(loop_devices, HasValue(Not(IsEmpty())));
+
+  // Open a file. This should make unmounting in `UnmountAll` deferred.
   unique_fd fd(
-      open("/apex/com.android.apex.test_package_2/etc/sample_prebuilt_file",
+      open("/apex/com.android.apex.test_package/etc/sample_prebuilt_file",
            O_RDONLY));
+  ASSERT_GE(fd, 0) << strerror(errno);
 
   auto& db = GetApexDatabaseForTesting();
   // UnmountAll expects apex database to empty, hence this reset.
   db.Reset();
-  ASSERT_NE(0, UnmountAll(/*also_include_staged_apexes=*/false));
-  apex_mounts = GetApexMounts();
-  ASSERT_THAT(apex_mounts, Not(IsEmpty()));
+  // UnmountAll should succeed despite the open file.
+  ASSERT_EQ(UnmountAll(/*also_include_staged_apexes=*/false), 0);
+
+  // The mount should still be there, but it should be detached from the
+  // filesystem, so the mount point should be gone.
+  EXPECT_THAT(GetApexMounts(), IsEmpty());
+  // The DM device and the loop device should still be there.
+  auto& dm = DeviceMapper::Instance();
+  EXPECT_EQ(dm.GetState(kDeviceName), dm::DmDeviceState::ACTIVE);
+  for (const std::string& loop_device : *loop_devices) {
+    EXPECT_THAT(GetLoopDeviceStatus(loop_device), Ok());
+  }
 
-  // Close the file. `UnmountAll` should succeed after then.
+  // Close the file. Unmounting should be automatically performed after then.
   fd.reset();
+  // Wait for the kernel to clean things up.
+  std::this_thread::sleep_for(std::chrono::milliseconds(300));
 
-  db.Reset();
-  ASSERT_EQ(0, UnmountAll(/*also_include_staged_apexes=*/false));
-  apex_mounts = GetApexMounts();
-  ASSERT_THAT(apex_mounts, IsEmpty());
+  // The DM device and the loop device should be gone.
+  EXPECT_EQ(dm.GetState(kDeviceName), dm::DmDeviceState::INVALID);
+  for (const std::string& loop_device : *loop_devices) {
+    EXPECT_THAT(GetLoopDeviceStatus(loop_device), HasError(WithCode(ENXIO)));
+  }
 }
 
 TEST_F(ApexdMountTest, UnmountAllStaged) {
diff --git a/apexd/apexd_test_utils.h b/apexd/apexd_test_utils.h
index b198115f..517080cb 100644
--- a/apexd/apexd_test_utils.h
+++ b/apexd/apexd_test_utils.h
@@ -463,6 +463,20 @@ inline android::base::Result<std::vector<std::string>> ListChildLoopDevices(
   return children;
 }
 
+inline android::base::Result<struct loop_info64> GetLoopDeviceStatus(
+    const std::string& loop_device) {
+  android::base::unique_fd loop_fd(
+      open(loop_device.c_str(), O_RDONLY | O_CLOEXEC));
+  if (loop_fd < 0) {
+    return ErrnoErrorf("Failed to open loop device '{}'", loop_device);
+  }
+  struct loop_info64 loop_info;
+  if (ioctl(loop_fd, LOOP_GET_STATUS64, &loop_info) != 0) {
+    return ErrnoErrorf("Failed to get loop device status '{}'", loop_device);
+  }
+  return loop_info;
+}
+
 }  // namespace apex
 }  // namespace android
 
diff --git a/apexd/apexd_testdata/Android.bp b/apexd/apexd_testdata/Android.bp
index ea382506..c90d943c 100644
--- a/apexd/apexd_testdata/Android.bp
+++ b/apexd/apexd_testdata/Android.bp
@@ -239,34 +239,6 @@ apex {
     updatable: false,
 }
 
-apex {
-    name: "apex.apexd_test_no_hashtree",
-    manifest: "manifest.json",
-    file_contexts: ":apex.test-file_contexts",
-    prebuilts: ["sample_prebuilt_file"],
-    key: "com.android.apex.test_package.key",
-    installable: false,
-    generate_hashtree: false,
-    updatable: false,
-}
-
-// This APEX has same name and version as apex.apexd_test_no_hashtree, but has
-// different content. It's used to test that staging a same version of already
-// active APEX without hashtree doesn't impact already active one.
-apex {
-    name: "apex.apexd_test_no_hashtree_2",
-    manifest: "manifest.json",
-    file_contexts: ":apex.test-file_contexts",
-    prebuilts: [
-        "another_prebuilt_file",
-        "sample_prebuilt_file",
-    ],
-    key: "com.android.apex.test_package.key",
-    installable: false,
-    generate_hashtree: false,
-    updatable: false,
-}
-
 apex {
     name: "apex.apexd_test_v2",
     manifest: "manifest_v2.json",
@@ -449,16 +421,6 @@ apex {
     updatable: false,
 }
 
-apex {
-    name: "test.rebootless_apex_v2_no_hashtree",
-    manifest: "manifest_rebootless_v2.json",
-    file_contexts: ":apex.test-file_contexts",
-    key: "com.android.apex.test_package.key",
-    installable: false,
-    updatable: false,
-    generate_hashtree: false,
-}
-
 apex {
     name: "test.rebootless_apex_provides_sharedlibs",
     manifest: "manifest_rebootless_provides_sharedlibs.json",
diff --git a/apexd/apexd_vendor_apex.cpp b/apexd/apexd_vendor_apex.cpp
index 00dde33d..1e0a7820 100644
--- a/apexd/apexd_vendor_apex.cpp
+++ b/apexd/apexd_vendor_apex.cpp
@@ -31,18 +31,25 @@ using android::base::StartsWith;
 namespace android {
 namespace apex {
 
+bool InVendorPartition(const std::string& path) {
+  return StartsWith(path, "/vendor/apex/") ||
+         StartsWith(path, "/system/vendor/apex/");
+}
+
+bool InOdmPartition(const std::string& path) {
+  return StartsWith(path, "/odm/apex/") ||
+         StartsWith(path, "/vendor/odm/apex/") ||
+         StartsWith(path, "/system/vendor/odm/apex/");
+}
+
 // Returns if apex is a vendor apex, works by testing path of its preinstalled
-// version NOTE: If BOARD_USES_VENDORIMAGE is false, then /vendor will be a
-// symlink to
-//    /system/vendor. Apexd handles "realpath"s for apexes. Hence when checking
-//    if an Apex is a vendor apex with path, we need to check against both.
+// version.
 bool IsVendorApex(const ApexFile& apex_file) {
   const auto& instance = ApexFileRepository::GetInstance();
   const auto& preinstalled =
       instance.GetPreInstalledApex(apex_file.GetManifest().name());
-  const auto& preinstalled_path = preinstalled.get().GetPath();
-  return (StartsWith(preinstalled_path, "/vendor/apex/") ||
-          StartsWith(preinstalled_path, "/system/vendor/apex/"));
+  const auto& path = preinstalled.get().GetPath();
+  return InVendorPartition(path) || InOdmPartition(path);
 }
 
 // Checks Compatibility for incoming vendor apex.
@@ -101,20 +108,23 @@ int GetPreinstallPartitionEnum(const ApexFile& apex_file) {
   const auto& preinstalled =
       instance.GetPreInstalledApex(apex_file.GetManifest().name());
   const auto& preinstalled_path = preinstalled.get().GetPath();
-  if (StartsWith(preinstalled_path, "/vendor/") ||
-      StartsWith(preinstalled_path, "/system/vendor/")) {
+  if (InVendorPartition(preinstalled_path)) {
     return stats::apex::
         APEX_INSTALLATION_REQUESTED__APEX_PREINSTALL_PARTITION__PARTITION_VENDOR;
   }
-  if (StartsWith(preinstalled_path, "/system_ext/")) {
+  if (InOdmPartition(preinstalled_path)) {
+    return stats::apex::
+        APEX_INSTALLATION_REQUESTED__APEX_PREINSTALL_PARTITION__PARTITION_ODM;
+  }
+  if (StartsWith(preinstalled_path, "/system_ext/apex/")) {
     return stats::apex::
         APEX_INSTALLATION_REQUESTED__APEX_PREINSTALL_PARTITION__PARTITION_SYSTEM_EXT;
   }
-  if (StartsWith(preinstalled_path, "/system/")) {
+  if (StartsWith(preinstalled_path, "/system/apex/")) {
     return stats::apex::
         APEX_INSTALLATION_REQUESTED__APEX_PREINSTALL_PARTITION__PARTITION_SYSTEM;
   }
-  if (StartsWith(preinstalled_path, "/product/")) {
+  if (StartsWith(preinstalled_path, "/product/apex/")) {
     return stats::apex::
         APEX_INSTALLATION_REQUESTED__APEX_PREINSTALL_PARTITION__PARTITION_PRODUCT;
   }
diff --git a/apexd/apexd_vendor_apex.h b/apexd/apexd_vendor_apex.h
index 5b0d912c..313a303b 100644
--- a/apexd/apexd_vendor_apex.h
+++ b/apexd/apexd_vendor_apex.h
@@ -28,6 +28,10 @@ using android::base::Result;
 namespace android {
 namespace apex {
 
+bool InVendorPartition(const std::string& path);
+
+bool InOdmPartition(const std::string& path);
+
 // Determines if an incoming apex is a vendor apex
 bool IsVendorApex(const ApexFile& apex_file);
 
diff --git a/apexd/apexd_verity.cpp b/apexd/apexd_verity.cpp
index 4106fa91..d0c4b2d5 100644
--- a/apexd/apexd_verity.cpp
+++ b/apexd/apexd_verity.cpp
@@ -16,191 +16,13 @@
 
 #include "apexd_verity.h"
 
-#include <android-base/file.h>
-#include <android-base/result.h>
-#include <android-base/unique_fd.h>
-#include <verity/hash_tree_builder.h>
-
-#include <filesystem>
 #include <iomanip>
 #include <sstream>
 #include <string>
-#include <vector>
-
-#include "apex_constants.h"
-#include "apex_file.h"
-#include "apexd_utils.h"
-
-using android::base::Dirname;
-using android::base::ErrnoError;
-using android::base::Error;
-using android::base::ReadFully;
-using android::base::Result;
-using android::base::unique_fd;
 
 namespace android {
 namespace apex {
 
-namespace {
-
-uint8_t HexToBin(char h) {
-  if (h >= 'A' && h <= 'H') return h - 'A' + 10;
-  if (h >= 'a' && h <= 'h') return h - 'a' + 10;
-  return h - '0';
-}
-
-std::vector<uint8_t> HexToBin(const std::string& hex) {
-  std::vector<uint8_t> bin;
-  bin.reserve(hex.size() / 2);
-  for (size_t i = 0; i + 1 < hex.size(); i += 2) {
-    uint8_t c = (HexToBin(hex[i]) << 4) + HexToBin(hex[i + 1]);
-    bin.push_back(c);
-  }
-  return bin;
-}
-
-Result<void> GenerateHashTree(const ApexFile& apex,
-                              const ApexVerityData& verity_data,
-                              const std::string& hashtree_file) {
-  unique_fd fd(
-      TEMP_FAILURE_RETRY(open(apex.GetPath().c_str(), O_RDONLY | O_CLOEXEC)));
-  if (fd.get() == -1) {
-    return ErrnoError() << "Failed to open " << apex.GetPath();
-  }
-
-  auto block_size = verity_data.desc->hash_block_size;
-  auto image_size = verity_data.desc->image_size;
-
-  auto hash_fn = HashTreeBuilder::HashFunction(verity_data.hash_algorithm);
-  if (hash_fn == nullptr) {
-    return Error() << "Unsupported hash algorithm "
-                   << verity_data.hash_algorithm;
-  }
-
-  auto builder = std::make_unique<HashTreeBuilder>(block_size, hash_fn);
-  if (!builder->Initialize(image_size, HexToBin(verity_data.salt))) {
-    return Error() << "Invalid image size " << image_size;
-  }
-
-  if (!apex.GetImageOffset()) {
-    return Error() << "Cannot generate HashTree without image offset";
-  }
-  if (lseek(fd, apex.GetImageOffset().value(), SEEK_SET) == -1) {
-    return ErrnoError() << "Failed to seek";
-  }
-
-  auto block_count = image_size / block_size;
-  auto buf = std::vector<uint8_t>(block_size);
-  while (block_count-- > 0) {
-    if (!ReadFully(fd, buf.data(), block_size)) {
-      return Error() << "Failed to read";
-    }
-    if (!builder->Update(buf.data(), block_size)) {
-      return Error() << "Failed to build hashtree: Update";
-    }
-  }
-  if (!builder->BuildHashTree()) {
-    return Error() << "Failed to build hashtree: incomplete data";
-  }
-
-  auto golden_digest = HexToBin(verity_data.root_digest);
-  auto digest = builder->root_hash();
-  // This returns zero-padded digest.
-  // resize() it to compare with golden digest,
-  digest.resize(golden_digest.size());
-  if (digest != golden_digest) {
-    return Error() << "Failed to build hashtree: root digest mismatch";
-  }
-
-  unique_fd out_fd(TEMP_FAILURE_RETRY(open(
-      hashtree_file.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0600)));
-  if (!builder->WriteHashTreeToFd(out_fd, 0)) {
-    return Error() << "Failed to write hashtree to " << hashtree_file;
-  }
-  return {};
-}
-
-Result<std::string> CalculateRootDigest(const std::string& hashtree_file,
-                                        const ApexVerityData& verity_data) {
-  unique_fd fd(
-      TEMP_FAILURE_RETRY(open(hashtree_file.c_str(), O_RDONLY | O_CLOEXEC)));
-  if (fd.get() == -1) {
-    return ErrnoError() << "Failed to open " << hashtree_file;
-  }
-  auto block_size = verity_data.desc->hash_block_size;
-  auto image_size = verity_data.desc->image_size;
-  std::vector<uint8_t> root_verity(block_size);
-  if (!ReadFully(fd.get(), root_verity.data(), block_size)) {
-    return ErrnoError() << "Failed to read " << block_size << " bytes from "
-                        << hashtree_file;
-  }
-  auto hash_fn = HashTreeBuilder::HashFunction(verity_data.hash_algorithm);
-  if (hash_fn == nullptr) {
-    return Error() << "Unsupported hash algorithm "
-                   << verity_data.hash_algorithm;
-  }
-  auto builder = std::make_unique<HashTreeBuilder>(block_size, hash_fn);
-  if (!builder->Initialize(image_size, HexToBin(verity_data.salt))) {
-    return Error() << "Invalid image size " << image_size;
-  }
-  std::vector<unsigned char> root_digest;
-  if (!builder->CalculateRootDigest(root_verity, &root_digest)) {
-    return Error() << "Failed to calculate digest of " << hashtree_file;
-  }
-  auto result = HashTreeBuilder::BytesArrayToString(root_digest);
-  result.resize(verity_data.root_digest.size());
-  return result;
-}
-
-}  // namespace
-
-Result<PrepareHashTreeResult> PrepareHashTree(
-    const ApexFile& apex, const ApexVerityData& verity_data,
-    const std::string& hashtree_file) {
-  if (apex.IsCompressed()) {
-    return Error() << "Cannot prepare HashTree of compressed APEX";
-  }
-
-  if (auto st = CreateDirIfNeeded(Dirname(hashtree_file), 0700); !st.ok()) {
-    return st.error();
-  }
-  bool should_regenerate_hashtree = false;
-  auto exists = PathExists(hashtree_file);
-  if (!exists.ok()) {
-    return exists.error();
-  }
-  if (*exists) {
-    auto digest = CalculateRootDigest(hashtree_file, verity_data);
-    if (!digest.ok()) {
-      return digest.error();
-    }
-    if (*digest != verity_data.root_digest) {
-      LOG(ERROR) << "Regenerating hashtree! Digest of " << hashtree_file
-                 << " does not match digest of " << apex.GetPath() << " : "
-                 << *digest << "\nvs\n"
-                 << verity_data.root_digest;
-      should_regenerate_hashtree = true;
-    }
-  } else {
-    should_regenerate_hashtree = true;
-  }
-
-  if (should_regenerate_hashtree) {
-    if (auto st = GenerateHashTree(apex, verity_data, hashtree_file);
-        !st.ok()) {
-      return st.error();
-    }
-    LOG(INFO) << "hashtree: generated to " << hashtree_file;
-    return KRegenerate;
-  }
-  LOG(INFO) << "hashtree: reuse " << hashtree_file;
-  return kReuse;
-}
-
-void RemoveObsoleteHashTrees() {
-  // TODO(b/120058143): on boot complete, remove unused hashtree files
-}
-
 std::string BytesToHex(const uint8_t* bytes, size_t bytes_len) {
   std::ostringstream s;
 
diff --git a/apexd/apexd_verity.h b/apexd/apexd_verity.h
index deb3ac0f..aeedf5ec 100644
--- a/apexd/apexd_verity.h
+++ b/apexd/apexd_verity.h
@@ -25,19 +25,5 @@ namespace apex {
 
 std::string BytesToHex(const uint8_t* bytes, size_t len);
 
-enum PrepareHashTreeResult {
-  kReuse = 0,
-  KRegenerate = 1,
-};
-
-// Generates a dm-verity hashtree of a given |apex| if |hashtree_file| doesn't
-// exist or it's root_digest doesn't match |verity_data.root_digest|. Otherwise
-// does nothing.
-android::base::Result<PrepareHashTreeResult> PrepareHashTree(
-    const ApexFile& apex, const ApexVerityData& verity_data,
-    const std::string& hashtree_file);
-
-void RemoveObsoleteHashTrees();
-
 }  // namespace apex
 }  // namespace android
diff --git a/apexd/apexd_verity_test.cpp b/apexd/apexd_verity_test.cpp
deleted file mode 100644
index 8838880d..00000000
--- a/apexd/apexd_verity_test.cpp
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "apexd_verity.h"
-
-#include <android-base/file.h>
-#include <android-base/logging.h>
-#include <android-base/result-gmock.h>
-#include <android-base/stringprintf.h>
-#include <errno.h>
-#include <gtest/gtest.h>
-#include <sys/stat.h>
-
-#include <string>
-
-#include "apex_file.h"
-#include "apexd_test_utils.h"
-
-namespace android {
-namespace apex {
-
-using namespace std::literals;
-
-using android::base::GetExecutableDirectory;
-using android::base::ReadFileToString;
-using android::base::StringPrintf;
-using android::base::testing::Ok;
-using ::testing::Not;
-
-static std::string GetTestDataDir() { return GetExecutableDirectory(); }
-static std::string GetTestFile(const std::string& name) {
-  return GetTestDataDir() + "/" + name;
-}
-
-TEST(ApexdVerityTest, ReusesHashtree) {
-  TemporaryDir td;
-
-  auto apex = ApexFile::Open(GetTestFile("apex.apexd_test_no_hashtree.apex"));
-  ASSERT_RESULT_OK(apex);
-  auto verity_data = apex->VerifyApexVerity(apex->GetBundledPublicKey());
-  ASSERT_RESULT_OK(verity_data);
-
-  auto hashtree_file = StringPrintf("%s/hashtree", td.path);
-  auto status = PrepareHashTree(*apex, *verity_data, hashtree_file);
-  ASSERT_RESULT_OK(status);
-  ASSERT_EQ(KRegenerate, *status);
-
-  std::string first_hashtree;
-  ASSERT_TRUE(ReadFileToString(hashtree_file, &first_hashtree))
-      << "Failed to read " << hashtree_file;
-
-  // Now call PrepareHashTree again. Since digest matches, hashtree should be
-  // reused.
-  status = PrepareHashTree(*apex, *verity_data, hashtree_file);
-  ASSERT_RESULT_OK(status);
-  ASSERT_EQ(kReuse, *status);
-
-  std::string second_hashtree;
-  ASSERT_TRUE(ReadFileToString(hashtree_file, &second_hashtree))
-      << "Failed to read " << hashtree_file;
-
-  // Hashtree file shouldn't be modified.
-  ASSERT_EQ(first_hashtree, second_hashtree)
-      << hashtree_file << " was regenerated";
-}
-
-TEST(ApexdVerityTest, RegenerateHashree) {
-  TemporaryDir td;
-
-  auto apex = ApexFile::Open(GetTestFile("apex.apexd_test_no_hashtree.apex"));
-  ASSERT_RESULT_OK(apex);
-  auto verity_data = apex->VerifyApexVerity(apex->GetBundledPublicKey());
-  ASSERT_RESULT_OK(verity_data);
-
-  auto hashtree_file = StringPrintf("%s/hashtree", td.path);
-  auto status = PrepareHashTree(*apex, *verity_data, hashtree_file);
-  ASSERT_RESULT_OK(status);
-  ASSERT_EQ(KRegenerate, *status);
-
-  std::string first_hashtree;
-  ASSERT_TRUE(ReadFileToString(hashtree_file, &first_hashtree))
-      << "Failed to read " << hashtree_file;
-
-  auto apex2 =
-      ApexFile::Open(GetTestFile("apex.apexd_test_no_hashtree_2.apex"));
-  ASSERT_RESULT_OK(apex2);
-  auto verity_data2 = apex2->VerifyApexVerity(apex2->GetBundledPublicKey());
-  ASSERT_RESULT_OK(verity_data2);
-
-  // Now call PrepareHashTree again. Since digest doesn't match, hashtree
-  // should be regenerated.
-  status = PrepareHashTree(*apex2, *verity_data2, hashtree_file);
-  ASSERT_RESULT_OK(status);
-  ASSERT_EQ(KRegenerate, *status);
-
-  std::string second_hashtree;
-  ASSERT_TRUE(ReadFileToString(hashtree_file, &second_hashtree))
-      << "Failed to read " << hashtree_file;
-
-  // Hashtree file should be regenerated.
-  ASSERT_NE(first_hashtree, second_hashtree) << hashtree_file << " was reused";
-}
-
-TEST(ApexdVerityTest, CannotPrepareHashTreeForCompressedApex) {
-  TemporaryDir td;
-
-  auto apex =
-      ApexFile::Open(GetTestFile("com.android.apex.compressed.v1.capex"));
-  ASSERT_RESULT_OK(apex);
-  std::string hash_tree;
-  ApexVerityData verity_data;
-  auto result = PrepareHashTree(*apex, verity_data, hash_tree);
-  ASSERT_THAT(result, Not(Ok()));
-  ASSERT_THAT(
-      result.error().message(),
-      ::testing::HasSubstr("Cannot prepare HashTree of compressed APEX"));
-}
-
-}  // namespace apex
-}  // namespace android
diff --git a/apexd/apexservice.cpp b/apexd/apexservice.cpp
index 4f4e1251..1dd59589 100644
--- a/apexd/apexservice.cpp
+++ b/apexd/apexservice.cpp
@@ -404,7 +404,7 @@ BinderStatus ApexService::getSessions(
     return check;
   }
 
-  auto sessions = ApexSession::GetSessions();
+  auto sessions = GetSessionManager()->GetSessions();
   for (const auto& session : sessions) {
     ApexSessionInfo session_info;
     ConvertToApexSessionInfo(session, &session_info);
@@ -424,7 +424,7 @@ BinderStatus ApexService::getStagedSessionInfo(
     return check;
   }
 
-  auto session = ApexSession::GetSession(session_id);
+  auto session = GetSessionManager()->GetSession(session_id);
   if (!session.ok()) {
     // Unknown session.
     ClearSessionInfo(apex_session_info);
@@ -833,7 +833,7 @@ status_t ApexService::dump(int fd, const Vector<String16>& /*args*/) {
   }
 
   dprintf(fd, "SESSIONS:\n");
-  std::vector<ApexSession> sessions = ApexSession::GetSessions();
+  std::vector<ApexSession> sessions = GetSessionManager()->GetSessions();
 
   for (const auto& session : sessions) {
     std::string child_ids_str = "";
diff --git a/apexd/apexservice_test.cpp b/apexd/apexservice_test.cpp
index d31c4c15..51adef06 100644
--- a/apexd/apexservice_test.cpp
+++ b/apexd/apexservice_test.cpp
@@ -123,10 +123,20 @@ class ApexServiceTest : public ::testing::Test {
     ASSERT_TRUE(IsOk(status));
     CleanUp();
     service_->recollectPreinstalledData(kApexPackageBuiltinDirs);
+
+    session_manager_ = ApexSessionManager::Create(GetSessionsDir());
   }
 
   void TearDown() override { CleanUp(); }
 
+  Result<ApexSession> CreateSession(int session_id) {
+    return session_manager_->CreateSession(session_id);
+  }
+
+  Result<ApexSession> GetSession(int session_id) {
+    return session_manager_->GetSession(session_id);
+  }
+
   static std::string GetTestDataDir() {
     return android::base::GetExecutableDirectory();
   }
@@ -382,12 +392,12 @@ class ApexServiceTest : public ::testing::Test {
   sp<IApexService> service_;
   sp<android::os::IVold> vold_service_;
   bool supports_fs_checkpointing_;
+  std::unique_ptr<ApexSessionManager> session_manager_;
 
  private:
   void CleanUp() {
     DeleteDirContent(kActiveApexPackagesDataDir);
     DeleteDirContent(kApexBackupDir);
-    DeleteDirContent(kApexHashTreeDir);
     DeleteDirContent(GetSessionsDir());
 
     DeleteIfExists("/data/misc_ce/0/apexdata/apex.apexd_test");
@@ -523,7 +533,7 @@ TEST_F(ApexServiceTest, SubmitStagedSessionStoresBuildFingerprint) {
   params.sessionId = 1547;
   ASSERT_TRUE(IsOk(service_->submitStagedSession(params, &list)));
 
-  auto session = ApexSession::GetSession(1547);
+  auto session = GetSession(1547);
   ASSERT_FALSE(session->GetBuildFingerprint().empty());
 }
 
@@ -577,7 +587,7 @@ TEST_F(ApexServiceTest, SessionParamDefaults) {
   params.sessionId = 1547;
   ASSERT_TRUE(IsOk(service_->submitStagedSession(params, &list)));
 
-  auto session = ApexSession::GetSession(1547);
+  auto session = GetSession(1547);
   ASSERT_TRUE(session->GetChildSessionIds().empty());
   ASSERT_FALSE(session->IsRollback());
   ASSERT_FALSE(session->HasRollbackEnabled());
@@ -998,7 +1008,7 @@ TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulFailsNoSession) {
 }
 
 TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulFailsSessionInWrongState) {
-  auto session = ApexSession::CreateSession(73);
+  auto session = CreateSession(73);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(
       session->UpdateStateAndCommit(::apex::proto::SessionState::STAGED));
@@ -1013,7 +1023,7 @@ TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulFailsSessionInWrongState) {
 }
 
 TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulActivatedSession) {
-  auto session = ApexSession::CreateSession(239);
+  auto session = CreateSession(239);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(
       session->UpdateStateAndCommit(::apex::proto::SessionState::ACTIVATED));
@@ -1028,7 +1038,7 @@ TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulActivatedSession) {
 }
 
 TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulNoOp) {
-  auto session = ApexSession::CreateSession(1543);
+  auto session = CreateSession(1543);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(
       session->UpdateStateAndCommit(::apex::proto::SessionState::SUCCESS));
@@ -1044,9 +1054,9 @@ TEST_F(ApexServiceTest, MarkStagedSessionSuccessfulNoOp) {
 
 // Should be able to abort individual staged session
 TEST_F(ApexServiceTest, AbortStagedSession) {
-  auto session1 = ApexSession::CreateSession(239);
+  auto session1 = CreateSession(239);
   ASSERT_RESULT_OK(session1->UpdateStateAndCommit(SessionState::VERIFIED));
-  auto session2 = ApexSession::CreateSession(240);
+  auto session2 = CreateSession(240);
   ASSERT_RESULT_OK(session2->UpdateStateAndCommit(SessionState::STAGED));
 
   std::vector<ApexSessionInfo> sessions;
@@ -1064,9 +1074,9 @@ TEST_F(ApexServiceTest, AbortStagedSession) {
 
 // abortStagedSession should not abort activated session
 TEST_F(ApexServiceTest, AbortStagedSessionActivatedFail) {
-  auto session1 = ApexSession::CreateSession(239);
+  auto session1 = CreateSession(239);
   ASSERT_RESULT_OK(session1->UpdateStateAndCommit(SessionState::ACTIVATED));
-  auto session2 = ApexSession::CreateSession(240);
+  auto session2 = CreateSession(240);
   ASSERT_RESULT_OK(session2->UpdateStateAndCommit(SessionState::STAGED));
 
   std::vector<ApexSessionInfo> sessions;
@@ -1100,19 +1110,19 @@ TEST_F(ApexServiceTest, DeleteFinalizedSessions) {
   // delete sessions in final state.
   auto nonFinalSessions = 0u;
   for (auto i = 0u; i < states.size(); i++) {
-    auto session = ApexSession::CreateSession(230 + i);
+    auto session = CreateSession(230 + i);
     SessionState::State state = states[i];
     ASSERT_RESULT_OK(session->UpdateStateAndCommit(state));
     if (!session->IsFinalized()) {
       nonFinalSessions++;
     }
   }
-  std::vector<ApexSession> sessions = ApexSession::GetSessions();
+  std::vector<ApexSession> sessions = session_manager_->GetSessions();
   ASSERT_EQ(states.size(), sessions.size());
 
   // Now try cleaning up all finalized sessions
-  ApexSession::DeleteFinalizedSessions();
-  sessions = ApexSession::GetSessions();
+  session_manager_->DeleteFinalizedSessions();
+  sessions = session_manager_->GetSessions();
   ASSERT_EQ(nonFinalSessions, sessions.size());
 
   // Verify only finalized sessions have been deleted
@@ -1304,7 +1314,7 @@ TEST_F(ApexServiceRevertTest, RevertActiveSessionsSuccessful) {
     return;
   }
 
-  auto session = ApexSession::CreateSession(1543);
+  auto session = CreateSession(1543);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(session->UpdateStateAndCommit(SessionState::ACTIVATED));
 
@@ -1334,7 +1344,7 @@ TEST_F(ApexServiceRevertTest,
     return;
   }
 
-  auto session = ApexSession::CreateSession(1543);
+  auto session = CreateSession(1543);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(session->UpdateStateAndCommit(SessionState::ACTIVATED));
 
@@ -1384,7 +1394,7 @@ TEST_F(ApexServiceRevertTest, MarkStagedSessionSuccessfulCleanupBackup) {
   PrepareBackup({GetTestFile("apex.apexd_test.apex"),
                  GetTestFile("apex.apexd_test_different_app.apex")});
 
-  auto session = ApexSession::CreateSession(101);
+  auto session = CreateSession(101);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(session->UpdateStateAndCommit(SessionState::ACTIVATED));
 
@@ -1408,7 +1418,7 @@ TEST_F(ApexServiceRevertTest, ResumesRevert) {
   // Make sure /data/apex/active is non-empty.
   ASSERT_TRUE(IsOk(service_->stagePackages({installer.test_file})));
 
-  auto session = ApexSession::CreateSession(17239);
+  auto session = CreateSession(17239);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(
       session->UpdateStateAndCommit(SessionState::REVERT_IN_PROGRESS));
@@ -1441,7 +1451,7 @@ TEST_F(ApexServiceRevertTest, DoesNotResumeRevert) {
   // Make sure /data/apex/active is non-empty.
   ASSERT_TRUE(IsOk(service_->stagePackages({installer.test_file})));
 
-  auto session = ApexSession::CreateSession(53);
+  auto session = CreateSession(53);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(session->UpdateStateAndCommit(SessionState::SUCCESS));
 
@@ -1466,7 +1476,7 @@ TEST_F(ApexServiceRevertTest, SessionsMarkedAsRevertFailed) {
     GTEST_SKIP() << "Can't run if filesystem checkpointing is enabled";
   }
 
-  auto session = ApexSession::CreateSession(53);
+  auto session = CreateSession(53);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(session->UpdateStateAndCommit(SessionState::ACTIVATED));
 
@@ -1483,7 +1493,7 @@ TEST_F(ApexServiceRevertTest, RevertFailedStateRevertAttemptFails) {
     GTEST_SKIP() << "Can't run if filesystem checkpointing is enabled";
   }
 
-  auto session = ApexSession::CreateSession(17239);
+  auto session = CreateSession(17239);
   ASSERT_RESULT_OK(session);
   ASSERT_RESULT_OK(session->UpdateStateAndCommit(SessionState::REVERT_FAILED));
 
@@ -1554,7 +1564,7 @@ TEST_F(ApexServiceTest, ApexdIsInSameMountNamespaceAsInit) {
 }
 
 // These are NOT exhaustive list of early processes be should be enough
-static const std::vector<const std::string> kEarlyProcesses = {
+static const std::vector<std::string> kEarlyProcesses = {
     "vold",
     "logd",
 };
@@ -1599,7 +1609,7 @@ TEST(ApexdTest, ApexIsAPrivateMountPoint) {
   ASSERT_TRUE(found_apex_mountpoint);
 }
 
-static const std::vector<const std::string> kEarlyApexes = {
+static const std::vector<std::string> kEarlyApexes = {
     "/apex/com.android.runtime",
     "/apex/com.android.tzdata",
 };
@@ -1780,25 +1790,6 @@ TEST_F(ApexServiceTest, StageCorruptApexFailsB146895998) {
   ASSERT_FALSE(IsOk(service_->stagePackages({installer.test_file})));
 }
 
-TEST_F(ApexServiceTest,
-       SubmitStagedSessionFailsManifestMismatchCleansUpHashtree) {
-  PrepareTestApexForInstall installer(
-      GetTestFile("apex.apexd_test_no_hashtree_manifest_mismatch.apex"),
-      "/data/app-staging/session_83", "staging_data_file");
-  if (!installer.Prepare()) {
-    return;
-  }
-
-  ApexInfoList list;
-  ApexSessionParams params;
-  params.sessionId = 83;
-  ASSERT_FALSE(IsOk(service_->submitStagedSession(params, &list)));
-  std::string hashtree_file = std::string(kApexHashTreeDir) + "/" +
-                              installer.package + "@" +
-                              std::to_string(installer.version) + ".new";
-  ASSERT_FALSE(RegularFileExists(hashtree_file));
-}
-
 class LogTestToLogcat : public ::testing::EmptyTestEventListener {
   void OnTestStart(const ::testing::TestInfo& test_info) override {
 #ifdef __ANDROID__
diff --git a/apexd/sysprop/ApexProperties.sysprop b/apexd/sysprop/ApexProperties.sysprop
index 9f92a336..7e204023 100644
--- a/apexd/sysprop/ApexProperties.sysprop
+++ b/apexd/sysprop/ApexProperties.sysprop
@@ -58,3 +58,11 @@ prop {
     access: Readonly
     prop_name: "apexd.config.boot_activation.threads"
 }
+
+prop {
+    api_name: "loopback_readahead"
+    type: UInt
+    scope: Internal
+    access: Readonly
+    prop_name: "apexd.config.loopback.readahead"
+}
diff --git a/apexer/apexer.py b/apexer/apexer.py
index 7ee620f1..88541545 100644
--- a/apexer/apexer.py
+++ b/apexer/apexer.py
@@ -346,14 +346,13 @@ def ValidateArgs(args):
       return False
 
   if not args.canned_fs_config:
-    if not args.canned_fs_config:
-      if build_info is not None:
-        with tempfile.NamedTemporaryFile(delete=False) as temp:
-          temp.write(build_info.canned_fs_config)
-          args.canned_fs_config = temp.name
-      else:
-        print('Missing ----canned_fs_config {config} argument, or a --build_info argument!')
-        return False
+    if build_info is not None:
+      with tempfile.NamedTemporaryFile(delete=False) as temp:
+        temp.write(build_info.canned_fs_config)
+        args.canned_fs_config = temp.name
+    else:
+      print('Missing --canned_fs_config {config} argument, or a --build_info argument!')
+      return False
 
   if not args.target_sdk_version:
     if build_info is not None:
diff --git a/apexer/apexer_test.py b/apexer/apexer_test.py
index fb355d9a..48d4a957 100644
--- a/apexer/apexer_test.py
+++ b/apexer/apexer_test.py
@@ -307,10 +307,10 @@ class ApexerRebuildTest(unittest.TestCase):
 
     def _get_java_toolchain(self):
         java_toolchain = "java"
-        if os.path.isfile("prebuilts/jdk/jdk17/linux-x86/bin/java"):
-            java_toolchain = "prebuilts/jdk/jdk17/linux-x86/bin/java"
-        elif os.path.isfile("/jdk/jdk17/linux-x86/bin/java"):
-            java_toolchain = "/jdk/jdk17/linux-x86/bin/java"
+        if os.path.isfile("prebuilts/jdk/jdk21/linux-x86/bin/java"):
+            java_toolchain = "prebuilts/jdk/jdk21/linux-x86/bin/java"
+        elif os.path.isfile("/jdk/jdk21/linux-x86/bin/java"):
+            java_toolchain = "/jdk/jdk21/linux-x86/bin/java"
         elif "ANDROID_JAVA_TOOLCHAIN" in os.environ:
             java_toolchain = os.path.join(os.environ["ANDROID_JAVA_TOOLCHAIN"], "java")
         elif "ANDROID_JAVA_HOME" in os.environ:
@@ -364,7 +364,6 @@ class ApexerRebuildTest(unittest.TestCase):
         salt = hashlib.sha256(manifest_apex.SerializeToString()).hexdigest()
         cmd.extend(['--salt', salt])
         cmd.extend(['--image', signed_payload])
-        cmd.append('--no_hashtree')
         run_and_check_output(cmd)
 
         return signed_payload
diff --git a/apexer/testdata/Android.bp b/apexer/testdata/Android.bp
index 42fed721..a5ce4efc 100644
--- a/apexer/testdata/Android.bp
+++ b/apexer/testdata/Android.bp
@@ -38,7 +38,6 @@ apex {
     certificate: ":com.android.example.apex.certificate",
     installable: false,
     updatable: false,
-    generate_hashtree: false,
 }
 
 apex {
@@ -50,7 +49,6 @@ apex {
     certificate: ":com.android.example.apex.certificate",
     min_sdk_version: "29",
     installable: false,
-    generate_hashtree: false,
 }
 
 apex {
diff --git a/libs/libapexsupport/include/android/apexsupport.h b/libs/libapexsupport/include/android/apexsupport.h
index 3be311e0..63dd86b4 100644
--- a/libs/libapexsupport/include/android/apexsupport.h
+++ b/libs/libapexsupport/include/android/apexsupport.h
@@ -14,7 +14,6 @@
 
 #pragma once
 
-#include <android/llndk-versioning.h>
 #include <stdint.h>
 #include <sys/cdefs.h>
 
@@ -58,15 +57,14 @@ typedef enum AApexInfoError : int32_t {
  * \returns AApexInfoError
  */
 __attribute__((warn_unused_result)) AApexInfoError
-AApexInfo_create(AApexInfo *_Nullable *_Nonnull info)
-    __INTRODUCED_IN_LLNDK(202404);
+AApexInfo_create(AApexInfo *_Nullable *_Nonnull info);
 
 /**
  * Destroys an AApexInfo object created by AApexInfo_create().
  *
  * \param info pointer to the AApexInfo object created by AApexInfo_create()
  */
-void AApexInfo_destroy(AApexInfo *_Nonnull info) __INTRODUCED_IN_LLNDK(202404);
+void AApexInfo_destroy(AApexInfo *_Nonnull info);
 
 /**
  * Returns a C-string for the APEX name.
@@ -80,8 +78,7 @@ void AApexInfo_destroy(AApexInfo *_Nonnull info) __INTRODUCED_IN_LLNDK(202404);
  * \return the APEX name.
  */
 __attribute__((warn_unused_result))
-const char *_Nonnull AApexInfo_getName(const AApexInfo *_Nonnull info)
-    __INTRODUCED_IN_LLNDK(202404);
+const char *_Nonnull AApexInfo_getName(const AApexInfo *_Nonnull info);
 
 /**
  * Returns the APEX version.
@@ -90,8 +87,7 @@ const char *_Nonnull AApexInfo_getName(const AApexInfo *_Nonnull info)
  *
  * \return the APEX version.
  */
-int64_t AApexInfo_getVersion(const AApexInfo *_Nonnull info)
-    __INTRODUCED_IN_LLNDK(202404);
+int64_t AApexInfo_getVersion(const AApexInfo *_Nonnull info);
 
 // AApexSupport_loadLibrary is private to platform yet.
 #if !defined(__ANDROID_VENDOR__) && !defined(__ANDROID_PRODUCT__)
diff --git a/libs/libapexsupport/tests/Android.bp b/libs/libapexsupport/tests/Android.bp
index 30bdec4c..1e53a7b0 100644
--- a/libs/libapexsupport/tests/Android.bp
+++ b/libs/libapexsupport/tests/Android.bp
@@ -2,7 +2,7 @@ package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
-apex {
+apex_test {
     name: "com.android.libapexsupport.tests",
     vendor: true,
     installable: false,
diff --git a/shim/build/Android.bp b/shim/build/Android.bp
index 24687c6c..36d12fd7 100644
--- a/shim/build/Android.bp
+++ b/shim/build/Android.bp
@@ -130,23 +130,6 @@ apex {
     updatable: false,
 }
 
-apex {
-    name: "com.android.apex.cts.shim.v2_no_hashtree",
-    manifest: "manifest_v2.json",
-    androidManifest: "AndroidManifest.xml",
-    file_contexts: ":apex.test-file_contexts",
-    key: "com.android.apex.cts.shim.key",
-    prebuilts: ["hash_of_dev_null"],
-    apps: [
-        "CtsShim",
-        "CtsShimPriv",
-    ],
-    installable: false,
-    allowed_files: "default_shim_allowed_list.txt",
-    generate_hashtree: false,
-    updatable: false,
-}
-
 apex {
     name: "com.android.apex.cts.shim.v2_unsigned_payload",
     // Use manifest_v2_rebootless to also re-use this APEX in the rebootless update test case.
@@ -276,7 +259,6 @@ genrule {
         ":com.android.apex.cts.shim.v2_additional_folder",
         ":com.android.apex.cts.shim.v2_different_certificate",
         ":com.android.apex.cts.shim.v2_different_package_name",
-        ":com.android.apex.cts.shim.v2_no_hashtree",
         ":com.android.apex.cts.shim.v2_signed_bob",
         ":com.android.apex.cts.shim.v2_signed_bob_rot",
         ":com.android.apex.cts.shim.v2_signed_bob_rot_rollback",
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v1.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v1.apex
index 1984240f..5a5afe72 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v1.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v1.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2.apex
index 637abc0e..f158d897 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_add_apk_to_apex.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_add_apk_to_apex.apex
new file mode 100644
index 00000000..96524516
Binary files /dev/null and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_add_apk_to_apex.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_file.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_file.apex
index ea9dbbda..382f1574 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_file.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_file.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_folder.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_folder.apex
index efac704f..e7757330 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_folder.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_additional_folder.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_sdk_target_p.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_sdk_target_p.apex
index ade5ad1b..77a66981 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_sdk_target_p.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_sdk_target_p.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_upgrades.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_upgrades.apex
index 08785cab..4276e15a 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_upgrades.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_apk_in_apex_upgrades.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_certificate.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_certificate.apex
index 4c109f04..823deab4 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_certificate.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_certificate.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_package_name.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_package_name.apex
index 45f60a52..2babcc8f 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_package_name.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_different_package_name.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_empty.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_empty.apex
index 6cd415bc..171aeeea 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_empty.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_empty.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_invalid_fingerprint.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_invalid_fingerprint.apex
index 430e8c6b..7d31f7f2 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_invalid_fingerprint.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_invalid_fingerprint.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_no_value.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_no_value.apex
index 0e267973..3be126a0 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_no_value.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_install_constraints_no_value.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_no_hashtree.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_no_hashtree.apex
index ef6212fe..50747725 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_no_hashtree.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_no_hashtree.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_rebootless.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_rebootless.apex
index eb8292a7..c3373367 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_rebootless.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_rebootless.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sdk_target_p.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sdk_target_p.apex
index c2a48dc5..ab870135 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sdk_target_p.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sdk_target_p.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sign_payload_with_different_key.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sign_payload_with_different_key.apex
index 46d091f8..2a6c6d76 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sign_payload_with_different_key.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_sign_payload_with_different_key.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob.apex
index e7072f29..476ba2e4 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot.apex
index 328727c3..4a7fd588 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex
index cfef97d2..64ac6400 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_apk_container.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_apk_container.apex
index 39fcd46d..adfd7a35 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_apk_container.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_apk_container.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_payload.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_payload.apex
index 2c2f2415..f0c98d39 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_payload.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_unsigned_payload.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_post_install_hook.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_post_install_hook.apex
index d8854ae8..c94ec614 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_post_install_hook.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_post_install_hook.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_pre_install_hook.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_pre_install_hook.apex
index 0d3e0370..9a7ff62e 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_pre_install_hook.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_with_pre_install_hook.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_without_apk_in_apex.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_without_apk_in_apex.apex
index e71c663e..e230ca20 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_without_apk_in_apex.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_without_apk_in_apex.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_wrong_sha.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_wrong_sha.apex
index 450c7430..e6ee493e 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_wrong_sha.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v2_wrong_sha.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3.apex
index 47d022fb..ec0758fb 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_rebootless.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_rebootless.apex
index ec352734..2a513db7 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_rebootless.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_rebootless.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob.apex
index 784b55ca..00c2fb06 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob_rot.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob_rot.apex
index 6dde66fa..9c22d92f 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob_rot.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim.v3_signed_bob_rot.apex differ
diff --git a/shim/prebuilts/riscv64/com.android.apex.cts.shim_not_pre_installed.apex b/shim/prebuilts/riscv64/com.android.apex.cts.shim_not_pre_installed.apex
index 0c76bca9..73ee2ecd 100644
Binary files a/shim/prebuilts/riscv64/com.android.apex.cts.shim_not_pre_installed.apex and b/shim/prebuilts/riscv64/com.android.apex.cts.shim_not_pre_installed.apex differ
diff --git a/tests/Android.bp b/tests/Android.bp
index 932a8bdf..46d7cb03 100644
--- a/tests/Android.bp
+++ b/tests/Android.bp
@@ -194,6 +194,7 @@ java_test_host {
         "hamcrest-library",
     ],
     static_libs: [
+        "cts-host-utils",
         "cts-install-lib-host",
         "frameworks-base-hostutils",
         "testng",
diff --git a/tests/app/src/com/android/tests/apex/app/VendorApexTests.java b/tests/app/src/com/android/tests/apex/app/VendorApexTests.java
index 1739bad4..3cd53cf8 100644
--- a/tests/app/src/com/android/tests/apex/app/VendorApexTests.java
+++ b/tests/app/src/com/android/tests/apex/app/VendorApexTests.java
@@ -24,6 +24,7 @@ import static org.junit.Assert.fail;
 import android.Manifest;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.os.Bundle;
 import android.os.SystemProperties;
 
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -64,12 +65,17 @@ public class VendorApexTests {
             "com.android.apex.vendor.foo.v2_with_wrong_vndk_version", APEX_PACKAGE_NAME, 2,
             /*isApex*/true, "com.android.apex.vendor.foo.v2_with_wrong_vndk_version.apex");
 
+    /* parameter passed from host-side VendorApexTests: [vendor, odm] */
+    private String mPartition;
+
     @Before
     public void setUp() {
         InstallUtils.dropShellPermissionIdentity();
         InstallUtils.adoptShellPermissionIdentity(
                 Manifest.permission.INSTALL_PACKAGE_UPDATES,
                 Manifest.permission.INSTALL_TEST_ONLY_PACKAGE);
+        Bundle bundle = InstrumentationRegistry.getArguments();
+        mPartition = bundle.getString("partition");
     }
 
     @Test
@@ -79,7 +85,7 @@ public class VendorApexTests {
         {
             PackageInfo apex = pm.getPackageInfo(APEX_PACKAGE_NAME, PackageManager.MATCH_APEX);
             assertThat(apex.getLongVersionCode()).isEqualTo(1);
-            assertThat(apex.applicationInfo.sourceDir).startsWith("/vendor/apex");
+            assertThat(apex.applicationInfo.sourceDir).startsWith("/" + mPartition + "/apex");
         }
 
         Install.single(Apex2Rebootless).commit();
diff --git a/tests/src/com/android/tests/apex/host/VendorApexTests.java b/tests/src/com/android/tests/apex/host/VendorApexTests.java
index a70c56c7..508230e8 100644
--- a/tests/src/com/android/tests/apex/host/VendorApexTests.java
+++ b/tests/src/com/android/tests/apex/host/VendorApexTests.java
@@ -21,14 +21,18 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 
+import static java.util.stream.Collectors.toList;
+
+import android.cts.host.utils.DeviceJUnit4ClassRunnerWithParameters;
+import android.cts.host.utils.DeviceJUnit4Parameterized;
 import android.cts.install.lib.host.InstallUtilsHost;
 import android.platform.test.annotations.LargeTest;
 
 import com.android.apex.ApexInfo;
 import com.android.apex.XmlParser;
 import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
-import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
 import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
+import com.android.tradefed.testtype.junit4.DeviceTestRunOptions;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 
@@ -36,15 +40,20 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-
-import static java.util.stream.Collectors.toList;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.UseParametersRunnerFactory;
 
 import java.io.File;
 import java.io.FileInputStream;
+import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.List;
 
-@RunWith(DeviceJUnit4ClassRunner.class)
+@RunWith(DeviceJUnit4Parameterized.class)
+@UseParametersRunnerFactory(DeviceJUnit4ClassRunnerWithParameters.RunnerFactory.class)
 public class VendorApexTests extends BaseHostJUnit4Test {
 
     private static final String TAG = "VendorApexTests";
@@ -52,10 +61,20 @@ public class VendorApexTests extends BaseHostJUnit4Test {
 
     private final InstallUtilsHost mHostUtils = new InstallUtilsHost(this);
 
+    @Parameter()
+    public String mPartition;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static Collection<Object[]> data() {
+        return Arrays.asList(new Object[][]{{"vendor"}, {"odm"}});
+    }
+
     private void runPhase(String phase) throws Exception {
-        assertThat(runDeviceTests("com.android.tests.vendorapex.app",
-                "com.android.tests.apex.app.VendorApexTests",
-                phase)).isTrue();
+        var options = new DeviceTestRunOptions("com.android.tests.vendorapex.app")
+                              .setTestClassName("com.android.tests.apex.app.VendorApexTests")
+                              .setTestMethodName(phase)
+                              .addInstrumentationArg("partition", mPartition);
+        assertThat(runDeviceTests(options)).isTrue();
     }
 
     @Before
@@ -73,7 +92,7 @@ public class VendorApexTests extends BaseHostJUnit4Test {
 
     @After
     public void tearDown() throws Exception {
-        deleteFiles("/vendor/apex/" + APEX_PACKAGE_NAME + "*apex",
+        deleteFiles("/" + mPartition + "/apex/" + APEX_PACKAGE_NAME + "*apex",
                 "/data/apex/active/" + APEX_PACKAGE_NAME + "*apex");
     }
 
@@ -149,7 +168,8 @@ public class VendorApexTests extends BaseHostJUnit4Test {
     private void pushPreinstalledApex(String fileName) throws Exception {
         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
         final File apex = buildHelper.getTestFile(fileName);
-        assertTrue(getDevice().pushFile(apex, Paths.get("/vendor/apex", fileName).toString()));
+        Path path = Paths.get("/", mPartition, "apex", fileName);
+        assertTrue(getDevice().pushFile(apex, path.toString()));
         getDevice().reboot();
     }
 
diff --git a/tests/testdata/sharedlibs/build/shared_libs_repack.py b/tests/testdata/sharedlibs/build/shared_libs_repack.py
index 6878dd53..f5f78286 100644
--- a/tests/testdata/sharedlibs/build/shared_libs_repack.py
+++ b/tests/testdata/sharedlibs/build/shared_libs_repack.py
@@ -200,8 +200,8 @@ def run_apexer(container_files, payload_dir, key_path, pubkey_path, tmpdir):
 
 def _get_java_toolchain():
   java_toolchain = 'java'
-  if os.path.isfile('prebuilts/jdk/jdk17/linux-x86/bin/java'):
-    java_toolchain = 'prebuilts/jdk/jdk17/linux-x86/bin/java'
+  if os.path.isfile('prebuilts/jdk/jdk21/linux-x86/bin/java'):
+    java_toolchain = 'prebuilts/jdk/jdk21/linux-x86/bin/java'
 
   java_dep_lib = (
       os.path.join(os.path.dirname(_get_host_tools_path()), 'lib64') + ':' +
diff --git a/tests/testdata/vendorapex/Android.bp b/tests/testdata/vendorapex/Android.bp
index 4dc2f6d2..6ac7bff4 100644
--- a/tests/testdata/vendorapex/Android.bp
+++ b/tests/testdata/vendorapex/Android.bp
@@ -185,7 +185,6 @@ apex_test {
     key: "com.android.hardware.key",
     certificate: ":com.android.hardware.certificate",
     file_contexts: "wifi_file_contexts",
-    use_vndk_as_stable: true,
     updatable: false,
     soc_specific: true,
     installable: false,
@@ -210,7 +209,6 @@ apex_test {
     key: "com.android.hardware.key",
     certificate: ":com.android.hardware.certificate",
     file_contexts: "wifi_file_contexts",
-    use_vndk_as_stable: true,
     updatable: false,
     soc_specific: true,
     installable: false,
@@ -236,7 +234,6 @@ apex_test {
     key: "com.android.hardware.key",
     certificate: ":com.android.hardware.certificate",
     file_contexts: "wifi_file_contexts",
-    use_vndk_as_stable: true,
     updatable: false,
     soc_specific: true,
     installable: false,
@@ -261,7 +258,6 @@ apex_test {
     key: "com.android.hardware.key",
     certificate: ":com.android.hardware.certificate",
     file_contexts: "wifi_file_contexts",
-    use_vndk_as_stable: true,
     updatable: false,
     soc_specific: true,
     installable: false,
diff --git a/tools/Android.bp b/tools/Android.bp
index a7ff261d..7acf7ebf 100644
--- a/tools/Android.bp
+++ b/tools/Android.bp
@@ -109,7 +109,6 @@ cc_binary_host {
         "libapex-deps",
     ],
     shared_libs: [
-        "libhidl-gen-utils",
         "libprocessgroup",
     ],
     static_libs: [
@@ -129,6 +128,7 @@ sh_test_host {
     data_bins: [
         "deapexer",
         "debugfs_static",
+        "fsck.erofs",
         "host_apex_verifier",
     ],
     data_libs: [
@@ -138,8 +138,11 @@ sh_test_host {
         "libcrypto",
         "libcutils",
         "liblog",
+        "libpcre2", // used by libselinux
         "libprocessgroup",
-        "libprotobuf-cpp-full",
+        "libprotobuf-cpp-full", // used by libapex
+        "libprotobuf-cpp-lite", // used by libinit_host
+        "libselinux", // used by libapex
         "libz",
         "libziparchive",
     ],
diff --git a/tools/TEST_MAPPING b/tools/TEST_MAPPING
new file mode 100644
index 00000000..a840033a
--- /dev/null
+++ b/tools/TEST_MAPPING
@@ -0,0 +1,7 @@
+{
+  "postsubmit": [
+    {
+      "name": "host-apex-verifier"
+    }
+  ]
+}
diff --git a/tools/apexd_host.py b/tools/apexd_host.py
index 80c959fd..0e163c33 100644
--- a/tools/apexd_host.py
+++ b/tools/apexd_host.py
@@ -42,7 +42,7 @@ import apex_manifest
 
 # This should be in sync with kApexPackageBuiltinDirs in
 # system/apex/apexd/apex_constants.h
-PARTITIONS = ['system', 'system_ext', 'product', 'vendor']
+PARTITIONS = ['system', 'system_ext', 'product', 'vendor', 'odm']
 
 
 def DirectoryType(path):
diff --git a/tools/create_apex_skeleton.sh b/tools/create_apex_skeleton.sh
index 2a9e8e7b..b7b672a9 100755
--- a/tools/create_apex_skeleton.sh
+++ b/tools/create_apex_skeleton.sh
@@ -11,12 +11,15 @@ usage() {
   echo "       Whether this is a vendor APEX"
   echo "  -k existing_apex_keyname"
   echo "       Use existing key instead of creating a new key"
+  echo "  -m"
+  echo "       Whether this is a Mainline module"
   exit -1
 }
 
 is_vendor=0
+mainline_module=0
 
-while getopts "vk:" opt; do
+while getopts "vmk:" opt; do
   case $opt in
     v)
       is_vendor=1
@@ -24,6 +27,9 @@ while getopts "vk:" opt; do
     k)
       APEX_KEY=${OPTARG}
       ;;
+    m)
+      mainline_module=1
+      ;;
     *)
       usage
   esac
@@ -38,8 +44,12 @@ then
 fi
 
 YEAR=$(date +%Y)
+
+# For Mainline module, add the apex at the root apex/ directory.
+if ((mainline_module == 0)); then
 mkdir -p ${APEX_NAME}
 cd ${APEX_NAME}
+fi
 
 cat > Android.bp <<EOF
 // Copyright (C) ${YEAR} The Android Open Source Project
@@ -108,6 +118,20 @@ fi
 
 if ((is_vendor == 0)); then
 
+if ((mainline_module == 1)); then
+
+cat >> Android.bp <<EOF
+apex {
+    name: "${APEX_NAME}",
+    manifest: "manifest.json",
+    file_contexts: ":${APEX_NAME}-file_contexts",
+    key: "${APEX_KEY}.key",
+    certificate: ":${APEX_KEY}.certificate",
+}
+EOF
+
+else
+
 cat >> Android.bp <<EOF
 apex {
     name: "${APEX_NAME}",
@@ -119,6 +143,8 @@ apex {
 }
 EOF
 
+fi
+
 cat > manifest.json << EOF
 {
     "name": "${APEX_NAME}",
diff --git a/tools/deapexer.py b/tools/deapexer.py
index 6821465a..e547ad90 100755
--- a/tools/deapexer.py
+++ b/tools/deapexer.py
@@ -355,6 +355,10 @@ def RunDecompress(args):
       args.input: file path to compressed APEX
       args.output: file path to where decompressed APEX will be placed
   """
+  if GetType(args.input) == ApexType.UNCOMPRESSED and args.copy_if_uncompressed:
+    shutil.copyfile(args.input, args.output)
+    return
+
   compressed_apex_fp = args.input
   decompressed_apex_fp = args.output
   return decompress(compressed_apex_fp, decompressed_apex_fp)
@@ -422,8 +426,10 @@ def main(argv):
                                  help='path to compressed APEX file that '
                                       'will be decompressed')
   parser_decompress.add_argument('--output', type=str, required=True,
-                                 help='output directory path where '
-                                      'decompressed APEX will be extracted')
+                                 help='path to the output APEX file')
+  parser_decompress.add_argument('--copy-if-uncompressed',
+                                 help='just copy the input if not compressed',
+                                 action='store_true')
   parser_decompress.set_defaults(func=RunDecompress)
 
   args = parser.parse_args(argv)
diff --git a/tools/host-apex-verifier.sh b/tools/host-apex-verifier.sh
index 1114aaa6..125c9b73 100755
--- a/tools/host-apex-verifier.sh
+++ b/tools/host-apex-verifier.sh
@@ -17,9 +17,11 @@ TEST_DIR=$(dirname $0)
 HOST_APEX_VERIFIER=$TEST_DIR/host_apex_verifier
 DEBUGFS=$TEST_DIR/debugfs_static
 DEAPEXER=$TEST_DIR/deapexer
+FSCKEROFS=$TEST_DIR/fsck.erofs
 $HOST_APEX_VERIFIER \
   --deapexer $DEAPEXER \
   --debugfs $DEBUGFS \
+  --fsckerofs $FSCKEROFS \
   --sdk_version $SDK_VERSION \
   --out_system $TEMP_DIR/system \
   --out_system_ext $TEMP_DIR/system_ext \
diff --git a/tools/host_apex_verifier.cc b/tools/host_apex_verifier.cc
index 0b484fc1..2cd670c9 100644
--- a/tools/host_apex_verifier.cc
+++ b/tools/host_apex_verifier.cc
@@ -23,7 +23,6 @@
 #include <android-base/result.h>
 #include <android-base/strings.h>
 #include <apex_file.h>
-#include <check_builtins.h>
 #include <getopt.h>
 #include <parser.h>
 #include <pwd.h>
@@ -85,8 +84,8 @@ void CheckInitRc(const std::string& apex_dir, const ApexManifest& manifest,
                  int sdk_version) {
   init::Parser parser;
   init::ServiceList service_list = init::ServiceList();
-  parser.AddSectionParser("service", std::make_unique<init::ServiceParser>(
-                                         &service_list, nullptr, std::nullopt));
+  parser.AddSectionParser(
+      "service", std::make_unique<init::ServiceParser>(&service_list, nullptr));
   const init::BuiltinFunctionMap& function_map = init::GetBuiltinFunctionMap();
   init::Action::set_function_map(&function_map);
   init::ActionManager action_manager = init::ActionManager();
@@ -277,8 +276,6 @@ int main(int argc, char** argv) {
     return EXIT_FAILURE;
   }
 
-  init::InitializeHostPropertyInfoArea({});
-
   if (!partition_map.empty()) {
     for (const auto& p : partition_map) {
       ScanPartitionApexes(deapexer, sdk_version, p.second);
```

