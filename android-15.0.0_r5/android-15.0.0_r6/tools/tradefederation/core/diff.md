```diff
diff --git a/.classpath b/.classpath
index 086252415..5a5fe22a1 100644
--- a/.classpath
+++ b/.classpath
@@ -58,5 +58,10 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-dynamic-sharding-grpc/linux_glibc_common/javac/tradefed-dynamic-sharding-grpc.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/misc/common/tools-common/tools-common-prebuilt/linux_glibc_common/combined/tools-common-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/misc/common/json/json-prebuilt/linux_glibc_common/combined/json-prebuilt.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/bazelbuild-remote-apis/build/bazel/remote/execution/v2/remote-execution-java-grpc/linux_glibc_common/javac/remote-execution-java-grpc.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/bazelbuild-remote-apis/build/bazel/remote/execution/v2/remote-execution-java-proto/linux_glibc_common/combined/remote-execution-java-proto.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/auto/value/auto_value_annotations/linux_glibc_common/javac/auto_value_annotations.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/googleapis/google/bytestream/bytestream-java-grpc/linux_glibc_common/javac/bytestream-java-grpc.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/googleapis/google/bytestream/bytestream-java-proto/linux_glibc_common/combined/bytestream-java-proto.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/Android.bp b/Android.bp
index 96b03b633..7cab1f7e5 100644
--- a/Android.bp
+++ b/Android.bp
@@ -27,6 +27,7 @@ java_library_host {
         "//tools/tradefederation/core/test_result_interfaces",
     ],
     srcs: ["proto/**/*.proto"],
+    exclude_srcs: ["proto/virtual_device_manager.proto"],
     libs: [
         "libprotobuf-java-full",
     ],
@@ -136,6 +137,37 @@ java_library_host {
     java_version: "11",
 }
 
+java_library_host {
+    name: "virtual-device-manager-proto",
+    srcs: ["proto/virtual_device_manager.proto"],
+    libs: [
+        "libprotobuf-java-full",
+    ],
+    proto: {
+        include_dirs: ["external/protobuf/src"],
+        type: "full",
+    },
+    // b/267831518: Pin tradefed and dependencies to Java 11.
+    java_version: "11",
+}
+
+java_library_host {
+    name: "virtual-device-manager-grpc",
+    srcs: ["proto/virtual_device_manager.proto"],
+    proto: {
+        include_dirs: ["external/protobuf/src"],
+        plugin: "grpc-java-plugin",
+    },
+    libs: [
+        "virtual-device-manager-proto",
+        "grpc-java",
+        "guava",
+        "javax-annotation-api-prebuilt-host-jar",
+    ],
+    // b/267831518: Pin tradefed and dependencies to Java 11.
+    java_version: "11",
+}
+
 // Avoid version number in apk file name
 genrule {
     name: "test-services-normalized.apk",
@@ -170,6 +202,9 @@ tradefed_java_library_host {
         "tradefed-lib-core",
         "tradefed-test-framework",
     ],
+    required: [
+        "loganalysis",
+    ],
     manifest: "MANIFEST.mf",
     // b/267831518: Pin tradefed and dependencies to Java 11.
     java_version: "11",
@@ -205,6 +240,7 @@ java_library_host {
         "test_observatory/**/*.java",
     ],
     static_libs: [
+        "tradefed-avd-util",
         "tradefed-common-util",
         "tradefed-clearcut-client",
         "tradefed-result-interfaces",
@@ -213,6 +249,7 @@ java_library_host {
         "tradefed-external-dependencies",
         "tradefed-service-grpc-lib",
         "lab-resource-grpc",
+        "virtual-device-manager-grpc",
         "tradefed-invocation-grpc",
         "tradefed-device-manager-grpc",
         "tradefed-dynamic-sharding-grpc",
@@ -339,3 +376,64 @@ sh_binary_host {
     name: "run_tf_cmd.sh",
     src: "run_tf_cmd.sh",
 }
+
+java_genrule_host {
+    name: "tradefed_zip",
+    tools: [
+        "atest_tradefed.sh",
+        "casuploader",
+        "content_uploader",
+        "soong_zip",
+    ],
+    srcs: [
+        ":TradeFedTestApp",
+        ":TradeFedUiTestApp",
+        ":compatibility-host-util",
+        ":compatibility-tradefed",
+        ":loganalysis",
+        ":tradefed",
+        ":tradefed-avd-util-tests",
+        ":tradefed-contrib",
+        ":tradefed-tests",
+        "script_help.sh",
+        "tools/content_uploader.py",
+        "tradefed.sh",
+    ],
+    uses_order_only_build_number_file: true,
+    out: ["tradefed.zip"],
+    dist: {
+        targets: ["tradefed"],
+    },
+    cmd: "mkdir -p $(genDir)/tmp && " +
+        "cp -f $(in) $(location casuploader) $(location atest_tradefed.sh) $(location content_uploader) $(genDir)/tmp && " +
+        "cp $(build_number_file) $(genDir)/tmp/version.txt && " +
+        "$(location soong_zip) -o $(out) -C $(genDir)/tmp -D $(genDir)/tmp",
+}
+
+// Create a simple alias to build all the TF-related targets
+// Note that this is incompatible with `make dist`.  If you want to make
+// the distribution, you must run `tapas` with the individual target names.
+phony_rule {
+    name: "tradefed-core",
+    phony_deps: [
+        "tradefed",
+        "tradefed-contrib",
+        "tradefed-test-framework",
+        "atest_tradefed.sh",
+        "script_help.sh",
+        "tradefed.sh",
+    ],
+}
+
+phony_rule {
+    name: "tradefed-all",
+    phony_deps: [
+        "casuploader",
+        "compatibility-host-util",
+        "compatibility-tradefed",
+        "tradefed-avd-util-tests",
+        "tradefed-core",
+        "tradefed-tests",
+        "tradefed_win",
+    ],
+}
diff --git a/Android.mk b/Android.mk
deleted file mode 100644
index 8e0bbcf8d..000000000
--- a/Android.mk
+++ /dev/null
@@ -1,77 +0,0 @@
-# Copyright (C) 2010 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH := $(call my-dir)
-COMPATIBILITY.tradefed_tests_dir := \
-  $(COMPATIBILITY.tradefed_tests_dir) $(LOCAL_PATH)/res/config $(LOCAL_PATH)/javatests/res/config
-
-include $(CLEAR_VARS)
-
-# makefile rules to copy jars to HOST_OUT/tradefed
-# so tradefed.sh can automatically add to classpath
-
-$(HOST_OUT_JAVA_LIBRARIES)/tradefed.jar : $(HOST_OUT)/tradefed/loganalysis.jar
-
-#######################################################
-
-# Create a simple alias to build all the TF-related targets
-# Note that this is incompatible with `make dist`.  If you want to make
-# the distribution, you must run `tapas` with the individual target names.
-.PHONY: tradefed-core
-tradefed-core: tradefed tradefed-test-framework atest_tradefed.sh tradefed-contrib script_help.sh tradefed.sh
-
-.PHONY: tradefed-all
-tradefed-all: tradefed-core tradefed-tests tradefed_win compatibility-host-util compatibility-tradefed casuploader
-
-########################################################
-# Zip up the built files and dist it as tradefed.zip
-
-tradefed_dist_host_jars := tradefed tradefed-tests loganalysis tradefed-contrib compatibility-tradefed compatibility-host-util
-tradefed_dist_host_exes := tradefed.sh script_help.sh atest_tradefed.sh casuploader
-tradefed_dist_test_apks := TradeFedUiTestApp TradeFedTestApp
-
-# Generate a src:dest list of copies to perform.
-# The source should always be an intermediate / source location, not the
-# installed location, as that will force installation, and cause this zip to be
-# regenerated too often during incremental builds.
-
-tradefed_dist_copy_pairs := $(foreach m, $(tradefed_dist_host_jars), $(call intermediates-dir-for,JAVA_LIBRARIES,$(m),HOST,COMMON)/javalib.jar:$(m).jar)
-tradefed_dist_copy_pairs += $(foreach m, $(tradefed_dist_host_exes), $(call intermediates-dir-for,EXECUTABLES,$(m),HOST)/$(m):$(m))
-tradefed_dist_copy_pairs += $(foreach m, $(tradefed_dist_test_apks), $(call intermediates-dir-for,APPS,$(m))/package.apk:$(m).apk)
-tradefed_dist_copy_pairs += tools/tradefederation/core/tools/content_uploader.py:content_uploader.py
-
-tradefed_dist_host_jars :=
-tradefed_dist_host_exes :=
-tradefed_dist_test_apks :=
-
-tradefed_dist_intermediates := $(call intermediates-dir-for,PACKAGING,tradefed_dist,HOST,COMMON)
-tradefed_dist_zip := $(tradefed_dist_intermediates)/tradefed.zip
-$(tradefed_dist_zip) : PRIVATE_COPY_PAIRS := $(tradefed_dist_copy_pairs)
-$(tradefed_dist_zip) : $(SOONG_ZIP) $(foreach f,$(tradefed_dist_copy_pairs),$(call word-colon,1,$(f)))
-	rm -rf $(dir $@)/tmp && mkdir -p $(dir $@)/tmp
-	$(foreach f,$(PRIVATE_COPY_PAIRS), \
-	  cp -f $(call word-colon,1,$(f)) $(dir $@)/tmp/$(call word-colon,2,$(f)) &&) true
-	echo $(BUILD_NUMBER_FROM_FILE) > $(dir $@)/tmp/version.txt
-	$(SOONG_ZIP) -o $@ -C $(dir $@)/tmp -f $(dir $@)/tmp/version.txt \
-	  $(foreach f,$(PRIVATE_COPY_PAIRS),-f $(dir $@)/tmp/$(call word-colon,2,$(f)))
-
-$(call declare-1p-container,$(tradefed_dist_zip),tools/tradefederation/core)
-$(call declare-container-license-deps,$(tradefed_dist_zip),$(filter $(OUT_DIR)/%,$(foreach f,$(tradefed_dist_copy_pairs), $(call word-colon,1,$(f)))),$(tradefed_dist_zip):)
-
-$(call dist-for-goals, tradefed, $(tradefed_dist_zip))
-
-tradefed_dist_copy_pairs :=
-tradefed_dist_intermediates :=
-tradefed_dist_zip :=
-
diff --git a/aoa_helper/src/com/android/helper/aoa/AoaDevice.java b/aoa_helper/src/com/android/helper/aoa/AoaDevice.java
index 7289c5078..30347f665 100644
--- a/aoa_helper/src/com/android/helper/aoa/AoaDevice.java
+++ b/aoa_helper/src/com/android/helper/aoa/AoaDevice.java
@@ -16,12 +16,11 @@
 package com.android.helper.aoa;
 
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Charsets;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Range;
 import com.google.common.util.concurrent.Uninterruptibles;
-
 import java.awt.Point;
+import java.nio.charset.StandardCharsets;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.Arrays;
@@ -29,7 +28,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
-
 import java.util.logging.Logger;
 import javax.annotation.Nonnull;
 
@@ -59,10 +57,11 @@ public class AoaDevice implements AutoCloseable {
     private static final Range<Integer> AUDIO_PID = Range.closed(0x2D02, 0x2D05);
     private static final ImmutableSet<Integer> ADB_PID = ImmutableSet.of(0x2D01, 0x2D03, 0x2D05);
 
-    // Simulated accessory information
-    private static final byte[] MANUFACTURER = "Android\0".getBytes(Charsets.UTF_8);
-    private static final byte[] MODEL = (AoaDevice.class.getName() + "\0").getBytes(Charsets.UTF_8);
-    private static final byte[] VERSION = "1.0\0".getBytes(Charsets.UTF_8);
+  // Simulated accessory information
+  private static final byte[] MANUFACTURER = "Android\0".getBytes(StandardCharsets.UTF_8);
+  private static final byte[] MODEL =
+      (AoaDevice.class.getName() + "\0").getBytes(StandardCharsets.UTF_8);
+  private static final byte[] VERSION = "1.0\0".getBytes(StandardCharsets.UTF_8);
 
     // AOA requests
     static final byte ACCESSORY_GET_PROTOCOL = 51;
diff --git a/avd_util/Android.bp b/avd_util/Android.bp
new file mode 100644
index 000000000..65b962110
--- /dev/null
+++ b/avd_util/Android.bp
@@ -0,0 +1,67 @@
+// Copyright 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+java_library_host {
+    name: "tradefed-avd-util",
+    // Restrict visibility to only those targets that need to access it.
+    visibility: [
+        "//tools/tradefederation/core",
+    ],
+    defaults: ["tradefed_defaults"],
+    java_version: "11",
+    srcs: [
+        "com/**/*.java",
+    ],
+    static_libs: [
+        "tradefed-common-util",
+        "virtual-device-manager-proto",
+    ],
+    libs: [
+        "ddmlib-prebuilt",
+        "json-prebuilt",
+        "guava",
+    ],
+    plugins: [
+    ],
+}
+
+tradefed_java_library_host {
+    name: "tradefed-avd-util-tests",
+    // Restrict visibility to only those targets that need to access it.
+    visibility: [
+        "//tools/tradefederation/core",
+        "//tools/tradefederation/core/javatests",
+    ],
+    defaults: ["tradefed_defaults"],
+    java_version: "11",
+    srcs: [
+        "javatests/**/*.java",
+    ],
+    static_libs: [
+        "tradefed-avd-util",
+        "tradefed-common-util",
+        "virtual-device-manager-proto",
+        "junit-host",
+        "mockito",
+    ],
+    libs: [
+        "guava",
+    ],
+    plugins: [
+    ],
+}
diff --git a/avd_util/OWNERS b/avd_util/OWNERS
new file mode 100644
index 000000000..2de9fee6f
--- /dev/null
+++ b/avd_util/OWNERS
@@ -0,0 +1,5 @@
+dshi@google.com
+easoncylee@google.com
+jdesprez@google.com
+yangmingjun@google.com
+yuchenhe@google.com
\ No newline at end of file
diff --git a/avd_util/README.md b/avd_util/README.md
new file mode 100644
index 000000000..814e1e12e
--- /dev/null
+++ b/avd_util/README.md
@@ -0,0 +1,8 @@
+# AVD Common Util
+
+Set of utilities and classes that are shared for managing AVD.
+
+This directory should contain classes that are:
+*  Only used for AVD management, including lease, release, log collection etc.
+*  Can be removed from TF if AVD management is not done inside TF.
+
diff --git a/avd_util/com/android/tradefed/util/avd/AcloudUtil.java b/avd_util/com/android/tradefed/util/avd/AcloudUtil.java
new file mode 100644
index 000000000..31bb27af0
--- /dev/null
+++ b/avd_util/com/android/tradefed/util/avd/AcloudUtil.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import com.android.tradefed.util.MultiMap;
+
+import com.google.common.collect.Lists;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
+/** A utility for Acloud related operations */
+public class AcloudUtil {
+
+    /**
+     * Build and return the command to launch GCE. Exposed for testing.
+     *
+     * @param binary Full path to the binary to run
+     * @param createCmd command to create the instance, e.g., create, create_gf
+     * @param reportFile Full path to the report file to save the output to
+     * @param buildTarget name of the device build target
+     * @param buildBranch name of the device build branch
+     * @param buildID ID of the device build
+     * @param ipDevice IP address of the remote host
+     * @param hostUser Name of the user to use for the remote host, must be set if ipDevice is set
+     * @param sshKeyPath path to the private ssh key file
+     * @param extraArgs a {@link List<String>} of extra command line args
+     * @param serviceAccountKeyPath path to the service account json key file
+     * @param offset integer of the device offset
+     * @param gceAccount account for the GCP project
+     * @param gceDriverParams a {@link List<String>} of parameters from gce-driver-param option
+     * @param gceDriverFileParams a {@link MultiMap<String, File>} of parameters from
+     *     gce-driver-file-param option
+     * @param extraFiles a {@link MultiMap<File, String>} of extra files fromg gce-extra-files
+     *     option, which contains the files to upload GCE instance during Acloud create. Key is
+     *     local file, value is GCE destination path.
+     * @return a {@link List<String>} of command line args
+     */
+    public static List<String> buildGceCmd(
+            String binary,
+            String createCmd,
+            File reportFile,
+            String buildTarget,
+            String buildBranch,
+            String buildId,
+            String ipDevice,
+            String hostUser,
+            String sshKeyPath,
+            List<String> extraArgs,
+            String serviceAccountKeyPath,
+            Integer offset,
+            String gceAccount,
+            List<String> gceDriverParams,
+            MultiMap<String, File> gceDriverFileParams,
+            MultiMap<File, String> extraFiles) {
+        List<String> gceArgs = Lists.newArrayList(binary);
+        gceArgs.add(createCmd);
+        gceArgs.addAll(extraArgs);
+
+        /* If args passed by gce-driver-param contain build-target or build_target, or
+        test device options include local-image and cvd-host-package to side load prebuilt virtual
+        device images, there is no need to pass the build info from device BuildInfo to gce
+        arguments. Otherwise, generate gce args from device BuildInfo. Please refer to acloud
+        arguments for the supported format:
+        https://android.googlesource.com/platform/tools/acloud/+/refs/heads/master/create/create_args.py  */
+        if (!gceDriverParams.contains("--build-target")
+                && !gceDriverParams.contains("--build_target")
+                && !(gceDriverFileParams.containsKey("local-image")
+                        && gceDriverFileParams.containsKey("cvd-host-package"))) {
+            gceArgs.add("--build-target");
+            gceArgs.add(buildTarget);
+            gceArgs.add("--branch");
+            gceArgs.add(buildBranch);
+            gceArgs.add("--build-id");
+            gceArgs.add(buildId);
+        }
+
+        for (Map.Entry<String, File> entry : gceDriverFileParams.entries()) {
+            gceArgs.add("--" + entry.getKey());
+            gceArgs.add(entry.getValue().getAbsolutePath());
+        }
+
+        if (!extraFiles.isEmpty()) {
+            gceArgs.add("--extra-files");
+            for (File local : extraFiles.keySet()) {
+                for (String remoteDestination : extraFiles.get(local)) {
+                    gceArgs.add(local.getAbsolutePath() + "," + remoteDestination);
+                }
+            }
+        }
+
+        // Add additional args passed by gce-driver-param.
+        gceArgs.addAll(gceDriverParams);
+        if (serviceAccountKeyPath != null) {
+            gceArgs.add("--service-account-json-private-key-path");
+            gceArgs.add(serviceAccountKeyPath);
+        }
+
+        if (ipDevice != null) {
+            gceArgs.add("--host");
+            gceArgs.add(ipDevice);
+            gceArgs.add("--host-user");
+            gceArgs.add(hostUser);
+            gceArgs.add("--host-ssh-private-key-path");
+            gceArgs.add(sshKeyPath);
+        }
+        gceArgs.add("--report_file");
+        gceArgs.add(reportFile.getAbsolutePath());
+
+        // Add base-instance-num args with offset, and override the remote adb port.
+        // When offset is 1, base-instance-num=2 and virtual device adb forward port is 6521.
+        if (offset != null) {
+            gceArgs.add("--base-instance-num");
+            gceArgs.add(String.valueOf(offset + 1));
+        }
+
+        if (gceAccount != null) {
+            gceArgs.add("--email");
+            gceArgs.add(gceAccount);
+        }
+        // Do not pass flags --logcat_file and --serial_log_file to collect logcat and serial logs.
+
+        return gceArgs;
+    }
+}
diff --git a/avd_util/com/android/tradefed/util/avd/AvdManagement.java b/avd_util/com/android/tradefed/util/avd/AvdManagement.java
new file mode 100644
index 000000000..7ee6cea2e
--- /dev/null
+++ b/avd_util/com/android/tradefed/util/avd/AvdManagement.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import android.virtualdevice.proto.LeaseAvdDeviceRequest;
+import android.virtualdevice.proto.LeaseAvdDeviceResponse;
+import android.virtualdevice.proto.ReleaseAvdDeviceRequest;
+import android.virtualdevice.proto.ReleaseAvdDeviceResponse;
+
+import com.android.tradefed.util.IRunUtil;
+
+/** A utility for AVD management */
+public class AvdManagement {
+    private IRunUtil mRunUtil;
+
+    IRunUtil getRunUtil() {
+        return mRunUtil;
+    }
+
+    /**
+     * Helper method to lease AVD device
+     *
+     * @param request detailed info about the device to lease
+     * @return {@link LeaseAvdDeviceResponse} device leased
+     */
+    public LeaseAvdDeviceResponse leaseDevice(LeaseAvdDeviceRequest request) {
+        // TODO(dshi): Implement the method
+        return null;
+    }
+
+    /**
+     * Helper method to release AVD device
+     *
+     * @param request detailed info about the device to release
+     * @return {@link ReleaseAvdDeviceResponse} result about the release device action.
+     */
+    public ReleaseAvdDeviceResponse releaseDevice(ReleaseAvdDeviceRequest request) {
+        // TODO(dshi): Implement the method
+        return null;
+    }
+}
diff --git a/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java b/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
new file mode 100644
index 000000000..d2c3c8ef9
--- /dev/null
+++ b/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
@@ -0,0 +1,546 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.util.avd;
+
+import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.ZipUtil2;
+import com.android.tradefed.util.avd.OxygenClient.LHPTunnelMode;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/** Utility to execute commands via Host Orchestrator on remote instances. */
+public class HostOrchestratorUtil {
+    public static final String URL_HOST_KERNEL_LOG = "_journal/entries?_TRANSPORT=kernel";
+    public static final String URL_HO_LOG =
+            "_journal/entries?_SYSTEMD_UNIT=cuttlefish-host_orchestrator.service";
+    public static final String URL_OXYGEN_CONTAINER_LOG = "_journal/entries?CONTAINER_NAME=oxygen";
+    private static final long CMD_TIMEOUT_MS = 5 * 6 * 1000 * 10; // 5 min
+    private static final long WAIT_FOR_OPERATION_MS = 5 * 6 * 1000; // 30 sec
+    private static final long WAIT_FOR_OPERATION_TIMEOUT_MS = 5 * 6 * 1000 * 10; // 5 min
+    private static final String CVD_HOST_LOGZ = "cvd_hostlog_zip";
+    private static final String URL_CVD_DEVICE_LOG = "cvds/%s/:bugreport";
+    private static final String URL_CVD_BUGREPORTS = "cvdbugreports/%s";
+    private static final String URL_HO_BASE = "http://%s:%s/%s";
+    private static final String URL_HO_POWERWASH = "cvds/%s/%s/:powerwash";
+    private static final String URL_HO_STOP = "cvds/%s/%s";
+    private static final String URL_QUERY_OPERATION = "operations/%s";
+    private static final String URL_QUERY_OPERATION_RESULT = "operations/%s/result";
+    private static final String UNSUPPORTED_API_RESPONSE = "404 page not found";
+
+    private File mTunnelLog;
+    private FileOutputStream mTunnelLogStream;
+    private boolean mUseOxygenation = false;
+    private boolean mUseCvdOxygen = false;
+
+    // User name and key file to ssh to the host VM
+    private File mSshPrivateKeyPath;
+    private String mInstanceUser;
+
+    // Oxygen instance name, host name, target region, accounting user, device ID, and other oxygen
+    // arguments.
+    private String mInstanceName;
+    private String mHost;
+    private String mOxygenationDeviceId;
+    private String mTargetRegion;
+    private String mAccountingUser;
+    private Map<String, String> mExtraOxygenArgs;
+    private OxygenClient mOxygenClient;
+
+    public HostOrchestratorUtil(
+            boolean useOxygenation,
+            Map<String, String> extraOxygenArgs,
+            String instanceName,
+            String host,
+            String oxygenationDeviceId,
+            String targetRegion,
+            String accountingUser,
+            OxygenClient oxygenClient) {
+        mUseOxygenation = useOxygenation;
+        mExtraOxygenArgs = extraOxygenArgs;
+        mInstanceName = instanceName;
+        mHost = host;
+        mOxygenationDeviceId = oxygenationDeviceId;
+        mTargetRegion = targetRegion;
+        mAccountingUser = accountingUser;
+        mOxygenClient = oxygenClient;
+    }
+
+    /**
+     * Execute a command via Host Orchestrator and log its output
+     *
+     * @param logName the log name to use when reporting to the {@link ITestLogger}
+     * @param url the Host Orchestrator API to be executed.
+     */
+    public File collectLogByCommand(String logName, String url) {
+        String portNumber = "2080";
+        Process tunnel = null;
+        File tempFile = null;
+        try {
+            tempFile = Files.createTempFile(logName, ".txt").toFile();
+            if (mUseOxygenation) {
+                portNumber = Integer.toString(mOxygenClient.createServerSocket());
+                tunnel = createHostOrchestratorTunnel(portNumber);
+                if (tunnel == null || !tunnel.isAlive()) {
+                    CLog.e("Failed portforwarding Host Orchestrator tunnel.");
+                    FileUtil.deleteFile(tempFile);
+                    return null;
+                }
+            }
+            CommandResult commandRes =
+                    curlCommandExecution(
+                            portNumber,
+                            "GET",
+                            url,
+                            false,
+                            "--compressed",
+                            "-o",
+                            tempFile.getAbsolutePath());
+            if (!CommandStatus.SUCCESS.equals(commandRes.getStatus())) {
+                CLog.e("Failed logging cvd logs via Host Orchestrator: %s", commandRes.getStdout());
+                FileUtil.deleteFile(tempFile);
+                return null;
+            }
+            return tempFile;
+        } catch (IOException e) {
+            CLog.e("Failed logging cvd logs via Host Orchestrator: %s", e);
+            FileUtil.deleteFile(tempFile);
+            return null;
+        } finally {
+            if (mUseOxygenation) {
+                mOxygenClient.closeLHPConnection(tunnel);
+            }
+        }
+    }
+
+    /** Pull CF host logs via Host Orchestrator. */
+    public File pullCvdHostLogs() {
+        // Basically, the rough processes to pull CF host logs are
+        // 1. Portforward CURL tunnel.
+        // 2. Run /cvds API and parse the json to get ${GROUP_NAME}.
+        // 3. Run /cvds/${GROUP_NAME}/:bugreport to get ${OPERATION_ID}
+        // 4. Periodically run /operations/${OPERATION_ID}, parse the json util get "done":true.
+        // 5. Run /operations/${OPERATION_ID}/result to get the ${UUID}.
+        // 6. Run /cvdbugreports/${UUID} to download the artifact.
+        String portNumber = "2080";
+        Process tunnel = null;
+        File cvdLogsDir = null;
+        File cvdLogsZip = null;
+        try {
+            cvdLogsZip = Files.createTempFile(CVD_HOST_LOGZ, ".zip").toFile();
+            if (mUseOxygenation) {
+                portNumber = Integer.toString(mOxygenClient.createServerSocket());
+                tunnel = createHostOrchestratorTunnel(portNumber);
+                if (tunnel == null || !tunnel.isAlive()) {
+                    CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
+                    return null;
+                }
+            }
+            CommandResult curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
+                return null;
+            }
+            String cvdGroup = parseListCvdOutput(curlRes.getStdout(), "group");
+            curlRes =
+                    cvdOperationExecution(
+                            portNumber,
+                            "POST",
+                            String.format(URL_CVD_DEVICE_LOG, cvdGroup),
+                            WAIT_FOR_OPERATION_TIMEOUT_MS);
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e(
+                        "Failed running cvd operation via Host Orchestrator: %s",
+                        curlRes.getStdout());
+                return null;
+            }
+            String operationId = curlRes.getStdout().strip().replaceAll("\"", "");
+            curlRes =
+                    curlCommandExecution(
+                            portNumber,
+                            "GET",
+                            String.format(URL_CVD_BUGREPORTS, operationId),
+                            true,
+                            "--output",
+                            cvdLogsZip.getAbsolutePath());
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e(
+                        "Failed downloading cvd host logs via Host Orchestrator: %s",
+                        curlRes.getStdout());
+                return null;
+            }
+            cvdLogsDir = ZipUtil2.extractZipToTemp(cvdLogsZip, "cvd_logs");
+        } catch (IOException e) {
+            CLog.e("Failed pulling cvd host logs via Host Orchestrator: %s", e);
+        } finally {
+            if (mUseOxygenation) {
+                mOxygenClient.closeLHPConnection(tunnel);
+            }
+            cvdLogsZip.delete();
+        }
+        return cvdLogsDir;
+    }
+
+    /**
+     * Get CF running status via Host Orchestrator.
+     *
+     * @param maxWaitTime The max timeout expected to getting the CF running status.
+     * @return True if device boot complete, false otherwise.
+     */
+    public boolean deviceBootCompleted(long maxWaitTime) {
+        String portNumber = "2080";
+        Process tunnel = null;
+        try {
+            if (mUseOxygenation) {
+                portNumber = Integer.toString(mOxygenClient.createServerSocket());
+                tunnel = createHostOrchestratorTunnel(portNumber);
+                if (tunnel == null || !tunnel.isAlive()) {
+                    CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
+                    return false;
+                }
+            }
+            long maxEndTime = System.currentTimeMillis() + maxWaitTime;
+            while (System.currentTimeMillis() < maxEndTime) {
+                CommandResult curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
+                if (CommandStatus.SUCCESS.equals(curlRes.getStatus())
+                        && parseListCvdOutput(curlRes.getStdout(), "status").equals("Running")) {
+                    return true;
+                }
+                getRunUtil().sleep(WAIT_FOR_OPERATION_MS);
+            }
+        } catch (IOException e) {
+            CLog.e("Failed getting gce status via Host Orchestrator: %s", e);
+        } finally {
+            if (mUseOxygenation) {
+                mOxygenClient.closeLHPConnection(tunnel);
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Attempt to powerwash a GCE instance via Host Orchestrator.
+     *
+     * @return A {@link CommandResult} containing the status and logs.
+     */
+    public CommandResult powerwashGce() {
+        // Basically, the rough processes to powerwash a GCE instance are
+        // 1. Portforward CURL tunnel
+        // 2. Obtain the necessary information to powerwash a GCE instance via Host Orchestrator.
+        // 3. Attempt to powerwash a GCE instance via Host Orchestrator.
+        // TODO(easoncylee): Flesh out this section when it's ready.
+        String portNumber = "2080";
+        Process tunnel = null;
+        CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
+        try {
+            if (mUseOxygenation) {
+                portNumber = Integer.toString(mOxygenClient.createServerSocket());
+                tunnel = createHostOrchestratorTunnel(portNumber);
+                if (tunnel == null || !tunnel.isAlive()) {
+                    String msg = "Failed portforwarding Host Orchestrator tunnel.";
+                    CLog.e(msg);
+                    curlRes.setStderr(msg);
+                    return curlRes;
+                }
+            }
+            curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
+                return curlRes;
+            }
+            String cvdGroup = parseListCvdOutput(curlRes.getStdout(), "group");
+            String cvdName = parseListCvdOutput(curlRes.getStdout(), "name");
+            if (cvdGroup == null || cvdGroup.isEmpty() || cvdName == null || cvdName.isEmpty()) {
+                CLog.e("Failed parsing cvd group and cvd name.");
+                curlRes.setStatus(CommandStatus.FAILED);
+                return curlRes;
+            }
+            curlRes =
+                    cvdOperationExecution(
+                            portNumber,
+                            "POST",
+                            String.format(URL_HO_POWERWASH, cvdGroup, cvdName),
+                            WAIT_FOR_OPERATION_TIMEOUT_MS);
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e("Failed powerwashing cvd via Host Orchestrator: %s", curlRes.getStdout());
+            }
+        } catch (IOException e) {
+            CLog.e("Failed powerwashing gce via Host Orchestrator: %s", e);
+        } finally {
+            if (mUseOxygenation) {
+                mOxygenClient.closeLHPConnection(tunnel);
+            }
+        }
+        return curlRes;
+    }
+
+    /** Attempt to stop a Cuttlefish instance via Host Orchestrator. */
+    public CommandResult stopGce() {
+        // Basically, the rough processes to powerwash a GCE instance are
+        // 1. Portforward CURL tunnel
+        // 2. Obtain the necessary information to powerwash a GCE instance via Host Orchestrator.
+        // 3. Attempt to stop a GCE instance via Host Orchestrator.
+        String portNumber = "2080";
+        Process tunnel = null;
+        CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
+        try {
+            if (mUseOxygenation) {
+                portNumber = Integer.toString(mOxygenClient.createServerSocket());
+                tunnel = createHostOrchestratorTunnel(portNumber);
+                if (tunnel == null || !tunnel.isAlive()) {
+                    String msg = "Failed portforwarding Host Orchestrator tunnel.";
+                    CLog.e(msg);
+                    curlRes.setStderr(msg);
+                    return curlRes;
+                }
+            }
+            curlRes = curlCommandExecution(portNumber, "GET", "cvds", true);
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
+                return curlRes;
+            }
+            String cvdGroup = parseListCvdOutput(curlRes.getStdout(), "group");
+            String cvdName = parseListCvdOutput(curlRes.getStdout(), "name");
+            if (cvdGroup == null || cvdGroup.isEmpty() || cvdName == null || cvdName.isEmpty()) {
+                CLog.e("Failed parsing cvd group and cvd name.");
+                curlRes.setStatus(CommandStatus.FAILED);
+                return curlRes;
+            }
+            curlRes =
+                    cvdOperationExecution(
+                            portNumber,
+                            "DELETE",
+                            String.format(URL_HO_STOP, cvdGroup, cvdName),
+                            WAIT_FOR_OPERATION_TIMEOUT_MS);
+            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
+                CLog.e("Failed stopping gce via Host Orchestrator: %s", curlRes.getStdout());
+            }
+        } catch (IOException e) {
+            CLog.e("Failed stopping gce via Host Orchestrator: %s", e);
+        } finally {
+            if (mUseOxygenation) {
+                mOxygenClient.closeLHPConnection(tunnel);
+            }
+        }
+        return curlRes;
+    }
+
+    /** Attempt to snapshot a Cuttlefish instance via Host Orchestrator. */
+    public CommandResult snapshotGce() {
+        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
+        return new CommandResult(CommandStatus.EXCEPTION);
+    }
+
+    /** Attempt to restore snapshot of a Cuttlefish instance via Host Orchestrator. */
+    public CommandResult restoreSnapshotGce() {
+        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
+        return new CommandResult(CommandStatus.EXCEPTION);
+    }
+
+    /**
+     * Create Host Orchestrator Tunnel with a given port number.
+     *
+     * @param portNumber The port number that Host Orchestrator communicates with.
+     * @return A {@link Process} of the Host Orchestrator connection between CuttleFish and TF.
+     */
+    @VisibleForTesting
+    Process createHostOrchestratorTunnel(String portNumber) throws IOException {
+        if (mTunnelLog == null || !mTunnelLog.exists()) {
+            try {
+                mTunnelLog = FileUtil.createTempFile("host-orchestrator-connection", ".txt");
+                mTunnelLogStream = new FileOutputStream(mTunnelLog, true);
+            } catch (IOException e) {
+                FileUtil.deleteFile(mTunnelLog);
+                CLog.e(e);
+            }
+        }
+        CLog.i("Portforwarding host orchestrator for oxygenation CF.");
+        return mOxygenClient.createTunnelViaLHP(
+                LHPTunnelMode.CURL,
+                portNumber,
+                mInstanceName,
+                mHost,
+                mTargetRegion,
+                mAccountingUser,
+                mOxygenationDeviceId,
+                mExtraOxygenArgs,
+                mTunnelLogStream);
+    }
+
+    /**
+     * Execute a curl command via Host Orchestrator.
+     *
+     * @param portNumber The port number that Host Orchestrator communicates with.
+     * @param method The HTTP Request containing GET, POST, PUT, DELETE, PATCH, etc...
+     * @param api The API that Host Orchestrator supports.
+     * @param commands The command to be executed.
+     * @return A {@link CommandResult} containing the status and logs.
+     */
+    @VisibleForTesting
+    CommandResult curlCommandExecution(
+            String portNumber,
+            String method,
+            String api,
+            boolean shouldDisplay,
+            String... commands) {
+        List<String> cmd = new ArrayList<>();
+        cmd.add("curl");
+        cmd.add("-0");
+        cmd.add("-v");
+        cmd.add("-X");
+        cmd.add(method);
+        if (mUseOxygenation) {
+            cmd.add(String.format(URL_HO_BASE, "127.0.0.1", portNumber, api));
+        } else {
+            cmd.add(String.format(URL_HO_BASE, mHost, portNumber, api));
+        }
+        for (String cmdOption : commands) {
+            cmd.add(cmdOption);
+        }
+        CommandResult commandRes =
+                getRunUtil().runTimedCmd(CMD_TIMEOUT_MS, null, null, cmd.toArray(new String[0]));
+        if (shouldDisplay) {
+            CLog.logAndDisplay(
+                    LogLevel.INFO,
+                    "Executing Host Orchestrator curl command: %s, Output: %s, Status: %s",
+                    cmd,
+                    commandRes.getStdout(),
+                    commandRes.getStatus());
+        }
+        if (commandRes.getStdout().contains(UNSUPPORTED_API_RESPONSE)) {
+            commandRes.setStatus(CommandStatus.FAILED);
+        }
+        return commandRes;
+    }
+
+    /** Return the value by parsing the output of list cvds with a given keyword. */
+    @VisibleForTesting
+    String parseListCvdOutput(String content, String keyword) {
+        // An example output of the given content is:
+        // {"cvds":
+        //      [{
+        //          "group":"cvd_1",
+        //          "name":"ins-1",
+        //          "build_source":{},
+        //          "status":"Running",
+        //          "displays":["720 x 1280 ( 320 )"],
+        //          "webrtc_device_id":"cvd-1",
+        //          "adb_serial":"0.0.0.0:6520"
+        //      }]
+        // }
+        JSONTokener tokener = new JSONTokener(content);
+        String output = "";
+        try {
+            JSONObject root = new JSONObject(tokener);
+            JSONArray array = root.getJSONArray("cvds");
+            output = parseCvdContent(array.getJSONObject(0).toString(), keyword);
+        } catch (JSONException e) {
+            CLog.e(e);
+        }
+        return output;
+    }
+
+    /** Return the value by parsing the simple JSON content with a given keyword. */
+    private String parseCvdContent(String content, String keyword) {
+        String output = "";
+        try {
+            JSONObject object = new JSONObject(content);
+            output = object.get(keyword).toString();
+        } catch (JSONException e) {
+            CLog.e(e);
+        }
+        return output;
+    }
+
+    /**
+     * Execute long-run operations via Host Orchestrator. A certain HO APIs would take longer time
+     * to complete, in order not to execute a long-run operations and wait for the output. This
+     * method calls the operation, get the operation id, periodically do quick check the operation's
+     * status util it's done, and return the result.
+     *
+     * @param portNumber The port number that Host Orchestrator communicates with.
+     * @param method The HTTP Request containing GET, POST, PUT, DELETE, PATCH, etc...
+     * @param request The HTTP request to be executed.
+     * @param maxWaitTime The max timeout expected to execute the HTTP request.
+     * @return A CommandResult containing the status and logs after running curl command.
+     */
+    @VisibleForTesting
+    CommandResult cvdOperationExecution(
+            String portNumber, String method, String request, long maxWaitTime) {
+        CommandResult commandRes = curlCommandExecution(portNumber, method, request, true);
+        if (!CommandStatus.SUCCESS.equals(commandRes.getStatus())) {
+            CLog.e("Failed running %s, error: %s", request, commandRes.getStdout());
+            return commandRes;
+        }
+
+        String operationId = parseCvdContent(commandRes.getStdout(), "name");
+        long maxEndTime = System.currentTimeMillis() + maxWaitTime;
+        while (System.currentTimeMillis() < maxEndTime) {
+            commandRes =
+                    curlCommandExecution(
+                            portNumber,
+                            "GET",
+                            String.format(URL_QUERY_OPERATION, operationId),
+                            true);
+            if (CommandStatus.SUCCESS.equals(commandRes.getStatus())
+                    && parseCvdContent(commandRes.getStdout(), "done").equals("true")) {
+                request = String.format(URL_QUERY_OPERATION_RESULT, operationId);
+                return curlCommandExecution(portNumber, "GET", request, true);
+            }
+            getRunUtil().sleep(WAIT_FOR_OPERATION_MS);
+        }
+        CLog.e("Running long operation cvd request timedout!");
+        // Return the last command result and change the status to TIMED_OUT.
+        commandRes.setStatus(CommandStatus.TIMED_OUT);
+        return commandRes;
+    }
+
+    /** Get {@link IRunUtil} to use. Exposed for unit testing. */
+    // TODO(dshi): Restore VisibleForTesting after the unittest is moved to the same package
+    // (tradefed-avd-util)
+    protected IRunUtil getRunUtil() {
+        return RunUtil.getDefault();
+    }
+
+    /** Return the unsupported api response. Exposed for unit testing. */
+    @VisibleForTesting
+    String getUnsupportedHoResponse() {
+        return UNSUPPORTED_API_RESPONSE;
+    }
+
+    /** Return the host orchestrator tunnel log file. */
+    public File getTunnelLog() {
+        return mTunnelLog;
+    }
+}
diff --git a/avd_util/com/android/tradefed/util/avd/LogCollector.java b/avd_util/com/android/tradefed/util/avd/LogCollector.java
new file mode 100644
index 000000000..b81b72bdb
--- /dev/null
+++ b/avd_util/com/android/tradefed/util/avd/LogCollector.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.gcs.GCSFileDownloaderBase;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.nio.file.Files;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Scanner;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/** A utility for collecting logs from AVD and host VM */
+public class LogCollector {
+    // Maximum size of tailing part of a file to search for error signature.
+    private static final long MAX_FILE_SIZE_FOR_ERROR = 10 * 1024 * 1024;
+
+    private static final Map<Pattern, AbstractMap.SimpleEntry<String, String>>
+            REMOTE_LOG_NAME_PATTERN_TO_ERROR_SIGNATURE_MAP =
+                    Stream.of(
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "Address already in use",
+                                                    "launch_cvd_port_collision")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "vcpu hw run failure: 0x7",
+                                                    "crosvm_vcpu_hw_run_failure_7")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "Unable to connect to vsock server",
+                                                    "unable_to_connect_to_vsock_server")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*(launcher|vdl_stdout).*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "failed to initialize fetch system images",
+                                                    "fetch_cvd_failure")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*vdl_stdout.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "E fetch_cvd:", "fetch_cvd_failure_general")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*vdl_stdout.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "E cvd     : fetch_cvd",
+                                                    "fetch_cvd_failure_general")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "failed to read from socket, retry",
+                                                    "rootcanal_socket_error")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "VIRTUAL_DEVICE_BOOT_PENDING: Bluetooth",
+                                                    "bluetooth_pending")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "another cuttlefish device already running",
+                                                    "another_device_running")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*launcher.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "Setup failed for cuttlefish::ConfigServer",
+                                                    "config_server_failed")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile(".*(launcher|kernel|logcat).*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "VIRTUAL_DEVICE_BOOT_FAILED: Dependencies not"
+                                                            + " ready after 10 checks: Bluetooth",
+                                                    "bluetooth_failed")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile("^logcat.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "System zygote died with fatal exception",
+                                                    "zygote_fatal_exception")),
+                                    new AbstractMap.SimpleEntry<>(
+                                            Pattern.compile("^logcat.*"),
+                                            new AbstractMap.SimpleEntry<>(
+                                                    "mkdir failed: errno 117 (Structure needs"
+                                                            + " cleaning)",
+                                                    "filesystem_corrupt")))
+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+
+    /**
+     * Download error logs from GCS when Oxygen failed to launch a virtual device.
+     *
+     * @param errorMessage error message raised when leasing device through Oxygen service.
+     * @param downloader: {@link GCSFileDownloaderBase} used to download files from GCS. If set to
+     *     null, the default downloader will be used, which only supports default credential (e.g.,
+     *     service account used by the node). *
+     * @return The {@link File} object of directory storing the logs.
+     */
+    public static File downloadLaunchFailureLogs(
+            String errorMessage, GCSFileDownloaderBase downloader) {
+        CLog.d("Downloading device launch failure logs based on error message: %s", errorMessage);
+        Pattern pattern = Pattern.compile(".*/storage/browser/(.*)\\?&project=.*", Pattern.DOTALL);
+        Matcher matcher = pattern.matcher(errorMessage);
+        if (!matcher.find()) {
+            CLog.d("Error message doesn't contain expected GCS link.");
+            return null;
+        }
+        String remoteFilePath = "gs://" + matcher.group(1);
+        File localDir;
+        try {
+            if (downloader == null) {
+                downloader = new GCSFileDownloaderBase();
+            }
+            return downloader.downloadFile(remoteFilePath);
+        } catch (Exception e) {
+            CLog.e("Failed to download Oxygen log from %s", remoteFilePath);
+            CLog.e(e);
+            return null;
+        }
+    }
+
+    /**
+     * Collect oxygen version info from oxygeen_version.txt.
+     *
+     * @param logDir directory of logs pulled from remote host.
+     * @return a string of Oxygen version
+     */
+    public static String collectOxygenVersion(File logDir) {
+        CLog.d("Collect Oxygen version from logs under: %s.", logDir);
+        try {
+            Set<String> files = FileUtil.findFiles(logDir, "^oxygen_version\\.txt.*");
+            if (files.size() == 0) {
+                CLog.d("There is no oxygen_version.txt found.");
+                return null;
+            }
+            // Trim the tailing spaces and line breakers at the end of the string.
+            return FileUtil.readStringFromFile(new File(files.iterator().next()))
+                    .replaceAll("(?s)\\n+$", "")
+                    .trim();
+        } catch (Exception e) {
+            CLog.e("Failed to read oxygen_version.txt .");
+            CLog.e(e);
+            return null;
+        }
+    }
+
+    /**
+     * Collect error signatures from logs.
+     *
+     * @param logDir directory of logs pulled from remote host.
+     * @return a list of error signatures.
+     */
+    public static List<String> collectErrorSignatures(File logDir) {
+        CLog.d("Collect error signature from logs under: %s.", logDir);
+        List<String> signatures = new ArrayList<>();
+        try {
+            Set<String> files = FileUtil.findFiles(logDir, ".*");
+            for (String f : files) {
+                File file = new File(f);
+                if (file.isDirectory()) {
+                    continue;
+                }
+                String fileName = file.getName();
+                List<AbstractMap.SimpleEntry<String, String>> pairs = new ArrayList<>();
+                for (Map.Entry<Pattern, AbstractMap.SimpleEntry<String, String>> entry :
+                        REMOTE_LOG_NAME_PATTERN_TO_ERROR_SIGNATURE_MAP.entrySet()) {
+                    Matcher matcher = entry.getKey().matcher(fileName);
+                    if (matcher.find()) {
+                        pairs.add(entry.getValue());
+                    }
+                }
+                if (pairs.size() == 0) {
+                    continue;
+                }
+                try (FileInputStream stream = new FileInputStream(file)) {
+                    long skipSize = Files.size(file.toPath()) - MAX_FILE_SIZE_FOR_ERROR;
+                    if (skipSize > 0) {
+                        stream.skip(skipSize);
+                    }
+                    try (Scanner scanner = new Scanner(stream)) {
+                        List<AbstractMap.SimpleEntry<String, String>> pairsToRemove =
+                                new ArrayList<>();
+                        while (scanner.hasNextLine()) {
+                            String line = scanner.nextLine();
+                            for (AbstractMap.SimpleEntry<String, String> pair : pairs) {
+                                if (line.indexOf(pair.getKey()) != -1) {
+                                    pairsToRemove.add(pair);
+                                    signatures.add(pair.getValue());
+                                }
+                            }
+                            if (pairsToRemove.size() > 0) {
+                                pairs.removeAll(pairsToRemove);
+                                if (pairs.size() == 0) {
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } catch (Exception e) {
+            CLog.e("Failed to collect error signature.");
+            CLog.e(e);
+        }
+        Collections.sort(signatures);
+        return signatures;
+    }
+
+    /**
+     * Collect device launcher metrics from vdl_stdout.
+     *
+     * @param logDir directory of logs pulled from remote host.
+     * @return a list of launch metrics: [fetch_time, launch_time]
+     */
+    public static long[] collectDeviceLaunchMetrics(File logDir) {
+        CLog.d("Collect device launcher metrics from logs under: %s.", logDir);
+        long[] metrics = {-1, -1};
+        try {
+            Set<String> files = FileUtil.findFiles(logDir, "^vdl_stdout\\.txt.*");
+            if (files.size() == 0) {
+                CLog.d("There is no vdl_stdout.txt found.");
+                return metrics;
+            }
+            File vdlStdout = new File(files.iterator().next());
+            // Keep collecting cuttlefish-common for legacy
+            double cuttlefishCommon = 0;
+            // cuttlefish-host-resources and cuttlefish-operator replaces cuttlefish-common
+            // in recent versions of cuttlefish debian packages.
+            double cuttlefishHostResources = 0;
+            double cuttlefishOperator = 0;
+            double launchDevice = 0;
+            double mainstart = 0;
+            Pattern cuttlefishCommonPatteren =
+                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishCommon");
+            Pattern cuttlefishHostResourcesPatteren =
+                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishHostResources");
+            Pattern cuttlefishOperatorPatteren =
+                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishOperator");
+            Pattern launchDevicePatteren =
+                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sLaunchDevice");
+            Pattern mainstartPatteren =
+                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishLauncherMainstart");
+            try (Scanner scanner = new Scanner(vdlStdout)) {
+                boolean metricsPending = false;
+                while (scanner.hasNextLine()) {
+                    String line = scanner.nextLine();
+                    if (!metricsPending) {
+                        if (line.indexOf("launch_cvd exited") != -1) {
+                            metricsPending = true;
+                        } else {
+                            continue;
+                        }
+                    }
+                    Matcher matcher;
+                    if (cuttlefishCommon == 0) {
+                        matcher = cuttlefishCommonPatteren.matcher(line);
+                        if (matcher.find()) {
+                            cuttlefishCommon = Double.parseDouble(matcher.group(1));
+                        }
+                    }
+                    if (cuttlefishHostResources == 0) {
+                        matcher = cuttlefishHostResourcesPatteren.matcher(line);
+                        if (matcher.find()) {
+                            cuttlefishHostResources = Double.parseDouble(matcher.group(1));
+                        }
+                    }
+                    if (cuttlefishOperator == 0) {
+                        matcher = cuttlefishOperatorPatteren.matcher(line);
+                        if (matcher.find()) {
+                            cuttlefishOperator = Double.parseDouble(matcher.group(1));
+                        }
+                    }
+                    if (launchDevice == 0) {
+                        matcher = launchDevicePatteren.matcher(line);
+                        if (matcher.find()) {
+                            launchDevice = Double.parseDouble(matcher.group(1));
+                        }
+                    }
+                    if (mainstart == 0) {
+                        matcher = mainstartPatteren.matcher(line);
+                        if (matcher.find()) {
+                            mainstart = Double.parseDouble(matcher.group(1));
+                        }
+                    }
+                }
+            }
+            if (mainstart > 0) {
+                metrics[0] =
+                        (long)
+                                ((mainstart
+                                                - launchDevice
+                                                - cuttlefishCommon
+                                                - cuttlefishHostResources
+                                                - cuttlefishOperator)
+                                        * 1000);
+                metrics[1] = (long) (launchDevice * 1000);
+            }
+        } catch (Exception e) {
+            CLog.e("Failed to parse device launch time from vdl_stdout.txt.");
+            CLog.e(e);
+        }
+        return metrics;
+    }
+}
diff --git a/src/com/android/tradefed/device/cloud/OxygenClient.java b/avd_util/com/android/tradefed/util/avd/OxygenClient.java
similarity index 58%
rename from src/com/android/tradefed/device/cloud/OxygenClient.java
rename to avd_util/com/android/tradefed/util/avd/OxygenClient.java
index 347a36d95..d6f31f40c 100644
--- a/src/com/android/tradefed/device/cloud/OxygenClient.java
+++ b/avd_util/com/android/tradefed/util/avd/OxygenClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,40 +14,33 @@
  * limitations under the License.
  */
 
-package com.android.tradefed.device.cloud;
+package com.android.tradefed.util.avd;
 
-import com.android.annotations.VisibleForTesting;
-import com.android.tradefed.build.IBuildInfo;
-import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.error.HarnessRuntimeException;
-import com.android.tradefed.invoker.logger.InvocationMetricLogger;
-import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.log.LogUtil.CLog;
-import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.RunUtil;
 
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 
-import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.ServerSocket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.Set;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import com.google.common.base.Strings;
-
 /** A class that manages the use of Oxygen client binary to lease or release Oxygen device. */
 public class OxygenClient {
 
@@ -57,7 +50,10 @@ public class OxygenClient {
         CURL;
     }
 
-    private final File mClientBinary;
+    // A list of commands to be executed to lease or release Oxygen devices, examples:
+    // 1. if the binary is an executable script, execute it directly.
+    // 2. if the binary is a jar file, execute it by using java -jar ${binary_path}.
+    private final List<String> mCmdArgs = Lists.newArrayList();
 
     private IRunUtil mRunUtil;
 
@@ -108,63 +104,26 @@ public class OxygenClient {
         return mRunUtil;
     }
 
-    @VisibleForTesting
-    public OxygenClient(File clientBinary, IRunUtil runUtil) {
-        this(clientBinary);
-        mRunUtil = runUtil;
-    }
-
     /**
      * The constructor of OxygenClient class.
      *
-     * @param clientBinary the executable Oxygen client binary file.
-     */
-    public OxygenClient(File clientBinary) {
-        mRunUtil = RunUtil.getDefault();
-        String error = null;
-        if (clientBinary == null) {
-            error = "the Oxygen client binary reference is null";
-        } else if (!clientBinary.exists()) {
-            error =
-                    String.format(
-                            "the Oxygen client binary file does not exist at %s",
-                            clientBinary.getAbsolutePath());
-        } else if (!clientBinary.canExecute()) {
-            error =
-                    String.format(
-                            "the Oxygen client binary file at %s is not executable",
-                            clientBinary.getAbsolutePath());
-        }
-        if (clientBinary == null || !clientBinary.exists()) {
-            throw new HarnessRuntimeException(
-                    String.format("Error in instantiating OxygenClient class: %s", error),
-                    InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
-        }
-        mClientBinary = clientBinary;
-    }
-
-    /**
-     * Check if no_wait_for_boot is specified in Oxygen lease request
-     *
-     * @param deviceOptions {@link TestDeviceOptions}
-     * @return true if no_wait_for_boot is specified
+     * @param cmdArgs a {@link List<String>} of commands to run Oxygen client.
+     * @param runUtil a {@link IRunUtil} to execute commands.
      */
-    public Boolean noWaitForBootSpecified(TestDeviceOptions deviceOptions) {
-        return deviceOptions.getExtraOxygenArgs().containsKey("no_wait_for_boot");
+    @VisibleForTesting
+    OxygenClient(List<String> cmdArgs, IRunUtil runUtil) {
+        mCmdArgs.addAll(cmdArgs);
+        mRunUtil = runUtil;
     }
 
     /**
-     * Returns the value of the 'override_cvd_path' argument in the given TestDeviceOptions.
+     * The constructor of OxygenClient class.
      *
-     * @param deviceOptions {@link TestDeviceOptions}
-     * @return the value of 'override_cvd_path', or null if it is not present
+     * @param cmdArgs a {@link List<String>} of commands to run Oxygen client.
      */
-    public String getOverrideCvdPath(TestDeviceOptions deviceOptions) {
-        if (!deviceOptions.getExtraOxygenArgs().containsKey("override_cvd_path")) {
-            return null;
-        }
-
-        return deviceOptions.getExtraOxygenArgs().get("override_cvd_path");
+    public OxygenClient(List<String> cmdArgs) {
+        mCmdArgs.addAll(cmdArgs);
+        mRunUtil = RunUtil.getDefault();
     }
 
     /**
@@ -192,24 +151,32 @@ public class OxygenClient {
     /**
      * Attempt to lease a device by calling Oxygen client binary.
      *
-     * @param b {@link IBuildInfo}
-     * @param deviceOptions {@link TestDeviceOptions}
+     * @param buildTarget build target
+     * @param buildBranch build branch
+     * @param buildId build ID
+     * @param targetRegion target region for Oxygen instance
+     * @param accountingUser Oxygen accounting user email
+     * @param leaseLength number of ms for the lease duration
+     * @param gceDriverParams {@link List<String>} of gce driver params
+     * @param extraOxygenArgs {@link Map<String, String>} of extra Oxygen lease args
      * @param attributes attributes associated with current invocation
+     * @param gceCmdTimeout number of ms for the command line timeout
+     * @param useOxygenation whether the device is leased from OmniLab Infra or not.
      * @return a {@link CommandResult} that Oxygen binary returned.
      */
     public CommandResult leaseDevice(
-            IBuildInfo b, TestDeviceOptions deviceOptions, MultiMap<String, String> attributes) {
-        if (deviceOptions.useOxygenationDevice()) {
-            // TODO(b/322726982): Flesh out this section when the oxygen client is supported.
-            // Lease an oxygenation device with additional options passed in when
-            // use-oxygenation-device is set.
-            // For now, return failure with exceptions first.
-            CommandResult ret = new CommandResult(CommandStatus.EXCEPTION);
-            ret.setStderr("OxygenClient: Leasing an oxygenation device is not supported for now.");
-            return ret;
-        }
-        List<String> oxygenClientArgs = Lists.newArrayList(mClientBinary.getAbsolutePath());
-        List<String> gceDriverParams = deviceOptions.getGceDriverParams();
+            String buildTarget,
+            String buildBranch,
+            String buildId,
+            String targetRegion,
+            String accountingUser,
+            long leaseLength,
+            List<String> gceDriverParams,
+            Map<String, String> extraOxygenArgs,
+            MultiMap<String, String> attributes,
+            long gceCmdTimeout,
+            boolean useOxygenation) {
+        List<String> oxygenClientArgs = Lists.newArrayList(mCmdArgs);
         oxygenClientArgs.add("-lease");
         // Add options from GceDriverParams
         int i = 0;
@@ -243,34 +210,28 @@ public class OxygenClient {
         // check if build info exists after added from GceDriverParams
         if (!oxygenClientArgs.contains("-build_target")) {
             oxygenClientArgs.add("-build_target");
-            if (b.getBuildAttributes().containsKey("build_target")) {
-                // If BuildInfo contains the attribute for a build target, use that.
-                oxygenClientArgs.add(b.getBuildAttributes().get("build_target"));
-            } else {
-                oxygenClientArgs.add(b.getBuildFlavor());
-            }
+            oxygenClientArgs.add(buildTarget);
             oxygenClientArgs.add("-build_branch");
-            oxygenClientArgs.add(b.getBuildBranch());
+            oxygenClientArgs.add(buildBranch);
             oxygenClientArgs.add("-build_id");
-            oxygenClientArgs.add(b.getBuildId());
+            oxygenClientArgs.add(buildId);
         }
 
         // add oxygen side lease options
         oxygenClientArgs.add("-target_region");
-        oxygenClientArgs.add(OxygenUtil.getTargetRegion(deviceOptions));
+        oxygenClientArgs.add(targetRegion);
         oxygenClientArgs.add("-accounting_user");
-        oxygenClientArgs.add(deviceOptions.getOxygenAccountingUser());
+        oxygenClientArgs.add(accountingUser);
         oxygenClientArgs.add("-lease_length_secs");
-        oxygenClientArgs.add(Long.toString(deviceOptions.getOxygenLeaseLength() / 1000));
+        oxygenClientArgs.add(Long.toString(leaseLength / 1000));
 
         // Check if there is a new CVD path to override
-        String override_cvd_path = getOverrideCvdPath(deviceOptions);
-        if (override_cvd_path != null) {
+        if (extraOxygenArgs.containsKey("override_cvd_path")) {
             oxygenClientArgs.add("-override_cvd_path");
-            oxygenClientArgs.add(override_cvd_path);
+            oxygenClientArgs.add(extraOxygenArgs.get("override_cvd_path"));
         }
 
-        for (Map.Entry<String, String> arg : deviceOptions.getExtraOxygenArgs().entrySet()) {
+        for (Map.Entry<String, String> arg : extraOxygenArgs.entrySet()) {
             oxygenClientArgs.add("-" + arg.getKey());
             if (!Strings.isNullOrEmpty(arg.getValue())) {
                 oxygenClientArgs.add(arg.getValue());
@@ -279,42 +240,43 @@ public class OxygenClient {
 
         addInvocationAttributes(oxygenClientArgs, attributes);
 
+        if (useOxygenation) {
+            oxygenClientArgs.add("-use_omnilab");
+        }
+
         CLog.i("Leasing device from oxygen client with %s", oxygenClientArgs.toString());
         return runOxygenTimedCmd(
-                oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]),
-                deviceOptions.getGceCmdTimeout());
+                oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]), gceCmdTimeout);
     }
 
     /**
      * Attempt to lease multiple devices by calling Oxygen client binary.
      *
-     * @param buildInfos {@link List<IBuildInfo>}
-     * @param deviceOptions {@link TestDeviceOptions}
+     * @param buildTargets a {@link List<String>} of build targets
+     * @param buildBranches a {@link List<String>} of build branches
+     * @param buildIds a {@link List<String>} of build IDs
+     * @param targetRegion target region for Oxygen instance
+     * @param accountingUser Oxygen accounting user email
+     * @param leaseLength number of ms for the lease duration
+     * @param gceDriverParams {@link List<String>} of gce driver params
+     * @param extraOxygenArgs {@link Map<String, String>} of extra Oxygen lease args
      * @param attributes attributes associated with current invocation
+     * @param gceCmdTimeout number of ms for the command line timeout
      * @return {@link CommandResult} that Oxygen binary returned.
      */
     public CommandResult leaseMultipleDevices(
-            List<IBuildInfo> buildInfos,
-            TestDeviceOptions deviceOptions,
-            MultiMap<String, String> attributes) {
-        List<String> oxygenClientArgs = Lists.newArrayList(mClientBinary.getAbsolutePath());
+            List<String> buildTargets,
+            List<String> buildBranches,
+            List<String> buildIds,
+            String targetRegion,
+            String accountingUser,
+            long leaseLength,
+            Map<String, String> extraOxygenArgs,
+            MultiMap<String, String> attributes,
+            long gceCmdTimeout) {
+        List<String> oxygenClientArgs = Lists.newArrayList(mCmdArgs);
         oxygenClientArgs.add("-lease");
 
-        List<String> buildTargets = new ArrayList<>();
-        List<String> buildBranches = new ArrayList<>();
-        List<String> buildIds = new ArrayList<>();
-
-        for (IBuildInfo b : buildInfos) {
-            if (b.getBuildAttributes().containsKey("build_target")) {
-                // If BuildInfo contains the attribute for a build target, use that.
-                buildTargets.add(b.getBuildAttributes().get("build_target"));
-            } else {
-                buildTargets.add(b.getBuildFlavor());
-            }
-            buildBranches.add(b.getBuildBranch());
-            buildIds.add(b.getBuildId());
-        }
-
         if (buildTargets.size() > 0) {
             oxygenClientArgs.add("-build_target");
             oxygenClientArgs.add(String.join(",", buildTargets));
@@ -329,15 +291,15 @@ public class OxygenClient {
             oxygenClientArgs.add(String.join(",", buildIds));
         }
         oxygenClientArgs.add("-multidevice_size");
-        oxygenClientArgs.add(String.valueOf(buildInfos.size()));
+        oxygenClientArgs.add(String.valueOf(buildTargets.size()));
         oxygenClientArgs.add("-target_region");
-        oxygenClientArgs.add(OxygenUtil.getTargetRegion(deviceOptions));
+        oxygenClientArgs.add(targetRegion);
         oxygenClientArgs.add("-accounting_user");
-        oxygenClientArgs.add(deviceOptions.getOxygenAccountingUser());
+        oxygenClientArgs.add(accountingUser);
         oxygenClientArgs.add("-lease_length_secs");
-        oxygenClientArgs.add(Long.toString(deviceOptions.getOxygenLeaseLength() / 1000));
+        oxygenClientArgs.add(Long.toString(leaseLength / 1000));
 
-        for (Map.Entry<String, String> arg : deviceOptions.getExtraOxygenArgs().entrySet()) {
+        for (Map.Entry<String, String> arg : extraOxygenArgs.entrySet()) {
             oxygenClientArgs.add("-" + arg.getKey());
             if (!Strings.isNullOrEmpty(arg.getValue())) {
                 oxygenClientArgs.add(arg.getValue());
@@ -348,91 +310,143 @@ public class OxygenClient {
 
         CLog.i("Leasing multiple devices from oxygen client with %s", oxygenClientArgs.toString());
         return runOxygenTimedCmd(
-                oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]),
-                deviceOptions.getGceCmdTimeout());
+                oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]), gceCmdTimeout);
     }
 
     /**
      * Attempt to release a device by using Oxygen client binary.
      *
-     * @param gceAvdInfo {@link GceAvdInfo}
-     * @param deviceOptions {@link TestDeviceOptions}
-     * @return a boolean which indicate whether the device release is successful.
+     * @param instanceName name of the Oxygen instance
+     * @param host hostname of the Oxygen instance
+     * @param targetRegion target region
+     * @param accountingUser name of accounting user email
+     * @param extraOxygenArgs {@link Map<String, String>} of extra Oxygen args
+     * @param gceCmdTimeout number of ms for the command line timeout
+     * @param useOxygenation whether the device is leased from OmniLab Infra or not.
+     * @return a {@link CommandResult} that Oxygen binary returned.
      */
-    public boolean release(GceAvdInfo gceAvdInfo, TestDeviceOptions deviceOptions) {
+    public CommandResult release(
+            String instanceName,
+            String host,
+            String targetRegion,
+            String accountingUser,
+            Map<String, String> extraOxygenArgs,
+            long gceCmdTimeout,
+            boolean useOxygenation) {
+        List<String> oxygenClientArgs = Lists.newArrayList(mCmdArgs);
+
         // If gceAvdInfo is missing info, then it means the device wasn't get leased successfully.
         // In such case, there is no need to release the device.
-        if (gceAvdInfo == null
-                || gceAvdInfo.instanceName() == null
-                || gceAvdInfo.hostAndPort() == null
-                || gceAvdInfo.hostAndPort().getHost() == null) {
-            return true;
+        if (instanceName == null || host == null) {
+            CommandResult res = new CommandResult();
+            res.setStatus(CommandStatus.SUCCESS);
+            return res;
         }
-        if (deviceOptions.useOxygenationDevice()) {
-            // TODO(b/322726982): Flesh out this section when the oxygen client is supported.
-            // Release an oxygenation device with additional options passed in when
-            // use-oxygenation-device is set.
-            // For now, return false first.
-            return false;
-        }
-        List<String> oxygenClientArgs = Lists.newArrayList(mClientBinary.getAbsolutePath());
 
-        for (Map.Entry<String, String> arg : deviceOptions.getExtraOxygenArgs().entrySet()) {
-            oxygenClientArgs.add("-" + arg.getKey());
-            if (!Strings.isNullOrEmpty(arg.getValue())) {
-                oxygenClientArgs.add(arg.getValue());
+        if (extraOxygenArgs != null) {
+            for (Map.Entry<String, String> arg : extraOxygenArgs.entrySet()) {
+                oxygenClientArgs.add("-" + arg.getKey());
+                if (!Strings.isNullOrEmpty(arg.getValue())) {
+                    oxygenClientArgs.add(arg.getValue());
+                }
             }
         }
 
         oxygenClientArgs.add("-release");
         oxygenClientArgs.add("-target_region");
-        oxygenClientArgs.add(OxygenUtil.getTargetRegion(deviceOptions));
+        oxygenClientArgs.add(targetRegion);
         oxygenClientArgs.add("-server_url");
-        oxygenClientArgs.add(gceAvdInfo.hostAndPort().getHost());
+        oxygenClientArgs.add(host);
         oxygenClientArgs.add("-session_id");
-        oxygenClientArgs.add(gceAvdInfo.instanceName());
+        oxygenClientArgs.add(instanceName);
         oxygenClientArgs.add("-accounting_user");
-        oxygenClientArgs.add(deviceOptions.getOxygenAccountingUser());
-        CLog.i("Releasing device from oxygen client with command %s", oxygenClientArgs.toString());
-        CommandResult res =
-                runOxygenTimedCmd(
-                        oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]),
-                        deviceOptions.getGceCmdTimeout());
-        if (!res.getStatus().equals(CommandStatus.SUCCESS)) {
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.OXYGEN_DEVICE_RELEASE_FAILURE_COUNT, 1);
-            if (res.getStderr() != null) {
-                String error = "Unknown";
-                if (res.getStderr().contains("context deadline exceeded")) {
-                    error = "SERVER_CALL_TIMEOUT";
-                }
-                InvocationMetricLogger.addInvocationMetrics(
-                        InvocationMetricKey.OXYGEN_DEVICE_RELEASE_FAILURE_MESSAGE, error);
-            }
+        oxygenClientArgs.add(accountingUser);
+        if (useOxygenation) {
+            oxygenClientArgs.add("-use_omnilab");
         }
-        return res.getStatus().equals(CommandStatus.SUCCESS);
+        CLog.i("Releasing device from oxygen client with command %s", oxygenClientArgs.toString());
+        return runOxygenTimedCmd(
+                oxygenClientArgs.toArray(new String[oxygenClientArgs.size()]), gceCmdTimeout);
     }
 
     /**
      * Create an adb or ssh tunnel to a given instance name and assign the endpoint to a device via
      * LHP based on the given tunnel mode.
      *
+     * @param mode The mode for oxygen client to talk to the device.
+     * @param portNumber The port number that Host Orchestrator communicates with.
+     * @param sessionId The session id returned by lease method in oxygenation.
+     * @param serverUrl The server url returned by lease method in oxygenation.
+     * @param targetRegion The target region for Oxygen instance
+     * @param accountingUser Oxygen accounting user email
+     * @param oxygenationDeviceId The device id returned by lease method in oxygenation.
+     * @param extraOxygenArgs {@link Map<String, String>} of extra Oxygen lease args
+     * @param tunnelLog {@link FileOutputStream} for storing logs.
      * @return {@link Process} of the adb over LHP tunnel.
      */
     public Process createTunnelViaLHP(
-            LHPTunnelMode mode, String portNumber, String instanceName, String deviceId) {
-        // TODO(easoncylee): Flesh out this section once the oxygen client is ready.
-        // At high level, the logic would look like as following steps:
-        // Step1: Create an unused ServerSocket port for establishing the adb tunnel.
-        // Step2: Establish ssh over LHP connection by running command.
-        // Step3: return the process of the connection, or null if the tunnel can't be established.
+            LHPTunnelMode mode,
+            String portNumber,
+            String sessionId,
+            String serverUrl,
+            String targetRegion,
+            String accountingUser,
+            String oxygenationDeviceId,
+            Map<String, String> extraOxygenArgs,
+            FileOutputStream tunnelLog) {
+        Process lhpTunnel = null;
+        List<String> oxygenClientArgs = Lists.newArrayList(mCmdArgs);
+        oxygenClientArgs.add("-build_lab_host_proxy_tunnel");
+        oxygenClientArgs.add("-server_url");
+        oxygenClientArgs.add(serverUrl);
+        oxygenClientArgs.add("-session_id");
+        oxygenClientArgs.add(sessionId);
+
+        if (extraOxygenArgs != null) {
+            for (Map.Entry<String, String> arg : extraOxygenArgs.entrySet()) {
+                oxygenClientArgs.add("-" + arg.getKey());
+                if (!Strings.isNullOrEmpty(arg.getValue())) {
+                    oxygenClientArgs.add(arg.getValue());
+                }
+            }
+        }
+
+        oxygenClientArgs.add("-target_region");
+        oxygenClientArgs.add(targetRegion);
+        oxygenClientArgs.add("-accounting_user");
+        oxygenClientArgs.add(accountingUser);
+        oxygenClientArgs.add("-use_omnilab");
+        oxygenClientArgs.add("-tunnel_type");
         if (LHPTunnelMode.ADB.equals(mode)) {
-            return null;
+            oxygenClientArgs.add("adb");
         } else if (LHPTunnelMode.CURL.equals(mode)) {
-            return null;
+            oxygenClientArgs.add("curl");
         } else {
+            oxygenClientArgs.add("ssh");
+        }
+        oxygenClientArgs.add("-tunnel_local_port");
+        oxygenClientArgs.add(portNumber);
+        oxygenClientArgs.add("-device_id");
+        oxygenClientArgs.add(oxygenationDeviceId);
+        try {
+            CLog.i(
+                    "Building %s tunnel from oxygen client with command %s...",
+                    mode, oxygenClientArgs.toString());
+            tunnelLog.write(String.format("\n=== Beginning ===\n").getBytes());
+            tunnelLog.write(
+                    String.format("\n=== Session id: %s, Server URL: %s===\n", sessionId, serverUrl)
+                            .getBytes());
+            lhpTunnel = getRunUtil().runCmdInBackground(oxygenClientArgs, tunnelLog);
+            // TODO(b/363861223): reduce the waiting time when LHP is stable.
+            getRunUtil().sleep(15 * 1000);
+        } catch (IOException e) {
+            CLog.d("Failed connecting to remote GCE using %s over LHP, %s", mode, e.getMessage());
+        }
+        if (lhpTunnel == null || !lhpTunnel.isAlive()) {
+            closeLHPConnection(lhpTunnel);
             return null;
         }
+        return lhpTunnel;
     }
 
     /** Helper to create an unused server socket. */
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/AcloudUtilTest.java b/avd_util/javatests/com/android/tradefed/util/avd/AcloudUtilTest.java
new file mode 100644
index 000000000..14fb483ca
--- /dev/null
+++ b/avd_util/javatests/com/android/tradefed/util/avd/AcloudUtilTest.java
@@ -0,0 +1,395 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import static org.junit.Assert.assertEquals;
+
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.MultiMap;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/** Test for {@link AcloudUtil} */
+@RunWith(JUnit4.class)
+public class AcloudUtilTest {
+    /** Test {@link AcloudUtil#buildGceCmd}. */
+    @Test
+    public void testBuildGceCommand() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            null, // idDevice
+                            null, // hostUser
+                            null, // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            "/path/to/key.json", // serviceAccountKeyPath
+                            null, // offset
+                            null, // gceAccount
+                            new ArrayList<>(), // gceDriverParams
+                            new MultiMap<String, File>(), // gceDriverFileParams
+                            new MultiMap<File, String>() // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--build-target",
+                                    "FLAVOR",
+                                    "--branch",
+                                    "BRANCH",
+                                    "--build-id",
+                                    "BUILDID",
+                                    "--service-account-json-private-key-path",
+                                    "/path/to/key.json",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath()));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+        }
+    }
+
+    /** Test {@link AcloudUtil#buildGceCmd} with IP based device. */
+    @Test
+    public void testBuildGceCommandWithIpDevice() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            "bar", // idDevice
+                            "foo", // hostUser
+                            "/path/to/id_rsa", // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            "/path/to/key.json", // serviceAccountKeyPath
+                            null, // offset
+                            null, // gceAccount
+                            new ArrayList<>(), // gceDriverParams
+                            new MultiMap<String, File>(), // gceDriverFileParams
+                            new MultiMap<File, String>() // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--build-target",
+                                    "FLAVOR",
+                                    "--branch",
+                                    "BRANCH",
+                                    "--build-id",
+                                    "BUILDID",
+                                    "--service-account-json-private-key-path",
+                                    "/path/to/key.json",
+                                    "--host",
+                                    "bar",
+                                    "--host-user",
+                                    "foo",
+                                    "--host-ssh-private-key-path",
+                                    "/path/to/id_rsa",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath()));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+        }
+    }
+
+    /** Test {@link AcloudUtil#buildGceCmd} with emulator build. */
+    @Test
+    public void testBuildGceCommandWithEmulatorBuild() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            List<String> gceDriverParams =
+                    new ArrayList<>(Arrays.asList("--emulator-build-id", "EMULATOR_BUILD_ID"));
+
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            null, // idDevice
+                            null, // hostUser
+                            null, // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            null, // serviceAccountKeyPath
+                            null, // offset
+                            null, // gceAccount
+                            gceDriverParams, // gceDriverParams
+                            new MultiMap<String, File>(), // gceDriverFileParams
+                            new MultiMap<File, String>() // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--build-target",
+                                    "FLAVOR",
+                                    "--branch",
+                                    "BRANCH",
+                                    "--build-id",
+                                    "BUILDID",
+                                    "--emulator-build-id",
+                                    "EMULATOR_BUILD_ID",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath()));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+        }
+    }
+
+    /** Test {@link AcloudUtil#buildGceCmd} with specified images. */
+    @Test
+    public void testBuildGceCommandWithSpecifiedImages() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            MultiMap<String, File> gceDriverFileParams = new MultiMap<String, File>();
+            gceDriverFileParams.put(
+                    "cvd-host-package", new File("/path/to/cvd-host-package.tar.gz"));
+            gceDriverFileParams.put(
+                    "local-image", new File("/path/to/cvd-cuttlefish-android-os.tar.gz"));
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            null, // idDevice
+                            null, // hostUser
+                            null, // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            null, // serviceAccountKeyPath
+                            null, // offset
+                            null, // gceAccount
+                            new ArrayList<>(), // gceDriverParams
+                            gceDriverFileParams, // gceDriverFileParams
+                            new MultiMap<File, String>() // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--cvd-host-package",
+                                    "/path/to/cvd-host-package.tar.gz",
+                                    "--local-image",
+                                    "/path/to/cvd-cuttlefish-android-os.tar.gz",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath()));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+        }
+    }
+
+    /** Test {@link AcloudUtil#buildGceCmd} with preconfigured virtual device. */
+    @Test
+    public void testBuildGceCommand_withPreconfiguredVirtualDevice() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            "bar", // idDevice
+                            "vsoc-01", // hostUser
+                            "/path/to/id_rsa", // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            "/path/to/key.json", // serviceAccountKeyPath
+                            2, // offset
+                            null, // gceAccount
+                            new ArrayList<>(), // gceDriverParams
+                            new MultiMap<String, File>(), // gceDriverFileParams
+                            new MultiMap<File, String>() // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--build-target",
+                                    "FLAVOR",
+                                    "--branch",
+                                    "BRANCH",
+                                    "--build-id",
+                                    "BUILDID",
+                                    "--service-account-json-private-key-path",
+                                    "/path/to/key.json",
+                                    "--host",
+                                    "bar",
+                                    "--host-user",
+                                    "vsoc-01",
+                                    "--host-ssh-private-key-path",
+                                    "/path/to/id_rsa",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath(),
+                                    "--base-instance-num",
+                                    "3"));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+        }
+    }
+
+    /** Test {@link AcloudUtil#buildGceCmd} with extra files. */
+    @Test
+    public void testBuildGceCommandWithExtraFiles() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        File file1 = null;
+        File file2 = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            MultiMap<File, String> extraFiles = new MultiMap<>();
+            file1 = FileUtil.createTempFile("test_file1", ".txt");
+            file2 = FileUtil.createTempFile("test_file2", ".txt");
+            extraFiles.put(file1, "/home/vsoc-01/test_file1.txt");
+            extraFiles.put(file2, "/home/vsoc-01/test_file2.txt");
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            null, // idDevice
+                            null, // hostUser
+                            null, // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            null, // serviceAccountKeyPath
+                            null, // offset
+                            null, // gceAccount
+                            new ArrayList<>(), // gceDriverParams
+                            new MultiMap<String, File>(), // gceDriverFileParams
+                            extraFiles // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--build-target",
+                                    "FLAVOR",
+                                    "--branch",
+                                    "BRANCH",
+                                    "--build-id",
+                                    "BUILDID",
+                                    "--extra-files",
+                                    file1.getAbsolutePath() + ",/home/vsoc-01/test_file1.txt",
+                                    file2.getAbsolutePath() + ",/home/vsoc-01/test_file2.txt",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath()));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+            FileUtil.deleteFile(file1);
+            FileUtil.deleteFile(file2);
+        }
+    }
+
+    /** Test {@link AcloudUtil#buildGceCmd} with kernel build. */
+    @Test
+    public void testBuildGceCommandWithKernelBuild() throws IOException {
+        MultiMap<String, String> stubAttributes = new MultiMap<>();
+        File reportFile = null;
+        try {
+            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
+            List<String> gceDriverParams =
+                    new ArrayList<>(Arrays.asList("--kernel-build-id", "KERNELBUILDID"));
+            List<String> result =
+                    AcloudUtil.buildGceCmd(
+                            "acloud",
+                            "create",
+                            reportFile,
+                            "FLAVOR",
+                            "BRANCH",
+                            "BUILDID",
+                            null, // idDevice
+                            null, // hostUser
+                            null, // sshKeyPath
+                            new ArrayList<>(), // extraArgs
+                            null, // serviceAccountKeyPath
+                            null, // offset
+                            null, // gceAccount
+                            gceDriverParams, // gceDriverParams
+                            new MultiMap<String, File>(), // gceDriverFileParams
+                            new MultiMap<File, String>() // extraFiles
+                            );
+            List<String> expected =
+                    new ArrayList<>(
+                            Arrays.asList(
+                                    "acloud",
+                                    "create",
+                                    "--build-target",
+                                    "FLAVOR",
+                                    "--branch",
+                                    "BRANCH",
+                                    "--build-id",
+                                    "BUILDID",
+                                    "--kernel-build-id",
+                                    "KERNELBUILDID",
+                                    "--report_file",
+                                    reportFile.getAbsolutePath()));
+            assertEquals(expected, result);
+        } finally {
+            FileUtil.deleteFile(reportFile);
+        }
+    }
+}
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
new file mode 100644
index 000000000..07eaa4c66
--- /dev/null
+++ b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
@@ -0,0 +1,1536 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import static org.mockito.Mockito.times;
+
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.avd.OxygenClient.LHPTunnelMode;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.io.File;
+import java.io.OutputStream;
+import java.util.HashMap;
+
+/** Unit tests for {@link HostOrchestratorUtil} */
+@RunWith(JUnit4.class)
+public class HostOrchestratorUtilTest {
+
+    private HostOrchestratorUtil mHOUtil;
+    private static final String INSTANCE_NAME = "instance";
+    private static final String OXYGENATION_DEVICE_ID = "id";
+    private static final String TARGET_REGION = "target_region";
+    private static final String ACCOUNTING_USER = "accounting_user";
+    private static final String HOST = "host";
+    private OxygenClient mMockClient;
+    private IRunUtil mMockRunUtil;
+    private Process mMockProcess;
+    private static final String LIST_CVD_RES =
+            "{\"cvds\":[{\"group\":\"cvd_1\",\"name\":\"ins-1\",\"build_source\":{},"
+                    + "\"status\":\"Running\",\"displays\":[\"720 x 1280 ( 320 )\"],"
+                    + "\"webrtc_device_id\":\"cvd-1\"}]}";
+    private static final String LIST_CVD_STARTING_RES =
+            "{\"cvds\":[{\"group\":\"cvd_1\",\"name\":\"ins-1\",\"build_source\":{},"
+                    + "\"status\":\"Starting\",\"displays\":[\"720 x 1280 ( 320 )\"],"
+                    + "\"webrtc_device_id\":\"cvd-1\"}]}";
+    private static final String OPERATION_RES = "{\"name\":\"some_id\"}";
+    private static final String OPERATION_TIMEOUT_RES = "{\"name\":\"some_id\", \"done\":false}";
+    private static final String OPERATION_DONE_RES = "{\"name\":\"some_id\", \"done\":true}";
+    private static final String LIST_CVD_BADRES =
+            "{\"cvds\":[{\"build_source\":{},"
+                    + "\"status\":\"Running\",\"displays\":[\"720 x 1280 ( 320 )\"],"
+                    + "\"webrtc_device_id\":\"cvd-1\"}]}";
+    private HashMap<String, String> mExtraOxygenArgs;
+
+    @Before
+    public void setUp() throws Exception {
+        mExtraOxygenArgs = new HashMap<>();
+        mExtraOxygenArgs.put("arg1", "value1");
+        mMockClient = Mockito.mock(OxygenClient.class);
+        mMockProcess = Mockito.mock(Process.class);
+        mMockRunUtil = Mockito.mock(IRunUtil.class);
+    }
+
+    @After
+    public void tearDown() {
+        FileUtil.deleteFile(mHOUtil.getTunnelLog());
+    }
+
+
+    @Test
+    public void testCreateHostOrchestratorTunnel_Oxygenation() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient);
+        mHOUtil.createHostOrchestratorTunnel("1111");
+        Mockito.verify(mMockClient, times(1))
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+    }
+
+
+    @Test
+    public void testCollectLogByCommand_Success() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdCommandRes.setStdout("some output");
+        cvdCommandRes.setStderr("some error");
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        (String[]) Mockito.any());
+        File tempFile =
+                mHOUtil.collectLogByCommand("log", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
+        FileUtil.deleteFile(tempFile);
+
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq(
+                                String.format(
+                                        "http://127.0.0.1:1111/%s",
+                                        HostOrchestratorUtil.URL_HOST_KERNEL_LOG)),
+                        Mockito.eq("--compressed"),
+                        Mockito.eq("-o"),
+                        Mockito.any());
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+    }
+
+    @Test
+    public void testCollectLogByCommand_Fail() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.FAILED);
+        cvdCommandRes.setStdout("some output");
+        cvdCommandRes.setStderr("some error");
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        (String[]) Mockito.any());
+        File tempFile =
+                mHOUtil.collectLogByCommand("log", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq(
+                                String.format(
+                                        "http://127.0.0.1:1111/%s",
+                                        HostOrchestratorUtil.URL_HOST_KERNEL_LOG)),
+                        Mockito.eq("--compressed"),
+                        Mockito.eq("-o"),
+                        Mockito.any());
+        FileUtil.deleteFile(tempFile);
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+    }
+
+    @Test
+    public void testPullCvdHostLogs_Oxygenation_Success() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+
+                    @Override
+                    public CommandResult cvdOperationExecution(
+                            String portNumber, String method, String request, long maxWaitTime) {
+                        CommandResult res = new CommandResult(CommandStatus.SUCCESS);
+                        res.setStdout("operation_id");
+                        return res;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdCommandRes.setStdout(LIST_CVD_RES);
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
+        commandRes.setStdout("some output");
+        Mockito.doReturn(commandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("--output"),
+                        Mockito.any());
+        mHOUtil.pullCvdHostLogs();
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("--output"),
+                        Mockito.any());
+    }
+
+    @Test
+    public void testPullCvdHostLogs_Oxygenation_CurlFailedGetCvd() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.FAILED);
+        cvdCommandRes.setStderr("some error");
+        cvdCommandRes.setStdout("some output");
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        (String[]) Mockito.any());
+        Assert.assertNull(mHOUtil.pullCvdHostLogs());
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("--output"),
+                        Mockito.any());
+    }
+
+    @Test
+    public void testPullCvdHostLogs_Oxygenation_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return null;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertNull(mHOUtil.pullCvdHostLogs());
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("--output"),
+                        Mockito.any());
+    }
+
+    @Test
+    public void testPullCvdHostLogs_Oxygenation_FailedDownload() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+
+                    @Override
+                    public CommandResult cvdOperationExecution(
+                            String portNumber, String method, String request, long maxWaitTime) {
+                        CommandResult res = new CommandResult(CommandStatus.SUCCESS);
+                        res.setStdout("operation_id");
+                        return res;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdCommandRes.setStdout(LIST_CVD_RES);
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        CommandResult commandRes = new CommandResult(CommandStatus.FAILED);
+        commandRes.setStdout("some output");
+        commandRes.setStderr("some error");
+        Mockito.doReturn(commandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("--output"),
+                        Mockito.any());
+        Assert.assertNull(mHOUtil.pullCvdHostLogs());
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+    }
+
+    @Test
+    public void testPullCvdHostLogs_Oxygenation_404() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdCommandRes.setStderr("some error");
+        cvdCommandRes.setStdout(mHOUtil.getUnsupportedHoResponse());
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        (String[]) Mockito.any());
+        Assert.assertNull(mHOUtil.pullCvdHostLogs());
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvdbugreports/operation_id"),
+                        Mockito.eq("--output"),
+                        Mockito.any());
+    }
+
+    @Test
+    public void testPowerwashGce() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdRes.setStdout(LIST_CVD_RES);
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        CommandResult powerwashRes = new CommandResult(CommandStatus.SUCCESS);
+        powerwashRes.setStdout(OPERATION_RES);
+        Mockito.doReturn(powerwashRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
+        CommandResult operationRes = new CommandResult(CommandStatus.SUCCESS);
+        operationRes.setStdout(OPERATION_DONE_RES);
+        Mockito.doReturn(operationRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id"));
+        CommandResult successRes = new CommandResult(CommandStatus.SUCCESS);
+        successRes.setStdout("operation_id");
+        Mockito.doReturn(successRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
+        Assert.assertNotNull(mHOUtil.powerwashGce());
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
+    }
+
+    @Test
+    public void testPowerwashGce_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return null;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
+    }
+
+    @Test
+    public void testPowerwashGce_ListCvdFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.FAILED);
+        cvdRes.setStdout("output");
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
+    }
+
+    @Test
+    public void testPowerwashGce_ListCvd404() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdRes.setStdout(mHOUtil.getUnsupportedHoResponse());
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
+    }
+
+    @Test
+    public void testPowerwashGce_NoCvdOutput() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdRes.setStdout(LIST_CVD_BADRES);
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1/:powerwash"));
+    }
+
+    @Test
+    public void testStopGce() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    public IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdRes.setStdout(LIST_CVD_RES);
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        CommandResult stopRes = new CommandResult(CommandStatus.SUCCESS);
+        stopRes.setStdout(OPERATION_RES);
+        Mockito.doReturn(stopRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("DELETE"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+        CommandResult operationRes = new CommandResult(CommandStatus.SUCCESS);
+        operationRes.setStdout(OPERATION_DONE_RES);
+        Mockito.doReturn(operationRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id"));
+        CommandResult successRes = new CommandResult(CommandStatus.SUCCESS);
+        successRes.setStdout("operation_id");
+        Mockito.doReturn(successRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
+        Assert.assertNotNull(mHOUtil.stopGce());
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("DELETE"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+    }
+
+    @Test
+    public void testStopGce_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return null;
+                    }
+
+                    @Override
+                    public IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("DELETE"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+    }
+
+    @Test
+    public void testStopGce_ListCvdFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    public IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.FAILED);
+        cvdRes.setStdout("output");
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("DELETE"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+    }
+
+    @Test
+    public void testStopGce_ListCvd404() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    public IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdRes.setStdout(mHOUtil.getUnsupportedHoResponse());
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("DELETE"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+    }
+
+    @Test
+    public void testStopGce_NoCvdOutput() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    public IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdRes.setStdout(LIST_CVD_BADRES);
+        Mockito.doReturn(cvdRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
+        Mockito.verify(mMockRunUtil, times(0))
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("DELETE"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds/cvd_1/ins-1"));
+    }
+
+    @Test
+    public void testCvdOperationExecution_Failed() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.FAILED);
+        cvdCommandRes.setStdout("some output");
+        cvdCommandRes.setStderr("some error");
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/request"));
+        Assert.assertEquals(
+                CommandStatus.FAILED,
+                mHOUtil.cvdOperationExecution("1111", "POST", "request", 5).getStatus());
+    }
+
+    @Test
+    public void testCvdOperationExecution_FailedOperation() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
+        commandRes.setStdout(OPERATION_RES);
+        Mockito.doReturn(commandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/request"));
+        CommandResult operationRes = new CommandResult(CommandStatus.SUCCESS);
+        operationRes.setStdout(OPERATION_DONE_RES);
+        Mockito.doReturn(operationRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id"));
+        CommandResult failedRes = new CommandResult(CommandStatus.FAILED);
+        failedRes.setStdout("some output");
+        Mockito.doReturn(failedRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
+        Assert.assertEquals(
+                CommandStatus.FAILED,
+                mHOUtil.cvdOperationExecution("1111", "POST", "request", 5).getStatus());
+    }
+
+    @Test
+    public void testCvdOperationExecution_Success() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
+        commandRes.setStdout(OPERATION_RES);
+        Mockito.doReturn(commandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/request"));
+        CommandResult operationRes = new CommandResult(CommandStatus.SUCCESS);
+        operationRes.setStdout(OPERATION_DONE_RES);
+        Mockito.doReturn(operationRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id"));
+        CommandResult successRes = new CommandResult(CommandStatus.SUCCESS);
+        successRes.setStdout("operation_id");
+        Mockito.doReturn(successRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id/result"));
+        Assert.assertEquals(
+                "operation_id",
+                mHOUtil.cvdOperationExecution("1111", "POST", "request", 5).getStdout());
+    }
+
+    @Test
+    public void testCvdOperationExecution_Timedout() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult commandRes = new CommandResult(CommandStatus.SUCCESS);
+        commandRes.setStdout(OPERATION_RES);
+        Mockito.doReturn(commandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("POST"),
+                        Mockito.eq("http://127.0.0.1:1111/request"));
+        CommandResult operationRes = new CommandResult(CommandStatus.SUCCESS);
+        commandRes.setStdout(OPERATION_TIMEOUT_RES);
+        Mockito.doReturn(commandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/operations/some_id"));
+        Assert.assertEquals(
+                CommandStatus.TIMED_OUT,
+                mHOUtil.cvdOperationExecution("1111", "POST", "request", 5).getStatus());
+    }
+
+    @Test
+    public void testParseListCvdOutput_success() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient);
+        Assert.assertEquals("cvd_1", mHOUtil.parseListCvdOutput(LIST_CVD_RES, "group"));
+    }
+
+    @Test
+    public void testParseListCvdOutput_failed() throws Exception {
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient);
+        Assert.assertEquals("", mHOUtil.parseListCvdOutput(LIST_CVD_BADRES, "group"));
+    }
+
+    @Test
+    public void testDeviceBootCompleted_success() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdCommandRes.setStdout(LIST_CVD_RES);
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertTrue(mHOUtil.deviceBootCompleted(10));
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+    }
+
+    @Test
+    public void testDeviceBootCompleted_failed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return mMockProcess;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
+        cvdCommandRes.setStdout(LIST_CVD_STARTING_RES);
+        Mockito.doReturn(cvdCommandRes)
+                .when(mMockRunUtil)
+                .runTimedCmd(
+                        Mockito.anyLong(),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq((OutputStream) null),
+                        Mockito.eq("curl"),
+                        Mockito.eq("-0"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("-X"),
+                        Mockito.eq("GET"),
+                        Mockito.eq("http://127.0.0.1:1111/cvds"));
+        Assert.assertFalse(mHOUtil.deviceBootCompleted(10));
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
+        // Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
+    }
+
+    @Test
+    public void testDeviceBootCompleted_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient) {
+                    @Override
+                    public Process createHostOrchestratorTunnel(String portNumber) {
+                        return null;
+                    }
+
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertFalse(mHOUtil.deviceBootCompleted(10));
+        Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
+    }
+}
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java b/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java
new file mode 100644
index 000000000..f0f9b0f18
--- /dev/null
+++ b/avd_util/javatests/com/android/tradefed/util/avd/OxygenClientTest.java
@@ -0,0 +1,1046 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.times;
+
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.avd.OxygenClient.LHPTunnelMode;
+
+import com.google.common.base.Joiner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+/** Unit tests for {@link OxygenClient} */
+@RunWith(JUnit4.class)
+public class OxygenClientTest {
+
+    private File mOxygenBinaryFile;
+    private File mOxygenJarFile;
+
+    private OxygenClient mOxygenClient;
+    private OxygenClient mOxygenClientJar;
+
+    // Build info
+    private static final String BUILD_TARGET = "target";
+    private static final String BUILD_BRANCH = "testBranch";
+    private static final String BUILD_ID = "P1234567";
+
+    // GceAvdInfo: InstanceName and host name
+    private static final String INSTANCE_NAME = "6a6a744e-0653-4926-b7b8-535d121a2fc9";
+    private static final String HOST = "10.0.80.227";
+
+    // TestDeviceOptions
+    private static final String TARGET_REGION = "us-east";
+    private static final long LEASE_LENGTH = 3600000;
+    private static final String OXYGEN_DEVICE_SIZE = "large";
+    private static final String OXYGEN_SERVICE_ADDRESS = "10.1.23.45";
+    private static final long GCE_CMD_TIMEOUT = 900000;
+    private static final String OXYGEN_ACCOUNTING_USER = "random1234@space.com";
+    private HashMap<String, String> mExtraOxygenArgs;
+
+    private IRunUtil mRunUtil;
+
+    private FileOutputStream mMockFileOutputStream;
+
+    private static final String[] GCE_DEVICE_PARAMS =
+            new String[] {
+                "random-arg",
+                "--branch",
+                "testBranch",
+                "--build-target",
+                "target",
+                "--build-id",
+                "P1234567",
+                "--system-build-target",
+                "testSystemTarget",
+                "--system-build-id",
+                "S1234567",
+                "--kernel-build-target",
+                "testKernelTarget",
+                "--kernel-build-id",
+                "K1234567"
+            };
+    private static final String[] BOOT_IMAGE_PARAMS =
+            new String[] {
+                "--boot-build-target",
+                "testBootTarget",
+                "--boot-build-id",
+                "B1234567",
+                "--boot-artifact",
+                "boot-5.10.img"
+            };
+
+    private static final String[] BOOTLOADER_PARAMS =
+            new String[] {
+                "--bootloader-build-target",
+                "testBootloaderTarget",
+                "--bootloader-build-id",
+                "BL1234567"
+            };
+
+    private static final String[] HOST_PACKAGE_PARAMS =
+            new String[] {
+                "--host_package_build_target",
+                "testHostPackageTarget",
+                "--host_package_build_id",
+                "HP1234567"
+            };
+
+    private static final String EXPECTED_OUTPUT =
+            "debug info lease result: session_id:\"6a6a744e-0653-4926-b7b8-535d121a2fc9\"\n"
+                    + " server_url:\"10.0.80.227\"\n"
+                    + " ports:{type:test value:12345}\n"
+                    + " random_key:\"this-is-12345678\"\n"
+                    + " leased_device_spec:{type:TESTTYPE build_artifacts:{build_id:\"P1234567\""
+                    + " build_target:\"target\" build_branch:\"testBranch\"}}"
+                    + " debug_info:{reserved_cores:1 region:\"test-region\" environment:\"test\"}";
+
+    @Before
+    public void setUp() throws Exception {
+        mOxygenBinaryFile = FileUtil.createTempFile("oxygen", "binary");
+        mOxygenJarFile = FileUtil.createTempFile("oxygen", ".jar");
+
+        mExtraOxygenArgs = new HashMap<>();
+        mExtraOxygenArgs.put("arg1", "value1");
+
+        mRunUtil = Mockito.mock(IRunUtil.class);
+        mOxygenClient =
+                new OxygenClient(Arrays.asList(mOxygenBinaryFile.getAbsolutePath()), mRunUtil);
+        mOxygenClientJar =
+                new OxygenClient(Arrays.asList(mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        mMockFileOutputStream = Mockito.mock(FileOutputStream.class);
+    }
+
+    @After
+    public void tearDown() {
+        FileUtil.recursiveDelete(mOxygenBinaryFile);
+        FileUtil.recursiveDelete(mOxygenJarFile);
+    }
+
+    /** Test leasing a device with Oxygen client binary. */
+    @Test
+    public void testLease() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567"
+                                                + " -system_build_target testSystemTarget"
+                                                + " -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567 -target_region"
+                                                + " us-east -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        Arrays.asList(GCE_DEVICE_PARAMS),
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    /** Test leasing a device from OmniLab's infra with Oxygen client jar file. */
+    @Test
+    public void testLeaseOmniLabDevice() throws Exception {
+        mOxygenClient =
+                new OxygenClient(
+                        Arrays.asList("java", "-jar", mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        "java -jar "
+                                                + mOxygenJarFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567"
+                                                + " -system_build_target testSystemTarget"
+                                                + " -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567 -target_region"
+                                                + " us-east -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id"
+                                                + " -use_omnilab";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        Arrays.asList(GCE_DEVICE_PARAMS),
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    /** Test leasing a device with Oxygen client binary without build-id specified. */
+    @Test
+    public void testLeaseWithoutBuildId() throws Exception {
+        List<String> gceDriverParams =
+                Arrays.asList(new String[] {"--branch", "testBranch", "--build-target", "target"});
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id testBranch -target_region"
+                                                + " us-east -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        gceDriverParams,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    /**
+     * Test leasing a device with Oxygen client binary from OmniLab's infra without build-id
+     * specified.
+     */
+    @Test
+    public void testLeaseOmniLabDeviceWithoutBuildId() throws Exception {
+        mOxygenClient =
+                new OxygenClient(
+                        Arrays.asList("java", "-jar", mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        List<String> gceDriverParams =
+                Arrays.asList(new String[] {"--branch", "testBranch", "--build-target", "target"});
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        "java -jar "
+                                                + mOxygenJarFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id testBranch -target_region"
+                                                + " us-east -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id"
+                                                + " -use_omnilab";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        gceDriverParams,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    /** Test leasing multiple devices with Oxygen client binary. */
+    @Test
+    public void testLeaseMultipleDevice() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease"
+                                                + " -build_target target,target"
+                                                + " -build_branch testBranch,testBranch"
+                                                + " -build_id P1234567,P1234567"
+                                                + " -multidevice_size 2"
+                                                + " -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        CommandResult res =
+                mOxygenClient.leaseMultipleDevices(
+                        Arrays.asList(BUILD_TARGET, BUILD_TARGET),
+                        Arrays.asList(BUILD_BRANCH, BUILD_BRANCH),
+                        Arrays.asList(BUILD_ID, BUILD_ID),
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    /** Test releasing a device with Oxygen client binary. */
+    @Test
+    public void testRelease() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -arg1 value1 -release -target_region us-east"
+                                                + " -server_url 10.0.80.227"
+                                                + " -session_id"
+                                                + " 6a6a744e-0653-4926-b7b8-535d121a2fc9"
+                                                + " -accounting_user"
+                                                + " random1234@space.com";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        CommandResult res =
+                mOxygenClient.release(
+                        INSTANCE_NAME,
+                        HOST,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        mExtraOxygenArgs,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+    }
+
+    /** Test releasing a device from OmniLab's infra with Oxygen client binary. */
+    @Test
+    public void testReleaseOmniLabDevice() throws Exception {
+        mOxygenClient =
+                new OxygenClient(
+                        Arrays.asList("java", "-jar", mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                long timeout = mock.getArgument(0);
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = Joiner.on(" ").join(cmd);
+                                String expectedCmdString =
+                                        "java -jar "
+                                                + mOxygenJarFile.getAbsolutePath()
+                                                + " -arg1 value1 -release -target_region us-east"
+                                                + " -server_url 10.0.80.227"
+                                                + " -session_id"
+                                                + " 6a6a744e-0653-4926-b7b8-535d121a2fc9"
+                                                + " -accounting_user"
+                                                + " random1234@space.com"
+                                                + " -use_omnilab";
+                                assertEquals(timeout, 900000);
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        CommandResult res =
+                mOxygenClient.release(
+                        INSTANCE_NAME,
+                        HOST,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        mExtraOxygenArgs,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+    }
+
+    /** Test releasing an empty GceAvdInfo. */
+    @Test
+    public void testReleaseEmptyGceAvdInfo() throws Exception {
+        // Empty GceAvdInfo happen when the lease was unsuccessful
+        CommandResult res =
+                mOxygenClient.release(
+                        null,
+                        null,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        mExtraOxygenArgs,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        // Should return true as there is nothing need to be released
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+    }
+
+    /** Test releasing an empty GceAvdInfo from Omnilab's infra. */
+    @Test
+    public void testReleaseOmniLabDeviceWithEmptyGceAvdInfo() throws Exception {
+        // Empty GceAvdInfo happen when the lease was unsuccessful
+        CommandResult res =
+                mOxygenClient.release(
+                        null,
+                        null,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        mExtraOxygenArgs,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        // Should return true as there is nothing need to be released
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+    }
+
+    @Test
+    public void testLeaseWithBootImageAndBootArtifact() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = String.join(" ", cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567"
+                                                + " -system_build_target testSystemTarget"
+                                                + " -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567"
+                                                + " -boot_build_target testBootTarget"
+                                                + " -boot_build_id B1234567"
+                                                + " -boot_artifact boot-5.10.img"
+                                                + " -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id";
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        List<String> paramsList = new ArrayList<>();
+        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
+        paramsList.addAll(Arrays.asList(BOOT_IMAGE_PARAMS));
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        paramsList,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    @Test
+    public void testLeaseOmniLabDeviceWithBootImageAndBootArtifact() throws Exception {
+        mOxygenClient =
+                new OxygenClient(
+                        Arrays.asList("java", "-jar", mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = String.join(" ", cmd);
+                                String expectedCmdString =
+                                        "java -jar "
+                                                + mOxygenJarFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567"
+                                                + " -system_build_target testSystemTarget"
+                                                + " -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567"
+                                                + " -boot_build_target testBootTarget"
+                                                + " -boot_build_id B1234567"
+                                                + " -boot_artifact boot-5.10.img"
+                                                + " -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id"
+                                                + " -use_omnilab";
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        List<String> paramsList = new ArrayList<>();
+        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
+        paramsList.addAll(Arrays.asList(BOOT_IMAGE_PARAMS));
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        paramsList,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    @Test
+    public void testLeaseWithBootloader() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = String.join(" ", cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567"
+                                                + " -system_build_target testSystemTarget"
+                                                + " -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567"
+                                                + " -bootloader_build_target testBootloaderTarget"
+                                                + " -bootloader_build_id BL1234567"
+                                                + " -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id";
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        List<String> paramsList = new ArrayList<>();
+        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
+        paramsList.addAll(Arrays.asList(BOOTLOADER_PARAMS));
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        paramsList,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    @Test
+    public void testLeaseOmniLabDeviceWithBootloader() throws Exception {
+        mOxygenClient =
+                new OxygenClient(
+                        Arrays.asList("java", "-jar", mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = String.join(" ", cmd);
+                                String expectedCmdString =
+                                        "java -jar "
+                                                + mOxygenJarFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567"
+                                                + " -system_build_target testSystemTarget"
+                                                + " -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567"
+                                                + " -bootloader_build_target testBootloaderTarget"
+                                                + " -bootloader_build_id BL1234567"
+                                                + " -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600"
+                                                + " -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id"
+                                                + " -use_omnilab";
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        List<String> paramsList = new ArrayList<>();
+        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
+        paramsList.addAll(Arrays.asList(BOOTLOADER_PARAMS));
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        paramsList,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    @Test
+    public void testLeaseWithHostPackage() throws Exception {
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = String.join(" ", cmd);
+                                String expectedCmdString =
+                                        mOxygenBinaryFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567 -system_build_target"
+                                                + " testSystemTarget -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567"
+                                                + " -host_package_build_target"
+                                                + " testHostPackageTarget -host_package_build_id"
+                                                + " HP1234567 -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600 -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id";
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        List<String> paramsList = new ArrayList<>();
+        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
+        paramsList.addAll(Arrays.asList(HOST_PACKAGE_PARAMS));
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        paramsList,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        false);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    @Test
+    public void testLeaseOmniLabDeviceWithHostPackage() throws Exception {
+        mOxygenClient =
+                new OxygenClient(
+                        Arrays.asList("java", "-jar", mOxygenJarFile.getAbsolutePath()), mRunUtil);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                List<String> cmd = new ArrayList<>();
+                                for (int i = 1; i < mock.getArguments().length; i++) {
+                                    cmd.add(mock.getArgument(i));
+                                }
+                                String cmdString = String.join(" ", cmd);
+                                String expectedCmdString =
+                                        "java -jar "
+                                                + mOxygenJarFile.getAbsolutePath()
+                                                + " -lease -build_branch testBranch -build_target"
+                                                + " target -build_id P1234567 -system_build_target"
+                                                + " testSystemTarget -system_build_id S1234567"
+                                                + " -kernel_build_target testKernelTarget"
+                                                + " -kernel_build_id K1234567"
+                                                + " -host_package_build_target"
+                                                + " testHostPackageTarget -host_package_build_id"
+                                                + " HP1234567 -target_region us-east"
+                                                + " -accounting_user random1234@space.com"
+                                                + " -lease_length_secs 3600 -arg1 value1"
+                                                + " -user_debug_info work_unit_id:some_id"
+                                                + " -use_omnilab";
+                                assertEquals(expectedCmdString, cmdString);
+
+                                CommandResult res = new CommandResult();
+                                res.setStatus(CommandStatus.SUCCESS);
+                                res.setStdout("");
+                                res.setStderr(EXPECTED_OUTPUT);
+                                return res;
+                            }
+                        })
+                .when(mRunUtil)
+                .runTimedCmd(Mockito.anyLong(), Mockito.any());
+        MultiMap<String, String> attributes = new MultiMap<>();
+        attributes.put("work_unit_id", "some_id");
+        List<String> paramsList = new ArrayList<>();
+        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
+        paramsList.addAll(Arrays.asList(HOST_PACKAGE_PARAMS));
+        CommandResult res =
+                mOxygenClient.leaseDevice(
+                        BUILD_TARGET,
+                        BUILD_BRANCH,
+                        BUILD_ID,
+                        TARGET_REGION,
+                        OXYGEN_ACCOUNTING_USER,
+                        LEASE_LENGTH,
+                        paramsList,
+                        mExtraOxygenArgs,
+                        attributes,
+                        GCE_CMD_TIMEOUT,
+                        true);
+        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
+        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
+    }
+
+    @Test
+    public void testCreateTunnelViaLHP_ADB() throws Exception {
+        mOxygenClientJar.createTunnelViaLHP(
+                LHPTunnelMode.ADB,
+                "1111",
+                "session",
+                "server",
+                "target_region",
+                "user",
+                "device_id",
+                mExtraOxygenArgs,
+                mMockFileOutputStream);
+        Mockito.verify(mRunUtil, times(1))
+                .runCmdInBackground(
+                        Mockito.eq(
+                                Arrays.asList(
+                                        mOxygenJarFile.getAbsolutePath(),
+                                        "-build_lab_host_proxy_tunnel",
+                                        "-server_url",
+                                        "server",
+                                        "-session_id",
+                                        "session",
+                                        "-arg1",
+                                        "value1",
+                                        "-target_region",
+                                        "target_region",
+                                        "-accounting_user",
+                                        "user",
+                                        "-use_omnilab",
+                                        "-tunnel_type",
+                                        "adb",
+                                        "-tunnel_local_port",
+                                        "1111",
+                                        "-device_id",
+                                        "device_id")),
+                        Mockito.eq(mMockFileOutputStream));
+    }
+
+    @Test
+    public void testCreateSSHTunnelViaLHP_SSH() throws Exception {
+        mOxygenClientJar.createTunnelViaLHP(
+                LHPTunnelMode.SSH,
+                "1111",
+                "session",
+                "server",
+                "target_region",
+                "user",
+                "device_id",
+                mExtraOxygenArgs,
+                mMockFileOutputStream);
+        Mockito.verify(mRunUtil, times(1))
+                .runCmdInBackground(
+                        Mockito.eq(
+                                Arrays.asList(
+                                        mOxygenJarFile.getAbsolutePath(),
+                                        "-build_lab_host_proxy_tunnel",
+                                        "-server_url",
+                                        "server",
+                                        "-session_id",
+                                        "session",
+                                        "-arg1",
+                                        "value1",
+                                        "-target_region",
+                                        "target_region",
+                                        "-accounting_user",
+                                        "user",
+                                        "-use_omnilab",
+                                        "-tunnel_type",
+                                        "ssh",
+                                        "-tunnel_local_port",
+                                        "1111",
+                                        "-device_id",
+                                        "device_id")),
+                        Mockito.eq(mMockFileOutputStream));
+    }
+
+    @Test
+    public void testCreateTunnelViaLHP_CURL() throws Exception {
+        mOxygenClientJar.createTunnelViaLHP(
+                LHPTunnelMode.CURL,
+                "1111",
+                "session",
+                "server",
+                "target_region",
+                "user",
+                "device_id",
+                mExtraOxygenArgs,
+                mMockFileOutputStream);
+        Mockito.verify(mRunUtil, times(1))
+                .runCmdInBackground(
+                        Mockito.eq(
+                                Arrays.asList(
+                                        mOxygenJarFile.getAbsolutePath(),
+                                        "-build_lab_host_proxy_tunnel",
+                                        "-server_url",
+                                        "server",
+                                        "-session_id",
+                                        "session",
+                                        "-arg1",
+                                        "value1",
+                                        "-target_region",
+                                        "target_region",
+                                        "-accounting_user",
+                                        "user",
+                                        "-use_omnilab",
+                                        "-tunnel_type",
+                                        "curl",
+                                        "-tunnel_local_port",
+                                        "1111",
+                                        "-device_id",
+                                        "device_id")),
+                        Mockito.eq(mMockFileOutputStream));
+    }
+}
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java b/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
new file mode 100644
index 000000000..345e38507
--- /dev/null
+++ b/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.avd;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+import org.junit.runners.Suite.SuiteClasses;
+
+/**
+ * A test suite for all Trade Federation avd util unit tests running under Junit4.
+ *
+ * <p>All tests listed here should be self-contained, and should not require any external
+ * dependencies.
+ */
+@RunWith(Suite.class)
+@SuiteClasses({AcloudUtilTest.class, HostOrchestratorUtilTest.class, OxygenClientTest.class})
+public class UnitTests {
+    // empty of purpose
+}
diff --git a/common_util/Android.bp b/common_util/Android.bp
index eb0ba9784..23be2c345 100644
--- a/common_util/Android.bp
+++ b/common_util/Android.bp
@@ -21,6 +21,7 @@ java_library_host {
     // Restrict visibility to only those targets that need to access it.
     visibility: [
         "//tools/tradefederation/core",
+        "//tools/tradefederation/core/avd_util",
         "//tools/tradefederation/core/clearcut_client",
         "//tools/tradefederation/core/device_build_interfaces",
         "//tools/tradefederation/core/invocation_interfaces",
@@ -41,6 +42,12 @@ java_library_host {
         "remote-execution-java-grpc",
         "bytestream-java-proto",
         "bytestream-java-grpc",
+        "google-api-java-client-assembly",
+        "google-api-services-compute",
+        "google-api-services-storage",
+        "google-auth-library-credentials-1.23.0",
+        "google-auth-library-oauth2-http-1.23.0",
+        "google-http-client-jackson2-1.28.0",
     ],
     libs: [
         "ddmlib-prebuilt",
diff --git a/common_util/com/android/tradefed/cache/ExecutableAction.java b/common_util/com/android/tradefed/cache/ExecutableAction.java
index 0fdfe57ea..1569debdc 100644
--- a/common_util/com/android/tradefed/cache/ExecutableAction.java
+++ b/common_util/com/android/tradefed/cache/ExecutableAction.java
@@ -22,8 +22,10 @@ import build.bazel.remote.execution.v2.Command.EnvironmentVariable;
 import build.bazel.remote.execution.v2.Digest;
 import build.bazel.remote.execution.v2.Platform;
 import build.bazel.remote.execution.v2.Platform.Property;
+
 import com.google.auto.value.AutoValue;
 import com.google.protobuf.Duration;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Map;
@@ -37,6 +39,9 @@ import java.util.stream.Collectors;
 @AutoValue
 public abstract class ExecutableAction {
 
+    // A silo key used to invalid stale cache.
+    private static final String SILO_CACHE_KEY = "0.0";
+
     /** Builds an {@link ExecutableAction}. */
     public static ExecutableAction create(
             File input, Iterable<String> args, Map<String, String> envVariables, long timeout)
@@ -49,7 +54,18 @@ public abstract class ExecutableAction {
                                 Platform.newBuilder()
                                         .addProperties(
                                                 Property.newBuilder()
-                                                        .setName(System.getProperty("os.name"))
+                                                        .setName(
+                                                                String.format(
+                                                                        "%s(%s)",
+                                                                        System.getProperty(
+                                                                                "os.name"),
+                                                                        System.getProperty(
+                                                                                "os.version")))
+                                                        .build())
+                                        .addProperties(
+                                                Property.newBuilder()
+                                                        .setName("cache-silo-key")
+                                                        .setValue(SILO_CACHE_KEY)
                                                         .build())
                                         .build())
                         .addAllEnvironmentVariables(
@@ -63,16 +79,22 @@ public abstract class ExecutableAction {
                                         .collect(Collectors.toList()))
                         .build();
 
+        MerkleTree inputMerkleTree = MerkleTree.buildFromDir(input);
         Action.Builder actionBuilder =
                 Action.newBuilder()
-                        .setInputRootDigest(MerkleTree.buildFromDir(input).rootDigest())
+                        .setInputRootDigest(inputMerkleTree.rootDigest())
                         .setCommandDigest(DigestCalculator.compute(command));
         if (timeout > 0L) {
             actionBuilder.setTimeout(Duration.newBuilder().setSeconds(timeout).build());
         }
 
         Action action = actionBuilder.build();
-        return new AutoValue_ExecutableAction(action, DigestCalculator.compute(action), command);
+        return new AutoValue_ExecutableAction(
+                action,
+                DigestCalculator.compute(action),
+                command,
+                DigestCalculator.compute(command),
+                inputMerkleTree);
     }
 
     public abstract Action action();
@@ -80,4 +102,8 @@ public abstract class ExecutableAction {
     public abstract Digest actionDigest();
 
     public abstract Command command();
+
+    public abstract Digest commandDigest();
+
+    public abstract MerkleTree input();
 }
diff --git a/common_util/com/android/tradefed/cache/ICacheClient.java b/common_util/com/android/tradefed/cache/ICacheClient.java
index 2fa3f5731..641c5f66d 100644
--- a/common_util/com/android/tradefed/cache/ICacheClient.java
+++ b/common_util/com/android/tradefed/cache/ICacheClient.java
@@ -29,6 +29,8 @@ public interface ICacheClient {
      *
      * @param action The action that generated the results.
      * @param actionResult The action result to associate with the {@code action}.
+     * @throws IOException if the client fails to upload cache.
+     * @throws InterruptedException if the thread that uploads cache is interrupted.
      */
     public void uploadCache(ExecutableAction action, ExecutableActionResult actionResult)
             throws IOException, InterruptedException;
diff --git a/common_util/com/android/tradefed/cache/MerkleTree.java b/common_util/com/android/tradefed/cache/MerkleTree.java
index bfa65302e..7cc74ffd5 100644
--- a/common_util/com/android/tradefed/cache/MerkleTree.java
+++ b/common_util/com/android/tradefed/cache/MerkleTree.java
@@ -20,10 +20,13 @@ import build.bazel.remote.execution.v2.Digest;
 import build.bazel.remote.execution.v2.Directory;
 import build.bazel.remote.execution.v2.DirectoryNode;
 import build.bazel.remote.execution.v2.FileNode;
+
 import com.google.auto.value.AutoValue;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.LinkedHashMap;
 import java.util.TreeSet;
 
 /** A merkle tree representation as defined by the remote execution api. */
@@ -33,18 +36,23 @@ public abstract class MerkleTree {
     /** Builds a merkle tree for the {@code directory}. */
     public static MerkleTree buildFromDir(File directory) throws IOException {
         if (!directory.exists() || !directory.isDirectory()) {
-            throw new IllegalArgumentException("Directory does not exist or is not a Directory!");
+            throw new IllegalArgumentException(
+                    String.format("Directory %s does not exist or is not a Directory!", directory));
         }
 
+        LinkedHashMap<Digest, File> digestToFile = new LinkedHashMap<>();
+        LinkedHashMap<Digest, Directory> digestToSubdir = new LinkedHashMap<>();
         Directory.Builder rootBuilder = Directory.newBuilder();
 
         // Sort the files, so that two equivalent directory messages have matching digests.
-        TreeSet<File> files = new TreeSet(Arrays.asList(directory.listFiles()));
+        TreeSet<File> files = new TreeSet<>(Arrays.asList(directory.listFiles()));
         for (File f : files) {
             if (f.isFile()) {
+                Digest digest = DigestCalculator.compute(f);
+                digestToFile.putIfAbsent(digest, f);
                 rootBuilder.addFiles(
                         FileNode.newBuilder()
-                                .setDigest(DigestCalculator.compute(f))
+                                .setDigest(digest)
                                 .setName(f.getName())
                                 .setIsExecutable(f.canExecute()));
             }
@@ -54,19 +62,36 @@ public abstract class MerkleTree {
                         DirectoryNode.newBuilder()
                                 .setDigest(childTree.rootDigest())
                                 .setName(childTree.rootName()));
+                digestToSubdir.putIfAbsent(childTree.rootDigest(), childTree.root());
+                childTree.digestToSubdir().forEach(digestToSubdir::putIfAbsent);
+                childTree.digestToFile().forEach(digestToFile::putIfAbsent);
             }
         }
 
+        Directory root = rootBuilder.build();
         return new AutoValue_MerkleTree(
-                directory.getName(), DigestCalculator.compute(rootBuilder.build()));
+                directory.getName(),
+                root,
+                DigestCalculator.compute(root),
+                digestToFile,
+                digestToSubdir);
     }
 
     /** The name of the root {@link Directory} of this Merkle tree. */
     public abstract String rootName();
 
+    /** The root {@link Directory} of this Merkle tree. */
+    public abstract Directory root();
+
     /**
      * The {@link Digest} of the root {@link Directory} of this Merkle tree. Note, this is only
      * consumed by the cache client.
      */
     public abstract Digest rootDigest();
+
+    /** The map of digests to files within this merkle tree. */
+    public abstract LinkedHashMap<Digest, File> digestToFile();
+
+    /** The map of digests to Sub-directories within this merkle tree. */
+    public abstract LinkedHashMap<Digest, Directory> digestToSubdir();
 }
diff --git a/common_util/com/android/tradefed/cache/UploadManifest.java b/common_util/com/android/tradefed/cache/UploadManifest.java
new file mode 100644
index 000000000..4df5bd721
--- /dev/null
+++ b/common_util/com/android/tradefed/cache/UploadManifest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.cache;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableMap;
+import com.google.protobuf.ByteString;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+
+/** A manifest of the BLOBs and files to upload. */
+@AutoValue
+public abstract class UploadManifest {
+    public abstract ImmutableMap<Digest, File> digestToFile();
+
+    public abstract ImmutableMap<Digest, ByteString> digestToBlob();
+
+    public static Builder builder() {
+        return new AutoValue_UploadManifest.Builder();
+    }
+
+    @AutoValue.Builder
+    public abstract static class Builder {
+        private final ImmutableMap.Builder<Digest, File> mDigestToFileBuilder =
+                ImmutableMap.builder();
+
+        private final ImmutableMap.Builder<Digest, ByteString> mDigestToBlobBuilder =
+                ImmutableMap.builder();
+
+        public final Builder addFile(Digest digest, File file) throws IOException {
+            if (!file.exists() || !file.isFile()) {
+                throw new IOException("File does not exist or is not a file!");
+            }
+            mDigestToFileBuilder.put(digest, file);
+            return this;
+        }
+
+        public final Builder addFiles(Map<Digest, File> digestToFile) throws IOException {
+            for (Map.Entry<Digest, File> entry : digestToFile.entrySet()) {
+                addFile(entry.getKey(), entry.getValue());
+            }
+            return this;
+        }
+
+        public final Builder addBlob(Digest digest, ByteString blob) {
+            mDigestToBlobBuilder.put(digest, blob);
+            return this;
+        }
+
+        public final Builder addBlobs(Map<Digest, ByteString> digestToBlob) {
+            mDigestToBlobBuilder.putAll(digestToBlob);
+            return this;
+        }
+
+        public abstract Builder setDigestToFile(ImmutableMap<Digest, File> digestToFile);
+
+        public abstract Builder setDigestToBlob(ImmutableMap<Digest, ByteString> digestToBlob);
+
+        public abstract UploadManifest autoBuild();
+
+        public UploadManifest build() {
+            return setDigestToFile(mDigestToFileBuilder.buildKeepingLast())
+                    .setDigestToBlob(mDigestToBlobBuilder.buildKeepingLast())
+                    .autoBuild();
+        }
+    }
+}
diff --git a/common_util/com/android/tradefed/cache/remote/ByteStreamDownloader.java b/common_util/com/android/tradefed/cache/remote/ByteStreamDownloader.java
index 67536d97c..a4599435b 100644
--- a/common_util/com/android/tradefed/cache/remote/ByteStreamDownloader.java
+++ b/common_util/com/android/tradefed/cache/remote/ByteStreamDownloader.java
@@ -52,7 +52,7 @@ public class ByteStreamDownloader {
             Channel channel,
             CallCredentials callCredentials,
             Duration callTimeout) {
-        checkArgument(callTimeout.getSeconds() > 0, "callTimeout must be gt 0.");
+        checkArgument(callTimeout.getSeconds() > 0, "callTimeout must be greater than 0.");
         checkArgument(!Strings.isNullOrEmpty(instanceName), "instanceName must be specified.");
         mInstanceName = instanceName;
         mChannel = channel;
diff --git a/common_util/com/android/tradefed/cache/remote/ByteStreamUploader.java b/common_util/com/android/tradefed/cache/remote/ByteStreamUploader.java
new file mode 100644
index 000000000..6c99fa64d
--- /dev/null
+++ b/common_util/com/android/tradefed/cache/remote/ByteStreamUploader.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.cache.remote;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import build.bazel.remote.execution.v2.Digest;
+import com.google.bytestream.ByteStreamGrpc;
+import com.google.bytestream.ByteStreamGrpc.ByteStreamStub;
+import com.google.bytestream.ByteStreamProto.WriteRequest;
+import com.google.bytestream.ByteStreamProto.WriteResponse;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import com.google.protobuf.ByteString;
+import io.grpc.CallCredentials;
+import io.grpc.Channel;
+import io.grpc.Status.Code;
+import io.grpc.StatusRuntimeException;
+import io.grpc.stub.ClientCallStreamObserver;
+import io.grpc.stub.ClientResponseObserver;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.time.Duration;
+import java.util.concurrent.TimeUnit;
+import java.util.UUID;
+
+/** A client implementing the {@code Write} method of the {@code ByteStream} gRPC service. */
+public class ByteStreamUploader {
+
+    // Uses 16KB as the default chunk size that is also used by Bazel.
+    private static final int DEFAULT_CHUNK_SIZE = 1024 * 16;
+    private final String mInstanceName;
+    private final Channel mChannel;
+    private final CallCredentials mCallCredentials;
+    private final Duration mCallTimeout;
+    private final int mChunkSize;
+
+    public ByteStreamUploader(
+            String instanceName,
+            Channel channel,
+            CallCredentials callCredentials,
+            Duration callTimeout) {
+        this(instanceName, channel, callCredentials, callTimeout, DEFAULT_CHUNK_SIZE);
+    }
+
+    @VisibleForTesting
+    ByteStreamUploader(
+            String instanceName,
+            Channel channel,
+            CallCredentials callCredentials,
+            Duration callTimeout,
+            int chunkSize) {
+        checkArgument(callTimeout.getSeconds() > 0, "callTimeout must be greater than 0.");
+        checkArgument(!Strings.isNullOrEmpty(instanceName), "instanceName must be specified.");
+        mInstanceName = instanceName;
+        mChannel = channel;
+        mCallCredentials = callCredentials;
+        mCallTimeout = callTimeout;
+        mChunkSize = chunkSize;
+    }
+
+    /**
+     * Uploads a BLOB by the remote {@code ByteStream} service.
+     *
+     * @param digest the digest of the BLOB to upload.
+     * @param blob the BLOB to upload.
+     */
+    public ListenableFuture<Void> uploadBlob(Digest digest, ByteString blob) {
+        return uploadBlob(digest, new Chunker(blob.newInput(), digest.getSizeBytes(), mChunkSize));
+    }
+
+    /**
+     * Uploads a file by the remote {@code ByteStream} service.
+     *
+     * @param digest the digest of the file to upload.
+     * @param file the file to upload.
+     */
+    public ListenableFuture<Void> uploadFile(Digest digest, File file) {
+        try {
+            return uploadBlob(
+                    digest,
+                    new Chunker(new FileInputStream(file), digest.getSizeBytes(), mChunkSize));
+        } catch (IOException e) {
+            return Futures.immediateFailedFuture(e);
+        }
+    }
+
+    private ListenableFuture<Void> uploadBlob(Digest digest, Chunker chunker) {
+        String resourceName = getResourceName(digest);
+        return Futures.catchingAsync(
+                Futures.transformAsync(
+                        write(resourceName, chunker),
+                        committedSize ->
+                                committedSize == digest.getSizeBytes()
+                                        ? Futures.immediateVoidFuture()
+                                        : Futures.immediateFailedFuture(
+                                                new IOException(
+                                                        String.format(
+                                                                "write incomplete: committed_size"
+                                                                        + " %d for %d total - %s",
+                                                                committedSize,
+                                                                digest.getSizeBytes(),
+                                                                resourceName))),
+                        MoreExecutors.directExecutor()),
+                StatusRuntimeException.class,
+                (sre) ->
+                        sre.getStatus().getCode() == Code.ALREADY_EXISTS
+                                ? Futures.immediateVoidFuture()
+                                : Futures.immediateFailedFuture(
+                                        new IOException(
+                                                String.format(
+                                                        "Error while uploading artifact with digest"
+                                                                + " '%s/%s'",
+                                                        digest.getHash(), digest.getSizeBytes()),
+                                                sre)),
+                MoreExecutors.directExecutor());
+    }
+
+    private ListenableFuture<Long> write(String resourceName, Chunker chunker) {
+        SettableFuture<Long> uploadResult = SettableFuture.create();
+        bsAsyncStub().write(new Writer(resourceName, uploadResult, chunker));
+        return uploadResult;
+    }
+
+    /** A writer used to stream the BLOB to the remote service and handle the response. */
+    private static final class Writer
+            implements ClientResponseObserver<WriteRequest, WriteResponse>, Runnable {
+        private final String mResourceName;
+        private final SettableFuture<Long> mUploadResult;
+        private final Chunker mChunker;
+        private ClientCallStreamObserver<WriteRequest> mRequestObserver;
+        private long mCommittedSize = -1;
+        private boolean mFirstRequest = true;
+        private boolean mFinishedWriting;
+
+        private Writer(String resourceName, SettableFuture<Long> uploadResult, Chunker chunker) {
+            mResourceName = resourceName;
+            mUploadResult = uploadResult;
+            mChunker = chunker;
+        }
+
+        @Override
+        public void beforeStart(ClientCallStreamObserver<WriteRequest> requestObserver) {
+            mRequestObserver = requestObserver;
+            mUploadResult.addListener(
+                    () -> {
+                        if (mUploadResult.isCancelled()) {
+                            mRequestObserver.cancel("cancelled by user", null);
+                        }
+                    },
+                    MoreExecutors.directExecutor());
+            mRequestObserver.setOnReadyHandler(this);
+        }
+
+        @Override
+        public void run() {
+            while (mRequestObserver.isReady()) {
+                WriteRequest.Builder request = WriteRequest.newBuilder();
+                if (mFirstRequest) {
+                    // Resource name only needs to be set on the first write for each file.
+                    request.setResourceName(mResourceName);
+                    mFirstRequest = false;
+                }
+                Chunker.Chunk chunk;
+                try {
+                    chunk = mChunker.next();
+                } catch (IOException e) {
+                    mRequestObserver.cancel("Failed to read next chunk.", e);
+                    return;
+                }
+                boolean isLastChunk = !mChunker.hasNext();
+                mRequestObserver.onNext(
+                        request.setData(chunk.getData())
+                                .setWriteOffset(chunk.getOffset())
+                                .setFinishWrite(isLastChunk)
+                                .build());
+                if (isLastChunk) {
+                    mRequestObserver.onCompleted();
+                    mFinishedWriting = true;
+                }
+            }
+        }
+
+        @Override
+        public void onNext(WriteResponse response) {
+            mCommittedSize = response.getCommittedSize();
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            mUploadResult.setException(t);
+        }
+
+        @Override
+        public void onCompleted() {
+            // Server completed successfully before we finished writing all the data, meaning the
+            // blob already exists.
+            if (mFinishedWriting) {
+                mRequestObserver.cancel("server has returned early", null);
+            }
+            mUploadResult.set(mCommittedSize);
+        }
+    }
+
+    private ByteStreamStub bsAsyncStub() {
+        return ByteStreamGrpc.newStub(mChannel)
+                .withCallCredentials(mCallCredentials)
+                .withDeadlineAfter(mCallTimeout.getSeconds(), TimeUnit.SECONDS);
+    }
+
+    private String getResourceName(Digest digest) {
+        return String.format(
+                "%s/uploads/%s/blobs/%s/%d",
+                mInstanceName, UUID.randomUUID(), digest.getHash(), digest.getSizeBytes());
+    }
+}
diff --git a/common_util/com/android/tradefed/cache/remote/Chunker.java b/common_util/com/android/tradefed/cache/remote/Chunker.java
new file mode 100644
index 000000000..7dfb228f3
--- /dev/null
+++ b/common_util/com/android/tradefed/cache/remote/Chunker.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.cache.remote;
+
+import static java.lang.Math.min;
+
+import com.google.protobuf.ByteString;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.NoSuchElementException;
+
+/**
+ * Splits a {@code blob} into one or more {@link Chunk}s of at most {@code chunkSize} bytes.
+ *
+ * <p>After {@code blob} has been fully consumed, that is until {@link #hasNext()} returns {@code
+ * false}, the chunker closes the underlying data source (i.e. file) itself.
+ */
+public final class Chunker {
+
+    /** A piece of a blob. */
+    public static final class Chunk {
+
+        private final long mOffset;
+        private final ByteString mData;
+
+        private Chunk(ByteString data, long offset) {
+            mData = data;
+            mOffset = offset;
+        }
+
+        public long getOffset() {
+            return mOffset;
+        }
+
+        public ByteString getData() {
+            return mData;
+        }
+    }
+
+    private InputStream mBlob;
+    private long mSize;
+    private int mChunkSize;
+    private long mOffset;
+    private byte[] mChunkBuffer;
+
+    public Chunker(InputStream blob, long size, int chunkSize) {
+        mBlob = blob;
+        mSize = size;
+        mChunkSize = chunkSize;
+        mOffset = 0;
+        mChunkBuffer = new byte[(int) min(size, chunkSize)];
+    }
+
+    /**
+     * Returns {@code true} if a subsequent call to {@link #next()} returns a {@link Chunk} object.
+     */
+    public boolean hasNext() {
+        return mBlob != null;
+    }
+
+    /**
+     * Returns the next {@link Chunk} or throws a {@link NoSuchElementException} if no data is left.
+     *
+     * <p>Always call {@link #hasNext()} before calling this method.
+     *
+     * <p>Zero byte inputs are treated special. Instead of throwing a {@link NoSuchElementException}
+     * on the first call to {@link #next()}, a {@link Chunk} with an empty {@link ByteString} is
+     * returned.
+     */
+    public Chunk next() throws IOException {
+        if (!hasNext()) {
+            throw new NoSuchElementException();
+        }
+
+        if (mSize == 0) {
+            close();
+            return new Chunk(ByteString.EMPTY, 0);
+        }
+
+        long offsetBefore = mOffset;
+
+        int bytesRead = read();
+
+        ByteString chunk = ByteString.copyFrom(mChunkBuffer, 0, bytesRead);
+
+        mOffset += bytesRead;
+        if (mOffset >= mSize) {
+            close();
+        }
+
+        return new Chunk(chunk, offsetBefore);
+    }
+
+    /** Attempts reading at most a full chunk and stores it in the chunk buffer. */
+    private int read() throws IOException {
+        int count = 0;
+        while (count < mChunkBuffer.length) {
+            int c = mBlob.read(mChunkBuffer, count, mChunkBuffer.length - count);
+            if (c < 0) {
+                close();
+                break;
+            }
+            count += c;
+        }
+        return count;
+    }
+
+    /** Closes the input stream. */
+    private void close() throws IOException {
+        if (mBlob != null) {
+            mBlob.close();
+            mBlob = null;
+        }
+    }
+}
diff --git a/common_util/com/android/tradefed/cache/remote/RemoteCacheClient.java b/common_util/com/android/tradefed/cache/remote/RemoteCacheClient.java
index 706b1ee52..ece39c2bc 100644
--- a/common_util/com/android/tradefed/cache/remote/RemoteCacheClient.java
+++ b/common_util/com/android/tradefed/cache/remote/RemoteCacheClient.java
@@ -16,85 +16,153 @@
 
 package com.android.tradefed.cache.remote;
 
-import build.bazel.remote.execution.v2.ActionCacheGrpc;
-import build.bazel.remote.execution.v2.ActionCacheGrpc.ActionCacheFutureStub;
-import build.bazel.remote.execution.v2.ActionResult;
-import build.bazel.remote.execution.v2.Digest;
-import build.bazel.remote.execution.v2.GetActionResultRequest;
-import build.bazel.remote.execution.v2.UpdateActionResultRequest;
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.android.tradefed.cache.DigestCalculator;
 import com.android.tradefed.cache.ExecutableAction;
 import com.android.tradefed.cache.ExecutableActionResult;
 import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.cache.MerkleTree;
+import com.android.tradefed.cache.UploadManifest;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.util.FileUtil;
+
+import build.bazel.remote.execution.v2.ActionCacheGrpc;
+import build.bazel.remote.execution.v2.ActionCacheGrpc.ActionCacheFutureStub;
+import build.bazel.remote.execution.v2.ActionResult;
+import build.bazel.remote.execution.v2.ContentAddressableStorageGrpc;
+import build.bazel.remote.execution.v2.ContentAddressableStorageGrpc.ContentAddressableStorageFutureStub;
+import build.bazel.remote.execution.v2.Digest;
+import build.bazel.remote.execution.v2.FindMissingBlobsRequest;
+import build.bazel.remote.execution.v2.FindMissingBlobsResponse;
+import build.bazel.remote.execution.v2.GetActionResultRequest;
+import build.bazel.remote.execution.v2.UpdateActionResultRequest;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
+
 import io.grpc.CallCredentials;
 import io.grpc.ManagedChannel;
 import io.grpc.Status.Code;
 import io.grpc.StatusRuntimeException;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.time.Duration;
 import java.util.ArrayList;
+import java.util.List;
+import java.util.Map.Entry;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
-import java.util.List;
+import java.util.stream.Collectors;
 
 /** A RemoteActionCache implementation that uses gRPC calls to a remote API server. */
 public class RemoteCacheClient implements ICacheClient {
-    private static final Duration REMOTE_TIMEOUT = Duration.ofSeconds(60);
+    public static final Duration REMOTE_TIMEOUT = Duration.ofSeconds(60);
     private final File mWorkFolder;
     private final String mInstanceName;
     private final ManagedChannel mChannel;
     private final CallCredentials mCallCredentials;
     private final ByteStreamDownloader mDownloader;
+    private final ByteStreamUploader mUploader;
+    private final int mMaxMissingBlobsDigestsPerMessage;
 
     public RemoteCacheClient(
             File workFolder,
             String instanceName,
             ManagedChannel channel,
             CallCredentials callCredentials,
-            ByteStreamDownloader downloader) {
+            ByteStreamDownloader downloader,
+            ByteStreamUploader uploader) {
+        checkArgument(
+                workFolder.exists() && workFolder.isDirectory(),
+                "a work folder must be specified.");
+        checkArgument(!Strings.isNullOrEmpty(instanceName), "instanceName must be specified.");
         mWorkFolder = workFolder;
         mInstanceName = instanceName;
         mChannel = channel;
         mCallCredentials = callCredentials;
         mDownloader = downloader;
+        mUploader = uploader;
+        mMaxMissingBlobsDigestsPerMessage = computeMaxMissingBlobsDigestsPerMessage();
     }
 
     /** {@inheritDoc} */
     @Override
     public void uploadCache(ExecutableAction action, ExecutableActionResult actionResult)
             throws IOException, InterruptedException {
+        MerkleTree input = action.input();
+        UploadManifest.Builder manifestBuilder =
+                UploadManifest.builder()
+                        .addFiles(input.digestToFile())
+                        .addBlob(input.rootDigest(), input.root().toByteString())
+                        .addBlobs(
+                                input.digestToSubdir().entrySet().stream()
+                                        .collect(
+                                                Collectors.toMap(
+                                                        Entry::getKey,
+                                                        e -> e.getValue().toByteString())))
+                        .addBlob(action.commandDigest(), action.command().toByteString())
+                        .addBlob(action.actionDigest(), action.action().toByteString());
         ActionResult.Builder actionResultBuilder =
                 ActionResult.newBuilder().setExitCode(actionResult.exitCode());
 
         if (actionResult.stdOut() != null) {
-            actionResultBuilder.setStdoutDigest(DigestCalculator.compute(actionResult.stdOut()));
+            Digest stdOutDigest = DigestCalculator.compute(actionResult.stdOut());
+            actionResultBuilder.setStdoutDigest(stdOutDigest);
+            manifestBuilder.addFile(stdOutDigest, actionResult.stdOut());
         }
 
         if (actionResult.stdErr() != null) {
-            actionResultBuilder.setStderrDigest(DigestCalculator.compute(actionResult.stdErr()));
+            Digest stdErrDigest = DigestCalculator.compute(actionResult.stdErr());
+            actionResultBuilder.setStderrDigest(stdErrDigest);
+            manifestBuilder.addFile(stdErrDigest, actionResult.stdErr());
         }
 
-        getFromFuture(
-                Futures.catchingAsync(
-                        acFutureStub()
-                                .updateActionResult(
-                                        UpdateActionResultRequest.newBuilder()
-                                                .setInstanceName(mInstanceName)
-                                                .setDigestFunction(DigestCalculator.DIGEST_FUNCTION)
-                                                .setActionDigest(action.actionDigest())
-                                                .setActionResult(actionResultBuilder.build())
-                                                .build()),
-                        StatusRuntimeException.class,
-                        (sre) -> Futures.immediateFailedFuture(new IOException(sre)),
-                        MoreExecutors.directExecutor()));
+        UploadManifest manifest = manifestBuilder.build();
+
+        try (CloseableTraceScope ignored = new CloseableTraceScope("upload blobs")) {
+            List<Digest> digests = new ArrayList<>();
+            digests.addAll(manifest.digestToFile().keySet());
+            digests.addAll(manifest.digestToBlob().keySet());
+            ImmutableSet<Digest> missingDigests = getFromFuture(findMissingDigests(digests));
+
+            List<ListenableFuture<Void>> uploads = new ArrayList<>();
+            uploads.addAll(
+                    manifest.digestToFile().entrySet().stream()
+                            .filter(e -> missingDigests.contains(e.getKey()))
+                            .map(e -> mUploader.uploadFile(e.getKey(), e.getValue()))
+                            .collect(Collectors.toList()));
+            uploads.addAll(
+                    manifest.digestToBlob().entrySet().stream()
+                            .filter(e -> missingDigests.contains(e.getKey()))
+                            .map(e -> mUploader.uploadBlob(e.getKey(), e.getValue()))
+                            .collect(Collectors.toList()));
+            waitForBulkTransfers(uploads);
+        }
+
+        try (CloseableTraceScope ignored = new CloseableTraceScope("update action result")) {
+            getFromFuture(
+                    Futures.catchingAsync(
+                            acFutureStub()
+                                    .updateActionResult(
+                                            UpdateActionResultRequest.newBuilder()
+                                                    .setInstanceName(mInstanceName)
+                                                    .setDigestFunction(
+                                                            DigestCalculator.DIGEST_FUNCTION)
+                                                    .setActionDigest(action.actionDigest())
+                                                    .setActionResult(actionResultBuilder.build())
+                                                    .build()),
+                            StatusRuntimeException.class,
+                            (sre) -> Futures.immediateFailedFuture(new IOException(sre)),
+                            MoreExecutors.directExecutor()));
+        }
     }
 
     /** {@inheritDoc} */
@@ -159,7 +227,7 @@ public class RemoteCacheClient implements ICacheClient {
                 downloads.add(mDownloader.downloadBlob(stderrDigest, stderrStream));
             }
             // TODO(b/346606200): Track download metrics.
-            waitForDownloads(downloads);
+            waitForBulkTransfers(downloads);
         } finally {
             if (stdoutStream != null) {
                 stdoutStream.close();
@@ -171,6 +239,85 @@ public class RemoteCacheClient implements ICacheClient {
         return ExecutableActionResult.create(actionResult.getExitCode(), stdout, stderr);
     }
 
+    private ListenableFuture<ImmutableSet<Digest>> findMissingDigests(Iterable<Digest> digests) {
+        if (Iterables.isEmpty(digests)) {
+            return Futures.immediateFuture(ImmutableSet.of());
+        }
+        // Need to potentially split the digests into multiple requests.
+        FindMissingBlobsRequest.Builder requestBuilder =
+                FindMissingBlobsRequest.newBuilder()
+                        .setInstanceName(mInstanceName)
+                        .setDigestFunction(DigestCalculator.DIGEST_FUNCTION);
+        List<ListenableFuture<FindMissingBlobsResponse>> getMissingDigestCalls = new ArrayList<>();
+        for (Digest digest : digests) {
+            requestBuilder.addBlobDigests(digest);
+            if (requestBuilder.getBlobDigestsCount() == mMaxMissingBlobsDigestsPerMessage) {
+                getMissingDigestCalls.add(getMissingDigests(requestBuilder.build()));
+                requestBuilder.clearBlobDigests();
+            }
+        }
+
+        if (requestBuilder.getBlobDigestsCount() > 0) {
+            getMissingDigestCalls.add(getMissingDigests(requestBuilder.build()));
+        }
+
+        ListenableFuture<ImmutableSet<Digest>> success =
+                Futures.whenAllSucceed(getMissingDigestCalls)
+                        .call(
+                                () -> {
+                                    ImmutableSet.Builder<Digest> result = ImmutableSet.builder();
+                                    for (ListenableFuture<FindMissingBlobsResponse> callFuture :
+                                            getMissingDigestCalls) {
+                                        result.addAll(callFuture.get().getMissingBlobDigestsList());
+                                    }
+                                    return result.build();
+                                },
+                                MoreExecutors.directExecutor());
+
+        return Futures.catchingAsync(
+                success,
+                RuntimeException.class,
+                (e) ->
+                        Futures.immediateFailedFuture(
+                                new IOException(
+                                        String.format(
+                                                "Failed to find missing blobs: %s", e.getMessage()),
+                                        e)),
+                MoreExecutors.directExecutor());
+    }
+
+    private ListenableFuture<FindMissingBlobsResponse> getMissingDigests(
+            FindMissingBlobsRequest request) {
+        return casFutureStub().findMissingBlobs(request);
+    }
+
+    private ContentAddressableStorageFutureStub casFutureStub() {
+        return ContentAddressableStorageGrpc.newFutureStub(mChannel)
+                .withCallCredentials(mCallCredentials)
+                .withDeadlineAfter(REMOTE_TIMEOUT.getSeconds(), TimeUnit.SECONDS);
+    }
+
+    private int computeMaxMissingBlobsDigestsPerMessage() {
+        final int overhead =
+                FindMissingBlobsRequest.newBuilder()
+                        .setInstanceName(mInstanceName)
+                        .setDigestFunction(DigestCalculator.DIGEST_FUNCTION)
+                        .build()
+                        .getSerializedSize();
+        final int tagSize =
+                FindMissingBlobsRequest.newBuilder()
+                                .addBlobDigests(Digest.getDefaultInstance())
+                                .build()
+                                .getSerializedSize()
+                        - FindMissingBlobsRequest.getDefaultInstance().getSerializedSize();
+        // All non-empty digests of SHA256 have the same size.
+        final int digestSize =
+                DigestCalculator.compute(new byte[] {1}).getSerializedSize() + tagSize;
+        // Set the max message size to 1MB that is used by Bazel (The default max message size is
+        // 4MB).
+        return (1024 * 1024 - overhead) / digestSize;
+    }
+
     private ActionCacheFutureStub acFutureStub() {
         ActionCacheFutureStub stub =
                 ActionCacheGrpc.newFutureStub(mChannel)
@@ -198,13 +345,13 @@ public class RemoteCacheClient implements ICacheClient {
         }
     }
 
-    private static void waitForDownloads(Iterable<? extends ListenableFuture<?>> downloads)
+    private static void waitForBulkTransfers(Iterable<? extends ListenableFuture<?>> transfers)
             throws IOException, InterruptedException {
         boolean interrupted = Thread.currentThread().isInterrupted();
         InterruptedException interruptedException = null;
-        for (ListenableFuture<?> download : downloads) {
+        for (ListenableFuture<?> transfer : transfers) {
             try {
-                getFromFuture(download);
+                getFromFuture(transfer);
             } catch (InterruptedException e) {
                 interrupted = Thread.interrupted() || interrupted;
                 interruptedException = e;
diff --git a/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java b/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
index c3bf92cd2..493d98593 100644
--- a/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
+++ b/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
@@ -183,6 +183,7 @@ public class InvocationMetricLogger {
         CF_OXYGEN_SERVER_URL("cf_oxygen_server_url", false),
         CF_OXYGEN_SESSION_ID("cf_oxygen_session_id", false),
         CF_OXYGEN_VERSION("cf_oxygen_version", false),
+        CF_OXYGENATION_VERSION("cf_oxygenation_version", false),
         CRASH_FAILURES("crash_failures", true),
         UNCAUGHT_CRASH_FAILURES("uncaught_crash_failures", true),
         TEST_CRASH_FAILURES("test_crash_failures", true),
@@ -253,16 +254,20 @@ public class InvocationMetricLogger {
         ART_RUN_TEST_CHECKER_COMMAND_TIME_MS("art_run_test_checker_command_time_ms", true),
 
         // CAS downloader metrics
+        CAS_VERSION("cas_version", false),
+        CAS_DOWNLOAD_ERRORS("cas_download_errors", true),
         // Name of files downloaded by CAS downloader.
         CAS_DOWNLOAD_FILES("cas_download_files", true),
         CAS_DOWNLOAD_FILE_SUCCESS_COUNT("cas_download_file_success_count", true),
         CAS_DOWNLOAD_FILE_FAIL_COUNT("cas_download_file_fail_count", true),
         CAS_DOWNLOAD_TIME("cas_download_time_ms", true),
+        CAS_DOWNLOAD_START_TIMESTAMP("cas_download_start_timestamp", true),
         // Records the wait time caused by CAS downloader concurrency limitation.
         CAS_DOWNLOAD_WAIT_TIME("cas_download_wait_time_ms", true),
         CAS_LOCK_TIMEOUTS("cas_lock_timeout", true),
         CAS_CACHE_FALLBACK_COUNT("cas_cache_fallback_count", true),
         CAS_TIMEOUT_COUNT("cas_timeout_count", true),
+        CAS_RETRY_BUDGET_EXHAUSTED_COUNT("cas_retry_budget_exhausted_count", true),
         // Records cache hit metrics
         CAS_DOWNLOAD_HOT_BYTES("cas_download_hot_bytes", true),
         CAS_DOWNLOAD_COLD_BYTES("cas_download_cold_bytes", true),
@@ -275,6 +280,10 @@ public class InvocationMetricLogger {
         CAS_DOWNLOAD_NFS_LOCAL_CACHE_CONCURRENCY("cas_download_nfs_local_cache_concurrency", false),
         CAS_DOWNLOAD_ACQUIRE_LOCAL_CACHE_LOCK_TIME(
                 "cas_download_acquire_local_cache_lock_time_ms", true),
+        CAS_DOWNLOAD_DIR_RETRIEVE_TIME("cas_download_dir_retrieve_time_ms", true),
+        CAS_DOWNLOAD_DIR_PREPARE_TIME("cas_download_dir_prepare_time_ms", true),
+        CAS_DOWNLOAD_FILE_DOWNLOAD_TIME("cas_download_file_download_time_ms", true),
+        CAS_DOWNLOAD_CHUNK_RESTORE_TIME("cas_download_chunk_restore_time_ms", true),
 
         // Download Cache
         CACHE_HIT_COUNT("cache_hit_count", true),
@@ -319,6 +328,7 @@ public class InvocationMetricLogger {
         TEST_ARTIFACT_NOT_CHANGED("test_artifact_not_changed", true),
         PURE_DEVICE_IMAGE_UNCHANGED("pure_device_image_unchanged", true),
         TEST_ARTIFACT_CHANGE_ONLY("test_artifact_change_only", true),
+        PARTIAL_SKIP_MODULE_UNCHANGED_COUNT("partial_skip_module_unchanged_count", true),
         WORKDIR_DIFFS_IN_COMMON("workdir_diffs_in_common", true),
         WOKRDIR_MODULE_WITH_DIFFS("workdir_module_with_diffs", true),
         WORKDIR_UNCHANGED_MODULES("workdir_unchanged_modules", true),
@@ -351,6 +361,8 @@ public class InvocationMetricLogger {
         INCREMENTAL_SNAPUSERD_WRITE_BLOCKING_TIME(
                 "incremental_snapuserd_write_blocking_time", true),
         INCREMENTAL_FALLBACK_REASON("incremental_fallback_reason", true),
+        INCREMENTAL_RECOVERY_FALLBACK("incremental_recovery_fallback", true),
+        INCREMENTAL_NEW_FLOW("incremental_new_flow", true),
         DEVICE_IMAGE_CACHE_MISMATCH("device_image_cache_mismatch", true),
         DEVICE_IMAGE_CACHE_ORIGIN("device_image_cache_origin", true),
 
@@ -361,6 +373,8 @@ public class InvocationMetricLogger {
         SILENT_INVOCATION_SKIP_COUNT("silent_invocation_skip_count", true),
         DEMOTION_FILTERS_RECEIVED_COUNT("demotion_filters_received_count", true),
         DEMOTION_ERROR_RESPONSE("demotion_error_response", true),
+        SEARCH_ARTIFACT_FAILURE_COUNT("search_artifact_failure_count", true),
+        RESOLVE_SYMLINK_COUNT("resolve_symlink_count", true),
 
         // Following are trace events also reporting as metrics
         invocation_warm_up("invocation_warm_up", true),
@@ -388,6 +402,12 @@ public class InvocationMetricLogger {
 
         // Test caching metrics
         CACHED_MODULE_RESULTS_COUNT("cached_module_results_count", true),
+
+        // Module level caching
+        MODULE_RESULTS_CHECKING_CACHE("module_results_checking_cache", true),
+        MODULE_RESULTS_CACHE_HIT("module_results_cache_hit", true),
+        MODULE_CACHE_NO_DIR("module_cache_no_dir", true),
+        MODULE_RESULTS_CACHE_DEVICE_MISMATCH("module_results_cache_device_mismatch", true),
         ;
 
         private final String mKeyName;
diff --git a/common_util/com/android/tradefed/log/Log.java b/common_util/com/android/tradefed/log/Log.java
new file mode 100644
index 000000000..8656f7bf9
--- /dev/null
+++ b/common_util/com/android/tradefed/log/Log.java
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.log;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * Log class that mirrors the API in main Android sources.
+ *
+ * <p>Default behavior outputs the log to {@link System#out}. Use {@link #setLogOutput(ILogOutput)}
+ * to redirect the log somewhere else.
+ */
+public final class Log {
+
+    /** Log Level enum. */
+    public enum LogLevel {
+        VERBOSE(2, "verbose", 'V'), // $NON-NLS-1$
+        DEBUG(3, "debug", 'D'), // $NON-NLS-1$
+        INFO(4, "info", 'I'), // $NON-NLS-1$
+        WARN(5, "warn", 'W'), // $NON-NLS-1$
+        ERROR(6, "error", 'E'), // $NON-NLS-1$
+        ASSERT(7, "assert", 'A'); // $NON-NLS-1$
+
+        private int mPriorityLevel;
+        private String mStringValue;
+        private char mPriorityLetter;
+
+        LogLevel(int intPriority, String stringValue, char priorityChar) {
+            mPriorityLevel = intPriority;
+            mStringValue = stringValue;
+            mPriorityLetter = priorityChar;
+        }
+
+        public static LogLevel getByString(String value) {
+            for (LogLevel mode : values()) {
+                if (mode.mStringValue.equals(value)) {
+                    return mode;
+                }
+            }
+
+            return null;
+        }
+
+        /**
+         * Returns the {@link LogLevel} enum matching the specified letter.
+         *
+         * @param letter the letter matching a <code>LogLevel</code> enum
+         * @return a <code>LogLevel</code> object or <code>null</code> if no match were found.
+         */
+        public static LogLevel getByLetter(char letter) {
+            for (LogLevel mode : values()) {
+                if (mode.mPriorityLetter == letter) {
+                    return mode;
+                }
+            }
+
+            return null;
+        }
+
+        /**
+         * Returns the {@link LogLevel} enum matching the specified letter.
+         *
+         * <p>The letter is passed as a {@link String} argument, but only the first character is
+         * used.
+         *
+         * @param letter the letter matching a <code>LogLevel</code> enum
+         * @return a <code>LogLevel</code> object or <code>null</code> if no match were found.
+         */
+        public static LogLevel getByLetterString(String letter) {
+            if (!letter.isEmpty()) {
+                return getByLetter(letter.charAt(0));
+            }
+
+            return null;
+        }
+
+        /** Returns the letter identifying the priority of the {@link LogLevel}. */
+        public char getPriorityLetter() {
+            return mPriorityLetter;
+        }
+
+        /** Returns the numerical value of the priority. */
+        public int getPriority() {
+            return mPriorityLevel;
+        }
+
+        /** Returns a non translated string representing the LogLevel. */
+        public String getStringValue() {
+            return mStringValue;
+        }
+
+        public static LogLevel convertFromDdmlib(com.android.ddmlib.Log.LogLevel level) {
+            switch (level) {
+                case VERBOSE:
+                    return VERBOSE;
+                case DEBUG:
+                    return DEBUG;
+                case INFO:
+                    return INFO;
+                case WARN:
+                    return WARN;
+                case ERROR:
+                    return ERROR;
+                case ASSERT:
+                    return ASSERT;
+                default:
+                    return VERBOSE;
+            }
+        }
+    }
+
+    /**
+     * Classes which implement this interface provides methods that deal with outputting log
+     * messages.
+     */
+    public interface ILogOutput {
+        /**
+         * Sent when a log message needs to be printed.
+         *
+         * @param logLevel The {@link LogLevel} enum representing the priority of the message.
+         * @param tag The tag associated with the message.
+         * @param message The message to display.
+         */
+        public void printLog(LogLevel logLevel, String tag, String message);
+
+        /**
+         * Sent when a log message needs to be printed, and, if possible, displayed to the user in a
+         * dialog box.
+         *
+         * @param logLevel The {@link LogLevel} enum representing the priority of the message.
+         * @param tag The tag associated with the message.
+         * @param message The message to display.
+         */
+        public void printAndPromptLog(LogLevel logLevel, String tag, String message);
+    }
+
+    private static LogLevel sLevel = LogLevel.VERBOSE;
+
+    private static ILogOutput sLogOutput;
+
+    private Log() {}
+
+    /**
+     * Outputs a {@link LogLevel#VERBOSE} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void v(String tag, String message) {
+        println(LogLevel.VERBOSE, tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#DEBUG} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void d(String tag, String message) {
+        println(LogLevel.DEBUG, tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#INFO} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void i(String tag, String message) {
+        println(LogLevel.INFO, tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#WARN} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void w(String tag, String message) {
+        println(LogLevel.WARN, tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#ERROR} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void e(String tag, String message) {
+        println(LogLevel.ERROR, tag, message);
+    }
+
+    /**
+     * Outputs a log message and attempts to display it in a dialog.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void logAndDisplay(LogLevel logLevel, String tag, String message) {
+        if (sLogOutput != null) {
+            sLogOutput.printAndPromptLog(logLevel, tag, message);
+        } else {
+            println(logLevel, tag, message);
+        }
+    }
+
+    /**
+     * Outputs a {@link LogLevel#ERROR} level {@link Throwable} information.
+     *
+     * @param tag The tag associated with the message.
+     * @param throwable The {@link Throwable} to output.
+     */
+    public static void e(String tag, Throwable throwable) {
+        if (throwable != null) {
+            StringWriter sw = new StringWriter();
+            PrintWriter pw = new PrintWriter(sw);
+
+            throwable.printStackTrace(pw);
+            println(LogLevel.ERROR, tag, throwable.getMessage() + '\n' + sw.toString());
+        }
+    }
+
+    static void setLevel(LogLevel logLevel) {
+        sLevel = logLevel;
+    }
+
+    /**
+     * Sets the {@link ILogOutput} to use to print the logs. If not set, {@link System#out} will be
+     * used.
+     *
+     * @param logOutput The {@link ILogOutput} to use to print the log.
+     */
+    public static void setLogOutput(ILogOutput logOutput) {
+        sLogOutput = logOutput;
+    }
+
+    /* currently prints to stdout; could write to a log window */
+    private static void println(LogLevel logLevel, String tag, String message) {
+        if (logLevel.getPriority() >= sLevel.getPriority()) {
+            if (sLogOutput != null) {
+                sLogOutput.printLog(logLevel, tag, message);
+            } else {
+                printLog(logLevel, tag, message);
+            }
+        }
+    }
+
+    /**
+     * Prints a log message.
+     *
+     * @param logLevel
+     * @param tag
+     * @param message
+     */
+    public static void printLog(LogLevel logLevel, String tag, String message) {
+        System.out.print(getLogFormatString(logLevel, tag, message));
+    }
+
+    /**
+     * Formats a log message.
+     *
+     * @param logLevel
+     * @param tag
+     * @param message
+     */
+    public static String getLogFormatString(LogLevel logLevel, String tag, String message) {
+        SimpleDateFormat formatter = new SimpleDateFormat("MM-dd HH:mm:ss", Locale.getDefault());
+        return String.format(
+                "%s %c/%s: %s\n",
+                formatter.format(new Date()), logLevel.getPriorityLetter(), tag, message);
+    }
+}
diff --git a/common_util/com/android/tradefed/log/LogUtil.java b/common_util/com/android/tradefed/log/LogUtil.java
index 0cb0ef33f..51646b2b3 100644
--- a/common_util/com/android/tradefed/log/LogUtil.java
+++ b/common_util/com/android/tradefed/log/LogUtil.java
@@ -16,7 +16,6 @@
 
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log;
 import com.android.ddmlib.Log.LogLevel;
 
 import java.io.PrintWriter;
@@ -206,6 +205,15 @@ public class LogUtil {
          */
         public static void logAndDisplay(LogLevel logLevel, String message) {
             // frame 2: skip frames 0 (#getClassName) and 1 (this method)
+            Log.logAndDisplay(
+                    com.android.tradefed.log.Log.LogLevel.convertFromDdmlib(logLevel),
+                    getClassName(2),
+                    message);
+        }
+
+        public static void logAndDisplay(
+                com.android.tradefed.log.Log.LogLevel logLevel, String message) {
+            // frame 2: skip frames 0 (#getClassName) and 1 (this method)
             Log.logAndDisplay(logLevel, getClassName(2), message);
         }
 
@@ -218,6 +226,22 @@ public class LogUtil {
          */
         public static void logAndDisplay(LogLevel logLevel, String format, Object... args) {
             // frame 2: skip frames 0 (#getClassName) and 1 (this method)
+            Log.logAndDisplay(
+                    com.android.tradefed.log.Log.LogLevel.convertFromDdmlib(logLevel),
+                    getClassName(2),
+                    String.format(format, args));
+        }
+
+        /**
+         * The shim version of {@link Log#logAndDisplay(LogLevel, String, String)}.
+         *
+         * @param logLevel the {@link LogLevel}
+         * @param format A format string for the message to log
+         * @param args The format string arguments
+         */
+        public static void logAndDisplay(
+                com.android.tradefed.log.Log.LogLevel logLevel, String format, Object... args) {
+            // frame 2: skip frames 0 (#getClassName) and 1 (this method)
             Log.logAndDisplay(logLevel, getClassName(2), String.format(format, args));
         }
 
@@ -268,7 +292,10 @@ public class LogUtil {
                logMessage += "\n" + stackTrace;
             }
 
-            Log.logAndDisplay(LogLevel.ASSERT, tag, logMessage);
+            Log.logAndDisplay(
+                    com.android.tradefed.log.Log.LogLevel.convertFromDdmlib(LogLevel.ASSERT),
+                    tag,
+                    logMessage);
         }
 
         /**
diff --git a/common_util/com/android/tradefed/result/error/DeviceErrorIdentifier.java b/common_util/com/android/tradefed/result/error/DeviceErrorIdentifier.java
index 5a1be81e2..774899fe9 100644
--- a/common_util/com/android/tradefed/result/error/DeviceErrorIdentifier.java
+++ b/common_util/com/android/tradefed/result/error/DeviceErrorIdentifier.java
@@ -29,6 +29,7 @@ public enum DeviceErrorIdentifier implements ErrorIdentifier {
     FAIL_ACTIVATE_APEX(520_002, FailureStatus.DEPENDENCY_ISSUE),
     APEX_ROLLBACK_FAILED(520_003, FailureStatus.DEPENDENCY_ISSUE),
     MAINLINE_MODULE_ROLLBACK_DETECTED(520_004, FailureStatus.DEPENDENCY_ISSUE),
+    KERNEL_MODULE_INSTALLATION_FAILED(520_005, FailureStatus.DEPENDENCY_ISSUE),
 
     AAPT_PARSER_FAILED(520_050, FailureStatus.DEPENDENCY_ISSUE),
 
diff --git a/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java b/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
index 9190d25ee..7290b8277 100644
--- a/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
+++ b/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
@@ -49,6 +49,7 @@ public enum InfraErrorIdentifier implements ErrorIdentifier {
     INCREMENTAL_FLASHING_ERROR(500_020, FailureStatus.INFRA_FAILURE),
     BLOCK_COMPARE_ERROR(500_021, FailureStatus.INFRA_FAILURE),
     FLASHSTATION_CACHE_PREPARATION_ERROR(500_022, FailureStatus.INFRA_FAILURE),
+    FLASHSTATION_SETUP_ERROR(500_023, FailureStatus.INFRA_FAILURE),
 
     // 500_400 - 500_500: General errors - subprocess related
     INTERRUPTED_DURING_SUBPROCESS_SHUTDOWN(500_401, FailureStatus.INFRA_FAILURE),
diff --git a/src/com/android/tradefed/targetprep/AltDirBehavior.java b/common_util/com/android/tradefed/targetprep/AltDirBehavior.java
similarity index 99%
rename from src/com/android/tradefed/targetprep/AltDirBehavior.java
rename to common_util/com/android/tradefed/targetprep/AltDirBehavior.java
index 564f5784b..09c4cd6a7 100644
--- a/src/com/android/tradefed/targetprep/AltDirBehavior.java
+++ b/common_util/com/android/tradefed/targetprep/AltDirBehavior.java
@@ -18,7 +18,9 @@ package com.android.tradefed.targetprep;
 
 /**
  * An enum to define alternative directory behaviors for various test artifact installers/pushers
+ *
  * <p>
+ *
  * @see TestAppInstallSetup
  * @see TestFilePushSetup
  */
diff --git a/common_util/com/android/tradefed/util/FileUtil.java b/common_util/com/android/tradefed/util/FileUtil.java
index 0663195fa..fc8d1e596 100644
--- a/common_util/com/android/tradefed/util/FileUtil.java
+++ b/common_util/com/android/tradefed/util/FileUtil.java
@@ -58,6 +58,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
 import java.util.zip.ZipFile;
+
 /**
  * A helper class for file related operations
  */
@@ -515,23 +516,6 @@ public class FileUtil {
         recursiveHardlink(sourceDir, destDir, false);
     }
 
-    /**
-     * Recursively hardlink folder contents.
-     *
-     * <p>Only supports copying of files and directories - symlinks are not copied. If the
-     * destination directory does not exist, it will be created.
-     *
-     * @param sourceDir the folder that contains the files to copy
-     * @param destDir the destination folder
-     * @param ignoreExistingFile If True and the file being linked already exists, skip the
-     *     exception.
-     * @throws IOException
-     */
-    public static void recursiveHardlink(File sourceDir, File destDir, boolean ignoreExistingFile)
-            throws IOException {
-        recursiveHardlink(sourceDir, destDir, ignoreExistingFile, new HashSet<>());
-    }
-
     /**
      * Recursively hardlink folder contents.
      *
@@ -545,11 +529,7 @@ public class FileUtil {
      * @param copyInsteadofHardlink Set of files that needs to be copied instead of linked.
      * @throws IOException
      */
-    public static void recursiveHardlink(
-            File sourceDir,
-            File destDir,
-            boolean ignoreExistingFile,
-            Set<String> copyInsteadofHardlink)
+    public static void recursiveHardlink(File sourceDir, File destDir, boolean ignoreExistingFile)
             throws IOException {
         if (!destDir.isDirectory() && !destDir.mkdir()) {
             throw new IOException(String.format("Could not create directory %s",
@@ -560,11 +540,7 @@ public class FileUtil {
             if (childFile.isDirectory()) {
                 recursiveHardlink(childFile, destChild, ignoreExistingFile);
             } else if (childFile.isFile()) {
-                if (copyInsteadofHardlink.contains(childFile.getName())) {
-                    FileUtil.copyFile(childFile, destChild);
-                } else {
-                    hardlinkFile(childFile, destChild, ignoreExistingFile);
-                }
+                hardlinkFile(childFile, destChild, ignoreExistingFile);
             }
         }
     }
diff --git a/src/com/android/tradefed/device/cloud/GceRemoteCmdFormatter.java b/common_util/com/android/tradefed/util/GceRemoteCmdFormatter.java
similarity index 98%
rename from src/com/android/tradefed/device/cloud/GceRemoteCmdFormatter.java
rename to common_util/com/android/tradefed/util/GceRemoteCmdFormatter.java
index 2bbee4aeb..67bb3ba55 100644
--- a/src/com/android/tradefed/device/cloud/GceRemoteCmdFormatter.java
+++ b/common_util/com/android/tradefed/util/GceRemoteCmdFormatter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.tradefed.device.cloud;
+package com.android.tradefed.util;
 
 import java.io.File;
 import java.util.ArrayList;
diff --git a/common_util/com/android/tradefed/util/IRunUtil.java b/common_util/com/android/tradefed/util/IRunUtil.java
index 31d2bf082..1a64e4d4b 100644
--- a/common_util/com/android/tradefed/util/IRunUtil.java
+++ b/common_util/com/android/tradefed/util/IRunUtil.java
@@ -17,6 +17,7 @@
 package com.android.tradefed.util;
 
 import com.android.annotations.Nullable;
+import com.android.tradefed.cache.ExecutableActionResult;
 import com.android.tradefed.cache.ICacheClient;
 import com.android.tradefed.result.error.ErrorIdentifier;
 
@@ -537,4 +538,12 @@ public interface IRunUtil {
         SET,
         UNSET
     }
+
+    /**
+     * Uploads the last {@link ExecutableActionResult} ran with a cacheClient.
+     *
+     * @param cacheClient The {@link ICacheClient} used to upload the result.
+     * @param actionResult The {@link ExecutableActionResult} to upload.
+     */
+    public void uploadCache(ICacheClient cacheClient, ExecutableActionResult actionResult);
 }
diff --git a/common_util/com/android/tradefed/util/ProcessUtil.java b/common_util/com/android/tradefed/util/ProcessUtil.java
new file mode 100644
index 000000000..70d952422
--- /dev/null
+++ b/common_util/com/android/tradefed/util/ProcessUtil.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/*
+ * A Collection of helper methods for creating functional processes.
+ */
+public class ProcessUtil {
+
+    // Format string for non-interactive SSH tunneling parameter;params in
+    // order:local port, remote port
+    private static final String TUNNEL_PARAM = "-L%d:127.0.0.1:%d";
+
+    // Format string for local hostname.
+    public static final String DEFAULT_LOCAL_HOST = "127.0.0.1:%d";
+
+    public static final int DEFAULT_ADB_PORT = 5555;
+
+    /**
+     * Create an ssh tunnel to a given remote host and return the process.
+     *
+     * @param remoteHost the hostname/ip of the remote tcp ip Android device.
+     * @param localPort the port of the local tcp ip device.
+     * @param remotePort the port of the remote tcp ip device.
+     * @return {@link Process} of the ssh command.
+     */
+    public static Process createSshTunnel(
+            String remoteHost,
+            int localPort,
+            int remotePort,
+            File sshPrivateKeyPath,
+            String user,
+            File sshTunnelLog,
+            IRunUtil runUtil) {
+        try {
+            String serial = String.format(DEFAULT_LOCAL_HOST, localPort);
+            CLog.d("Device serial will be %s", serial);
+
+            List<String> tunnelParam = new ArrayList<>();
+            tunnelParam.add(String.format(TUNNEL_PARAM, localPort, remotePort));
+            tunnelParam.add("-N");
+            List<String> sshTunnel =
+                    GceRemoteCmdFormatter.getSshCommand(
+                            sshPrivateKeyPath, tunnelParam, user, remoteHost, "" /* no command */);
+            FileOutputStream output = null;
+            if (sshTunnelLog != null && sshTunnelLog.exists()) {
+                output = new FileOutputStream(sshTunnelLog, true);
+            }
+            return runUtil.runCmdInBackground(sshTunnel, output);
+        } catch (IOException e) {
+            CLog.d("Failed to connect to remote GCE using ssh tunnel %s", e.getMessage());
+        }
+        return null;
+    }
+}
diff --git a/common_util/com/android/tradefed/util/RunUtil.java b/common_util/com/android/tradefed/util/RunUtil.java
index 2abc81ac1..11601fba8 100644
--- a/common_util/com/android/tradefed/util/RunUtil.java
+++ b/common_util/com/android/tradefed/util/RunUtil.java
@@ -16,6 +16,7 @@
 
 package com.android.tradefed.util;
 
+
 import com.android.annotations.Nullable;
 import com.android.tradefed.cache.ExecutableAction;
 import com.android.tradefed.cache.ExecutableActionResult;
@@ -33,11 +34,11 @@ import com.google.common.base.Strings;
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.ProcessBuilder.Redirect;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -47,6 +48,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
 
 import javax.annotation.Nonnull;
 
@@ -73,6 +75,8 @@ public class RunUtil implements IRunUtil {
     private static final String PROGRESS_MONITOR_TIMEOUT_ENV = "RUN_PROGRESS_MONITOR_TIMEOUT";
 
     private final CommandInterrupter mInterrupter;
+    private final boolean mInheritEnvVars;
+    private ExecutableAction mAction = null;
 
     /**
      * Create a new {@link RunUtil} object to use.
@@ -81,9 +85,18 @@ public class RunUtil implements IRunUtil {
         this(CommandInterrupter.INSTANCE);
     }
 
+    public RunUtil(boolean inheritEnvVars) {
+        this(CommandInterrupter.INSTANCE, inheritEnvVars);
+    }
+
     @VisibleForTesting
     RunUtil(@Nonnull CommandInterrupter interrupter) {
+        this(interrupter, true);
+    }
+
+    private RunUtil(@Nonnull CommandInterrupter interrupter, boolean inheritEnvVars) {
         mInterrupter = interrupter;
+        mInheritEnvVars = inheritEnvVars;
     }
 
     /**
@@ -211,16 +224,20 @@ public class RunUtil implements IRunUtil {
             OutputStream stderr,
             ICacheClient cacheClient,
             final String... command) {
-        ProcessBuilder processBuilder = createProcessBuilder(command);
-        ExecutableAction action = null;
+        ProcessBuilder processBuilder = createProcessBuilder(cacheClient != null, command);
         if (cacheClient != null) {
             try {
-                action =
+                mAction =
                         ExecutableAction.create(
                                 processBuilder.directory(),
                                 processBuilder.command(),
                                 processBuilder.environment(),
                                 timeout);
+                CLog.d(
+                        "Caching command [%s] running in [%s] with environment variables:\n%s",
+                        processBuilder.command(),
+                        processBuilder.directory(),
+                        processBuilder.environment());
             } catch (IOException e) {
                 CLog.e("Exception occurred when building executable action! Disabling cache...");
                 CLog.e(e);
@@ -232,7 +249,9 @@ public class RunUtil implements IRunUtil {
         ExecutableActionResult cachedResult = null;
         try {
             cachedResult =
-                    action != null && cacheClient != null ? cacheClient.lookupCache(action) : null;
+                    mAction != null && cacheClient != null
+                            ? cacheClient.lookupCache(mAction)
+                            : null;
         } catch (IOException e) {
             CLog.e("Failed to lookup cache!");
             CLog.e(e);
@@ -241,6 +260,7 @@ public class RunUtil implements IRunUtil {
         }
         if (cachedResult != null) {
             try {
+                CLog.d("Cache is hit with action: %s", mAction.action());
                 return handleCachedResult(cachedResult, stdout, stderr);
             } catch (IOException e) {
                 CLog.e("Exception occurred when handling cached result!");
@@ -248,54 +268,12 @@ public class RunUtil implements IRunUtil {
             }
         }
 
-        File stdoutBuffer = null;
-        File stderrBuffer = null;
-        if (cacheClient != null) {
-            try {
-                stdoutBuffer = FileUtil.createTempFile("stdout-to-upload", ".txt");
-                stdoutBuffer.deleteOnExit();
-                stdout = new ForkedOutputStream(stdout, new FileOutputStream(stdoutBuffer));
-                if (stderr != null) {
-                    stderrBuffer = FileUtil.createTempFile("stderr-to-upload", ".txt");
-                    stderrBuffer.deleteOnExit();
-                    stderr = new ForkedOutputStream(stderr, new FileOutputStream(stderrBuffer));
-                }
-            } catch (IOException e) {
-                CLog.e("Failed to catch command execution output! Skipping the cache upload...");
-                CLog.e(e);
-                // Disable cache upload.
-                cacheClient = null;
-            }
-        }
         RunnableResult osRunnable = createRunnableResult(stdout, stderr, processBuilder);
 
         CommandStatus status =
                 runTimedWithOutputMonitor(timeout, idleOutputTimeout, osRunnable, true);
         CommandResult result = osRunnable.getResult();
         result.setStatus(status);
-
-        try {
-            if (CommandStatus.SUCCESS.equals(status) && action != null && cacheClient != null) {
-                ForkedOutputStream stdoutForkedStream = (ForkedOutputStream) stdout;
-                ForkedOutputStream stderrForkedStream =
-                        stderr != null ? (ForkedOutputStream) stderr : null;
-                if (stdoutForkedStream.isSuccess()
-                        && (stderr == null || stderrForkedStream.isSuccess())) {
-                    cacheClient.uploadCache(
-                            action,
-                            ExecutableActionResult.create(
-                                    result.getExitCode(), stdoutBuffer, stderrBuffer));
-                }
-            }
-        } catch (IOException e) {
-            CLog.e("Failed to upload cache!");
-            CLog.e(e);
-        } catch (InterruptedException e) {
-            throw new RunInterruptedException(e.getMessage(), e, InfraErrorIdentifier.UNDETERMINED);
-        } finally {
-            FileUtil.deleteFile(stdoutBuffer);
-            FileUtil.deleteFile(stderrBuffer);
-        }
         return result;
     }
 
@@ -347,25 +325,56 @@ public class RunUtil implements IRunUtil {
         return createProcessBuilder(Arrays.asList(command));
     }
 
+    private synchronized ProcessBuilder createProcessBuilder(
+            boolean enableCache, String... command) {
+        return createProcessBuilder(null, Arrays.asList(command), enableCache);
+    }
+
     private synchronized ProcessBuilder createProcessBuilder(Redirect redirect, String... command) {
-        return createProcessBuilder(redirect, Arrays.asList(command));
+        return createProcessBuilder(redirect, Arrays.asList(command), false);
     }
 
     private synchronized ProcessBuilder createProcessBuilder(List<String> commandList) {
-        return createProcessBuilder(null, commandList);
+        return createProcessBuilder(null, commandList, false);
     }
 
-    private synchronized ProcessBuilder createProcessBuilder(
-            Redirect redirect, List<String> commandList) {
+    public synchronized ProcessBuilder createProcessBuilder(
+            Redirect redirect, List<String> commandList, boolean enableCache) {
         ProcessBuilder processBuilder = new ProcessBuilder();
+        if (!mInheritEnvVars) {
+            processBuilder.environment().clear();
+        }
+
         if (mWorkingDir != null) {
             processBuilder.directory(mWorkingDir);
         }
+        Map<String, String> env = mEnvVariables;
+        if (enableCache) {
+            File workingDir =
+                    processBuilder.directory() != null
+                            ? processBuilder.directory()
+                            : new File(System.getProperty("user.dir"));
+            for (int i = 0; i < commandList.size(); i++) {
+                String prefix = i < 1 ? "./" : "";
+                commandList.set(i, prefix + toRelative(workingDir, commandList.get(i)));
+            }
+            for (Map.Entry<String, String> entry : env.entrySet()) {
+                String key = entry.getKey();
+                if (key.equals("LD_LIBRARY_PATH")) {
+                    env.put(
+                            key,
+                            Arrays.asList(entry.getValue().split(pathSeparator())).stream()
+                                    .map(p -> toRelative(workingDir, p))
+                                    .sorted()
+                                    .collect(Collectors.joining(pathSeparator())));
+                }
+            }
+        }
         // By default unset an env. for process has higher priority, but in some case we might want
         // the 'set' to have priority.
         if (EnvPriority.UNSET.equals(mEnvVariablePriority)) {
-            if (!mEnvVariables.isEmpty()) {
-                processBuilder.environment().putAll(mEnvVariables);
+            if (!env.isEmpty()) {
+                processBuilder.environment().putAll(env);
             }
             if (!mUnsetEnvVariables.isEmpty()) {
                 // in this implementation, the unsetEnv's priority is higher than set.
@@ -375,9 +384,9 @@ public class RunUtil implements IRunUtil {
             if (!mUnsetEnvVariables.isEmpty()) {
                 processBuilder.environment().keySet().removeAll(mUnsetEnvVariables);
             }
-            if (!mEnvVariables.isEmpty()) {
+            if (!env.isEmpty()) {
                 // in this implementation, the setEnv's priority is higher than set.
-                processBuilder.environment().putAll(mEnvVariables);
+                processBuilder.environment().putAll(env);
             }
         }
         processBuilder.redirectErrorStream(mRedirectStderr);
@@ -450,9 +459,7 @@ public class RunUtil implements IRunUtil {
         return result;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
     public CommandResult runTimedCmdSilently(final long timeout, final String... command) {
         RunnableResult osRunnable = new RunnableResult(null, createProcessBuilder(command), false);
@@ -511,7 +518,7 @@ public class RunUtil implements IRunUtil {
     public Process runCmdInBackground(Redirect redirect, final List<String> command)
             throws IOException {
         CLog.v("Running in background: %s", command);
-        return createProcessBuilder(redirect, command).start();
+        return createProcessBuilder(redirect, command, false).start();
     }
 
     /**
@@ -1205,103 +1212,97 @@ public class RunUtil implements IRunUtil {
         // Only success run will be cached.
         commandResult.setStatus(CommandStatus.SUCCESS);
         commandResult.setCached(true);
-        if (result.stdOut() != null && stdout != null) {
-            FileInputStream stdoutStream = new FileInputStream(result.stdOut());
-            try {
-                StreamUtil.copyStreams(stdoutStream, stdout);
-            } finally {
-                stdoutStream.close();
-                FileUtil.deleteFile(result.stdOut());
+        if (result.stdOut() != null) {
+            if (stdout != null) {
+                FileInputStream stdoutStream = new FileInputStream(result.stdOut());
+                try {
+                    StreamUtil.copyStreams(stdoutStream, stdout);
+                } finally {
+                    stdoutStream.close();
+                    FileUtil.deleteFile(result.stdOut());
+                }
+            } else {
+                try {
+                    commandResult.setStdout(FileUtil.readStringFromFile(result.stdOut()));
+                } finally {
+                    FileUtil.deleteFile(result.stdOut());
+                }
             }
         }
-        if (result.stdErr() != null && stderr != null) {
-            FileInputStream stderrStream = new FileInputStream(result.stdErr());
-            try {
-                StreamUtil.copyStreams(stderrStream, stderr);
-            } finally {
-                stderrStream.close();
-                FileUtil.deleteFile(result.stdErr());
+        if (result.stdErr() != null) {
+            if (stderr != null) {
+                FileInputStream stderrStream = new FileInputStream(result.stdErr());
+                try {
+                    StreamUtil.copyStreams(stderrStream, stderr);
+                } finally {
+                    stderrStream.close();
+                    FileUtil.deleteFile(result.stdErr());
+                }
+            } else {
+                try {
+                    commandResult.setStderr(FileUtil.readStringFromFile(result.stdErr()));
+                } finally {
+                    FileUtil.deleteFile(result.stdErr());
+                }
             }
         }
         return commandResult;
     }
 
-    /**
-     * Utility subclass of OutputStream that forwards the data to both underlying {@link
-     * OutputStream} and {@link FileOutputStream}.
-     */
-    private static class ForkedOutputStream extends OutputStream {
-        private final FileOutputStream mFileOutputStream;
-        private final OutputStream mOut;
-        private boolean mSuccess = true;
-
-        public ForkedOutputStream(OutputStream out, FileOutputStream fileOutputStream) {
-            mOut = out;
-            mFileOutputStream = fileOutputStream;
-        }
+    public static String toRelative(File start, String target) {
+        File targetFile = new File(target);
+        return targetFile.exists() ? toRelative(start, targetFile) : target;
+    }
 
-        @Override
-        public void write(int b) throws IOException {
-            mOut.write(b);
-            try {
-                mFileOutputStream.write(b);
-            } catch (IOException e) {
-                CLog.e("Failed to write to the file output stream!");
-                CLog.e(e);
-                mSuccess = false;
-            }
-        }
+    public static String toRelative(File start, File target) {
+        String relPath = start.toPath().relativize(target.toPath()).toString();
+        return relPath.length() != 0 ? relPath : ".";
+    }
 
-        @Override
-        public void write(byte[] b) throws IOException {
-            mOut.write(b);
-            try {
-                mFileOutputStream.write(b);
-            } catch (IOException e) {
-                CLog.e("Failed to write to the file output stream!");
-                CLog.e(e);
-                mSuccess = false;
-            }
-        }
+    private static String pathSeparator() {
+        return System.getProperty("path.separator");
+    }
 
-        @Override
-        public void write(byte[] b, int off, int len) throws IOException {
-            mOut.write(b, off, len);
-            try {
-                mFileOutputStream.write(b, off, len);
-            } catch (IOException e) {
-                CLog.e("Failed to write to the file output stream!");
-                CLog.e(e);
-                mSuccess = false;
-            }
+    /**
+     * Links the {@code target} to a place under {@code destRoot}.
+     *
+     * <p>If the target file or the symlink is already existed under the {@code destRoot}, the file
+     * won't be linked.
+     *
+     * @param destRoot The root of the destination.
+     * @param relToRoot The relative path from the destination dir to root.
+     * @param target The target file to be linked.
+     * @return the symlink
+     * @throws IOException if the target file fails to be linked.
+     */
+    public static File linkFile(File destRoot, String relToRoot, File target) throws IOException {
+        if (target.getAbsolutePath().startsWith(destRoot.getAbsolutePath())) {
+            return target;
         }
-
-        @Override
-        public void flush() throws IOException {
-            mOut.flush();
-            try {
-                mFileOutputStream.flush();
-            } catch (IOException e) {
-                CLog.e("Failed to flush the file output stream!");
-                CLog.e(e);
-                mSuccess = false;
-            }
+        String relPath = Paths.get(relToRoot, target.getName()).toString();
+        File symlink = new File(destRoot, relPath);
+        if (symlink.exists()) {
+            FileUtil.deleteFile(symlink);
         }
+        symlink.getParentFile().mkdirs();
+        FileUtil.symlinkFile(target, symlink);
+        return symlink;
+    }
 
-        @Override
-        public void close() throws IOException {
-            mOut.close();
-            try {
-                mFileOutputStream.close();
-            } catch (IOException e) {
-                CLog.e("Failed to close the file output stream!");
-                CLog.e(e);
-                mSuccess = false;
-            }
+    /** {@inheritDoc} */
+    @Override
+    public void uploadCache(ICacheClient cacheClient, ExecutableActionResult actionResult) {
+        if (actionResult.exitCode() != 0 || cacheClient == null || mAction == null) {
+            return;
         }
-
-        public boolean isSuccess() {
-            return mSuccess;
+        CLog.d("Uploading cache for action: %s", mAction.action());
+        try {
+            cacheClient.uploadCache(mAction, actionResult);
+        } catch (IOException e) {
+            CLog.e("Failed to upload cache!");
+            CLog.e(e);
+        } catch (InterruptedException e) {
+            throw new RunInterruptedException(e.getMessage(), e, InfraErrorIdentifier.UNDETERMINED);
         }
     }
 }
diff --git a/common_util/com/android/tradefed/util/gcs/GCSCommon.java b/common_util/com/android/tradefed/util/gcs/GCSCommon.java
new file mode 100644
index 000000000..81755b07c
--- /dev/null
+++ b/common_util/com/android/tradefed/util/gcs/GCSCommon.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.util.gcs;
+
+import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
+import com.google.api.client.http.HttpRequestInitializer;
+import com.google.api.client.json.gson.GsonFactory;
+import com.google.api.services.storage.Storage;
+import com.google.auth.Credentials;
+import com.google.auth.http.HttpCredentialsAdapter;
+
+import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Collection;
+
+/** Base class for Gcs operation like download and upload. */
+public abstract class GCSCommon {
+
+    public static final int DEFAULT_TIMEOUT = 10 * 60 * 1000; // 10minutes
+
+    protected File mJsonKeyFile = null;
+
+    protected Storage mStorage;
+
+    public GCSCommon() {}
+
+    protected void setJsonKeyFile(File jsonKeyFile) {
+        mJsonKeyFile = jsonKeyFile;
+    }
+
+    /*
+     * The base implementation only supports using default credential.
+     */
+    protected Storage getStorage(Collection<String> scopes) throws IOException {
+        Credentials credential = null;
+        try {
+            if (mStorage == null) {
+                credential = GoogleApiClientUtilBase.createCredential(scopes);
+                HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credential);
+                mStorage =
+                        new Storage.Builder(
+                                        GoogleNetHttpTransport.newTrustedTransport(),
+                                        GsonFactory.getDefaultInstance(),
+                                        GoogleApiClientUtilBase.configureRetryStrategy(
+                                                GoogleApiClientUtilBase.setHttpTimeout(
+                                                        requestInitializer,
+                                                        DEFAULT_TIMEOUT,
+                                                        DEFAULT_TIMEOUT)))
+                                .setApplicationName(GoogleApiClientUtilBase.APP_NAME)
+                                .build();
+            }
+            return mStorage;
+        } catch (GeneralSecurityException e) {
+            throw new IOException(e);
+        }
+    }
+}
diff --git a/common_util/com/android/tradefed/util/gcs/GCSFileDownloaderBase.java b/common_util/com/android/tradefed/util/gcs/GCSFileDownloaderBase.java
new file mode 100644
index 000000000..fe95ed203
--- /dev/null
+++ b/common_util/com/android/tradefed/util/gcs/GCSFileDownloaderBase.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.gcs;
+
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.StreamUtil;
+
+import com.google.api.client.googleapis.json.GoogleJsonResponseException;
+import com.google.api.services.storage.Storage;
+import com.google.api.services.storage.model.Objects;
+import com.google.api.services.storage.model.StorageObject;
+import com.google.common.annotations.VisibleForTesting;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.math.BigInteger;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** File downloader to download file from google cloud storage (GCS). */
+public class GCSFileDownloaderBase extends GCSCommon {
+    public static final String GCS_PREFIX = "gs://";
+    public static final String GCS_APPROX_PREFIX = "gs:/";
+
+    private static final Pattern GCS_PATH_PATTERN = Pattern.compile("gs://([^/]*)/(.*)");
+    private static final String PATH_SEP = "/";
+    private static final Collection<String> SCOPES =
+            Collections.singleton("https://www.googleapis.com/auth/devstorage.read_only");
+    private static final long LIST_BATCH_SIZE = 100;
+
+    // Allow downloader to create empty files instead of throwing exception.
+    protected Boolean mCreateEmptyFile = false;
+
+    public GCSFileDownloaderBase(Boolean createEmptyFile) {
+        mCreateEmptyFile = createEmptyFile;
+    }
+
+    public GCSFileDownloaderBase() {
+        this(false);
+    }
+
+    protected Storage getStorage() throws IOException {
+        return getStorage(SCOPES);
+    }
+
+    public StorageObject getRemoteFileMetaData(String bucketName, String remoteFilename)
+            throws IOException {
+        int i = 0;
+        do {
+            i++;
+            try {
+                return getStorage().objects().get(bucketName, remoteFilename).execute();
+            } catch (GoogleJsonResponseException e) {
+                if (e.getStatusCode() == 404) {
+                    return null;
+                }
+                throw e;
+            } catch (SocketTimeoutException e) {
+                // Allow one retry in case of flaky connection.
+                if (i >= 2) {
+                    throw e;
+                }
+            }
+        } while (true);
+    }
+
+    public File downloadFile(String remoteFilePath) throws Exception {
+        File destFile = createTempFile(remoteFilePath, null);
+        try {
+            downloadFile(remoteFilePath, destFile);
+            return destFile;
+        } catch (IOException e) {
+            FileUtil.recursiveDelete(destFile);
+            throw e;
+        }
+    }
+
+    /**
+     * Download a file from a GCS bucket file.
+     *
+     * @param bucketName GCS bucket name
+     * @param filename the filename
+     * @return {@link InputStream} with the file content.
+     */
+    public InputStream downloadFile(String bucketName, String filename) throws IOException {
+        InputStream remoteInput = null;
+        ByteArrayOutputStream tmpStream = null;
+        try {
+            remoteInput =
+                    getStorage().objects().get(bucketName, filename).executeMediaAsInputStream();
+            // The input stream from api call can not be reset. Change it to ByteArrayInputStream.
+            tmpStream = new ByteArrayOutputStream();
+            StreamUtil.copyStreams(remoteInput, tmpStream);
+            return new ByteArrayInputStream(tmpStream.toByteArray());
+        } finally {
+            StreamUtil.close(remoteInput);
+            StreamUtil.close(tmpStream);
+        }
+    }
+
+    public void downloadFile(String remotePath, File destFile) throws Exception {
+        String[] pathParts = parseGcsPath(remotePath);
+        downloadFile(pathParts[0], pathParts[1], destFile);
+    }
+
+    @VisibleForTesting
+    protected void downloadFile(String bucketName, String remoteFilename, File localFile)
+            throws Exception {
+        int i = 0;
+        try {
+            do {
+                i++;
+                try {
+                    if (!isRemoteFolder(bucketName, remoteFilename)) {
+                        fetchRemoteFile(bucketName, remoteFilename, localFile);
+                        return;
+                    }
+                    remoteFilename = sanitizeDirectoryName(remoteFilename);
+                    recursiveDownloadFolder(bucketName, remoteFilename, localFile);
+                    return;
+                } catch (SocketException se) {
+                    // Allow one retry in case of flaky connection.
+                    if (i >= 2) {
+                        throw se;
+                    }
+                    CLog.e(
+                            "Error '%s' while downloading gs://%s/%s. retrying.",
+                            se.getMessage(), bucketName, remoteFilename);
+                }
+            } while (true);
+        } catch (IOException e) {
+            String message =
+                    String.format(
+                            "Failed to download gs://%s/%s due to: %s",
+                            bucketName, remoteFilename, e.getMessage());
+            CLog.e(message);
+            throw new IOException(message, e);
+        }
+    }
+
+    protected void listRemoteFilesUnderFolder(
+            String bucketName, String folder, List<StorageObject> subFiles, List<String> subFolders)
+            throws IOException {
+        String pageToken = null;
+        while (true) {
+            com.google.api.services.storage.Storage.Objects.List listOperation =
+                    getStorage()
+                            .objects()
+                            .list(bucketName)
+                            .setPrefix(folder)
+                            .setDelimiter(PATH_SEP)
+                            .setMaxResults(LIST_BATCH_SIZE);
+            if (pageToken != null) {
+                listOperation.setPageToken(pageToken);
+            }
+            Objects objects = listOperation.execute();
+            if (objects.getItems() != null && !objects.getItems().isEmpty()) {
+                for (int i = 0; i < objects.getItems().size(); i++) {
+                    if (objects.getItems().get(i).getName().equals(folder)) {
+                        // If the folder is created from UI, the folder itself
+                        // is a size 0 text file and its name will be
+                        // the folder's name, we should ignore this file.
+                        continue;
+                    }
+                    subFiles.add(objects.getItems().get(i));
+                }
+            }
+            if (objects.getPrefixes() != null && !objects.getPrefixes().isEmpty()) {
+                // size 0 sub-folders will also be listed under the prefix.
+                // So this includes all the sub-folders.
+                subFolders.addAll(objects.getPrefixes());
+            }
+            pageToken = objects.getNextPageToken();
+            if (pageToken == null) {
+                return;
+            }
+        }
+    }
+
+    protected String[] parseGcsPath(String remotePath) throws Exception {
+        if (remotePath.startsWith(GCS_APPROX_PREFIX) && !remotePath.startsWith(GCS_PREFIX)) {
+            // File object remove double // so we have to rebuild it in some cases
+            remotePath = remotePath.replaceAll(GCS_APPROX_PREFIX, GCS_PREFIX);
+        }
+        Matcher m = GCS_PATH_PATTERN.matcher(remotePath);
+        if (!m.find()) {
+            throw new IOException(
+                    String.format("Only GCS path is supported, %s is not supported", remotePath));
+        }
+        return new String[] {m.group(1), m.group(2)};
+    }
+
+    public String sanitizeDirectoryName(String name) {
+        /** Folder name should end with "/" */
+        if (!name.endsWith(PATH_SEP)) {
+            name += PATH_SEP;
+        }
+        return name;
+    }
+
+    /**
+     * Check given filename is a folder or not.
+     *
+     * <p>There 2 types of folders in gcs: 1. Created explicitly from UI. The folder is a size 0
+     * text file (it's an object). 2. When upload a file, all its parent folders will be created,
+     * but these folders doesn't exist (not objects) in gcs. This function work for both cases. But
+     * we should not try to download the size 0 folders.
+     *
+     * @param bucketName is the gcs bucket name.
+     * @param filename is the relative path to the bucket.
+     * @return true if the filename is a folder, otherwise false.
+     */
+    public boolean isRemoteFolder(String bucketName, String filename) throws IOException {
+        filename = sanitizeDirectoryName(filename);
+        Objects objects =
+                getStorage()
+                        .objects()
+                        .list(bucketName)
+                        .setPrefix(filename)
+                        .setDelimiter(PATH_SEP)
+                        .setMaxResults(1L)
+                        .execute();
+        if (objects.getItems() != null && !objects.getItems().isEmpty()) {
+            // The filename is end with '/', if there are objects use filename as prefix
+            // then filename must be a folder.
+            return true;
+        }
+        if (objects.getPrefixes() != null && !objects.getPrefixes().isEmpty()) {
+            // This will happen when the folder only contains folders but no objects.
+            // objects.getItems() will be empty, but objects.getPrefixes will list
+            // sub-folders.
+            return true;
+        }
+        return false;
+    }
+
+    void fetchRemoteFile(String bucketName, String remoteFilename, File localFile)
+            throws IOException {
+        CLog.d("Fetching gs://%s/%s to %s.", bucketName, remoteFilename, localFile.toString());
+        StorageObject meta = getRemoteFileMetaData(bucketName, remoteFilename);
+        if (meta == null || meta.getSize().equals(BigInteger.ZERO)) {
+            if (!mCreateEmptyFile) {
+                throw new IOException(
+                        String.format(
+                                "File (not folder) gs://%s/%s doesn't exist or is size 0.",
+                                bucketName, remoteFilename));
+            } else {
+                // Create the empty file.
+                CLog.d("GCS file is empty: gs://%s/%s", bucketName, remoteFilename);
+                localFile.createNewFile();
+                return;
+            }
+        }
+        try (OutputStream writeStream = new FileOutputStream(localFile)) {
+            getStorage()
+                    .objects()
+                    .get(bucketName, remoteFilename)
+                    .executeMediaAndDownloadTo(writeStream);
+        }
+    }
+
+    /**
+     * Recursively download remote folder to local folder.
+     *
+     * @param bucketName the gcs bucket name
+     * @param remoteFolderName remote folder name, must end with "/"
+     * @param localFolder local folder
+     * @throws IOException
+     */
+    private void recursiveDownloadFolder(
+            String bucketName, String remoteFolderName, File localFolder) throws IOException {
+        CLog.d("Downloading folder gs://%s/%s.", bucketName, remoteFolderName);
+        if (!localFolder.exists()) {
+            FileUtil.mkdirsRWX(localFolder);
+        }
+        if (!localFolder.isDirectory()) {
+            String error =
+                    String.format(
+                            "%s is not a folder. (gs://%s/%s)",
+                            localFolder, bucketName, remoteFolderName);
+            CLog.e(error);
+            throw new IOException(error);
+        }
+        Set<String> subFilenames = new HashSet<>(Arrays.asList(localFolder.list()));
+        List<String> subRemoteFolders = new ArrayList<>();
+        List<StorageObject> subRemoteFiles = new ArrayList<>();
+        listRemoteFilesUnderFolder(bucketName, remoteFolderName, subRemoteFiles, subRemoteFolders);
+        for (StorageObject subRemoteFile : subRemoteFiles) {
+            String subFilename = Paths.get(subRemoteFile.getName()).getFileName().toString();
+            fetchRemoteFile(
+                    bucketName, subRemoteFile.getName(), new File(localFolder, subFilename));
+            subFilenames.remove(subFilename);
+        }
+        for (String subRemoteFolder : subRemoteFolders) {
+            String subFolderName = Paths.get(subRemoteFolder).getFileName().toString();
+            File subFolder = new File(localFolder, subFolderName);
+            if (new File(localFolder, subFolderName).exists()
+                    && !new File(localFolder, subFolderName).isDirectory()) {
+                CLog.w("%s exists as a non-directory.", subFolder);
+                subFolder = new File(localFolder, subFolderName + "_folder");
+            }
+            recursiveDownloadFolder(bucketName, subRemoteFolder, subFolder);
+            subFilenames.remove(subFolder.getName());
+        }
+        for (String subFilename : subFilenames) {
+            FileUtil.recursiveDelete(new File(localFolder, subFilename));
+        }
+    }
+
+    @VisibleForTesting
+    protected File createTempFile(String remoteFilePath, File rootDir) throws Exception {
+        return createTempFileForRemote(remoteFilePath, rootDir);
+    }
+
+    /**
+     * Creates a unique file on temporary disk to house downloaded file with given path.
+     *
+     * <p>Constructs the file name based on base file name from path
+     *
+     * @param remoteFilePath the remote path to construct the name from
+     */
+    public static File createTempFileForRemote(String remoteFilePath, File rootDir)
+            throws Exception {
+        // create a unique file.
+        File tmpFile = FileUtil.createTempFileForRemote(remoteFilePath, rootDir);
+        // now delete it so name is available
+        tmpFile.delete();
+        return tmpFile;
+    }
+}
diff --git a/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java b/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java
new file mode 100644
index 000000000..357d201c4
--- /dev/null
+++ b/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util.gcs;
+
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.api.client.auth.oauth2.Credential;
+import com.google.api.client.http.HttpBackOffUnsuccessfulResponseHandler;
+import com.google.api.client.http.HttpRequest;
+import com.google.api.client.http.HttpRequestInitializer;
+import com.google.api.client.http.HttpResponse;
+import com.google.api.client.http.HttpUnsuccessfulResponseHandler;
+import com.google.api.client.util.ExponentialBackOff;
+import com.google.auth.Credentials;
+import com.google.auth.oauth2.ComputeEngineCredentials;
+import com.google.auth.oauth2.GoogleCredentials;
+import com.google.common.annotations.VisibleForTesting;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Collection;
+
+public class GoogleApiClientUtilBase {
+
+    public static final String APP_NAME = "tradefed";
+    private static GoogleApiClientUtilBase sInstance = null;
+
+    private static GoogleApiClientUtilBase getInstance() {
+        if (sInstance == null) {
+            sInstance = new GoogleApiClientUtilBase();
+        }
+        return sInstance;
+    }
+
+    /**
+     * Try to create Google API credential with default credential.
+     *
+     * <p>Only default credential is used.
+     *
+     * @param scopes scopes for the credential.
+     * @return a {@link Credential}
+     * @throws IOException
+     * @throws GeneralSecurityException
+     */
+    public static Credentials createCredential(Collection<String> scopes)
+            throws IOException, GeneralSecurityException {
+        return getInstance().doCreateDefaultCredential(scopes);
+    }
+
+    /**
+     * Create credential from json key file.
+     *
+     * @param file is the p12 key file
+     * @param scopes is the API's scope.
+     * @return a {@link Credential}.
+     * @throws FileNotFoundException
+     * @throws IOException
+     * @throws GeneralSecurityException
+     */
+    public static Credentials createCredentialFromJsonKeyFile(File file, Collection<String> scopes)
+            throws IOException, GeneralSecurityException {
+        return getInstance().doCreateCredentialFromJsonKeyFile(file, scopes);
+    }
+
+    @VisibleForTesting
+    protected Credentials doCreateCredentialFromJsonKeyFile(File file, Collection<String> scopes)
+            throws IOException, GeneralSecurityException {
+        Credentials credentail =
+                GoogleCredentials.fromStream(new FileInputStream(file)).createScoped(scopes);
+        return credentail;
+    }
+
+    @VisibleForTesting
+    protected Credentials doCreateDefaultCredential(Collection<String> scopes) throws IOException {
+        try {
+            CLog.d("Using local authentication.");
+            return ComputeEngineCredentials.getApplicationDefault().createScoped(scopes);
+        } catch (IOException e) {
+            CLog.e(
+                    "Try 'gcloud auth application-default login' to login for "
+                            + "personal account; Or 'export "
+                            + "GOOGLE_APPLICATION_CREDENTIALS=/path/to/key.json' "
+                            + "for service account.");
+            throw e;
+        }
+    }
+
+    /**
+     * @param requestInitializer a {@link HttpRequestInitializer}, normally it's {@link Credential}.
+     * @param connectTimeout connect timeout in milliseconds.
+     * @param readTimeout read timeout in milliseconds.
+     * @return a {@link HttpRequestInitializer} with timeout.
+     */
+    public static HttpRequestInitializer setHttpTimeout(
+            final HttpRequestInitializer requestInitializer, int connectTimeout, int readTimeout) {
+        return new HttpRequestInitializer() {
+            @Override
+            public void initialize(HttpRequest request) throws IOException {
+                requestInitializer.initialize(request);
+                request.setConnectTimeout(connectTimeout);
+                request.setReadTimeout(readTimeout);
+            }
+        };
+    }
+
+    /**
+     * Setup a retry strategy for the provided HttpRequestInitializer. In case of server errors
+     * requests will be automatically retried with an exponential backoff.
+     *
+     * @param initializer - an initializer which will setup a retry strategy.
+     * @return an initializer that will retry failed requests automatically.
+     */
+    public static HttpRequestInitializer configureRetryStrategyAndTimeout(
+            HttpRequestInitializer initializer, int connectTimeout, int readTimeout) {
+        return new HttpRequestInitializer() {
+            @Override
+            public void initialize(HttpRequest request) throws IOException {
+                initializer.initialize(request);
+                request.setConnectTimeout(connectTimeout);
+                request.setReadTimeout(readTimeout);
+                request.setUnsuccessfulResponseHandler(new RetryResponseHandler());
+            }
+        };
+    }
+
+    /**
+     * Setup a retry strategy for the provided HttpRequestInitializer. In case of server errors
+     * requests will be automatically retried with an exponential backoff.
+     *
+     * @param initializer - an initializer which will setup a retry strategy.
+     * @return an initializer that will retry failed requests automatically.
+     */
+    public static HttpRequestInitializer configureRetryStrategy(
+            HttpRequestInitializer initializer) {
+        return new HttpRequestInitializer() {
+            @Override
+            public void initialize(HttpRequest request) throws IOException {
+                initializer.initialize(request);
+                request.setUnsuccessfulResponseHandler(new RetryResponseHandler());
+            }
+        };
+    }
+
+    private static class RetryResponseHandler implements HttpUnsuccessfulResponseHandler {
+        // Initial interval to wait before retrying if a request fails.
+        private static final int INITIAL_RETRY_INTERVAL = 1000;
+        private static final int MAX_RETRY_INTERVAL = 3 * 60000; // Set max interval to 3 minutes.
+
+        private final HttpUnsuccessfulResponseHandler backOffHandler;
+
+        public RetryResponseHandler() {
+            backOffHandler =
+                    new HttpBackOffUnsuccessfulResponseHandler(
+                            new ExponentialBackOff.Builder()
+                                    .setInitialIntervalMillis(INITIAL_RETRY_INTERVAL)
+                                    .setMaxIntervalMillis(MAX_RETRY_INTERVAL)
+                                    .build());
+        }
+
+        @Override
+        public boolean handleResponse(
+                HttpRequest request, HttpResponse response, boolean supportsRetry)
+                throws IOException {
+            CLog.w(
+                    "Request to %s failed: %d %s",
+                    request.getUrl(), response.getStatusCode(), response.getStatusMessage());
+            if (response.getStatusCode() == 400) {
+                return false;
+            }
+            return backOffHandler.handleResponse(request, response, supportsRetry);
+        }
+    }
+}
diff --git a/src/com/android/tradefed/build/IDeviceBuildInfo.java b/device_build_interfaces/com/android/tradefed/build/IDeviceBuildInfo.java
similarity index 73%
rename from src/com/android/tradefed/build/IDeviceBuildInfo.java
rename to device_build_interfaces/com/android/tradefed/build/IDeviceBuildInfo.java
index be64e507e..26b99dfa9 100644
--- a/src/com/android/tradefed/build/IDeviceBuildInfo.java
+++ b/device_build_interfaces/com/android/tradefed/build/IDeviceBuildInfo.java
@@ -29,9 +29,7 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public String getDeviceBuildId();
 
-    /**
-     * Optional method to return the type of the platform build being tested.
-     */
+    /** Optional method to return the type of the platform build being tested. */
     public String getDeviceBuildFlavor();
 
     /**
@@ -42,14 +40,10 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public default void setDeviceBuildFlavor(String deviceBuildFlavor) {}
 
-    /**
-     * Get the local device image zip file.
-     */
+    /** Get the local device image zip file. */
     public File getDeviceImageFile();
 
-    /**
-     * Get the local device image zip version.
-     */
+    /** Get the local device image zip version. */
     public String getDeviceImageVersion();
 
     /**
@@ -59,14 +53,10 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public void setDeviceImageFile(File deviceImageFile, String version);
 
-    /**
-     * Get the local test userdata image file.
-     */
+    /** Get the local test userdata image file. */
     public File getUserDataImageFile();
 
-    /**
-     * Get the local test userdata image version.
-     */
+    /** Get the local test userdata image version. */
     public String getUserDataImageVersion();
 
     /**
@@ -76,14 +66,10 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public void setUserDataImageFile(File userDataFile, String version);
 
-    /**
-     * Get the local path to the extracted tests.zip file contents.
-     */
+    /** Get the local path to the extracted tests.zip file contents. */
     public File getTestsDir();
 
-    /**
-     * Get the extracted tests.zip version.
-     */
+    /** Get the extracted tests.zip version. */
     public String getTestsDirVersion();
 
     /**
@@ -109,14 +95,10 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public void setTestsDir(File testsZipFile, String version);
 
-    /**
-     * Get the local baseband image file.
-     */
+    /** Get the local baseband image file. */
     public File getBasebandImageFile();
 
-    /**
-     * Get the baseband version.
-     */
+    /** Get the baseband version. */
     public String getBasebandVersion();
 
     /**
@@ -127,14 +109,10 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public void setBasebandImage(File basebandFile, String version);
 
-    /**
-     * Get the local bootloader image file.
-     */
+    /** Get the local bootloader image file. */
     public File getBootloaderImageFile();
 
-    /**
-     * Get the bootloader version.
-     */
+    /** Get the bootloader version. */
     public String getBootloaderVersion();
 
     /**
@@ -145,55 +123,34 @@ public interface IDeviceBuildInfo extends IBuildInfo {
      */
     public void setBootloaderImageFile(File bootloaderImgFile, String version);
 
-    /**
-     * Get the device OTA package zip file.
-     */
+    /** Get the device OTA package zip file. */
     public File getOtaPackageFile();
 
-    /**
-     * Get the device OTA package zip version.
-     */
+    /** Get the device OTA package zip version. */
     public String getOtaPackageVersion();
 
-    /**
-     * Set the device OTA package zip file.
-     */
+    /** Set the device OTA package zip file. */
     public void setOtaPackageFile(File otaFile, String version);
 
-    /**
-     * Gets the mkbootimg file used to create the kernel image.
-     */
+    /** Gets the mkbootimg file used to create the kernel image. */
     public File getMkbootimgFile();
 
-    /**
-     * Gets the mkbootimg version.
-     */
+    /** Gets the mkbootimg version. */
     public String getMkbootimgVersion();
 
-    /**
-     * Sets the mkbootimg file used to create the kernel image.
-     */
+    /** Sets the mkbootimg file used to create the kernel image. */
     public void setMkbootimgFile(File mkbootimg, String version);
 
-    /**
-     * Gets the ramdisk file used to create the kernel image.
-     */
+    /** Gets the ramdisk file used to create the kernel image. */
     public File getRamdiskFile();
 
-    /**
-     * Gets the ramdisk version.
-     */
+    /** Gets the ramdisk version. */
     public String getRamdiskVersion();
 
-    /**
-     * Gets the ramdisk file used to create the kernel image.
-     */
+    /** Gets the ramdisk file used to create the kernel image. */
     public void setRamdiskFile(File ramdisk, String version);
 
-    /**
-     * Removes all temporary files.
-     */
+    /** Removes all temporary files. */
     @Override
     public void cleanUp();
-
 }
diff --git a/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java b/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java
index db9aa168e..6524f5b1e 100644
--- a/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java
+++ b/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java
@@ -219,4 +219,9 @@ public interface IDeviceStateMonitor {
 
     /** Gets the fastboot mode serial number. */
     public String getFastbootSerialNumber();
+
+    /** Attach a final state to abort waitForDeviceState if reached. */
+    public default void attachFinalState(TestDeviceState finalState) {
+        // Empty by default
+    }
 }
diff --git a/device_build_interfaces/com/android/tradefed/device/INativeDevice.java b/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
index c3777af44..5904a975f 100644
--- a/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
@@ -82,6 +82,14 @@ public interface INativeDevice {
      */
     public String getSerialNumber();
 
+    /** For device management purpose track the serial we use for referencing the device. */
+    public void setTrackingSerial(String trackingSerial);
+
+    /** For device management purpose get the serial used to track the device. */
+    public default String getTrackingSerial() {
+        return getSerialNumber();
+    }
+
     /** Returns the fastboot mode serial number. */
     public String getFastbootSerialNumber();
 
diff --git a/device_build_interfaces/com/android/tradefed/device/ITestDevice.java b/device_build_interfaces/com/android/tradefed/device/ITestDevice.java
index 687bc17ce..4518a25de 100644
--- a/device_build_interfaces/com/android/tradefed/device/ITestDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/ITestDevice.java
@@ -886,7 +886,11 @@ public interface ITestDevice extends INativeDevice {
      * @return the userId of the primary user if there is one, and null if there is no primary user.
      * @throws DeviceNotAvailableException
      * @throws DeviceRuntimeException if the output from the device is not as expected.
+     * @deprecated getPrimaryUser was deprecated from UserManager service, use
+     *             {@link android.os.UserManager#getMainUserId()} to get first full user
+     *             or 0 for system. Note that for headless system it is not a full user.
      */
+    @Deprecated
     public Integer getPrimaryUserId() throws DeviceNotAvailableException;
 
     /**
diff --git a/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java b/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
index eec9adae2..c5e0cc155 100644
--- a/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
+++ b/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
@@ -1030,5 +1030,13 @@ public class TestDeviceOptions {
     public boolean useOxygenationDevice() {
         return mUseOxygenationDevice;
     }
+
+    /** Helper to return true if the device is launched by cvd, false otherwise. */
+    public boolean useCvdCF() {
+        if (mUseOxygenationDevice || getExtraOxygenArgs().containsKey("use_cvd")) {
+            return true;
+        }
+        return false;
+    }
 }
 
diff --git a/global_configuration/com/android/tradefed/config/gcs/GCSConfigurationServer.java b/global_configuration/com/android/tradefed/config/gcs/GCSConfigurationServer.java
index 6cf74ff4c..90ae7227c 100644
--- a/global_configuration/com/android/tradefed/config/gcs/GCSConfigurationServer.java
+++ b/global_configuration/com/android/tradefed/config/gcs/GCSConfigurationServer.java
@@ -26,7 +26,6 @@ import com.android.tradefed.util.GCSFileDownloader;
 import com.google.common.annotations.VisibleForTesting;
 
 import java.io.File;
-import java.io.IOException;
 import java.io.InputStream;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -191,7 +190,7 @@ public class GCSConfigurationServer implements IConfigurationServer {
     InputStream downloadFileToInputStream(String name) throws ConfigurationException {
         try {
             return getFileDownloader().downloadFile(mBucketName, name);
-        } catch (IOException e) {
+        } catch (Exception e) {
             throw new ConfigurationException("failed to download from GCS", e);
         }
     }
diff --git a/global_configuration/com/android/tradefed/util/hostmetric/HeapHostMonitor.java b/global_configuration/com/android/tradefed/util/hostmetric/HeapHostMonitor.java
index 79af3759a..124113924 100644
--- a/global_configuration/com/android/tradefed/util/hostmetric/HeapHostMonitor.java
+++ b/global_configuration/com/android/tradefed/util/hostmetric/HeapHostMonitor.java
@@ -15,16 +15,15 @@
  */
 package com.android.tradefed.util.hostmetric;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log.LogLevel;
+import com.android.tradefed.log.LogRegistry;
 
 import com.google.common.annotations.VisibleForTesting;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import com.android.tradefed.log.LogRegistry;
-
 /**
  * {@link AbstractHostMonitor} implementation that monitors the heap memory on the host and log it
  * periodically to the history log.
diff --git a/invocation_interfaces/com/android/tradefed/invoker/TestInformation.java b/invocation_interfaces/com/android/tradefed/invoker/TestInformation.java
index a9a69937e..993e73aa2 100644
--- a/invocation_interfaces/com/android/tradefed/invoker/TestInformation.java
+++ b/invocation_interfaces/com/android/tradefed/invoker/TestInformation.java
@@ -22,6 +22,7 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.SearchArtifactUtil;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -192,6 +193,19 @@ public class TestInformation {
     public File getDependencyFile(String fileName, boolean targetFirst)
             throws FileNotFoundException {
         File dependency = null;
+        try {
+            dependency = SearchArtifactUtil.searchFile(fileName, targetFirst, this);
+        } catch (Exception e) {
+            // TODO: handle error when migration is complete.
+            CLog.e(e);
+        }
+        if (dependency != null && dependency.isFile()) {
+            return dependency;
+        } else {
+            // Silently report not found and fall back to old logic.
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, 1);
+        }
         dependency = getFromEnv(fileName, targetFirst);
         if (dependency != null && dependency.isFile()) {
             return dependency;
@@ -208,6 +222,9 @@ public class TestInformation {
         if (dependency != null && dependency.isFile()) {
             return dependency;
         }
+        // if old logic fails too, do not report search artifact failure
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, -1);
         throw new FileNotFoundException(
                 String.format("Could not find an artifact file associated with %s", fileName));
     }
diff --git a/invocation_interfaces/com/android/tradefed/invoker/logger/CurrentInvocation.java b/invocation_interfaces/com/android/tradefed/invoker/logger/CurrentInvocation.java
index 8408e9bdb..fc02c4b99 100644
--- a/invocation_interfaces/com/android/tradefed/invoker/logger/CurrentInvocation.java
+++ b/invocation_interfaces/com/android/tradefed/invoker/logger/CurrentInvocation.java
@@ -70,6 +70,7 @@ public class CurrentInvocation {
         public IsolationGrade mIsModuleIsolated = IsolationGrade.FULLY_ISOLATED;
         public IsolationGrade mIsRunIsolated = IsolationGrade.FULLY_ISOLATED;
         public IInvocationContext mContext;
+        public IInvocationContext mModuleContext;
     }
 
     /**
@@ -218,6 +219,31 @@ public class CurrentInvocation {
         }
     }
 
+    /** Sets the module {@link IInvocationContext} of the currently running module. */
+    public static void setModuleContext(IInvocationContext moduleContext) {
+        ThreadGroup group = Thread.currentThread().getThreadGroup();
+        synchronized (mPerGroupInfo) {
+            if (mPerGroupInfo.get(group) == null) {
+                mPerGroupInfo.put(group, new InternalInvocationTracking());
+            }
+            mPerGroupInfo.get(group).mModuleContext = moduleContext;
+        }
+    }
+
+    /**
+     * Returns the module {@link IInvocationContext} for the current module. Can be null if out of
+     * scope of a module run.
+     */
+    public static @Nullable IInvocationContext getModuleContext() {
+        ThreadGroup group = Thread.currentThread().getThreadGroup();
+        synchronized (mPerGroupInfo) {
+            if (mPerGroupInfo.get(group) == null) {
+                return null;
+            }
+            return mPerGroupInfo.get(group).mModuleContext;
+        }
+    }
+
     /** Returns whether the current suite module executed was isolated or not. */
     public static IsolationGrade moduleCurrentIsolation() {
         ThreadGroup group = Thread.currentThread().getThreadGroup();
diff --git a/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java b/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
new file mode 100644
index 000000000..7c7e8f5cf
--- /dev/null
+++ b/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
@@ -0,0 +1,409 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.invoker.ExecutionFiles;
+import com.android.tradefed.invoker.ExecutionFiles.FilesKey;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
+import com.android.tradefed.invoker.logger.CurrentInvocation.InvocationInfo;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.targetprep.AltDirBehavior;
+import com.android.tradefed.testtype.Abi;
+import com.android.tradefed.testtype.IAbi;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+/** A utility class that can be used to search for test artifacts. */
+public class SearchArtifactUtil {
+    // The singleton is used for mocking the non-static methods during testing..
+    @VisibleForTesting public static SearchArtifactUtil singleton = new SearchArtifactUtil();
+    private static final String MODULE_NAME = "module-name";
+    private static final String MODULE_ABI = "module-abi";
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(String fileName, boolean targetFirst) {
+        return searchFile(fileName, targetFirst, null, null, null, null);
+    }
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @param testInfo The {@link TestInformation} of the current test when available.
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(String fileName, boolean targetFirst, TestInformation testInfo) {
+        return searchFile(fileName, targetFirst, null, null, null, testInfo);
+    }
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @param abi The {@link IAbi} to match the file.
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(String fileName, boolean targetFirst, IAbi abi) {
+        return searchFile(fileName, targetFirst, abi, null, null, null);
+    }
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @param altDirs Alternative search paths, in addition to the default search paths.
+     * @param altDirBehavior how alternative search paths should be used against default paths: as
+     *     fallback, or as override; if unspecified, fallback will be used
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(
+            String fileName,
+            boolean targetFirst,
+            List<File> altDirs,
+            AltDirBehavior altDirBehavior) {
+        return searchFile(fileName, targetFirst, null, altDirs, altDirBehavior, null);
+    }
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @param abi The {@link IAbi} to match the file.
+     * @param altDirs Alternative search paths, in addition to the default search paths.
+     * @param altDirBehavior how alternative search paths should be used against default paths: as
+     *     fallback, or as override; if unspecified, fallback will be used
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(
+            String fileName,
+            boolean targetFirst,
+            IAbi abi,
+            List<File> altDirs,
+            AltDirBehavior altDirBehavior,
+            TestInformation testInfo) {
+        List<File> searchDirectories =
+                singleton.getSearchDirectories(targetFirst, altDirs, altDirBehavior, testInfo);
+
+        // Search in the test directories
+        for (File dir : searchDirectories) {
+            File file = findFile(fileName, abi, dir);
+            if (fileExists(file)) {
+                return file;
+            }
+        }
+        // Search in the execution files directly
+        ExecutionFiles executionFiles = singleton.getExecutionFiles(testInfo);
+        if (executionFiles != null) {
+            File file = executionFiles.get(fileName);
+            if (fileExists(file)) {
+                return file;
+            }
+        }
+
+        // Search in the build info or stage remote file as fallback
+        IBuildInfo buildInfo = singleton.getBuildInfo();
+        if (buildInfo != null) {
+            File file = buildInfo.getFile(fileName);
+            if (fileExists(file)) {
+                return file;
+            } else {
+                // fallback to staging from remote zip files.
+                File stagingDir = getWorkFolder(testInfo);
+                if (fileExists(stagingDir)) {
+                    buildInfo.stageRemoteFile(fileName, stagingDir);
+                    // multiple matching files can be staged. So do a search with module name and
+                    // abi in consideration.
+                    file = findFile(fileName, abi, stagingDir);
+                    if (fileExists(file)) {
+                        InvocationMetricLogger.addInvocationMetrics(
+                                InvocationMetricKey.STAGE_UNDEFINED_DEPENDENCY, fileName);
+                        return file;
+                    }
+                }
+            }
+        }
+        CLog.e("Could not find an artifact file associated with %s.", fileName);
+        return null;
+    }
+
+    /** Returns the list of search locations in correct order. */
+    @VisibleForTesting
+    List<File> getSearchDirectories(
+            boolean targetFirst,
+            List<File> altDirs,
+            AltDirBehavior altDirBehavior,
+            TestInformation testInfo) {
+        List<File> dirs = new LinkedList<>();
+        ExecutionFiles executionFiles = singleton.getExecutionFiles(testInfo);
+        if (executionFiles != null) {
+            // Add host/testcases or target/testcases directory first
+            FilesKey hostOrTarget = FilesKey.HOST_TESTS_DIRECTORY;
+            if (targetFirst) {
+                hostOrTarget = FilesKey.TARGET_TESTS_DIRECTORY;
+            }
+            File testcasesDir = executionFiles.get(hostOrTarget);
+            if (fileExists(testcasesDir)) {
+                dirs.add(testcasesDir);
+            }
+
+            // Add root test directory
+            File rootTestDir = executionFiles.get(FilesKey.TESTS_DIRECTORY);
+            if (fileExists(rootTestDir)) {
+                dirs.add(rootTestDir);
+            }
+        } else {
+            // try getting the search directories from the build info.
+            IBuildInfo buildInfo = singleton.getBuildInfo();
+            if (buildInfo != null) {
+
+                // Add host/testcases or target/testcases directory first
+                BuildInfoFileKey hostOrTarget = BuildInfoFileKey.HOST_LINKED_DIR;
+                if (targetFirst) {
+                    hostOrTarget = BuildInfoFileKey.TARGET_LINKED_DIR;
+                }
+                File testcasesDir = buildInfo.getFile(hostOrTarget);
+                if (fileExists(testcasesDir)) {
+                    dirs.add(testcasesDir);
+                }
+
+                // Add root test directory
+                File rootTestDir = null;
+                if (buildInfo instanceof IDeviceBuildInfo) {
+                    rootTestDir = ((IDeviceBuildInfo) buildInfo).getTestsDir();
+                }
+                if (!fileExists(rootTestDir)) {
+                    rootTestDir = buildInfo.getFile(BuildInfoFileKey.TESTDIR_IMAGE);
+                }
+                if (!fileExists(rootTestDir)) {
+                    rootTestDir = buildInfo.getFile(BuildInfoFileKey.ROOT_DIRECTORY);
+                }
+                if (fileExists(rootTestDir)) {
+                    dirs.add(rootTestDir);
+                }
+            }
+        }
+
+        // Add alternative directories based on the alt dir behavior
+        if (altDirs != null) {
+            // reverse the order so ones provided via command line last can be searched first
+            Collections.reverse(altDirs);
+            if (altDirBehavior == null || AltDirBehavior.FALLBACK.equals(altDirBehavior)) {
+                dirs.addAll(altDirs);
+            } else {
+                altDirs.addAll(dirs);
+                dirs = altDirs;
+            }
+        }
+
+        // Add working directory at the end as a last resort
+        File workDir = getWorkFolder(testInfo);
+        if (fileExists(workDir)) {
+            dirs.add(workDir);
+        }
+        return dirs;
+    }
+
+    /** Searches for the file in the given search directory and possibly matching the abi. */
+    private static File findFile(String filename, IAbi abi, File searchDirectory) {
+        if (filename == null || searchDirectory == null || !searchDirectory.exists()) {
+            return null;
+        }
+        // Try looking for abi if not provided.
+        if (abi == null) {
+            abi = findModuleAbi();
+        }
+        File retFile;
+        String moduleName = singleton.findModuleName();
+        // Check under module subdirectory first if it is present.
+        if (!Strings.isNullOrEmpty(moduleName)) {
+            try {
+                File moduleDir = FileUtil.findDirectory(moduleName, searchDirectory);
+                if (moduleDir != null) {
+                    CLog.d("Searching the module dir: %s", moduleDir);
+                    // search with abi filtering on first
+                    retFile = FileUtil.findFile(filename, abi, moduleDir);
+                    if (fileExists(retFile)) {
+                        return retFile;
+                    }
+                    // search without the abi filter
+                    retFile = FileUtil.findFile(filename, null, moduleDir);
+                    if (fileExists(retFile)) {
+                        return retFile;
+                    }
+                } else {
+                    CLog.w(
+                            "we have a module name: %s but no directory found in %s.",
+                            moduleName, searchDirectory);
+                }
+            } catch (IOException e) {
+                CLog.w(
+                        "Something went wrong while searching for the module '%s' directory.",
+                        moduleName);
+                CLog.e(e);
+            }
+        }
+
+        // if module subdirectory not present or file not found, search under the entire directory
+        try {
+            Set<File> allMatch = FileUtil.findFilesObject(searchDirectory, filename, false);
+            if (allMatch.size() == 1) {
+                // if only one file found, return this one since we can not filter anymore.
+                return allMatch.iterator().next();
+            } else if (allMatch.size() > 1) {
+                // prioritize the top level file to avoid selecting from a wrong module directory.
+                for (File f : allMatch) {
+                    if (searchDirectory.getAbsolutePath().equals(f.getParent())) {
+                        return f;
+                    }
+                }
+                // if top level not found, prioritize the one with the correct abi
+                if (abi != null) {
+                    for (File f : allMatch) {
+                        if (f.getParentFile()
+                                .getName()
+                                .equals(AbiUtils.getArchForAbi(abi.getName()))) {
+                            return f;
+                        }
+                    }
+                }
+                // if abi not matches, return any of them
+                return allMatch.iterator().next();
+            }
+        } catch (IOException e) {
+            CLog.w(
+                    "Something went wrong while searching for file %s under the directory '%s'.",
+                    filename, moduleName);
+            CLog.e(e);
+        }
+        CLog.w("Failed to find test file %s from directory %s.", filename, searchDirectory);
+        return null;
+    }
+
+    /**
+     * Finds the module directory that matches the given module name
+     *
+     * @param moduleName The name of the module.
+     * @param targetFirst Whether we are favoring target-side vs. host-side for the search.
+     * @return the module directory. Can be null.
+     */
+    public static File findModuleDir(String moduleName, boolean targetFirst) {
+        try (CloseableTraceScope ignored = new CloseableTraceScope("findModuleDir")) {
+            List<File> searchDirectories =
+                    singleton.getSearchDirectories(targetFirst, null, null, null);
+            for (File searchDirectory : searchDirectories) {
+                try {
+                    File moduleDir = FileUtil.findDirectory(moduleName, searchDirectory);
+                    if (moduleDir != null && moduleDir.exists()) {
+                        return moduleDir;
+                    }
+                } catch (IOException e) {
+                    CLog.w(
+                            "Something went wrong while searching for the module '%s' directory in"
+                                    + " %s.",
+                            moduleName, searchDirectory);
+                    CLog.e(e);
+                }
+            }
+            return null;
+        }
+    }
+
+    /** returns the module name for the current test invocation if present. */
+    @VisibleForTesting
+    String findModuleName() {
+        IInvocationContext moduleContext = CurrentInvocation.getModuleContext();
+        if (moduleContext != null && moduleContext.getAttributes().get(MODULE_NAME) != null) {
+            return moduleContext.getAttributes().get(MODULE_NAME).get(0);
+        } else if (moduleContext != null
+                && moduleContext.getConfigurationDescriptor().getModuleName() != null) {
+            return moduleContext.getConfigurationDescriptor().getModuleName();
+        }
+        return null;
+    }
+
+    /** returns the abi for the current module if present. */
+    private static IAbi findModuleAbi() {
+        IInvocationContext moduleContext = CurrentInvocation.getModuleContext();
+        if (moduleContext != null && moduleContext.getAttributes().get(MODULE_ABI) != null) {
+            String abiName = moduleContext.getAttributes().get(MODULE_ABI).get(0);
+            return new Abi(abiName, AbiUtils.getBitness(abiName));
+        }
+        return null;
+    }
+
+    /** returns the primary build info for the current invocation. */
+    @VisibleForTesting
+    IBuildInfo getBuildInfo() {
+        IInvocationContext context = CurrentInvocation.getInvocationContext();
+        if (context != null
+                && context.getBuildInfos() != null
+                && !context.getBuildInfos().isEmpty()) {
+            return context.getBuildInfos().get(0);
+        }
+        return null;
+    }
+
+    @VisibleForTesting
+    ExecutionFiles getExecutionFiles(TestInformation testInfo) {
+        if (testInfo != null && testInfo.executionFiles() != null) {
+            return testInfo.executionFiles();
+        }
+        return CurrentInvocation.getInvocationFiles();
+    }
+
+    private static File getWorkFolder(TestInformation testInfo) {
+        if (testInfo != null && testInfo.dependenciesFolder() != null) {
+            return testInfo.dependenciesFolder();
+        }
+        return CurrentInvocation.getInfo(InvocationInfo.WORK_FOLDER);
+    }
+
+    private static boolean fileExists(File file) {
+        return file != null && file.exists();
+    }
+}
diff --git a/isolation/com/android/tradefed/isolation/IsolationRunner.java b/isolation/com/android/tradefed/isolation/IsolationRunner.java
index c1965e84d..ebd27cf8f 100644
--- a/isolation/com/android/tradefed/isolation/IsolationRunner.java
+++ b/isolation/com/android/tradefed/isolation/IsolationRunner.java
@@ -77,7 +77,7 @@ public final class IsolationRunner {
                 RunnerReply reply;
                 switch (message.getCommand()) {
                     case RUNNER_OP_STOP:
-                        System.out.println("Received Stop Message");
+                        System.out.println("INFO: IsolationRunner: Received Stop Message");
                         reply =
                                 RunnerReply.newBuilder()
                                         .setRunnerStatus(RunnerStatus.RUNNER_STATUS_FINISHED_OK)
@@ -98,7 +98,7 @@ public final class IsolationRunner {
                         output.flush();
                         break;
                     default:
-                        System.out.println("Received unrecognized message");
+                        System.out.println("INFO: IsolationRunner: Received unrecognized message");
                 }
             }
         } finally {
@@ -121,14 +121,14 @@ public final class IsolationRunner {
     }
 
     private void runTests(OutputStream output, TestParameters params) throws IOException {
-        System.out.println("Filters: ");
+        System.out.println("INFO: IsolationRunner: Filters: ");
         System.out.println(params.getFilter());
 
         List<Class<?>> klasses = this.getClasses(params);
 
         try {
             for (Class<?> klass : klasses) {
-                System.out.println("Starting class: " + klass);
+                System.out.println("INFO: IsolationRunner: Starting class: " + klass);
                 IsolationResultForwarder list = new IsolationResultForwarder(output);
                 JUnitCore runnerCore = new JUnitCore();
                 runnerCore.addListener(list);
@@ -146,13 +146,21 @@ public final class IsolationRunner {
                     if (!params.hasFilter() && isFilterError) {
                         System.err.println(
                                 String.format(
-                                        "Found ErrorRunner when trying to run class: %s", klass));
+                                        "ERROR: IsolationRunner: Found ErrorRunner when trying to"
+                                                + " run class: %s",
+                                        klass));
                         runnerCore.run(req.getRunner());
+                    } else {
+                        System.err.println(
+                                String.format(
+                                        "ERROR: IsolationRunner: Encountered ErrorReportingRunner"
+                                                + " when trying to run: %s",
+                                        klass));
                     }
                 } else if (req.getRunner() instanceof IgnoredClassRunner) {
                     // Do nothing since class was ignored
                 } else {
-                    System.out.println("Executing class: " + klass);
+                    System.out.println("INFO: IsolationRunner: Executing class: " + klass);
                     Runner checkRunner = req.getRunner();
 
                     if (params.getDryRun()) {
@@ -184,7 +192,7 @@ public final class IsolationRunner {
     }
 
     private List<Class<?>> getClasses(TestParameters params) {
-        System.out.println("Excluded paths:");
+        System.out.println("INFO: IsolationRunner: Excluded paths:");
         params.getExcludePathsList().stream().forEach(path -> System.out.println(path));
         return HostUtils.getJUnitClasses(
                 new HashSet<>(params.getTestClassesList()),
diff --git a/javatests/.classpath b/javatests/.classpath
index 2f25b5b2a..eacebd764 100644
--- a/javatests/.classpath
+++ b/javatests/.classpath
@@ -22,8 +22,6 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/sdklib/sdklib-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/tools-common/tools-common-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/tools/common/m2/repository/org/mockito/mockito-core/4.6.1/mockito-core-4.6.1.jar" sourcepath="/TRADEFED_ROOT/prebuilts/tools/common/m2/repository/org/mockito/mockito-core/4.6.1/mockito-core-4.6.1-sources.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/mockito/mockito-byte-buddy-agent/linux_glibc_common/combined/mockito-byte-buddy-agent.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/mockito/mockito-byte-buddy/linux_glibc_common/combined/mockito-byte-buddy.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/truth/truth/linux_glibc_common/combined/truth.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/jacoco/jacoco-cli/linux_glibc_common/combined/jacoco-cli.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/tools/tradefederation/core/tradefed-protos/linux_glibc_common/combined/tradefed-protos.jar"/>
@@ -44,5 +42,11 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/apache-commons-compress/apache-commons-compress/linux_glibc_common/combined/apache-commons-compress.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/kxml2/kxml2-2.3.0.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/misc/common/json/json-prebuilt/linux_glibc_common/combined/json-prebuilt.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/bazelbuild-remote-apis/build/bazel/remote/execution/v2/remote-execution-java-grpc/linux_glibc_common/javac/remote-execution-java-grpc.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/bazelbuild-remote-apis/build/bazel/remote/execution/v2/remote-execution-java-proto/linux_glibc_common/combined/remote-execution-java-proto.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/googleapis/google/bytestream/bytestream-java-grpc/linux_glibc_common/javac/bytestream-java-grpc.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/googleapis/google/bytestream/bytestream-java-proto/linux_glibc_common/combined/bytestream-java-proto.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/prebuilts/tools/common/m2/google-auth-library-credentials-1.23.0/linux_glibc_common/combined/google-auth-library-credentials-1.23.0.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/mockito/mockito/linux_glibc_common/combined/mockito.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/javatests/Android.bp b/javatests/Android.bp
index 7de4e2fb1..0f07d6eb4 100644
--- a/javatests/Android.bp
+++ b/javatests/Android.bp
@@ -64,6 +64,7 @@ tradefed_java_library_host {
     ],
     libs: [
         "tradefed",
+        "tradefed-avd-util-tests",
         "libprotobuf-java-full",
         "truth",
         "loganalysis",
diff --git a/javatests/com/android/tradefed/UnitTests.java b/javatests/com/android/tradefed/UnitTests.java
index ffd1c8c84..f9ca11d83 100644
--- a/javatests/com/android/tradefed/UnitTests.java
+++ b/javatests/com/android/tradefed/UnitTests.java
@@ -25,13 +25,16 @@ import com.android.tradefed.build.DeviceBuildInfoTest;
 import com.android.tradefed.build.DeviceFolderBuildInfoTest;
 import com.android.tradefed.build.FileDownloadCacheTest;
 import com.android.tradefed.build.LocalDeviceBuildProviderTest;
-import com.android.tradefed.build.OtaZipfileBuildProviderTest;
 import com.android.tradefed.build.cache.PartialZipDownloadCacheTest;
 import com.android.tradefed.build.content.ArtifactDetailsTest;
 import com.android.tradefed.build.content.ContentAnalysisResultsTest;
+import com.android.tradefed.build.content.DeviceMerkleTreeTest;
 import com.android.tradefed.build.content.TestContentAnalyzerTest;
 import com.android.tradefed.cache.MerkleTreeTest;
+import com.android.tradefed.cache.UploadManifestTest;
 import com.android.tradefed.cache.remote.ByteStreamDownloaderTest;
+import com.android.tradefed.cache.remote.ByteStreamUploaderTest;
+import com.android.tradefed.cache.remote.ChunkerTest;
 import com.android.tradefed.cache.remote.RemoteCacheClientTest;
 import com.android.tradefed.clearcut.ClearcutClientTest;
 import com.android.tradefed.cluster.ClusterBuildProviderTest;
@@ -98,12 +101,9 @@ import com.android.tradefed.device.cloud.AcloudConfigParserTest;
 import com.android.tradefed.device.cloud.CommonLogRemoteFileUtilTest;
 import com.android.tradefed.device.cloud.GceAvdInfoTest;
 import com.android.tradefed.device.cloud.GceManagerTest;
-import com.android.tradefed.device.cloud.GceRemoteCmdFormatterTest;
 import com.android.tradefed.device.cloud.GceSshTunnelMonitorTest;
-import com.android.tradefed.device.cloud.HostOrchestratorUtilTest;
 import com.android.tradefed.device.cloud.ManagedRemoteDeviceTest;
 import com.android.tradefed.device.cloud.NestedRemoteDeviceTest;
-import com.android.tradefed.device.cloud.OxygenClientTest;
 import com.android.tradefed.device.cloud.OxygenUtilTest;
 import com.android.tradefed.device.cloud.RemoteAndroidVirtualDeviceTest;
 import com.android.tradefed.device.cloud.RemoteFileUtilTest;
@@ -164,6 +164,7 @@ import com.android.tradefed.invoker.logger.InvocationLocalTest;
 import com.android.tradefed.invoker.logger.InvocationMetricLoggerTest;
 import com.android.tradefed.invoker.logger.TfObjectTrackerTest;
 import com.android.tradefed.invoker.sandbox.ParentSandboxInvocationExecutionTest;
+import com.android.tradefed.invoker.shard.DynamicShardHelperTest;
 import com.android.tradefed.invoker.shard.ParentShardReplicateTest;
 import com.android.tradefed.invoker.shard.RemoteDynamicPoolTest;
 import com.android.tradefed.invoker.shard.ShardHelperTest;
@@ -226,9 +227,11 @@ import com.android.tradefed.result.XmlResultReporterTest;
 import com.android.tradefed.result.ddmlib.TestRunToTestInvocationForwarderTest;
 import com.android.tradefed.result.error.ErrorIdentifierTest;
 import com.android.tradefed.result.proto.FileProtoResultReporterTest;
+import com.android.tradefed.result.proto.ModuleProtoResultReporterTest;
 import com.android.tradefed.result.proto.ProtoResultParserTest;
 import com.android.tradefed.result.proto.ProtoResultReporterTest;
 import com.android.tradefed.result.proto.StreamProtoResultReporterTest;
+import com.android.tradefed.result.skipped.SkipFeatureTest;
 import com.android.tradefed.result.skipped.SkipManagerTest;
 import com.android.tradefed.result.skipped.SkipReasonTest;
 import com.android.tradefed.result.suite.FormattedGeneratorReporterTest;
@@ -281,12 +284,14 @@ import com.android.tradefed.targetprep.GsiDeviceFlashPreparerTest;
 import com.android.tradefed.targetprep.InstallAllTestZipAppsSetupTest;
 import com.android.tradefed.targetprep.InstallApexModuleTargetPreparerTest;
 import com.android.tradefed.targetprep.InstallApkSetupTest;
+import com.android.tradefed.targetprep.InstallKernelModulePreparerTest;
 import com.android.tradefed.targetprep.InstrumentationPreparerTest;
 import com.android.tradefed.targetprep.KnownFailurePreparerTest;
 import com.android.tradefed.targetprep.LocalEmulatorLaunchTest;
 import com.android.tradefed.targetprep.MixKernelTargetPreparerTest;
 import com.android.tradefed.targetprep.ModuleOemTargetPreparerTest;
 import com.android.tradefed.targetprep.ModulePusherTest;
+import com.android.tradefed.targetprep.OtaUpdateDeviceFlasherTest;
 import com.android.tradefed.targetprep.PushFilePreparerTest;
 import com.android.tradefed.targetprep.PythonVirtualenvPreparerTest;
 import com.android.tradefed.targetprep.RebootTargetPreparerTest;
@@ -430,10 +435,12 @@ import com.android.tradefed.util.FileUtilTest;
 import com.android.tradefed.util.FixedByteArrayOutputStreamTest;
 import com.android.tradefed.util.FuseUtilTest;
 import com.android.tradefed.util.GCSFileDownloaderTest;
+import com.android.tradefed.util.GceRemoteCmdFormatterTest;
 import com.android.tradefed.util.GoogleApiClientUtilTest;
 import com.android.tradefed.util.HprofAllocSiteParserTest;
 import com.android.tradefed.util.JUnitXmlParserTest;
 import com.android.tradefed.util.JavaCodeCoverageFlusherTest;
+import com.android.tradefed.util.KernelModuleUtilsTest;
 import com.android.tradefed.util.KeyguardControllerStateTest;
 import com.android.tradefed.util.ListInstrumentationParserTest;
 import com.android.tradefed.util.LocalRunInstructionBuilderTest;
@@ -454,6 +461,7 @@ import com.android.tradefed.util.RequestUtilTest;
 import com.android.tradefed.util.ResourceUtilTest;
 import com.android.tradefed.util.RestApiHelperTest;
 import com.android.tradefed.util.RunUtilTest;
+import com.android.tradefed.util.SearchArtifactUtilTest;
 import com.android.tradefed.util.SerializationUtilTest;
 import com.android.tradefed.util.ShellOutputReceiverStreamTest;
 import com.android.tradefed.util.SimplePerfStatResultParserTest;
@@ -519,7 +527,6 @@ import org.junit.runners.Suite.SuiteClasses;
     DeviceFolderBuildInfoTest.class,
     FileDownloadCacheTest.class,
     LocalDeviceBuildProviderTest.class,
-    OtaZipfileBuildProviderTest.class,
 
     // build.cache
     PartialZipDownloadCacheTest.class,
@@ -527,12 +534,16 @@ import org.junit.runners.Suite.SuiteClasses;
     // build.content
     ArtifactDetailsTest.class,
     ContentAnalysisResultsTest.class,
+    DeviceMerkleTreeTest.class,
     TestContentAnalyzerTest.class,
 
     // cache
     MerkleTreeTest.class,
     ByteStreamDownloaderTest.class,
+    ByteStreamUploaderTest.class,
+    ChunkerTest.class,
     RemoteCacheClientTest.class,
+    UploadManifestTest.class,
 
     // clearcut
     ClearcutClientTest.class,
@@ -624,12 +635,9 @@ import org.junit.runners.Suite.SuiteClasses;
     CommonLogRemoteFileUtilTest.class,
     GceAvdInfoTest.class,
     GceManagerTest.class,
-    GceRemoteCmdFormatterTest.class,
     GceSshTunnelMonitorTest.class,
-    HostOrchestratorUtilTest.class,
     ManagedRemoteDeviceTest.class,
     NestedRemoteDeviceTest.class,
-    OxygenClientTest.class,
     OxygenUtilTest.class,
     RemoteAndroidVirtualDeviceTest.class,
     RemoteFileUtilTest.class,
@@ -714,6 +722,7 @@ import org.junit.runners.Suite.SuiteClasses;
     TfObjectTrackerTest.class,
 
     // invoker.shard
+    DynamicShardHelperTest.class,
     ParentShardReplicateTest.class,
     RemoteDynamicPoolTest.class,
     ShardHelperTest.class,
@@ -793,11 +802,13 @@ import org.junit.runners.Suite.SuiteClasses;
 
     // result.proto
     FileProtoResultReporterTest.class,
+    ModuleProtoResultReporterTest.class,
     ProtoResultParserTest.class,
     ProtoResultReporterTest.class,
     StreamProtoResultReporterTest.class,
 
     // result.skipped
+    SkipFeatureTest.class,
     SkipManagerTest.class,
     SkipReasonTest.class,
 
@@ -833,6 +844,7 @@ import org.junit.runners.Suite.SuiteClasses;
     InstallAllTestZipAppsSetupTest.class,
     InstallApexModuleTargetPreparerTest.class,
     InstallApkSetupTest.class,
+    InstallKernelModulePreparerTest.class,
     InstrumentationPreparerTest.class,
     KnownFailurePreparerTest.class,
     LocalEmulatorLaunchTest.class,
@@ -862,6 +874,7 @@ import org.junit.runners.Suite.SuiteClasses;
     SwitchUserTargetPreparerTest.class,
     UserCleanerTest.class,
     VisibleBackgroundUserPreparerTest.class,
+    OtaUpdateDeviceFlasherTest.class,
 
     // targetprep.adb
     AdbStopServerPreparerTest.class,
@@ -1044,11 +1057,13 @@ import org.junit.runners.Suite.SuiteClasses;
     FileUtilTest.class,
     FixedByteArrayOutputStreamTest.class,
     FuseUtilTest.class,
+    GceRemoteCmdFormatterTest.class,
     GCSFileDownloaderTest.class,
     GoogleApiClientUtilTest.class,
     HprofAllocSiteParserTest.class,
     JavaCodeCoverageFlusherTest.class,
     JUnitXmlParserTest.class,
+    KernelModuleUtilsTest.class,
     KeyguardControllerStateTest.class,
     LegacySubprocessResultsReporterTest.class,
     ListInstrumentationParserTest.class,
@@ -1069,6 +1084,7 @@ import org.junit.runners.Suite.SuiteClasses;
     RestApiHelperTest.class,
     RequestUtilTest.class,
     RunUtilTest.class,
+    SearchArtifactUtilTest.class,
     SerializationUtilTest.class,
     ShellOutputReceiverStreamTest.class,
     SimplePerfStatResultParserTest.class,
diff --git a/javatests/com/android/tradefed/build/OtaZipfileBuildProviderTest.java b/javatests/com/android/tradefed/build/OtaZipfileBuildProviderTest.java
deleted file mode 100644
index 807b50f0c..000000000
--- a/javatests/com/android/tradefed/build/OtaZipfileBuildProviderTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tradefed.build;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.File;
-
-/** Tests for {@link OtaZipfileBuildProvider} */
-@RunWith(JUnit4.class)
-public class OtaZipfileBuildProviderTest {
-    private static final String SOME_BAD_PATH = "/some/inexistent/path.zip";
-    private static final String BUILD_ID = "123456";
-    private static final String MOCK_BUILD_PROP =
-        "some.fake.property=some_value\n" +
-        "ro.build.version.incremental=" + BUILD_ID + "\n" +
-        "some.other.fake.property=some_value";
-
-    private static class OtaZipfileBuildProviderUnderTest extends OtaZipfileBuildProvider {
-        @Override
-        String getOtaPath() {
-            return SOME_BAD_PATH;
-        }
-    }
-
-    @Test
-    public void testGetBuild_Success() throws BuildRetrievalError {
-        OtaZipfileBuildProviderUnderTest providerAllGood = new OtaZipfileBuildProviderUnderTest() {
-            @Override
-            String getBuildPropContents() {
-                return MOCK_BUILD_PROP;
-            }
-        };
-        IBuildInfo buildInfo = providerAllGood.getBuild();
-        assertEquals(BUILD_ID, buildInfo.getBuildId());
-        assertTrue(buildInfo instanceof IDeviceBuildInfo);
-        assertEquals(new File(SOME_BAD_PATH), ((IDeviceBuildInfo) buildInfo).getOtaPackageFile());
-    }
-
-    @Test
-    public void testGetBuild_NoPath() throws BuildRetrievalError {
-        OtaZipfileBuildProvider providerNoPath = new OtaZipfileBuildProvider();
-        try {
-            providerNoPath.getBuild();
-            fail("Expected to get an IllegalArgumentException when no path was passed");
-        } catch (IllegalArgumentException e) {
-            assertTrue(true);
-        }
-    }
-
-    @Test
-    public void testGetBuild_BadPath() {
-        OtaZipfileBuildProviderUnderTest providerBadPath = new OtaZipfileBuildProviderUnderTest();
-        try {
-            providerBadPath.getBuild();
-            fail("Expected to get an BuildRetrievalError when a bad path was passed");
-        } catch (BuildRetrievalError e) {
-            assertTrue(true);
-        }
-    }
-}
diff --git a/javatests/com/android/tradefed/build/content/ArtifactDetailsTest.java b/javatests/com/android/tradefed/build/content/ArtifactDetailsTest.java
index 16f450d16..57852489c 100644
--- a/javatests/com/android/tradefed/build/content/ArtifactDetailsTest.java
+++ b/javatests/com/android/tradefed/build/content/ArtifactDetailsTest.java
@@ -65,7 +65,7 @@ public class ArtifactDetailsTest {
         }
     }
 
-    private File generateBaseContent() throws IOException {
+    public static File generateBaseContent() throws IOException {
         File content = FileUtil.createTempFile("artifacts-details-test", ".json");
         String baseContent =
                 "[\n"
@@ -108,7 +108,7 @@ public class ArtifactDetailsTest {
         return content;
     }
 
-    private File generateCurrentContent() throws IOException {
+    public static File generateCurrentContent() throws IOException {
         File content = FileUtil.createTempFile("artifacts-details-test", ".json");
         String currentContent =
                 "[\n"
diff --git a/javatests/com/android/tradefed/build/content/ContentAnalysisResultsTest.java b/javatests/com/android/tradefed/build/content/ContentAnalysisResultsTest.java
index ad281203f..da472eee2 100644
--- a/javatests/com/android/tradefed/build/content/ContentAnalysisResultsTest.java
+++ b/javatests/com/android/tradefed/build/content/ContentAnalysisResultsTest.java
@@ -18,10 +18,14 @@ package com.android.tradefed.build.content;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+import com.google.common.truth.Truth;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import java.util.Arrays;
+
 /** Unit tests for {@link ContentAnalysisResults}. */
 @RunWith(JUnit4.class)
 public class ContentAnalysisResultsTest {
@@ -43,8 +47,22 @@ public class ContentAnalysisResultsTest {
 
     @Test
     public void testModifiedModules() {
-        ContentAnalysisResults results = new ContentAnalysisResults().addModifiedModule();
+        ContentAnalysisResults results = new ContentAnalysisResults().addModifiedModule("module1");
 
         assertTrue(results.hasAnyTestsChange());
     }
+
+    @Test
+    public void testModifiedModulesMerge() {
+        ContentAnalysisResults result1 =
+                new ContentAnalysisResults()
+                        .addUnchangedModule("module1")
+                        .addUnchangedModule("module2");
+        ContentAnalysisResults result2 = new ContentAnalysisResults().addModifiedModule("module1");
+
+        ContentAnalysisResults merge =
+                ContentAnalysisResults.mergeResults(Arrays.asList(result1, result2));
+        assertTrue(merge.hasAnyTestsChange());
+        Truth.assertThat(merge.getUnchangedModules()).containsExactly("module2");
+    }
 }
diff --git a/javatests/com/android/tradefed/build/content/DeviceMerkleTreeTest.java b/javatests/com/android/tradefed/build/content/DeviceMerkleTreeTest.java
new file mode 100644
index 000000000..a0a33d13e
--- /dev/null
+++ b/javatests/com/android/tradefed/build/content/DeviceMerkleTreeTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.build.content;
+
+import com.android.tradefed.build.content.ContentAnalysisContext.AnalysisMethod;
+import com.android.tradefed.util.FileUtil;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import com.google.common.truth.Truth;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.File;
+import java.io.IOException;
+
+/** Unit tests for {@link DeviceMerkleTree}. */
+@RunWith(JUnit4.class)
+public class DeviceMerkleTreeTest {
+
+    @Test
+    public void testGenerateDigest() throws IOException {
+        File baseJson = ArtifactDetailsTest.generateBaseContent();
+        File currentJson = ArtifactDetailsTest.generateCurrentContent();
+
+        try {
+            ContentInformation infoBase = new ContentInformation(null, null, baseJson, "8888");
+            ContentAnalysisContext contextBase =
+                    new ContentAnalysisContext(
+                            "mysuite.zip", infoBase, AnalysisMethod.DEVICE_IMAGE);
+            Digest baseDigest = DeviceMerkleTree.buildFromContext(contextBase);
+
+            ContentInformation currentBase =
+                    new ContentInformation(null, null, currentJson, "8888");
+            ContentAnalysisContext contextCurrent =
+                    new ContentAnalysisContext(
+                            "mysuite.zip", currentBase, AnalysisMethod.DEVICE_IMAGE);
+            Digest currentDigest = DeviceMerkleTree.buildFromContext(contextCurrent);
+
+            Truth.assertThat(baseDigest.getHash()).isNotEqualTo(currentDigest.getHash());
+            Truth.assertThat(baseDigest.getHash())
+                    .isEqualTo("a4246469911c553cae9d8ce1b6e40cacb2131d6e07aabe5c28b1c180b4e7114f");
+            Truth.assertThat(currentDigest.getHash())
+                    .isEqualTo("d4f7d421e22f24bbf0a5d3bfad906a475e390b2aa0f69215d587a65ba1c3a484");
+        } finally {
+            FileUtil.deleteFile(baseJson);
+            FileUtil.deleteFile(currentJson);
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/cache/MerkleTreeTest.java b/javatests/com/android/tradefed/cache/MerkleTreeTest.java
index 91cae588f..b2535d0f4 100644
--- a/javatests/com/android/tradefed/cache/MerkleTreeTest.java
+++ b/javatests/com/android/tradefed/cache/MerkleTreeTest.java
@@ -26,6 +26,7 @@ import build.bazel.remote.execution.v2.FileNode;
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.Map;
 import org.junit.Rule;
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
@@ -43,54 +44,56 @@ public class MerkleTreeTest {
         File root = workingDir.getRoot();
         // Not sort the files in purpose to test the digests of two equivalent directories will
         // match.
-        addFile(new File(root, "srcs/bar.cc"), "bar", false);
-        addFile(new File(root, "srcs/foo.cc"), "foo", false);
-        addFile(new File(root, "srcs/fizz/fizzbuzz"), "fizzbuzz", true);
-        addFile(new File(root, "srcs/fizz/buzz.cc"), "buzz", false);
+        File bar = new File(root, "srcs/bar.cc");
+        addFile(bar, "bar", false);
+        Digest barDigest = DigestCalculator.compute(bar);
+        File foo = new File(root, "srcs/foo.cc");
+        addFile(foo, "foo", false);
+        Digest fooDigest = DigestCalculator.compute(foo);
+        File fizzbuzz = new File(root, "srcs/fizz/fizzbuzz");
+        addFile(fizzbuzz, "fizzbuzz", true);
+        Digest fizzbuzzDigest = DigestCalculator.compute(fizzbuzz);
+        File buzz = new File(root, "srcs/fizz/buzz.cc");
+        addFile(buzz, "buzz", false);
+        Digest buzzDigest = DigestCalculator.compute(buzz);
+        Map<Digest, File> digestToFile =
+                Map.of(
+                        barDigest, bar,
+                        fooDigest, foo,
+                        fizzbuzzDigest, fizzbuzz,
+                        buzzDigest, buzz);
         Directory fizzDir =
                 Directory.newBuilder()
-                        .addFiles(
-                                newFileNode(
-                                        "buzz.cc",
-                                        DigestCalculator.compute("buzz".getBytes(UTF_8)),
-                                        false))
-                        .addFiles(
-                                newFileNode(
-                                        "fizzbuzz",
-                                        DigestCalculator.compute("fizzbuzz".getBytes(UTF_8)),
-                                        true))
+                        .addFiles(newFileNode("buzz.cc", buzzDigest, false))
+                        .addFiles(newFileNode("fizzbuzz", fizzbuzzDigest, true))
                         .build();
+        Digest fizzDirDigest = DigestCalculator.compute(fizzDir);
         Directory srcsDir =
                 Directory.newBuilder()
-                        .addFiles(
-                                newFileNode(
-                                        "bar.cc",
-                                        DigestCalculator.compute("bar".getBytes(UTF_8)),
-                                        false))
-                        .addFiles(
-                                newFileNode(
-                                        "foo.cc",
-                                        DigestCalculator.compute("foo".getBytes(UTF_8)),
-                                        false))
+                        .addFiles(newFileNode("bar.cc", barDigest, false))
+                        .addFiles(newFileNode("foo.cc", fooDigest, false))
                         .addDirectories(
-                                DirectoryNode.newBuilder()
-                                        .setName("fizz")
-                                        .setDigest(DigestCalculator.compute(fizzDir)))
+                                DirectoryNode.newBuilder().setName("fizz").setDigest(fizzDirDigest))
                         .build();
+        Digest srcsDirDigest = DigestCalculator.compute(srcsDir);
+        Map<Digest, Directory> digestToSubdir =
+                Map.of(
+                        fizzDirDigest, fizzDir,
+                        srcsDirDigest, srcsDir);
         Directory rootDir =
                 Directory.newBuilder()
                         .addDirectories(
-                                DirectoryNode.newBuilder()
-                                        .setName("srcs")
-                                        .setDigest(DigestCalculator.compute(srcsDir)))
+                                DirectoryNode.newBuilder().setName("srcs").setDigest(srcsDirDigest))
                         .build();
 
         MerkleTree tree = MerkleTree.buildFromDir(root);
 
         assertEquals(tree.rootDigest(), DigestCalculator.compute(rootDir));
+        assertEquals(tree.digestToFile(), digestToFile);
+        assertEquals(tree.digestToSubdir(), digestToSubdir);
     }
 
-    private void addFile(File file, String content, boolean isExecutable) throws IOException {
+    public static void addFile(File file, String content, boolean isExecutable) throws IOException {
         File parent = file.getParentFile();
         if (!parent.exists()) {
             parent.mkdirs();
@@ -100,7 +103,7 @@ public class MerkleTreeTest {
         file.setExecutable(isExecutable);
     }
 
-    private static FileNode newFileNode(String name, Digest digest, boolean isExecutable) {
+    public static FileNode newFileNode(String name, Digest digest, boolean isExecutable) {
         return FileNode.newBuilder()
                 .setName(name)
                 .setDigest(digest)
diff --git a/javatests/com/android/tradefed/cache/UploadManifestTest.java b/javatests/com/android/tradefed/cache/UploadManifestTest.java
new file mode 100644
index 000000000..07fea1395
--- /dev/null
+++ b/javatests/com/android/tradefed/cache/UploadManifestTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.cache;
+
+import static org.junit.Assert.assertEquals;
+
+import com.android.tradefed.util.FileUtil;
+
+import build.bazel.remote.execution.v2.Digest;
+import build.bazel.remote.execution.v2.Directory;
+import build.bazel.remote.execution.v2.FileNode;
+
+import com.google.protobuf.ByteString;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+
+/** Tests for {@link UploadManifest}. */
+@RunWith(JUnit4.class)
+public class UploadManifestTest {
+    private File mWorkFolder;
+
+    @Before
+    public final void setUp() throws Exception {
+        mWorkFolder = FileUtil.createTempDir("work-folder");
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        FileUtil.recursiveDelete(mWorkFolder);
+    }
+
+    @Test
+    public void builder_works() throws IOException {
+        File emptyFileA = FileUtil.createTempFile("empty-a-", ".txt", mWorkFolder);
+        Digest emptyFileADigest = DigestCalculator.compute(emptyFileA);
+        File emptyFileB = FileUtil.createTempFile("empty-b-", ".txt", mWorkFolder);
+        Digest emptyFileBDigest = DigestCalculator.compute(emptyFileB);
+        File testFile = FileUtil.createTempFile("test-", ".txt", mWorkFolder);
+        FileUtil.writeToFile("test", testFile);
+        Digest testFileDigest = DigestCalculator.compute(testFile);
+        Directory defaultDirectoryA = Directory.getDefaultInstance();
+        Digest defaultDirectoryADigest = DigestCalculator.compute(defaultDirectoryA);
+        Directory defaultDirectoryB = Directory.getDefaultInstance();
+        Digest defaultDirectoryBDigest = DigestCalculator.compute(defaultDirectoryB);
+        Directory directory =
+                Directory.newBuilder()
+                        .addFiles(
+                                FileNode.newBuilder()
+                                        .setDigest(testFileDigest)
+                                        .setName(testFile.getName()))
+                        .build();
+        Digest directoryDigest = DigestCalculator.compute(directory);
+        Map<Digest, File> expectedDigestToFile =
+                Map.of(testFileDigest, testFile, emptyFileBDigest, emptyFileB);
+        Map<Digest, ByteString> expectedDigestToBlob =
+                Map.of(
+                        directoryDigest,
+                        directory.toByteString(),
+                        defaultDirectoryBDigest,
+                        defaultDirectoryB.toByteString());
+
+        UploadManifest manifest =
+                UploadManifest.builder()
+                        .addFile(emptyFileADigest, emptyFileA)
+                        .addFiles(expectedDigestToFile)
+                        .addBlob(defaultDirectoryADigest, defaultDirectoryA.toByteString())
+                        .addBlobs(expectedDigestToBlob)
+                        .build();
+
+        assertEquals(emptyFileADigest, emptyFileBDigest);
+        assertEquals(defaultDirectoryADigest, defaultDirectoryBDigest);
+        assertEquals(expectedDigestToFile, manifest.digestToFile());
+        assertEquals(expectedDigestToBlob, manifest.digestToBlob());
+    }
+}
diff --git a/javatests/com/android/tradefed/cache/remote/ByteStreamUploaderTest.java b/javatests/com/android/tradefed/cache/remote/ByteStreamUploaderTest.java
new file mode 100644
index 000000000..02982cdef
--- /dev/null
+++ b/javatests/com/android/tradefed/cache/remote/ByteStreamUploaderTest.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.cache.remote;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import build.bazel.remote.execution.v2.Digest;
+import com.android.tradefed.cache.DigestCalculator;
+import com.google.bytestream.ByteStreamGrpc.ByteStreamImplBase;
+import com.google.bytestream.ByteStreamProto.WriteRequest;
+import com.google.bytestream.ByteStreamProto.WriteResponse;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.protobuf.ByteString;
+import io.grpc.ManagedChannel;
+import io.grpc.Server;
+import io.grpc.stub.StreamObserver;
+import io.grpc.inprocess.InProcessChannelBuilder;
+import io.grpc.inprocess.InProcessServerBuilder;
+import io.grpc.util.MutableHandlerRegistry;
+import java.time.Duration;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.Random;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.junit.Test;
+
+/** Tests for {@link ByteStreamUploader}. */
+@RunWith(JUnit4.class)
+public class ByteStreamUploaderTest {
+    private static final String INSTANCE = "test instance";
+    private final String mFakeServerName = "fake server for " + getClass();
+    private final MutableHandlerRegistry mServiceRegistry = new MutableHandlerRegistry();
+    private ManagedChannel mChannel;
+    private Server mFakeServer;
+    private int mChunkSize = 10;
+
+    private static class FakeByteStreamService extends ByteStreamImplBase {
+        private long mNextOffset = 0;
+        public byte[] receivedData;
+        public String receivedResourceName = null;
+        public int requestCount = 0;
+
+        private FakeByteStreamService(int bufferSize) {
+            this.receivedData = new byte[bufferSize];
+        }
+
+        @Override
+        public StreamObserver<WriteRequest> write(StreamObserver<WriteResponse> streamObserver) {
+            return new StreamObserver<WriteRequest>() {
+                @Override
+                public void onNext(WriteRequest writeRequest) {
+                    if (mNextOffset == 0) {
+                        receivedResourceName = writeRequest.getResourceName();
+                    }
+                    ByteString data = writeRequest.getData();
+                    System.arraycopy(
+                            data.toByteArray(), 0, receivedData, (int) mNextOffset, data.size());
+                    mNextOffset += data.size();
+                    requestCount++;
+                }
+
+                @Override
+                public void onError(Throwable throwable) {
+                    fail("onError should never be called.");
+                }
+
+                @Override
+                public void onCompleted() {
+                    assertEquals(mNextOffset, receivedData.length);
+                    streamObserver.onNext(
+                            WriteResponse.newBuilder().setCommittedSize(mNextOffset).build());
+                    streamObserver.onCompleted();
+                }
+            };
+        }
+    }
+
+    @Before
+    public final void setUp() throws Exception {
+        mFakeServer =
+                InProcessServerBuilder.forName(mFakeServerName)
+                        .fallbackHandlerRegistry(mServiceRegistry)
+                        .directExecutor()
+                        .build()
+                        .start();
+        mChannel = InProcessChannelBuilder.forName(mFakeServerName).directExecutor().build();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        mChannel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
+        mFakeServer.shutdown().awaitTermination(5, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void uploadBlob_single_blob_works() throws InterruptedException, ExecutionException {
+        int bufferSize = 10;
+        byte[] blob = new byte[bufferSize];
+        new Random().nextBytes(blob);
+        Digest digest = DigestCalculator.compute(blob);
+        FakeByteStreamService service = new FakeByteStreamService(bufferSize);
+        mServiceRegistry.addService(service);
+        mChunkSize = 11;
+
+        newUploader().uploadBlob(digest, ByteString.copyFrom(blob)).get();
+
+        assertArrayEquals(service.receivedData, blob);
+        assertTrue(service.receivedResourceName.startsWith(INSTANCE + "/uploads"));
+        assertTrue(
+                service.receivedResourceName.endsWith(
+                        digest.getHash() + "/" + String.valueOf(bufferSize)));
+    }
+
+    @Test
+    public void uploadBlob_multiple_blobs_works() throws InterruptedException, ExecutionException {
+        int bufferSize = 10;
+        byte[] blob = new byte[bufferSize];
+        new Random().nextBytes(blob);
+        FakeByteStreamService service = new FakeByteStreamService(bufferSize);
+        mServiceRegistry.addService(service);
+        mChunkSize = 3;
+
+        newUploader().uploadBlob(DigestCalculator.compute(blob), ByteString.copyFrom(blob)).get();
+
+        assertArrayEquals(service.receivedData, blob);
+        assertEquals(service.requestCount, 4);
+    }
+
+    @Test
+    public void uploadBlob_incorrect_committed_size_fails()
+            throws InterruptedException, ExecutionException {
+        byte[] blob = new byte[10];
+        new Random().nextBytes(blob);
+        mServiceRegistry.addService(
+                new ByteStreamImplBase() {
+                    @Override
+                    public StreamObserver<WriteRequest> write(
+                            StreamObserver<WriteResponse> streamObserver) {
+                        return new StreamObserver<WriteRequest>() {
+                            @Override
+                            public void onNext(WriteRequest writeRequest) {}
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                                fail("onError should never be called.");
+                            }
+
+                            @Override
+                            public void onCompleted() {
+                                streamObserver.onNext(
+                                        WriteResponse.newBuilder()
+                                                .setCommittedSize(blob.length + 1)
+                                                .build());
+                                streamObserver.onCompleted();
+                            }
+                        };
+                    }
+                });
+
+        ListenableFuture<Void> future =
+                newUploader().uploadBlob(DigestCalculator.compute(blob), ByteString.copyFrom(blob));
+
+        assertThrows(ExecutionException.class, () -> future.get());
+    }
+
+    @Test
+    public void uploadBlob_early_response_should_not_fail()
+            throws InterruptedException, ExecutionException {
+        byte[] blob = new byte[10];
+        new Random().nextBytes(blob);
+        mServiceRegistry.addService(
+                new ByteStreamImplBase() {
+                    @Override
+                    public StreamObserver<WriteRequest> write(
+                            StreamObserver<WriteResponse> streamObserver) {
+                        return new StreamObserver<WriteRequest>() {
+                            @Override
+                            public void onNext(WriteRequest writeRequest) {
+                                // On receiving the chunk, respond with the full size of the
+                                // uploaded file immediately without error to indicate that the blob
+                                // already exists (per the remote API spec) and close the stream.
+                                streamObserver.onNext(
+                                        WriteResponse.newBuilder()
+                                                .setCommittedSize(blob.length)
+                                                .build());
+                                streamObserver.onCompleted();
+                            }
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                                fail("onError should never be called.");
+                            }
+
+                            @Override
+                            public void onCompleted() {}
+                        };
+                    }
+                });
+
+        newUploader().uploadBlob(DigestCalculator.compute(blob), ByteString.copyFrom(blob)).get();
+    }
+
+    private ByteStreamUploader newUploader() {
+        return new ByteStreamUploader(INSTANCE, mChannel, null, Duration.ofSeconds(5), mChunkSize);
+    }
+}
diff --git a/javatests/com/android/tradefed/cache/remote/ChunkerTest.java b/javatests/com/android/tradefed/cache/remote/ChunkerTest.java
new file mode 100644
index 000000000..faead294e
--- /dev/null
+++ b/javatests/com/android/tradefed/cache/remote/ChunkerTest.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.cache.remote;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.NoSuchElementException;
+import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link Chunker}. */
+@RunWith(JUnit4.class)
+public class ChunkerTest {
+    @Test
+    public void chunkingShouldWork() throws IOException {
+        byte[] expectedData = new byte[21];
+        new Random().nextBytes(expectedData);
+        Chunker chunker =
+                new Chunker(new ByteArrayInputStream(expectedData), expectedData.length, 10);
+        ByteArrayOutputStream actualData = new ByteArrayOutputStream();
+
+        Chunker.Chunk first = chunker.next();
+        first.getData().writeTo(actualData);
+        Chunker.Chunk second = chunker.next();
+        second.getData().writeTo(actualData);
+        Chunker.Chunk third = chunker.next();
+        third.getData().writeTo(actualData);
+
+        assertEquals(first.getData().size(), 10);
+        assertEquals(first.getOffset(), 0);
+        assertEquals(second.getData().size(), 10);
+        assertEquals(second.getOffset(), 10);
+        assertEquals(third.getData().size(), 1);
+        assertEquals(third.getOffset(), 20);
+        assertArrayEquals(actualData.toByteArray(), expectedData);
+    }
+
+    @Test
+    public void hasNextReturnsTrue() throws IOException {
+        byte[] data = new byte[10];
+        Chunker chunker = new Chunker(new ByteArrayInputStream(data), 10, 10);
+
+        boolean hasNext = chunker.hasNext();
+
+        assertTrue(hasNext);
+    }
+
+    @Test
+    public void nextShouldThrowIfNoMoreData() throws IOException {
+        byte[] data = new byte[10];
+        Chunker chunker = new Chunker(new ByteArrayInputStream(data), 10, 11);
+
+        chunker.next();
+
+        assertFalse(chunker.hasNext());
+        assertThrows(NoSuchElementException.class, () -> chunker.next());
+    }
+
+    @Test
+    public void nextWorksOnEmptyData() throws Exception {
+        var inp =
+                new ByteArrayInputStream(new byte[0]) {
+                    private boolean closed;
+
+                    @Override
+                    public void close() throws IOException {
+                        closed = true;
+                        super.close();
+                    }
+                };
+        Chunker chunker = new Chunker(inp, 0, 10);
+
+        Chunker.Chunk next = chunker.next();
+
+        assertNotNull(next);
+        assertTrue(next.getData().isEmpty());
+        assertEquals(next.getOffset(), 0);
+        assertTrue(inp.closed);
+    }
+}
diff --git a/javatests/com/android/tradefed/cache/remote/RemoteCacheClientTest.java b/javatests/com/android/tradefed/cache/remote/RemoteCacheClientTest.java
index 1eb53dea5..5c8beeacc 100644
--- a/javatests/com/android/tradefed/cache/remote/RemoteCacheClientTest.java
+++ b/javatests/com/android/tradefed/cache/remote/RemoteCacheClientTest.java
@@ -22,16 +22,23 @@ import static org.junit.Assert.assertNull;
 
 import build.bazel.remote.execution.v2.ActionCacheGrpc.ActionCacheImplBase;
 import build.bazel.remote.execution.v2.ActionResult;
+import build.bazel.remote.execution.v2.ContentAddressableStorageGrpc.ContentAddressableStorageImplBase;
 import build.bazel.remote.execution.v2.Digest;
+import build.bazel.remote.execution.v2.Directory;
+import build.bazel.remote.execution.v2.DirectoryNode;
+import build.bazel.remote.execution.v2.FindMissingBlobsRequest;
+import build.bazel.remote.execution.v2.FindMissingBlobsResponse;
 import build.bazel.remote.execution.v2.GetActionResultRequest;
 import build.bazel.remote.execution.v2.UpdateActionResultRequest;
 import com.android.tradefed.cache.DigestCalculator;
 import com.android.tradefed.cache.ExecutableAction;
 import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.MerkleTreeTest;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.StreamUtil;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.protobuf.ByteString;
 import io.grpc.ManagedChannel;
 import io.grpc.Server;
 import io.grpc.Status;
@@ -50,6 +57,7 @@ import java.util.Collections;
 import java.util.concurrent.TimeUnit;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.stream.Collectors;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.runner.RunWith;
@@ -70,6 +78,10 @@ public class RemoteCacheClientTest {
     private static class FakeByteStreamDownloader extends ByteStreamDownloader {
         private final Map<Digest, String> mData;
 
+        public FakeByteStreamDownloader() {
+            this(new HashMap<>());
+        }
+
         public FakeByteStreamDownloader(Map<Digest, String> data) {
             super(INSTANCE, null, null, Duration.ofSeconds(5));
             mData = data;
@@ -97,6 +109,44 @@ public class RemoteCacheClientTest {
         }
     }
 
+    private static class FakeByteStreamUploader extends ByteStreamUploader {
+        public final Map<Digest, ByteString> blobs = new HashMap<>();
+
+        public FakeByteStreamUploader() {
+            super(INSTANCE, null, null, Duration.ofSeconds(5));
+        }
+
+        @Override
+        public ListenableFuture<Void> uploadFile(Digest digest, File file) {
+            try {
+                blobs.put(digest, ByteString.copyFromUtf8(FileUtil.readStringFromFile(file)));
+            } catch (IOException e) {
+                return Futures.immediateFailedFuture(e);
+            }
+            return Futures.immediateVoidFuture();
+        }
+
+        @Override
+        public ListenableFuture<Void> uploadBlob(Digest digest, ByteString blob) {
+            blobs.put(digest, blob);
+            return Futures.immediateVoidFuture();
+        }
+    }
+
+    private static class DefaultContentAddressableStorage
+            extends ContentAddressableStorageImplBase {
+        @Override
+        public void findMissingBlobs(
+                FindMissingBlobsRequest request,
+                StreamObserver<FindMissingBlobsResponse> responseObserver) {
+            responseObserver.onNext(
+                    FindMissingBlobsResponse.newBuilder()
+                            .addAllMissingBlobDigests(request.getBlobDigestsList())
+                            .build());
+            responseObserver.onCompleted();
+        }
+    }
+
     @Before
     public final void setUp() throws Exception {
         mFakeServer =
@@ -136,6 +186,7 @@ public class RemoteCacheClientTest {
         }
         SpyActionCacheImpl actionCache = new SpyActionCacheImpl();
         mServiceRegistry.addService(actionCache);
+        mServiceRegistry.addService(new DefaultContentAddressableStorage());
         ExecutableAction action =
                 ExecutableAction.create(
                         mInput, Arrays.asList("test", "command"), new HashMap<>(), 100L);
@@ -144,7 +195,8 @@ public class RemoteCacheClientTest {
         String stdout = "test stdout";
         FileUtil.writeToFile(stdout, stdoutFile);
         ExecutableActionResult result = ExecutableActionResult.create(exitCode, stdoutFile, null);
-        RemoteCacheClient client = newClient(null);
+        RemoteCacheClient client =
+                newClient(new FakeByteStreamDownloader(), new FakeByteStreamUploader());
         ActionResult expectedResult =
                 ActionResult.newBuilder()
                         .setExitCode(exitCode)
@@ -157,6 +209,108 @@ public class RemoteCacheClientTest {
         assertEquals(actionCache.actionDigest, DigestCalculator.compute(action.action()));
     }
 
+    @Test
+    public void uploadCache_all_files_and_blobs_are_uploaded_except_existing_blobs()
+            throws IOException, InterruptedException {
+        mServiceRegistry.addService(
+                new ActionCacheImplBase() {
+                    @Override
+                    public void updateActionResult(
+                            UpdateActionResultRequest request,
+                            StreamObserver<ActionResult> responseObserver) {
+                        responseObserver.onNext(request.getActionResult());
+                        responseObserver.onCompleted();
+                    }
+                });
+        File configFile = new File(mInput, "hello_world_test.config");
+        String config = "test config";
+        MerkleTreeTest.addFile(configFile, config, false);
+        Digest configFileDigest = DigestCalculator.compute(configFile);
+        File x86 = new File(mInput, "x86");
+        File testFile = new File(x86, "hello_world_test");
+        String test = "test cases";
+        MerkleTreeTest.addFile(testFile, test, true);
+        File existingDataFile = new File(x86, "existing_test_data");
+        MerkleTreeTest.addFile(existingDataFile, "test data", false);
+        Digest existingDataFileDigest = DigestCalculator.compute(existingDataFile);
+        Digest testFileDigest = DigestCalculator.compute(testFile);
+        Directory x86Dir =
+                Directory.newBuilder()
+                        .addFiles(
+                                MerkleTreeTest.newFileNode(
+                                        "existing_test_data", existingDataFileDigest, false))
+                        .addFiles(
+                                MerkleTreeTest.newFileNode(
+                                        "hello_world_test", testFileDigest, true))
+                        .build();
+        Digest x86Digest = DigestCalculator.compute(x86Dir);
+        Directory inputRoot =
+                Directory.newBuilder()
+                        .addFiles(
+                                MerkleTreeTest.newFileNode(
+                                        "hello_world_test.config", configFileDigest, false))
+                        .addDirectories(
+                                DirectoryNode.newBuilder().setName("x86").setDigest(x86Digest))
+                        .build();
+        ExecutableAction action =
+                ExecutableAction.create(
+                        mInput, Arrays.asList("test", "command"), new HashMap<>(), 100L);
+        File stdoutFile = FileUtil.createTempFile("stdout-", ".txt", mWorkFolder);
+        String stdout = "test stdout";
+        FileUtil.writeToFile(stdout, stdoutFile);
+        File stderrFile = FileUtil.createTempFile("stderr-", ".txt", mWorkFolder);
+        String stderr = "test stderr";
+        FileUtil.writeToFile(stderr, stderrFile);
+        ExecutableActionResult result = ExecutableActionResult.create(0, stdoutFile, stderrFile);
+        FakeByteStreamUploader uploader = new FakeByteStreamUploader();
+        RemoteCacheClient client = newClient(new FakeByteStreamDownloader(), uploader);
+        mServiceRegistry.addService(
+                new ContentAddressableStorageImplBase() {
+                    @Override
+                    public void findMissingBlobs(
+                            FindMissingBlobsRequest request,
+                            StreamObserver<FindMissingBlobsResponse> responseObserver) {
+                        responseObserver.onNext(
+                                FindMissingBlobsResponse.newBuilder()
+                                        .addAllMissingBlobDigests(
+                                                request.getBlobDigestsList().stream()
+                                                        // Assume that the test data file and the
+                                                        // Command message already exist.
+                                                        .filter(
+                                                                d ->
+                                                                        !d.equals(
+                                                                                        existingDataFileDigest)
+                                                                                && !d.equals(
+                                                                                        action
+                                                                                                .commandDigest()))
+                                                        .collect(Collectors.toList()))
+                                        .build());
+                        responseObserver.onCompleted();
+                    }
+                });
+        // The test data file and the Command message should not be in the output.
+        Map<Digest, ByteString> expectedDigestToBlob =
+                Map.of(
+                        DigestCalculator.compute(stdoutFile),
+                        ByteString.copyFromUtf8(stdout),
+                        DigestCalculator.compute(stderrFile),
+                        ByteString.copyFromUtf8(stderr),
+                        action.actionDigest(),
+                        action.action().toByteString(),
+                        configFileDigest,
+                        ByteString.copyFromUtf8(config),
+                        testFileDigest,
+                        ByteString.copyFromUtf8(test),
+                        x86Digest,
+                        x86Dir.toByteString(),
+                        DigestCalculator.compute(inputRoot),
+                        inputRoot.toByteString());
+
+        client.uploadCache(action, result);
+
+        assertEquals(expectedDigestToBlob, uploader.blobs);
+    }
+
     @Test
     public void lookupCache_works() throws IOException, InterruptedException {
         ExecutableAction notFoundAction =
@@ -168,6 +322,7 @@ public class RemoteCacheClientTest {
         int exitCode = 0;
         String stdout = "STDOUT";
         Digest stdOutDigest = DigestCalculator.compute(stdout.getBytes());
+        mServiceRegistry.addService(new DefaultContentAddressableStorage());
         mServiceRegistry.addService(
                 new ActionCacheImplBase() {
                     @Override
@@ -189,7 +344,8 @@ public class RemoteCacheClientTest {
         RemoteCacheClient client =
                 newClient(
                         new FakeByteStreamDownloader(
-                                Collections.singletonMap(stdOutDigest, stdout)));
+                                Collections.singletonMap(stdOutDigest, stdout)),
+                        new FakeByteStreamUploader());
 
         ExecutableActionResult notFoundResult = client.lookupCache(notFoundAction);
         ExecutableActionResult cachedResult = client.lookupCache(cachedAction);
@@ -200,7 +356,8 @@ public class RemoteCacheClientTest {
         assertNull(cachedResult.stdErr());
     }
 
-    private RemoteCacheClient newClient(ByteStreamDownloader downloader) {
-        return new RemoteCacheClient(mWorkFolder, INSTANCE, mChannel, null, downloader);
+    private RemoteCacheClient newClient(
+            ByteStreamDownloader downloader, ByteStreamUploader uploader) {
+        return new RemoteCacheClient(mWorkFolder, INSTANCE, mChannel, null, downloader, uploader);
     }
 }
diff --git a/javatests/com/android/tradefed/cluster/ClusterCommandConfigBuilderTest.java b/javatests/com/android/tradefed/cluster/ClusterCommandConfigBuilderTest.java
index fc9e186ee..ed5e1de16 100644
--- a/javatests/com/android/tradefed/cluster/ClusterCommandConfigBuilderTest.java
+++ b/javatests/com/android/tradefed/cluster/ClusterCommandConfigBuilderTest.java
@@ -299,4 +299,13 @@ public class ClusterCommandConfigBuilderTest {
         verify(mConfig, times(1))
                 .injectOptionValue("cluster:exclude-file-in-java-classpath", "art-run-test.*");
     }
+
+    @Test
+    public void testBuild_buildAttributes()
+            throws IOException, ConfigurationException, JSONException {
+        mTestEnvironment.addBuildAttribute("attr", "value");
+
+        builder.build();
+        verify(mConfig, times(1)).injectOptionValue("cluster:build-attribute", "attr", "value");
+    }
 }
diff --git a/javatests/com/android/tradefed/config/ConfigurationFactoryTest.java b/javatests/com/android/tradefed/config/ConfigurationFactoryTest.java
index 787098bac..ba6c27927 100644
--- a/javatests/com/android/tradefed/config/ConfigurationFactoryTest.java
+++ b/javatests/com/android/tradefed/config/ConfigurationFactoryTest.java
@@ -25,7 +25,6 @@ import static org.junit.Assert.fail;
 
 import static java.util.Map.entry;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IBuildProvider;
 import com.android.tradefed.build.IDeviceBuildProvider;
@@ -34,6 +33,7 @@ import com.android.tradefed.config.ConfigurationDef.ConfigObjectDef;
 import com.android.tradefed.config.ConfigurationFactory.ConfigId;
 import com.android.tradefed.config.remote.IRemoteFileResolver.ResolvedFile;
 import com.android.tradefed.log.ILeveledLogOutput;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.targetprep.DeviceWiper;
 import com.android.tradefed.targetprep.ILabPreparer;
diff --git a/javatests/com/android/tradefed/config/ConfigurationTest.java b/javatests/com/android/tradefed/config/ConfigurationTest.java
index 5cc880b24..eef41784d 100644
--- a/javatests/com/android/tradefed/config/ConfigurationTest.java
+++ b/javatests/com/android/tradefed/config/ConfigurationTest.java
@@ -25,7 +25,6 @@ import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.BuildRetrievalError;
 import com.android.tradefed.build.IBuildProvider;
 import com.android.tradefed.command.CommandOptions;
@@ -37,6 +36,7 @@ import com.android.tradefed.device.TestDeviceOptions;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.ILeveledLogOutput;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TextResultReporter;
 import com.android.tradefed.targetprep.BaseTargetPreparer;
diff --git a/javatests/com/android/tradefed/device/DeviceManagerTest.java b/javatests/com/android/tradefed/device/DeviceManagerTest.java
index 038a8b700..3c207b037 100644
--- a/javatests/com/android/tradefed/device/DeviceManagerTest.java
+++ b/javatests/com/android/tradefed/device/DeviceManagerTest.java
@@ -187,6 +187,11 @@ public class DeviceManagerTest {
                         invocation -> {
                             return capturedIDevice.getValue().getSerialNumber();
                         });
+        when(mMockTestDevice.getTrackingSerial())
+                .thenAnswer(
+                        invocation -> {
+                            return capturedIDevice.getValue().getSerialNumber();
+                        });
         when(mMockTestDevice.getMonitor()).thenReturn(mMockStateMonitor);
         when(mMockRunUtil.runTimedCmd(
                         Mockito.anyLong(), (String) Mockito.any(), (String) Mockito.any()))
diff --git a/javatests/com/android/tradefed/device/TestDeviceFuncTest.java b/javatests/com/android/tradefed/device/TestDeviceFuncTest.java
index 43cda928d..9ead3f959 100644
--- a/javatests/com/android/tradefed/device/TestDeviceFuncTest.java
+++ b/javatests/com/android/tradefed/device/TestDeviceFuncTest.java
@@ -28,13 +28,13 @@ import static org.junit.Assume.assumeTrue;
 import static org.mockito.Mockito.mock;
 
 import com.android.ddmlib.IDevice;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.TestAppConstants;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.CollectingTestListener;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.TestStatus;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
 import com.android.tradefed.testtype.IDeviceTest;
 import com.android.tradefed.util.CommandResult;
diff --git a/javatests/com/android/tradefed/device/TestDeviceTest.java b/javatests/com/android/tradefed/device/TestDeviceTest.java
index 9a5b84f37..f550834c8 100644
--- a/javatests/com/android/tradefed/device/TestDeviceTest.java
+++ b/javatests/com/android/tradefed/device/TestDeviceTest.java
@@ -50,7 +50,6 @@ import com.android.ddmlib.ShellCommandUnresponsiveException;
 import com.android.ddmlib.SplitApkInstaller;
 import com.android.ddmlib.TimeoutException;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.sdklib.AndroidVersion;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.ITestDevice.ApexInfo;
@@ -3324,7 +3323,7 @@ public class TestDeviceTest {
     /**
      * Test that trying to run a test with a user with {@link
      * TestDevice#runInstrumentationTestsAsUser(IRemoteAndroidTestRunner, int, Collection)} fails if
-     * the {@link IRemoteAndroidTestRunner} is not an instance of {@link RemoteAndroidTestRunner}.
+     * the {@link IRemoteAndroidTestRunner} is not an instance of ddmlib RemoteAndroidTestRunner.
      */
     @Test
     public void testrunInstrumentationTestsAsUser_failed() throws Exception {
diff --git a/javatests/com/android/tradefed/device/cloud/GceAvdInfoTest.java b/javatests/com/android/tradefed/device/cloud/GceAvdInfoTest.java
index daed06129..c65815729 100644
--- a/javatests/com/android/tradefed/device/cloud/GceAvdInfoTest.java
+++ b/javatests/com/android/tradefed/device/cloud/GceAvdInfoTest.java
@@ -21,6 +21,8 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.device.TestDeviceOptions;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.result.LogDataType;
@@ -31,6 +33,7 @@ import com.android.tradefed.util.CommandStatus;
 
 import org.json.JSONArray;
 import org.json.JSONObject;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -45,6 +48,14 @@ import java.util.Map;
 @RunWith(JUnit4.class)
 public class GceAvdInfoTest {
 
+    private TestDeviceOptions mOptions;
+
+    @Before
+    public void setUp() {
+        mOptions = new TestDeviceOptions();
+        mOptions.setRemoteAdbPort(1234);
+    }
+
     @Test
     public void testValidGceJsonParsing() throws Exception {
         String valid =
@@ -482,14 +493,14 @@ public class GceAvdInfoTest {
     @Test
     public void testOxygenClientSucceedResponse() {
         String output =
-                "debug info lease result: session_id:\"6a6a744e-0653-4926-b7b8-535d121a2fc9\"\n"
-                    + " server_url:\"10.0.80.227\"\n"
-                    + " ports:{type:test value:12345}\n"
-                    + " random_key:\"this-is-12345678\"\n"
-                    + " leased_device_spec:{type:TESTTYPE build_artifacts:{build_id:\"P1234567\""
-                    + " build_target:\"target\" build_branch:\"testBranch\"}}"
-                    + " oxygen_version:\"v20220509-0008-rc01-cl447382102\"  "
-                    + " debug_info:{reserved_cores:1 region:\"test-region\" environment:\"test\"}";
+                "debug info lease result: session_id: \"6a6a744e-0653-4926-b7b8-535d121a2fc9\"\n"
+                    + " server_url: \"10.0.80.227\"\n"
+                    + " ports: {type: test value:12345}\n"
+                    + " random_key: \"this-is-12345678\"\n"
+                    + " leased_device_spec: {type:TESTTYPE build_artifacts:{build_id:\"P1234567\""
+                    + " build_target: \"target\" build_branch:\"testBranch\"}} oxygen_version:"
+                    + " \"v20220509-0008-rc01-cl447382102\"   debug_info: {reserved_cores:1"
+                    + " region:\"test-region\" environment:\"test\"}";
         CommandResult res = Mockito.mock(CommandResult.class);
         Mockito.doAnswer(
                         new Answer<Object>() {
@@ -519,7 +530,8 @@ public class GceAvdInfoTest {
                 .when(res)
                 .getStderr();
         try {
-            GceAvdInfo gceAvdInfo = GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, 1234).get(0);
+            GceAvdInfo gceAvdInfo =
+                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions).get(0);
             assertEquals(gceAvdInfo.getStatus(), GceAvdInfo.GceStatus.SUCCESS);
             assertEquals(gceAvdInfo.instanceName(), "6a6a744e-0653-4926-b7b8-535d121a2fc9");
             assertEquals(gceAvdInfo.hostAndPort().getHost(), "10.0.80.227");
@@ -533,29 +545,29 @@ public class GceAvdInfoTest {
     public void testOxygenClientLeaseMultiDevicesSucceedResponse() {
         String output =
                 "I0516 20:50:21.513705   21141 oxygen_proxy_cf_client.go:102] "
-                        + "lease_infos:{session_id:\"17c788fa-be05-45e9-a8df-6e02f387d4a4\"  "
-                        + "server_url:\"10.120.166.14\"  ports:{type:WATERFALL  value:26908}  "
-                        + "ports:{type:WATERFALL_REVERSE_PORT_FORWARDER  value:24885}  "
-                        + "leased_device_spec:{virtualization_type:CUTTLEFISH  "
-                        + "build_artifacts:{build_id:\"8552002\"  "
-                        + "build_target:\"cf_x86_64_phone-userdebug\"  "
-                        + "build_branch:\"git_master\"  "
-                        + "cuttlefish_build_artifacts:{build_id:\"8552002\"  "
-                        + "build_target:\"cf_x86_64_phone-userdebug\"  image_type:DEVICE_IMAGE}}}"
-                        + "  debug_info:{reserved_cores:5  region:\"us-east4\"  "
-                        + "environment:\"prod\"  oxygen_version:\"v20220509-0008-rc01-cl447382102"
-                        + "\"  prewarmed:false}}  lease_infos:{session_id:\"17c788fa-be05-45e9"
-                        + "-a8df-6e02f387d4a4\"  server_url:\"10.120.166.14\"  "
-                        + "ports:{type:WATERFALL  value:16590}  "
-                        + "ports:{type:WATERFALL_REVERSE_PORT_FORWARDER  value:26010}  "
-                        + "leased_device_spec:{virtualization_type:CUTTLEFISH  "
-                        + "build_artifacts:{build_id:\"8558504\"  "
-                        + "build_target:\"cf_x86_64_phone-userdebug\"  "
-                        + "build_branch:\"git_master\"  "
-                        + "cuttlefish_build_artifacts:{build_id:\"8558504\"  "
-                        + "build_target:\"cf_x86_64_phone-userdebug\"  image_type:DEVICE_IMAGE}}}"
+                        + "lease_infos:{session_id: \"17c788fa-be05-45e9-a8df-6e02f387d4a4\"  "
+                        + "server_url: \"10.120.166.14\"  ports: {type:WATERFALL  value:26908}  "
+                        + "ports: {type: WATERFALL_REVERSE_PORT_FORWARDER  value:24885}  "
+                        + "leased_device_spec: {virtualization_type:CUTTLEFISH  "
+                        + "build_artifacts: {build_id:\"8552002\"  "
+                        + "build_target: \"cf_x86_64_phone-userdebug\"  "
+                        + "build_branch: \"git_master\"  "
+                        + "cuttlefish_build_artifacts: {build_id:\"8552002\"  "
+                        + "build_target: \"cf_x86_64_phone-userdebug\"  image_type:DEVICE_IMAGE}}}"
+                        + "  debug_info:{reserved_cores:5  region: \"us-east4\"  "
+                        + "environment:\"prod\"  oxygen_version: \"v20220509-0008-rc01-cl447382102"
+                        + "\"  prewarmed:false}}  lease_infos:{session_id: \"17c788fa-be05-45e9"
+                        + "-a8df-6e02f387d4a4\"  server_url: \"10.120.166.14\"  "
+                        + "ports: {type:WATERFALL  value:16590}  "
+                        + "ports: {type:WATERFALL_REVERSE_PORT_FORWARDER  value:26010}  "
+                        + "leased_device_spec: {virtualization_type:CUTTLEFISH  "
+                        + "build_artifacts: {build_id:\"8558504\"  "
+                        + "build_target: \"cf_x86_64_phone-userdebug\"  "
+                        + "build_branch: \"git_master\"  "
+                        + "cuttlefish_build_artifacts: {build_id:\"8558504\"  "
+                        + "build_target: \"cf_x86_64_phone-userdebug\"  image_type:DEVICE_IMAGE}}}"
                         + "  index:1  debug_info:{reserved_cores:5  region:\"us-east4\"  "
-                        + "environment:\"prod\"  oxygen_version:\"v20220509-0008-rc01-cl447382102"
+                        + "environment:\"prod\"  oxygen_version: \"v20220509-0008-rc01-cl447382102"
                         + "\"  prewarmed:false}}  debug_info:{reserved_cores:5  "
                         + "region:\"us-east4\"  environment:\"prod\"  "
                         + "oxygen_version:\"v20220509-0008-rc01-cl447382102\"  prewarmed:false}";
@@ -589,10 +601,10 @@ public class GceAvdInfoTest {
                 .getStderr();
         try {
             List<GceAvdInfo> gceAvdInfoList =
-                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, 1234);
+                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions);
             for (int i = 0; i < 2; i++) {
                 GceAvdInfo gceAvdInfo =
-                        GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, 1234).get(i);
+                        GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions).get(i);
                 assertEquals(gceAvdInfo.getStatus(), GceAvdInfo.GceStatus.SUCCESS);
                 assertEquals(gceAvdInfo.instanceName(), "17c788fa-be05-45e9-a8df-6e02f387d4a4");
                 assertEquals(gceAvdInfo.hostAndPort().getHost(), "10.120.166.14");
@@ -640,7 +652,7 @@ public class GceAvdInfoTest {
                 .when(res)
                 .getStderr();
         try {
-            GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, 1234);
+            GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions);
             fail("Should have thrown an exception");
         } catch (TargetSetupError expected) {
             assertEquals(
@@ -667,7 +679,8 @@ public class GceAvdInfoTest {
                 .when(res)
                 .getStatus();
         try {
-            GceAvdInfo gceAvdInfo = GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, 1234).get(0);
+            GceAvdInfo gceAvdInfo =
+                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions).get(0);
             assertEquals(gceAvdInfo.getStatus(), GceAvdInfo.GceStatus.FAIL);
             assertEquals(
                     gceAvdInfo.getErrorType(), InfraErrorIdentifier.OXYGEN_CLIENT_BINARY_TIMEOUT);
@@ -715,7 +728,7 @@ public class GceAvdInfoTest {
                 .when(res)
                 .getStderr();
         try {
-            GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, 1234);
+            GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions);
             fail("Should have thrown an exception");
         } catch (TargetSetupError expected) {
             assertEquals("Oxygen client failed to lease a device", expected.getMessage());
@@ -770,5 +783,148 @@ public class GceAvdInfoTest {
                         "Lease aborted due to launcher failure: Timed out waiting for virtual"
                                 + " device to start"));
     }
+
+    /** Test handling succeeded Oxygenation device lease request. */
+    @Test
+    public void testOxygenationClientSucceedResponse() throws Exception {
+        OptionSetter setter = new OptionSetter(mOptions);
+        setter.setOptionValue("use-oxygenation-device", "true");
+        String output =
+                "INFO: session_id: \"f549fcec-5246-4ef1-ba57-392af67bc2e9\""
+                        + "\nserver_url: \"oxy-gto2.us-central1-b.c.omnilab-oxygen-01.internal\""
+                        + "\ndebug_info {"
+                        + "\n  region: \"region\""
+                        + "\n  environment: \"env\""
+                        + "\n  cluster_name: \"somecluster\""
+                        + "\n  oxygen_version:\"someversion\""
+                        + "\n}"
+                        + "\ndevice_info {"
+                        + "\n  omnilab_device_info {"
+                        + "\n    device_id: \"0.0.0.0:6520\""
+                        + "\n  }"
+                        + "\n}";
+        CommandResult res = Mockito.mock(CommandResult.class);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                return CommandStatus.SUCCESS;
+                            }
+                        })
+                .when(res)
+                .getStatus();
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                return "";
+                            }
+                        })
+                .when(res)
+                .getStdout();
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                return output;
+                            }
+                        })
+                .when(res)
+                .getStderr();
+        try {
+            GceAvdInfo gceAvdInfo =
+                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions).get(0);
+            assertEquals(gceAvdInfo.getStatus(), GceAvdInfo.GceStatus.SUCCESS);
+            assertEquals(gceAvdInfo.instanceName(), "f549fcec-5246-4ef1-ba57-392af67bc2e9");
+            assertEquals(
+                    gceAvdInfo.hostAndPort().getHost(),
+                    "oxy-gto2.us-central1-b.c.omnilab-oxygen-01.internal");
+            assertEquals(gceAvdInfo.getOxygenationDeviceId(), "0.0.0.0:6520");
+        } catch (TargetSetupError e) {
+            e.printStackTrace();
+        }
+    }
+
+    /** Test handling succeeded Oxygenation device lease request. */
+    @Test
+    public void testOxygenationClientLeaseMultiDevicesSucceedResponse() throws Exception {
+        OptionSetter setter = new OptionSetter(mOptions);
+        setter.setOptionValue("use-oxygenation-device", "true");
+        String output =
+                "INFO: session_id: \"f549fcec-5246-4ef1-ba57-392af67bc2e9\""
+                        + " server_url: \"oxy-gto2.us-central1-b.c.omnilab-oxygen-01.internal\""
+                        + "  debug_info {"
+                        + "   region: \"region\""
+                        + "   environment: \"env\""
+                        + "   cluster_name: \"somecluster\""
+                        + "   oxygen_version:\"someversion\""
+                        + " }"
+                        + " device_info {"
+                        + "   omnilab_device_info {"
+                        + "     device_id: \"0.0.0.0:6520\""
+                        + "   }"
+                        + " }"
+                        + "session_id: \"f549fcec-5246-4ef1-ba57-392af67bc2e9-1\""
+                        + " server_url: \"oxy-gto2.us-central1-b.c.omnilab-oxygen-02.internal\""
+                        + "  debug_info {"
+                        + "   region: \"region\""
+                        + "   environment: \"env\""
+                        + "   cluster_name: \"somecluster\""
+                        + "   oxygen_version:\"someversion\""
+                        + " }"
+                        + " device_info {"
+                        + "   omnilab_device_info {"
+                        + "     device_id: \"0.0.0.0:6521\""
+                        + "   }"
+                        + " }";
+        CommandResult res = Mockito.mock(CommandResult.class);
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                return CommandStatus.SUCCESS;
+                            }
+                        })
+                .when(res)
+                .getStatus();
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                return "";
+                            }
+                        })
+                .when(res)
+                .getStdout();
+        Mockito.doAnswer(
+                        new Answer<Object>() {
+                            @Override
+                            public Object answer(InvocationOnMock mock) throws Throwable {
+                                return output;
+                            }
+                        })
+                .when(res)
+                .getStderr();
+        try {
+            List<GceAvdInfo> gceAvdInfos =
+                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mOptions);
+            assertEquals(gceAvdInfos.get(0).getStatus(), GceAvdInfo.GceStatus.SUCCESS);
+            assertEquals(gceAvdInfos.get(0).instanceName(), "f549fcec-5246-4ef1-ba57-392af67bc2e9");
+            assertEquals(
+                    gceAvdInfos.get(0).hostAndPort().getHost(),
+                    "oxy-gto2.us-central1-b.c.omnilab-oxygen-01.internal");
+            assertEquals(gceAvdInfos.get(0).getOxygenationDeviceId(), "0.0.0.0:6520");
+
+            assertEquals(gceAvdInfos.get(1).getStatus(), GceAvdInfo.GceStatus.SUCCESS);
+            assertEquals(
+                    gceAvdInfos.get(1).instanceName(), "f549fcec-5246-4ef1-ba57-392af67bc2e9-1");
+            assertEquals(
+                    gceAvdInfos.get(1).hostAndPort().getHost(),
+                    "oxy-gto2.us-central1-b.c.omnilab-oxygen-02.internal");
+            assertEquals(gceAvdInfos.get(1).getOxygenationDeviceId(), "0.0.0.0:6521");
+        } catch (TargetSetupError e) {
+            e.printStackTrace();
+        }
+    }
 }
 
diff --git a/javatests/com/android/tradefed/device/cloud/GceManagerTest.java b/javatests/com/android/tradefed/device/cloud/GceManagerTest.java
index f31f014f5..3000a8264 100644
--- a/javatests/com/android/tradefed/device/cloud/GceManagerTest.java
+++ b/javatests/com/android/tradefed/device/cloud/GceManagerTest.java
@@ -21,7 +21,6 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.build.BuildInfo;
@@ -37,7 +36,6 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
-import com.android.tradefed.util.MultiMap;
 
 import com.google.common.net.HostAndPort;
 
@@ -50,13 +48,13 @@ import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.ProcessBuilder.Redirect;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /** Unit tests for {@link GceManager} */
@@ -69,7 +67,6 @@ public class GceManagerTest {
     private IBuildInfo mMockBuildInfo;
     @Mock IRunUtil mMockRunUtil;
     private File mAvdBinary;
-    @Mock OxygenClient mMockOxygenClient;
 
     @Before
     public void setUp() throws Exception {
@@ -162,383 +159,6 @@ public class GceManagerTest {
         assertNull(result);
     }
 
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)}. */
-    @Test
-    public void testBuildGceCommand() throws IOException {
-        IBuildInfo mockBuildInfo = mock(IBuildInfo.class);
-        when(mockBuildInfo.getBuildAttributes()).thenReturn(Collections.<String, String>emptyMap());
-        when(mockBuildInfo.getBuildFlavor()).thenReturn("FLAVOR");
-        when(mockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        MultiMap<String, String> stubAttributes = new MultiMap<>();
-        stubAttributes.put("foo", "bar");
-        File reportFile = null;
-        try {
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(
-                            reportFile, mockBuildInfo, null, null, null, stubAttributes);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "FLAVOR",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--gce-metadata",
-                            "foo:bar",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)} with json key file set. */
-    @Test
-    public void testBuildGceCommand_withServiceAccountJsonKeyFile() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("FLAVOR");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-        OptionSetter setter = new OptionSetter(mOptions);
-        setter.setOptionValue("gce-driver-service-account-json-key-path", "/path/to/key.json");
-        try {
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, null, null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "FLAVOR",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--service-account-json-private-key-path",
-                            "/path/to/key.json",
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)} with IP based device. */
-    @Test
-    public void testBuildGceCommandWithIpDevice() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("FLAVOR");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-        OptionSetter setter = new OptionSetter(mOptions);
-        setter.setOptionValue("gce-driver-service-account-json-key-path", "/path/to/key.json");
-        setter.setOptionValue("gce-private-key-path", "/path/to/id_rsa");
-        setter.setOptionValue("instance-user", "foo");
-        try {
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, "bar", null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "FLAVOR",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--service-account-json-private-key-path",
-                            "/path/to/key.json",
-                            "--host",
-                            "bar",
-                            "--host-user",
-                            "foo",
-                            "--host-ssh-private-key-path",
-                            "/path/to/id_rsa",
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)}. */
-    @Test
-    public void testBuildGceCommandWithEmulatorBuild() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("TARGET");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-
-        try {
-            OptionSetter setter = new OptionSetter(mOptions);
-            setter.setOptionValue("gce-driver-param", "--emulator-build-id");
-            setter.setOptionValue("gce-driver-param", "EMULATOR_BUILD_ID");
-            mGceManager =
-                    new GceManager(mMockDeviceDesc, mOptions, mMockBuildInfo) {
-                        @Override
-                        IRunUtil getRunUtil() {
-                            return mMockRunUtil;
-                        }
-                    };
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, null, null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "TARGET",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--emulator-build-id",
-                            "EMULATOR_BUILD_ID",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)}. */
-    @Test
-    public void testBuildGceCommandWithSpecifiedImages() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("TARGET");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-
-        try {
-            OptionSetter setter = new OptionSetter(mOptions);
-            setter.setOptionValue(
-                    "gce-driver-file-param",
-                    "cvd-host-package",
-                    "/path/to/cvd-host-package.tar.gz");
-            setter.setOptionValue(
-                    "gce-driver-file-param",
-                    "local-image",
-                    "/path/to/cvd-cuttlefish-android-os.tar.gz");
-            mGceManager =
-                    new GceManager(mMockDeviceDesc, mOptions, mMockBuildInfo) {
-                        @Override
-                        IRunUtil getRunUtil() {
-                            return mMockRunUtil;
-                        }
-                    };
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, null, null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--cvd-host-package",
-                            "/path/to/cvd-host-package.tar.gz",
-                            "--local-image",
-                            "/path/to/cvd-cuttlefish-android-os.tar.gz",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /**
-     * Test {@link GceManager#buildGceCmd(File, IBuildInfo, String, String, Integer,
-     * MultiMap<String, String>)} with preconfigured virtual device.
-     */
-    @Test
-    public void testBuildGceCommand_withPreconfiguredVirtualDevice() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("FLAVOR");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-        OptionSetter setter = new OptionSetter(mOptions);
-        setter.setOptionValue("gce-driver-service-account-json-key-path", "/path/to/key.json");
-        setter.setOptionValue("gce-private-key-path", "/path/to/id_rsa");
-
-        try {
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, "bar", "vsoc-1", 2, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "FLAVOR",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--service-account-json-private-key-path",
-                            "/path/to/key.json",
-                            "--host",
-                            "bar",
-                            "--host-user",
-                            "vsoc-1",
-                            "--host-ssh-private-key-path",
-                            "/path/to/id_rsa",
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "--base-instance-num",
-                            "3",
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)}. */
-    @Test
-    public void testBuildGceCommandWithGceDriverParam() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("FLAVOR");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-        OptionSetter setter = new OptionSetter(mOptions);
-        setter.setOptionValue("gce-driver-param", "--report-internal-ip");
-        setter.setOptionValue("gce-driver-param", "--no-autoconnect");
-        try {
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, null, null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "FLAVOR",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--report-internal-ip",
-                            "--no-autoconnect",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)}. */
-    @Test
-    public void testBuildGceCommandWithExtraFiles() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("TARGET");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-        MultiMap<File, String> extraFiles = new MultiMap<>();
-        File file1 = FileUtil.createTempFile("test_file1", ".txt");
-        File file2 = FileUtil.createTempFile("test_file2", ".txt");
-        extraFiles.put(file1, "/home/vsoc-01/test_file1.txt");
-        extraFiles.put(file2, "/home/vsoc-01/test_file2.txt");
-        try {
-            mOptions.setExtraFiles(extraFiles);
-            mGceManager =
-                    new GceManager(mMockDeviceDesc, mOptions, mMockBuildInfo) {
-                        @Override
-                        IRunUtil getRunUtil() {
-                            return mMockRunUtil;
-                        }
-                    };
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, null, null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "TARGET",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--extra-files",
-                            file1.getAbsolutePath() + ",/home/vsoc-01/test_file1.txt",
-                            file2.getAbsolutePath() + ",/home/vsoc-01/test_file2.txt",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-            FileUtil.deleteFile(file1);
-            FileUtil.deleteFile(file2);
-            mOptions.setExtraFiles(new MultiMap<>());
-        }
-    }
-
     /** Ensure exception is thrown after a timeout from the acloud command. */
     @Test
     public void testStartGce_timeout() throws Exception {
@@ -553,28 +173,36 @@ public class GceManagerTest {
                     IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
-
-                    @Override
-                    protected List<String> buildGceCmd(
-                            File reportFile,
-                            IBuildInfo b,
-                            String ipDevice,
-                            String user,
-                            Integer offset,
-                            MultiMap<String, String> attributes) {
-                        List<String> tmp = new ArrayList<String>();
-                        tmp.add("");
-                        return tmp;
-                    }
                 };
         final String expectedException =
                 "acloud errors: timeout after 1620000ms, acloud did not return null";
         CommandResult cmd = new CommandResult();
         cmd.setStatus(CommandStatus.TIMED_OUT);
         cmd.setStdout("output err");
+
+        // 1>/tmp/acloud7406709073430982755.par  ~ 2>create  ~ 3>-v  ~ 4>--config_file  ~
+        // 5>/tmp/acloud7406709073430982755.par  ~ 6>--build-target  ~ 7>null
+        // ~ 8>--branch  ~ 9>null  ~ 10>--build-id  ~ 11>-1  ~ 12>--boot-timeout
+        // ~ 13>900  ~ 14>--report_file  ~ 15>/tmp/gce_avd_driver5779200185926758904.json
+        // ~ 16>--boot-timeout  ~ 17>1620
+
         when(mMockRunUtil.runTimedCmd(
                         Mockito.eq(1800000L),
                         Mockito.any(),
+                        Mockito.eq("create"),
+                        Mockito.eq("-v"),
+                        Mockito.eq("--config_file"),
+                        Mockito.any(),
+                        Mockito.eq("--build-target"),
+                        Mockito.any(),
+                        Mockito.eq("--branch"),
+                        Mockito.any(),
+                        Mockito.eq("--build-id"),
+                        Mockito.any(),
+                        Mockito.eq("--boot-timeout"),
+                        Mockito.eq("900"),
+                        Mockito.eq("--report_file"),
+                        Mockito.any(),
                         Mockito.eq("--boot-timeout"),
                         Mockito.eq("1620")))
                 .thenReturn(cmd);
@@ -588,47 +216,6 @@ public class GceManagerTest {
         }
     }
 
-    /** Test {@link GceManager#buildGceCmd(File, IBuildInfo, String)}. */
-    @Test
-    public void testBuildGceCommandWithKernelBuild() throws Exception {
-        IBuildInfo mMockBuildInfo = mock(IBuildInfo.class);
-        when(mMockBuildInfo.getBuildAttributes())
-                .thenReturn(Collections.<String, String>emptyMap());
-        when(mMockBuildInfo.getBuildFlavor()).thenReturn("FLAVOR");
-        when(mMockBuildInfo.getBuildBranch()).thenReturn("BRANCH");
-        when(mMockBuildInfo.getBuildId()).thenReturn("BUILDID");
-
-        File reportFile = null;
-        try {
-            OptionSetter setter = new OptionSetter(mOptions);
-            setter.setOptionValue("gce-driver-param", "--kernel-build-id");
-            setter.setOptionValue("gce-driver-param", "KERNELBUILDID");
-            reportFile = FileUtil.createTempFile("test-gce-cmd", "report");
-            List<String> result =
-                    mGceManager.buildGceCmd(reportFile, mMockBuildInfo, null, null, null, null);
-            List<String> expected =
-                    ArrayUtil.list(
-                            mOptions.getAvdDriverBinary().getAbsolutePath(),
-                            "create",
-                            "--build-target",
-                            "FLAVOR",
-                            "--branch",
-                            "BRANCH",
-                            "--build-id",
-                            "BUILDID",
-                            "--kernel-build-id",
-                            "KERNELBUILDID",
-                            "--config_file",
-                            mGceManager.getAvdConfigFile().getAbsolutePath(),
-                            "--report_file",
-                            reportFile.getAbsolutePath(),
-                            "-v");
-            assertEquals(expected, result);
-        } finally {
-            FileUtil.deleteFile(reportFile);
-        }
-    }
-
     /**
      * Test that a {@link com.android.tradefed.device.cloud.GceAvdInfo} is properly created when the
      * output of acloud and runutil is fine.
@@ -644,14 +231,7 @@ public class GceManagerTest {
                         return mMockRunUtil;
                     }
 
-                    @Override
-                    protected List<String> buildGceCmd(
-                            File reportFile,
-                            IBuildInfo b,
-                            String ipDevice,
-                            String user,
-                            Integer offset,
-                            MultiMap<String, String> attributes) {
+                    public void mockReportFile(File reportFile) {
                         String valid =
                                 " {\n"
                                         + "\"data\": {\n"
@@ -671,15 +251,43 @@ public class GceManagerTest {
                         } catch (IOException e) {
                             throw new RuntimeException(e);
                         }
-                        List<String> tmp = new ArrayList<String>();
-                        tmp.add("");
-                        return tmp;
                     }
                 };
-        CommandResult cmd = new CommandResult();
-        cmd.setStatus(CommandStatus.SUCCESS);
-        cmd.setStdout("output");
-        when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[]) Mockito.any())).thenReturn(cmd);
+
+        when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[]) Mockito.any()))
+                .thenAnswer(
+                        new Answer() {
+                            @Override
+                            public Object answer(InvocationOnMock invocation) {
+                                Object[] args = invocation.getArguments();
+                                File reportFile = new File((String) args[13]);
+
+                                String valid =
+                                        " {\n"
+                                            + "\"data\": {\n"
+                                            + "\"devices\": [\n"
+                                            + "{\n"
+                                            + "\"ip\": \"104.154.62.236\",\n"
+                                            + "\"instance_name\": \"gce-x86-phone-userdebug-22\"\n"
+                                            + "}\n"
+                                            + "]\n"
+                                            + "},\n"
+                                            + "\"errors\": [],\n"
+                                            + "\"command\": \"create\",\n"
+                                            + "\"status\": \"SUCCESS\"\n"
+                                            + "}";
+                                try {
+                                    FileUtil.writeToFile(valid, reportFile);
+                                } catch (IOException e) {
+                                    throw new RuntimeException(e);
+                                }
+
+                                CommandResult cmd = new CommandResult();
+                                cmd.setStatus(CommandStatus.SUCCESS);
+                                cmd.setStdout("output");
+                                return cmd;
+                            }
+                        });
 
         GceAvdInfo res = mGceManager.startGce();
 
@@ -701,21 +309,6 @@ public class GceManagerTest {
                     IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
-
-                    @Override
-                    protected List<String> buildGceCmd(
-                            File reportFile,
-                            IBuildInfo b,
-                            String ipDevice,
-                            String user,
-                            Integer offset,
-                            MultiMap<String, String> attributes) {
-                        // We delete the potential report file to create an issue.
-                        FileUtil.deleteFile(reportFile);
-                        List<String> tmp = new ArrayList<String>();
-                        tmp.add("");
-                        return tmp;
-                    }
                 };
         CommandResult cmd = new CommandResult();
         cmd.setStatus(CommandStatus.FAILED);
@@ -743,43 +336,42 @@ public class GceManagerTest {
                     IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
-
-                    @Override
-                    protected List<String> buildGceCmd(
-                            File reportFile,
-                            IBuildInfo b,
-                            String ipDevice,
-                            String user,
-                            Integer offset,
-                            MultiMap<String, String> attributes) {
-                        String validFail =
-                                " {\n"
-                                        + "\"data\": {\n"
-                                        + "\"devices_failing_boot\": [\n"
-                                        + "{\n"
-                                        + "\"ip\": \"104.154.62.236\",\n"
-                                        + "\"instance_name\": \"ins-x86-phone-userdebug-229\"\n"
-                                        + "}\n"
-                                        + "]\n"
-                                        + "},\n"
-                                        + "\"errors\": [\"device did not boot\"],\n"
-                                        + "\"command\": \"create\",\n"
-                                        + "\"status\": \"BOOT_FAIL\"\n"
-                                        + "}";
-                        try {
-                            FileUtil.writeToFile(validFail, reportFile);
-                        } catch (IOException e) {
-                            throw new RuntimeException(e);
-                        }
-                        List<String> tmp = new ArrayList<String>();
-                        tmp.add("");
-                        return tmp;
-                    }
                 };
-        CommandResult cmd = new CommandResult();
-        cmd.setStatus(CommandStatus.FAILED);
-        cmd.setStdout("output");
-        when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[]) Mockito.any())).thenReturn(cmd);
+
+        when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[]) Mockito.any()))
+                .thenAnswer(
+                        new Answer() {
+                            @Override
+                            public Object answer(InvocationOnMock invocation) {
+                                Object[] args = invocation.getArguments();
+
+                                File reportFile = new File((String) args[13]);
+                                String validFail =
+                                        " {\n"
+                                            + "\"data\": {\n"
+                                            + "\"devices_failing_boot\": [\n"
+                                            + "{\n"
+                                            + "\"ip\": \"104.154.62.236\",\n"
+                                            + "\"instance_name\": \"ins-x86-phone-userdebug-229\"\n"
+                                            + "}\n"
+                                            + "]\n"
+                                            + "},\n"
+                                            + "\"errors\": [\"device did not boot\"],\n"
+                                            + "\"command\": \"create\",\n"
+                                            + "\"status\": \"BOOT_FAIL\"\n"
+                                            + "}";
+                                try {
+                                    FileUtil.writeToFile(validFail, reportFile);
+                                } catch (IOException e) {
+                                    throw new RuntimeException(e);
+                                }
+
+                                CommandResult cmd = new CommandResult();
+                                cmd.setStatus(CommandStatus.FAILED);
+                                cmd.setStdout("output");
+                                return cmd;
+                            }
+                        });
 
         GceAvdInfo res = mGceManager.startGce();
 
@@ -1100,39 +692,40 @@ public class GceManagerTest {
                     IRunUtil getRunUtil() {
                         return mMockRunUtil;
                     }
-
-                    @Override
-                    protected List<String> buildGceCmd(
-                            File reportFile,
-                            IBuildInfo b,
-                            String ipDevice,
-                            String user,
-                            Integer offset,
-                            MultiMap<String, String> attributes) {
-                        // We delete the potential report file to create an issue.
-                        FileUtil.deleteFile(reportFile);
-                        List<String> tmp = new ArrayList<String>();
-                        tmp.add("");
-                        return tmp;
-                    }
                 };
-        CommandResult cmd = new CommandResult();
-        cmd.setStatus(CommandStatus.TIMED_OUT);
-        cmd.setStderr(
-                "2016-09-20 08:11:02,287 |INFO| gcompute_client:728| Creating instance: "
-                        + "project android-treehugger, zone us-central1-f, body:{'name': "
-                        + "'ins-fake-instance-linux', "
-                        + "'disks': [{'autoDelete': True, 'boot': True, 'mode': 'READ_WRITE', "
-                        + "'initializeParams': {'diskName': 'gce-x86-phone-userdebug-fastbuild-"
-                        + "linux-3286354-eb1fd2e3', 'sourceImage': u'https://www.googleapis.com"
-                        + "compute/v1/projects/android-treehugger/global/images/image-gce-x86-ph"
-                        + "one-userdebug-fastbuild-linux-3286354-b6b99338'}, 'type': 'PERSISTENT'"
-                        + "}, {'autoDelete': True, 'deviceName': 'gce-x86-phone-userdebug-fastbuil"
-                        + "d-linux-3286354-eb1fd2e3-data', 'interface': 'SCSI', 'mode': 'READ_WRI"
-                        + "TE', 'type': 'PERSISTENT', 'boot': False, 'source': u'projects/andro"
-                        + "id-treehugger/zones/us-c}]}");
-        cmd.setStdout("output");
-        when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[]) Mockito.any())).thenReturn(cmd);
+
+        // when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[])
+        // Mockito.any())).thenReturn(cmd);
+
+        when(mMockRunUtil.runTimedCmd(Mockito.anyLong(), (String[]) Mockito.any()))
+                .thenAnswer(
+                        new Answer() {
+                            @Override
+                            public Object answer(InvocationOnMock invocation) {
+
+                                CommandResult cmd = new CommandResult();
+                                cmd.setStatus(CommandStatus.TIMED_OUT);
+                                cmd.setStderr(
+                                        "2016-09-20 08:11:02,287 |INFO| gcompute_client:728|"
+                                            + " Creating instance: project android-treehugger, zone"
+                                            + " us-central1-f, body:{'name':"
+                                            + " 'ins-fake-instance-linux', 'disks': [{'autoDelete':"
+                                            + " True, 'boot': True, 'mode': 'READ_WRITE',"
+                                            + " 'initializeParams': {'diskName':"
+                                            + " 'gce-x86-phone-userdebug-fastbuild-linux-3286354-eb1fd2e3',"
+                                            + " 'sourceImage': u'https://www.googleapis.com"
+                                            + "compute/v1/projects/android-treehugger/global/images/image-gce-x86-phone-userdebug-fastbuild-linux-3286354-b6b99338'},"
+                                            + " 'type': 'PERSISTENT'}, {'autoDelete': True,"
+                                            + " 'deviceName':"
+                                            + " 'gce-x86-phone-userdebug-fastbuild-linux-3286354-eb1fd2e3-data',"
+                                            + " 'interface': 'SCSI', 'mode': 'READ_WRITE', 'type':"
+                                            + " 'PERSISTENT', 'boot': False, 'source':"
+                                            + " u'projects/android-treehugger/zones/us-c}]}");
+                                cmd.setStdout("output");
+                                return cmd;
+                            }
+                        });
+
         // Ensure that the instance can be shutdown.
         CommandResult shutdownResult = new CommandResult();
         shutdownResult.setStatus(CommandStatus.SUCCESS);
diff --git a/javatests/com/android/tradefed/device/cloud/HostOrchestratorUtilTest.java b/javatests/com/android/tradefed/device/cloud/HostOrchestratorUtilTest.java
deleted file mode 100644
index 324ac2d55..000000000
--- a/javatests/com/android/tradefed/device/cloud/HostOrchestratorUtilTest.java
+++ /dev/null
@@ -1,520 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tradefed.device.cloud;
-
-import static org.mockito.Mockito.times;
-
-import com.android.tradefed.config.OptionSetter;
-import com.android.tradefed.device.ITestDevice;
-import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.device.cloud.OxygenClient.LHPTunnelMode;
-import com.android.tradefed.util.CommandResult;
-import com.android.tradefed.util.CommandStatus;
-import com.android.tradefed.util.IRunUtil;
-
-import com.google.common.net.HostAndPort;
-
-import java.io.OutputStream;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mockito;
-
-/** Unit tests for {@link HostOrchestratorUtil} */
-@RunWith(JUnit4.class)
-public class HostOrchestratorUtilTest {
-
-    private HostOrchestratorUtil mHOUtil;
-    private GceAvdInfo mMockGceAvd;
-    private ITestDevice mMockDevice;
-    private OxygenClient mMockClient;
-    private TestDeviceOptions mTestDeviceOptions;
-    private IRunUtil mMockRunUtil;
-    private Process mMockProcess;
-    private static final String LIST_CVD_RES =
-            "{\"cvds\":[{\"group\":\"cvd_1\",\"name\":\"ins-1\",\"build_source\":{},"
-                    + "\"status\":\"Running\",\"displays\":[\"720 x 1280 ( 320 )\"],"
-                    + "\"webrtc_device_id\":\"cvd-1\"}]}";
-    private static final String LIST_CVD_BADRES =
-            "{\"cvds\":[{\"build_source\":{},"
-                    + "\"status\":\"Running\",\"displays\":[\"720 x 1280 ( 320 )\"],"
-                    + "\"webrtc_device_id\":\"cvd-1\"}]}";
-
-    @Before
-    public void setUp() throws Exception {
-        mMockDevice = Mockito.mock(ITestDevice.class);
-        mMockGceAvd = Mockito.mock(GceAvdInfo.class);
-        mMockClient = Mockito.mock(OxygenClient.class);
-        mMockProcess = Mockito.mock(Process.class);
-        mMockRunUtil = Mockito.mock(IRunUtil.class);
-        mTestDeviceOptions = new TestDeviceOptions();
-        mHOUtil = new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient);
-    }
-
-    @After
-    public void tearDown() {}
-
-    @Test
-    public void testCreateHostOrchestratorTunnel_NoCVDNoOxygenation() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "false");
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.verify(mMockClient, times(0))
-                .createTunnelViaLHP(LHPTunnelMode.CURL, "1111", "instance", "id");
-        Assert.assertNull(mHOUtil.createHostOrchestratorTunnel("1111"));
-    }
-
-    @Test
-    public void testCreateHostOrchestratorTunnel_Oxygenation() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn("instance").when(mMockGceAvd).instanceName();
-        Mockito.doReturn("id").when(mMockGceAvd).getOxygenationDeviceId();
-        mHOUtil.createHostOrchestratorTunnel("1111");
-        Mockito.verify(mMockClient, times(1))
-                .createTunnelViaLHP(LHPTunnelMode.CURL, "1111", "instance", "id");
-    }
-
-    @Test
-    public void testCreateHostOrchestratorTunnel_Oxygen_UseCVD() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "false");
-        setter.setOptionValue("extra-oxygen-args", "use_cvd", "value");
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        Mockito.verify(mMockClient, times(0))
-                .createTunnelViaLHP(LHPTunnelMode.CURL, "1111", "instance", "id");
-        mHOUtil.createHostOrchestratorTunnel("1111");
-    }
-
-    @Test
-    public void testPullCvdHostLogs_Oxygenation_Success() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStdout("some output");
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        (String[]) Mockito.any());
-        mHOUtil.pullCvdHostLogs();
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-    }
-
-    @Test
-    public void testPullCvdHostLogs_Oxygenation_CurlFailed() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.FAILED);
-        cvdCommandRes.setStderr("some error");
-        cvdCommandRes.setStdout("some output");
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        (String[]) Mockito.any());
-        Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/runtimeartifacts/:pull"),
-                        Mockito.eq("--output"),
-                        Mockito.anyString());
-    }
-
-    @Test
-    public void testPullCvdHostLogs_Oxygenation_CreateHOFailed() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return null;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(null);
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/runtimeartifacts/:pull"),
-                        Mockito.eq("--output"),
-                        Mockito.anyString());
-    }
-
-    @Test
-    public void testPullCvdHostLogs_Oxygenation_404() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdCommandRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdCommandRes.setStderr("some error");
-        cvdCommandRes.setStdout(mHOUtil.getUnsupportedHoResponse());
-        Mockito.doReturn(cvdCommandRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        (String[]) Mockito.any());
-        Assert.assertNull(mHOUtil.pullCvdHostLogs());
-        Mockito.verify(mMockClient, times(1)).closeLHPConnection(mMockProcess);
-    }
-
-    @Test
-    public void testPowerwashGce() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(LIST_CVD_RES);
-        CommandResult powerwashRes = new CommandResult(CommandStatus.SUCCESS);
-        powerwashRes.setStdout("");
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://host:1111/cvds"));
-        Mockito.doReturn(powerwashRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/cvds/cvd_1/ins-1/:powerwash"));
-        Assert.assertNotNull(mHOUtil.powerwashGce());
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://host:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(1))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_CreateHOFailed() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return null;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://host:1111/cvds"));
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_ListCvdFailed() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.FAILED);
-        cvdRes.setStdout("output");
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://host:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_ListCvd404() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(mHOUtil.getUnsupportedHoResponse());
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://host:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-
-    @Test
-    public void testPowerwashGce_NoCvdOutput() throws Exception {
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("use-oxygenation-device", "true");
-        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
-        Mockito.doReturn(mTestDeviceOptions).when(mMockDevice).getOptions();
-        Mockito.doReturn(true).when(mMockProcess).isAlive();
-        Mockito.doReturn(HostAndPort.fromString("host:2080")).when(mMockGceAvd).hostAndPort();
-        mHOUtil =
-                new HostOrchestratorUtil(mMockDevice, mMockGceAvd, mMockClient) {
-                    @Override
-                    Process createHostOrchestratorTunnel(String portNumber) {
-                        return mMockProcess;
-                    }
-
-                    @Override
-                    IRunUtil getRunUtil() {
-                        return mMockRunUtil;
-                    }
-                };
-        CommandResult cvdRes = new CommandResult(CommandStatus.SUCCESS);
-        cvdRes.setStdout(LIST_CVD_BADRES);
-        Mockito.doReturn(cvdRes)
-                .when(mMockRunUtil)
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("GET"),
-                        Mockito.eq("http://host:1111/cvds"));
-        Assert.assertEquals(CommandStatus.FAILED, mHOUtil.powerwashGce().getStatus());
-        Mockito.verify(mMockRunUtil, times(0))
-                .runTimedCmd(
-                        Mockito.anyLong(),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq((OutputStream) null),
-                        Mockito.eq("curl"),
-                        Mockito.eq("-0"),
-                        Mockito.eq("-v"),
-                        Mockito.eq("-X"),
-                        Mockito.eq("POST"),
-                        Mockito.eq("http://host:1111/cvds/cvd_1/ins-1/:powerwash"));
-    }
-}
diff --git a/javatests/com/android/tradefed/device/cloud/OxygenClientTest.java b/javatests/com/android/tradefed/device/cloud/OxygenClientTest.java
deleted file mode 100644
index fb3fc1c99..000000000
--- a/javatests/com/android/tradefed/device/cloud/OxygenClientTest.java
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tradefed.device.cloud;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-import com.android.tradefed.build.BuildInfo;
-import com.android.tradefed.config.OptionSetter;
-import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.device.cloud.OxygenClient.LHPTunnelMode;
-import com.android.tradefed.util.CommandResult;
-import com.android.tradefed.util.CommandStatus;
-import com.android.tradefed.util.FileUtil;
-import com.android.tradefed.util.IRunUtil;
-import com.android.tradefed.util.MultiMap;
-
-import com.google.common.base.Joiner;
-import com.google.common.net.HostAndPort;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mockito;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/** Unit tests for {@link OxygenClient} */
-@RunWith(JUnit4.class)
-public class OxygenClientTest {
-
-    private File mOxygenBinaryFile;
-
-    private OxygenClient mOxygenClient;
-
-    private BuildInfo mBuildInfo;
-
-    private GceAvdInfo mGceAvdInfo;
-
-    private TestDeviceOptions mTestDeviceOptions;
-
-    private IRunUtil mRunUtil;
-
-    private static final String[] GCE_DEVICE_PARAMS =
-            new String[] {
-                "random-arg",
-                "--branch",
-                "testBranch",
-                "--build-target",
-                "target",
-                "--build-id",
-                "P1234567",
-                "--system-build-target",
-                "testSystemTarget",
-                "--system-build-id",
-                "S1234567",
-                "--kernel-build-target",
-                "testKernelTarget",
-                "--kernel-build-id",
-                "K1234567"
-            };
-    private static final String[] BOOT_IMAGE_PARAMS =
-            new String[] {
-                "--boot-build-target",
-                "testBootTarget",
-                "--boot-build-id",
-                "B1234567",
-                "--boot-artifact",
-                "boot-5.10.img"
-            };
-
-    private static final String[] BOOTLOADER_PARAMS =
-            new String[] {
-                "--bootloader-build-target",
-                "testBootloaderTarget",
-                "--bootloader-build-id",
-                "BL1234567"
-            };
-
-    private static final String[] HOST_PACKAGE_PARAMS =
-            new String[] {
-                "--host_package_build_target",
-                "testHostPackageTarget",
-                "--host_package_build_id",
-                "HP1234567"
-            };
-
-    private static final String EXPECTED_OUTPUT =
-            "debug info lease result: session_id:\"6a6a744e-0653-4926-b7b8-535d121a2fc9\"\n"
-                    + " server_url:\"10.0.80.227\"\n"
-                    + " ports:{type:test value:12345}\n"
-                    + " random_key:\"this-is-12345678\"\n"
-                    + " leased_device_spec:{type:TESTTYPE build_artifacts:{build_id:\"P1234567\""
-                    + " build_target:\"target\" build_branch:\"testBranch\"}}"
-                    + " debug_info:{reserved_cores:1 region:\"test-region\" environment:\"test\"}";
-
-    @Before
-    public void setUp() throws Exception {
-        mOxygenBinaryFile = FileUtil.createTempFile("oxygen", "binary");
-        mBuildInfo = new BuildInfo("P1234567", "target");
-        mBuildInfo.setBuildBranch("testBranch");
-        mBuildInfo.addBuildAttribute("build_target", "target");
-        mGceAvdInfo =
-                new GceAvdInfo(
-                        "6a6a744e-0653-4926-b7b8-535d121a2fc9",
-                        HostAndPort.fromString("10.0.80.227").withDefaultPort(12345));
-        mTestDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public List<String> getGceDriverParams() {
-                        return Arrays.asList(GCE_DEVICE_PARAMS);
-                    }
-                };
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("oxygen-target-region", "us-east");
-        setter.setOptionValue("oxygen-lease-length", "60m");
-        setter.setOptionValue("oxygen-device-size", "large");
-        setter.setOptionValue("oxygen-service-address", "10.1.23.45");
-        setter.setOptionValue("gce-boot-timeout", "900000");
-        setter.setOptionValue("oxygen-accounting-user", "random1234@space.com");
-        setter.setOptionValue("extra-oxygen-args", "arg1", "value1");
-        mRunUtil = Mockito.mock(IRunUtil.class);
-        mOxygenClient = new OxygenClient(mOxygenBinaryFile, mRunUtil);
-    }
-
-    @After
-    public void tearDown() {
-        FileUtil.recursiveDelete(mOxygenBinaryFile);
-    }
-
-    /** Test leasing a device with Oxygen client binary. */
-    @Test
-    public void testLease() throws Exception {
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                long timeout = mock.getArgument(0);
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = Joiner.on(" ").join(cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -lease -build_branch testBranch -build_target"
-                                                + " target -build_id P1234567"
-                                                + " -system_build_target testSystemTarget"
-                                                + " -system_build_id S1234567"
-                                                + " -kernel_build_target testKernelTarget"
-                                                + " -kernel_build_id K1234567 -target_region"
-                                                + " us-east -accounting_user random1234@space.com"
-                                                + " -lease_length_secs 3600"
-                                                + " -arg1 value1"
-                                                + " -user_debug_info work_unit_id:some_id";
-                                assertEquals(timeout, 900000);
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                res.setStdout("");
-                                res.setStderr(EXPECTED_OUTPUT);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res = mOxygenClient.leaseDevice(mBuildInfo, mTestDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
-        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
-    }
-
-    /** Test leasing a device with Oxygen client binary without build-id specified. */
-    @Test
-    public void testLeaseWithoutBuildId() throws Exception {
-        TestDeviceOptions testDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public List<String> getGceDriverParams() {
-                        return Arrays.asList(
-                                new String[] {
-                                    "--branch", "testBranch", "--build-target", "target"
-                                });
-                    }
-                };
-        OptionSetter setter = new OptionSetter(testDeviceOptions);
-        setter.setOptionValue("oxygen-target-region", "us-east");
-        setter.setOptionValue("oxygen-lease-length", "60m");
-        setter.setOptionValue("oxygen-device-size", "large");
-        setter.setOptionValue("oxygen-service-address", "10.1.23.45");
-        setter.setOptionValue("gce-boot-timeout", "900000");
-        setter.setOptionValue("oxygen-accounting-user", "random1234@space.com");
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                long timeout = mock.getArgument(0);
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = Joiner.on(" ").join(cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -lease -build_branch testBranch -build_target"
-                                                + " target -build_id testBranch -target_region"
-                                                + " us-east -accounting_user random1234@space.com"
-                                                + " -lease_length_secs 3600"
-                                                + " -user_debug_info work_unit_id:some_id";
-                                assertEquals(timeout, 900000);
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                res.setStdout("");
-                                res.setStderr(EXPECTED_OUTPUT);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res = mOxygenClient.leaseDevice(mBuildInfo, testDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
-        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
-    }
-
-    /** Test leasing multiple devices with Oxygen client binary. */
-    @Test
-    public void testLeaseMultipleDevice() throws Exception {
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                long timeout = mock.getArgument(0);
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = Joiner.on(" ").join(cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -lease"
-                                                + " -build_target target,target"
-                                                + " -build_branch testBranch,testBranch"
-                                                + " -build_id P1234567,P1234567"
-                                                + " -multidevice_size 2"
-                                                + " -target_region us-east"
-                                                + " -accounting_user random1234@space.com"
-                                                + " -lease_length_secs 3600"
-                                                + " -arg1 value1"
-                                                + " -user_debug_info work_unit_id:some_id";
-                                assertEquals(timeout, 900000);
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                res.setStdout("");
-                                res.setStderr(EXPECTED_OUTPUT);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res =
-                mOxygenClient.leaseMultipleDevices(
-                        Arrays.asList(mBuildInfo, mBuildInfo), mTestDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
-        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
-    }
-
-    /** Test releasing a device with Oxygen client binary. */
-    @Test
-    public void testRelease() throws Exception {
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                long timeout = mock.getArgument(0);
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = Joiner.on(" ").join(cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -arg1 value1 -release -target_region us-east"
-                                                + " -server_url 10.0.80.227"
-                                                + " -session_id"
-                                                + " 6a6a744e-0653-4926-b7b8-535d121a2fc9"
-                                                + " -accounting_user"
-                                                + " random1234@space.com";
-                                assertEquals(timeout, 900000);
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        boolean isReleased = mOxygenClient.release(mGceAvdInfo, mTestDeviceOptions);
-        assertTrue(isReleased);
-    }
-
-    /** Test releasing an empty GceAvdInfo. */
-    @Test
-    public void testReleaseEmptyGceAvdInfo() throws Exception {
-        // Empty GceAvdInfo happen when the lease was unsuccessful
-        GceAvdInfo emptyGceAvdInfo = new GceAvdInfo(null, null);
-        boolean isReleased = mOxygenClient.release(emptyGceAvdInfo, mTestDeviceOptions);
-        // Should return true as there is nothing need to be released
-        assertTrue(isReleased);
-    }
-
-    @Test
-    public void testNoWaitForBootSpecified() throws Exception {
-        assertFalse(mOxygenClient.noWaitForBootSpecified(mTestDeviceOptions));
-
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("extra-oxygen-args", "no_wait_for_boot", "");
-        assertTrue(mOxygenClient.noWaitForBootSpecified(mTestDeviceOptions));
-    }
-
-    /** Test cvd path override. */
-    @Test
-    public void testCvdOverride() throws Exception {
-        assertNull(mOxygenClient.getOverrideCvdPath(mTestDeviceOptions));
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("extra-oxygen-args", "override_cvd_path", "gs://abc/cvd");
-        assertEquals(
-                mOxygenClient.getOverrideCvdPath(mTestDeviceOptions), "gs://abc/cvd");
-    }
-
-    @Test
-    public void testLeaseWithBootImageAndBootArtifact() throws Exception {
-        mTestDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public List<String> getGceDriverParams() {
-                        List<String> paramsList = new ArrayList<>();
-                        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
-                        paramsList.addAll(Arrays.asList(BOOT_IMAGE_PARAMS));
-                        return paramsList;
-                    }
-                };
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("oxygen-target-region", "us-east");
-        setter.setOptionValue("oxygen-lease-length", "60m");
-        setter.setOptionValue("oxygen-device-size", "large");
-        setter.setOptionValue("oxygen-service-address", "10.1.23.45");
-        setter.setOptionValue("gce-boot-timeout", "900000");
-        setter.setOptionValue("oxygen-accounting-user", "random1234@space.com");
-        setter.setOptionValue("extra-oxygen-args", "arg1", "value1");
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = String.join(" ", cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -lease -build_branch testBranch -build_target"
-                                                + " target -build_id P1234567"
-                                                + " -system_build_target testSystemTarget"
-                                                + " -system_build_id S1234567"
-                                                + " -kernel_build_target testKernelTarget"
-                                                + " -kernel_build_id K1234567"
-                                                + " -boot_build_target testBootTarget"
-                                                + " -boot_build_id B1234567"
-                                                + " -boot_artifact boot-5.10.img"
-                                                + " -target_region us-east"
-                                                + " -accounting_user random1234@space.com"
-                                                + " -lease_length_secs 3600"
-                                                + " -arg1 value1"
-                                                + " -user_debug_info work_unit_id:some_id";
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                res.setStdout("");
-                                res.setStderr(EXPECTED_OUTPUT);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res = mOxygenClient.leaseDevice(mBuildInfo, mTestDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
-        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
-    }
-
-    @Test
-    public void testLeaseWithBootloader() throws Exception {
-        mTestDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public List<String> getGceDriverParams() {
-                        List<String> paramsList = new ArrayList<>();
-                        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
-                        paramsList.addAll(Arrays.asList(BOOTLOADER_PARAMS));
-                        return paramsList;
-                    }
-                };
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("oxygen-target-region", "us-east");
-        setter.setOptionValue("oxygen-lease-length", "60m");
-        setter.setOptionValue("oxygen-device-size", "large");
-        setter.setOptionValue("oxygen-service-address", "10.1.23.45");
-        setter.setOptionValue("gce-boot-timeout", "900000");
-        setter.setOptionValue("oxygen-accounting-user", "random1234@space.com");
-        setter.setOptionValue("extra-oxygen-args", "arg1", "value1");
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = String.join(" ", cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -lease -build_branch testBranch -build_target"
-                                                + " target -build_id P1234567"
-                                                + " -system_build_target testSystemTarget"
-                                                + " -system_build_id S1234567"
-                                                + " -kernel_build_target testKernelTarget"
-                                                + " -kernel_build_id K1234567"
-                                                + " -bootloader_build_target testBootloaderTarget"
-                                                + " -bootloader_build_id BL1234567"
-                                                + " -target_region us-east"
-                                                + " -accounting_user random1234@space.com"
-                                                + " -lease_length_secs 3600"
-                                                + " -arg1 value1"
-                                                + " -user_debug_info work_unit_id:some_id";
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                res.setStdout("");
-                                res.setStderr(EXPECTED_OUTPUT);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res = mOxygenClient.leaseDevice(mBuildInfo, mTestDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
-        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
-    }
-
-    @Test
-    public void testLeaseWithHostPackage() throws Exception {
-        mTestDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public List<String> getGceDriverParams() {
-                        List<String> paramsList = new ArrayList<>();
-                        paramsList.addAll(Arrays.asList(GCE_DEVICE_PARAMS));
-                        paramsList.addAll(Arrays.asList(HOST_PACKAGE_PARAMS));
-                        return paramsList;
-                    }
-                };
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        setter.setOptionValue("oxygen-target-region", "us-east");
-        setter.setOptionValue("oxygen-lease-length", "60m");
-        setter.setOptionValue("oxygen-device-size", "large");
-        setter.setOptionValue("oxygen-service-address", "10.1.23.45");
-        setter.setOptionValue("gce-boot-timeout", "900000");
-        setter.setOptionValue("oxygen-accounting-user", "random1234@space.com");
-        setter.setOptionValue("extra-oxygen-args", "arg1", "value1");
-        Mockito.doAnswer(
-                        new Answer<Object>() {
-                            @Override
-                            public Object answer(InvocationOnMock mock) throws Throwable {
-                                List<String> cmd = new ArrayList<>();
-                                for (int i = 1; i < mock.getArguments().length; i++) {
-                                    cmd.add(mock.getArgument(i));
-                                }
-                                String cmdString = String.join(" ", cmd);
-                                String expectedCmdString =
-                                        mOxygenBinaryFile.getAbsolutePath()
-                                                + " -lease -build_branch testBranch -build_target"
-                                                + " target -build_id P1234567 -system_build_target"
-                                                + " testSystemTarget -system_build_id S1234567"
-                                                + " -kernel_build_target testKernelTarget"
-                                                + " -kernel_build_id K1234567"
-                                                + " -host_package_build_target"
-                                                + " testHostPackageTarget -host_package_build_id"
-                                                + " HP1234567 -target_region us-east"
-                                                + " -accounting_user random1234@space.com"
-                                                + " -lease_length_secs 3600 -arg1 value1"
-                                                + " -user_debug_info work_unit_id:some_id";
-                                assertEquals(expectedCmdString, cmdString);
-
-                                CommandResult res = new CommandResult();
-                                res.setStatus(CommandStatus.SUCCESS);
-                                res.setStdout("");
-                                res.setStderr(EXPECTED_OUTPUT);
-                                return res;
-                            }
-                        })
-                .when(mRunUtil)
-                .runTimedCmd(Mockito.anyLong(), Mockito.any());
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res = mOxygenClient.leaseDevice(mBuildInfo, mTestDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.SUCCESS);
-        assertEquals(res.getStderr(), EXPECTED_OUTPUT);
-    }
-
-    @Test
-    public void testLeaseOxygenationDevice() throws Exception {
-        mTestDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public boolean useOxygenationDevice() {
-                        return true;
-                    }
-                };
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        CommandResult res = mOxygenClient.leaseDevice(mBuildInfo, mTestDeviceOptions, attributes);
-        assertEquals(res.getStatus(), CommandStatus.EXCEPTION);
-        assertEquals(
-                res.getStderr(),
-                "OxygenClient: Leasing an oxygenation device is not supported for now.");
-    }
-
-    @Test
-    public void testReleaseOxygenationDevice() throws Exception {
-        mTestDeviceOptions =
-                new TestDeviceOptions() {
-                    @Override
-                    public boolean useOxygenationDevice() {
-                        return true;
-                    }
-                };
-        OptionSetter setter = new OptionSetter(mTestDeviceOptions);
-        MultiMap<String, String> attributes = new MultiMap<>();
-        attributes.put("work_unit_id", "some_id");
-        assertFalse(mOxygenClient.release(mGceAvdInfo, mTestDeviceOptions));
-    }
-
-    @Test
-    public void testCreateTunnelViaLHP_ADB() throws Exception {
-        // TODO(easoncylee): Flesh out when the oxygen client is ready.
-        assertNull(mOxygenClient.createTunnelViaLHP(LHPTunnelMode.ADB, "1111", "instance", "id"));
-    }
-
-    @Test
-    public void testCreateSSHTunnelViaLHP_SSH() throws Exception {
-        // TODO(easoncylee): Flesh out when the oxygen client is ready.
-        assertNull(mOxygenClient.createTunnelViaLHP(LHPTunnelMode.SSH, "1111", "instance", "id"));
-    }
-
-    @Test
-    public void testCreateTunnelViaLHP_CURL() throws Exception {
-        // TODO(easoncylee): Flesh out when the oxygen client is ready.
-        assertNull(mOxygenClient.createTunnelViaLHP(LHPTunnelMode.CURL, "1111", "instance", "id"));
-    }
-}
diff --git a/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java b/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java
index 25119a6f6..5af450c87 100644
--- a/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java
+++ b/javatests/com/android/tradefed/device/cloud/OxygenUtilTest.java
@@ -29,6 +29,7 @@ import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.GCSFileDownloader;
+import com.android.tradefed.util.avd.LogCollector;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -105,7 +106,7 @@ public class OxygenUtilTest {
                             + "some vcpu hw run failure: 0x7.\n"
                             + "tailing string";
             FileUtil.writeToFile(content, file1);
-            List<String> signatures = OxygenUtil.collectErrorSignatures(tmpDir);
+            List<String> signatures = LogCollector.collectErrorSignatures(tmpDir);
             assertEquals("crosvm_vcpu_hw_run_failure_7", signatures.get(0));
             assertEquals("launch_cvd_port_collision", signatures.get(1));
         } finally {
@@ -133,7 +134,7 @@ public class OxygenUtilTest {
                             + " CuttlefishLauncherMainstart\n"
                             + "tailing string";
             FileUtil.writeToFile(content, file1);
-            long[] metrics = OxygenUtil.collectDeviceLaunchMetrics(tmpDir);
+            long[] metrics = LogCollector.collectDeviceLaunchMetrics(tmpDir);
             assertEquals(61880, metrics[0]);
             assertEquals(124630, metrics[1]);
 
@@ -164,7 +165,7 @@ public class OxygenUtilTest {
                         + " CuttlefishLauncherMainstart\n"
                         + "tailing string";
             FileUtil.writeToFile(content, file1);
-            long[] metrics = OxygenUtil.collectDeviceLaunchMetrics(tmpDir);
+            long[] metrics = LogCollector.collectDeviceLaunchMetrics(tmpDir);
             assertEquals(47470, metrics[0]);
             assertEquals(80800, metrics[1]);
 
@@ -181,7 +182,7 @@ public class OxygenUtilTest {
             File file1 = FileUtil.createTempFile("oxygen_version.txt", "", tmpDir);
             String content = "version_number \n\n\n";
             FileUtil.writeToFile(content, file1);
-            assertEquals("version_number", OxygenUtil.collectOxygenVersion(tmpDir));
+            assertEquals("version_number", LogCollector.collectOxygenVersion(tmpDir));
 
         } finally {
             FileUtil.recursiveDelete(tmpDir);
diff --git a/javatests/com/android/tradefed/device/cloud/RemoteFileUtilTest.java b/javatests/com/android/tradefed/device/cloud/RemoteFileUtilTest.java
index e98b382cb..600244e6f 100644
--- a/javatests/com/android/tradefed/device/cloud/RemoteFileUtilTest.java
+++ b/javatests/com/android/tradefed/device/cloud/RemoteFileUtilTest.java
@@ -236,41 +236,4 @@ public class RemoteFileUtilTest {
             FileUtil.recursiveDelete(localFile);
         }
     }
-
-    /** Test checking if a file exists in the remote oxygenation instance */
-    @Test
-    public void testDoesRemoteFileExistInOxygenation() throws Exception {
-        String remotePath = "/home/vsoc-01/cuttlefish_runtime/kernel.log";
-        when(mMockGceAvdInfo.isOxygenationDevice()).thenReturn(true);
-        when(mMockFile.exists()).thenReturn(true);
-        when(mMockFile.canExecute()).thenReturn(true);
-        boolean result =
-                RemoteFileUtil.doesRemoteFileExist(
-                        mMockGceAvdInfo, mOptions, mMockRunUtil, 500L, remotePath);
-        assertFalse(result);
-    }
-
-    /** Test pushing a file to a remote oxygenation instance via scp */
-    @Test
-    public void testPushFileToRemoteOxygenation() throws Exception {
-        String remotePath = "/home/vsoc-01/cuttlefish_runtime/kernel.log";
-        File localFile = FileUtil.createTempDir("test-remote-push-dir");
-        when(mMockGceAvdInfo.isOxygenationDevice()).thenReturn(true);
-        when(mMockFile.exists()).thenReturn(true);
-        when(mMockFile.canExecute()).thenReturn(true);
-        try {
-            boolean result =
-                    RemoteFileUtil.pushFileToRemote(
-                            mMockGceAvdInfo,
-                            mOptions,
-                            Arrays.asList(""),
-                            mMockRunUtil,
-                            500L,
-                            remotePath,
-                            localFile);
-            assertFalse(result);
-        } finally {
-            FileUtil.recursiveDelete(localFile);
-        }
-    }
 }
diff --git a/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java b/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java
index de7ad05fb..6f04c4ae6 100644
--- a/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java
+++ b/javatests/com/android/tradefed/device/connection/AdbSshConnectionTest.java
@@ -16,9 +16,13 @@
 package com.android.tradefed.device.connection;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.ddmlib.IDevice;
@@ -47,9 +51,11 @@ import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.avd.HostOrchestratorUtil;
 
 import com.google.common.net.HostAndPort;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -62,7 +68,6 @@ import org.mockito.MockitoAnnotations;
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.util.ArrayList;
 import java.util.List;
 
 /** Unit tests for {@link AdbSshConnection}. */
@@ -83,8 +88,11 @@ public class AdbSshConnectionTest {
     @Mock ITestLogger mMockLogger;
     @Mock GceManager mGceHandler;
     @Mock GceSshTunnelMonitor mGceSshMonitor;
+    @Mock GceLHPTunnelMonitor mGceLhpMonitor;
     @Mock ITestDevice mMockTestDevice;
     @Mock GceAvdInfo mMockAvdInfo;
+    @Mock File mMockFile;
+    @Mock HostOrchestratorUtil mMockHOUtil;
 
     public static interface TestableConfigurableVirtualDevice
             extends IDevice, IConfigurableVirtualDevice {}
@@ -100,6 +108,7 @@ public class AdbSshConnectionTest {
 
     @Before
     public void setUp() throws Exception {
+        mMockFile = Mockito.mock(File.class);
         MockitoAnnotations.initMocks(this);
         mOptions = new TestDeviceOptions();
         OptionSetter setter = new OptionSetter(mOptions);
@@ -125,6 +134,13 @@ public class AdbSshConnectionTest {
                 };
     }
 
+    @After
+    public void tearDown() {
+        if (mConnection.getGceTunnelMonitor() != null) {
+            mConnection.getGceTunnelMonitor().shutdown();
+        }
+    }
+
     /** Run powerwash() but GceAvdInfo = null. */
     @Test
     public void testPowerwashNoAvdInfo() throws Exception {
@@ -190,6 +206,61 @@ public class AdbSshConnectionTest {
         mConnection.powerwashGce(instanceUser, null);
     }
 
+    /** Test powerwash cvd in oxygen command */
+    @Test
+    public void testPowerwashCvdOxygen() throws Exception {
+        String instanceUser = "user1";
+        mOptions.setAvdDriverBinary(mMockFile);
+        OptionSetter setter = new OptionSetter(mOptions);
+        setter.setOptionValue("instance-user", instanceUser);
+        setter.setOptionValue("extra-oxygen-args", "use_cvd", "");
+        mConnection =
+                new AdbSshConnection(
+                        new ConnectionBuilder(
+                                mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger)) {
+                    @Override
+                    GceManager getGceHandler() {
+                        return mGceHandler;
+                    }
+
+                    @Override
+                    HostOrchestratorUtil createHostOrchestratorUtil(GceAvdInfo gceAvdInfo) {
+                        return mMockHOUtil;
+                    }
+                };
+        when(mMockDevice.getOptions()).thenReturn(mOptions);
+        when(mMockFile.exists()).thenReturn(true);
+        when(mMockFile.canExecute()).thenReturn(true);
+        when(mMockFile.getAbsolutePath()).thenReturn("a/b/c/script");
+        when(mMockAvdInfo.instanceName()).thenReturn("instance");
+        when(mMockAvdInfo.getOxygenationDeviceId()).thenReturn("device_id");
+        when(mMockAvdInfo.hostAndPort()).thenReturn(HostAndPort.fromString("127.0.0.1"));
+        GceAvdInfo gceAvd =
+                new GceAvdInfo(
+                        instanceUser,
+                        HostAndPort.fromHost("127.0.0.1"),
+                        null,
+                        null,
+                        GceStatus.SUCCESS);
+        doReturn(gceAvd)
+                .when(mGceHandler)
+                .startGce(
+                        Mockito.isNull(),
+                        Mockito.isNull(),
+                        Mockito.eq(0),
+                        Mockito.any(),
+                        Mockito.eq(mMockLogger));
+        CommandResult powerwashCmdResult = new CommandResult(CommandStatus.SUCCESS);
+        when(mMockHOUtil.powerwashGce()).thenReturn(powerwashCmdResult);
+        when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
+        when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
+
+        // Launch GCE before powerwash.
+        mConnection.initializeConnection();
+        mConnection.powerwashGce(instanceUser, null);
+        verify(mMockHOUtil, times(1)).powerwashGce();
+    }
+
     @Test
     public void testPowerwashOxygenGce() throws Exception {
         String instanceUser = "user1";
@@ -379,38 +450,34 @@ public class AdbSshConnectionTest {
                 "acloud errors: Could not get a valid instance name, check the gce driver's "
                         + "output.The instance may not have booted up at all.\nGCE driver stderr: ";
 
-        mConnection =
-                new AdbSshConnection(
-                        new ConnectionBuilder(
-                                mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger)) {
-                    @Override
-                    GceManager getGceHandler() {
-                        return new GceManager(
-                                getDevice().getDeviceDescriptor(),
-                                new TestDeviceOptions(),
-                                mMockBuildInfo) {
-                            @Override
-                            protected List<String> buildGceCmd(
-                                    File reportFile,
-                                    IBuildInfo b,
-                                    String ipDevice,
-                                    String user,
-                                    Integer offset,
-                                    MultiMap<String, String> attributes) {
-                                FileUtil.deleteFile(reportFile);
-                                List<String> tmp = new ArrayList<String>();
-                                tmp.add("");
-                                return tmp;
-                            }
-                        };
-                    }
-                };
-
+        String echoFilePath = null;
         try {
+            final File echoFile = FileUtil.createTempFile("echo", ".sh");
+            echoFilePath = echoFile.getAbsolutePath();
+            FileUtil.writeToFile("#!/bin/bash\necho $#", echoFile);
+            FileUtil.chmodGroupRWX(echoFile);
+            mConnection =
+                    new AdbSshConnection(
+                            new ConnectionBuilder(
+                                    mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger)) {
+                        @Override
+                        GceManager getGceHandler() {
+                            TestDeviceOptions deviceOptions = new TestDeviceOptions();
+                            // Make the command line a no-op.
+                            deviceOptions.setAvdDriverBinary(echoFile);
+                            return new GceManager(
+                                    getDevice().getDeviceDescriptor(),
+                                    deviceOptions,
+                                    mMockBuildInfo) {};
+                        }
+                    };
+
             mConnection.initializeConnection();
             fail("A TargetSetupError should have been thrown");
         } catch (TargetSetupError expected) {
             assertTrue(expected.getMessage().startsWith(expectedException));
+        } finally {
+            FileUtil.deleteFile(new File(echoFilePath));
         }
     }
 
@@ -745,7 +812,7 @@ public class AdbSshConnectionTest {
         }
     }
 
-    /** Test ssh tunnel monitor will be initialized when use-oxygenation-device is True */
+    /** Test SSH tunnel monitor will be initialized when use-oxygenation-device is False */
     @Test
     public void testCreateGceTunnelMonitor_SSHTunnel() throws Exception {
         mConnection =
@@ -755,23 +822,151 @@ public class AdbSshConnectionTest {
         mOptions = new TestDeviceOptions();
         OptionSetter setter = new OptionSetter(mOptions);
         setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
-        setter.setOptionValue("use-oxygenation-device", "true");
+        setter.setOptionValue("use-oxygenation-device", "false");
+        mOptions.setSshPrivateKeyPath(mMockFile);
+        when(mMockFile.canRead()).thenReturn(true);
         mConnection.createGceTunnelMonitor(mMockTestDevice, mMockBuildInfo, mMockAvdInfo, mOptions);
-        assertTrue(mConnection.getGceTunnelMonitor() instanceof GceLHPTunnelMonitor);
+        assertTrue(mConnection.getGceTunnelMonitor() instanceof GceSshTunnelMonitor);
     }
 
-    /** Test LHP tunnel monitor will be initialized when use-oxygenation-device is False */
+    /** Test host orchestrator will be initialized when use-oxygenation-device is True. */
     @Test
-    public void testCreateGceTunnelMonitor_LHPTunnel() throws Exception {
+    public void testCreateHOForOxygenation() throws Exception {
         mConnection =
                 new AdbSshConnection(
                         new ConnectionBuilder(
-                                mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger));
+                                mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger)) {
+                    @Override
+                    GceManager getGceHandler() {
+                        return mGceHandler;
+                    }
+
+                    @Override
+                    void createGceTunnelMonitor(
+                            ITestDevice device,
+                            IBuildInfo buildInfo,
+                            GceAvdInfo gceAvdInfo,
+                            TestDeviceOptions deviceOptions) {
+                        // Ignore
+                    }
+                };
         mOptions = new TestDeviceOptions();
+        mOptions.setAvdDriverBinary(mMockFile);
+        OptionSetter setter = new OptionSetter(mOptions);
+        setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
+        setter.setOptionValue("use-oxygenation-device", "true");
+        when(mMockDevice.getOptions()).thenReturn(mOptions);
+        when(mMockFile.exists()).thenReturn(true);
+        when(mMockFile.canExecute()).thenReturn(true);
+        when(mMockFile.getAbsolutePath()).thenReturn("somepath");
+        GceAvdInfo gceAvd =
+                new GceAvdInfo(
+                        "user", HostAndPort.fromHost("127.0.0.1"), null, null, GceStatus.SUCCESS);
+        doReturn(gceAvd)
+                .when(mGceHandler)
+                .startGce(
+                        Mockito.isNull(),
+                        Mockito.isNull(),
+                        Mockito.eq(0),
+                        Mockito.any(),
+                        Mockito.eq(mMockLogger));
+        when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
+        when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
+        mConnection.initializeConnection();
+        assertNotNull(mConnection.getHostOrchestratorUtil());
+    }
+
+    /** Test host orchestrator will be initialized when use_cvd is specified. */
+    @Test
+    public void testCreateHOForOxygen() throws Exception {
+        mConnection =
+                new AdbSshConnection(
+                        new ConnectionBuilder(
+                                mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger)) {
+                    @Override
+                    GceManager getGceHandler() {
+                        return mGceHandler;
+                    }
+
+                    @Override
+                    void createGceTunnelMonitor(
+                            ITestDevice device,
+                            IBuildInfo buildInfo,
+                            GceAvdInfo gceAvdInfo,
+                            TestDeviceOptions deviceOptions) {
+                        // Ignore
+                    }
+                };
+        mOptions = new TestDeviceOptions();
+        mOptions.setAvdDriverBinary(mMockFile);
         OptionSetter setter = new OptionSetter(mOptions);
         setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
         setter.setOptionValue("use-oxygenation-device", "false");
-        mConnection.createGceTunnelMonitor(mMockTestDevice, mMockBuildInfo, mMockAvdInfo, mOptions);
-        assertTrue(mConnection.getGceTunnelMonitor() instanceof GceSshTunnelMonitor);
+        setter.setOptionValue("extra-oxygen-args", "use_cvd", "");
+        when(mMockDevice.getOptions()).thenReturn(mOptions);
+        when(mMockFile.exists()).thenReturn(true);
+        when(mMockFile.canExecute()).thenReturn(true);
+        when(mMockFile.getAbsolutePath()).thenReturn("somepath");
+        GceAvdInfo gceAvd =
+                new GceAvdInfo(
+                        "user", HostAndPort.fromHost("127.0.0.1"), null, null, GceStatus.SUCCESS);
+        doReturn(gceAvd)
+                .when(mGceHandler)
+                .startGce(
+                        Mockito.isNull(),
+                        Mockito.isNull(),
+                        Mockito.eq(0),
+                        Mockito.any(),
+                        Mockito.eq(mMockLogger));
+        when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
+        when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
+        mConnection.initializeConnection();
+        assertNotNull(mConnection.getHostOrchestratorUtil());
+    }
+
+    /** Test host orchestrator will not be initialized for neither Oxygenation nor Oxygen. */
+    @Test
+    public void testNoHOCreated() throws Exception {
+        mConnection =
+                new AdbSshConnection(
+                        new ConnectionBuilder(
+                                mMockRunUtil, mMockDevice, mMockBuildInfo, mMockLogger)) {
+                    @Override
+                    GceManager getGceHandler() {
+                        return mGceHandler;
+                    }
+
+                    @Override
+                    void createGceTunnelMonitor(
+                            ITestDevice device,
+                            IBuildInfo buildInfo,
+                            GceAvdInfo gceAvdInfo,
+                            TestDeviceOptions deviceOptions) {
+                        // Ignore
+                    }
+                };
+        mOptions = new TestDeviceOptions();
+        mOptions.setAvdDriverBinary(mMockFile);
+        OptionSetter setter = new OptionSetter(mOptions);
+        setter.setOptionValue(TestDeviceOptions.INSTANCE_TYPE_OPTION, "CUTTLEFISH");
+        setter.setOptionValue("use-oxygenation-device", "false");
+        when(mMockDevice.getOptions()).thenReturn(mOptions);
+        when(mMockFile.exists()).thenReturn(true);
+        when(mMockFile.canExecute()).thenReturn(true);
+        GceAvdInfo gceAvd =
+                new GceAvdInfo(
+                        "user", HostAndPort.fromHost("127.0.0.1"), null, null, GceStatus.SUCCESS);
+        doReturn(gceAvd)
+                .when(mGceHandler)
+                .startGce(
+                        Mockito.isNull(),
+                        Mockito.isNull(),
+                        Mockito.eq(0),
+                        Mockito.any(),
+                        Mockito.eq(mMockLogger));
+        when(mMockMonitor.waitForDeviceAvailable(Mockito.anyLong())).thenReturn(mMockIDevice);
+        when(mMockIDevice.getState()).thenReturn(DeviceState.ONLINE);
+        mConnection.initializeConnection();
+        assertNull(mConnection.getHostOrchestratorUtil());
     }
 }
diff --git a/javatests/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollectorTest.java b/javatests/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollectorTest.java
index d157b084e..86f956871 100644
--- a/javatests/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollectorTest.java
+++ b/javatests/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollectorTest.java
@@ -19,32 +19,31 @@ package com.android.tradefed.device.metric;
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertTrue;
-
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.startsWith;
-import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.device.DeviceRuntimeException;
 import com.android.tradefed.device.IDeviceActionReceiver;
 import com.android.tradefed.device.ITestDevice;
-import com.android.tradefed.device.DeviceRuntimeException;
 import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.testtype.coverage.CoverageOptions;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
-import com.android.tradefed.util.proto.TfMetricProtoUtil;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.proto.TfMetricProtoUtil;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -118,6 +117,7 @@ public class GcovKernelCodeCoverageCollectorTest {
         mCoverageOptionsSetter = new OptionSetter(mCoverageOptions);
 
         doReturn(mCoverageOptions).when(mMockConfiguration).getCoverageOptions();
+        doReturn("mock-serial").when(mMockDevice).getSerialNumber();
         doReturn(ImmutableList.of(mMockDevice)).when(mMockContext).getDevices();
         doReturn(mContextAttributes).when(mMockContext).getAttributes();
 
@@ -142,8 +142,8 @@ public class GcovKernelCodeCoverageCollectorTest {
                         })
                 .when(mMockDevice)
                 .reboot();
-
-        doReturn(true).when(mMockDevice).isDebugfsMounted();
+        // Not mounted initially. Then mounted successfully.
+        doReturn(false, true).when(mMockDevice).isDebugfsMounted();
 
         when(mMockDevice.executeShellV2Command(
                         GcovKernelCodeCoverageCollector.RESET_GCOV_COUNTS_COMMAND))
diff --git a/javatests/com/android/tradefed/invoker/InvocationExecutionTest.java b/javatests/com/android/tradefed/invoker/InvocationExecutionTest.java
index 3021d27fc..fe4947650 100644
--- a/javatests/com/android/tradefed/invoker/InvocationExecutionTest.java
+++ b/javatests/com/android/tradefed/invoker/InvocationExecutionTest.java
@@ -16,19 +16,17 @@
 package com.android.tradefed.invoker;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.any;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
 
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.config.Configuration;
@@ -66,14 +64,16 @@ import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
 import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Unit tests for {@link InvocationExecution}. Tests for each individual interface of
@@ -253,7 +253,8 @@ public class InvocationExecutionTest {
         mConfig.setTests(tests);
         mConfig.getRetryDecision().setInvocationContext(mContext);
         LogSaverResultForwarder forwarder =
-                new LogSaverResultForwarder(mConfig.getLogSaver(), Arrays.asList(mMockLogListener));
+                new LogSaverResultForwarder(
+                        mConfig.getLogSaver(), Arrays.asList(mMockLogListener), mConfig);
         mExec.runTests(info, mConfig, forwarder);
 
         verify(mMockLogListener).testRunStarted(eq("runName"), eq(3), eq(0), Mockito.anyLong());
diff --git a/javatests/com/android/tradefed/invoker/ShardListenerTest.java b/javatests/com/android/tradefed/invoker/ShardListenerTest.java
index 32172d130..76d1b84ca 100644
--- a/javatests/com/android/tradefed/invoker/ShardListenerTest.java
+++ b/javatests/com/android/tradefed/invoker/ShardListenerTest.java
@@ -20,6 +20,9 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.build.BuildInfo;
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.ByteArrayInputStreamSource;
@@ -321,14 +324,22 @@ public class ShardListenerTest {
                 .thenReturn(invocFile);
 
         // Setup of sharding
+        IConfiguration originalConfig = new Configuration("", "");
+        originalConfig.setCommandOptions(new CommandOptions());
         LogSaverResultForwarder originalInvocation =
-                new LogSaverResultForwarder(mMockSaver, Arrays.asList(mockListener));
+                new LogSaverResultForwarder(
+                        mMockSaver, Arrays.asList(mockListener), originalConfig);
         ShardMainResultForwarder mainForwarder =
                 new ShardMainResultForwarder(Arrays.asList(originalInvocation), 1);
         mainForwarder.invocationStarted(mContext);
+
         ShardListener shard1 = new ShardListener(mainForwarder);
+        IConfiguration shardConfig = new Configuration("", "");
+        CommandOptions shardOptions = new CommandOptions();
+        shardOptions.setHostLogSuffix("_shard_index_1");
+        shardConfig.setCommandOptions(shardOptions);
         LogSaverResultForwarder shardedInvocation =
-                new LogSaverResultForwarder(mMockSaver, Arrays.asList(shard1));
+                new LogSaverResultForwarder(mMockSaver, Arrays.asList(shard1), shardConfig);
 
         shardedInvocation.invocationStarted(mContext);
         shardedInvocation.testRunStarted("run1", 1);
@@ -392,5 +403,10 @@ public class ShardListenerTest {
         inOrder.verify(mockListener).getSummary();
         inOrder.verify(mMockSaver).invocationEnded(0L);
         inOrder.verify(mMockSaver).invocationEnded(0L);
+        inOrder.verify(mMockSaver)
+                .saveLogData(
+                        Mockito.eq(TestInvocation.TRADEFED_END_HOST_LOG + "_shard_index_1"),
+                        Mockito.eq(LogDataType.HOST_LOG),
+                        Mockito.any());
     }
 }
diff --git a/javatests/com/android/tradefed/invoker/ShardMainResultForwarderTest.java b/javatests/com/android/tradefed/invoker/ShardMainResultForwarderTest.java
index c0e66798e..acfd07479 100644
--- a/javatests/com/android/tradefed/invoker/ShardMainResultForwarderTest.java
+++ b/javatests/com/android/tradefed/invoker/ShardMainResultForwarderTest.java
@@ -21,7 +21,10 @@ import static org.mockito.Mockito.times;
 
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationDescriptor;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationGroupMetricKey;
 import com.android.tradefed.result.ByteArrayInputStreamSource;
@@ -165,8 +168,11 @@ public class ShardMainResultForwarderTest {
         ShardMainResultForwarder reporter =
                 new ShardMainResultForwarder(Arrays.asList(mMockLogListener), 1);
         ShardListener shardListener = new ShardListener(reporter);
+        IConfiguration config = new Configuration("", "");
+        config.setCommandOptions(new CommandOptions());
+
         LogSaverResultForwarder invocationLogger =
-                new LogSaverResultForwarder(mMockLogSaver, Arrays.asList(shardListener));
+                new LogSaverResultForwarder(mMockLogSaver, Arrays.asList(shardListener), config);
         IInvocationContext main = new InvocationContext();
         IBuildInfo mainBuild1 = new BuildInfo();
         main.addAllocatedDevice("device1", Mockito.mock(ITestDevice.class));
diff --git a/javatests/com/android/tradefed/invoker/shard/DynamicShardHelperTest.java b/javatests/com/android/tradefed/invoker/shard/DynamicShardHelperTest.java
new file mode 100644
index 000000000..754cb0201
--- /dev/null
+++ b/javatests/com/android/tradefed/invoker/shard/DynamicShardHelperTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.invoker.shard;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.invoker.IRescheduler;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.testtype.IRemoteTest;
+import com.android.tradefed.testtype.StubTest;
+
+import com.google.internal.android.engprod.v1.ProvideTestTargetResponse;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** Unit tests for {@link StrictShardHelper}. */
+@RunWith(JUnit4.class)
+public class DynamicShardHelperTest {
+    @Test
+    public void testBailoutNoITestSuite() throws Exception {
+        IConfiguration config = new Configuration("fake_sharding_config", "desc");
+        List<IRemoteTest> tests = new ArrayList<>();
+        tests.add(new StubTest());
+        config.setTests(tests);
+
+        // Set command options such that it appears that dynamic sharding should be used.
+        CommandOptions options = new CommandOptions();
+        OptionSetter setter = new OptionSetter(options);
+        setter.setOptionValue("shard-count", "3");
+        setter.setOptionValue("shard-index", "1");
+        setter.setOptionValue("remote-dynamic-sharding", "true");
+        config.setCommandOptions(options);
+        config.setCommandLine(new String[] {"empty"});
+
+        InvocationContext ctx = new InvocationContext();
+        ctx.addInvocationAttribute("invocation_id", "testPool123abc");
+        ctx.addInvocationAttribute("invocation-id", "testPool123abc");
+        ctx.addInvocationAttribute("attempt_id", "0");
+        TestInformation testInfo = TestInformation.newBuilder().setInvocationContext(ctx).build();
+
+        IRescheduler rescheduler = Mockito.mock(IRescheduler.class);
+
+        IDynamicShardingClient mockClient = mock(ConfigurableGrpcDynamicShardingClient.class);
+        ProvideTestTargetResponse fakeResponse = ProvideTestTargetResponse.newBuilder().build();
+        doReturn(fakeResponse).when(mockClient).provideTestTarget(Mockito.any());
+
+        DynamicShardHelper helper =
+                new DynamicShardHelper() {
+                    private IDynamicShardingClient getClient() {
+                        return mockClient;
+                    }
+                };
+
+        DynamicShardHelper spyHelper = spy(helper);
+
+        boolean result = spyHelper.shardConfig(config, testInfo, rescheduler, null);
+
+        verify(spyHelper, times(1))
+                .shardConfigStrict(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any());
+        assertEquals(config.getCommandOptions().shouldRemoteDynamicShard(), true);
+    }
+}
diff --git a/javatests/com/android/tradefed/invoker/shard/StrictShardHelperTest.java b/javatests/com/android/tradefed/invoker/shard/StrictShardHelperTest.java
index 8d4507f08..e59aff31a 100644
--- a/javatests/com/android/tradefed/invoker/shard/StrictShardHelperTest.java
+++ b/javatests/com/android/tradefed/invoker/shard/StrictShardHelperTest.java
@@ -22,6 +22,8 @@ import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.build.StubBuildProvider;
@@ -40,6 +42,7 @@ import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.IRescheduler;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.ITestLogger;
 import com.android.tradefed.result.ILogSaver;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.testtype.IInvocationContextReceiver;
@@ -708,6 +711,90 @@ public class StrictShardHelperTest {
         }
     }
 
+    @Test
+    public void testDynamicShardEnabled() throws Exception {
+        StrictShardHelper tHelper =
+                new StrictShardHelper() {
+                    @Override
+                    protected boolean shardConfigDynamic(
+                            IConfiguration config,
+                            TestInformation testInfo,
+                            IRescheduler rescheduler,
+                            ITestLogger logger) {
+                        return true;
+                    }
+                };
+        StrictShardHelper spyHelper = Mockito.spy(tHelper);
+
+        List<IRemoteTest> test = new ArrayList<>();
+        test.add(createFakeSuite("module2"));
+        test.add(createFakeSuite("module1"));
+        test.add(createFakeSuite("module3"));
+        test.add(createFakeSuite("module1"));
+        test.add(createFakeSuite("module1"));
+        test.add(createFakeSuite("module2"));
+        test.add(createFakeSuite("module3"));
+        CommandOptions options = new CommandOptions();
+        OptionSetter setter = new OptionSetter(options);
+        setter.setOptionValue("shard-count", "3");
+        setter.setOptionValue("shard-index", "1");
+
+        // Important! Setting remote-dynamic-sharding to true
+        setter.setOptionValue("remote-dynamic-sharding", "true");
+
+        mConfig.setCommandOptions(options);
+        mConfig.setCommandLine(new String[] {"empty"});
+        mConfig.setTests(test);
+
+        spyHelper.shardConfig(mConfig, mTestInfo, mRescheduler, null);
+
+        // Verify that it is called once
+        verify(spyHelper, times(1))
+                .shardConfigDynamic(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any());
+    }
+
+    @Test
+    public void testDynamicShardDisabled() throws Exception {
+        StrictShardHelper tHelper =
+                new StrictShardHelper() {
+                    @Override
+                    protected boolean shardConfigDynamic(
+                            IConfiguration config,
+                            TestInformation testInfo,
+                            IRescheduler rescheduler,
+                            ITestLogger logger) {
+                        return true;
+                    }
+                };
+        StrictShardHelper spyHelper = Mockito.spy(tHelper);
+
+        List<IRemoteTest> test = new ArrayList<>();
+        test.add(createFakeSuite("module2"));
+        test.add(createFakeSuite("module1"));
+        test.add(createFakeSuite("module3"));
+        test.add(createFakeSuite("module1"));
+        test.add(createFakeSuite("module1"));
+        test.add(createFakeSuite("module2"));
+        test.add(createFakeSuite("module3"));
+        CommandOptions options = new CommandOptions();
+        OptionSetter setter = new OptionSetter(options);
+        setter.setOptionValue("shard-count", "3");
+        setter.setOptionValue("shard-index", "1");
+
+        // Important! Setting remote-dynamic-sharding to false
+        setter.setOptionValue("remote-dynamic-sharding", "false");
+
+        mConfig.setCommandOptions(options);
+        mConfig.setCommandLine(new String[] {"empty"});
+        mConfig.setTests(test);
+
+        spyHelper.shardConfig(mConfig, mTestInfo, mRescheduler, null);
+
+        // Verify that it is not called
+        verify(spyHelper, times(0))
+                .shardConfigDynamic(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any());
+    }
+
     private File createTmpConfig(String objType, Object obj) throws IOException {
         File configFile = FileUtil.createTempFile("shard-helper-test", ".xml");
         String content = String.format(TEST_CONFIG, objType, obj.getClass().getCanonicalName());
diff --git a/javatests/com/android/tradefed/invoker/shard/TestsPoolPollerTest.java b/javatests/com/android/tradefed/invoker/shard/TestsPoolPollerTest.java
index a277c6546..f9dce7df3 100644
--- a/javatests/com/android/tradefed/invoker/shard/TestsPoolPollerTest.java
+++ b/javatests/com/android/tradefed/invoker/shard/TestsPoolPollerTest.java
@@ -21,7 +21,6 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.IConfiguration;
@@ -36,6 +35,7 @@ import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.invoker.shard.token.ITokenRequest;
 import com.android.tradefed.log.ILogRegistry;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
diff --git a/javatests/com/android/tradefed/log/FileLoggerTest.java b/javatests/com/android/tradefed/log/FileLoggerTest.java
index bb0cb08b1..796d4011b 100644
--- a/javatests/com/android/tradefed/log/FileLoggerTest.java
+++ b/javatests/com/android/tradefed/log/FileLoggerTest.java
@@ -20,11 +20,11 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.targetprep.StubTargetPreparer;
 import com.android.tradefed.targetprep.suite.SuiteApkInstaller;
@@ -66,13 +66,11 @@ public class FileLoggerTest {
             logger.init();
             // Write 3 lines of text to the log...
             logger.printLog(LogLevel.INFO, LOG_TAG, Text1);
-            String expectedText1 = LogUtil.getLogFormatString(LogLevel.INFO, LOG_TAG, Text1).trim();
+            String expectedText1 = Log.getLogFormatString(LogLevel.INFO, LOG_TAG, Text1).trim();
             logger.printLog(LogLevel.VERBOSE, LOG_TAG, Text2);
-            String expectedText2 =
-                    LogUtil.getLogFormatString(LogLevel.VERBOSE, LOG_TAG, Text2).trim();
+            String expectedText2 = Log.getLogFormatString(LogLevel.VERBOSE, LOG_TAG, Text2).trim();
             logger.printLog(LogLevel.ASSERT, LOG_TAG, Text3);
-            String expectedText3 =
-                    LogUtil.getLogFormatString(LogLevel.ASSERT, LOG_TAG, Text3).trim();
+            String expectedText3 = Log.getLogFormatString(LogLevel.ASSERT, LOG_TAG, Text3).trim();
             // Verify the 3 lines we logged
             logSource = logger.getLog();
             logFileReader = new BufferedReader(new InputStreamReader(
diff --git a/javatests/com/android/tradefed/log/HistoryLoggerTest.java b/javatests/com/android/tradefed/log/HistoryLoggerTest.java
index db9d6a13f..db54ee144 100644
--- a/javatests/com/android/tradefed/log/HistoryLoggerTest.java
+++ b/javatests/com/android/tradefed/log/HistoryLoggerTest.java
@@ -15,8 +15,8 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log.LogLevel;
 
 import org.junit.After;
 import org.junit.Assert;
diff --git a/javatests/com/android/tradefed/log/LogRegistryTest.java b/javatests/com/android/tradefed/log/LogRegistryTest.java
index b46beaa71..4fcfd317f 100644
--- a/javatests/com/android/tradefed/log/LogRegistryTest.java
+++ b/javatests/com/android/tradefed/log/LogRegistryTest.java
@@ -19,8 +19,7 @@ import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.android.ddmlib.Log;
-import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.log.Log.LogLevel;
 
 import org.junit.After;
 import org.junit.Before;
diff --git a/javatests/com/android/tradefed/log/SimpleFileLoggerTest.java b/javatests/com/android/tradefed/log/SimpleFileLoggerTest.java
index b6ae74cec..7c90946f0 100644
--- a/javatests/com/android/tradefed/log/SimpleFileLoggerTest.java
+++ b/javatests/com/android/tradefed/log/SimpleFileLoggerTest.java
@@ -15,15 +15,14 @@
  */
 package com.android.tradefed.log;
 
+import static org.hamcrest.CoreMatchers.endsWith;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
-
-import static org.hamcrest.CoreMatchers.endsWith;
 import static org.junit.Assert.assertTrue;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.util.FileUtil;
 
 import org.junit.After;
diff --git a/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java b/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java
index aeffd0ea3..6f3d89766 100644
--- a/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java
+++ b/javatests/com/android/tradefed/postprocessor/BasePostProcessorTest.java
@@ -22,6 +22,7 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.device.metric.BaseDeviceMetricCollector;
 import com.android.tradefed.device.metric.DeviceMetricData;
 import com.android.tradefed.invoker.InvocationContext;
@@ -234,6 +235,7 @@ public class BasePostProcessorTest {
     @Mock ILogSaver mMockLogSaver;
 
     @Rule public TemporaryFolder folder = new TemporaryFolder();
+    @Mock IConfiguration mMockConfig;
 
     @Before
     public void setUp() throws IOException {
@@ -309,7 +311,7 @@ public class BasePostProcessorTest {
         // callbacks.
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         listener.testRunStarted("test-run", 0, 0, 0L);
         listener.testLog(
                 RUN_DATA_NAME_1,
@@ -342,7 +344,7 @@ public class BasePostProcessorTest {
         // callbacks.
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         // Simulate two tests that log one file each, with run-level logs in-between and after.
         listener.testRunStarted("test-run", 2, 0, 0L);
         listener.testStarted(test1);
@@ -412,7 +414,7 @@ public class BasePostProcessorTest {
         // callbacks.
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         // Simulate a run with two test logs.
         listener.testStarted(test);
         listener.testLog(
@@ -455,7 +457,7 @@ public class BasePostProcessorTest {
         // callbacks.
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         // Simulate a run with one test log and one run log.
         listener.testStarted(test);
         listener.testLog(
@@ -490,7 +492,7 @@ public class BasePostProcessorTest {
         // Two calls are expected since there are two tests.
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         // Simulate two tests that log one file each.
         listener.testStarted(test1);
         listener.testLog(
@@ -587,7 +589,7 @@ public class BasePostProcessorTest {
 
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         // Simulate a run with two tests that log one file each.
         listener.testRunStarted("test-run", 2, 0, 0L);
         listener.testStarted(test1);
@@ -641,7 +643,7 @@ public class BasePostProcessorTest {
         // Two sets of expected captures for two test runs.
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         // Simulate a test run with two runs and one test each.
         // Run 1.
         listener.testRunStarted(runName, 1, 0, 0L);
@@ -736,7 +738,7 @@ public class BasePostProcessorTest {
 
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         listener.testRunStarted(RUN_NAME, 1);
         listener.testStarted(TEST_DESCRIPTION);
         listener.testEnded(TEST_DESCRIPTION, new HashMap<String, Metric>());
@@ -770,7 +772,7 @@ public class BasePostProcessorTest {
         // files saved from the metric collector will only be saved once.
         LogSaverResultForwarder forwarder =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         FileLoggingMetricCollector listener = new FileLoggingMetricCollector();
         listener.init(new InvocationContext(), forwarder);
         listener.testRunStarted(RUN_NAME, 1);
@@ -827,7 +829,8 @@ public class BasePostProcessorTest {
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
                         mMockLogSaver,
-                        Arrays.asList(mProcessor.init(innerProcessor.init(mMockListener))));
+                        Arrays.asList(mProcessor.init(innerProcessor.init(mMockListener))),
+                        mMockConfig);
         listener.testRunStarted(RUN_NAME, 1);
         listener.testStarted(TEST_DESCRIPTION);
         listener.testEnded(TEST_DESCRIPTION, new HashMap<String, Metric>());
@@ -860,7 +863,7 @@ public class BasePostProcessorTest {
 
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         listener.testRunStarted(RUN_NAME, 1);
         listener.testStarted(TEST_DESCRIPTION);
         listener.testEnded(TEST_DESCRIPTION, new HashMap<String, Metric>());
@@ -881,7 +884,7 @@ public class BasePostProcessorTest {
 
         LogSaverResultForwarder listener =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         listener.testRunStarted(RUN_NAME, 1);
         listener.testStarted(TEST_DESCRIPTION);
         listener.testEnded(TEST_DESCRIPTION, new HashMap<String, Metric>());
@@ -938,7 +941,7 @@ public class BasePostProcessorTest {
         // files saved from the metric collector will only be saved once.
         LogSaverResultForwarder forwarder =
                 new LogSaverResultForwarder(
-                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)));
+                        mMockLogSaver, Arrays.asList(mProcessor.init(mMockListener)), mMockConfig);
         FileLoggingMetricCollector listener = new FileLoggingMetricCollector();
         listener.init(new InvocationContext(), forwarder);
         listener.testRunStarted(RUN_NAME, 1);
diff --git a/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java b/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
index a07e40a47..3de8501b9 100644
--- a/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
+++ b/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
@@ -43,6 +43,8 @@ import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mock;
 
+import perfetto.protos.PerfettoMergedMetrics.TraceMetrics;
+
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -52,8 +54,6 @@ import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
-import perfetto.protos.PerfettoMergedMetrics.TraceMetrics;
-
 /** Unit tests for {@link PerfettoGenericPostProcessor}. */
 @RunWith(JUnit4.class)
 public class PerfettoGenericPostProcessorTest {
@@ -500,11 +500,18 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics = mProcessor
                 .processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
+        if (DEBUG) {
+            printOutputMetricsForDebug(parsedMetrics);
+        }
         assertMetricsContain(
                 parsedMetrics,
                 "android_jank_cuj-cuj-name-com.android.systemui-name-NOTIFICATION_ADD-timeline_"
                 + "metrics-frame_dur_avg",
                 5040562);
+        assertMetricsContain(
+                parsedMetrics,
+                "perfetto_android_jank_cuj-cuj-name-NOTIFICATION_ADD-dur",
+                460793302);
     }
 
     @Test
diff --git a/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java b/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
index 2cbb55530..6f377641f 100644
--- a/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
+++ b/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
@@ -111,7 +111,8 @@ public class GeneralTestsConfigValidation implements IBuildReceiver {
                             "com.google.android.deviceconfig.RebootTest",
                             "com.android.scenario.AppSetup",
                             "com.android.power.PowerRunner",
-                            "com.android.boot.BootTimeTest"));
+                            "com.android.boot.BootTimeTest",
+                            "org.khronos.cts.runner.KhronosCTSRunner"));
 
     /**
      * List of configs that will be exempted until they are converted to use MediaPreparers.
diff --git a/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java b/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
index b2c5dac3b..f7cc9f15a 100644
--- a/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
+++ b/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
@@ -151,15 +151,21 @@ public class TestMappingsValidation implements IBuildReceiver {
 
     private static final Set<String> PRESUBMIT_LARGE_ALLOWLIST =
             ImmutableSet.of(
+                    "FrameworksServicesTests_Presubmit",
                     "binderRpcTestNoKernel",
                     "CtsLibcoreOjTestCases_time",
+                    "CtsLibcoreOjTestCases_util",
                     "CtsTelecomTestCases",
                     "CtsAppTestCases",
+                    "CtsAppTestCases_all-except-large",
+                    "CtsAppTestCases_activitymanagerprocessstatetest",
                     "binderRpcTestSingleThreadedNoKernel",
                     "CtsSuspendAppsPermissionTestCases",
                     "CtsAppSecurityHostTestCases",
+                    "CtsAppSecurityHostTestCases_cts_externalstoragehosttest",
                     "CtsPackageManagerTestCases", // Renamed from CtsAppSecurityHostTestCases
                     "FrameworksServicesTests",
+                    "FrameworksServicesTests_presubmit",
                     "NeuralNetworksTest_static",
                     "CtsNNAPITestCases",
                     "CtsLibcoreTestCases",
@@ -168,6 +174,8 @@ public class TestMappingsValidation implements IBuildReceiver {
                     "CtsPermissionUiTestCases",
                     "sharedlibs_host_tests",
                     "CtsDevicePolicyManagerTestCases",
+                    "CtsDevicePolicyManagerTestCases_Permissions",
+                    "CtsDevicePolicyManagerTestCases_LockSettingsTest",
                     "CtsMediaAudioTestCases",
                     "CtsScopedStoragePublicVolumeHostTest",
                     "CtsContentTestCases",
@@ -196,6 +204,8 @@ public class TestMappingsValidation implements IBuildReceiver {
                     "CtsMediaCodecTestCases",
                     "CtsRollbackManagerHostTestCases",
                     "CtsAutoFillServiceTestCases",
+                    "CtsAutoFillServiceTestCases_cts_inline",
+                    "CtsAutoFillServiceTestCases_android_server_autofill_Presubmit",
                     "CtsOsTestCases",
                     "CtsDynamicMimeHostTestCases",
                     "VtsHalNeuralnetworksTargetTest",
@@ -210,6 +220,7 @@ public class TestMappingsValidation implements IBuildReceiver {
             ImmutableSet.of(
                     "libnativeloader_e2e_tests",
                     "BugreportManagerTestCases",
+                    "BugreportManagerTestCases_android_server_os",
                     "CtsRootBugreportTestCases",
                     "ApexServiceTestCases",
                     "OverlayDeviceTests");
@@ -405,27 +416,6 @@ public class TestMappingsValidation implements IBuildReceiver {
         }
     }
 
-    /**
-     * Test all the tests by each test group and make sure the file options aren't conflict to AJUR
-     * rules.
-     */
-    @Test
-    public void testFilterOptions() {
-        List<String> errors = new ArrayList<>();
-        for (String testGroup : allTests.keySet()) {
-            for (String moduleName : getModuleNames(testGroup)) {
-                errors.addAll(validateFilterOption(moduleName, INCLUDE_FILTER, testGroup));
-                errors.addAll(validateFilterOption(moduleName, EXCLUDE_FILTER, testGroup));
-            }
-        }
-        if (!errors.isEmpty()) {
-            fail(
-                    String.format(
-                            "Fail include/exclude filter setting check:\n%s",
-                            Joiner.on("\n").join(errors)));
-        }
-    }
-
     /** Test to ensure performance test modules are not included for test mapping. */
     @Test
     public void testNoPerformanceTests() throws IOException {
@@ -501,45 +491,6 @@ public class TestMappingsValidation implements IBuildReceiver {
         }
     }
 
-    /**
-     * Validate if the filter option of a test contains both class/method and package. options.
-     *
-     * @param moduleName A {@code String} name of a test module.
-     * @param filterOption A {@code String} of the filter option defined in TEST MAPPING file.
-     * @param testGroup A {@code String} name of the test group.
-     * @return A {@code List<String>} of the validation errors.
-     */
-    private List<String> validateFilterOption(
-            String moduleName, String filterOption, String testGroup) {
-        List<String> errors = new ArrayList<>();
-        for (TestInfo test : getTestInfos(moduleName, testGroup)) {
-            Set<Filters> filterTypes = new HashSet<>();
-            Map<Filters, Set<TestInfo>> filterTestInfos = new HashMap<>();
-            for (TestOption options : test.getOptions()) {
-                if (options.getName().equals(filterOption)) {
-                    Filters optionType = getOptionType(options.getValue());
-                    // Add optionType with each TestInfo to get the detailed information.
-                    filterTestInfos.computeIfAbsent(optionType, k -> new HashSet<>()).add(test);
-                }
-            }
-            filterTypes = filterTestInfos.keySet();
-            // If the options of a test in one TEST_MAPPING file contain either REGEX,
-            // CLASS_OR_METHOD, or PACKAGE, it should be caught and output the tests
-            // information.
-            // TODO(b/128947872): List the type with fewest options first.
-            if (filterTypes.size() > 1) {
-                errors.add(
-                        String.format(
-                                "Mixed filter types found. Test: %s , TestGroup: %s, Details:\n"
-                                        + "%s",
-                                moduleName,
-                                testGroup,
-                                getDetailedErrors(filterOption, filterTestInfos)));
-            }
-        }
-        return errors;
-    }
-
     /**
      * Get the detailed validation errors.
      *
diff --git a/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java b/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java
new file mode 100644
index 000000000..5cd797b37
--- /dev/null
+++ b/javatests/com/android/tradefed/result/proto/ModuleProtoResultReporterTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.proto;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import com.android.tradefed.config.ConfigurationDescriptor;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.testtype.suite.ITestSuite;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.proto.TestRecordProtoUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/** Unit tests for {@link ModuleProtoResultReporter}. */
+public class ModuleProtoResultReporterTest {
+
+    private ModuleProtoResultReporter mReporter;
+    private File mOutput;
+    @Mock ITestInvocationListener mMockListener;
+
+    @Before
+    public void setUp() throws IOException {
+        MockitoAnnotations.initMocks(this);
+
+        mOutput = FileUtil.createTempFile("proto-file-reporter-test", ".pb");
+        mReporter = new ModuleProtoResultReporter();
+        mReporter.setFileOutput(mOutput);
+    }
+
+    @After
+    public void tearDown() {
+        FileUtil.deleteFile(mOutput);
+    }
+
+    @Test
+    public void testModuleReporting() throws Exception {
+        IInvocationContext context = new InvocationContext();
+        TestDescription test1 = new TestDescription("class1", "test1");
+
+        IInvocationContext module1Context = createModuleContext("module1");
+        mReporter.testModuleStarted(module1Context);
+        mReporter.testRunStarted("run1", 1);
+        mReporter.testStarted(test1);
+        mReporter.testEnded(test1, new HashMap<String, Metric>());
+        mReporter.testRunEnded(200L, new HashMap<String, Metric>());
+        module1Context.addInvocationAttribute(ITestSuite.MODULE_END_TIME, "endTime");
+        mReporter.testModuleEnded();
+
+        ProtoResultParser parser = new ProtoResultParser(mMockListener, context, false);
+        parser.processFinalizedProto(TestRecordProtoUtil.readFromFile(mOutput, false));
+
+        verify(mMockListener, never()).invocationStarted(Mockito.any());
+        verify(mMockListener).testModuleStarted(Mockito.any());
+        verify(mMockListener)
+                .testRunStarted(
+                        Mockito.eq("run1"), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
+        verify(mMockListener).testStarted(Mockito.eq(test1), Mockito.anyLong());
+        verify(mMockListener)
+                .testEnded(
+                        Mockito.eq(test1),
+                        Mockito.anyLong(),
+                        Mockito.<HashMap<String, Metric>>any());
+        verify(mMockListener).testRunEnded(200L, new HashMap<String, Metric>());
+        verify(mMockListener).testModuleEnded();
+        verify(mMockListener, never()).invocationEnded(anyLong());
+    }
+
+    @Test
+    public void testModuleReporting_metadata() throws Exception {
+        IInvocationContext context = new InvocationContext();
+        context.addInvocationAttribute(ModuleProtoResultReporter.INVOCATION_ID_KEY, "I8888");
+        mReporter = new ModuleProtoResultReporter(context);
+        mReporter.setFileOutput(mOutput);
+        TestDescription test1 = new TestDescription("class1", "test1");
+
+        IInvocationContext module1Context = createModuleContext("module1");
+        mReporter.testModuleStarted(module1Context);
+        mReporter.testRunStarted("run1", 1);
+        mReporter.testStarted(test1);
+        mReporter.testEnded(test1, new HashMap<String, Metric>());
+        mReporter.testRunEnded(200L, new HashMap<String, Metric>());
+        module1Context.addInvocationAttribute(ITestSuite.MODULE_END_TIME, "endTime");
+        mReporter.testModuleEnded();
+
+        Map<String, String> metadata = ModuleProtoResultReporter.parseResultsMetadata(mOutput);
+        assertEquals(metadata.get(ModuleProtoResultReporter.INVOCATION_ID_KEY), "I8888");
+    }
+
+    private IInvocationContext createModuleContext(String moduleId) {
+        IInvocationContext context = new InvocationContext();
+        context.addInvocationAttribute(ModuleDefinition.MODULE_ID, moduleId);
+        context.setConfigurationDescriptor(new ConfigurationDescriptor());
+        context.addInvocationAttribute(ITestSuite.MODULE_START_TIME, "startTime");
+        return context;
+    }
+}
diff --git a/javatests/com/android/tradefed/result/skipped/SkipFeatureTest.java b/javatests/com/android/tradefed/result/skipped/SkipFeatureTest.java
new file mode 100644
index 000000000..b4409dace
--- /dev/null
+++ b/javatests/com/android/tradefed/result/skipped/SkipFeatureTest.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.skipped;
+
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.service.TradefedFeatureClient;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.truth.Truth;
+import com.proto.tradefed.feature.FeatureRequest;
+import com.proto.tradefed.feature.FeatureResponse;
+import com.proto.tradefed.feature.PartResponse;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.util.Map;
+import java.util.Set;
+
+/** Unit tests for {@link SkipFeature}. */
+@RunWith(JUnit4.class)
+public class SkipFeatureTest {
+    @Mock TradefedFeatureClient mMockClient;
+    private SkipFeature mSkipGetter;
+    private IConfiguration mConfiguration;
+    private TestInformation mTestInfo;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mSkipGetter = new SkipFeature();
+        mConfiguration = new Configuration("name", "description");
+        mTestInfo =
+                TestInformation.newBuilder().setInvocationContext(new InvocationContext()).build();
+    }
+
+    @Test
+    public void testSkipFeature() throws Exception {
+        Map<String, Digest> image =
+                ImmutableMap.of(
+                        "device_image",
+                                Digest.newBuilder().setHash("fakehash").setSizeBytes(8).build(),
+                        "cvd.tar",
+                                Digest.newBuilder().setHash("fakehash2").setSizeBytes(9).build());
+        FeatureRequest.Builder builder = FeatureRequest.newBuilder();
+        SkipManager skipManager =
+                new SkipManager() {
+                    @Override
+                    public Set<String> getUnchangedModules() {
+                        return ImmutableSet.of("module1", "module2");
+                    }
+
+                    @Override
+                    public Map<String, Digest> getImageToDigest() {
+                        return image;
+                    }
+                };
+        OptionSetter setter = new OptionSetter(skipManager);
+        setter.setOptionValue("report-module-skipped", "true");
+        mConfiguration.setConfigurationObject(Configuration.SKIP_MANAGER_TYPE_NAME, skipManager);
+        mSkipGetter.setConfiguration(mConfiguration);
+        mSkipGetter.setTestInformation(mTestInfo);
+        FeatureResponse response = mSkipGetter.execute(builder.build());
+        String skippedModules = null;
+        String delimiter = null;
+        String imageDigests = null;
+        String presubmit = null;
+        for (PartResponse partResponse : response.getMultiPartResponse().getResponsePartList()) {
+            if (partResponse.getKey().equals(SkipFeature.SKIPPED_MODULES)) {
+                skippedModules = partResponse.getValue();
+            } else if (partResponse.getKey().equals(SkipFeature.DELIMITER_NAME)) {
+                delimiter = partResponse.getValue();
+            } else if (partResponse.getKey().equals(SkipFeature.IMAGE_DIGESTS)) {
+                imageDigests = partResponse.getValue();
+            } else if (partResponse.getKey().equals(SkipFeature.PRESUBMIT)) {
+                presubmit = partResponse.getValue();
+            }
+        }
+        Truth.assertThat(delimiter).isEqualTo("\\+,");
+        Truth.assertThat(skippedModules).isEqualTo("module1+,module2");
+        Truth.assertThat(presubmit).isEqualTo("false");
+        Map<String, Digest> parsed = SkipFeature.parseDigests(delimiter, imageDigests);
+        Truth.assertThat(parsed).isEqualTo(image);
+    }
+}
diff --git a/javatests/com/android/tradefed/result/suite/XmlSuiteResultFormatterTest.java b/javatests/com/android/tradefed/result/suite/XmlSuiteResultFormatterTest.java
index 103df49f4..b475555ca 100644
--- a/javatests/com/android/tradefed/result/suite/XmlSuiteResultFormatterTest.java
+++ b/javatests/com/android/tradefed/result/suite/XmlSuiteResultFormatterTest.java
@@ -71,14 +71,7 @@ public class XmlSuiteResultFormatterTest {
 
     @Before
     public void setUp() throws Exception {
-        mFormatter =
-                new XmlSuiteResultFormatter() {
-                    @Override
-                    protected String sanitizeXmlContent(String s) {
-                        // Stub sanitize to avoid some versioning issues
-                        return s.replace("\0", "0");
-                    }
-                };
+        mFormatter = new XmlSuiteResultFormatter();
         mResultHolder = new SuiteResultHolder();
         mContext = new InvocationContext();
         mResultDir = FileUtil.createTempDir("result-dir");
diff --git a/javatests/com/android/tradefed/service/management/DeviceManagementGrpcServerTest.java b/javatests/com/android/tradefed/service/management/DeviceManagementGrpcServerTest.java
index 8ab7900c8..5aeda72fb 100644
--- a/javatests/com/android/tradefed/service/management/DeviceManagementGrpcServerTest.java
+++ b/javatests/com/android/tradefed/service/management/DeviceManagementGrpcServerTest.java
@@ -27,8 +27,8 @@ import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.device.DeviceAllocationState;
 import com.android.tradefed.device.FreeDeviceState;
 import com.android.tradefed.device.IDeviceManager;
-import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.IManagedTestDevice;
+import com.android.tradefed.device.ITestDevice;
 
 import com.proto.tradefed.device.DeviceStatus.ReservationStatus;
 import com.proto.tradefed.device.GetDevicesStatusRequest;
@@ -38,6 +38,10 @@ import com.proto.tradefed.device.ReleaseReservationResponse;
 import com.proto.tradefed.device.ReserveDeviceRequest;
 import com.proto.tradefed.device.ReserveDeviceResponse;
 
+import io.grpc.Server;
+import io.grpc.stub.ServerCallStreamObserver;
+import io.grpc.stub.StreamObserver;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -53,10 +57,6 @@ import org.mockito.junit.MockitoRule;
 import java.util.ArrayList;
 import java.util.List;
 
-import io.grpc.Server;
-import io.grpc.stub.ServerCallStreamObserver;
-import io.grpc.stub.StreamObserver;
-
 /** Unit tests for {@link DeviceManagementGrpcServer}. */
 @RunWith(JUnit4.class)
 public class DeviceManagementGrpcServerTest {
@@ -86,7 +86,7 @@ public class DeviceManagementGrpcServerTest {
         descriptors.add(createDescriptor("serial2", DeviceAllocationState.Allocated));
         descriptors.add(createDescriptor("serial3", DeviceAllocationState.Unavailable));
         descriptors.add(createDescriptor("serial4", DeviceAllocationState.Unknown));
-        when(mMockDeviceManager.listAllDevices(true)).thenReturn(descriptors);
+        when(mMockDeviceManager.listAllDevices(false)).thenReturn(descriptors);
 
         GetDevicesStatusRequest.Builder requestBuilder = GetDevicesStatusRequest.newBuilder();
         mServer.getDevicesStatus(requestBuilder.build(), mGetDevicesStatusObserver);
diff --git a/javatests/com/android/tradefed/suite/checker/baseline/CommandBaselineSetterTest.java b/javatests/com/android/tradefed/suite/checker/baseline/CommandBaselineSetterTest.java
index b8a3aa518..3afaac956 100644
--- a/javatests/com/android/tradefed/suite/checker/baseline/CommandBaselineSetterTest.java
+++ b/javatests/com/android/tradefed/suite/checker/baseline/CommandBaselineSetterTest.java
@@ -72,11 +72,4 @@ public final class CommandBaselineSetterTest {
                 .thenReturn(new CommandResult(CommandStatus.FAILED));
         assertFalse(mSetter.setBaseline(mMockDevice));
     }
-
-    /** Test that the setter returns false when the baseline is failed to set. */
-    @Test
-    public void setBaseline_nullResult_returnFalse() throws Exception {
-        when(mMockDevice.executeShellV2Command("input keyevent KEYCODE_HOME")).thenReturn(null);
-        assertFalse(mSetter.setBaseline(mMockDevice));
-    }
 }
diff --git a/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java b/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java
index 18e290837..52239ccd4 100644
--- a/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java
+++ b/javatests/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetterTest.java
@@ -21,11 +21,12 @@ import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
 
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -46,6 +47,7 @@ public final class LockSettingsBaselineSetterTest {
     private static final String GET_LOCK_SCREEN_COMMAND = "locksettings get-disabled";
     private static final String LOCK_SCREEN_OFF_COMMAND = "locksettings set-disabled true";
     private static final String CLEAR_PWD_COMMAND = "locksettings clear --old %s";
+    private static final String KEYCODE_MENU_COMMAND = "input keyevent KEYCODE_MENU";
 
     @Before
     public void setup() throws Exception {
@@ -66,29 +68,56 @@ public final class LockSettingsBaselineSetterTest {
     /** Test that the setter skips removing passwords when lock-screen is turned off. */
     @Test
     public void setBaseline_lockScreenOff_skipRemovingPasswords() throws Exception {
-        when(mMockDevice.executeShellCommand(GET_LOCK_SCREEN_COMMAND)).thenReturn("true");
+        when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         assertTrue(mSetter.setBaseline(mMockDevice));
-        verify(mMockDevice).executeShellCommand(GET_LOCK_SCREEN_COMMAND);
-        verify(mMockDevice, never()).executeShellCommand(LOCK_SCREEN_OFF_COMMAND);
-        verify(mMockDevice, never()).executeShellCommand(String.format(CLEAR_PWD_COMMAND, "0000"));
-        verify(mMockDevice, never()).executeShellCommand(String.format(CLEAR_PWD_COMMAND, "1234"));
+        verify(mMockDevice, never()).executeShellV2Command(LOCK_SCREEN_OFF_COMMAND);
+        verify(mMockDevice, never())
+                .executeShellV2Command(String.format(CLEAR_PWD_COMMAND, "0000"));
+        verify(mMockDevice, never())
+                .executeShellV2Command(String.format(CLEAR_PWD_COMMAND, "1234"));
     }
 
     /** Test that the setter removes passwords successfully. */
     @Test
     public void setBaseline_setSucceeds_passwordsRemoved() throws Exception {
-        when(mMockDevice.executeShellCommand(GET_LOCK_SCREEN_COMMAND)).thenReturn("false", "true");
+        when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
+                .thenReturn(
+                        getMockCommandResult(CommandStatus.SUCCESS, "false"),
+                        getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         assertTrue(mSetter.setBaseline(mMockDevice));
-        verify(mMockDevice, times(2)).executeShellCommand(GET_LOCK_SCREEN_COMMAND);
-        verify(mMockDevice).executeShellCommand(LOCK_SCREEN_OFF_COMMAND);
-        verify(mMockDevice).executeShellCommand(String.format(CLEAR_PWD_COMMAND, "0000"));
-        verify(mMockDevice).executeShellCommand(String.format(CLEAR_PWD_COMMAND, "1234"));
+        verify(mMockDevice).executeShellV2Command(LOCK_SCREEN_OFF_COMMAND);
+        verify(mMockDevice).executeShellV2Command(String.format(CLEAR_PWD_COMMAND, "0000"));
+        verify(mMockDevice).executeShellV2Command(String.format(CLEAR_PWD_COMMAND, "1234"));
     }
 
-    /** Test that the setter returns false when the baseline is failed to set. */
+    /** Test that the setter returns false when the baseline is failed to remove lock screen. */
     @Test
-    public void setBaseline_setFails_returnFalse() throws Exception {
-        when(mMockDevice.executeShellCommand(GET_LOCK_SCREEN_COMMAND)).thenReturn("false");
+    public void setBaseline_removeLockScreenFails_returnFalse() throws Exception {
+        when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "false"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, null));
         assertFalse(mSetter.setBaseline(mMockDevice));
     }
+
+    /** Test that the setter returns false when the baseline is failed to input KEYCODE_MENU. */
+    @Test
+    public void setBaseline_inputKeycodeMenuFails_returnFalse() throws Exception {
+        when(mMockDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.SUCCESS, "true"));
+        when(mMockDevice.executeShellV2Command(KEYCODE_MENU_COMMAND))
+                .thenReturn(getMockCommandResult(CommandStatus.FAILED, null));
+        assertFalse(mSetter.setBaseline(mMockDevice));
+    }
+
+    private CommandResult getMockCommandResult(CommandStatus status, String stdout) {
+        CommandResult mockResult = new CommandResult(status);
+        mockResult.setStdout(stdout);
+        return mockResult;
+    }
 }
diff --git a/javatests/com/android/tradefed/targetprep/DeviceSetupTest.java b/javatests/com/android/tradefed/targetprep/DeviceSetupTest.java
index 6f3293a0a..45d7c958d 100644
--- a/javatests/com/android/tradefed/targetprep/DeviceSetupTest.java
+++ b/javatests/com/android/tradefed/targetprep/DeviceSetupTest.java
@@ -1563,6 +1563,10 @@ public class DeviceSetupTest {
                 .thenReturn(successResult);
         when(mMockDevice.executeShellV2Command("dumpsys window displays | grep mCurrentFocus"))
                 .thenReturn(successResult);
+        when(mMockDevice.executeShellV2Command(
+                        "cmd package resolve-activity -c android.intent.category.HOME -a"
+                                + " android.intent.action.MAIN"))
+                .thenReturn(successResult);
     }
 
     /** Perform common EasyMock expect operations for a setUp call which syncs local data */
diff --git a/javatests/com/android/tradefed/targetprep/FeatureFlagTargetPreparerTest.java b/javatests/com/android/tradefed/targetprep/FeatureFlagTargetPreparerTest.java
index 7e2faac26..e3bdefd07 100644
--- a/javatests/com/android/tradefed/targetprep/FeatureFlagTargetPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/FeatureFlagTargetPreparerTest.java
@@ -15,19 +15,27 @@
  */
 package com.android.tradefed.targetprep;
 
+import static com.android.tradefed.testtype.suite.ITestSuite.BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY;
+import static com.android.tradefed.testtype.suite.ModuleDefinition.MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY;
+
 import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.startsWith;
+import static org.mockito.Mockito.argThat;
 import static org.mockito.Mockito.clearInvocations;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
+import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 
@@ -52,6 +60,8 @@ public class FeatureFlagTargetPreparerTest {
 
     @Mock private TestInformation mTestInfo;
     @Mock private ITestDevice mDevice;
+    @Mock private IInvocationContext mContext;
+    @Mock private IBuildInfo mBuildInfo;
 
     private static final String DEFAULT_CONFIG = "namespace/f=v\n";
     private FeatureFlagTargetPreparer mPreparer;
@@ -61,6 +71,10 @@ public class FeatureFlagTargetPreparerTest {
     public void setUp() throws Exception {
         mPreparer = new FeatureFlagTargetPreparer();
         when(mTestInfo.getDevice()).thenReturn(mDevice);
+        when(mTestInfo.getContext()).thenReturn(mContext);
+        when(mContext.getAttribute(ModuleDefinition.MODULE_NAME)).thenReturn(null);
+        when(mContext.getBuildInfo(eq(mDevice))).thenReturn(mBuildInfo);
+        doNothing().when(mBuildInfo).addBuildAttribute(anyString(), anyString());
         // Default to successful command execution.
         mCommandResult = new CommandResult(CommandStatus.SUCCESS);
         when(mDevice.executeShellV2Command(anyString())).thenReturn(mCommandResult);
@@ -80,6 +94,14 @@ public class FeatureFlagTargetPreparerTest {
         verify(mDevice).executeShellV2Command(eq("device_config put 'namespace' 'f1' 'v1'"));
         verify(mDevice).reboot();
         verifyNoMoreInteractions(mDevice);
+        verify(mBuildInfo)
+                .addBuildAttribute(
+                        eq(BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY),
+                        argThat(
+                                s ->
+                                        s.contains("namespace/f=v1")
+                                                && s.contains("namespace/f1=v1")));
+        verifyNoMoreInteractions(mBuildInfo);
 
         // Reverts to previous flags (revert f and delete f2) during tearDown and reboots.
         clearInvocations(mDevice);
@@ -101,6 +123,9 @@ public class FeatureFlagTargetPreparerTest {
         verify(mDevice).executeShellV2Command(eq("device_config put 'namespace' 'f' 'v'"));
         verify(mDevice).reboot();
         verifyNoMoreInteractions(mDevice);
+        verify(mBuildInfo)
+                .addBuildAttribute(eq(BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY), eq("namespace/f=v"));
+        verifyNoMoreInteractions(mBuildInfo);
 
         // Reverts to previous flags (revert f) during tearDown and reboots.
         clearInvocations(mDevice);
@@ -246,6 +271,14 @@ public class FeatureFlagTargetPreparerTest {
         verify(mDevice).executeShellV2Command(eq("device_config put 'namespace' 'f2' 'v3'"));
         verify(mDevice, times(1)).reboot();
         verifyNoMoreInteractions(mDevice);
+        verify(mBuildInfo)
+                .addBuildAttribute(
+                        eq(BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY),
+                        argThat(
+                                s ->
+                                        s.contains("namespace/f1=v2")
+                                                && s.contains("namespace/f2=v3")));
+        verifyNoMoreInteractions(mBuildInfo);
 
         // Reverts to previous flags during tearDown and reboots.
         clearInvocations(mDevice);
@@ -322,6 +355,27 @@ public class FeatureFlagTargetPreparerTest {
         verify(mDevice, never()).reboot();
     }
 
+    @Test
+    public void testSetUp_moduleNameExists_updatesInvocationAttribute() throws Exception {
+        // Set module name and context in invocation context.
+        when(mContext.getAttribute(ModuleDefinition.MODULE_NAME)).thenReturn("moduleName");
+        doNothing().when(mContext).addInvocationAttribute(anyString(), anyString());
+        // Set command to update the flag value from v1 to v2.
+        mCommandResult.setStdout("namespace/f1=v1\n");
+        new OptionSetter(mPreparer).setOptionValue("flag-value", "namespace/f1=v2");
+
+        // Run the setUp() method.
+        mPreparer.setUp(mTestInfo);
+
+        // Updated flag value should be stored in context.
+        verify(mContext, never()).getBuildInfo(eq(mDevice));
+        verify(mContext).getAttribute(eq(ModuleDefinition.MODULE_NAME));
+        verify(mContext)
+                .addInvocationAttribute(
+                        eq(MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY), eq("namespace/f1=v2"));
+        verifyNoMoreInteractions(mContext);
+    }
+
     private File addFlagFile(String content) throws Exception {
         File file = mTmpDir.newFile();
         Files.writeString(file.toPath(), content);
diff --git a/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java b/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java
index dc4717b5a..12957eea0 100644
--- a/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/GkiDeviceFlashPreparerTest.java
@@ -28,6 +28,7 @@ import static org.mockito.Mockito.when;
 import com.android.tradefed.build.DeviceBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.command.remote.DeviceDescriptor;
+import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.DeviceAllocationState;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
@@ -67,11 +68,14 @@ import java.util.stream.Stream;
 @RunWith(JUnit4.class)
 public class GkiDeviceFlashPreparerTest {
 
+    private static final String COMMAND_SUCCESS_STDERROR = "OKAY [  0.043s]";
+    private static final String COMMAND_FAILED_STDERROR = "FAILED (remote: 'Partition error')";
     private GkiDeviceFlashPreparer mPreparer;
     @Mock ITestDevice mMockDevice;
     private IDeviceBuildInfo mBuildInfo;
     private File mTmpDir;
     private TestInformation mTestInfo;
+    private OptionSetter mOptionSetter;
     private CommandResult mSuccessResult;
     private CommandResult mFailureResult;
     @Mock IRunUtil mMockRunUtil;
@@ -167,6 +171,7 @@ public class GkiDeviceFlashPreparerTest {
                         return systemDlkmStagingDir;
                     }
                 };
+        mOptionSetter = new OptionSetter(mPreparer);
         // Reset default settings
         mTmpDir = FileUtil.createTempDir("tmp");
         mBuildInfo = new DeviceBuildInfo("0", "");
@@ -176,10 +181,10 @@ public class GkiDeviceFlashPreparerTest {
         context.addDeviceBuildInfo("device", mBuildInfo);
         mTestInfo = TestInformation.newBuilder().setInvocationContext(context).build();
         mSuccessResult = new CommandResult(CommandStatus.SUCCESS);
-        mSuccessResult.setStderr("OKAY [  0.043s]");
+        mSuccessResult.setStderr(COMMAND_SUCCESS_STDERROR);
         mSuccessResult.setStdout("");
         mFailureResult = new CommandResult(CommandStatus.FAILED);
-        mFailureResult.setStderr("FAILED (remote: 'Partition error')");
+        mFailureResult.setStderr(COMMAND_FAILED_STDERROR);
         mFailureResult.setStdout("");
     }
 
@@ -397,6 +402,76 @@ public class GkiDeviceFlashPreparerTest {
         verify(mMockDevice).postBootSetup();
     }
 
+    /* Verifies that preparer can flash GKI boot image with fastboot flash options */
+    @Test
+    public void testSetup_Success_with_flash_options() throws Exception {
+        File bootImg = FileUtil.createTempFile("boot", ".img", mTmpDir);
+        bootImg.renameTo(new File(mTmpDir, "boot.img"));
+        FileUtil.writeToFile("ddd", bootImg);
+        mBuildInfo.setFile("gki_boot.img", bootImg, "0");
+        mOptionSetter.setOptionValue("fastboot-flash-option", "--disable-verity");
+
+        when(mMockDevice.executeLongFastbootCommand(
+                        "--disable-verity",
+                        "flash",
+                        "boot",
+                        mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
+                .thenReturn(mSuccessResult);
+        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
+
+        when(mMockDevice.enableAdbRoot()).thenReturn(Boolean.TRUE);
+
+        mPreparer.setUp(mTestInfo);
+        mPreparer.tearDown(mTestInfo, null);
+
+        verify(mMockDevice).rebootIntoBootloader();
+        verify(mMockRunUtil).allowInterrupt(false);
+        verify(mMockRunUtil).allowInterrupt(true);
+        verify(mMockRunUtil).sleep(anyLong());
+        verify(mMockDevice).rebootUntilOnline();
+        verify(mMockDevice).setDate(null);
+        verify(mMockDevice).waitForDeviceAvailable(anyLong());
+        verify(mMockDevice).setRecoveryMode(RecoveryMode.AVAILABLE);
+        verify(mMockDevice).postBootSetup();
+    }
+
+    /* Verifies that preparer can flash GKI boot image with disable-verity options */
+    @Test
+    public void testSetup_Success_with_disable_verity() throws Exception {
+        File bootImg = FileUtil.createTempFile("boot", ".img", mTmpDir);
+        bootImg.renameTo(new File(mTmpDir, "boot.img"));
+        FileUtil.writeToFile("ddd", bootImg);
+        mBuildInfo.setFile("gki_boot.img", bootImg, "0");
+        mOptionSetter.setOptionValue("disable-verity", "true");
+        mOptionSetter.setOptionValue("fastboot-flash-option", "--disable-verity");
+
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+        when(mMockDevice.executeAdbCommand("disable-verity")).thenReturn("disabled");
+        when(mMockDevice.executeLongFastbootCommand(
+                        "--disable-verity",
+                        "flash",
+                        "boot",
+                        mBuildInfo.getFile("gki_boot.img").getAbsolutePath()))
+                .thenReturn(mSuccessResult);
+        when(mMockDevice.executeLongFastbootCommand("-w")).thenReturn(mSuccessResult);
+
+        when(mMockDevice.enableAdbRoot()).thenReturn(Boolean.TRUE);
+
+        mPreparer.setUp(mTestInfo);
+        mPreparer.tearDown(mTestInfo, null);
+
+        verify(mMockDevice).reboot();
+        verify(mMockDevice).rebootIntoBootloader();
+        verify(mMockRunUtil).allowInterrupt(false);
+        verify(mMockRunUtil).allowInterrupt(true);
+        verify(mMockRunUtil).sleep(anyLong());
+        verify(mMockDevice).rebootUntilOnline();
+        verify(mMockDevice).setDate(null);
+        verify(mMockDevice).waitForDeviceAvailable(anyLong());
+        verify(mMockDevice).setRecoveryMode(RecoveryMode.AVAILABLE);
+        verify(mMockDevice).postBootSetup();
+    }
+
     /* Verifies that preparer can flash GKI boot image and vendor_boot,
      * vendor_kernel_boot, vendor_dlkm, and dtbo images */
     @Test
@@ -672,3 +747,4 @@ public class GkiDeviceFlashPreparerTest {
         }
     }
 }
+
diff --git a/javatests/com/android/tradefed/targetprep/InstallApexModuleTargetPreparerTest.java b/javatests/com/android/tradefed/targetprep/InstallApexModuleTargetPreparerTest.java
index 76a4943cd..914dc03bf 100644
--- a/javatests/com/android/tradefed/targetprep/InstallApexModuleTargetPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/InstallApexModuleTargetPreparerTest.java
@@ -697,7 +697,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.setUp(mTestInfo);
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifySuccessfulInstallPackages(Arrays.asList(mFakeApex2));
-        verify(mMockDevice, times(3)).getActiveApexes();
+        verify(mMockDevice, times(4)).getActiveApexes();
         verify(mMockDevice, atLeastOnce()).getActiveApexes();
         verify(mMockDevice, times(1)).getMainlineModuleInfo();
         verify(mMockDevice, times(1)).uninstallPackage(Mockito.any());
@@ -735,7 +735,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.setUp(mTestInfo);
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getMainlineModuleInfo();
         verify(mMockDevice, times(1)).uninstallPackage(Mockito.any());
     }
@@ -845,7 +845,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.setUp(mTestInfo);
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifySuccessfulInstallPackages(Arrays.asList(mFakeApex2));
-        verify(mMockDevice, times(3)).getActiveApexes();
+        verify(mMockDevice, times(4)).getActiveApexes();
         verify(mMockDevice, times(1)).getMainlineModuleInfo();
     }
 
@@ -1112,7 +1112,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(2)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
     }
 
     @Test
@@ -1138,7 +1138,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(2)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
     }
 
     @Test
@@ -1212,7 +1212,7 @@ public class InstallApexModuleTargetPreparerTest {
             verify(mMockDevice, times(1)).deleteFile(STAGING_DATA_DIR + "*");
             verify(mMockDevice, times(2)).reboot();
             verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
-            verify(mMockDevice, times(2)).getActiveApexes();
+            verify(mMockDevice, times(3)).getActiveApexes();
             verify(mMockDevice).waitForDeviceAvailable();
             assertTrue(!mInstallApexModuleTargetPreparer.getApkInstalled().isEmpty());
         } finally {
@@ -1240,7 +1240,7 @@ public class InstallApexModuleTargetPreparerTest {
         verifySuccessfulInstallPackages(Arrays.asList(mFakeApex));
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(2)).reboot();
-        verify(mMockDevice, times(3)).getActiveApexes();
+        verify(mMockDevice, times(4)).getActiveApexes();
     }
 
     @Test
@@ -1272,7 +1272,7 @@ public class InstallApexModuleTargetPreparerTest {
         verifyCleanInstalledApexPackages(1);
         verifySuccessfulInstallMultiPackages();
         verify(mMockDevice, times(2)).reboot();
-        verify(mMockDevice, times(3)).getActiveApexes();
+        verify(mMockDevice, times(4)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1298,7 +1298,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(2)).reboot();
-        verify(mMockDevice, times(3)).getActiveApexes();
+        verify(mMockDevice, times(4)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
         verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
     }
@@ -1324,7 +1324,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1358,7 +1358,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1393,7 +1393,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1442,7 +1442,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1502,7 +1502,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1564,7 +1564,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -1663,7 +1663,7 @@ public class InstallApexModuleTargetPreparerTest {
                             Mockito.any(IBuildInfo.class));
             verify(mMockDevice, times(2)).reboot();
             verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
-            verify(mMockDevice, times(3)).getActiveApexes();
+            verify(mMockDevice, times(4)).getActiveApexes();
             verify(mMockDevice, times(1)).waitForDeviceAvailable();
         } finally {
             FileUtil.deleteFile(mFakeApexApks);
@@ -1771,7 +1771,7 @@ public class InstallApexModuleTargetPreparerTest {
                             Mockito.any(IBuildInfo.class));
             verify(mMockDevice, times(2)).reboot();
             verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
-            verify(mMockDevice, times(3)).getActiveApexes();
+            verify(mMockDevice, times(4)).getActiveApexes();
             verify(mMockDevice, times(1)).waitForDeviceAvailable();
         } finally {
             FileUtil.deleteFile(mFakeApexApks);
@@ -1882,7 +1882,7 @@ public class InstallApexModuleTargetPreparerTest {
                             Mockito.any(IBuildInfo.class));
             verify(mMockDevice, times(2)).reboot();
             verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
-            verify(mMockDevice, times(3)).getActiveApexes();
+            verify(mMockDevice, times(4)).getActiveApexes();
             verify(mMockDevice, times(1)).waitForDeviceAvailable();
         } finally {
             FileUtil.deleteFile(mFakeApexApks);
@@ -1992,7 +1992,7 @@ public class InstallApexModuleTargetPreparerTest {
                             Mockito.any(IBuildInfo.class));
             verify(mMockDevice, times(2)).reboot();
             verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
-            verify(mMockDevice, times(3)).getActiveApexes();
+            verify(mMockDevice, times(4)).getActiveApexes();
             verify(mMockDevice, times(1)).waitForDeviceAvailable();
         } finally {
             FileUtil.recursiveDelete(trainFolder);
@@ -2102,7 +2102,7 @@ public class InstallApexModuleTargetPreparerTest {
                             Mockito.any(IBuildInfo.class));
             verify(mMockDevice, times(2)).reboot();
             verify(mMockDevice, times(1)).executeAdbCommand(trainInstallCmd.toArray(new String[0]));
-            verify(mMockDevice, times(3)).getActiveApexes();
+            verify(mMockDevice, times(4)).getActiveApexes();
             verify(mMockDevice, times(1)).waitForDeviceAvailable();
         } finally {
             FileUtil.deleteFile(mFakeApexApks);
@@ -2177,7 +2177,6 @@ public class InstallApexModuleTargetPreparerTest {
             order.verify(mMockDevice, times(1)).deleteFile(STAGING_DATA_DIR + "*");
             order.verify(mMockDevice, times(1)).deleteFile(SESSION_DATA_DIR + "*");
             order.verify(mMockDevice, times(1)).reboot();
-            order.verify(mMockDevice, times(2)).getActiveApexes();
             order.verify(mMockBundletoolUtil, times(1))
                     .generateDeviceSpecFile(Mockito.any(ITestDevice.class));
             // Extract splits 1 time to get the package name for the module, does not attempt to
@@ -2198,6 +2197,7 @@ public class InstallApexModuleTargetPreparerTest {
                             Mockito.any(IBuildInfo.class));
             order.verify(mMockBundletoolUtil, times(1))
                     .installApks(eq(mFakeApkApks), eq(mMockDevice), eq(new ArrayList<String>()));
+            verify(mMockDevice, atLeastOnce()).getActiveApexes();
         } finally {
             FileUtil.deleteFile(mFakeApexApks);
             FileUtil.deleteFile(mFakeApkApks);
@@ -2368,7 +2368,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifyCleanInstalledApexPackages(1);
         verify(mMockDevice, times(1)).reboot();
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
     }
 
     @Test
@@ -2391,7 +2391,7 @@ public class InstallApexModuleTargetPreparerTest {
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
         verifySuccessfulInstallMultiPackages();
         verify(mMockDevice, times(2)).reboot();
-        verify(mMockDevice, times(3)).getActiveApexes();
+        verify(mMockDevice, times(4)).getActiveApexes();
         verify(mMockDevice, times(1)).getInstalledPackageNames();
     }
 
@@ -2459,7 +2459,7 @@ public class InstallApexModuleTargetPreparerTest {
 
         mInstallApexModuleTargetPreparer.setUp(mTestInfo);
         mInstallApexModuleTargetPreparer.tearDown(mTestInfo, null);
-        verify(mMockDevice, times(2)).getActiveApexes();
+        verify(mMockDevice, times(3)).getActiveApexes();
         verify(mMockDevice, times(1)).deleteFile(APEX_DATA_DIR + "*");
         verify(mMockDevice, times(1)).deleteFile(SESSION_DATA_DIR + "*");
         verify(mMockDevice, times(1)).deleteFile(STAGING_DATA_DIR + "*");
@@ -2526,7 +2526,7 @@ public class InstallApexModuleTargetPreparerTest {
             Mockito.verify(mMockBundletoolUtil, times(1))
                     .installApksFromZip(mFakeApkZip, mMockDevice, expectedArgs);
             verify(mMockDevice, times(2)).reboot();
-            verify(mMockDevice, times(1)).getActiveApexes();
+            verify(mMockDevice, times(2)).getActiveApexes();
             verify(mMockDevice, times(1)).waitForDeviceAvailable();
         } finally {
             FileUtil.deleteFile(mBundletoolJar);
diff --git a/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java b/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java
new file mode 100644
index 000000000..2c76fda56
--- /dev/null
+++ b/javatests/com/android/tradefed/targetprep/InstallKernelModulePreparerTest.java
@@ -0,0 +1,273 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.targetprep;
+
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.matches;
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.command.remote.DeviceDescriptor;
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.device.DeviceAllocationState;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.TestDeviceOptions;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+/** Unit tests for {@link InstallKernelModulePreparer} */
+@RunWith(JUnit4.class)
+public class InstallKernelModulePreparerTest {
+
+    private static final String SERIAL = "SERIAL";
+    private static final String KUNIT_MODULE = "/data/kunit/kunit.ko";
+    private static final String KUNIT_MODULE_INSTALLATION_COMMAND =
+            String.format("insmod %s enable=1", KUNIT_MODULE);
+    private static final String KUNIT_MODULE_REMOVAL_COMMAND = "rmmod kunit";
+    private static final String LIST_MODULE_COMMAND = "lsmod";
+    private static final String NO_PREEXISTING_MODULE_OUTPUT =
+            "Module Size  Used by\n" + "sec_touch             663552  0";
+    private static final String PREEXISTING_MODULE_OUTPUT =
+            "Module Size  Used by\n"
+                    + "sec_touch             663552  0"
+                    + "kunit                  57344  0";
+
+    private InstallKernelModulePreparer mPreparer;
+    private TestInformation mTestInfo;
+    private OptionSetter mOptionSetter;
+    @Mock ITestDevice mMockDevice;
+    private DeviceDescriptor mDeviceDescriptor;
+    private final CommandResult mSuccessResult;
+    private final CommandResult mFailedResult;
+
+    public InstallKernelModulePreparerTest() {
+        mSuccessResult = new CommandResult(CommandStatus.SUCCESS);
+        mSuccessResult.setStdout("ffffffffffff\n");
+        mSuccessResult.setExitCode(0);
+
+        mFailedResult = new CommandResult(CommandStatus.FAILED);
+        mFailedResult.setStdout("");
+        mFailedResult.setExitCode(-1);
+        mFailedResult.setStderr("error");
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mDeviceDescriptor =
+                new DeviceDescriptor(
+                        "serial_1",
+                        false,
+                        DeviceAllocationState.Available,
+                        "unknown",
+                        "unknown",
+                        "unknown",
+                        "unknown",
+                        "unknown");
+
+        InvocationContext context = new InvocationContext();
+        context.addAllocatedDevice("device", mMockDevice);
+
+        mTestInfo = TestInformation.newBuilder().setInvocationContext(context).build();
+
+        mPreparer = new InstallKernelModulePreparer();
+        mOptionSetter = new OptionSetter(mPreparer);
+        mOptionSetter.setOptionValue("module-path", KUNIT_MODULE);
+        when(mMockDevice.getSerialNumber()).thenReturn(SERIAL);
+        when(mMockDevice.getDeviceDescriptor()).thenReturn(mDeviceDescriptor);
+        when(mMockDevice.getOptions()).thenReturn(new TestDeviceOptions());
+    }
+
+    /**
+     * Test {@link InstallKernelModulePreparer#setUp()} by successfully installing a kernel module
+     * file
+     */
+    @Test
+    public void testSetup()
+            throws DeviceNotAvailableException,
+                    BuildError,
+                    TargetSetupError,
+                    ConfigurationException {
+        mOptionSetter.setOptionValue("install-arg", "enable=1");
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(NO_PREEXISTING_MODULE_OUTPUT);
+        when(mMockDevice.executeShellV2Command(matches(KUNIT_MODULE_REMOVAL_COMMAND)))
+                .thenReturn(mFailedResult);
+        when(mMockDevice.executeShellV2Command(
+                        matches(KUNIT_MODULE_INSTALLATION_COMMAND), anyLong(), any()))
+                .thenReturn(mSuccessResult);
+        mPreparer.setUp(mTestInfo);
+    }
+
+    /**
+     * Test {@link InstallKernelModulePreparer#setUp()} by successfully installing a kernel module
+     * file with the module already loaded on the device
+     */
+    @Test
+    public void testSetupWithPreExistingDependentModule()
+            throws DeviceNotAvailableException,
+                    BuildError,
+                    TargetSetupError,
+                    ConfigurationException {
+        String output =
+                "Module Size  Used b\n"
+                        + "kunit_test             663552  0\n"
+                        + "time_test             663558  0\n"
+                        + "kunit                  57344  15 kunit_test,time_test\n";
+        mOptionSetter.setOptionValue("install-arg", "enable=1");
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(output)
+                .thenReturn(output)
+                .thenReturn(output);
+        when(mMockDevice.executeShellV2Command(
+                        matches(KUNIT_MODULE_INSTALLATION_COMMAND), anyLong(), any()))
+                .thenReturn(mSuccessResult)
+                .thenReturn(mSuccessResult)
+                .thenReturn(mSuccessResult);
+        mPreparer.setUp(mTestInfo);
+        InOrder inOrder = Mockito.inOrder(mMockDevice);
+        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit_test"));
+        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod time_test"));
+        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit"));
+    }
+
+    /** Test {@link InstallKernelModulePreparer#setUp()} by successfully installing 1 ko file */
+    @Test
+    public void testSetupWithDifferentArgs()
+            throws DeviceNotAvailableException,
+                    BuildError,
+                    TargetSetupError,
+                    ConfigurationException {
+        mOptionSetter.setOptionValue("install-arg", "enable=0");
+        mOptionSetter.setOptionValue("install-arg", "stats_enabled=0");
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(NO_PREEXISTING_MODULE_OUTPUT);
+        when(mMockDevice.executeShellV2Command(matches(KUNIT_MODULE_REMOVAL_COMMAND)))
+                .thenReturn(mFailedResult);
+        when(mMockDevice.executeShellV2Command(
+                        matches(String.format("insmod %s enable=0 stats_enabled=0", KUNIT_MODULE)),
+                        anyLong(),
+                        any()))
+                .thenReturn(mSuccessResult);
+        mPreparer.setUp(mTestInfo);
+    }
+
+    /** Test {@link InstallKernelModulePreparer#setUp()} by successfully installing 2 modules */
+    @Test
+    public void testSetupWithTwoModules()
+            throws DeviceNotAvailableException,
+                    BuildError,
+                    TargetSetupError,
+                    ConfigurationException {
+        mOptionSetter.setOptionValue("install-arg", "enable=1");
+        mOptionSetter.setOptionValue("module-path", "/data/kunit/kunit-test.ko");
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(NO_PREEXISTING_MODULE_OUTPUT);
+        when(mMockDevice.executeShellV2Command(matches(KUNIT_MODULE_REMOVAL_COMMAND)))
+                .thenReturn(mFailedResult);
+        when(mMockDevice.executeShellV2Command(
+                        matches(KUNIT_MODULE_INSTALLATION_COMMAND), anyLong(), any()))
+                .thenReturn(mSuccessResult);
+        when(mMockDevice.executeShellCommand(matches("rmmod kunit_test"))).thenReturn("");
+        when(mMockDevice.executeShellV2Command(
+                        matches("insmod /data/kunit/kunit-test.ko enable=1"), anyLong(), any()))
+                .thenReturn(mSuccessResult);
+        mPreparer.setUp(mTestInfo);
+    }
+
+    /**
+     * Test {@link InstallKernelModulePreparer#setUp()} by having module installation failure and
+     * throwing an exception
+     */
+    @Test
+    public void testInstallFailureThrow()
+            throws DeviceNotAvailableException, BuildError, ConfigurationException {
+        mOptionSetter.setOptionValue("install-arg", "enable=1");
+        when(mMockDevice.isAdbRoot()).thenReturn(true);
+
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(NO_PREEXISTING_MODULE_OUTPUT);
+        when(mMockDevice.executeShellV2Command(matches(KUNIT_MODULE_REMOVAL_COMMAND)))
+                .thenReturn(mFailedResult);
+        when(mMockDevice.executeShellV2Command(matches(KUNIT_MODULE_INSTALLATION_COMMAND)))
+                .thenReturn(mFailedResult);
+
+        try {
+            mPreparer.setUp(mTestInfo);
+            fail("should have failed due to installation failure");
+        } catch (TargetSetupError expected) {
+            // expected
+        }
+    }
+
+    /**
+     * Test {@link InstallKernelModulePreparer#tearDown()} by successfully uninstall kernel module
+     */
+    @Test
+    public void testTearDown()
+            throws DeviceNotAvailableException,
+                    BuildError,
+                    TargetSetupError,
+                    ConfigurationException {
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(PREEXISTING_MODULE_OUTPUT);
+        when(mMockDevice.executeShellCommand(matches("rmmod kunit"))).thenReturn("");
+        mPreparer.tearDown(mTestInfo, null);
+    }
+
+    /**
+     * Test {@link InstallKernelModulePreparer#tearDown()} by successfully uninstall 2 kernel
+     * modules
+     */
+    @Test
+    public void testTearDownTwoModules()
+            throws DeviceNotAvailableException,
+                    BuildError,
+                    TargetSetupError,
+                    ConfigurationException {
+        mOptionSetter.setOptionValue("module-path", "/data/kunit/kunit_test.ko");
+        when(mMockDevice.executeShellCommand(matches(LIST_MODULE_COMMAND)))
+                .thenReturn(NO_PREEXISTING_MODULE_OUTPUT);
+        when(mMockDevice.executeShellCommand(matches("rmmod kunit_test"))).thenReturn("");
+        when(mMockDevice.executeShellCommand(matches("rmmod kunit"))).thenReturn("");
+        mPreparer.tearDown(mTestInfo, null);
+        InOrder inOrder = Mockito.inOrder(mMockDevice);
+        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit_test"));
+        inOrder.verify(mMockDevice).executeShellCommand(matches("rmmod kunit"));
+    }
+}
diff --git a/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java b/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
new file mode 100644
index 000000000..75e2f23c1
--- /dev/null
+++ b/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.targetprep;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
+import com.android.tradefed.build.DeviceBuildInfo;
+import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.targetprep.IDeviceFlasher.UserDataFlashOption;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.IRunUtil;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import java.io.File;
+
+@RunWith(JUnit4.class)
+public class OtaUpdateDeviceFlasherTest {
+    private OtaUpdateDeviceFlasher mFlasher = null;
+    @Mock private ITestDevice mMockDevice;
+    @Mock private IRunUtil mMockRunUtil;
+    private InOrder mInOrder;
+
+    @Rule public TemporaryFolder mTempFolder = new TemporaryFolder();
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        mInOrder = inOrder(mMockDevice, mMockRunUtil);
+        mFlasher =
+                new OtaUpdateDeviceFlasher() {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+    }
+
+    @Test
+    public void testUserDataWipeOptions_wipe() throws Exception {
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.TESTS_ZIP);
+        assertEquals(
+                "Any userdata option that's not retain should be reset to wipe",
+                UserDataFlashOption.WIPE,
+                mFlasher.getUserDataFlashOption());
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.WIPE_RM);
+        assertEquals(
+                "Any userdata option that's not retain should be reset to wipe",
+                UserDataFlashOption.WIPE,
+                mFlasher.getUserDataFlashOption());
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.WIPE);
+        assertEquals(
+                "Any userdata option that's not retain should be reset to wipe",
+                UserDataFlashOption.WIPE,
+                mFlasher.getUserDataFlashOption());
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.FLASH);
+        assertEquals(
+                "Any userdata option that's not retain should be reset to wipe",
+                UserDataFlashOption.WIPE,
+                mFlasher.getUserDataFlashOption());
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.FLASH_IMG_ZIP);
+        assertEquals(
+                "Any userdata option that's not retain should be reset to wipe",
+                UserDataFlashOption.WIPE,
+                mFlasher.getUserDataFlashOption());
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.FORCE_WIPE);
+        assertEquals(
+                "Any userdata option that's not retain should be reset to wipe",
+                UserDataFlashOption.WIPE,
+                mFlasher.getUserDataFlashOption());
+    }
+
+    @Test
+    public void testUserDataWipeOptions_retain() throws Exception {
+        mFlasher.setUserDataFlashOption(UserDataFlashOption.RETAIN);
+        assertEquals(
+                "RETAIN userdata option should not be changed",
+                UserDataFlashOption.RETAIN,
+                mFlasher.getUserDataFlashOption());
+    }
+
+    @Test(expected = TargetSetupError.class)
+    public void testUpdateScriptNotSet() throws Exception {
+        DeviceBuildInfo dbi = new DeviceBuildInfo();
+        mFlasher.preFlashOperations(mMockDevice, dbi);
+        fail("Device build info without update-device-script set should cause an exception");
+    }
+
+    @Test(expected = TargetSetupError.class)
+    public void testInvalidUpdateScriptSet() throws Exception {
+        DeviceBuildInfo dbi = new DeviceBuildInfo();
+        File tmpFolder = mTempFolder.getRoot();
+        dbi.setFile(
+                OtaUpdateDeviceFlasher.UPDATE_DEVICE_SCRIPT, new File(tmpFolder, "foo-bar"), "0");
+        mFlasher.preFlashOperations(mMockDevice, dbi);
+    }
+
+    @Test(expected = TargetSetupError.class)
+    public void testOtaPackageNotSet() throws Exception {
+        DeviceBuildInfo dbi = new DeviceBuildInfo();
+        File fakeScript =
+                new File(mTempFolder.getRoot(), OtaUpdateDeviceFlasher.IN_ZIP_SCRIPT_PATH);
+        assertTrue(
+                "Failed to create temp parent folder for fake script for test",
+                fakeScript.getParentFile().mkdirs());
+        assertTrue("Failed to create fake script for test", fakeScript.createNewFile());
+        dbi.setFile(OtaUpdateDeviceFlasher.UPDATE_DEVICE_SCRIPT, mTempFolder.getRoot(), "0");
+        mFlasher.preFlashOperations(mMockDevice, dbi);
+    }
+
+    private IDeviceBuildInfo setupDeviceBuildInfoForOta() throws Exception {
+        IDeviceBuildInfo dbi = new DeviceBuildInfo();
+        File fakeScript =
+                new File(mTempFolder.getRoot(), OtaUpdateDeviceFlasher.IN_ZIP_SCRIPT_PATH);
+        assertTrue(
+                "Failed to create temp parent folder for fake script for test",
+                fakeScript.getParentFile().mkdirs());
+        assertTrue("Failed to create fake script for test", fakeScript.createNewFile());
+        dbi.setFile(OtaUpdateDeviceFlasher.UPDATE_DEVICE_SCRIPT, mTempFolder.getRoot(), "0");
+        dbi.setFile(BuildInfoFileKey.OTA_IMAGE, mTempFolder.newFile(), "0");
+        return dbi;
+    }
+
+    @Test
+    public void testPreFlashOperations() throws Exception {
+        mFlasher.preFlashOperations(mMockDevice, setupDeviceBuildInfoForOta());
+    }
+
+    @Test
+    public void testFlash() throws Exception {
+        // prep
+        when(mMockDevice.enableAdbRoot()).thenReturn(true);
+        when(mMockDevice.setProperty(
+                        Mockito.eq(OtaUpdateDeviceFlasher.OTA_DOWNGRADE_PROP), Mockito.eq("1")))
+                .thenReturn(true);
+        CommandResult cr = new CommandResult();
+        cr.setStatus(CommandStatus.SUCCESS);
+        when(mMockRunUtil.runTimedCmd(Mockito.any(long.class), Mockito.any())).thenReturn(cr);
+        doNothing().when(mMockDevice).rebootUntilOnline();
+        // test
+        IDeviceBuildInfo dbi = setupDeviceBuildInfoForOta();
+        mFlasher.preFlashOperations(mMockDevice, dbi);
+        mFlasher.flash(mMockDevice, dbi);
+        // verify
+        mInOrder.verify(mMockDevice).enableAdbRoot();
+        mInOrder.verify(mMockDevice)
+                .setProperty(
+                        Mockito.eq(OtaUpdateDeviceFlasher.OTA_DOWNGRADE_PROP), Mockito.eq("1"));
+        mInOrder.verify(mMockRunUtil).runTimedCmd(Mockito.any(long.class), Mockito.any());
+        mInOrder.verify(mMockDevice).rebootUntilOnline();
+    }
+}
diff --git a/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java b/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
index 62fe328a3..b8cdb2681 100644
--- a/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
+++ b/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
@@ -110,6 +110,8 @@ public class IncrementalImageFuncTest extends BaseHostJUnit4Test {
                         getBuild().getFile("target-image"),
                         getBuild().getFile("create_snapshot.zip"),
                         mApplySnapshot,
+                        false,
+                        false,
                         SnapuserdWaitPhase.BLOCK_AFTER_UPDATE);
         try {
             updateUtil.updateDevice(null, null);
diff --git a/javatests/com/android/tradefed/testtype/HostGTestTest.java b/javatests/com/android/tradefed/testtype/HostGTestTest.java
index f530bcaff..51d82646a 100644
--- a/javatests/com/android/tradefed/testtype/HostGTestTest.java
+++ b/javatests/com/android/tradefed/testtype/HostGTestTest.java
@@ -25,7 +25,11 @@ import static org.mockito.Mockito.when;
 
 import com.android.tradefed.build.BuildInfoKey;
 import com.android.tradefed.build.DeviceBuildInfo;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.invoker.TestInformation;
@@ -34,6 +38,7 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FakeShellOutputReceiver;
 import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.RunUtilTest;
 
 import org.junit.After;
 import org.junit.Before;
@@ -57,6 +62,7 @@ public class HostGTestTest {
     private ITestInvocationListener mMockInvocationListener;
     private FakeShellOutputReceiver mFakeReceiver;
     private OptionSetter mSetter;
+    private RunUtilTest.FakeCacheClient mFakeCacheClient;
 
     /** Helper to initialize the object or folder for unittest need. */
     @Before
@@ -73,11 +79,19 @@ public class HostGTestTest {
         mSetter = new OptionSetter(mHostGTest);
 
         mTestInfo = TestInformation.newBuilder().build();
+
+        mFakeCacheClient = new RunUtilTest.FakeCacheClient();
     }
 
     @After
     public void afterMethod() {
         FileUtil.recursiveDelete(mTestsDir);
+        mFakeCacheClient.getAllCache().values().stream()
+                .forEach(
+                        a -> {
+                            FileUtil.deleteFile(a.stdOut());
+                            FileUtil.deleteFile(a.stdErr());
+                        });
     }
 
     /**
@@ -205,6 +219,66 @@ public class HostGTestTest {
         assertNotEquals(0, mFakeReceiver.getReceivedOutput().length);
     }
 
+    @Test
+    public void testRun_upload_cache_for_success_run() throws Exception {
+        HostGTest hostGTest =
+                createHostGTestWithCache(
+                        "echo \"[==========] Running 1 tests from 1 test suites.\n"
+                                + "[----------] Global test environment set-up.\n"
+                                + "[----------] 1 tests from HelloWorldTest\n"
+                                + "[ RUN      ] HelloWorldTest.Hello \n"
+                                + "[       OK ] HelloWorldTest.Hello (100 ms)\n"
+                                + "[----------] 1 tests from HelloWorldTest (100 ms total)\n"
+                                + "[----------] Global test environment tear-down\n"
+                                + "[==========] 1 tests from 1 test suites ran. (100 ms total)\n"
+                                + "[  PASSED  ] 1 tests.\n"
+                                + "\"");
+
+        hostGTest.run(mTestInfo, mMockInvocationListener);
+
+        assertFalse(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
+    @Test
+    public void testRun_skip_cache_upload_for_timeout_run() throws Exception {
+        HostGTest hostGTest =
+                createHostGTestWithCache(
+                        "echo \"[==========] Running 1 tests from 1 test suites.\n"
+                                + "[----------] Global test environment set-up.\n"
+                                + "[----------] 1 tests from HelloWorldTest\n"
+                                + "[ RUN      ] HelloWorldTest.Hello \n"
+                                + "[       OK ] HelloWorldTest.Hello (10000 ms)\n"
+                                + "[----------] 1 tests from HelloWorldTest (10000 ms total)\n"
+                                + "[----------] Global test environment tear-down\n"
+                                + "[==========] 1 tests from 1 test suites ran. (10000 ms total)\n"
+                                + "[  PASSED  ] 1 tests.\n"
+                                + "\"");
+
+        hostGTest.run(mTestInfo, mMockInvocationListener);
+
+        assertTrue(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
+    @Test
+    public void testRun_skip_cache_upload_for_failed_run() throws Exception {
+        HostGTest hostGTest =
+                createHostGTestWithCache(
+                        "echo \"[==========] Running 1 tests from 1 test suites.\n"
+                                + "[----------] Global test environment set-up.\n"
+                                + "[----------] 1 tests from HelloWorldTest\n"
+                                + "[ RUN      ] HelloWorldTest.Hello \n"
+                                + "[  FAILED  ] HelloWorldTest.Hello (100 ms)\n"
+                                + "[----------] 1 tests from HelloWorldTest (100 ms total)\n"
+                                + "[----------] Global test environment tear-down\n"
+                                + "[==========] 1 tests from 1 test suites ran. (100 ms total)\n"
+                                + "[  FAILED  ] 1 tests.\n"
+                                + "\"");
+
+        hostGTest.run(mTestInfo, mMockInvocationListener);
+
+        assertTrue(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
     /** Test the run method for host linked folder is set. */
     @Test
     public void testRun_priority_get_testcase_from_hostlinked_folder()
@@ -396,4 +470,32 @@ public class HostGTestTest {
 
         assertNotEquals(0, mFakeReceiver.getReceivedOutput().length);
     }
+
+    private HostGTest createHostGTestWithCache(String scriptContent) throws Exception {
+        HostGTest hostGTest =
+                new HostGTest() {
+                    @Override
+                    ICacheClient getCacheClient(File workFolder, String instanceName) {
+                        return mFakeCacheClient;
+                    }
+                };
+        OptionSetter testSetter = new OptionSetter(hostGTest);
+        String moduleName = "hello_world_test";
+        testSetter.setOptionValue("module-name", moduleName);
+        testSetter.setOptionValue("enable-cache", "true");
+        testSetter.setOptionValue("test-case-timeout", "1s");
+        File hostLinkedFolder = createSubFolder("hosttestcases");
+        createExecutableFile(
+                Paths.get(hostLinkedFolder.getAbsolutePath(), moduleName), scriptContent);
+        DeviceBuildInfo buildInfo = new DeviceBuildInfo();
+        buildInfo.setFile(BuildInfoKey.BuildInfoFileKey.HOST_LINKED_DIR, hostLinkedFolder, "0.0");
+        hostGTest.setBuild(buildInfo);
+        CommandOptions commandOptions = new CommandOptions();
+        OptionSetter commandOptionsSetter = new OptionSetter(commandOptions);
+        commandOptionsSetter.setOptionValue("remote-cache-instance-name", "test_instance");
+        IConfiguration config = new Configuration("config", "Test config");
+        config.setCommandOptions(commandOptions);
+        hostGTest.setConfiguration(config);
+        return hostGTest;
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java b/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java
index ee6c70c1a..4acd606fe 100644
--- a/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java
+++ b/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java
@@ -39,7 +39,6 @@ import static org.mockito.Mockito.when;
 
 import com.android.ddmlib.IDevice;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
@@ -59,6 +58,7 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.ITestLifeCycleReceiver;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.result.skipped.SkipReason;
diff --git a/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java b/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java
index dbd73901c..77ab61c1c 100644
--- a/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java
@@ -24,6 +24,8 @@ import static org.mockito.Mockito.verify;
 
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.command.CommandOptions;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
@@ -37,6 +39,7 @@ import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.testtype.coverage.CoverageOptions;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.ResourceUtil;
+import com.android.tradefed.util.RunUtilTest;
 
 import org.junit.After;
 import org.junit.Before;
@@ -65,6 +68,8 @@ public class IsolatedHostTestTest {
     private IBuildInfo mMockBuildInfo;
     private ServerSocket mMockServer;
     private File mMockTestDir;
+    private File mWorkFolder;
+    private final ICacheClient mFakeCacheClient = new RunUtilTest.FakeCacheClient();
 
     /**
      * (copied and altered from JarHostTestTest) Helper to read a file from the res/testtype
@@ -76,7 +81,11 @@ public class IsolatedHostTestTest {
      * @return the extracted jar file.
      */
     protected File getJarResource(String filename, File parentDir, String name) throws IOException {
-        File jarFile = FileUtil.createTempFile("tradefed-isolation", ".jar", parentDir);
+        File jarFile = new File(parentDir, name);
+        if (jarFile.exists()) {
+            FileUtil.deleteFile(jarFile);
+        }
+        jarFile.createNewFile();
         boolean res =
                 ResourceUtil.extractResourceWithAltAsFile(filename, PACKAGE + filename, jarFile);
         if (!res) {
@@ -110,12 +119,14 @@ public class IsolatedHostTestTest {
         context.addDeviceBuildInfo("device", mMockBuildInfo);
         mHostTest.setBuild(mMockBuildInfo);
         mHostTest.setServer(mMockServer);
-        mMockTestDir = FileUtil.createTempDir("isolatedhosttesttest");
+        mWorkFolder = FileUtil.createTempDir("workfolder");
+        mMockTestDir = FileUtil.createTempDir("isolatedhosttesttest", mWorkFolder);
+        mHostTest.setWorkDir(mMockTestDir);
     }
 
     @After
     public void tearDown() throws Exception {
-        FileUtil.recursiveDelete(mMockTestDir);
+        FileUtil.recursiveDelete(mWorkFolder);
         mHostTest.deleteTempFiles();
     }
 
@@ -132,7 +143,7 @@ public class IsolatedHostTestTest {
         List<String> commandArgs = mHostTest.compileCommandArgs("", null);
         assertTrue(commandArgs.contains("-Drobolectric.offline=true"));
         assertTrue(commandArgs.contains("-Drobolectric.logging=stdout"));
-        assertTrue(commandArgs.contains("-Drobolectric.resourcesMode=binary"));
+        assertTrue(commandArgs.contains("-Drobolectric.resourcesMode=BINARY"));
         assertTrue(
                 commandArgs.stream()
                         .anyMatch(
@@ -162,8 +173,9 @@ public class IsolatedHostTestTest {
         doReturn(Inet4Address.getByName("localhost")).when(mMockServer).getInetAddress();
         assertTrue(mHostTest.compileClassPath().contains("ravenwood-runtime"));
 
-        String expectedLdLibraryPath = String.join(java.io.File.pathSeparator, ldLibraryPath);
-        assertEquals(expectedLdLibraryPath, mHostTest.compileLdLibraryPathInner(null));
+        assertEquals(
+                "ravenwood-runtime/lib:ravenwood-runtime/lib64",
+                mHostTest.compileLdLibraryPathInner(null));
 
         List<String> commandArgs = mHostTest.compileCommandArgs("", null);
         assertTrue(commandArgs.contains("-Dandroid.junit.runner=org.junit.runners.JUnit4"));
@@ -191,7 +203,7 @@ public class IsolatedHostTestTest {
         List<String> commandArgs = mHostTest.compileCommandArgs("", null);
         assertFalse(commandArgs.contains("-Drobolectric.offline=true"));
         assertFalse(commandArgs.contains("-Drobolectric.logging=stdout"));
-        assertFalse(commandArgs.contains("-Drobolectric.resourcesMode=binary"));
+        assertFalse(commandArgs.contains("-Drobolectric.resourcesMode=BINARY"));
         assertFalse(
                 commandArgs.stream().anyMatch(s -> s.contains("-Drobolectric.dependency.dir=")));
     }
@@ -289,6 +301,69 @@ public class IsolatedHostTestTest {
         verify(mListener).testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
     }
 
+    @Test
+    public void testCacheWorks() throws Exception {
+        final String jarName = "SimplePassingTest.jar";
+        final String className = "com.android.tradefed.referencetests.SimplePassingTest";
+        InvocationContext context = new InvocationContext();
+        TestInformation testInfo =
+                TestInformation.newBuilder().setInvocationContext(context).build();
+        TestDescription test = new TestDescription(className, "test2Plus2");
+        ITestInvocationListener firstListener = Mockito.mock(ITestInvocationListener.class);
+        ITestInvocationListener secondListener = Mockito.mock(ITestInvocationListener.class);
+        File testDir1 = FileUtil.createTempDir("isolatedhosttesttest", mWorkFolder);
+        IsolatedHostTest runner1 = createTestRunnerForCaching(testDir1);
+        OptionSetter setter = new OptionSetter(runner1);
+        File jar1 = getJarResource("/" + jarName, testDir1, jarName);
+        setter.setOptionValue("jar", jar1.getName());
+        setter.setOptionValue("exclude-paths", "org/junit");
+        setter.setOptionValue("exclude-paths", "junit");
+        File testDir2 = FileUtil.createTempDir("isolatedhosttesttest", mWorkFolder);
+        IsolatedHostTest runner2 = createTestRunnerForCaching(testDir2);
+        setter = new OptionSetter(runner2);
+        File jar2 = getJarResource("/" + jarName, testDir2, jarName);
+        setter.setOptionValue("jar", jar2.getName());
+        // Test that the different order of option values won't affect caching.
+        setter.setOptionValue("exclude-paths", "junit");
+        setter.setOptionValue("exclude-paths", "org/junit");
+
+        doReturn(testDir1).when(mMockBuildInfo).getFile(BuildInfoFileKey.HOST_LINKED_DIR);
+        doReturn(testDir1).when(mMockBuildInfo).getFile(BuildInfoFileKey.TESTDIR_IMAGE);
+        runner1.run(testInfo, firstListener);
+        boolean isFirstRunCached = runner1.isCached();
+        doReturn(testDir2).when(mMockBuildInfo).getFile(BuildInfoFileKey.HOST_LINKED_DIR);
+        doReturn(testDir2).when(mMockBuildInfo).getFile(BuildInfoFileKey.TESTDIR_IMAGE);
+        runner2.run(testInfo, secondListener);
+        boolean isSecondRunCached = runner2.isCached();
+
+        assertFalse(isFirstRunCached);
+        verify(firstListener).testRunStarted((String) Mockito.any(), Mockito.eq(1));
+        verify(firstListener).testStarted(Mockito.eq(test), Mockito.anyLong());
+        verify(firstListener)
+                .testEnded(
+                        Mockito.eq(test),
+                        Mockito.anyLong(),
+                        Mockito.<HashMap<String, Metric>>any());
+        verify(firstListener)
+                .testLog((String) Mockito.any(), Mockito.eq(LogDataType.TEXT), Mockito.any());
+        verify(firstListener)
+                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+        assertTrue(isSecondRunCached);
+        verify(secondListener)
+                .testRunStarted(
+                        (String) Mockito.any(), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
+        verify(secondListener).testStarted(Mockito.eq(test), Mockito.anyLong());
+        verify(secondListener)
+                .testEnded(
+                        Mockito.eq(test),
+                        Mockito.anyLong(),
+                        Mockito.<HashMap<String, Metric>>any());
+        verify(secondListener)
+                .testLog((String) Mockito.any(), Mockito.eq(LogDataType.TEXT), Mockito.any());
+        verify(secondListener)
+                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+    }
+
     @Test
     public void testSimplePassingTestLifecycle() throws Exception {
         final String jarName = "SimplePassingTest.jar";
@@ -565,10 +640,9 @@ public class IsolatedHostTestTest {
         makeDirAndAddToList(androidHostOut, "lib", paths);
         makeDirAndAddToList(androidHostOut, "lib64", paths);
 
-        final String expectedLdLibraryPath = String.join(java.io.File.pathSeparator, paths);
         final String ldLibraryPath =
                 mHostTest.compileLdLibraryPathInner(androidHostOut.getAbsolutePath());
-        assertEquals(expectedLdLibraryPath, ldLibraryPath);
+        assertEquals("ANDROID_HOST_OUT/lib:ANDROID_HOST_OUT/lib64:lib:lib64", ldLibraryPath);
     }
 
     @Test
@@ -609,4 +683,32 @@ public class IsolatedHostTestTest {
                 .testLog((String) Mockito.any(), Mockito.eq(LogDataType.TEXT), Mockito.any());
         verify(mListener).testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
     }
+
+    private IsolatedHostTest createTestRunnerForCaching(File testDir) throws Exception {
+        IsolatedHostTest hostTest =
+                new IsolatedHostTest() {
+                    @Override
+                    String getEnvironment(String key) {
+                        return null;
+                    }
+
+                    @Override
+                    ICacheClient getCacheClient(File workFolder, String instanceName) {
+                        return mFakeCacheClient;
+                    }
+                };
+        hostTest.setBuild(mMockBuildInfo);
+        hostTest.setServer(mMockServer);
+        hostTest.setWorkDir(testDir);
+        OptionSetter runnerSetter = new OptionSetter(hostTest);
+        runnerSetter.setOptionValue("enable-cache", "true");
+        runnerSetter.setOptionValue("inherit-env-vars", "false");
+        CommandOptions commandOptions = new CommandOptions();
+        OptionSetter commandOptionsSetter = new OptionSetter(commandOptions);
+        commandOptionsSetter.setOptionValue("remote-cache-instance-name", "test_instance");
+        IConfiguration config = new Configuration("config", "Test config");
+        config.setCommandOptions(commandOptions);
+        hostTest.setConfiguration(config);
+        return hostTest;
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/JarHostTestTest.java b/javatests/com/android/tradefed/testtype/JarHostTestTest.java
index d2b7c7525..107f1b44e 100644
--- a/javatests/com/android/tradefed/testtype/JarHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/JarHostTestTest.java
@@ -266,6 +266,28 @@ public class JarHostTestTest {
         assertEquals(4, mTest.countTestCases());
     }
 
+    @Test
+    public void testFilter_countWithMalformedIncludeRegex() throws Exception {
+        mTest =
+                setupTestFilter(
+                        "com.google.android.apps.yts.tvts.YtsReport#yts[MSEConformanceTestsMSECoreVideoBufferSize-1.3.11.1]");
+        // Just testing it doesn't throw exceptions we don't expect any matches.
+        assertEquals(0, mTest.countTestCases());
+    }
+
+    @Test
+    public void testFilter_countWithMalformedExcludeRegex() throws Exception {
+        mTest = setupTestFilter(".*#test2.*");
+        OptionSetter setter = new OptionSetter(mTest);
+        setter.setOptionValue(
+                "exclude-filter",
+                // Ensure this malformed regex does not cause problems.
+                "com.google.android.apps.yts.tvts.YtsReport#yts[MSEConformanceTestsMSECoreVideoBufferSize-1.3.11.1]");
+
+        // Same as #testFilter_countWithFilterMethodRegex
+        assertEquals(4, mTest.countTestCases());
+    }
+
     @Test
     public void testFilter_countWithClassFilter() throws Exception {
         mTest = setupTestFilter("com.android.tradefed.referencetests.SimplePassingTest");
diff --git a/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java b/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java
index 0cc8f7616..630879dc4 100644
--- a/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java
+++ b/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java
@@ -17,6 +17,7 @@ package com.android.tradefed.testtype;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
@@ -100,7 +101,7 @@ public class PythonUnitTestResultParserTest {
         assertTrue(PythonUnitTestResultParser.PATTERN_FAIL_MESSAGE.matcher(s).matches());
         s = "FAIL: a (b) (i=3)";
         assertTrue(PythonUnitTestResultParser.PATTERN_FAIL_MESSAGE.matcher(s).matches());
-        s = "FAIL: my_test_method (__main__.MyExampleTest.my_test_method)";
+        s = "FAIL: my_test_method (a.b.c.MyExampleTest.my_test_method)";
         assertTrue(PythonUnitTestResultParser.PATTERN_FAIL_MESSAGE.matcher(s).matches());
     }
 
@@ -128,6 +129,85 @@ public class PythonUnitTestResultParserTest {
         assertTrue(PythonUnitTestResultParser.PATTERN_RUN_RESULT.matcher(s).matches());
     }
 
+    @Test
+    public void testShouldSkipCurrentTestPartialClassnameIncludeFilterDoesntSkip() {
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("MyExample");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.MyExampleTest", "test_1", includeFilters, excludeFilters));
+    }
+
+    @Test
+    public void testShouldSkipCurrentTestFullyQualifiedClassMethodIncludeFilterSkipsVariation() {
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("a.b.c.MyExample#test_1");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.c.MyExample", "test_1", includeFilters, excludeFilters));
+        assertTrue(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.c.MyExample", "test_1_variation", includeFilters, excludeFilters));
+    }
+
+    @Test
+    public void testShouldSkipCurrentTestPartialMethodNameIncludeFilterDoesntSkip() {
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("test");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.MyExampleTest", "test_1", includeFilters, excludeFilters));
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.MyExampleTest", "test_2", includeFilters, excludeFilters));
+    }
+
+    @Test
+    public void testShouldSkipCurrentTestFnMatchPatternIncludeFilterDoesntSkip() {
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("test*1");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.MyExampleTest", "test_1", includeFilters, excludeFilters));
+    }
+
+    @Test
+    public void testShouldSkipCurrentTestMalFormedRegexIncludeFilterDoesntSkip() {
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("test[12]");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.MyExampleTest", "test_1", includeFilters, excludeFilters));
+        assertFalse(
+                mParser.shouldSkipCurrentTest(
+                        "a.b.MyExampleTest", "test_2", includeFilters, excludeFilters));
+    }
+
     @Test
     public void testParseNoTests() throws Exception {
         String[] output = {
@@ -200,14 +280,14 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseSingleWithModuleClass() throws Exception {
         String[] output = {
-            "test_1_pass (__main__.MyExampleTest.test_1_pass) ... ok",
+            "test_1_pass (module.package.MyExampleTest.test_1_pass) ... ok",
             "",
             PythonUnitTestResultParser.DASH_LINE,
             "Ran 1 test in 1s",
             "",
             "OK"
         };
-        TestDescription id = new TestDescription("__main__.MyExampleTest", "test_1_pass");
+        TestDescription id = new TestDescription("module.package.MyExampleTest", "test_1_pass");
 
         mParser.processNewLines(output);
 
@@ -219,6 +299,78 @@ public class PythonUnitTestResultParserTest {
         inOrder.verify(mMockListener, times(1)).testRunEnded(1000L, new HashMap<String, Metric>());
     }
 
+    @Test
+    public void testParseMultipleWithFullyQualifiedClassNameAndClassIncludeFilter()
+            throws Exception {
+        String[] output = {
+            "test_1 (atest.module.package.MyClassTest.test_1) ... ok",
+            "test_2 (atest.module.package.MyClassTest.test_2) ... ok",
+            "test_3 (atest.module.package.MyOtherClassTest.test_3) ... ok",
+            "",
+            PythonUnitTestResultParser.DASH_LINE,
+            "Ran 3 tests in 1s",
+            "",
+            "OK"
+        };
+        TestDescription id1 = new TestDescription("atest.module.package.MyClassTest", "test_1");
+        TestDescription id2 = new TestDescription("atest.module.package.MyClassTest", "test_2");
+        TestDescription id3 =
+                new TestDescription("atest.module.package.MyOtherClassTest", "test_3");
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("MyClassTest");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        mParser.processNewLines(output);
+
+        InOrder inOrder = Mockito.inOrder(mMockListener);
+        inOrder.verify(mMockListener, times(1)).testRunStarted("test", 3);
+        inOrder.verify(mMockListener, times(1)).testStarted(Mockito.eq(id1));
+        inOrder.verify(mMockListener, times(1))
+                .testEnded(Mockito.eq(id1), Mockito.<HashMap<String, Metric>>any());
+        inOrder.verify(mMockListener, times(1)).testStarted(Mockito.eq(id2));
+        inOrder.verify(mMockListener, times(1))
+                .testEnded(Mockito.eq(id2), Mockito.<HashMap<String, Metric>>any());
+        inOrder.verify(mMockListener, times(1)).testRunEnded(1000L, new HashMap<String, Metric>());
+        verify(mMockListener, never()).testIgnored(id1);
+        verify(mMockListener, never()).testIgnored(id2);
+        verify(mMockListener).testIgnored(id3);
+    }
+
+    @Test
+    public void testParseMultipleWithFullyQualifiedClassNameAndMethodIncludeFilter()
+            throws Exception {
+        String[] output = {
+            "test_1 (atest.module.package.TestClass.test_1) ... ok",
+            "test_2 (atest.module.package.TestClass.test_2) ... ok",
+            "",
+            PythonUnitTestResultParser.DASH_LINE,
+            "Ran 2 tests in 1s",
+            "",
+            "OK"
+        };
+        TestDescription id1 = new TestDescription("atest.module.package.TestClass", "test_1");
+        TestDescription id2 = new TestDescription("atest.module.package.TestClass", "test_2");
+        Set<String> includeFilters = new LinkedHashSet<>();
+        Set<String> excludeFilters = new LinkedHashSet<>();
+        includeFilters.add("TestClass#test_1");
+        mParser =
+                new PythonUnitTestResultParser(
+                        ArrayUtil.list(mMockListener), "test", includeFilters, excludeFilters);
+
+        mParser.processNewLines(output);
+
+        InOrder inOrder = Mockito.inOrder(mMockListener);
+        inOrder.verify(mMockListener, times(1)).testRunStarted("test", 2);
+        inOrder.verify(mMockListener, times(1)).testStarted(Mockito.eq(id1));
+        inOrder.verify(mMockListener, times(1))
+                .testEnded(Mockito.eq(id1), Mockito.<HashMap<String, Metric>>any());
+        verify(mMockListener, never()).testIgnored(id1);
+        verify(mMockListener).testIgnored(id2);
+    }
+
     @Test
     public void testParseMultiTestPass() throws Exception {
         String[] output = {
diff --git a/javatests/com/android/tradefed/testtype/binary/ExecutableHostTestTest.java b/javatests/com/android/tradefed/testtype/binary/ExecutableHostTestTest.java
index ed3b36d4c..c5f6b7f21 100644
--- a/javatests/com/android/tradefed/testtype/binary/ExecutableHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/ExecutableHostTestTest.java
@@ -15,6 +15,8 @@
  */
 package com.android.tradefed.testtype.binary;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
@@ -29,9 +31,14 @@ import static org.mockito.Mockito.verify;
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.build.DeviceBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
@@ -45,7 +52,9 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtilTest;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -67,9 +76,11 @@ public class ExecutableHostTestTest {
     private ITestDevice mMockDevice;
     private IRunUtil mMockRunUtil;
     private TestInformation mTestInfo;
+    private File mModuleDir;
+    private RunUtilTest.FakeCacheClient mFakeCacheClient;
 
     @Before
-    public void setUp() {
+    public void setUp() throws Exception {
         mMockListener = Mockito.mock(ITestInvocationListener.class);
         mMockDevice = Mockito.mock(ITestDevice.class);
         mMockRunUtil = Mockito.mock(IRunUtil.class);
@@ -87,6 +98,41 @@ public class ExecutableHostTestTest {
         InvocationContext context = new InvocationContext();
         context.addAllocatedDevice("device", mMockDevice);
         mTestInfo = TestInformation.newBuilder().setInvocationContext(context).build();
+        mModuleDir = FileUtil.createTempDir("test-module");
+        mFakeCacheClient = new RunUtilTest.FakeCacheClient();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        FileUtil.recursiveDelete(mModuleDir);
+        mFakeCacheClient.getAllCache().values().stream()
+                .forEach(
+                        a -> {
+                            FileUtil.deleteFile(a.stdOut());
+                            FileUtil.deleteFile(a.stdErr());
+                        });
+    }
+
+    /** Test that a success executable host test run is uploaded to cache service. */
+    @Test
+    public void testRun_upload_cache_for_success_run() throws Exception {
+        doReturn(new StubDevice("123")).when(mMockDevice).getIDevice();
+        ExecutableHostTest executableTest = createExecutableHostTestWithCache("echo hello_world");
+
+        executableTest.run(mTestInfo, mMockListener);
+
+        assertFalse(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
+    /** Test that a failed executable host test run is not uploaded to cache service. */
+    @Test
+    public void testRun_skip_cache_uploading_for_failed_run() throws Exception {
+        doReturn(new StubDevice("123")).when(mMockDevice).getIDevice();
+        ExecutableHostTest executableTest = createExecutableHostTestWithCache("exit 1");
+
+        executableTest.run(mTestInfo, mMockListener);
+
+        assertTrue(mFakeCacheClient.getAllCache().isEmpty());
     }
 
     @Test
@@ -118,12 +164,13 @@ public class ExecutableHostTestTest {
 
     @Test
     public void testRunHostExecutable() throws Exception {
-        File tmpBinary = FileUtil.createTempFile("test-executable", "");
+        File tmpBinary = FileUtil.createTempFile("test-executable", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mExecutableTest);
             setter.setOptionValue("binary", tmpBinary.getAbsolutePath());
 
             CommandResult result = new CommandResult(CommandStatus.SUCCESS);
+            result.setExitCode(0);
             doReturn(result)
                     .when(mMockRunUtil)
                     .runTimedCmd(
@@ -146,25 +193,21 @@ public class ExecutableHostTestTest {
 
     @Test
     public void testRunHostExecutable_relativePath() throws Exception {
-        File tmpBinary = FileUtil.createTempFile("test-executable", "");
+        File tmpBinary = FileUtil.createTempFile("test-executable", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mExecutableTest);
             setter.setOptionValue("binary", tmpBinary.getAbsolutePath());
             setter.setOptionValue("relative-path-execution", "true");
 
             CommandResult result = new CommandResult(CommandStatus.SUCCESS);
+            result.setExitCode(0);
             doReturn(result)
                     .when(mMockRunUtil)
                     .runTimedCmd(
                             Mockito.anyLong(),
                             (OutputStream) Mockito.any(),
                             Mockito.any(),
-                            Mockito.eq("bash"),
-                            Mockito.eq("-c"),
-                            Mockito.eq(
-                                    String.format(
-                                            "pushd %s; ./%s;",
-                                            tmpBinary.getParent(), tmpBinary.getName())));
+                            Mockito.eq(String.format("./%s", tmpBinary.getName())));
 
             mExecutableTest.run(mTestInfo, mMockListener);
 
@@ -180,12 +223,13 @@ public class ExecutableHostTestTest {
 
     @Test
     public void testRunHostExecutable_dnae() throws Exception {
-        File tmpBinary = FileUtil.createTempFile("test-executable", "");
+        File tmpBinary = FileUtil.createTempFile("test-executable", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mExecutableTest);
             setter.setOptionValue("binary", tmpBinary.getAbsolutePath());
 
             CommandResult result = new CommandResult(CommandStatus.SUCCESS);
+            result.setExitCode(0);
             doReturn(result)
                     .when(mMockRunUtil)
                     .runTimedCmd(
@@ -237,6 +281,7 @@ public class ExecutableHostTestTest {
             setter.setOptionValue("binary", tmpBinary.getName());
 
             CommandResult result = new CommandResult(CommandStatus.SUCCESS);
+            result.setExitCode(0);
             doReturn(result)
                     .when(mMockRunUtil)
                     .runTimedCmd(
@@ -270,6 +315,7 @@ public class ExecutableHostTestTest {
             tmpBinary.delete();
 
             CommandResult result = new CommandResult(CommandStatus.SUCCESS);
+            result.setExitCode(0);
             doReturn(result)
                     .when(mMockRunUtil)
                     .runTimedCmd(Mockito.anyLong(), Mockito.eq(tmpBinary.getAbsolutePath()));
@@ -294,7 +340,7 @@ public class ExecutableHostTestTest {
 
     @Test
     public void testRunHostExecutable_failure() throws Exception {
-        File tmpBinary = FileUtil.createTempFile("test-executable", "");
+        File tmpBinary = FileUtil.createTempFile("test-executable", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mExecutableTest);
             setter.setOptionValue("binary", tmpBinary.getAbsolutePath());
@@ -340,7 +386,7 @@ public class ExecutableHostTestTest {
 
     @Test
     public void testRunHostExecutable_timeout() throws Exception {
-        File tmpBinary = FileUtil.createTempFile("test-executable", "");
+        File tmpBinary = FileUtil.createTempFile("test-executable", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mExecutableTest);
             setter.setOptionValue("binary", tmpBinary.getAbsolutePath());
@@ -383,4 +429,29 @@ public class ExecutableHostTestTest {
             FileUtil.recursiveDelete(tmpBinary);
         }
     }
+
+    private ExecutableHostTest createExecutableHostTestWithCache(String scriptContent)
+            throws Exception {
+        ExecutableHostTest executableTest =
+                new ExecutableHostTest() {
+                    @Override
+                    ICacheClient getCacheClient(File workFolder, String instanceName) {
+                        return mFakeCacheClient;
+                    }
+                };
+        File binary =
+                new File(FileUtil.createTempDir("hosttestcases", mModuleDir), "hello_world_test");
+        FileUtil.writeToFile(scriptContent, binary);
+        binary.setExecutable(true);
+        OptionSetter testSetter = new OptionSetter(executableTest);
+        testSetter.setOptionValue("binary", binary.getAbsolutePath());
+        testSetter.setOptionValue("enable-cache", "true");
+        CommandOptions commandOptions = new CommandOptions();
+        OptionSetter commandOptionsSetter = new OptionSetter(commandOptions);
+        commandOptionsSetter.setOptionValue("remote-cache-instance-name", "test_instance");
+        IConfiguration config = new Configuration("config", "Test config");
+        config.setCommandOptions(commandOptions);
+        executableTest.setConfiguration(config);
+        return executableTest;
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/binary/ExecutableTargetTestTest.java b/javatests/com/android/tradefed/testtype/binary/ExecutableTargetTestTest.java
index 9513da00c..79122dd5a 100644
--- a/javatests/com/android/tradefed/testtype/binary/ExecutableTargetTestTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/ExecutableTargetTestTest.java
@@ -39,9 +39,9 @@ import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mockito;
 
-import java.util.List;
-import java.util.HashMap;
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
 
@@ -98,17 +98,21 @@ public class ExecutableTargetTestTest {
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         // run cmd1 test
         TestDescription testDescription = new TestDescription(testName1, testName1);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         // run cmd2 test
         TestDescription testDescription2 = new TestDescription(testName2, testName2);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription2),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(
@@ -119,6 +123,8 @@ public class ExecutableTargetTestTest {
     /** Test the run method for a couple commands but binary path not found. */
     @Test
     public void testRun_pathNotExist() throws DeviceNotAvailableException, ConfigurationException {
+        TestDescription testDescription1 = new TestDescription(testName1, testName1);
+        TestDescription testDescription2 = new TestDescription(testName2, testName2);
         mExecutableTargetTest =
                 new ExecutableTargetTest() {
                     @Override
@@ -140,6 +146,8 @@ public class ExecutableTargetTestTest {
         mExecutableTargetTest.run(mTestInfo, mListener);
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         // run cmd1 test
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription1), Mockito.anyLong());
         FailureDescription failure1 =
                 FailureDescription.create(
                                 String.format(ExecutableBaseTest.NO_BINARY_ERROR, testCmd1),
@@ -147,9 +155,16 @@ public class ExecutableTargetTestTest {
                         .setErrorIdentifier(InfraErrorIdentifier.ARTIFACT_NOT_FOUND);
         Mockito.verify(mListener, Mockito.times(1))
                 .testFailed(
-                        Mockito.eq(new TestDescription(testName1, testName1)),
+                        Mockito.eq(testDescription1),
                         Mockito.eq(failure1));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testEnded(
+                        Mockito.eq(testDescription1),
+                        Mockito.anyLong(),
+                        Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         // run cmd2 test
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription2), Mockito.anyLong());
         FailureDescription failure2 =
                 FailureDescription.create(
                                 String.format(ExecutableBaseTest.NO_BINARY_ERROR, testCmd2),
@@ -157,8 +172,13 @@ public class ExecutableTargetTestTest {
                         .setErrorIdentifier(InfraErrorIdentifier.ARTIFACT_NOT_FOUND);
         Mockito.verify(mListener, Mockito.times(1))
                 .testFailed(
-                        Mockito.eq(new TestDescription(testName2, testName2)),
+                        Mockito.eq(testDescription2),
                         Mockito.eq(failure2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testEnded(
+                        Mockito.eq(testDescription2),
+                        Mockito.anyLong(),
+                        Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(
                         Mockito.anyLong(),
@@ -192,19 +212,23 @@ public class ExecutableTargetTestTest {
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         // run cmd1 test
         TestDescription testDescription = new TestDescription(testName1, testName1);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1)).testFailed(testDescription, ERROR_MESSAGE);
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         // run cmd2 test
         TestDescription testDescription2 = new TestDescription(testName2, testName2);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1)).testFailed(testDescription2, ERROR_MESSAGE);
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription2),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(
@@ -243,17 +267,21 @@ public class ExecutableTargetTestTest {
         mExecutableTargetTest.run(mTestInfo, mListener);
         // testName1 should NOT run.
         Mockito.verify(mListener, Mockito.never()).testRunStarted(eq(testName1), eq(1));
-        Mockito.verify(mListener, Mockito.never()).testStarted(Mockito.eq(testDescription));
+        Mockito.verify(mListener, Mockito.never())
+                .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never())
                 .testEnded(
                         Mockito.eq(testDescription),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         // run cmd2 test
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(eq(testName2), eq(1));
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription2),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(
@@ -261,10 +289,12 @@ public class ExecutableTargetTestTest {
                         Mockito.<HashMap<String, MetricMeasurement.Metric>>any());
         // testName3 should NOT run.
         Mockito.verify(mListener, Mockito.never()).testRunStarted(eq(testName3), eq(1));
-        Mockito.verify(mListener, Mockito.never()).testStarted(Mockito.eq(testDescription3));
+        Mockito.verify(mListener, Mockito.never())
+                .testStarted(Mockito.eq(testDescription3), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never())
                 .testEnded(
                         Mockito.eq(testDescription3),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
     }
 
@@ -298,17 +328,21 @@ public class ExecutableTargetTestTest {
         mExecutableTargetTest.run(mTestInfo, mListener);
         // testName1 should NOT run.
         Mockito.verify(mListener, Mockito.never()).testRunStarted(eq(testName1), eq(1));
-        Mockito.verify(mListener, Mockito.never()).testStarted(Mockito.eq(testDescription));
+        Mockito.verify(mListener, Mockito.never())
+                .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never())
                 .testEnded(
                         Mockito.eq(testDescription),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         // run cmd2 test
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(eq(testName2), eq(1));
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription2),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(
@@ -316,10 +350,12 @@ public class ExecutableTargetTestTest {
                         Mockito.<HashMap<String, MetricMeasurement.Metric>>any());
         // testName3 should NOT run.
         Mockito.verify(mListener, Mockito.never()).testRunStarted(eq(testName3), eq(1));
-        Mockito.verify(mListener, Mockito.never()).testStarted(Mockito.eq(testDescription3));
+        Mockito.verify(mListener, Mockito.never())
+                .testStarted(Mockito.eq(testDescription3), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never())
                 .testEnded(
                         Mockito.eq(testDescription3),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
     }
 
@@ -353,17 +389,21 @@ public class ExecutableTargetTestTest {
         mExecutableTargetTest.run(mTestInfo, mListener);
         // testName1 should NOT run.
         Mockito.verify(mListener, Mockito.never()).testRunStarted(eq(testName1), eq(1));
-        Mockito.verify(mListener, Mockito.never()).testStarted(Mockito.eq(testDescription));
+        Mockito.verify(mListener, Mockito.never())
+                .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never())
                 .testEnded(
                         Mockito.eq(testDescription),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         // run cmd2 test
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(eq(testName2), eq(1));
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription2),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(
@@ -371,10 +411,12 @@ public class ExecutableTargetTestTest {
                         Mockito.<HashMap<String, MetricMeasurement.Metric>>any());
         // testName3 should NOT run.
         Mockito.verify(mListener, Mockito.never()).testRunStarted(eq(testName3), eq(1));
-        Mockito.verify(mListener, Mockito.never()).testStarted(Mockito.eq(testDescription3));
+        Mockito.verify(mListener, Mockito.never())
+                .testStarted(Mockito.eq(testDescription3), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never())
                 .testEnded(
                         Mockito.eq(testDescription3),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
     }
 
@@ -477,10 +519,12 @@ public class ExecutableTargetTestTest {
         // run cmd1 test
         TestDescription testDescription = new TestDescription(testName1, testName1);
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(eq(testName1), eq(1));
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
                         Mockito.eq(testDescription),
+                        Mockito.anyLong(),
                         Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
     }
 }
diff --git a/javatests/com/android/tradefed/testtype/binary/KTapResultParserTest.java b/javatests/com/android/tradefed/testtype/binary/KTapResultParserTest.java
index 6c5d86605..229299d4e 100644
--- a/javatests/com/android/tradefed/testtype/binary/KTapResultParserTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/KTapResultParserTest.java
@@ -21,16 +21,9 @@ import static org.junit.Assert.assertThrows;
 
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.CollectingTestListener;
+import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.TestResult;
 import com.android.tradefed.result.TestRunResult;
-import com.android.tradefed.result.TestDescription;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Optional;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,6 +31,13 @@ import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameter;
 import org.junit.runners.Parameterized.Parameters;
 
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
 @RunWith(Parameterized.class)
 public class KTapResultParserTest {
 
@@ -46,7 +46,8 @@ public class KTapResultParserTest {
         return Arrays.asList(
                 new Object[][] {
                     {KTapResultParser.ParseResolution.INDIVIDUAL_LEAVES},
-                    {KTapResultParser.ParseResolution.AGGREGATED_TOP_LEVEL}
+                    {KTapResultParser.ParseResolution.AGGREGATED_SUITE},
+                    {KTapResultParser.ParseResolution.AGGREGATED_MODULE},
                 });
     }
 
@@ -55,29 +56,30 @@ public class KTapResultParserTest {
     @Test
     public void test_doc_example_tap() {
         // Example taken from https://docs.kernel.org/dev-tools/ktap.html#example-ktap-output
-        String ktapResults =
-                "KTAP version 1\n"
-                        + "1..1\n"
-                        + "  KTAP version 1\n"
-                        + "  1..3\n"
-                        + "    KTAP version 1\n"
-                        + "    1..1\n"
-                        + "    # test_1: initializing test_1\n"
-                        + "    ok 1 test_1\n"
-                        + "  ok 1 example_test_1\n"
-                        + "    KTAP version 1\n"
-                        + "    1..2\n"
-                        + "    ok 1 test_1 # SKIP test_1 skipped\n"
-                        + "    ok 2 test_2\n"
-                        + "  ok 2 example_test_2\n"
-                        + "    KTAP version 1\n"
-                        + "    1..3\n"
-                        + "    ok 1 test_1\n"
-                        + "    # test_2: FAIL\n"
-                        + "    not ok 2 test_2\n"
-                        + "    ok 3 test_3 # SKIP test_3 skipped\n"
-                        + "  not ok 3 example_test_3\n"
-                        + "not ok 1 main_test\n";
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "  KTAP version 1\n"
+                    + "  1..3\n"
+                    + "    KTAP version 1\n"
+                    + "    1..1\n"
+                    + "    # test_1: initializing test_1\n"
+                    + "    ok 1 test_1\n"
+                    + "  ok 1 example_test_1\n"
+                    + "    KTAP version 1\n"
+                    + "    1..2\n"
+                    + "    ok 1 test_1 # SKIP test_1 skipped\n"
+                    + "    ok 2 test_2\n"
+                    + "  ok 2 example_test_2\n"
+                    + "    KTAP version 1\n"
+                    + "    1..3\n"
+                    + "    ok 1 test_1\n"
+                    + "    # test_2: FAIL\n"
+                    + "    not ok 2 test_2\n"
+                    + "    ok 3 test_3 # SKIP test_3 skipped\n"
+                    + "  not ok 3 example_test_3\n"
+                    + "not ok 1 main_test\n"
+        };
 
         String[][] expectedLeafResults = {
             {"main_test.example_test_1.test_1", "PASSED", ""},
@@ -87,8 +89,10 @@ public class KTapResultParserTest {
             {"main_test.example_test_3.test_2", "FAILURE", "# test_2: FAIL"},
             {"main_test.example_test_3.test_3", "IGNORED", ""}
         };
-        String[] expectedRootResults = {"main_test", "FAILURE", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"main_test", "FAILURE", ""}};
+        String[] expectedModuleResults = {"main_test", "FAILURE", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
@@ -130,8 +134,13 @@ public class KTapResultParserTest {
         // The full KTAP should pass with no error.
         Optional<String> ktapResults =
                 Arrays.stream(ktapResultsByLine).reduce((str1, str2) -> str1 + str2);
-        String[] expectedRootResults = {"main_test", "FAILURE", ""};
-        checkKTap(ktapResults.get(), expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"main_test", "FAILURE", ""}};
+        String[] expectedModuleResults = {"main_test", "FAILURE", ""};
+        checkKTap(
+                new String[] {ktapResults.get()},
+                expectedLeafResults,
+                expectedSuiteResults,
+                expectedModuleResults);
 
         // Loop through the good KTAP with an additional line removed for each iteration.
         // An exception should be thrown for each partial result.
@@ -145,96 +154,104 @@ public class KTapResultParserTest {
                                     + " didn't report an error as expected: %s",
                             ktapResultsByLine.length - i - 1, ktapResults2.get()),
                     RuntimeException.class,
-                    () -> checkKTap(ktapResults2.get(), expectedLeafResults, expectedRootResults));
+                    () ->
+                            checkKTap(
+                                    new String[] {ktapResults2.get()},
+                                    expectedLeafResults,
+                                    expectedSuiteResults,
+                                    expectedModuleResults));
         }
     }
 
     @Test
     public void test_too_many_results() {
-        String ktapResults =
-                "KTAP version 1\n"
-                        + "1..1\n"
-                        + "  KTAP version 1\n"
-                        + "  1..3\n"
-                        + "    KTAP version 1\n"
-                        + "    1..1\n"
-                        + "    # test_1: initializing test_1\n"
-                        + "    ok 1 test_1\n"
-                        + "  ok 1 example_test_1\n"
-                        + "    KTAP version 1\n"
-                        + "    1..2\n"
-                        + "    ok 1 test_1 # SKIP test_1 skipped\n"
-                        + "    ok 2 test_2\n"
-                        + "    ok 3 test_2\n" // <-- This is the error
-                        + "  ok 2 example_test_2\n"
-                        + "    KTAP version 1\n"
-                        + "    1..3\n"
-                        + "    ok 1 test_1\n"
-                        + "    # test_2: FAIL\n"
-                        + "    not ok 2 test_2\n"
-                        + "    ok 3 test_3 # SKIP test_3 skipped\n"
-                        + "  not ok 3 example_test_3\n"
-                        + "not ok 1 main_test\n";
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "  KTAP version 1\n"
+                    + "  1..3\n"
+                    + "    KTAP version 1\n"
+                    + "    1..1\n"
+                    + "    # test_1: initializing test_1\n"
+                    + "    ok 1 test_1\n"
+                    + "  ok 1 example_test_1\n"
+                    + "    KTAP version 1\n"
+                    + "    1..2\n"
+                    + "    ok 1 test_1 # SKIP test_1 skipped\n"
+                    + "    ok 2 test_2\n"
+                    + "    ok 3 test_2\n" // <-- This is the error
+                    + "  ok 2 example_test_2\n"
+                    + "    KTAP version 1\n"
+                    + "    1..3\n"
+                    + "    ok 1 test_1\n"
+                    + "    # test_2: FAIL\n"
+                    + "    not ok 2 test_2\n"
+                    + "    ok 3 test_3 # SKIP test_3 skipped\n"
+                    + "  not ok 3 example_test_3\n"
+                    + "not ok 1 main_test\n"
+        };
 
-        assertThrows(RuntimeException.class, () -> checkKTap(ktapResults, null, null));
+        assertThrows(RuntimeException.class, () -> checkKTap(ktapResultsList, null, null, null));
     }
 
     @Test
     public void test_duplicate_test_num() {
-        String ktapResults =
-                "KTAP version 1\n"
-                        + "1..1\n"
-                        + "  KTAP version 1\n"
-                        + "  1..3\n"
-                        + "    KTAP version 1\n"
-                        + "    1..1\n"
-                        + "    # test_1: initializing test_1\n"
-                        + "    ok 1 test_1\n"
-                        + "  ok 1 example_test_1\n"
-                        + "    KTAP version 1\n"
-                        + "    1..2\n"
-                        + "    ok 1 test_1 # SKIP test_1 skipped\n"
-                        + "    ok 1 test_2\n" // <-- This is the error
-                        + "  ok 2 example_test_2\n"
-                        + "    KTAP version 1\n"
-                        + "    1..3\n"
-                        + "    ok 1 test_1\n"
-                        + "    # test_2: FAIL\n"
-                        + "    not ok 2 test_2\n"
-                        + "    ok 3 test_3 # SKIP test_3 skipped\n"
-                        + "  not ok 3 example_test_3\n"
-                        + "not ok 1 main_test\n";
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "  KTAP version 1\n"
+                    + "  1..3\n"
+                    + "    KTAP version 1\n"
+                    + "    1..1\n"
+                    + "    # test_1: initializing test_1\n"
+                    + "    ok 1 test_1\n"
+                    + "  ok 1 example_test_1\n"
+                    + "    KTAP version 1\n"
+                    + "    1..2\n"
+                    + "    ok 1 test_1 # SKIP test_1 skipped\n"
+                    + "    ok 1 test_2\n" // <-- This is the error
+                    + "  ok 2 example_test_2\n"
+                    + "    KTAP version 1\n"
+                    + "    1..3\n"
+                    + "    ok 1 test_1\n"
+                    + "    # test_2: FAIL\n"
+                    + "    not ok 2 test_2\n"
+                    + "    ok 3 test_3 # SKIP test_3 skipped\n"
+                    + "  not ok 3 example_test_3\n"
+                    + "not ok 1 main_test\n"
+        };
 
-        assertThrows(RuntimeException.class, () -> checkKTap(ktapResults, null, null));
+        assertThrows(RuntimeException.class, () -> checkKTap(ktapResultsList, null, null, null));
     }
 
     @Test
     public void test_skipped_test_num() {
-        String ktapResults =
-                "KTAP version 1\n"
-                        + "1..1\n"
-                        + "  KTAP version 1\n"
-                        + "  1..3\n"
-                        + "    KTAP version 1\n"
-                        + "    1..1\n"
-                        + "    # test_1: initializing test_1\n"
-                        + "    ok 1 test_1\n"
-                        + "  ok 1 example_test_1\n"
-                        + "    KTAP version 1\n"
-                        + "    1..2\n"
-                        + "    ok 1 test_1 # SKIP test_1 skipped\n"
-                        + "    ok 2 test_2\n"
-                        + "  ok 2 example_test_2\n"
-                        + "    KTAP version 1\n"
-                        + "    1..3\n"
-                        + "    ok 1 test_1\n"
-                        + "    # test_2: FAIL\n"
-                        + "    # not ok 2 test_2\n" // <-- This is the error.
-                        + "    ok 3 test_3 # SKIP test_3 skipped\n"
-                        + "  not ok 3 example_test_3\n"
-                        + "not ok 1 main_test\n";
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "  KTAP version 1\n"
+                    + "  1..3\n"
+                    + "    KTAP version 1\n"
+                    + "    1..1\n"
+                    + "    # test_1: initializing test_1\n"
+                    + "    ok 1 test_1\n"
+                    + "  ok 1 example_test_1\n"
+                    + "    KTAP version 1\n"
+                    + "    1..2\n"
+                    + "    ok 1 test_1 # SKIP test_1 skipped\n"
+                    + "    ok 2 test_2\n"
+                    + "  ok 2 example_test_2\n"
+                    + "    KTAP version 1\n"
+                    + "    1..3\n"
+                    + "    ok 1 test_1\n"
+                    + "    # test_2: FAIL\n"
+                    + "    # not ok 2 test_2\n" // <-- This is the error.
+                    + "    ok 3 test_3 # SKIP test_3 skipped\n"
+                    + "  not ok 3 example_test_3\n"
+                    + "not ok 1 main_test\n"
+        };
 
-        assertThrows(RuntimeException.class, () -> checkKTap(ktapResults, null, null));
+        assertThrows(RuntimeException.class, () -> checkKTap(ktapResultsList, null, null, null));
     }
 
     @Test
@@ -283,8 +300,8 @@ public class KTapResultParserTest {
     @Test
     public void test_ext4_inode_test_ktap() {
         // Example output taken from ext4-inode-test.ko
-        String ktapResults =
-                "KTAP version 1\n"
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
                     + "1..1\n"
                     + "    KTAP version 1\n"
                     + "    # Subtest: ext4_inode_test\n"
@@ -323,7 +340,8 @@ public class KTapResultParserTest {
                     + "    ok 1 inode_test_xtimestamp_decoding\n"
                     + "    # module: ext4_inode_test\n"
                     + "# Totals: pass:16 fail:0 skip:0 total:16\n"
-                    + "ok 1 ext4_inode_test\n";
+                    + "ok 1 ext4_inode_test\n"
+        };
 
         String[][] expectedLeafResults = {
             {
@@ -407,54 +425,57 @@ public class KTapResultParserTest {
                 ""
             },
         };
-        String[] expectedRootResults = {"ext4_inode_test", "PASSED", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"ext4_inode_test", "PASSED", ""}};
+        String[] expectedModuleResults = {"ext4_inode_test", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_fat_test_ktap() {
         // Example output taken from fat_test.ko
-        String ktapResults =
-                "KTAP version 1\n"
-                        + "1..1\n"
-                        + "    KTAP version 1\n"
-                        + "    # Subtest: fat_test\n"
-                        + "    1..3\n"
-                        + "    ok 1 fat_checksum_test\n"
-                        + "        KTAP version 1\n"
-                        + "        # Subtest: fat_time_fat2unix_test\n"
-                        + "        ok 1 Earliest possible UTC (1980-01-01 00:00:00)\n"
-                        + "        ok 2 Latest possible UTC (2107-12-31 23:59:58)\n"
-                        + "        ok 3 Earliest possible (UTC-11) (== 1979-12-31 13:00:00 UTC)\n"
-                        + "        ok 4 Latest possible (UTC+11) (== 2108-01-01 10:59:58 UTC)\n"
-                        + "        ok 5 Leap Day / Year (1996-02-29 00:00:00)\n"
-                        + "        ok 6 Year 2000 is leap year (2000-02-29 00:00:00)\n"
-                        + "        ok 7 Year 2100 not leap year (2100-03-01 00:00:00)\n"
-                        + "        ok 8 Leap year + timezone UTC+1 (== 2004-02-29 00:30:00 UTC)\n"
-                        + "        ok 9 Leap year + timezone UTC-1 (== 2004-02-29 23:30:00 UTC)\n"
-                        + "        ok 10 VFAT odd-second resolution (1999-12-31 23:59:59)\n"
-                        + "        ok 11 VFAT 10ms resolution (1980-01-01 00:00:00:0010)\n"
-                        + "    # fat_time_fat2unix_test: pass:11 fail:0 skip:0 total:11\n"
-                        + "    ok 2 fat_time_fat2unix_test\n"
-                        + "        KTAP version 1\n"
-                        + "        # Subtest: fat_time_unix2fat_test\n"
-                        + "        ok 1 Earliest possible UTC (1980-01-01 00:00:00)\n"
-                        + "        ok 2 Latest possible UTC (2107-12-31 23:59:58)\n"
-                        + "        ok 3 Earliest possible (UTC-11) (== 1979-12-31 13:00:00 UTC)\n"
-                        + "        ok 4 Latest possible (UTC+11) (== 2108-01-01 10:59:58 UTC)\n"
-                        + "        ok 5 Leap Day / Year (1996-02-29 00:00:00)\n"
-                        + "        ok 6 Year 2000 is leap year (2000-02-29 00:00:00)\n"
-                        + "        ok 7 Year 2100 not leap year (2100-03-01 00:00:00)\n"
-                        + "        ok 8 Leap year + timezone UTC+1 (== 2004-02-29 00:30:00 UTC)\n"
-                        + "        ok 9 Leap year + timezone UTC-1 (== 2004-02-29 23:30:00 UTC)\n"
-                        + "        ok 10 VFAT odd-second resolution (1999-12-31 23:59:59)\n"
-                        + "        ok 11 VFAT 10ms resolution (1980-01-01 00:00:00:0010)\n"
-                        + "    # fat_time_unix2fat_test: pass:11 fail:0 skip:0 total:11\n"
-                        + "    ok 3 fat_time_unix2fat_test\n"
-                        + "    # module: fat_test\n"
-                        + "# fat_test: pass:3 fail:0 skip:0 total:3\n"
-                        + "# Totals: pass:23 fail:0 skip:0 total:23\n"
-                        + "ok 1 fat_test\n";
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "    KTAP version 1\n"
+                    + "    # Subtest: fat_test\n"
+                    + "    1..3\n"
+                    + "    ok 1 fat_checksum_test\n"
+                    + "        KTAP version 1\n"
+                    + "        # Subtest: fat_time_fat2unix_test\n"
+                    + "        ok 1 Earliest possible UTC (1980-01-01 00:00:00)\n"
+                    + "        ok 2 Latest possible UTC (2107-12-31 23:59:58)\n"
+                    + "        ok 3 Earliest possible (UTC-11) (== 1979-12-31 13:00:00 UTC)\n"
+                    + "        ok 4 Latest possible (UTC+11) (== 2108-01-01 10:59:58 UTC)\n"
+                    + "        ok 5 Leap Day / Year (1996-02-29 00:00:00)\n"
+                    + "        ok 6 Year 2000 is leap year (2000-02-29 00:00:00)\n"
+                    + "        ok 7 Year 2100 not leap year (2100-03-01 00:00:00)\n"
+                    + "        ok 8 Leap year + timezone UTC+1 (== 2004-02-29 00:30:00 UTC)\n"
+                    + "        ok 9 Leap year + timezone UTC-1 (== 2004-02-29 23:30:00 UTC)\n"
+                    + "        ok 10 VFAT odd-second resolution (1999-12-31 23:59:59)\n"
+                    + "        ok 11 VFAT 10ms resolution (1980-01-01 00:00:00:0010)\n"
+                    + "    # fat_time_fat2unix_test: pass:11 fail:0 skip:0 total:11\n"
+                    + "    ok 2 fat_time_fat2unix_test\n"
+                    + "        KTAP version 1\n"
+                    + "        # Subtest: fat_time_unix2fat_test\n"
+                    + "        ok 1 Earliest possible UTC (1980-01-01 00:00:00)\n"
+                    + "        ok 2 Latest possible UTC (2107-12-31 23:59:58)\n"
+                    + "        ok 3 Earliest possible (UTC-11) (== 1979-12-31 13:00:00 UTC)\n"
+                    + "        ok 4 Latest possible (UTC+11) (== 2108-01-01 10:59:58 UTC)\n"
+                    + "        ok 5 Leap Day / Year (1996-02-29 00:00:00)\n"
+                    + "        ok 6 Year 2000 is leap year (2000-02-29 00:00:00)\n"
+                    + "        ok 7 Year 2100 not leap year (2100-03-01 00:00:00)\n"
+                    + "        ok 8 Leap year + timezone UTC+1 (== 2004-02-29 00:30:00 UTC)\n"
+                    + "        ok 9 Leap year + timezone UTC-1 (== 2004-02-29 23:30:00 UTC)\n"
+                    + "        ok 10 VFAT odd-second resolution (1999-12-31 23:59:59)\n"
+                    + "        ok 11 VFAT 10ms resolution (1980-01-01 00:00:00:0010)\n"
+                    + "    # fat_time_unix2fat_test: pass:11 fail:0 skip:0 total:11\n"
+                    + "    ok 3 fat_time_unix2fat_test\n"
+                    + "    # module: fat_test\n"
+                    + "# fat_test: pass:3 fail:0 skip:0 total:3\n"
+                    + "# Totals: pass:23 fail:0 skip:0 total:23\n"
+                    + "ok 1 fat_test\n"
+        };
 
         String[][] expectedLeafResults = {
             {"fat_test.fat_checksum_test", "PASSED", ""},
@@ -561,43 +582,54 @@ public class KTapResultParserTest {
                 ""
             },
         };
-        String[] expectedRootResults = {"fat_test", "PASSED", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"fat_test", "PASSED", ""}};
+        String[] expectedModuleResults = {"fat_test", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_no_tests_run_with_header_ktap() {
         // Example taken from KUnits: test_data/test_is_test_passed-no_tests_run_with_header.log
-        String ktapResults = "TAP version 14\n" + "1..0\n";
+        String[] ktapResultsList = {"TAP version 14\n" + "1..0\n"};
         String[][] expectedLeafResults = {};
-        String[] expectedRootResults = {};
+        String[][] expectedSuiteResults = {};
+        String[] expectedModuleResults = {};
         assertThrows(
                 IllegalArgumentException.class,
-                () -> checkKTap(ktapResults, expectedLeafResults, expectedRootResults));
+                () ->
+                        checkKTap(
+                                ktapResultsList,
+                                expectedLeafResults,
+                                expectedSuiteResults,
+                                expectedModuleResults));
     }
 
     @Test
     public void test_passed_no_tests_no_plan_ktap() {
         // Example taken from KUnits: test_data/test_is_test_passed-no_tests_no_plan.log
-        String ktapResults =
-                "TAP version 14\n"
-                        + "1..1\n"
-                        + "  # Subtest: suite\n"
-                        + "  1..1\n"
-                        + "    # Subtest: case\n"
-                        + "  ok 1 - case\n"
-                        + "ok 1 - suite\n";
+        String[] ktapResultsList = {
+            "TAP version 14\n"
+                    + "1..1\n"
+                    + "  # Subtest: suite\n"
+                    + "  1..1\n"
+                    + "    # Subtest: case\n"
+                    + "  ok 1 - case\n"
+                    + "ok 1 - suite\n"
+        };
 
         String[][] expectedLeafResults = {{"suite.case", "PASSED", ""}};
-        String[] expectedRootResults = {"suite", "PASSED", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"suite", "PASSED", ""}};
+        String[] expectedModuleResults = {"suite", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_passed_missing_plan_ktap() {
         // Example from KUnits: test_data/test_is_test_passed-missing_plan.log
-        String ktapResults =
-                "KTAP version 1\n"
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
                     + "	# Subtest: sysctl_test\n"
                     + "	# sysctl_test_dointvec_null_tbl_data: sysctl_test_dointvec_null_tbl_data"
                     + " passed\n"
@@ -635,7 +667,8 @@ public class KTapResultParserTest {
                     + "	# example_mock_test: example_mock_test passed\n"
                     + "	ok 2 - example_mock_test\n"
                     + "kunit example: all tests passed\n"
-                    + "ok 2 - example\n";
+                    + "ok 2 - example\n"
+        };
 
         String[][] expectedLeafResults = {
             {"sysctl_test.sysctl_test_dointvec_null_tbl_data", "PASSED", ""},
@@ -649,15 +682,17 @@ public class KTapResultParserTest {
             {"example.example_simple_test", "PASSED", ""},
             {"example.example_mock_test", "PASSED", ""},
         };
-        String[] expectedRootResults = {"sysctl_test.example", "PASSED", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"sysctl_test.example", "PASSED", ""}};
+        String[] expectedModuleResults = {"sysctl_test.example", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_passed_kselftest_ktap() {
         // Example from KUnits: test_data/test_is_test_passed-kselftest.log
-        String ktapResults =
-                "TAP version 13\n"
+        String[] ktapResultsList = {
+            "TAP version 13\n"
                     + "1..2\n"
                     + "# selftests: membarrier: membarrier_test_single_thread\n"
                     + "# TAP version 13\n"
@@ -672,25 +707,34 @@ public class KTapResultParserTest {
                     + "# ok 1 sys_membarrier available\n"
                     + "# ok 2 sys membarrier invalid command test: command = -1, flags = 0, errno ="
                     + " 22. Failed as expected\n"
-                    + "ok 2 selftests: membarrier: membarrier_test_multi_thread\n";
+                    + "ok 2 selftests: membarrier: membarrier_test_multi_thread\n"
+        };
 
         String[][] expectedLeafResults = {
             {"selftests:_membarrier:_membarrier_test_single_thread", "PASSED", ""},
             {"selftests:_membarrier:_membarrier_test_multi_thread", "PASSED", ""}
         };
-        String[] expectedRootResults = {
+        String[][] expectedSuiteResults = {
+            {
+                "selftests:_membarrier:_membarrier_test_single_thread.selftests:_membarrier:_membarrier_test_multi_thread",
+                "PASSED",
+                ""
+            }
+        };
+        String[] expectedModuleResults = {
             "selftests:_membarrier:_membarrier_test_single_thread.selftests:_membarrier:_membarrier_test_multi_thread",
             "PASSED",
             ""
         };
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_passed_failure_ktap() {
         // Example from KUnits: test_data/test_is_test_passed-failure.log
-        String ktapResults =
-                "TAP version 14\n"
+        String[] ktapResultsList = {
+            "TAP version 14\n"
                     + "1..2\n"
                     + "	# Subtest: sysctl_test\n"
                     + "	1..8\n"
@@ -734,7 +778,8 @@ public class KTapResultParserTest {
                     + "	# example_mock_test: example_mock_test passed\n"
                     + "	ok 2 - example_mock_test\n"
                     + "kunit example: one or more tests failed\n"
-                    + "not ok 2 - example\n";
+                    + "not ok 2 - example\n"
+        };
 
         String[][] expectedLeafResults = {
             {"sysctl_test.sysctl_test_dointvec_null_tbl_data", "PASSED", ""},
@@ -758,15 +803,17 @@ public class KTapResultParserTest {
             },
             {"example.example_mock_test", "PASSED", ""},
         };
-        String[] expectedRootResults = {"sysctl_test.example", "FAILURE", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"sysctl_test.example", "FAILURE", ""}};
+        String[] expectedModuleResults = {"sysctl_test.example", "FAILURE", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_passed_all_passed_nested_ktap() {
         // Example from KUnits: test_data/test_is_test_passed-all_passed_nested.log
-        String ktapResults =
-                "TAP version 14\n"
+        String[] ktapResultsList = {
+            "TAP version 14\n"
                     + "1..2\n"
                     + "	# Subtest: sysctl_test\n"
                     + "	1..4\n"
@@ -802,7 +849,8 @@ public class KTapResultParserTest {
                     + "	# example_mock_test: example_mock_test passed\n"
                     + "	ok 2 - example_mock_test\n"
                     + "kunit example: all tests passed\n"
-                    + "ok 2 - example\n";
+                    + "ok 2 - example\n"
+        };
 
         String[][] expectedLeafResults = {
             {"sysctl_test.sysctl_test_dointvec_null_tbl_data", "PASSED", ""},
@@ -813,15 +861,17 @@ public class KTapResultParserTest {
             {"example.example_simple_test", "PASSED", ""},
             {"example.example_mock_test", "PASSED", ""}
         };
-        String[] expectedRootResults = {"sysctl_test.example", "PASSED", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"sysctl_test.example", "PASSED", ""}};
+        String[] expectedModuleResults = {"sysctl_test.example", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_passed_all_passed_ktap() {
         // Example from KUnits: test_data/test_is_test_passed-all_passed.log
-        String ktapResults =
-                "TAP version 14\n"
+        String[] ktapResultsList = {
+            "TAP version 14\n"
                     + "1..2\n"
                     + "	# Subtest: sysctl_test\n"
                     + "	1..8\n"
@@ -861,7 +911,9 @@ public class KTapResultParserTest {
                     + "	# example_mock_test: example_mock_test passed\n"
                     + "	ok 2 - example_mock_test\n"
                     + "kunit example: all tests passed\n"
-                    + "ok 2 - example\n";
+                    + "ok 2 - example\n"
+        };
+
         String[][] expectedLeafResults = {
             {"sysctl_test.sysctl_test_dointvec_null_tbl_data", "PASSED", ""},
             {"sysctl_test.sysctl_test_dointvec_table_maxlen_unset", "PASSED", ""},
@@ -874,62 +926,262 @@ public class KTapResultParserTest {
             {"example.example_simple_test", "PASSED", ""},
             {"example.example_mock_test", "PASSED", ""},
         };
-        String[] expectedRootResults = {"sysctl_test.example", "PASSED", ""};
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        String[][] expectedSuiteResults = {{"sysctl_test.example", "PASSED", ""}};
+        String[] expectedModuleResults = {"sysctl_test.example", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     @Test
     public void test_passed_kselftest_binderfs() {
-        String ktapResults =
-                "TAP version 13\n"
-                    + "1..3\n"
-                    + "# Starting 3 tests from 1 test cases.\n"
-                    + "#  RUN           global.binderfs_stress ...\n"
-                    + "#      SKIP      binderfs_stress: user namespace not supported\n"
-                    + "\n"
-                    + "#            OK  global.binderfs_stress\n"
-                    + "ok 1 # SKIP binderfs_stress: user namespace not supported\n"
-                    + "\n"
-                    + "#  RUN           global.binderfs_test_privileged ...\n"
-                    + "# external/linux-kselftest/tools/testing/selftests/filesystems/binderfs/binderfs_test.c:109:binderfs_test_privileged:Allocated"
-                    + " new binder device with major 506, minor 8, and name my-binder\n"
-                    + "# external/linux-kselftest/tools/testing/selftests/filesystems/binderfs/binderfs_test.c:131:binderfs_test_privileged:Detected"
-                    + " binder version: 8\n"
-                    + "#            OK  global.binderfs_test_privileged\n"
-                    + "ok 2 global.binderfs_test_privileged\n"
-                    + "#  RUN           global.binderfs_test_unprivileged ...\n"
-                    + "#      SKIP      binderfs_test_unprivileged: user namespace not supported\n"
-                    + "\n"
-                    + "#            OK  global.binderfs_test_unprivileged\n"
-                    + "ok 3 # SKIP binderfs_test_unprivileged: user namespace not supported\n"
-                    + "\n"
-                    + "# PASSED: 3 / 3 tests passed.\n"
-                    + "# Totals: pass:1 fail:0 xfail:0 xpass:0 skip:2 error:\n";
+        String[] ktapResultsList = {
+            "TAP version 13\n"
+                + "1..3\n"
+                + "# Starting 3 tests from 1 test cases.\n"
+                + "#  RUN           global.binderfs_stress ...\n"
+                + "#      SKIP      binderfs_stress: user namespace not supported\n"
+                + "\n"
+                + "#            OK  global.binderfs_stress\n"
+                + "ok 1 # SKIP binderfs_stress: user namespace not supported\n"
+                + "\n"
+                + "#  RUN           global.binderfs_test_privileged ...\n"
+                + "# external/linux-kselftest/tools/testing/selftests/filesystems/binderfs/binderfs_test.c:109:binderfs_test_privileged:Allocated"
+                + " new binder device with major 506, minor 8, and name my-binder\n"
+                + "# external/linux-kselftest/tools/testing/selftests/filesystems/binderfs/binderfs_test.c:131:binderfs_test_privileged:Detected"
+                + " binder version: 8\n"
+                + "#            OK  global.binderfs_test_privileged\n"
+                + "ok 2 global.binderfs_test_privileged\n"
+                + "#  RUN           global.binderfs_test_unprivileged ...\n"
+                + "#      SKIP      binderfs_test_unprivileged: user namespace not supported\n"
+                + "\n"
+                + "#            OK  global.binderfs_test_unprivileged\n"
+                + "ok 3 # SKIP binderfs_test_unprivileged: user namespace not supported\n"
+                + "\n"
+                + "# PASSED: 3 / 3 tests passed.\n"
+                + "# Totals: pass:1 fail:0 xfail:0 xpass:0 skip:2 error:\n"
+        };
+
         String[][] expectedLeafResults = {
             {"unnamed_test_1", "IGNORED", ""},
             {"global.binderfs_test_privileged", "PASSED", ""},
             {"unnamed_test_3", "IGNORED", ""}
         };
 
-        String[] expectedRootResults = {
+        String[][] expectedSuiteResults = {
+            {"unnamed_test_1.global.binderfs_test_privileged.unnamed_test_3", "PASSED", ""}
+        };
+        String[] expectedModuleResults = {
             "unnamed_test_1.global.binderfs_test_privileged.unnamed_test_3", "PASSED", ""
         };
-        checkKTap(ktapResults, expectedLeafResults, expectedRootResults);
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
+    }
+
+    @Test
+    public void test_aggregate_kunit_module_fail() {
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "    KTAP version 1\n"
+                    + "    # Subtest: example\n"
+                    + "    1..9\n"
+                    + "    # example_simple_test: initializing\n"
+                    + "    # example_simple_test: cleaning up\n"
+                    + "    ok 1 example_simple_test\n"
+                    + "    # example_skip_test: initializing\n"
+                    + "    # example_skip_test: You should not see a line below.\n"
+                    + "    # example_skip_test: cleaning up\n"
+                    + "    ok 2 example_skip_test # SKIP this test should be skipped\n"
+                    + "    # example_mark_skipped_test: initializing\n"
+                    + "    # example_mark_skipped_test: You should see a line below.\n"
+                    + "    # example_mark_skipped_test: You should see this line.\n"
+                    + "    # example_mark_skipped_test: cleaning up\n"
+                    + "    ok 3 example_mark_skipped_test # SKIP this test should be skipped\n"
+                    + "    # example_all_expect_macros_test: initializing\n"
+                    + "    # example_all_expect_macros_test: cleaning up\n"
+                    + "    ok 4 example_all_expect_macros_test\n"
+                    + "    # example_static_stub_test: initializing\n"
+                    + "    # example_static_stub_test: cleaning up\n"
+                    + "    ok 5 example_static_stub_test\n"
+                    + "    # example_static_stub_using_fn_ptr_test: initializing\n"
+                    + "    # example_static_stub_using_fn_ptr_test: cleaning up\n"
+                    + "    ok 6 example_static_stub_using_fn_ptr_test\n"
+                    + "    # example_priv_test: initializing\n"
+                    + "    # example_priv_test: cleaning up\n"
+                    + "    ok 7 example_priv_test\n"
+                    + "        KTAP version 1\n"
+                    + "        # Subtest: example_params_test\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 1 example value 3 # SKIP unsupported param value 3\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 2 example value 2\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 3 example value 1\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 4 example value 0 # SKIP unsupported param value 0\n"
+                    + "    # example_params_test: pass:2 fail:0 skip:2 total:4\n"
+                    + "    ok 8 example_params_test\n"
+                    + "    # example_slow_test: initializing\n"
+                    + "    # example_slow_test: cleaning up\n"
+                    + "    # example_slow_test.speed: slow\n"
+                    + "    ok 9 example_slow_test\n"
+                    + "    # example: initializing suite\n"
+                    + "    # module: kunit_example_test\n"
+                    + "    # example: exiting suite\n"
+                    + "# example: pass:7 fail:0 skip:2 total:9\n"
+                    + "# Totals: pass:8 fail:0 skip:4 total:12\n"
+                    + "ok 1 example\n",
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "    KTAP version 1\n"
+                    + "    # Subtest: example_init\n"
+                    + "    1..1\n"
+                    + "    # example_init_test: FAIL\n"
+                    + "    not ok 1 example_init_test\n"
+                    + "    # module: kunit_example_test\n"
+                    + "    # is_init: true\n"
+                    + "not ok 1 example_init\n"
+        };
+
+        String[][] expectedLeafResults = {
+            {"example.example_simple_test", "PASSED", ""},
+            {"example.example_skip_test", "IGNORED", ""},
+            {"example.example_mark_skipped_test", "IGNORED", ""},
+            {"example.example_all_expect_macros_test", "PASSED", ""},
+            {"example.example_static_stub_test", "PASSED", ""},
+            {"example.example_static_stub_using_fn_ptr_test", "PASSED", ""},
+            {"example.example_priv_test", "PASSED", ""},
+            {"example.example_params_test.example_value_3", "IGNORED", ""},
+            {"example.example_params_test.example_value_2", "PASSED", ""},
+            {"example.example_params_test.example_value_1", "PASSED", ""},
+            {"example.example_params_test.example_value_0", "IGNORED", ""},
+            {"example.example_slow_test", "PASSED", ""},
+            {"example_init.example_init_test", "FAILURE", "# example_init_test: FAIL"},
+        };
+        String[][] expectedSuiteResults = {
+            {"example", "PASSED", ""},
+            {"example_init", "FAILURE", ""},
+        };
+        String[] expectedModuleResults = {"example,example_init", "FAILURE", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
+    }
+
+    @Test
+    public void test_aggregate_kunit_module_pass() {
+        String[] ktapResultsList = {
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "    KTAP version 1\n"
+                    + "    # Subtest: example\n"
+                    + "    1..9\n"
+                    + "    # example_simple_test: initializing\n"
+                    + "    # example_simple_test: cleaning up\n"
+                    + "    ok 1 example_simple_test\n"
+                    + "    # example_skip_test: initializing\n"
+                    + "    # example_skip_test: You should not see a line below.\n"
+                    + "    # example_skip_test: cleaning up\n"
+                    + "    ok 2 example_skip_test # SKIP this test should be skipped\n"
+                    + "    # example_mark_skipped_test: initializing\n"
+                    + "    # example_mark_skipped_test: You should see a line below.\n"
+                    + "    # example_mark_skipped_test: You should see this line.\n"
+                    + "    # example_mark_skipped_test: cleaning up\n"
+                    + "    ok 3 example_mark_skipped_test # SKIP this test should be skipped\n"
+                    + "    # example_all_expect_macros_test: initializing\n"
+                    + "    # example_all_expect_macros_test: cleaning up\n"
+                    + "    ok 4 example_all_expect_macros_test\n"
+                    + "    # example_static_stub_test: initializing\n"
+                    + "    # example_static_stub_test: cleaning up\n"
+                    + "    ok 5 example_static_stub_test\n"
+                    + "    # example_static_stub_using_fn_ptr_test: initializing\n"
+                    + "    # example_static_stub_using_fn_ptr_test: cleaning up\n"
+                    + "    ok 6 example_static_stub_using_fn_ptr_test\n"
+                    + "    # example_priv_test: initializing\n"
+                    + "    # example_priv_test: cleaning up\n"
+                    + "    ok 7 example_priv_test\n"
+                    + "        KTAP version 1\n"
+                    + "        # Subtest: example_params_test\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 1 example value 3 # SKIP unsupported param value 3\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 2 example value 2\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 3 example value 1\n"
+                    + "    # example_params_test: initializing\n"
+                    + "    # example_params_test: cleaning up\n"
+                    + "        ok 4 example value 0 # SKIP unsupported param value 0\n"
+                    + "    # example_params_test: pass:2 fail:0 skip:2 total:4\n"
+                    + "    ok 8 example_params_test\n"
+                    + "    # example_slow_test: initializing\n"
+                    + "    # example_slow_test: cleaning up\n"
+                    + "    # example_slow_test.speed: slow\n"
+                    + "    ok 9 example_slow_test\n"
+                    + "    # example: initializing suite\n"
+                    + "    # module: kunit_example_test\n"
+                    + "    # example: exiting suite\n"
+                    + "# example: pass:7 fail:0 skip:2 total:9\n"
+                    + "# Totals: pass:8 fail:0 skip:4 total:12\n"
+                    + "ok 1 example\n",
+            "KTAP version 1\n"
+                    + "1..1\n"
+                    + "    KTAP version 1\n"
+                    + "    # Subtest: example_init\n"
+                    + "    1..1\n"
+                    + "    ok 1 example_init_test\n"
+                    + "    # module: kunit_example_test\n"
+                    + "    # is_init: true\n"
+                    + "ok 1 example_init\n"
+        };
+
+        String[][] expectedLeafResults = {
+            {"example.example_simple_test", "PASSED", ""},
+            {"example.example_skip_test", "IGNORED", ""},
+            {"example.example_mark_skipped_test", "IGNORED", ""},
+            {"example.example_all_expect_macros_test", "PASSED", ""},
+            {"example.example_static_stub_test", "PASSED", ""},
+            {"example.example_static_stub_using_fn_ptr_test", "PASSED", ""},
+            {"example.example_priv_test", "PASSED", ""},
+            {"example.example_params_test.example_value_3", "IGNORED", ""},
+            {"example.example_params_test.example_value_2", "PASSED", ""},
+            {"example.example_params_test.example_value_1", "PASSED", ""},
+            {"example.example_params_test.example_value_0", "IGNORED", ""},
+            {"example.example_slow_test", "PASSED", ""},
+            {"example_init.example_init_test", "PASSED", ""},
+        };
+        String[][] expectedSuiteResults = {
+            {"example", "PASSED", ""},
+            {"example_init", "PASSED", ""},
+        };
+        String[] expectedModuleResults = {"example,example_init", "PASSED", ""};
+        checkKTap(
+                ktapResultsList, expectedLeafResults, expectedSuiteResults, expectedModuleResults);
     }
 
     private void checkKTap(
-            String ktapResults, String[][] expectedLeafResults, String[] expectedRootResults) {
+            String[] ktapResultsList,
+            String[][] expectedLeafResults,
+            String[][] expectedSuiteResults,
+            String[] expectedModuleResults) {
         // Setup
         String[][] expectedResults =
                 mParseResolution == KTapResultParser.ParseResolution.INDIVIDUAL_LEAVES
                         ? expectedLeafResults
-                        : new String[][] {expectedRootResults};
+                        : (mParseResolution == KTapResultParser.ParseResolution.AGGREGATED_SUITE
+                                ? expectedSuiteResults
+                                : new String[][] {expectedModuleResults});
         CollectingTestListener listener = new CollectingTestListener();
-        String moduleName = "kunit_test_module.ko";
+        String moduleName = "kunit_test_module";
         listener.testRunStarted(moduleName, 1);
 
         KTapResultParser.applyKTapResultToListener(
-                listener, moduleName, ktapResults, mParseResolution);
+                listener, moduleName, Arrays.asList(ktapResultsList), mParseResolution);
 
         listener.testRunEnded(0, new HashMap<String, Metric>());
         List<TestRunResult> testRunResults = listener.getMergedTestRunResults();
diff --git a/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java b/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java
index 799a0ac80..a63500b0b 100644
--- a/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/KUnitModuleTestTest.java
@@ -23,8 +23,8 @@ import static org.mockito.Mockito.when;
 
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.OptionSetter;
-import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.metrics.proto.MetricMeasurement;
@@ -35,15 +35,15 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.Pair;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mockito;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+
 /** Unit tests for {@link com.android.tradefed.testtype.binary.KUnitModuleTest}. */
 @RunWith(JUnit4.class)
 public class KUnitModuleTestTest {
@@ -57,7 +57,8 @@ public class KUnitModuleTestTest {
     private final CommandResult mSuccessResult;
     private final CommandResult mFailedResult;
 
-    private static final String MODULE_01 = "kunit-module-01.ko";
+    private static final String MODULE_01_KO = "kunit-module-01.ko";
+    private static final String MODULE_01 = "kunit-module-01";
     private static final String MODULE_NAME_01 = "kunit_module_01";
     private static final String KTAP_RESULTS_01 =
             "KTAP version 1\n"
@@ -76,7 +77,8 @@ public class KUnitModuleTestTest {
                     + "  ok 2 example_test_2\n"
                     + "ok 1 main_test_01\n";
 
-    private static final String MODULE_02 = "kunit-module-02.ko";
+    private static final String MODULE_02_KO = "kunit-module-02.ko";
+    private static final String MODULE_02 = "kunit-module-02";
     private static final String MODULE_NAME_02 = "kunit_module_02";
     private static final String KTAP_RESULTS_02 =
             "KTAP version 1\n"
@@ -129,8 +131,9 @@ public class KUnitModuleTestTest {
         mKUnitModuleTest.setDevice(mMockDevice);
 
         OptionSetter setter = new OptionSetter(mKUnitModuleTest);
-        setter.setOptionValue("binary", MODULE_NAME_01, MODULE_01);
-        setter.setOptionValue("binary", MODULE_NAME_02, MODULE_02);
+        setter.setOptionValue("binary", MODULE_NAME_01, MODULE_01_KO);
+        setter.setOptionValue("binary", MODULE_NAME_02, MODULE_02_KO);
+        setter.setOptionValue("ktap-result-parser-resolution", "AGGREGATED_SUITE");
 
         // For 2 modules: first rmmod call expect fail, second rmmod call expect pass
         when(mMockDevice.executeShellV2Command(
@@ -174,10 +177,12 @@ public class KUnitModuleTestTest {
 
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         for (TestDescription testDescription : testDescriptions) {
-            Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testDescription));
+            Mockito.verify(mListener, Mockito.times(1))
+                    .testStarted(Mockito.eq(testDescription), Mockito.anyLong());
             Mockito.verify(mListener, Mockito.times(1))
                     .testEnded(
                             Mockito.eq(testDescription),
+                            Mockito.anyLong(),
                             Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         }
 
@@ -192,13 +197,13 @@ public class KUnitModuleTestTest {
 
         // First module loads successfully
         when(mMockDevice.executeShellV2Command(
-                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, MODULE_01)),
+                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, MODULE_01_KO)),
                         anyLong(),
                         any()))
                 .thenReturn(mSuccessResult);
         // Second module set fail on load
         when(mMockDevice.executeShellV2Command(
-                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, MODULE_02)),
+                        startsWith(String.format(KUnitModuleTest.INSMOD_COMMAND_FMT, MODULE_02_KO)),
                         anyLong(),
                         any()))
                 .thenReturn(mFailedResult);
@@ -206,17 +211,14 @@ public class KUnitModuleTestTest {
         // Run test
         mKUnitModuleTest.run(mTestInfo, mListener);
 
-        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults =
-                new ArrayList<>() {
-                    {
-                        add(Pair.create(new TestDescription(MODULE_01, "main_test_01"), true));
-                        add(Pair.create(new TestDescription(MODULE_02, MODULE_02), false));
-                    }
-                };
+        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults = new ArrayList<>();
+        expectedTestResults.add(Pair.create(new TestDescription(MODULE_01, "main_test_01"), true));
+        expectedTestResults.add(Pair.create(new TestDescription(MODULE_02, MODULE_02), false));
 
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         for (Pair<TestDescription, Boolean> testResult : expectedTestResults) {
-            Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testResult.first));
+            Mockito.verify(mListener, Mockito.times(1))
+                    .testStarted(Mockito.eq(testResult.first), Mockito.anyLong());
             if (!testResult.second) {
                 Mockito.verify(mListener, Mockito.times(1))
                         .testFailed(Mockito.eq(testResult.first), any(FailureDescription.class));
@@ -224,6 +226,7 @@ public class KUnitModuleTestTest {
             Mockito.verify(mListener, Mockito.times(1))
                     .testEnded(
                             Mockito.eq(testResult.first),
+                            Mockito.anyLong(),
                             Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         }
 
@@ -244,16 +247,14 @@ public class KUnitModuleTestTest {
         // Run test
         mKUnitModuleTest.run(mTestInfo, mListener);
 
-        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults =
-                new ArrayList<>() {
-                    {
-                        add(Pair.create(new TestDescription(MODULE_01, "main_test_01"), true));
-                        add(Pair.create(new TestDescription(MODULE_02, MODULE_02), false));
-                    }
-                };
+        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults = new ArrayList<>();
+        expectedTestResults.add(Pair.create(new TestDescription(MODULE_01, "main_test_01"), true));
+        expectedTestResults.add(Pair.create(new TestDescription(MODULE_02, MODULE_02), false));
+
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         for (Pair<TestDescription, Boolean> testResult : expectedTestResults) {
-            Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testResult.first));
+            Mockito.verify(mListener, Mockito.times(1))
+                    .testStarted(Mockito.eq(testResult.first), Mockito.anyLong());
             if (!testResult.second) {
                 Mockito.verify(mListener, Mockito.times(1))
                         .testFailed(Mockito.eq(testResult.first), any(FailureDescription.class));
@@ -261,6 +262,7 @@ public class KUnitModuleTestTest {
             Mockito.verify(mListener, Mockito.times(1))
                     .testEnded(
                             Mockito.eq(testResult.first),
+                            Mockito.anyLong(),
                             Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         }
 
@@ -284,16 +286,14 @@ public class KUnitModuleTestTest {
         // Run test
         mKUnitModuleTest.run(mTestInfo, mListener);
 
-        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults =
-                new ArrayList<>() {
-                    {
-                        add(Pair.create(new TestDescription(MODULE_01, "main_test_01"), true));
-                        add(Pair.create(new TestDescription(MODULE_02, MODULE_02), false));
-                    }
-                };
+        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults = new ArrayList<>();
+        expectedTestResults.add(Pair.create(new TestDescription(MODULE_01, "main_test_01"), true));
+        expectedTestResults.add(Pair.create(new TestDescription(MODULE_02, MODULE_02), false));
+
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(Mockito.any(), eq(2));
         for (Pair<TestDescription, Boolean> testResult : expectedTestResults) {
-            Mockito.verify(mListener, Mockito.times(1)).testStarted(Mockito.eq(testResult.first));
+            Mockito.verify(mListener, Mockito.times(1))
+                    .testStarted(Mockito.eq(testResult.first), Mockito.anyLong());
             if (!testResult.second) {
                 Mockito.verify(mListener, Mockito.times(1))
                         .testFailed(Mockito.eq(testResult.first), any(FailureDescription.class));
@@ -301,6 +301,7 @@ public class KUnitModuleTestTest {
             Mockito.verify(mListener, Mockito.times(1))
                     .testEnded(
                             Mockito.eq(testResult.first),
+                            Mockito.anyLong(),
                             Mockito.eq(new HashMap<String, MetricMeasurement.Metric>()));
         }
 
diff --git a/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java b/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java
index 363b4c373..c005c2ddd 100644
--- a/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java
@@ -35,15 +35,15 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.Pair;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mockito;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+
 /** Unit tests for {@link com.android.tradefed.testtype.binary.KernelTargetTest}. */
 @RunWith(JUnit4.class)
 public class KernelTargetTestTest {
@@ -189,18 +189,24 @@ public class KernelTargetTestTest {
 
         // Both tests should run
         TestDescription testDescription = new TestDescription(TEST_NAME_1, TEST_NAME_1);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(eq(testDescription));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never()).testIgnored(eq(testDescription));
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
-                        eq(testDescription), eq(new HashMap<String, MetricMeasurement.Metric>()));
+                        eq(testDescription),
+                        Mockito.anyLong(),
+                        eq(new HashMap<String, MetricMeasurement.Metric>()));
 
         TestDescription testDescription2 = new TestDescription(TEST_NAME_2, TEST_NAME_2);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never()).testIgnored(eq(testDescription2));
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
-                        eq(testDescription2), eq(new HashMap<String, MetricMeasurement.Metric>()));
+                        eq(testDescription2),
+                        Mockito.anyLong(),
+                        eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(anyLong(), Mockito.<HashMap<String, MetricMeasurement.Metric>>any());
     }
@@ -239,19 +245,25 @@ public class KernelTargetTestTest {
 
         // First test should be ignored
         TestDescription testDescription = new TestDescription(TEST_NAME_1, TEST_NAME_1);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(eq(testDescription));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(eq(testDescription), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.times(1)).testIgnored(eq(testDescription));
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
-                        eq(testDescription), eq(new HashMap<String, MetricMeasurement.Metric>()));
+                        eq(testDescription),
+                        Mockito.anyLong(),
+                        eq(new HashMap<String, MetricMeasurement.Metric>()));
 
         // Second test should be run
         TestDescription testDescription2 = new TestDescription(TEST_NAME_2, TEST_NAME_2);
-        Mockito.verify(mListener, Mockito.times(1)).testStarted(eq(testDescription2));
+        Mockito.verify(mListener, Mockito.times(1))
+                .testStarted(eq(testDescription2), Mockito.anyLong());
         Mockito.verify(mListener, Mockito.never()).testIgnored(eq(testDescription2));
         Mockito.verify(mListener, Mockito.times(1))
                 .testEnded(
-                        eq(testDescription2), eq(new HashMap<String, MetricMeasurement.Metric>()));
+                        eq(testDescription2),
+                        Mockito.anyLong(),
+                        eq(new HashMap<String, MetricMeasurement.Metric>()));
         Mockito.verify(mListener, Mockito.times(1))
                 .testRunEnded(anyLong(), Mockito.<HashMap<String, MetricMeasurement.Metric>>any());
     }
@@ -264,12 +276,9 @@ public class KernelTargetTestTest {
         Mockito.when(mMockITestDevice.executeShellV2Command(eq(TEST_CMD_1), anyLong(), any()))
                 .thenReturn(mCommandResult);
 
-        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults =
-                new ArrayList<>() {
-                    {
-                        add(Pair.create(new TestDescription(TEST_NAME_1, "main_test_01"), true));
-                    }
-                };
+        ArrayList<Pair<TestDescription, Boolean>> expectedTestResults = new ArrayList<>();
+        expectedTestResults.add(
+                Pair.create(new TestDescription(TEST_NAME_1, "main_test_01"), true));
 
         mKernelTargetTest = new KernelTargetTest();
         mKernelTargetTest.setDevice(mMockITestDevice);
@@ -282,7 +291,8 @@ public class KernelTargetTestTest {
 
         Mockito.verify(mListener, Mockito.times(1)).testRunStarted(any(), eq(1));
         for (Pair<TestDescription, Boolean> testResult : expectedTestResults) {
-            Mockito.verify(mListener, Mockito.times(1)).testStarted(eq(testResult.first));
+            Mockito.verify(mListener, Mockito.times(1))
+                    .testStarted(eq(testResult.first), Mockito.anyLong());
             if (!testResult.second) {
                 Mockito.verify(mListener, Mockito.times(1))
                         .testFailed(Mockito.eq(testResult.first), any(FailureDescription.class));
@@ -290,6 +300,7 @@ public class KernelTargetTestTest {
             Mockito.verify(mListener, Mockito.times(1))
                     .testEnded(
                             eq(testResult.first),
+                            Mockito.anyLong(),
                             eq(new HashMap<String, MetricMeasurement.Metric>()));
         }
         Mockito.verify(mListener, Mockito.times(1))
diff --git a/javatests/com/android/tradefed/testtype/junit4/BaseHostJUnit4TestTest.java b/javatests/com/android/tradefed/testtype/junit4/BaseHostJUnit4TestTest.java
index f3a96e128..965726120 100644
--- a/javatests/com/android/tradefed/testtype/junit4/BaseHostJUnit4TestTest.java
+++ b/javatests/com/android/tradefed/testtype/junit4/BaseHostJUnit4TestTest.java
@@ -22,7 +22,6 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.config.ConfigurationDef;
 import com.android.tradefed.config.OptionSetter;
@@ -38,6 +37,7 @@ import com.android.tradefed.result.CollectingTestListener;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.ITestLifeCycleReceiver;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.targetprep.suite.SuiteApkInstaller;
 import com.android.tradefed.testtype.Abi;
diff --git a/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java b/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java
index 1a283b895..9e62e5f0b 100644
--- a/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java
@@ -71,7 +71,6 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 /** Unit tests for {@link MoblyBinaryHostTest}. */
 @RunWith(JUnit4.class)
@@ -734,98 +733,6 @@ public class MoblyBinaryHostTestTest {
                         contains("--log_path="));
     }
 
-    @Test
-    public void testRun_withInvalidIncludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-        OptionSetter setter = new OptionSetter(mSpyTest);
-        setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
-        File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
-        mSpyTest.addIncludeFilter("test_bar");
-        Mockito.when(mMockRunUtil.runTimedCmd(anyLong(), any()))
-                .thenAnswer(
-                        invocation -> {
-                            CommandResult res = new CommandResult(CommandStatus.SUCCESS);
-                            res.setStdout("==========> FooTest <==========\ntest_foo");
-                            return res;
-                        })
-                .thenAnswer(
-                        invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
-                            return new CommandResult(CommandStatus.SUCCESS);
-                        });
-
-        ITestInvocationListener mockListener = Mockito.mock(ITestInvocationListener.class);
-
-        mSpyTest.run(mTestInfo, mockListener);
-
-        verify(mockListener, times(1)).testRunStarted(anyString(), eq(0));
-        verify(mockListener, times(1)).testRunFailed(any(FailureDescription.class));
-        verify(mockListener, times(1)).testRunEnded(eq(0L), eq(new HashMap<String, Metric>()));
-    }
-
-    @Test
-    public void testRun_withInvalidExcludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-        OptionSetter setter = new OptionSetter(mSpyTest);
-        setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
-        File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
-        mSpyTest.addExcludeFilter("test_bar");
-        Mockito.when(mMockRunUtil.runTimedCmd(anyLong(), any()))
-                .thenAnswer(
-                        invocation -> {
-                            CommandResult res = new CommandResult(CommandStatus.SUCCESS);
-                            res.setStdout("==========> FooTest <==========\ntest_foo");
-                            return res;
-                        })
-                .thenAnswer(
-                        invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
-                            return new CommandResult(CommandStatus.SUCCESS);
-                        });
-
-        ITestInvocationListener mockListener = Mockito.mock(ITestInvocationListener.class);
-
-        mSpyTest.run(mTestInfo, mockListener);
-
-        verify(mockListener, times(1)).testRunStarted(anyString(), eq(0));
-    }
-
-    @Test
-    public void testRun_withInvalidExcludeFiltersPrefix() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-        OptionSetter setter = new OptionSetter(mSpyTest);
-        setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
-        File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
-        mSpyTest.addExcludeFilter("test_f");
-        Mockito.when(mMockRunUtil.runTimedCmd(anyLong(), any()))
-                .thenAnswer(
-                        invocation -> {
-                            CommandResult res = new CommandResult(CommandStatus.SUCCESS);
-                            res.setStdout("==========> FooTest <==========\ntest_foo");
-                            return res;
-                        })
-                .thenAnswer(
-                        invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
-                            return new CommandResult(CommandStatus.SUCCESS);
-                        });
-
-        ITestInvocationListener mockListener = Mockito.mock(ITestInvocationListener.class);
-
-        mSpyTest.run(mTestInfo, mockListener);
-
-        verify(mockListener, times(1)).testRunStarted(anyString(), eq(0));
-    }
-
     @Test
     public void testRun_withIncludeFiltersExact() throws Exception {
         Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
@@ -1133,154 +1040,6 @@ public class MoblyBinaryHostTestTest {
         }
     }
 
-    @Test
-    public void testFilterTests_withInvalidIncludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-
-        Set<String> invalidIncludeFilters =
-                Set.of(
-                        "FooTest#test_bar_1",
-                        "BarTest#test_foo_1",
-                        "BazTest#test_baz_1",
-                        "BazTest#",
-                        "BazTest",
-                        "#test_baz_1",
-                        "test_baz_1",
-                        "#test_baz",
-                        "test_baz",
-                        "foo",
-                        "foo_test",
-                        "bar",
-                        "bar_test",
-                        "baz",
-                        "baz_test",
-                        "@#!",
-                        "",
-                        "#",
-                        ".");
-
-        Set<String> validIncludeFilters =
-                Set.of(
-                        "FooTest#test_foo_1",
-                        "FooTest#test_foo_2",
-                        "BarTest#test_bar_1",
-                        "BarTest#test_bar_2",
-                        "FooTest#",
-                        "FooTest",
-                        "BarTest#",
-                        "BarTest",
-                        "#test_foo",
-                        "test_foo",
-                        "#test_bar",
-                        "test_bar",
-                        "#test_",
-                        "test_");
-
-        mSpyTest.addAllIncludeFilters(invalidIncludeFilters);
-        mSpyTest.addAllIncludeFilters(validIncludeFilters);
-
-        ITestInvocationListener mockListener = Mockito.mock(ITestInvocationListener.class);
-
-        mSpyTest.filterTests(
-                new String[] {
-                    "invalid line",
-                    "==========> FooTest <==========",
-                    "FooTest.test_foo_1",
-                    "test_foo_2",
-                    "==========> BarTest <==========",
-                    "BarTest.test_bar_1",
-                    "test_bar_2",
-                },
-                BINARY_PATH,
-                mockListener);
-
-        String invalidIncludeFiltersString =
-                invalidIncludeFilters.stream().collect(Collectors.joining(", "));
-
-        FailureDescription failureDescription =
-                FailureDescription.create(
-                        "Invalid include filters: [" + invalidIncludeFiltersString + "]",
-                        TestRecordProto.FailureStatus.TEST_FAILURE);
-
-        verify(mockListener, times(1)).testRunStarted(anyString(), eq(0));
-        verify(mockListener, times(1)).testRunFailed(eq(failureDescription));
-        verify(mockListener, times(1)).testRunEnded(eq(0L), eq(new HashMap<String, Metric>()));
-    }
-
-    @Test
-    public void testFilterTests_withInvalidExcludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-
-        Set<String> invalidExcludeFilters =
-                Set.of(
-                        "FooTest#test_bar_1",
-                        "BarTest#test_foo_1",
-                        "BazTest#test_baz_1",
-                        "BazTest#",
-                        "BazTest",
-                        "#test_foo",
-                        "test_foo",
-                        "#test_bar",
-                        "test_bar",
-                        "#test_",
-                        "test_",
-                        "#test_baz_1",
-                        "test_baz_1",
-                        "#test_baz",
-                        "test_baz",
-                        "foo",
-                        "foo_test",
-                        "bar",
-                        "bar_test",
-                        "baz",
-                        "baz_test",
-                        "@#!",
-                        "",
-                        "#",
-                        ".");
-
-        Set<String> validExcludeFilters =
-                Set.of(
-                        "FooTest#test_foo_1",
-                        "FooTest#test_foo_2",
-                        "BarTest#test_bar_1",
-                        "BarTest#test_bar_2",
-                        "FooTest#",
-                        "FooTest",
-                        "BarTest#",
-                        "BarTest");
-
-        mSpyTest.addAllExcludeFilters(invalidExcludeFilters);
-        mSpyTest.addAllExcludeFilters(validExcludeFilters);
-
-        ITestInvocationListener mockListener = Mockito.mock(ITestInvocationListener.class);
-
-        mSpyTest.filterTests(
-                new String[] {
-                    "invalid line",
-                    "==========> FooTest <==========",
-                    "FooTest.test_foo_1",
-                    "test_foo_2",
-                    "==========> BarTest <==========",
-                    "BarTest.test_bar_1",
-                    "test_bar_2",
-                },
-                BINARY_PATH,
-                mockListener);
-
-        String invalidExcludeFiltersString =
-                invalidExcludeFilters.stream().collect(Collectors.joining(", "));
-
-        FailureDescription failureDescription =
-                FailureDescription.create(
-                        "Invalid exclude filters: [" + invalidExcludeFiltersString + "]",
-                        TestRecordProto.FailureStatus.TEST_FAILURE);
-
-        verify(mockListener, times(1)).testRunStarted(anyString(), eq(0));
-        verify(mockListener, times(1)).testRunFailed(eq(failureDescription));
-        verify(mockListener, times(1)).testRunEnded(eq(0L), eq(new HashMap<String, Metric>()));
-    }
-
     @Test
     public void testFilterTests_withIncludeFilters() throws Exception {
         Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
diff --git a/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java b/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java
new file mode 100644
index 000000000..9e14aa50d
--- /dev/null
+++ b/javatests/com/android/tradefed/testtype/pandora/PtsBotTestTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.testtype.pandora;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.util.FileUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.io.File;
+
+/** Unit tests for {@link PtsBotTest}. */
+@RunWith(JUnit4.class)
+public class PtsBotTestTest {
+
+    private PtsBotTest mSpyTest;
+    private ITestDevice mMockDevice;
+    private TestInformation mTestInfo;
+    private File mPandoraTestDir;
+    private File mConfigFlagsFile;
+
+    @Before
+    public void setup() throws Exception {
+        mSpyTest = Mockito.spy(new PtsBotTest());
+        mMockDevice = Mockito.mock(ITestDevice.class);
+        IInvocationContext context = new InvocationContext();
+        context.addAllocatedDevice("device", mMockDevice);
+        mPandoraTestDir = FileUtil.createTempDir("pandora_tests");
+        mConfigFlagsFile =
+                FileUtil.createTempFile("pts_bot_tests_config", ".json", mPandoraTestDir);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        FileUtil.recursiveDelete(mPandoraTestDir);
+    }
+
+    @Test
+    public void testParse_configFlagsFile() throws Exception {
+        String flag = "baguette_flag";
+        String jsonString =
+                String.format(
+                        "{\"flags\":[{\"flags\":[\"%s\"],\"tests\":[\"test1\",\"test2\"]}]}", flag);
+        FileUtil.writeToFile(jsonString, mConfigFlagsFile);
+
+        mSpyTest.initFlagsConfig(mMockDevice, mConfigFlagsFile);
+        PtsBotTest.TestFlagConfiguration config = mSpyTest.getTestFlagConfiguration();
+
+        assertThat(config.flags).isNotEmpty();
+        assertThat(config.flags.get(0).flags).containsExactly(flag);
+        assertThat(config.flags.get(0).tests).containsExactly("test1", "test2");
+
+        mSpyTest.getTestFlagConfiguration().flags.clear();
+    }
+
+    @Test
+    public void testParse_emptyConfigFlagsFile() throws Exception {
+        String json_string = String.format("{\"flags\": []}");
+        FileUtil.writeToFile(json_string, mConfigFlagsFile);
+
+        mSpyTest.initFlagsConfig(mMockDevice, mConfigFlagsFile);
+
+        assertThat(mSpyTest.getTestFlagConfiguration().flags).isEmpty();
+    }
+}
diff --git a/javatests/com/android/tradefed/testtype/python/PythonBinaryHostTestTest.java b/javatests/com/android/tradefed/testtype/python/PythonBinaryHostTestTest.java
index 73abb909f..20d05282d 100644
--- a/javatests/com/android/tradefed/testtype/python/PythonBinaryHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/python/PythonBinaryHostTestTest.java
@@ -20,6 +20,8 @@ import static com.android.tradefed.testtype.python.PythonBinaryHostTest.USE_TEST
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
@@ -27,6 +29,10 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.StubDevice;
@@ -45,6 +51,7 @@ import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.IRunUtil.EnvPriority;
+import com.android.tradefed.util.RunUtilTest;
 import com.android.tradefed.util.StreamUtil;
 
 import org.junit.After;
@@ -77,15 +84,18 @@ public final class PythonBinaryHostTestTest {
     private TestInformation mTestInfo;
     @Mock ITestInvocationListener mMockListener;
     private File mFakeAdb;
+    private File mFakeAapt;
     private File mPythonBinary;
     private File mOutputFile;
     private File mModuleDir;
+    private RunUtilTest.FakeCacheClient mFakeCacheClient;
 
     @Before
     public void setUp() throws Exception {
         MockitoAnnotations.initMocks(this);
 
         mFakeAdb = FileUtil.createTempFile("adb-python-tests", "");
+        mFakeAapt = FileUtil.createTempFile("aapt-python-tests", "");
 
         mTest =
                 new PythonBinaryHostTest() {
@@ -94,6 +104,16 @@ public final class PythonBinaryHostTestTest {
                         return mMockRunUtil;
                     }
 
+                    @Override
+                    File getAdb() {
+                        return mFakeAdb;
+                    }
+
+                    @Override
+                    File getAapt() {
+                        return mFakeAapt;
+                    }
+
                     @Override
                     String getAdbPath() {
                         return mFakeAdb.getAbsolutePath();
@@ -112,14 +132,61 @@ public final class PythonBinaryHostTestTest {
         mModuleDir = FileUtil.createTempDir("python-module");
         mPythonBinary = FileUtil.createTempFile("python-dir", "", mModuleDir);
         mTestInfo.executionFiles().put(FilesKey.HOST_TESTS_DIRECTORY, new File("/path-not-exist"));
+        mFakeCacheClient = new RunUtilTest.FakeCacheClient();
     }
 
     @After
     public void tearDown() throws Exception {
         FileUtil.deleteFile(mFakeAdb);
+        FileUtil.deleteFile(mFakeAapt);
         FileUtil.deleteFile(mPythonBinary);
         FileUtil.deleteFile(mOutputFile);
         FileUtil.recursiveDelete(mModuleDir);
+        mFakeCacheClient.getAllCache().values().stream()
+                .forEach(
+                        a -> {
+                            FileUtil.deleteFile(a.stdOut());
+                            FileUtil.deleteFile(a.stdErr());
+                        });
+    }
+
+    /** Test that a success python host test run is uploaded to cache service. */
+    @Test
+    public void testRun_upload_cache_for_success_run() throws Exception {
+        PythonBinaryHostTest pyTest =
+                createPythonBinaryHostTestWithCache(
+                        "echo \"hello_world_test (__main__.HelloWorldTest.hello_world_test) ..."
+                            + " ok\n\n"
+                            + "----------------------------------------------------------------------\n"
+                            + "Ran 1 test in 0.001s\n\n"
+                            + "OK\n"
+                            + "\" >&2");
+
+        pyTest.run(mTestInfo, mMockListener);
+
+        assertFalse(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
+    /** Test that a failed python host test run is not uploaded to cache service. */
+    @Test
+    public void testRun_skip_cache_uploading_for_failed_run() throws Exception {
+        PythonBinaryHostTest pyTest =
+                createPythonBinaryHostTestWithCache(
+                        "echo \"hello_world_test (__main__.HelloWorldTest.hello_world_test) ..."
+                            + " FAIL \n\n"
+                            + "======================================================================\n"
+                            + "FAIL: hello_world_test (__main__.HelloWorldTest.hello_world_test)\n"
+                            + "----------------------------------------------------------------------\n"
+                            + "Traceback (most recent call last):\n"
+                            + "  File \"hello_world_test.py\", line 666, in hello_world_test\n"
+                            + "AssertionError: True is not false\n\n"
+                            + "----------------------------------------------------------------------\n"
+                            + "Ran 1 test in 0.001sFAILED (failures=1)\n"
+                            + "\" >&2");
+
+        pyTest.run(mTestInfo, mMockListener);
+
+        assertTrue(mFakeCacheClient.getAllCache().isEmpty());
     }
 
     /** Test that when running a python binary the output is parsed to obtain results. */
@@ -134,6 +201,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             res.setStdout("python binary stdout.");
             res.setStderr(FileUtil.readStringFromFile(mOutputFile));
@@ -151,23 +219,24 @@ public final class PythonBinaryHostTestTest {
 
             when(mMockDevice.getIDevice()).thenReturn(new StubDevice("serial"));
 
+            mTest.run(mTestInfo, mMockListener);
             mTest.run(mTestInfo, mMockListener);
 
-            verify(mMockRunUtil)
-                    .setEnvVariable("PATH", String.format("%s:bin/", mFakeAdb.getParent()));
-            verify(mMockRunUtil).setEnvVariable(Mockito.eq("LD_LIBRARY_PATH"), Mockito.any());
-            verify(mMockListener)
+            verify(mMockRunUtil, times(2)).setEnvVariable("PATH", ".:runtime_deps:/usr/bin");
+            verify(mMockRunUtil, times(2))
+                    .setEnvVariable(Mockito.eq("LD_LIBRARY_PATH"), Mockito.any());
+            verify(mMockListener, times(2))
                     .testRunStarted(
                             Mockito.eq(mPythonBinary.getName()),
                             Mockito.eq(11),
                             Mockito.eq(0),
                             Mockito.anyLong());
-            verify(mMockListener)
+            verify(mMockListener, times(2))
                     .testLog(
                             Mockito.eq(mPythonBinary.getName() + "-stdout"),
                             Mockito.eq(LogDataType.TEXT),
                             Mockito.any());
-            verify(mMockListener)
+            verify(mMockListener, times(2))
                     .testLog(
                             Mockito.eq(mPythonBinary.getName() + "-stderr"),
                             Mockito.eq(LogDataType.TEXT),
@@ -190,13 +259,16 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             res.setStderr(FileUtil.readStringFromFile(mOutputFile));
             when(mMockRunUtil.runTimedCmd(
                             Mockito.anyLong(),
                             Mockito.isNull(),
                             (OutputStream) Mockito.any(),
-                            Mockito.eq(mPythonBinary.getAbsolutePath())))
+                            Mockito.eq(mPythonBinary.getAbsolutePath()),
+                            Mockito.eq("-k"),
+                            Mockito.eq("test1")))
                     .thenAnswer(
                             invocation -> {
                                 throw new RuntimeException("Parser error");
@@ -238,6 +310,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             String output =
                     "test_1 (__main__.Class1)\n"
@@ -253,7 +326,9 @@ public final class PythonBinaryHostTestTest {
                             Mockito.anyLong(),
                             Mockito.isNull(),
                             (OutputStream) Mockito.any(),
-                            Mockito.eq(mPythonBinary.getAbsolutePath())))
+                            Mockito.eq(mPythonBinary.getAbsolutePath()),
+                            Mockito.eq("-k"),
+                            Mockito.eq("test_1")))
                     .thenAnswer(
                             invocation -> {
                                 OutputStream stream = (OutputStream) invocation.getArguments()[2];
@@ -293,6 +368,142 @@ public final class PythonBinaryHostTestTest {
         }
     }
 
+    /**
+     * Test that when running a python binary with include filters containing the fully qualified
+     * class name, the filters are passed to the run command.
+     */
+    @Test
+    public void testRun_withIncludeFiltersClass_addsClassNameToCmd() throws Exception {
+        try {
+            OptionSetter setter = new OptionSetter(mTest);
+            setter.setOptionValue("python-binaries", mPythonBinary.getAbsolutePath());
+            mTest.addIncludeFilter("__main__.Class1");
+
+            expectedAdbPath();
+
+            CommandResult res = new CommandResult();
+            res.setExitCode(0);
+            res.setStatus(CommandStatus.SUCCESS);
+            String output =
+                    "test_1 (__main__.Class1)\n"
+                        + "run first test. ... ok\n"
+                        + "test_2 (__main__.Class1)\n"
+                        + "run second test. ... ok\n"
+                        + "----------------------------------------------------------------------\n"
+                        + "Ran 2 tests in 1s\n";
+            res.setStderr(output);
+            when(mMockRunUtil.runTimedCmd(
+                            Mockito.anyLong(),
+                            Mockito.isNull(),
+                            (OutputStream) Mockito.any(),
+                            Mockito.eq(mPythonBinary.getAbsolutePath()),
+                            Mockito.eq("-k"),
+                            Mockito.eq("__main__.Class1")))
+                    .thenAnswer(
+                            invocation -> {
+                                OutputStream stream = (OutputStream) invocation.getArguments()[2];
+                                StreamUtil.copyStreams(
+                                        new ByteArrayInputStream(output.getBytes()), stream);
+                                return res;
+                            });
+            when(mMockDevice.getIDevice()).thenReturn(new StubDevice("serial"));
+
+            mTest.run(mTestInfo, mMockListener);
+
+            verify(mMockRunUtil)
+                    .setEnvVariable("PATH", String.format("%s:bin/", mFakeAdb.getParent()));
+            verify(mMockRunUtil).setEnvVariable(Mockito.eq("LD_LIBRARY_PATH"), Mockito.any());
+            verify(mMockListener)
+                    .testRunStarted(
+                            Mockito.eq(mPythonBinary.getName()),
+                            Mockito.eq(2),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener)
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener, times(2)).testStarted(Mockito.any(), Mockito.anyLong());
+            verify(mMockListener, times(2))
+                    .testEnded(
+                            Mockito.<TestDescription>any(),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener)
+                    .testLog(
+                            Mockito.eq(mPythonBinary.getName() + "-stderr"),
+                            Mockito.eq(LogDataType.TEXT),
+                            Mockito.any());
+        } finally {
+            FileUtil.deleteFile(mPythonBinary);
+        }
+    }
+
+    /**
+     * Test that when running a python binary with include filters that use the class#method format,
+     * only the method name is passed to the run command.
+     */
+    @Test
+    public void testRun_withIncludeFiltersClassAndMethod_addsMethodNameToCmd() throws Exception {
+        try {
+            OptionSetter setter = new OptionSetter(mTest);
+            setter.setOptionValue("python-binaries", mPythonBinary.getAbsolutePath());
+            mTest.addIncludeFilter("__main__.Class1#test_1");
+
+            expectedAdbPath();
+
+            CommandResult res = new CommandResult();
+            res.setExitCode(0);
+            res.setStatus(CommandStatus.SUCCESS);
+            String output =
+                    "test_1 (__main__.Class1)\n"
+                        + "run first test. ... ok\n"
+                        + "----------------------------------------------------------------------\n"
+                        + "Ran 1 tests in 1s\n";
+            res.setStderr(output);
+            when(mMockRunUtil.runTimedCmd(
+                            Mockito.anyLong(),
+                            Mockito.isNull(),
+                            (OutputStream) Mockito.any(),
+                            Mockito.eq(mPythonBinary.getAbsolutePath()),
+                            Mockito.eq("-k"),
+                            Mockito.eq("test_1")))
+                    .thenAnswer(
+                            invocation -> {
+                                OutputStream stream = (OutputStream) invocation.getArguments()[2];
+                                StreamUtil.copyStreams(
+                                        new ByteArrayInputStream(output.getBytes()), stream);
+                                return res;
+                            });
+            when(mMockDevice.getIDevice()).thenReturn(new StubDevice("serial"));
+
+            mTest.run(mTestInfo, mMockListener);
+
+            verify(mMockRunUtil)
+                    .setEnvVariable("PATH", String.format("%s:bin/", mFakeAdb.getParent()));
+            verify(mMockRunUtil).setEnvVariable(Mockito.eq("LD_LIBRARY_PATH"), Mockito.any());
+            verify(mMockListener)
+                    .testRunStarted(
+                            Mockito.eq(mPythonBinary.getName()),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener)
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener, times(1)).testStarted(Mockito.any(), Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testEnded(
+                            Mockito.<TestDescription>any(),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener)
+                    .testLog(
+                            Mockito.eq(mPythonBinary.getName() + "-stderr"),
+                            Mockito.eq(LogDataType.TEXT),
+                            Mockito.any());
+        } finally {
+            FileUtil.deleteFile(mPythonBinary);
+        }
+    }
+
     /**
      * Test that when running a python binary with exclude filters, the output is parsed to obtain
      * results.
@@ -307,6 +518,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             String output =
                     "test_1 (__main__.Class1)\n"
@@ -379,6 +591,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             res.setStderr(FileUtil.readStringFromFile(mOutputFile));
             when(mMockRunUtil.runTimedCmd(
@@ -437,6 +650,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             res.setStderr(FileUtil.readStringFromFile(mOutputFile));
             when(mMockRunUtil.runTimedCmd(
@@ -501,6 +715,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(0);
             res.setStatus(CommandStatus.SUCCESS);
             res.setStderr(FileUtil.readStringFromFile(mOutputFile));
             when(mMockRunUtil.runTimedCmd(
@@ -558,6 +773,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(1);
             res.setStatus(CommandStatus.EXCEPTION);
             res.setStderr("Could not execute.");
             String output = "Could not execute.";
@@ -619,6 +835,7 @@ public final class PythonBinaryHostTestTest {
             expectedAdbPath();
 
             CommandResult res = new CommandResult();
+            res.setExitCode(1);
             res.setStatus(CommandStatus.FAILED);
             res.setStderr(FileUtil.readStringFromFile(mOutputFile));
             when(mMockRunUtil.runTimedCmd(
@@ -753,6 +970,7 @@ public final class PythonBinaryHostTestTest {
 
     private static CommandResult newCommandResult(CommandStatus status, String stderr) {
         CommandResult res = new CommandResult();
+        res.setExitCode(0);
         res.setStatus(status);
         res.setStderr(stderr);
         return res;
@@ -784,11 +1002,13 @@ public final class PythonBinaryHostTestTest {
 
     private void expectedAdbPath() {
         CommandResult pathRes = new CommandResult();
+        pathRes.setExitCode(0);
         pathRes.setStatus(CommandStatus.SUCCESS);
         pathRes.setStdout("bin/");
         when(mMockRunUtil.runTimedCmd(60000L, "/bin/bash", "-c", "echo $PATH")).thenReturn(pathRes);
 
         CommandResult versionRes = new CommandResult();
+        versionRes.setExitCode(0);
         versionRes.setStatus(CommandStatus.SUCCESS);
         versionRes.setStdout("bin/");
         when(mMockRunUtil.runTimedCmd(60000L, "adb", "version")).thenReturn(versionRes);
@@ -803,4 +1023,29 @@ public final class PythonBinaryHostTestTest {
         FileUtil.writeToFile(stream, output);
         return output;
     }
+
+    private PythonBinaryHostTest createPythonBinaryHostTestWithCache(String scriptContent)
+            throws Exception {
+        PythonBinaryHostTest pyTest =
+                new PythonBinaryHostTest() {
+                    @Override
+                    ICacheClient getCacheClient(File workFolder, String instanceName) {
+                        return mFakeCacheClient;
+                    }
+                };
+        File binary =
+                new File(FileUtil.createTempDir("hosttestcases", mModuleDir), "hello_world_test");
+        FileUtil.writeToFile(scriptContent, binary);
+        binary.setExecutable(true);
+        OptionSetter testSetter = new OptionSetter(pyTest);
+        testSetter.setOptionValue("python-binaries", binary.getAbsolutePath());
+        testSetter.setOptionValue("enable-cache", "true");
+        CommandOptions commandOptions = new CommandOptions();
+        OptionSetter commandOptionsSetter = new OptionSetter(commandOptions);
+        commandOptionsSetter.setOptionValue("remote-cache-instance-name", "test_instance");
+        IConfiguration config = new Configuration("config", "Test config");
+        config.setCommandOptions(commandOptions);
+        pyTest.setConfiguration(config);
+        return pyTest;
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java b/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java
index 51b788ef4..255c5a117 100644
--- a/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java
@@ -16,13 +16,19 @@
 package com.android.tradefed.testtype.rust;
 
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
+import com.android.tradefed.build.DeviceBuildInfo;
 import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.command.CommandOptions;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
@@ -37,9 +43,11 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtilTest;
 
 import com.google.common.truth.Truth;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -55,8 +63,10 @@ import java.util.List;
 /** Unit tests for {@link RustBinaryHostTest}. */
 @RunWith(JUnit4.class)
 public class RustBinaryHostTestTest {
+    private RunUtilTest.FakeCacheClient mFakeCacheClient;
     private RustBinaryHostTest mTest;
     private TestInformation mTestInfo;
+    private File mModuleDir;
     @Mock IRunUtil mMockRunUtil;
     @Mock IBuildInfo mMockBuildInfo;
     @Mock ITestInvocationListener mMockListener;
@@ -76,6 +86,19 @@ public class RustBinaryHostTestTest {
         InvocationContext context = new InvocationContext();
         context.addDeviceBuildInfo("device", mMockBuildInfo);
         mTestInfo = TestInformation.newBuilder().setInvocationContext(context).build();
+        mModuleDir = FileUtil.createTempDir("rust-module");
+        mFakeCacheClient = new RunUtilTest.FakeCacheClient();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        FileUtil.recursiveDelete(mModuleDir);
+        mFakeCacheClient.getAllCache().values().stream()
+                .forEach(
+                        a -> {
+                            FileUtil.deleteFile(a.stdOut());
+                            FileUtil.deleteFile(a.stdErr());
+                        });
     }
 
     private CommandResult newCommandResult(CommandStatus status, String stderr, String stdout) {
@@ -195,10 +218,46 @@ public class RustBinaryHostTestTest {
                 .thenReturn(successResult("", output));
     }
 
+    /** Test that a success rust test run is uploaded to cache service. */
+    @Test
+    public void testRun_upload_cache_for_success_run() throws Exception {
+        RustBinaryHostTest rustTest =
+                createRustBinaryHostTestWithCache(
+                        "#!/bin/bash\n"
+                            + "[ \"${@: -1}\" == \"--list\" ] && echo \"hello_world_test : test\""
+                            + " || echo \"running 1 tests\n"
+                            + "test hello_world ... ok <0.001s>\n"
+                            + "test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0"
+                            + " filtered out; finished in 0.01s\n"
+                            + "\"");
+
+        rustTest.run(mTestInfo, mMockListener);
+
+        assertFalse(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
+    /** Test that a failed rust test run is not uploaded to cache service. */
+    @Test
+    public void testRun_skip_cache_uploading_for_failed_run() throws Exception {
+        RustBinaryHostTest rustTest =
+                createRustBinaryHostTestWithCache(
+                        "#!/bin/bash\n"
+                            + "[ \"${@: -1}\" == \"--list\" ] && echo \"hello_world_test : test\""
+                            + " || echo \"running 1 tests\n"
+                            + "test hello_world ... FAILED <0.001s>\n"
+                            + "test result: ok. 0 passed; 1 failed; 0 ignored; 0 measured; 0"
+                            + " filtered out; finished in 0.01s\n"
+                            + "\"");
+
+        rustTest.run(mTestInfo, mMockListener);
+
+        assertTrue(mFakeCacheClient.getAllCache().isEmpty());
+    }
+
     /** Test that when running a rust binary the output is parsed to obtain results. */
     @Test
     public void testRun() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -232,7 +291,7 @@ public class RustBinaryHostTestTest {
         mMockBuildInfo = mock(IBuildInfo.class);
         mTest.setBuild(mMockBuildInfo);
 
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -259,7 +318,7 @@ public class RustBinaryHostTestTest {
     /** If the binary returns an exception status, it is treated as a failed test. */
     @Test
     public void testRunFail_exception() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -292,7 +351,7 @@ public class RustBinaryHostTestTest {
      */
     @Test
     public void testRunFail_list() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -319,7 +378,7 @@ public class RustBinaryHostTestTest {
     /** If the binary reports a FAILED status, it is treated as a failed test. */
     @Test
     public void testRunFail_failureOnly() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -347,7 +406,7 @@ public class RustBinaryHostTestTest {
     /** Test the exclude filtering of test methods. */
     @Test
     public void testExcludeFilter() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -398,7 +457,7 @@ public class RustBinaryHostTestTest {
     /** Test both include and exclude filters. */
     @Test
     public void testIncludeExcludeFilter() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -453,7 +512,7 @@ public class RustBinaryHostTestTest {
     /** Test multiple include and exclude filters. */
     @Test
     public void testMultipleIncludeExcludeFilter() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -543,7 +602,7 @@ public class RustBinaryHostTestTest {
     /** Test benchmark run */
     @Test
     public void testRun_benchmark() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -568,12 +627,18 @@ public class RustBinaryHostTestTest {
                             Mockito.anyInt(),
                             Mockito.anyLong());
             verifyListenerLog(binary, false);
-            verify(mMockListener).testStarted(desc1);
+            verify(mMockListener).testStarted(Mockito.eq(desc1), Mockito.anyLong());
             verify(mMockListener)
-                    .testEnded(Mockito.eq(desc1), Mockito.<HashMap<String, Metric>>any());
-            verify(mMockListener).testStarted(desc2);
+                    .testEnded(
+                            Mockito.eq(desc1),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener).testStarted(Mockito.eq(desc2), Mockito.anyLong());
             verify(mMockListener)
-                    .testEnded(Mockito.eq(desc2), Mockito.<HashMap<String, Metric>>any());
+                    .testEnded(
+                            Mockito.eq(desc2),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
             verify(mMockListener)
                     .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         } finally {
@@ -583,7 +648,7 @@ public class RustBinaryHostTestTest {
 
     @Test
     public void testRun_benchmarkDoubleStart() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -606,13 +671,19 @@ public class RustBinaryHostTestTest {
                             Mockito.anyInt(),
                             Mockito.anyLong());
             verifyListenerLog(binary, false);
-            verify(mMockListener).testStarted(desc1);
+            verify(mMockListener).testStarted(Mockito.eq(desc1), Mockito.anyLong());
             verify(mMockListener).testFailed(Mockito.eq(desc1), Mockito.<String>any());
             verify(mMockListener)
-                    .testEnded(Mockito.eq(desc1), Mockito.<HashMap<String, Metric>>any());
-            verify(mMockListener).testStarted(desc2);
+                    .testEnded(
+                            Mockito.eq(desc1),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener).testStarted(Mockito.eq(desc2), Mockito.anyLong());
             verify(mMockListener)
-                    .testEnded(Mockito.eq(desc2), Mockito.<HashMap<String, Metric>>any());
+                    .testEnded(
+                            Mockito.eq(desc2),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
             verify(mMockListener)
                     .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         } finally {
@@ -622,7 +693,7 @@ public class RustBinaryHostTestTest {
 
     @Test
     public void testRun_benchmarkNotFinished() throws Exception {
-        File binary = FileUtil.createTempFile("rust-dir", "");
+        File binary = FileUtil.createTempFile("rust-dir", "", mModuleDir);
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
@@ -646,13 +717,19 @@ public class RustBinaryHostTestTest {
                             Mockito.anyInt(),
                             Mockito.anyLong());
             verifyListenerLog(binary, false);
-            verify(mMockListener).testStarted(desc1);
+            verify(mMockListener).testStarted(Mockito.eq(desc1), Mockito.anyLong());
             verify(mMockListener)
-                    .testEnded(Mockito.eq(desc1), Mockito.<HashMap<String, Metric>>any());
-            verify(mMockListener).testStarted(desc2);
+                    .testEnded(
+                            Mockito.eq(desc1),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener).testStarted(Mockito.eq(desc2), Mockito.anyLong());
             verify(mMockListener).testFailed(Mockito.eq(desc2), Mockito.<String>any());
             verify(mMockListener)
-                    .testEnded(Mockito.eq(desc2), Mockito.<HashMap<String, Metric>>any());
+                    .testEnded(
+                            Mockito.eq(desc2),
+                            Mockito.anyLong(),
+                            Mockito.<HashMap<String, Metric>>any());
             verify(mMockListener).testRunFailed(Mockito.<String>any());
             verify(mMockListener)
                     .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
@@ -687,4 +764,32 @@ public class RustBinaryHostTestTest {
             FileUtil.recursiveDelete(testsDir);
         }
     }
+
+    private RustBinaryHostTest createRustBinaryHostTestWithCache(String scriptContent)
+            throws Exception {
+        RustBinaryHostTest rustTest =
+                new RustBinaryHostTest() {
+                    @Override
+                    ICacheClient getCacheClient(File workFolder, String instanceName) {
+                        return mFakeCacheClient;
+                    }
+                };
+        File hostLinkedFolder = FileUtil.createTempDir("hosttestcases", mModuleDir);
+        File binary = new File(hostLinkedFolder, "hello_world_test");
+        FileUtil.writeToFile(scriptContent, binary);
+        binary.setExecutable(true);
+        OptionSetter testSetter = new OptionSetter(rustTest);
+        testSetter.setOptionValue("test-file", binary.getAbsolutePath());
+        testSetter.setOptionValue("enable-cache", "true");
+        DeviceBuildInfo buildInfo = new DeviceBuildInfo();
+        buildInfo.setFile(BuildInfoFileKey.HOST_LINKED_DIR, hostLinkedFolder, "0.0");
+        rustTest.setBuild(buildInfo);
+        CommandOptions commandOptions = new CommandOptions();
+        OptionSetter commandOptionsSetter = new OptionSetter(commandOptions);
+        commandOptionsSetter.setOptionValue("remote-cache-instance-name", "test_instance");
+        IConfiguration config = new Configuration("config", "Test config");
+        config.setCommandOptions(commandOptions);
+        rustTest.setConfiguration(config);
+        return rustTest;
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/suite/ITestSuiteIntegrationTest.java b/javatests/com/android/tradefed/testtype/suite/ITestSuiteIntegrationTest.java
index 4b5e15032..4c03600fa 100644
--- a/javatests/com/android/tradefed/testtype/suite/ITestSuiteIntegrationTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/ITestSuiteIntegrationTest.java
@@ -270,7 +270,8 @@ public class ITestSuiteIntegrationTest {
             setter.setOptionValue("log-file-path", logSaverTmpDir.getAbsolutePath());
             mStubMainConfiguration.setLogSaver(logSaver);
             LogSaverResultForwarder mainInvocationForwarder =
-                    new LogSaverResultForwarder(logSaver, Arrays.asList(mListener));
+                    new LogSaverResultForwarder(
+                            logSaver, Arrays.asList(mListener), mStubMainConfiguration);
 
             createConfig(
                     mTestConfigFolder, "module1", TEST_STUB, true, true, false, false, false, true);
diff --git a/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java b/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java
index 7b6b4ed45..1a8e7283a 100644
--- a/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/ModuleDefinitionTest.java
@@ -1353,13 +1353,14 @@ public class ModuleDefinitionTest {
     public void testModule_LogSaverResultForwarder() throws Exception {
         List<IRemoteTest> testList = new ArrayList<>();
         testList.add(new TestLogClass());
+        IConfiguration moduleConfig = new Configuration("", "");
         mModule =
                 new ModuleDefinition(
                         MODULE_NAME,
                         testList,
                         mMapDeviceTargetPreparer,
                         mMultiTargetPrepList,
-                        new Configuration("", ""));
+                        moduleConfig);
         mModule.setRetryDecision(mDecision);
         mModule.setLogSaver(mMockLogSaver);
         mModule.getModuleInvocationContext().addAllocatedDevice(DEFAULT_DEVICE_NAME, mMockDevice);
@@ -1382,7 +1383,8 @@ public class ModuleDefinitionTest {
 
         // Simulate how the invoker actually put the log saver
         LogSaverResultForwarder forwarder =
-                new LogSaverResultForwarder(mMockLogSaver, Arrays.asList(mMockLogSaverListener));
+                new LogSaverResultForwarder(
+                        mMockLogSaver, Arrays.asList(mMockLogSaverListener), moduleConfig);
         mModule.run(mModuleInfo, forwarder);
         InOrder inOrder = Mockito.inOrder(mMockLogSaverListener);
         inOrder.verify(mMockLogSaverListener).setLogSaver(mMockLogSaver);
@@ -1496,13 +1498,14 @@ public class ModuleDefinitionTest {
         final int testCount = 5;
         List<IRemoteTest> testList = new ArrayList<>();
         testList.add(new TestObject("run1", testCount, false));
+        IConfiguration moduleConfig = new Configuration("", "");
         mModule =
                 new ModuleDefinition(
                         MODULE_NAME,
                         testList,
                         mMapDeviceTargetPreparer,
                         mMultiTargetPrepList,
-                        new Configuration("", ""));
+                        moduleConfig);
         mModule.setRetryDecision(mDecision);
         mModule.setLogSaver(mMockLogSaver);
         mModule.getModuleInvocationContext().addAllocatedDevice(DEFAULT_DEVICE_NAME, mMockDevice);
@@ -1521,7 +1524,8 @@ public class ModuleDefinitionTest {
         // Simulate how the invoker actually put the log saver
 
         LogSaverResultForwarder forwarder =
-                new LogSaverResultForwarder(mMockLogSaver, Arrays.asList(mMockLogSaverListener));
+                new LogSaverResultForwarder(
+                        mMockLogSaver, Arrays.asList(mMockLogSaverListener), moduleConfig);
         mModule.run(mModuleInfo, forwarder, Arrays.asList(mMockListener));
         InOrder inOrder = Mockito.inOrder(mMockLogSaverListener, mMockListener);
         inOrder.verify(mMockLogSaverListener).setLogSaver(mMockLogSaver);
diff --git a/javatests/com/android/tradefed/testtype/suite/retry/ResultsPlayerTest.java b/javatests/com/android/tradefed/testtype/suite/retry/ResultsPlayerTest.java
index 3845ae9cf..5df3e27bf 100644
--- a/javatests/com/android/tradefed/testtype/suite/retry/ResultsPlayerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/retry/ResultsPlayerTest.java
@@ -20,7 +20,6 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.android.ddmlib.IDevice;
-import com.android.ddmlib.Log.LogLevel;
 import com.android.ddmlib.testrunner.TestResult.TestStatus;
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.config.ConfigurationDef;
@@ -31,6 +30,7 @@ import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.ILeveledLogOutput;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
diff --git a/javatests/com/android/tradefed/util/GCSFileDownloaderFuncTest.java b/javatests/com/android/tradefed/util/GCSFileDownloaderFuncTest.java
index 55a3462bd..14a52ad2f 100644
--- a/javatests/com/android/tradefed/util/GCSFileDownloaderFuncTest.java
+++ b/javatests/com/android/tradefed/util/GCSFileDownloaderFuncTest.java
@@ -88,7 +88,7 @@ public class GCSFileDownloaderFuncTest {
                 new GCSFileDownloader() {
 
                     @Override
-                    File createTempFile(String remoteFilePath, File rootDir)
+                    protected File createTempFile(String remoteFilePath, File rootDir)
                             throws BuildRetrievalError {
                         try {
                             File tmpFile =
diff --git a/javatests/com/android/tradefed/util/GCSFileDownloaderTest.java b/javatests/com/android/tradefed/util/GCSFileDownloaderTest.java
index 54b4d8d94..a2dac6612 100644
--- a/javatests/com/android/tradefed/util/GCSFileDownloaderTest.java
+++ b/javatests/com/android/tradefed/util/GCSFileDownloaderTest.java
@@ -39,7 +39,7 @@ public class GCSFileDownloaderTest {
         mGCSFileDownloader =
                 new GCSFileDownloader() {
                     @Override
-                    void downloadFile(String bucketName, String filename, File localFile)
+                    protected void downloadFile(String bucketName, String filename, File localFile)
                             throws BuildRetrievalError {
                         try {
                             FileUtil.writeToFile(bucketName + "\n" + filename, localFile);
diff --git a/javatests/com/android/tradefed/util/GCSFileUploaderFuncTest.java b/javatests/com/android/tradefed/util/GCSFileUploaderFuncTest.java
index 804f5f694..e042d53a5 100644
--- a/javatests/com/android/tradefed/util/GCSFileUploaderFuncTest.java
+++ b/javatests/com/android/tradefed/util/GCSFileUploaderFuncTest.java
@@ -125,7 +125,7 @@ public class GCSFileUploaderFuncTest {
         return os.toByteArray();
     }
 
-    private InputStream pullFileFromGcs(String gcsFilePath) throws IOException {
+    private InputStream pullFileFromGcs(String gcsFilePath) throws Exception {
         return mDownloader.downloadFile(BUCKET_NAME, gcsFilePath);
     }
 }
diff --git a/javatests/com/android/tradefed/device/cloud/GceRemoteCmdFormatterTest.java b/javatests/com/android/tradefed/util/GceRemoteCmdFormatterTest.java
similarity index 88%
rename from javatests/com/android/tradefed/device/cloud/GceRemoteCmdFormatterTest.java
rename to javatests/com/android/tradefed/util/GceRemoteCmdFormatterTest.java
index e57f1c310..5494dcdd8 100644
--- a/javatests/com/android/tradefed/device/cloud/GceRemoteCmdFormatterTest.java
+++ b/javatests/com/android/tradefed/util/GceRemoteCmdFormatterTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.android.tradefed.device.cloud;
+package com.android.tradefed.util;
 
 import static org.junit.Assert.*;
 
-import com.android.tradefed.device.cloud.GceRemoteCmdFormatter.ScpMode;
+import com.android.tradefed.util.GceRemoteCmdFormatter.ScpMode;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -76,14 +76,4 @@ public class GceRemoteCmdFormatterTest {
         assertEquals("root@127.0.0.1:/sdcard/test", res.get(11));
         assertEquals("/tmp/here", res.get(12));
     }
-
-    @Test
-    public void testFormatSshOverLHP() {
-        // TODO(easoncylee): Flesh out this section when it's ready.
-    }
-
-    @Test
-    public void testFormatScpOverLHP() {
-        // TODO(easoncylee): Flesh out this section when it's ready.
-    }
 }
diff --git a/javatests/com/android/tradefed/util/GoogleApiClientUtilTest.java b/javatests/com/android/tradefed/util/GoogleApiClientUtilTest.java
index 5a6100f65..9e1da8119 100644
--- a/javatests/com/android/tradefed/util/GoogleApiClientUtilTest.java
+++ b/javatests/com/android/tradefed/util/GoogleApiClientUtilTest.java
@@ -19,6 +19,7 @@ package com.android.tradefed.util;
 import com.android.tradefed.auth.ICredentialFactory;
 import com.android.tradefed.config.GlobalConfiguration;
 import com.android.tradefed.config.OptionSetter;
+
 import com.google.auth.Credentials;
 
 import org.junit.After;
@@ -57,14 +58,15 @@ public class GoogleApiClientUtilTest {
         boolean mDefaultCredentialUsed = false;
 
         @Override
-        Credentials doCreateCredentialFromJsonKeyFile(File file, Collection<String> scopes)
-                throws IOException, GeneralSecurityException {
+        protected Credentials doCreateCredentialFromJsonKeyFile(
+                File file, Collection<String> scopes) throws IOException, GeneralSecurityException {
             mKeyFiles.add(file);
             return Mockito.mock(Credentials.class);
         }
 
         @Override
-        Credentials doCreateDefaultCredential(Collection<String> scopes) throws IOException {
+        protected Credentials doCreateDefaultCredential(Collection<String> scopes)
+                throws IOException {
             mDefaultCredentialUsed = true;
             return Mockito.mock(Credentials.class);
         }
diff --git a/javatests/com/android/tradefed/util/KernelModuleUtilsTest.java b/javatests/com/android/tradefed/util/KernelModuleUtilsTest.java
new file mode 100644
index 000000000..4e4020081
--- /dev/null
+++ b/javatests/com/android/tradefed/util/KernelModuleUtilsTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.util;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+public class KernelModuleUtilsTest {
+
+    /** Test {@link KernelModuleUtils#getDependentModules(String, String)} */
+    @Test
+    public void testGetDependentModules() {
+        String output =
+                "Module Size  Used b\n"
+                        + "kunit_test             663552  0\n"
+                        + "time_test             663558  0\n"
+                        + "kunit                  57344  15 kunit_test,time_test\n";
+        String[] expected = {"kunit_test", "time_test"};
+        String[] actual = KernelModuleUtils.getDependentModules("kunit", output);
+        assertArrayEquals(expected, actual);
+        assertArrayEquals(
+                new String[0], KernelModuleUtils.getDependentModules("kunit_test", output));
+        assertArrayEquals(
+                new String[0], KernelModuleUtils.getDependentModules("kunit", "kunit 123 12"));
+    }
+
+    /** Test {@link KernelModuleUtils#getDisplayedModuleName(String)} */
+    @Test
+    public void testGetDisplayedModuleName() {
+        assertEquals("kunit_test", KernelModuleUtils.getDisplayedModuleName("/data/kunit-test.ko"));
+        assertEquals("kunit_test", KernelModuleUtils.getDisplayedModuleName("kunit-test.ko"));
+    }
+}
diff --git a/javatests/com/android/tradefed/util/RunUtilTest.java b/javatests/com/android/tradefed/util/RunUtilTest.java
index 9ce84a5ce..265fd9091 100644
--- a/javatests/com/android/tradefed/util/RunUtilTest.java
+++ b/javatests/com/android/tradefed/util/RunUtilTest.java
@@ -28,8 +28,6 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import build.bazel.remote.execution.v2.Digest;
-
 import com.android.tradefed.cache.DigestCalculator;
 import com.android.tradefed.cache.ExecutableAction;
 import com.android.tradefed.cache.ExecutableActionResult;
@@ -40,6 +38,8 @@ import com.android.tradefed.util.IRunUtil.EnvPriority;
 import com.android.tradefed.util.IRunUtil.IRunnableResult;
 import com.android.tradefed.util.RunUtil.RunnableResult;
 
+import build.bazel.remote.execution.v2.Digest;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -54,9 +54,9 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
-import java.util.concurrent.TimeUnit;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 
 /** Unit tests for {@link RunUtil} */
 @RunWith(JUnit4.class)
@@ -65,6 +65,7 @@ public class RunUtilTest {
     private RunUtil mRunUtil;
     private RunnableResult mMockRunnableResult;
     private long mSleepTime = 0L;
+    private File mWorkingDir;
     private static final long VERY_SHORT_TIMEOUT_MS = 10L;
     private static final long SHORT_TIMEOUT_MS = 200L;
     private static final long LONG_TIMEOUT_MS = 1000L;
@@ -77,12 +78,14 @@ public class RunUtilTest {
         mRunUtil = new RunUtil(new CommandInterrupter());
         mRunUtil.setPollingInterval(SHORT_TIMEOUT_MS);
         mMockRunnableResult = null;
+        mWorkingDir = FileUtil.createTempDir("working_dir_");
     }
 
     @After
     public void tearDown() {
         // clear interrupted status
         Thread.interrupted();
+        FileUtil.recursiveDelete(mWorkingDir);
     }
 
     /** Test class on {@link RunUtil} in order to avoid creating a real process. */
@@ -119,17 +122,35 @@ public class RunUtilTest {
         }
     }
 
+    /** Test class on {@link RunUtil} in order to monitor the real process. */
+    class MonitoredRunUtil extends RunUtil {
+        public ProcessBuilder processBuilder;
+
+        public MonitoredRunUtil(boolean inheritEnvVars) {
+            super(inheritEnvVars);
+        }
+
+        @Override
+        RunnableResult createRunnableResult(
+                OutputStream stdout, OutputStream stderr, ProcessBuilder processBuilder) {
+            this.processBuilder = processBuilder;
+            return super.createRunnableResult(stdout, stderr, processBuilder);
+        }
+    }
+
     /** Test class implementing {@link ICacheClient} to mock the cache client. */
-    class FakeCacheClient implements ICacheClient {
+    public static class FakeCacheClient implements ICacheClient {
         private final Map<Digest, ExecutableActionResult> mCache = new HashMap<>();
 
-        FakeCacheClient() {}
+        public FakeCacheClient() {}
+
+        public Map<Digest, ExecutableActionResult> getAllCache() {
+            return mCache;
+        }
 
         @Override
         public void uploadCache(ExecutableAction action, ExecutableActionResult actionResult) {
             try {
-                System.out.println("heidoudou");
-                System.out.println(FileUtil.readStringFromFile(actionResult.stdOut()));
                 File stdout = FileUtil.createTempFile("stdout_", ".txt");
                 FileUtil.copyFile(actionResult.stdOut(), stdout);
                 File stderr = null;
@@ -224,80 +245,76 @@ public class RunUtilTest {
      * ICacheClient, String...)} caches command execution successfully.
      */
     @Test
-    public void runTimedCmdWithOutputMonitor_cache_same_run() {
-        File firstWorkingDir = null;
-        File firstStdout = null;
-        File firstStderr = null;
-        OutputStream firstStdoutStream = null;
-        OutputStream firstStderrStream = null;
-        File secondWorkingDir = null;
-        File secondStdout = null;
-        File secondStderr = null;
-        OutputStream secondStdoutStream = null;
-        OutputStream secondStderrStream = null;
-        try {
-            firstWorkingDir = FileUtil.createTempDir("first_run_");
-            firstStdout = FileUtil.createTempFile("stdout_subprocess_1_", ".txt");
-            firstStdoutStream = new FileOutputStream(firstStdout);
-            firstStderr = FileUtil.createTempFile("stderr_subprocess_1_", ".txt");
-            firstStderrStream = new FileOutputStream(firstStderr);
-            secondWorkingDir = FileUtil.createTempDir("second_run_");
-            secondStdout = FileUtil.createTempFile("stdout_subprocess_2_", ".txt");
-            secondStdoutStream = new FileOutputStream(secondStdout);
-            secondStderr = FileUtil.createTempFile("stderr_subprocess_2_", ".txt");
-            secondStderrStream = new FileOutputStream(secondStderr);
-        } catch (IOException e) {
-            fail("Failed to create output files: " + e.getMessage());
-        }
-        RunUtil firstRunUtil = new SpyRunUtil(false);
+    public void runTimedCmdWithOutputMonitor_cache_same_run() throws IOException {
+        String content = "echo test-cache-stdout";
+        File firstWorkingDir = FileUtil.createTempDir("first_run_", mWorkingDir);
+        File sharedLibA = new File(firstWorkingDir, "lib1");
+        sharedLibA.createNewFile();
+        File sharedLibB = new File(firstWorkingDir, "lib2");
+        sharedLibB.createNewFile();
+        File firstBinary = new File(firstWorkingDir, "hello_world_test.sh");
+        firstBinary.createNewFile();
+        FileUtil.writeToFile(content, firstBinary);
+        FileUtil.ensureGroupRWX(firstBinary);
+        File firstStdout = FileUtil.createTempFile("stdout_subprocess_1_", ".txt", mWorkingDir);
+        File firstStderr = FileUtil.createTempFile("stderr_subprocess_1_", ".txt", mWorkingDir);
+        File secondWorkingDir = FileUtil.createTempDir("second_run_", mWorkingDir);
+        File sharedLibC = new File(secondWorkingDir, "lib1");
+        sharedLibC.createNewFile();
+        File sharedLibD = new File(secondWorkingDir, "lib2");
+        sharedLibD.createNewFile();
+        File secondBinary = new File(secondWorkingDir, "hello_world_test.sh");
+        secondBinary.createNewFile();
+        FileUtil.writeToFile(content, secondBinary);
+        FileUtil.ensureGroupRWX(secondBinary);
+        File secondStdout = FileUtil.createTempFile("stdout_subprocess_2_", ".txt", mWorkingDir);
+        File secondStderr = FileUtil.createTempFile("stderr_subprocess_2_", ".txt", mWorkingDir);
+        MonitoredRunUtil firstRunUtil = new MonitoredRunUtil(false);
         firstRunUtil.setWorkingDir(firstWorkingDir);
-        firstRunUtil.setEnvVariable("KEY", "VALUE");
-        RunUtil secondRunUtil = new SpyRunUtil(false);
+        firstRunUtil.setEnvVariable(
+                "LD_LIBRARY_PATH",
+                sharedLibA.getAbsolutePath() + ":" + sharedLibB.getAbsolutePath());
+        MonitoredRunUtil secondRunUtil = new MonitoredRunUtil(false);
         secondRunUtil.setWorkingDir(secondWorkingDir);
-        secondRunUtil.setEnvVariable("KEY", "VALUE");
-        String[] command = {"unused", "cmd"};
+        secondRunUtil.setEnvVariable(
+                "LD_LIBRARY_PATH",
+                sharedLibD.getAbsolutePath() + ":" + sharedLibC.getAbsolutePath());
+        String[] firstCommand = {firstBinary.getAbsolutePath(), "--option"};
+        String[] secondCommand = {secondBinary.getAbsolutePath(), "--option"};
         ICacheClient cacheClient = new FakeCacheClient();
 
         CommandResult firstResult =
                 firstRunUtil.runTimedCmdWithOutputMonitor(
                         LONG_TIMEOUT_MS,
                         0,
-                        firstStdoutStream,
-                        firstStderrStream,
+                        new FileOutputStream(firstStdout),
+                        new FileOutputStream(firstStderr),
                         cacheClient,
-                        command);
+                        firstCommand);
+        firstRunUtil.uploadCache(
+                cacheClient,
+                ExecutableActionResult.create(firstResult.getExitCode(), firstStdout, firstStderr));
         CommandResult secondResult =
                 secondRunUtil.runTimedCmdWithOutputMonitor(
                         LONG_TIMEOUT_MS,
                         0,
-                        secondStdoutStream,
-                        secondStderrStream,
+                        new FileOutputStream(secondStdout),
+                        new FileOutputStream(secondStderr),
                         cacheClient,
-                        command);
+                        secondCommand);
+        String actualStdout = FileUtil.readStringFromFile(firstStdout);
 
         assertFalse(firstResult.isCached());
         assertTrue(secondResult.isCached());
         assertEquals(CommandStatus.SUCCESS, firstResult.getStatus());
         assertEquals(CommandStatus.SUCCESS, secondResult.getStatus());
-        try {
-            assertFalse(FileUtil.readStringFromFile(firstStdout).isEmpty());
-            assertEquals(
-                    FileUtil.readStringFromFile(firstStdout),
-                    FileUtil.readStringFromFile(secondStdout));
-            assertFalse(FileUtil.readStringFromFile(firstStderr).isEmpty());
-            assertEquals(
-                    FileUtil.readStringFromFile(firstStderr),
-                    FileUtil.readStringFromFile(secondStderr));
-        } catch (IOException e) {
-            fail(e.getMessage());
-        } finally {
-            FileUtil.deleteFile(firstStdout);
-            FileUtil.deleteFile(firstStderr);
-            FileUtil.deleteFile(secondStdout);
-            FileUtil.deleteFile(secondStderr);
-            FileUtil.recursiveDelete(firstWorkingDir);
-            FileUtil.recursiveDelete(secondWorkingDir);
-        }
+        // Remove the line break character.
+        assertEquals(actualStdout.substring(0, actualStdout.length() - 1), "test-cache-stdout");
+        assertEquals(actualStdout, FileUtil.readStringFromFile(secondStdout));
+        assertTrue(FileUtil.readStringFromFile(firstStderr).isEmpty());
+        assertTrue(FileUtil.readStringFromFile(secondStderr).isEmpty());
+        assertEquals(
+                firstRunUtil.processBuilder.environment(), Map.of("LD_LIBRARY_PATH", "lib1:lib2"));
     }
 
     /**
diff --git a/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java b/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java
new file mode 100644
index 000000000..9a42d4169
--- /dev/null
+++ b/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java
@@ -0,0 +1,485 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.invoker.ExecutionFiles;
+import com.android.tradefed.targetprep.AltDirBehavior;
+import com.android.tradefed.testtype.Abi;
+import com.android.tradefed.testtype.IAbi;
+
+import com.google.common.truth.Truth;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+
+/** Unit tests for {@link SearchArtifactUtil} */
+@RunWith(JUnit4.class)
+public class SearchArtifactUtilTest {
+    /**
+     * When file is present in multiple modules, including top level folder, and module name is
+     * present, it should return the file from the correct module directory.
+     */
+    @Test
+    public void testSearchFile_multipleMatchWithModuleName() throws IOException {
+        File searchDirectory = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+            File correctModuleFile = new File(searchDirectory, "correctModule/testfile.txt");
+            correctModuleFile.getParentFile().mkdirs();
+            correctModuleFile.createNewFile();
+
+            File wrongModuleFile = new File(searchDirectory, "wrongModule/testfile.txt");
+            wrongModuleFile.getParentFile().mkdirs();
+            wrongModuleFile.createNewFile();
+
+            File topLevelFile = new File(searchDirectory, "testfile.txt");
+            topLevelFile.createNewFile();
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
+
+            File f = SearchArtifactUtil.searchFile("testfile.txt", false);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(correctModuleFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+        }
+    }
+
+    /**
+     * When file is present in multiple modules, including top level folder, but module name is not
+     * present, it should return the file from the top level directory.
+     */
+    @Test
+    public void testSearchFile_multipleMatchWithoutModuleName() throws IOException {
+        File searchDirectory = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+            File module1File = new File(searchDirectory, "moduleName1/testfile.txt");
+            module1File.getParentFile().mkdirs();
+            module1File.createNewFile();
+
+            File module2File = new File(searchDirectory, "moduleName2/testfile.txt");
+            module2File.getParentFile().mkdirs();
+            module2File.createNewFile();
+
+            File topLevelFile = new File(searchDirectory, "testfile.txt");
+            topLevelFile.createNewFile();
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn(null);
+
+            File f = SearchArtifactUtil.searchFile("testfile.txt", false);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(topLevelFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+        }
+    }
+
+    /**
+     * When file is present in multiple modules, including top level folder, and both module name
+     * and abi is present, it should return the file from the correct module directory with the
+     * correct abi.
+     */
+    @Test
+    public void testSearchFile_multipleMatchWithModuleNameAndAbi() throws IOException {
+        File searchDirectory = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+            File armFile = new File(searchDirectory, "correctModule/arm/testfile.txt");
+            armFile.getParentFile().mkdirs();
+            armFile.createNewFile();
+
+            File arm64File = new File(searchDirectory, "correctModule/arm64/testfile.txt");
+            arm64File.getParentFile().mkdirs();
+            arm64File.createNewFile();
+
+            File armFile2 = new File(searchDirectory, "wrongModule/arm/testfile.txt");
+            armFile2.getParentFile().mkdirs();
+            armFile2.createNewFile();
+
+            File arm64File2 = new File(searchDirectory, "wrongModule/arm64/testfile.txt");
+            arm64File2.getParentFile().mkdirs();
+            arm64File2.createNewFile();
+
+            File topLevelFile = new File(searchDirectory, "testfile.txt");
+            topLevelFile.createNewFile();
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
+
+            IAbi arm64abi = new Abi("arm64-v8a", "64");
+            File f = SearchArtifactUtil.searchFile("testfile.txt", false, arm64abi);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(arm64File.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+        }
+    }
+
+    /**
+     * When file is present in multiple modules, including in the top level folder, And abi is given
+     * but module is not present, it should ignore the abi and return the top level file in order to
+     * avoid selecting a file from the wrong module.
+     */
+    @Test
+    public void testSearchFile_multipleMatchWithAbiButNoModuleName() throws IOException {
+        File searchDirectory = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+
+            File armFile = new File(searchDirectory, "wrongModule/arm/testfile.txt");
+            armFile.getParentFile().mkdirs();
+            armFile.createNewFile();
+
+            File arm64File = new File(searchDirectory, "wrongModule/arm64/testfile.txt");
+            arm64File.getParentFile().mkdirs();
+            arm64File.createNewFile();
+
+            File topLevelFile = new File(searchDirectory, "testfile.txt");
+            topLevelFile.createNewFile();
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn(null);
+
+            IAbi arm64abi = new Abi("arm64-v8a", "64");
+            File f = SearchArtifactUtil.searchFile("testfile.txt", false, arm64abi);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(topLevelFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+        }
+    }
+
+    /**
+     * When file is present in multiple places, but not in the top level folder, And abi is given
+     * but module is not present, it should return the file that matches the abi.
+     */
+    @Test
+    public void testSearchFile_multipleMatchNoTopLevelMatchWithAbiButNoModuleName()
+            throws IOException {
+        File searchDirectory = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+
+            File armFile = new File(searchDirectory, "wrongModule/arm/testfile.txt");
+            armFile.getParentFile().mkdirs();
+            armFile.createNewFile();
+
+            File arm64File = new File(searchDirectory, "wrongModule/arm64/testfile.txt");
+            arm64File.getParentFile().mkdirs();
+            arm64File.createNewFile();
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn(null);
+
+            IAbi arm64abi = new Abi("arm64-v8a", "64");
+            File f = SearchArtifactUtil.searchFile("testfile.txt", false, arm64abi);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(arm64File.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+        }
+    }
+
+    /**
+     * When only one file is present, it should ignore module name and abi even if they are present.
+     */
+    @Test
+    public void testSearchFile_singleNonAbiNonModuleMatchWithAbiAndModuleNamePresent()
+            throws IOException {
+        File searchDirectory = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+
+            File armFile = new File(searchDirectory, "wrongModule/arm/testfile.txt");
+            armFile.getParentFile().mkdirs();
+            armFile.createNewFile();
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
+
+            IAbi arm64abi = new Abi("arm64-v8a", "64");
+            File f = SearchArtifactUtil.searchFile("testfile.txt", false, arm64abi);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(armFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+        }
+    }
+
+    /**
+     * when no matching file is present in the search directories, but is present in the
+     * ExecutionFiles, it should be returned.
+     */
+    @Test
+    public void testSearchFile_matchInExecutionFile() throws IOException {
+        File searchDirectory = null;
+        File correctFile = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+            File wrongModuleFile = new File(searchDirectory, "wrongModule/wrongTestFile.txt");
+            wrongModuleFile.getParentFile().mkdirs();
+            wrongModuleFile.createNewFile();
+
+            File wrongTopLevelFile = new File(searchDirectory, "wrongTestFile.txt");
+            wrongTopLevelFile.createNewFile();
+
+            correctFile = FileUtil.createTempFile("correctFile", ".txt");
+            ExecutionFiles executionFiles = Mockito.mock(ExecutionFiles.class);
+            when(executionFiles.get(correctFile.getName())).thenReturn(correctFile);
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
+            when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
+
+            File f = SearchArtifactUtil.searchFile(correctFile.getName(), false);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(correctFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+            FileUtil.deleteFile(correctFile);
+        }
+    }
+
+    /**
+     * when no matching file is present in the search directories, but is present in the IBuildInfo,
+     * it should be returned.
+     */
+    @Test
+    public void testSearchFile_matchInIBuildInfo() throws IOException {
+        File searchDirectory = null;
+        File correctFile = null;
+        try {
+            searchDirectory = FileUtil.createTempDir("test-dir");
+            File wrongModuleFile = new File(searchDirectory, "wrongModule/wrongTestFile.txt");
+            wrongModuleFile.getParentFile().mkdirs();
+            wrongModuleFile.createNewFile();
+
+            File wrongTopLevelFile = new File(searchDirectory, "wrongTestFile.txt");
+            wrongTopLevelFile.createNewFile();
+
+            correctFile = FileUtil.createTempFile("correctFile", ".txt");
+            IBuildInfo buildInfo = Mockito.mock(IBuildInfo.class);
+            when(buildInfo.getFile(correctFile.getName())).thenReturn(correctFile);
+
+            List<File> searchDirectories = new LinkedList<>();
+            searchDirectories.add(searchDirectory);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenReturn(searchDirectories);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
+            when(SearchArtifactUtil.singleton.getBuildInfo()).thenReturn(buildInfo);
+
+            File f = SearchArtifactUtil.searchFile(correctFile.getName(), false);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(correctFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(searchDirectory);
+            FileUtil.deleteFile(correctFile);
+        }
+    }
+
+    /**
+     * When alt-dir is provided with OVERRIDE behavior, it should return the file from the alt-dir
+     * even if it is present in the other search directories.
+     */
+    @Test
+    public void testSearchFile_withAltDirOverRide() throws IOException {
+        File testDir = null;
+        File altDir = null;
+        try {
+            testDir = FileUtil.createTempDir("test-dir");
+            File correctModuleFile = new File(testDir, "correctModule/testfile.txt");
+            correctModuleFile.getParentFile().mkdirs();
+            correctModuleFile.createNewFile();
+
+            File wrongModuleFile = new File(testDir, "wrongModule/testfile.txt");
+            wrongModuleFile.getParentFile().mkdirs();
+            wrongModuleFile.createNewFile();
+
+            File topLevelFile = new File(testDir, "testfile.txt");
+            topLevelFile.createNewFile();
+
+            altDir = FileUtil.createTempDir("altDir");
+            File altFile = new File(altDir, "testfile.txt");
+            altFile.createNewFile();
+            List<File> altDirs = new LinkedList<>();
+            altDirs.add(altDir);
+
+            ExecutionFiles executionFiles = Mockito.mock(ExecutionFiles.class);
+            when(executionFiles.get(ExecutionFiles.FilesKey.TESTS_DIRECTORY)).thenReturn(testDir);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
+            when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(
+                            false, altDirs, AltDirBehavior.OVERRIDE, null))
+                    .thenCallRealMethod();
+
+            File f =
+                    SearchArtifactUtil.searchFile(
+                            "testfile.txt", false, altDirs, AltDirBehavior.OVERRIDE);
+            Truth.assertThat(f).isNotNull();
+            Truth.assertThat(f.getAbsolutePath()).isEqualTo(altFile.getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(testDir);
+            FileUtil.recursiveDelete(altDir);
+        }
+    }
+
+    /**
+     * Should return the correct module directory from the target/testcases parent directory when
+     * target first is true.
+     */
+    @Test
+    public void testFindModuleDir_whenTargetFirst() throws IOException {
+        File testDir = null;
+        try {
+            testDir = FileUtil.createTempDir("test-dir");
+            File hostDir = FileUtil.createNamedTempDir(testDir, "host/testcases");
+            File targetDir = FileUtil.createNamedTempDir(testDir, "target/testcases");
+
+            File hostCorretModuleFile = new File(hostDir, "correctModule/testfile.txt");
+            hostCorretModuleFile.getParentFile().mkdirs();
+            hostCorretModuleFile.createNewFile();
+            File hostWrongModuleFile = new File(hostDir, "wrongModule/testfile.txt");
+            hostWrongModuleFile.getParentFile().mkdirs();
+            hostWrongModuleFile.createNewFile();
+
+            File targetCorrectModuleFile = new File(targetDir, "correctModule/testfile.txt");
+            targetCorrectModuleFile.getParentFile().mkdirs();
+            targetCorrectModuleFile.createNewFile();
+            File targetWrongModuleFile = new File(targetDir, "wrongModule/testfile.txt");
+            targetWrongModuleFile.getParentFile().mkdirs();
+            targetWrongModuleFile.createNewFile();
+
+            ExecutionFiles executionFiles = Mockito.mock(ExecutionFiles.class);
+            when(executionFiles.get(ExecutionFiles.FilesKey.TESTS_DIRECTORY)).thenReturn(testDir);
+            when(executionFiles.get(ExecutionFiles.FilesKey.HOST_TESTS_DIRECTORY))
+                    .thenReturn(hostDir);
+            when(executionFiles.get(ExecutionFiles.FilesKey.TARGET_TESTS_DIRECTORY))
+                    .thenReturn(targetDir);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(true, null, null, null))
+                    .thenCallRealMethod();
+
+            File dir = SearchArtifactUtil.findModuleDir("correctModule", true);
+            Truth.assertThat(dir).isNotNull();
+            Truth.assertThat(dir.getAbsolutePath())
+                    .isEqualTo(targetCorrectModuleFile.getParentFile().getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(testDir);
+        }
+    }
+
+    /**
+     * Should return the correct module directory from the host/testcases parent directory when
+     * target first is false.
+     */
+    @Test
+    public void testFindModuleDir_whenNotTargetFirst() throws IOException {
+        File testDir = null;
+        try {
+            testDir = FileUtil.createTempDir("test-dir");
+            File hostDir = FileUtil.createNamedTempDir(testDir, "host/testcases");
+            File targetDir = FileUtil.createNamedTempDir(testDir, "target/testcases");
+
+            File hostCorretModuleFile = new File(hostDir, "correctModule/testfile.txt");
+            hostCorretModuleFile.getParentFile().mkdirs();
+            hostCorretModuleFile.createNewFile();
+            File hostWrongModuleFile = new File(hostDir, "wrongModule/testfile.txt");
+            hostWrongModuleFile.getParentFile().mkdirs();
+            hostWrongModuleFile.createNewFile();
+
+            File targetCorrectModuleFile = new File(targetDir, "correctModule/testfile.txt");
+            targetCorrectModuleFile.getParentFile().mkdirs();
+            targetCorrectModuleFile.createNewFile();
+            File targetWrongModuleFile = new File(targetDir, "wrongModule/testfile.txt");
+            targetWrongModuleFile.getParentFile().mkdirs();
+            targetWrongModuleFile.createNewFile();
+
+            ExecutionFiles executionFiles = Mockito.mock(ExecutionFiles.class);
+            when(executionFiles.get(ExecutionFiles.FilesKey.TESTS_DIRECTORY)).thenReturn(testDir);
+            when(executionFiles.get(ExecutionFiles.FilesKey.HOST_TESTS_DIRECTORY))
+                    .thenReturn(hostDir);
+            when(executionFiles.get(ExecutionFiles.FilesKey.TARGET_TESTS_DIRECTORY))
+                    .thenReturn(targetDir);
+
+            SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
+            when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+                    .thenCallRealMethod();
+
+            File dir = SearchArtifactUtil.findModuleDir("correctModule", false);
+            Truth.assertThat(dir).isNotNull();
+            Truth.assertThat(dir.getAbsolutePath())
+                    .isEqualTo(hostCorretModuleFile.getParentFile().getAbsolutePath());
+        } finally {
+            FileUtil.recursiveDelete(testDir);
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/util/flag/DeviceFeatureFlagTest.java b/javatests/com/android/tradefed/util/flag/DeviceFeatureFlagTest.java
index 9b888dca9..35f2bff6d 100644
--- a/javatests/com/android/tradefed/util/flag/DeviceFeatureFlagTest.java
+++ b/javatests/com/android/tradefed/util/flag/DeviceFeatureFlagTest.java
@@ -26,15 +26,29 @@ import org.junit.runners.JUnit4;
 /** Unit tests for {@link DeviceFeatureFlag}. */
 @RunWith(JUnit4.class)
 public class DeviceFeatureFlagTest {
-    private static final String VALID_FLAG = "namespace/package.flag=value";
+
+    private static final String NAMESPACE = "namespace";
+    private static final String FLAG_NAME = "package.flag";
+    private static final String FLAG_VALUE = "value";
+    private static final String VALID_FLAG =
+            String.format("%s/%s=%s", NAMESPACE, FLAG_NAME, FLAG_VALUE);
     private static final String INVALID_FLAG = "invalid flag";
 
     @Test
-    public void testConstructor_validFlag_setsFlagAttributes() {
+    public void testConstructor_validFlagString_setsFlagAttributes() {
         DeviceFeatureFlag deviceFeatureFlag = new DeviceFeatureFlag(VALID_FLAG);
-        assertEquals("namespace", deviceFeatureFlag.getNamespace());
-        assertEquals("package.flag", deviceFeatureFlag.getFlagName());
-        assertEquals("value", deviceFeatureFlag.getFlagValue());
+        assertEquals(NAMESPACE, deviceFeatureFlag.getNamespace());
+        assertEquals(FLAG_NAME, deviceFeatureFlag.getFlagName());
+        assertEquals(FLAG_VALUE, deviceFeatureFlag.getFlagValue());
+    }
+
+    @Test
+    public void testConstructor_validFlagAttributes_setsFlagAttributes() {
+        DeviceFeatureFlag deviceFeatureFlag =
+                new DeviceFeatureFlag(NAMESPACE, FLAG_NAME, FLAG_VALUE);
+        assertEquals(NAMESPACE, deviceFeatureFlag.getNamespace());
+        assertEquals(FLAG_NAME, deviceFeatureFlag.getFlagName());
+        assertEquals(FLAG_VALUE, deviceFeatureFlag.getFlagValue());
     }
 
     @Test
diff --git a/proto/device/device_manager.proto b/proto/device/device_manager.proto
index 6f47df60d..2d070fff6 100644
--- a/proto/device/device_manager.proto
+++ b/proto/device/device_manager.proto
@@ -125,4 +125,7 @@ message DeviceStatus {
   }
   string device_id = 1;
   ReservationStatus reservation_status = 2;
+  // the run target of the device used for scheduling purpose, default to product board
+  // but can be customized via TF global host config files
+  string run_target = 3;
 }
diff --git a/proto/virtual_device_manager.proto b/proto/virtual_device_manager.proto
new file mode 100644
index 000000000..b680eb655
--- /dev/null
+++ b/proto/virtual_device_manager.proto
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+syntax = "proto3";
+
+package android.virtualdevice.proto;
+
+option java_package = "android.virtualdevice.proto";
+
+option java_multiple_files = true;
+option java_generic_services = true;
+
+// Request to lease a virtual device with specific hardware and software
+// configurations.
+message LeaseAvdDeviceRequest {
+  // Specifications for the device to be leased.
+  VirtualDeviceSpec device_specification = 1;
+  // User account associated with the device lease.
+  string accounting_user = 2;
+}
+
+// Response containing details of the leased virtual device.
+message LeaseAvdDeviceResponse {
+  // Specifications of the leased device. This can be null or empty if there's
+  // an error.
+  VirtualDeviceSpec leased_device_spec = 1;
+  // Error details if the leasing process fails. This should be null or empty on
+  // success.
+  ErrorDetails error = 2;
+}
+
+// Request to release a virtual device that was previously leased.
+message ReleaseAvdDeviceRequest {
+  // Specifications of the device to be released.
+  VirtualDeviceSpec device_specification = 1;
+}
+
+// Response indicating the status of the virtual device release operation.
+message ReleaseAvdDeviceResponse {
+  // Error details if the release process fails. This should be null or empty on
+  // success.
+  ErrorDetails error = 1;
+}
+
+// Specifications defining a virtual device.
+message VirtualDeviceSpec {
+  // Base specifications for a Cuttlefish device.
+  CuttlefishBuildInfo cuttlefish_spec = 1;
+  // Options for launching the device.
+  CuttlefishLaunchOptions launch_options = 2;
+  // Network ports exposed by the virtual device.
+  repeated ExposedPort ports = 3;
+  // Session ID associated with the device lease.
+  string session_id = 4;
+  // URL for remote access to the device.
+  string server_url = 5;
+  // Duration of the lease in seconds.
+  uint32 lease_length_secs = 6;
+  // Hardware size of the device instance(GENERIC_CF, GENERIC_CF_LARGE,
+  // GENERIC_CF_EXTRA_LARGE)
+  string instance_size = 7;
+}
+
+// Detailed specifications of a Cuttlefish virtual device.
+message CuttlefishBuildInfo {
+  // Build ID of the Cuttlefish device.
+  string build_id = 1;
+  // Build target of the Cuttlefish device.
+  string build_target = 2;
+  // Build branch of the Cuttlefish device.
+  string build_branch = 3;
+}
+
+// Options to customize the launch of a Cuttlefish device.
+message CuttlefishLaunchOptions {
+  // Extra arguments to pass during launch.
+  repeated string extra_launch_args = 1;
+}
+
+// Description of network ports exposed by the virtual device.
+message ExposedPort {
+  // Port number on the remote host machine.
+  uint32 host_port = 1;
+  // Corresponding port in local environment.
+  uint32 guest_port = 2;
+  // Network protocol used (e.g. ADB).
+  string protocol_type = 3;
+}
+
+// Request to set up a connection for a leased virtual device.
+message SetupDeviceConnectionRequest {
+  // Specifications of the device to be connected.
+  VirtualDeviceSpec device_specification = 1;
+}
+
+// Response to a request for setting up a device connection.
+message SetupDeviceConnectionResponse {
+  // Specifications of the connected device. This can be null or empty if
+  // there's an error.
+  VirtualDeviceSpec device_specification = 1;
+
+  // Error details if the connection setup fails. This should be null or empty
+  // on success.
+  ErrorDetails error = 2;
+}
+
+// Request to retrieve logs from a specific virtual device.
+message PullLogsRequest {
+  // Type of log to be retrieved.
+  LogType log_type = 1;
+  // Specifications of the device from which logs are to be pulled.
+  VirtualDeviceSpec device_specification = 2;
+}
+
+// Response containing logs retrieved from a virtual device.
+message PullLogsResponse {
+  // Error details if the log retrieval process fails. This should be null or
+  // empty on success.
+  ErrorDetails error_details = 1;
+  // Location where the logs are stored or accessible locally after being
+  // successfully pulled from the virtual device service. This field is
+  // populated only if the retrieval is successful. It typically contains a
+  // local file path.
+  string log_location = 2;
+}
+
+// Detailed information about errors encountered in using the virtual device
+// component.
+message ErrorDetails {
+  // Human-readable description of the error.
+  string message = 1;
+  // Numeric error code for categorizing the error type.
+  int32 code = 2;
+}
+
+// Enum to specify the type of log to be retrieved.
+enum LogType {
+  // Default value, unspecified log type.
+  LOG_TYPE_UNSPECIFIED = 0;
+  // General log from the Cuttlefish instance.
+  GENERAL_CF_LOG = 1;
+  // Kernel log from the virtual device hosting machine.
+  HOST_KERNEL_LOG = 2;
+  // Log from the host orchestrator.
+  HOST_ORCHESTRATOR_LOG = 3;
+}
+
+// VirtualDeviceManagerInterface provides an interface for managing virtual
+// devices in a virtual device service, including leasing, releasing, and
+// managing device connections.
+service VirtualDeviceManagerInterface {
+  // Leases a virtual device based on the specified requirements and returns
+  // VirtualDeviceSpec with the leased device details.
+  rpc LeaseAvdDevice(LeaseAvdDeviceRequest) returns (LeaseAvdDeviceResponse) {}
+
+  // Releases a previously leased virtual device. Returns an error if failed to
+  // release the device.
+  rpc ReleaseAvdDevice(ReleaseAvdDeviceRequest)
+      returns (ReleaseAvdDeviceResponse) {}
+
+  // Sets up a connection for a leased virtual device.
+  rpc SetupDeviceConnection(SetupDeviceConnectionRequest)
+      returns (SetupDeviceConnectionResponse) {}
+
+  // Retrieves specified logs from a leased virtual device.
+  rpc PullLogs(PullLogsRequest) returns (PullLogsResponse) {}
+}
diff --git a/pylintrc b/pylintrc
index 173e3857e..9e55a5210 100644
--- a/pylintrc
+++ b/pylintrc
@@ -1,14 +1,14 @@
 [BASIC]
 
-# Naming hint for method names
-method-name-hint=(([a-z][a-z0-9_]{2,50})|(_[a-z0-9_]*))$
-
 # Regular expression matching correct method names
 method-rgx=(([a-z][a-z0-9_]{2,50})|(_[a-z0-9_]*))$
 
 # Good variable names which should always be accepted, separated by a comma
 good-names=e, f, i, j
 
+# Naming style for methods
+method-naming-style=snake_case
+
 [DESIGN]
 
 # Maximum number of arguments for function / method
diff --git a/res/META-INF/services/com.android.tradefed.service.IRemoteFeature b/res/META-INF/services/com.android.tradefed.service.IRemoteFeature
index 9ed334e30..03b1b6ba9 100644
--- a/res/META-INF/services/com.android.tradefed.service.IRemoteFeature
+++ b/res/META-INF/services/com.android.tradefed.service.IRemoteFeature
@@ -3,4 +3,5 @@ com.android.tradefed.config.filter.CommandOptionsGetter
 com.android.tradefed.device.internal.DeviceResetFeature
 com.android.tradefed.device.internal.EarlyDeviceReleaseFeature
 com.android.tradefed.device.internal.DeviceSnapshotFeature
+com.android.tradefed.result.skipped.SkipFeature
 com.android.tradefed.testtype.suite.ResolvePartialDownload
diff --git a/res/config/checker/baseline_config.json b/res/config/checker/baseline_config.json
index 44dbfcd17..873365a52 100644
--- a/res/config/checker/baseline_config.json
+++ b/res/config/checker/baseline_config.json
@@ -65,5 +65,11 @@
     "class_name": "com.android.tradefed.suite.checker.baseline.CommandBaselineSetter",
     "command": "settings delete global hidden_api_policy",
     "min_api_level": "35"
+  },
+  "ensure_verify_apps": {
+    "class_name": "com.android.tradefed.suite.checker.baseline.CommandBaselineSetter",
+    "command": "pm get-user-restriction --user 0 ensure_verify_apps",
+    "min_api_level": "35",
+    "experimental": true
   }
 }
diff --git a/res/suite/allowed-preparers.txt b/res/suite/allowed-preparers.txt
index 516a4b237..6eab817d6 100644
--- a/res/suite/allowed-preparers.txt
+++ b/res/suite/allowed-preparers.txt
@@ -1,6 +1,7 @@
 com.android.tradefed.targetprep.AoaTargetPreparer
 com.android.tradefed.targetprep.DeviceCleaner
 com.android.tradefed.targetprep.FeatureFlagTargetPreparer
+com.android.tradefed.targetprep.InstallApexModuleTargetPreparer
 com.android.tradefed.targetprep.RootTargetPreparer
 com.android.tradefed.targetprep.RunCommandTargetPreparer
 com.android.tradefed.targetprep.WifiPreparer
diff --git a/src/com/android/tradefed/build/DependenciesResolver.java b/src/com/android/tradefed/build/DependenciesResolver.java
index 87ac7a774..d396c8c3e 100644
--- a/src/com/android/tradefed/build/DependenciesResolver.java
+++ b/src/com/android/tradefed/build/DependenciesResolver.java
@@ -112,6 +112,10 @@ public class DependenciesResolver
             }
             build.setTestsDir(mTestsDir, "1");
         }
+        if (CurrentInvocation.getInvocationFiles() != null) {
+            CurrentInvocation.getInvocationFiles()
+                    .put(ExecutionFiles.FilesKey.TESTS_DIRECTORY, build.getTestsDir());
+        }
         return build;
     }
 
diff --git a/src/com/android/tradefed/build/LocalDeviceBuildProvider.java b/src/com/android/tradefed/build/LocalDeviceBuildProvider.java
index 00f5648ba..ffc741cbd 100644
--- a/src/com/android/tradefed/build/LocalDeviceBuildProvider.java
+++ b/src/com/android/tradefed/build/LocalDeviceBuildProvider.java
@@ -17,6 +17,8 @@ package com.android.tradefed.build;
 
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.invoker.ExecutionFiles;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.targetprep.FlashingResourcesParser;
@@ -216,6 +218,10 @@ public class LocalDeviceBuildProvider extends StubBuildProvider {
         if (testsDir != null) {
             buildInfo.setTestsDir(testsDir, buildInfo.getBuildId());
             CLog.d("Using test files from %s", testsDir.getAbsolutePath());
+            if (CurrentInvocation.getInvocationFiles() != null) {
+                CurrentInvocation.getInvocationFiles()
+                        .put(ExecutionFiles.FilesKey.TESTS_DIRECTORY, testsDir);
+            }
         }
     }
 
diff --git a/src/com/android/tradefed/build/OtaZipfileBuildProvider.java b/src/com/android/tradefed/build/OtaZipfileBuildProvider.java
deleted file mode 100644
index e80d34f09..000000000
--- a/src/com/android/tradefed/build/OtaZipfileBuildProvider.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tradefed.build;
-
-import com.android.tradefed.config.Option;
-import com.android.tradefed.config.Option.Importance;
-import com.android.tradefed.device.DeviceProperties;
-import com.android.tradefed.result.error.InfraErrorIdentifier;
-import com.android.tradefed.util.ZipUtil;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.StringReader;
-import java.util.Properties;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
-/**
- * Provides a {@link IBuildInfo} based on a local OTA zip file.
- */
-public class OtaZipfileBuildProvider implements IBuildProvider {
-
-    @Option(name = "ota-path", description = "path to the OTA zipfile",
-            importance = Importance.IF_UNSET)
-    private String mOtaZipPath = null;
-
-    @Override
-    public IBuildInfo getBuild() throws BuildRetrievalError {
-        Properties buildProp = null;
-        try {
-            buildProp = new Properties();
-            buildProp.load(new StringReader(getBuildPropContents()));
-        } catch (IOException e) {
-            throw new BuildRetrievalError(
-                    "Error processing build.prop contents from file: " + getOtaPath(), e);
-        }
-        String bid = buildProp.getProperty(DeviceProperties.BUILD_ID);
-        IDeviceBuildInfo buildInfo = new DeviceBuildInfo(bid, bid);
-        buildInfo.setOtaPackageFile(new File(getOtaPath()), bid);
-        return buildInfo;
-
-    }
-
-    /**
-     * Package-private for testing
-     *
-     * @return an {@link InputStream} of the contents of the system/build.prop
-     *         file inside the OTA zipfile
-     * @throws BuildRetrievalError
-     */
-    String getBuildPropContents() throws BuildRetrievalError {
-        ZipFile otaZip = null;
-        try {
-            otaZip = new ZipFile(getOtaPath());
-            ZipEntry buildPropEntry = otaZip.getEntry("system/build.prop");
-            if (buildPropEntry == null) {
-                // no build.prop in the zip file
-                throw new BuildRetrievalError(
-                        "Couldn't find a build.prop file in OTA zip file " + getOtaPath(),
-                        InfraErrorIdentifier.ARTIFACT_NOT_FOUND);
-            }
-            StringBuilder body = new StringBuilder();
-            BufferedReader reader = new BufferedReader(
-                    new InputStreamReader(otaZip.getInputStream(buildPropEntry)));
-            String line = reader.readLine();
-            while (line != null) {
-                body.append(line).append("\n");
-                line = reader.readLine();
-            }
-
-            return body.toString();
-        } catch (IOException e) {
-            throw new BuildRetrievalError(
-                    "Failure while getting build.prop from OTA zipfile",
-                    e,
-                    InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
-        } finally {
-            ZipUtil.closeZip(otaZip);
-        }
-    }
-
-    @Override
-    public void cleanUp(IBuildInfo info) {
-        // ignore
-    }
-
-    String getOtaPath() {
-        if (mOtaZipPath == null || mOtaZipPath.isEmpty()) {
-            throw new IllegalArgumentException("Please pass ota-path");
-        }
-        return mOtaZipPath;
-    }
-}
diff --git a/src/com/android/tradefed/build/content/ContentAnalysisResults.java b/src/com/android/tradefed/build/content/ContentAnalysisResults.java
index 897338c1b..cc38fe58f 100644
--- a/src/com/android/tradefed/build/content/ContentAnalysisResults.java
+++ b/src/com/android/tradefed/build/content/ContentAnalysisResults.java
@@ -15,9 +15,12 @@
  */
 package com.android.tradefed.build.content;
 
+import build.bazel.remote.execution.v2.Digest;
 
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /** Summary of the content analysis. */
@@ -30,6 +33,8 @@ public class ContentAnalysisResults {
     private long buildKeyChanges = 0;
     private long deviceImageChanges = 0;
     private Set<String> unchangedModules = new HashSet<>();
+    private Set<String> modifiedModuleNames = new HashSet<>();
+    private Map<String, Digest> imageToDigest = new LinkedHashMap<>();
 
     public ContentAnalysisResults() {}
 
@@ -53,11 +58,17 @@ public class ContentAnalysisResults {
         return this;
     }
 
-    public ContentAnalysisResults addModifiedModule() {
+    public ContentAnalysisResults addModifiedModule(String moduleBaseName) {
+        modifiedModuleNames.add(moduleBaseName);
         modifiedModules++;
         return this;
     }
 
+    public ContentAnalysisResults addImageDigestMapping(String imageFileName, Digest digest) {
+        imageToDigest.put(imageFileName, digest);
+        return this;
+    }
+
     public ContentAnalysisResults addChangedBuildKey(long count) {
         buildKeyChanges += count;
         return this;
@@ -72,7 +83,7 @@ public class ContentAnalysisResults {
     public boolean hasAnyTestsChange() {
         if (modifiedFiles > 0
                 || sharedFolderChanges > 0
-                || modifiedModules > 0
+                || modifiedModuleNames.size() > 0
                 || buildKeyChanges > 0) {
             return true;
         }
@@ -87,6 +98,18 @@ public class ContentAnalysisResults {
         return deviceImageChanges > 0;
     }
 
+    public boolean hasSharedFolderChanges() {
+        return sharedFolderChanges > 0;
+    }
+
+    public Set<String> getUnchangedModules() {
+        return unchangedModules;
+    }
+
+    public Map<String, Digest> getImageToDigest() {
+        return imageToDigest;
+    }
+
     @Override
     public String toString() {
         return "ContentAnalysisResults [unchangedFiles="
@@ -117,8 +140,12 @@ public class ContentAnalysisResults {
             mergedResults.modifiedModules += res.modifiedModules;
             mergedResults.buildKeyChanges += res.buildKeyChanges;
             mergedResults.unchangedModules.addAll(res.unchangedModules);
+            mergedResults.modifiedModuleNames.addAll(res.modifiedModuleNames);
             mergedResults.deviceImageChanges += res.deviceImageChanges;
+            mergedResults.imageToDigest.putAll(res.imageToDigest);
         }
+        // Re-align what didn't change across analysis.
+        mergedResults.unchangedModules.removeAll(mergedResults.modifiedModuleNames);
         return mergedResults;
     }
 }
diff --git a/src/com/android/tradefed/build/content/ContentInformation.java b/src/com/android/tradefed/build/content/ContentInformation.java
index e26061848..da30abd17 100644
--- a/src/com/android/tradefed/build/content/ContentInformation.java
+++ b/src/com/android/tradefed/build/content/ContentInformation.java
@@ -36,6 +36,13 @@ public class ContentInformation {
         this.currentBuildId = currentBuildId;
     }
 
+    public boolean isValid() {
+        return baseContent != null
+                && baseBuildId != null
+                && currentContent != null
+                && currentBuildId != null;
+    }
+
     public void clean() {
         FileUtil.deleteFile(baseContent);
         FileUtil.deleteFile(currentContent);
diff --git a/src/com/android/tradefed/build/content/DeviceMerkleTree.java b/src/com/android/tradefed/build/content/DeviceMerkleTree.java
new file mode 100644
index 000000000..a17150dc3
--- /dev/null
+++ b/src/com/android/tradefed/build/content/DeviceMerkleTree.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.build.content;
+
+import com.android.tradefed.build.content.ArtifactDetails.ArtifactFileDescriptor;
+import com.android.tradefed.cache.DigestCalculator;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import build.bazel.remote.execution.v2.Digest;
+import build.bazel.remote.execution.v2.Directory;
+import build.bazel.remote.execution.v2.FileNode;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+/** Compute a MerkleTree from the device content information. */
+public class DeviceMerkleTree {
+
+    /** Builds a merkle tree and returns the root digest from the device content informaton */
+    public static Digest buildFromContext(ContentAnalysisContext context) {
+        try {
+            ArtifactDetails currentContent =
+                    ArtifactDetails.parseFile(
+                            context.contentInformation().currentContent, context.contentEntry());
+            Directory.Builder rootBuilder = Directory.newBuilder();
+            List<ArtifactFileDescriptor> allFiles = currentContent.details;
+            ImageContentAnalyzer.normalizeDeviceImage(allFiles);
+            // Sort to ensure final messages are identical
+            Collections.sort(
+                    allFiles,
+                    new Comparator<ArtifactFileDescriptor>() {
+                        @Override
+                        public int compare(
+                                ArtifactFileDescriptor arg0, ArtifactFileDescriptor arg1) {
+                            return arg0.path.compareTo(arg1.path);
+                        }
+                    });
+            for (ArtifactFileDescriptor afd : currentContent.details) {
+                Digest digest =
+                        Digest.newBuilder().setHash(afd.digest).setSizeBytes(afd.size).build();
+                rootBuilder.addFiles(
+                        FileNode.newBuilder()
+                                .setDigest(digest)
+                                .setName(afd.path)
+                                .setIsExecutable(false));
+            }
+            Directory root = rootBuilder.build();
+            Digest d = DigestCalculator.compute(root);
+            CLog.d("Digest for '%s' is '%s'", context.contentEntry(), d);
+            return d;
+        } catch (IOException | RuntimeException e) {
+            CLog.e(e);
+            return null;
+        }
+    }
+}
diff --git a/src/com/android/tradefed/build/content/ImageContentAnalyzer.java b/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
index 48061af3a..d718f7eda 100644
--- a/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
+++ b/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
@@ -22,6 +22,7 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetr
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.skipped.AnalysisHeuristic;
+import com.android.tradefed.testtype.suite.SuiteResultCacheUtil;
 
 import com.google.api.client.util.Joiner;
 
@@ -45,6 +46,23 @@ public class ImageContentAnalyzer {
         this.mAnalysisLevel = analysisLevel;
     }
 
+    /** Remove descriptors for files that do not impact the device image functionally */
+    public static void normalizeDeviceImage(List<ArtifactFileDescriptor> allDescriptors) {
+        // Remove all build.prop paths
+        allDescriptors.removeIf(d -> d.path.endsWith("/build.prop"));
+        allDescriptors.removeIf(d -> d.path.endsWith("/prop.default"));
+        allDescriptors.removeIf(d -> d.path.endsWith("/default.prop"));
+        // Remove all notices they don't change the image
+        allDescriptors.removeIf(d -> d.path.endsWith("/etc/NOTICE.xml.gz"));
+        // Remove build time flags, we will catch other files that are changing
+        allDescriptors.removeIf(d -> d.path.endsWith("/etc/build_flags.json"));
+        // Remove all IMAGES/ paths
+        allDescriptors.removeIf(d -> d.path.startsWith("IMAGES/"));
+        allDescriptors.removeIf(d -> d.path.startsWith("META/"));
+        allDescriptors.removeIf(d -> d.path.startsWith("PREBUILT_IMAGES/"));
+        allDescriptors.removeIf(d -> d.path.startsWith("RADIO/"));
+    }
+
     public ContentAnalysisResults evaluate() {
         List<ContentAnalysisContext> activeContexts = new ArrayList<>(contexts);
         try (CloseableTraceScope ignored = new CloseableTraceScope("image_analysis")) {
@@ -97,6 +115,8 @@ public class ImageContentAnalyzer {
                                     "build key '%s' was unchanged.",
                                     context.contentEntry());
                         }
+                        results.addImageDigestMapping(
+                                context.contentEntry(), DeviceMerkleTree.buildFromContext(context));
                         break;
                     case DEVICE_IMAGE:
                         long changeCount = deviceImageAnalysis(context);
@@ -104,6 +124,9 @@ public class ImageContentAnalyzer {
                             CLog.d("device image '%s' has changed.", context.contentEntry());
                             results.addDeviceImageChanges(changeCount);
                         }
+                        results.addImageDigestMapping(
+                                SuiteResultCacheUtil.DEVICE_IMAGE_KEY,
+                                DeviceMerkleTree.buildFromContext(context));
                         break;
                     default:
                         break;
@@ -145,19 +168,7 @@ public class ImageContentAnalyzer {
                             context.contentInformation(), context.contentEntry());
             // Remove paths that are ignored
             diffs.removeIf(d -> context.ignoredChanges().contains(d.path));
-            // Remove all build.prop paths
-            diffs.removeIf(d -> d.path.endsWith("/build.prop"));
-            diffs.removeIf(d -> d.path.endsWith("/prop.default"));
-            diffs.removeIf(d -> d.path.endsWith("/default.prop"));
-            // Remove all notices they don't change the image
-            diffs.removeIf(d -> d.path.endsWith("/etc/NOTICE.xml.gz"));
-            // Remove build time flags, we will catch other files that are changing
-            diffs.removeIf(d -> d.path.endsWith("/etc/build_flags.json"));
-            // Remove all IMAGES/ paths
-            diffs.removeIf(d -> d.path.startsWith("IMAGES/"));
-            diffs.removeIf(d -> d.path.startsWith("META/"));
-            diffs.removeIf(d -> d.path.startsWith("PREBUILT_IMAGES/"));
-            diffs.removeIf(d -> d.path.startsWith("RADIO/"));
+            normalizeDeviceImage(diffs);
             if (mAnalysisLevel.ordinal() >= AnalysisHeuristic.REMOVE_EXEMPTION.ordinal()) {
                 boolean removed = false;
                 // b/335722003
diff --git a/src/com/android/tradefed/build/content/TestContentAnalyzer.java b/src/com/android/tradefed/build/content/TestContentAnalyzer.java
index dd82241c9..83503b007 100644
--- a/src/com/android/tradefed/build/content/TestContentAnalyzer.java
+++ b/src/com/android/tradefed/build/content/TestContentAnalyzer.java
@@ -227,7 +227,7 @@ public class TestContentAnalyzer {
                     CLog.d("Module %s directory has changed: %s", moduleDir.getName(), moduleDiff);
                     InvocationMetricLogger.addInvocationMetrics(
                             InvocationMetricKey.XTS_MODULE_WITH_DIFFS, 1);
-                    results.addModifiedModule();
+                    results.addModifiedModule(moduleDir.getName());
                 }
             } else {
                 String relativeRootFilePath =
@@ -356,7 +356,7 @@ public class TestContentAnalyzer {
                     CLog.d("Module %s directory has changed: %s", module, moduleDiff);
                     InvocationMetricLogger.addInvocationMetrics(
                             InvocationMetricKey.WOKRDIR_MODULE_WITH_DIFFS, 1);
-                    results.addModifiedModule();
+                    results.addModifiedModule(module);
                 }
             }
         } else {
@@ -402,7 +402,7 @@ public class TestContentAnalyzer {
                                     moduleDir.getName(), moduleDiff);
                             InvocationMetricLogger.addInvocationMetrics(
                                     InvocationMetricKey.WOKRDIR_MODULE_WITH_DIFFS, 1);
-                            results.addModifiedModule();
+                            results.addModifiedModule(moduleDir.getName());
                         }
                     }
                 }
diff --git a/src/com/android/tradefed/cluster/ClusterBuildProvider.java b/src/com/android/tradefed/cluster/ClusterBuildProvider.java
index 940cf825b..0663e0864 100644
--- a/src/com/android/tradefed/cluster/ClusterBuildProvider.java
+++ b/src/com/android/tradefed/cluster/ClusterBuildProvider.java
@@ -16,17 +16,21 @@
 package com.android.tradefed.cluster;
 
 import com.android.annotations.VisibleForTesting;
+import com.android.tradefed.build.BuildInfoKey;
 import com.android.tradefed.build.BuildRetrievalError;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IBuildProvider;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.invoker.ExecutionFiles;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.invoker.logger.InvocationLocal;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.FuseUtil;
 import com.android.tradefed.util.TarUtil;
 import com.android.tradefed.util.ZipUtil2;
+
 import org.apache.commons.compress.archivers.zip.ZipFile;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,7 +39,9 @@ import java.io.File;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 /** A {@link IBuildProvider} to download TFC test resources. */
@@ -59,6 +65,9 @@ public class ClusterBuildProvider implements IBuildProvider {
     @Option(name = "build-target", description = "Build target name")
     private String mBuildTarget = "stub";
 
+    @Option(name = "build-attribute", description = "Build attributes to supply")
+    private Map<String, String> mBuildAttributes = new HashMap<String, String>();
+
     // The keys are the URLs; the values are the downloaded files shared among all build providers
     // in the invocation.
     // TODO(b/139876060): Use dynamic download when it supports caching HTTPS and GCS files.
@@ -136,6 +145,12 @@ public class ClusterBuildProvider implements IBuildProvider {
             }
             buildInfo.setFile(resource.getName(), file, DEFAULT_FILE_VERSION);
         }
+        buildInfo.addBuildAttributes(mBuildAttributes);
+        File testsDir = buildInfo.getFile(BuildInfoKey.BuildInfoFileKey.TESTDIR_IMAGE);
+        if (testsDir != null && CurrentInvocation.getInvocationFiles() != null) {
+            CurrentInvocation.getInvocationFiles()
+                    .put(ExecutionFiles.FilesKey.TESTS_DIRECTORY, testsDir);
+        }
         return buildInfo;
     }
 
diff --git a/src/com/android/tradefed/cluster/ClusterCommandConfigBuilder.java b/src/com/android/tradefed/cluster/ClusterCommandConfigBuilder.java
index 6360c163c..ecd880205 100644
--- a/src/com/android/tradefed/cluster/ClusterCommandConfigBuilder.java
+++ b/src/com/android/tradefed/cluster/ClusterCommandConfigBuilder.java
@@ -303,6 +303,9 @@ public class ClusterCommandConfigBuilder {
         for (String excludedFile : mTestEnvironment.getExcludedFilesInJavaClasspath()) {
             config.injectOptionValue("cluster:exclude-file-in-java-classpath", excludedFile);
         }
+        for (Map.Entry<String, String> entry : mTestEnvironment.getBuildAttributes().entrySet()) {
+            config.injectOptionValue("cluster:build-attribute", entry.getKey(), entry.getValue());
+        }
 
         List<TestResource> testResources = new ArrayList<>();
         testResources.addAll(mTestResources);
diff --git a/src/com/android/tradefed/cluster/TestEnvironment.java b/src/com/android/tradefed/cluster/TestEnvironment.java
index 912c8a608..61b526320 100644
--- a/src/com/android/tradefed/cluster/TestEnvironment.java
+++ b/src/com/android/tradefed/cluster/TestEnvironment.java
@@ -47,6 +47,7 @@ public class TestEnvironment {
     final List<TradefedConfigObject> mTradefedConfigObjects = new ArrayList<>();
     boolean mUseParallelSetup = false;
     private final List<String> mExcludedFilesInJavaClasspath = new ArrayList<>();
+    private final Map<String, String> mBuildAttributes = new HashMap<>();
 
     /**
      * Adds an environment variable.
@@ -257,14 +258,34 @@ public class TestEnvironment {
         return Collections.unmodifiableList(mExcludedFilesInJavaClasspath);
     }
 
+    @VisibleForTesting
+    void addBuildAttribute(String key, String value) {
+        mBuildAttributes.put(key, value);
+    }
+
+    /**
+     * Returns a {@link Map} object containing all build attrbitues.
+     *
+     * @return unmodifiable map of all build attributes
+     */
+    public Map<String, String> getBuildAttributes() {
+        return Collections.unmodifiableMap(mBuildAttributes);
+    }
+
+    private static Map<String, String> loadKeyValuePairs(JSONArray pairs) throws JSONException {
+        Map<String, String> map = new HashMap<>();
+        for (int i = 0; i < pairs.length(); i++) {
+            final JSONObject pair = pairs.getJSONObject(i);
+            map.put(pair.getString("key"), pair.getString("value"));
+        }
+        return map;
+    }
+
     public static TestEnvironment fromJson(JSONObject json) throws JSONException {
         TestEnvironment obj = new TestEnvironment();
         final JSONArray envVars = json.optJSONArray("env_vars");
         if (envVars != null) {
-            for (int i = 0; i < envVars.length(); i++) {
-                final JSONObject envVar = envVars.getJSONObject(i);
-                obj.addEnvVar(envVar.getString("key"), envVar.getString("value"));
-            }
+            obj.mEnvVars.putAll(loadKeyValuePairs(envVars));
         } else {
             CLog.w("env_vars is null");
         }
@@ -278,10 +299,7 @@ public class TestEnvironment {
         }
         final JSONArray javaProperties = json.optJSONArray("java_properties");
         if (javaProperties != null) {
-            for (int i = 0; i < javaProperties.length(); i++) {
-                final JSONObject javaProperty = javaProperties.getJSONObject(i);
-                obj.addJavaProperty(javaProperty.getString("key"), javaProperty.getString("value"));
-            }
+            obj.mJavaProperties.putAll(loadKeyValuePairs(javaProperties));
         } else {
             CLog.w("java_properties is null");
         }
@@ -334,6 +352,12 @@ public class TestEnvironment {
         } else {
             CLog.w("exclude_files_in_java_classpath is null");
         }
+        final JSONArray buildAttributes = json.optJSONArray("build_attributes");
+        if (buildAttributes != null) {
+            obj.mBuildAttributes.putAll(loadKeyValuePairs(buildAttributes));
+        } else {
+            CLog.w("build_attributes is null");
+        }
         return obj;
     }
 }
diff --git a/src/com/android/tradefed/command/CommandOptions.java b/src/com/android/tradefed/command/CommandOptions.java
index 97c783860..95271ce6a 100644
--- a/src/com/android/tradefed/command/CommandOptions.java
+++ b/src/com/android/tradefed/command/CommandOptions.java
@@ -258,6 +258,11 @@ public class CommandOptions implements ICommandOptions {
             description = "Map of experimental flags that can be used for feature gating projects.")
     private Map<String, String> mExperimentalFlags = new LinkedHashMap<>();
 
+    @Option(
+            name = "skip-trybot-experiment",
+            description = "Whether to skip experiments for TRYBOT runs.")
+    private boolean mSkipTrybotExperiment = true;
+
     @Deprecated
     @Option(
         name = "logcat-on-failure",
@@ -341,6 +346,25 @@ public class CommandOptions implements ICommandOptions {
                             + " folder instead of current one.")
     private File mJdkFolder;
 
+    @Option(
+            name = "remote-cache-instance-name",
+            description =
+                    "The name of the instance used to handle remote caching. Set this option to"
+                        + " enable caching in the test runners that support caching. The instance"
+                        + " name should be in this format:"
+                        + " projects/[PROJECT_ID]/instances/[INSTANCE_ID].")
+    private String mRemoteCacheInstanceName = null;
+
+    @Option(
+            name = "upload-cached-module-results",
+            description = "Whether or not to upload the results of a module to the cache")
+    private boolean mUploadCachedResults = false;
+
+    @Option(
+            name = "report-cache-results",
+            description = "Actually enable the reporting of caching status.")
+    private boolean mEnableModuleCachingResults = false;
+
     /**
      * Set the help mode for the config.
      * <p/>
@@ -646,6 +670,12 @@ public class CommandOptions implements ICommandOptions {
         return mExperimentalFlags;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean skipTrybotExperiment() {
+        return mSkipTrybotExperiment;
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean captureScreenshotOnFailure() {
@@ -847,4 +877,22 @@ public class CommandOptions implements ICommandOptions {
     public void setShouldUseEvenModuleSharding(boolean useEvenModuleSharding) {
         mEvenModuleSharding = useEvenModuleSharding;
     }
+
+    /** {@inheritDoc} */
+    @Override
+    public String getRemoteCacheInstanceName() {
+        return mRemoteCacheInstanceName;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean shouldUploadCacheResults() {
+        return mUploadCachedResults;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean reportCacheResults() {
+        return mEnableModuleCachingResults;
+    }
 }
diff --git a/src/com/android/tradefed/command/CommandScheduler.java b/src/com/android/tradefed/command/CommandScheduler.java
index 192e3f46f..4246664f9 100644
--- a/src/com/android/tradefed/command/CommandScheduler.java
+++ b/src/com/android/tradefed/command/CommandScheduler.java
@@ -17,7 +17,6 @@
 package com.android.tradefed.command;
 
 import com.android.ddmlib.DdmPreferences;
-import com.android.ddmlib.Log;
 import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.BuildInfo;
 import com.android.tradefed.build.BuildRetrievalError;
@@ -69,6 +68,7 @@ import com.android.tradefed.invoker.tracing.ActiveTrace;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.invoker.tracing.TracingLogger;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log;
 import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.ConsoleResultReporter;
@@ -633,30 +633,6 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                                 .getInvocationData()
                                 .containsKey(SubprocessTfLauncher.SUBPROCESS_TAG_NAME));
             }
-            // Set experimental flags
-            if (config.getCommandOptions().isExperimentEnabled()) {
-                for (Map.Entry<String, String> entry :
-                        config.getCommandOptions().getExperimentalFlags().entrySet()) {
-                    try {
-                        String optionName = entry.getKey();
-                        String optionValue = entry.getValue();
-                        // Support map experiments, where optionValue is a key=value pair
-                        int equalsIndex = optionValue.indexOf('=');
-                        if (equalsIndex != -1) {
-                            String mapKey = optionValue.substring(0, equalsIndex);
-                            String mapValue = optionValue.substring(equalsIndex + 1);
-                            config.injectOptionValue(optionName, mapKey, mapValue);
-                        } else {
-                            config.injectOptionValue(optionName, optionValue);
-                        }
-                        mInvocationContext.addInvocationAttribute(
-                                "experiment:" + optionName, optionValue);
-                    } catch (ConfigurationException e) {
-                        CLog.e("Configuration Exception caught while setting experimental flags.");
-                        CLog.e(e);
-                    }
-                }
-            }
             mStartTime = System.currentTimeMillis();
             ITestInvocation instance = getInvocation();
             instance.setClearcutClient(mClient);
@@ -680,6 +656,33 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                     mInvocationContext.addInvocationAttributes(
                             config.getCommandOptions().getInvocationData());
                 }
+                // Set experimental flags
+                if (config.getCommandOptions().isExperimentEnabled()
+                        && !skipExperiment(config, mInvocationContext)) {
+                    for (Map.Entry<String, String> entry :
+                            config.getCommandOptions().getExperimentalFlags().entrySet()) {
+                        try {
+                            String optionName = entry.getKey();
+                            String optionValue = entry.getValue();
+                            // Support map experiments, where optionValue is a key=value pair
+                            int equalsIndex = optionValue.indexOf('=');
+                            if (equalsIndex != -1) {
+                                String mapKey = optionValue.substring(0, equalsIndex);
+                                String mapValue = optionValue.substring(equalsIndex + 1);
+                                config.injectOptionValue(optionName, mapKey, mapValue);
+                            } else {
+                                config.injectOptionValue(optionName, optionValue);
+                            }
+                            mInvocationContext.addInvocationAttribute(
+                                    "experiment:" + optionName, optionValue);
+                        } catch (ConfigurationException e) {
+                            CLog.e(
+                                    "Configuration Exception caught while setting experimental"
+                                            + " flags.");
+                            CLog.e(e);
+                        }
+                    }
+                }
                 mCmd.commandStarted();
                 long invocTimeout = config.getCommandOptions().getInvocationTimeout();
                 if (invocTimeout > 0) {
@@ -980,6 +983,12 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                 }
             }
         }
+
+        private boolean skipExperiment(IConfiguration config, IInvocationContext context) {
+            // skip experiment for TRYBOT runs
+            return config.getCommandOptions().skipTrybotExperiment()
+                    && "TRYBOT".equals(context.getAttribute("trigger"));
+        }
     }
 
     /** Create a map of the devices state so they can be released appropriately. */
@@ -2251,9 +2260,9 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
      *
      * <p>Exposed so unit tests can mock.
      */
-    @SuppressWarnings("deprecation")
     protected void initLogging() {
-        DdmPreferences.setLogLevel(LogLevel.VERBOSE.getStringValue());
+        // Set ddmlib logging high so it doesn't print by default as we are migrating out of it.
+        DdmPreferences.setLogLevel(LogLevel.WARN.getStringValue());
         Log.setLogOutput(LogRegistry.getLogRegistry());
     }
 
@@ -2269,7 +2278,8 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
     /** log an event to the registry history logger. */
     @VisibleForTesting
     void logEvent(EventType event, Map<String, String> args) {
-        LogRegistry.getLogRegistry().logEvent(LogLevel.DEBUG, event, args);
+        LogRegistry.getLogRegistry()
+                .logEvent(com.android.tradefed.log.Log.LogLevel.DEBUG, event, args);
     }
 
     /** {@inheritDoc} */
diff --git a/src/com/android/tradefed/command/Console.java b/src/com/android/tradefed/command/Console.java
index 352700fc1..d0e0ad598 100644
--- a/src/com/android/tradefed/command/Console.java
+++ b/src/com/android/tradefed/command/Console.java
@@ -16,7 +16,6 @@
 
 package com.android.tradefed.command;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.clearcut.ClearcutClient;
 import com.android.tradefed.clearcut.TerminateClearcutClient;
 import com.android.tradefed.command.CommandRunner.ExitCode;
@@ -32,6 +31,7 @@ import com.android.tradefed.config.proxy.AutomatedReporters;
 import com.android.tradefed.device.IDeviceManager;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInvocation;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.FailureDescription;
@@ -61,6 +61,9 @@ import org.jline.reader.LineReaderBuilder;
 import org.jline.reader.impl.history.DefaultHistory;
 import org.jline.terminal.TerminalBuilder;
 
+import sun.misc.Signal;
+import sun.misc.SignalHandler;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
@@ -77,9 +80,6 @@ import java.util.TreeMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Pattern;
 
-import sun.misc.Signal;
-import sun.misc.SignalHandler;
-
 /**
  * Main TradeFederation console providing user with the interface to interact
  *
diff --git a/src/com/android/tradefed/command/ICommandOptions.java b/src/com/android/tradefed/command/ICommandOptions.java
index 4cc70c632..3cebde521 100644
--- a/src/com/android/tradefed/command/ICommandOptions.java
+++ b/src/com/android/tradefed/command/ICommandOptions.java
@@ -192,6 +192,9 @@ public interface ICommandOptions {
     /** Returns the experimental flags map, that can be used to feature gate projects. */
     public Map<String, String> getExperimentalFlags();
 
+    /** Whether to skip experiments for TRYBOT runs. */
+    public boolean skipTrybotExperiment();
+
     /** Whether or not to capture a screenshot on test case failure */
     public boolean captureScreenshotOnFailure();
 
@@ -296,4 +299,13 @@ public interface ICommandOptions {
 
     /** Set whether to attempt to distribute number of modules evenly across shards */
     public void setShouldUseEvenModuleSharding(boolean useEvenModuleSharding);
+
+    /** Returns the name of the instance used to handle remote caching. */
+    public String getRemoteCacheInstanceName();
+
+    /** Returns true if we should capture the results in the cache. */
+    public boolean shouldUploadCacheResults();
+
+    /** Returns true if we should report cache results when available. */
+    public boolean reportCacheResults();
 }
diff --git a/src/com/android/tradefed/config/Configuration.java b/src/com/android/tradefed/config/Configuration.java
index 139e08b0d..8b8a369da 100644
--- a/src/com/android/tradefed/config/Configuration.java
+++ b/src/com/android/tradefed/config/Configuration.java
@@ -112,6 +112,7 @@ public class Configuration implements IConfiguration {
     public static final Set<String> NON_MODULE_OBJECTS =
             ImmutableSet.of(
                     BUILD_PROVIDER_TYPE_NAME,
+                    CMD_OPTIONS_TYPE_NAME,
                     DEVICE_RECOVERY_TYPE_NAME,
                     LOGGER_TYPE_NAME,
                     LOG_SAVER_TYPE_NAME,
@@ -1438,6 +1439,7 @@ public class Configuration implements IConfiguration {
                     excludeFilters,
                     printDeprecatedOptions,
                     printUnchangedOptions);
+            output.flush();
         }
 
         for (IMultiTargetPreparer multipreparer : getMultiTargetPreparers()) {
diff --git a/src/com/android/tradefed/config/ConfigurationUtil.java b/src/com/android/tradefed/config/ConfigurationUtil.java
index fcc904fc9..01b5233fa 100644
--- a/src/com/android/tradefed/config/ConfigurationUtil.java
+++ b/src/com/android/tradefed/config/ConfigurationUtil.java
@@ -29,6 +29,8 @@ import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -138,6 +140,7 @@ public class ConfigurationUtil {
                     serializer, obj, transformer, printDeprecatedOptions, printUnchangedOptions);
             serializer.endTag(null, classTypeName);
         }
+        serializer.flush();
     }
 
     /**
@@ -167,8 +170,17 @@ public class ConfigurationUtil {
                 throw new RuntimeException(e);
             }
         }
-
-        for (Field field : OptionSetter.getOptionFieldsForClass(obj.getClass())) {
+        List<Field> fields = OptionSetter.getOptionFieldsForClass(obj.getClass());
+        // Sort fields to always print in same order
+        Collections.sort(
+                fields,
+                new Comparator<Field>() {
+                    @Override
+                    public int compare(Field arg0, Field arg1) {
+                        return arg0.getName().compareTo(arg1.getName());
+                    }
+                });
+        for (Field field : fields) {
             Option option = field.getAnnotation(Option.class);
             Deprecated deprecatedAnnotation = field.getAnnotation(Deprecated.class);
             // If enabled, skip @Deprecated options
@@ -213,6 +225,7 @@ public class ConfigurationUtil {
                 fieldVal = transformer.transform(obj, option, fieldVal);
                 dumpOptionToXml(serializer, option.name(), null, fieldVal.toString());
             }
+            serializer.flush();
         }
     }
 
diff --git a/src/com/android/tradefed/config/DynamicRemoteFileResolver.java b/src/com/android/tradefed/config/DynamicRemoteFileResolver.java
index b986f829a..5fb31a5aa 100644
--- a/src/com/android/tradefed/config/DynamicRemoteFileResolver.java
+++ b/src/com/android/tradefed/config/DynamicRemoteFileResolver.java
@@ -32,12 +32,14 @@ import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.ErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.testtype.suite.ITestSuite;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IDisableable;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.ZipUtil;
 import com.android.tradefed.util.ZipUtil2;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 
@@ -365,8 +367,21 @@ public class DynamicRemoteFileResolver {
         if (excludeFilters != null) {
             queryArgs.put("exclude_filters", String.join(";", excludeFilters));
         }
+
+        // TODO(rbraunstein): Consider changing to take map of args.
+        for (String key : ImmutableList.of(ITestSuite.ENABLE_RESOLVE_SYM_LINKS)) {
+            String value = mExtraArgs.get(key);
+            if (value != null) {
+                queryArgs.put(key, value);
+            }
+        }
         // Downloaded individual files should be saved to destDir, return value is not needed.
-        try {
+        try (CloseableTraceScope ignored =
+                new CloseableTraceScope(
+                        String.format(
+                                "resolvePartialDownload %s, %s, %s",
+                                remoteZipFilePath, protocol, queryArgs))) {
+
             IRemoteFileResolver resolver = getResolver(protocol);
             resolver.setPrimaryDevice(mDevice);
             RemoteFileResolverArgs args = new RemoteFileResolverArgs();
@@ -388,7 +403,7 @@ public class DynamicRemoteFileResolver {
 
     private IRemoteFileResolver getResolver(String protocol) throws BuildRetrievalError {
         try {
-        return mFileResolverLoader.load(protocol, mExtraArgs);
+            return mFileResolverLoader.load(protocol, mExtraArgs);
         } catch (ResolverLoadingException e) {
             throw new BuildRetrievalError(
                     String.format("Could not load resolver for protocol %s", protocol), e);
@@ -440,7 +455,7 @@ public class DynamicRemoteFileResolver {
         String protocol;
         Map<String, String> query;
         try {
-            URI uri = new URI(path.replace('\\','/'));
+            URI uri = new URI(path.replace('\\', '/'));
             protocol = uri.getScheme();
             query = parseQuery(uri.getQuery());
             fileToResolve = new File(protocol + ":" + uri.getPath());
diff --git a/src/com/android/tradefed/config/OptionSetter.java b/src/com/android/tradefed/config/OptionSetter.java
index cf08c63b4..b93432809 100644
--- a/src/com/android/tradefed/config/OptionSetter.java
+++ b/src/com/android/tradefed/config/OptionSetter.java
@@ -801,8 +801,8 @@ public class OptionSetter {
      * @param optionClass the {@link Class} to search
      * @return a {@link Collection} of fields annotated with {@link Option}
      */
-    public static Collection<Field> getOptionFieldsForClass(final Class<?> optionClass) {
-        Collection<Field> fieldList = new ArrayList<Field>();
+    public static List<Field> getOptionFieldsForClass(final Class<?> optionClass) {
+        List<Field> fieldList = new ArrayList<Field>();
         buildOptionFieldsForClass(optionClass, fieldList);
         return fieldList;
     }
diff --git a/src/com/android/tradefed/config/filter/OptionFetcher.java b/src/com/android/tradefed/config/filter/OptionFetcher.java
index 63ed71f16..1b32c2d7f 100644
--- a/src/com/android/tradefed/config/filter/OptionFetcher.java
+++ b/src/com/android/tradefed/config/filter/OptionFetcher.java
@@ -47,7 +47,10 @@ public class OptionFetcher implements AutoCloseable {
                     "auto-collect",
                     "skip-retry-in-presubmit",
                     "skip-retrying-list",
-                    "remote-dynamic-sharding");
+                    "remote-dynamic-sharding",
+                    "remote-cache-instance-name",
+                    "upload-cached-module-results",
+                    "report-cache-results");
 
     private TradefedFeatureClient mClient;
 
diff --git a/src/com/android/tradefed/config/remote/ExtendedFile.java b/src/com/android/tradefed/config/remote/ExtendedFile.java
index 044f4eb0f..4c1337a1b 100644
--- a/src/com/android/tradefed/config/remote/ExtendedFile.java
+++ b/src/com/android/tradefed/config/remote/ExtendedFile.java
@@ -20,6 +20,7 @@ import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 
 import java.io.File;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
 /** A extension of standard file to carry a build related metadata. */
@@ -31,6 +32,7 @@ public class ExtendedFile extends File {
     private String mRemoteFilePath;
 
     private Future<BuildRetrievalError> mParallelDownload;
+    private ExecutorService mExecutorService;
 
     ExtendedFile(String path) {
         super(path);
@@ -77,6 +79,12 @@ public class ExtendedFile extends File {
         mParallelDownload = download;
     }
 
+    public void setDownloadFuture(
+            ExecutorService serviceUsed, Future<BuildRetrievalError> download) {
+        mExecutorService = serviceUsed;
+        mParallelDownload = download;
+    }
+
     public void cancelDownload() {
         if (!isDownloadingInParallel()) {
             return;
@@ -85,6 +93,10 @@ public class ExtendedFile extends File {
             mParallelDownload.cancel(true);
         } catch (RuntimeException ignored) {
             // Ignore
+        } finally {
+            if (mExecutorService != null) {
+                mExecutorService.shutdown();
+            }
         }
     }
 
@@ -101,6 +113,10 @@ public class ExtendedFile extends File {
         } catch (ExecutionException | InterruptedException e) {
             throw new BuildRetrievalError(
                     String.format("Error during parallel download: %s", e.getMessage()), e);
+        } finally {
+            if (mExecutorService != null) {
+                mExecutorService.shutdown();
+            }
         }
     }
 
diff --git a/src/com/android/tradefed/config/remote/GcsRemoteFileResolver.java b/src/com/android/tradefed/config/remote/GcsRemoteFileResolver.java
index 14cd52bb9..8650eaf72 100644
--- a/src/com/android/tradefed/config/remote/GcsRemoteFileResolver.java
+++ b/src/com/android/tradefed/config/remote/GcsRemoteFileResolver.java
@@ -36,6 +36,7 @@ import java.util.AbstractMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
@@ -63,10 +64,29 @@ public class GcsRemoteFileResolver implements IRemoteFileResolver {
         File destFile = GCSFileDownloader.createTempFileForRemote(path, null);
         try {
             if (canUseParallelDownload(args.getQueryArgs())) {
+                ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();
+                ThreadFactory factory =
+                        new ThreadFactory() {
+                            @Override
+                            public Thread newThread(Runnable r) {
+                                Thread t =
+                                        new Thread(
+                                                currentGroup,
+                                                r,
+                                                "gcs-pool-task-" + poolNumber.getAndIncrement());
+                                t.setDaemon(true);
+                                return t;
+                            }
+                        };
+                ExecutorService service =
+                        TracePropagatingExecutorService.create(
+                                Executors.newFixedThreadPool(1, factory));
                 Entry<File, Future<BuildRetrievalError>> parallelDownload =
-                        fetchResourceWithRetryParallel(path, args.getQueryArgs(), destFile);
+                        fetchResourceWithRetryParallel(
+                                service, path, args.getQueryArgs(), destFile);
+
                 ExtendedFile eFile = new ExtendedFile(parallelDownload.getKey(), "gcs", "gcs");
-                eFile.setDownloadFuture(parallelDownload.getValue());
+                eFile.setDownloadFuture(service, parallelDownload.getValue());
                 // Return the file with metadata
                 return new ResolvedFile(eFile);
             } else {
@@ -129,7 +149,8 @@ public class GcsRemoteFileResolver implements IRemoteFileResolver {
     }
 
     private Entry<File, Future<BuildRetrievalError>> fetchResourceWithRetryParallel(
-            String path, Map<String, String> queryArgs, File destFile) throws IOException {
+            ExecutorService service, String path, Map<String, String> queryArgs, File destFile)
+            throws IOException {
         String unzipValue = queryArgs.get(DynamicRemoteFileResolver.UNZIP_KEY);
         boolean useDirectory = unzipValue != null && "true".equals(unzipValue.toLowerCase());
         File possibleDir = null;
@@ -139,20 +160,6 @@ public class GcsRemoteFileResolver implements IRemoteFileResolver {
                             FileUtil.getBaseName(destFile.getName()),
                             CurrentInvocation.getInfo(InvocationInfo.WORK_FOLDER));
         }
-        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();
-        ThreadFactory factory =
-                new ThreadFactory() {
-                    @Override
-                    public Thread newThread(Runnable r) {
-                        Thread t =
-                                new Thread(
-                                        currentGroup,
-                                        r,
-                                        "gcs-pool-task-" + poolNumber.getAndIncrement());
-                        t.setDaemon(true);
-                        return t;
-                    }
-                };
         File destDir = possibleDir;
         CompletableFuture<BuildRetrievalError> futureClient =
                 CompletableFuture.supplyAsync(
@@ -171,8 +178,7 @@ public class GcsRemoteFileResolver implements IRemoteFileResolver {
                                 return e;
                             }
                         },
-                        TracePropagatingExecutorService.create(
-                                Executors.newFixedThreadPool(1, factory)));
+                        service);
         if (useDirectory) {
             return new AbstractMap.SimpleEntry<File, Future<BuildRetrievalError>>(
                     destDir, futureClient);
diff --git a/src/com/android/tradefed/device/DeviceManager.java b/src/com/android/tradefed/device/DeviceManager.java
index 3d07a379d..9f01ac82a 100644
--- a/src/com/android/tradefed/device/DeviceManager.java
+++ b/src/com/android/tradefed/device/DeviceManager.java
@@ -20,7 +20,6 @@ import com.android.ddmlib.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.ddmlib.DdmPreferences;
 import com.android.ddmlib.IDevice;
 import com.android.ddmlib.IDevice.DeviceState;
-import com.android.ddmlib.Log.LogLevel;
 import com.android.ddmlib.PropertyFetcher;
 import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.config.GlobalConfiguration;
@@ -33,6 +32,7 @@ import com.android.tradefed.device.cloud.VmRemoteDevice;
 import com.android.tradefed.host.IHostOptions;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
diff --git a/src/com/android/tradefed/device/ManagedDeviceList.java b/src/com/android/tradefed/device/ManagedDeviceList.java
index f8e82affd..197b78ddd 100644
--- a/src/com/android/tradefed/device/ManagedDeviceList.java
+++ b/src/com/android/tradefed/device/ManagedDeviceList.java
@@ -142,12 +142,16 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
      * @return the {@link IManagedTestDevice} or <code>null</code> if not found
      */
     public IManagedTestDevice find(final String serialNumber) {
-        return find(new IMatcher<IManagedTestDevice>() {
-            @Override
-            public boolean matches(IManagedTestDevice element) {
-                return serialNumber.equals(element.getSerialNumber());
-            }
-        });
+        return find(
+                new IMatcher<IManagedTestDevice>() {
+                    @Override
+                    public boolean matches(IManagedTestDevice element) {
+                        // For TCP devices if we find their tracking serial or serial, allow the
+                        // match
+                        return serialNumber.equals(element.getTrackingSerial())
+                                || serialNumber.equals(element.getSerialNumber());
+                    }
+                });
     }
 
     private IManagedTestDevice find(IMatcher<IManagedTestDevice> m) {
@@ -289,12 +293,23 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
         if (!isValidDeviceSerial(serial)) {
             return null;
         }
+        boolean setTracking = false;
+        // We spy for Tcp devices that aren't virtual (physical devices connected via tcp) and track
+        // them via their true serial.
+        // This should not be applied to Cuttlefish devices (virtual)
         if (isTcpDeviceSerial(serial)) {
             // Override serial for tcp devices into their real one
             try {
                 String realSerial = idevice.getProperty("ro.serialno");
                 if (!Strings.isNullOrEmpty(realSerial)) {
+                    // If the device happen to already exists, re-check it to ensure we update
+                    // tracking.
+                    IManagedTestDevice d = find(serial);
+                    if (d != null) {
+                        d.setTrackingSerial(realSerial);
+                    }
                     serial = realSerial.trim();
+                    setTracking = true;
                 }
             } catch (RuntimeException e) {
                 CLog.e(e);
@@ -306,6 +321,9 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
             if (d == null || DeviceAllocationState.Unavailable.equals(d.getAllocationState())) {
                 mList.remove(d);
                 d = mDeviceFactory.createDevice(idevice);
+                if (setTracking) {
+                    d.setTrackingSerial(serial);
+                }
                 mList.add(d);
             }
             return d;
@@ -330,7 +348,6 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
         try {
             IManagedTestDevice d = find(fastboot.getSerialNumber());
             if (d == null) {
-                mList.remove(d);
                 d = mDeviceFactory.createDevice(fastboot);
                 mList.add(d);
             }
diff --git a/src/com/android/tradefed/device/NativeDevice.java b/src/com/android/tradefed/device/NativeDevice.java
index 3dafb0a9b..2c8eb8862 100644
--- a/src/com/android/tradefed/device/NativeDevice.java
+++ b/src/com/android/tradefed/device/NativeDevice.java
@@ -29,7 +29,6 @@ import com.android.ddmlib.SyncService;
 import com.android.ddmlib.TimeoutException;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
 import com.android.ddmlib.testrunner.ITestRunListener;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.config.ConfigurationException;
@@ -59,6 +58,7 @@ import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.SnapshotInputStreamSource;
 import com.android.tradefed.result.StubTestRunListener;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.result.ddmlib.TestRunToTestInvocationForwarder;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
@@ -256,6 +256,7 @@ public class NativeDevice
     private DeviceDescriptor mCachedDeviceDescriptor = null;
     private final Object mCacheLock = new Object();
 
+    private String mTrackingSerialNumber = null;
     private String mFastbootSerialNumber = null;
     private File mUnpackedFastbootDir = null;
     // Connection for the device.
@@ -575,6 +576,19 @@ public class NativeDevice
         return getIDevice().getSerialNumber();
     }
 
+    @Override
+    public void setTrackingSerial(String trackingSerial) {
+        mTrackingSerialNumber = trackingSerial;
+    }
+
+    @Override
+    public String getTrackingSerial() {
+        if (Strings.isNullOrEmpty(mTrackingSerialNumber)) {
+            return getSerialNumber();
+        }
+        return mTrackingSerialNumber;
+    }
+
     /**
      * Fetch a device property, from the ddmlib cache by default, and falling back to either `adb
      * shell getprop` or `fastboot getvar` depending on whether the device is in Fastboot or not.
@@ -1273,6 +1287,16 @@ public class NativeDevice
                     : userRunTimeOption;
             ((RemoteAndroidTestRunner) runner).setRunOptions(updated);
             return original;
+        } else if (runner instanceof com.android.ddmlib.testrunner.RemoteAndroidTestRunner) {
+            // Support a backward compatible runners through the interface
+            String original =
+                    ((com.android.ddmlib.testrunner.RemoteAndroidTestRunner) runner)
+                            .getRunOptions();
+            String userRunTimeOption = String.format("--user %s", Integer.toString(userId));
+            String updated =
+                    (original != null) ? (original + " " + userRunTimeOption) : userRunTimeOption;
+            ((com.android.ddmlib.testrunner.RemoteAndroidTestRunner) runner).setRunOptions(updated);
+            return original;
         } else {
             throw new IllegalStateException(String.format("%s runner does not support multi-user",
                     runner.getClass().getName()));
@@ -1287,10 +1311,14 @@ public class NativeDevice
      */
     private void resetUserRunTimeOptionToRunner(final IRemoteAndroidTestRunner runner,
             String oldRunTimeOptions) {
+        if (oldRunTimeOptions == null) {
+            return;
+        }
         if (runner instanceof RemoteAndroidTestRunner) {
-            if (oldRunTimeOptions != null) {
-                ((RemoteAndroidTestRunner) runner).setRunOptions(oldRunTimeOptions);
-            }
+            ((RemoteAndroidTestRunner) runner).setRunOptions(oldRunTimeOptions);
+        } else if (runner instanceof com.android.ddmlib.testrunner.RemoteAndroidTestRunner) {
+            ((com.android.ddmlib.testrunner.RemoteAndroidTestRunner) runner)
+                    .setRunOptions(oldRunTimeOptions);
         } else {
             throw new IllegalStateException(String.format("%s runner does not support multi-user",
                     runner.getClass().getName()));
@@ -1430,7 +1458,7 @@ public class NativeDevice
     @Override
     public boolean pullFile(final String remoteFilePath, final File localFile)
             throws DeviceNotAvailableException {
-        return pullFile(remoteFilePath, localFile, getCurrentUserCompatible());
+        return pullFile(remoteFilePath, localFile, getCurrentUserCompatible(remoteFilePath));
     }
 
     /** {@inheritDoc} */
@@ -1458,7 +1486,7 @@ public class NativeDevice
     /** {@inheritDoc} */
     @Override
     public File pullFile(String remoteFilePath) throws DeviceNotAvailableException {
-        return pullFile(remoteFilePath, getCurrentUserCompatible());
+        return pullFile(remoteFilePath, getCurrentUserCompatible(remoteFilePath));
     }
 
     /**
@@ -1550,7 +1578,7 @@ public class NativeDevice
     @Override
     public boolean pushFile(final File localFile, final String remoteFilePath)
             throws DeviceNotAvailableException {
-        return pushFile(localFile, remoteFilePath, getCurrentUserCompatible());
+        return pushFile(localFile, remoteFilePath, getCurrentUserCompatible(remoteFilePath));
     }
 
     @Override
@@ -1566,7 +1594,7 @@ public class NativeDevice
             boolean evaluateContentProviderNeeded)
             throws DeviceNotAvailableException {
         boolean skipContentProvider = false;
-        int userId = getCurrentUserCompatible();
+        int userId = getCurrentUserCompatible(remoteFilePath);
         if (evaluateContentProviderNeeded) {
             skipContentProvider = userId == 0;
         }
@@ -1667,7 +1695,7 @@ public class NativeDevice
     /** {@inheritDoc} */
     @Override
     public boolean doesFileExist(String deviceFilePath) throws DeviceNotAvailableException {
-        return doesFileExist(deviceFilePath, getCurrentUserCompatible());
+        return doesFileExist(deviceFilePath, getCurrentUserCompatible(deviceFilePath));
     }
 
     /** {@inheritDoc} */
@@ -1709,7 +1737,7 @@ public class NativeDevice
     /** {@inheritDoc} */
     @Override
     public void deleteFile(String deviceFilePath) throws DeviceNotAvailableException {
-        deleteFile(deviceFilePath, getCurrentUserCompatible());
+        deleteFile(deviceFilePath, getCurrentUserCompatible(deviceFilePath));
     }
 
     /** {@inheritDoc} */
@@ -2037,7 +2065,10 @@ public class NativeDevice
             File localFileDir, String deviceFilePath, Set<String> excludedDirectories)
             throws DeviceNotAvailableException {
         return pushDir(
-                localFileDir, deviceFilePath, excludedDirectories, getCurrentUserCompatible());
+                localFileDir,
+                deviceFilePath,
+                excludedDirectories,
+                getCurrentUserCompatible(deviceFilePath));
     }
 
     private boolean pushDir(
@@ -2103,7 +2134,7 @@ public class NativeDevice
     @Override
     public boolean pullDir(String deviceFilePath, File localDir)
             throws DeviceNotAvailableException {
-        return pullDir(deviceFilePath, localDir, getCurrentUserCompatible());
+        return pullDir(deviceFilePath, localDir, getCurrentUserCompatible(deviceFilePath));
     }
 
     /** {@inheritDoc} */
@@ -5079,7 +5110,10 @@ public class NativeDevice
     }
 
     /** Used internally to fallback to non-user logic */
-    private int getCurrentUserCompatible() throws DeviceNotAvailableException {
+    private int getCurrentUserCompatible(String devicePath) throws DeviceNotAvailableException {
+        if (!isSdcardOrEmulated(devicePath)) {
+            return 0;
+        }
         try {
             return getCurrentUser();
         } catch (RuntimeException e) {
@@ -5460,7 +5494,9 @@ public class NativeDevice
             }
             return new DeviceDescriptor(
                     idevice.getSerialNumber(),
-                    null,
+                    (mTrackingSerialNumber != null)
+                            ? idevice.getSerialNumber() + "[" + mTrackingSerialNumber + "]"
+                            : null,
                     idevice instanceof StubDevice,
                     idevice.getState(),
                     getAllocationState(),
diff --git a/src/com/android/tradefed/device/NativeDeviceStateMonitor.java b/src/com/android/tradefed/device/NativeDeviceStateMonitor.java
index e106403cd..3280fd8da 100644
--- a/src/com/android/tradefed/device/NativeDeviceStateMonitor.java
+++ b/src/com/android/tradefed/device/NativeDeviceStateMonitor.java
@@ -21,6 +21,7 @@ import com.android.ddmlib.IDevice;
 import com.android.ddmlib.ShellCommandUnresponsiveException;
 import com.android.ddmlib.TimeoutException;
 import com.android.tradefed.device.IDeviceManager.IFastbootListener;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
@@ -55,7 +56,8 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
     /** the time in ms to wait between 'poll for responsiveness' attempts */
     private static final long CHECK_POLL_TIME = 1 * 1000;
 
-    protected static final long MAX_CHECK_POLL_TIME = 10 * 1000;
+    protected static final long MAX_CHECK_POLL_TIME = 3 * 1000;
+
     /** the maximum operation time in ms for a 'poll for responsiveness' command */
     protected static final int MAX_OP_TIME = 10 * 1000;
     /** Reference for TMPFS from 'man statfs' */
@@ -75,6 +77,7 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
     private IDeviceManager mMgr;
     private final boolean mFastbootEnabled;
     private boolean mMountFileSystemCheckEnabled = false;
+    private TestDeviceState mFinalState = null;
 
     protected static final String PERM_DENIED_ERROR_PATTERN = "Permission denied";
 
@@ -88,6 +91,11 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
         mMountFileSystemCheckEnabled = mMgr.isFileSystemMountCheckEnabled();
     }
 
+    @Override
+    public void attachFinalState(TestDeviceState finalState) {
+        mFinalState = finalState;
+    }
+
     /**
      * Get the {@link RunUtil} instance to use.
      * <p/>
@@ -129,8 +137,10 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
      */
     @Override
     public IDevice waitForDeviceOnline(long waitTime) {
-        if (waitForDeviceState(TestDeviceState.ONLINE, waitTime)) {
-            return getIDevice();
+        try (CloseableTraceScope ignored = new CloseableTraceScope("waitForDeviceOnline")) {
+            if (waitForDeviceState(TestDeviceState.ONLINE, waitTime)) {
+                return getIDevice();
+            }
         }
         return null;
     }
@@ -304,57 +314,59 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
      */
     @Override
     public boolean waitForBootComplete(final long waitTime) {
-        CLog.i("Waiting %d ms for device %s boot complete", waitTime, getSerialNumber());
-        long start = System.currentTimeMillis();
-        // For the first boot (first adb command after ONLINE state), we allow a few miscall for
-        // stability.
-        int[] offlineCount = new int[1];
-        offlineCount[0] = 5;
-        Callable<BUSY_WAIT_STATUS> bootComplete =
-                () -> {
-                    final String cmd = "getprop " + BOOTCOMPLETE_PROP;
-                    try {
-                        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
-                        getIDevice()
-                                .executeShellCommand(
-                                        "getprop " + BOOTCOMPLETE_PROP,
-                                        receiver,
-                                        60000L,
-                                        TimeUnit.MILLISECONDS);
-                        String bootFlag = receiver.getOutput();
-                        if (bootFlag != null) {
-                            // Workaround for microdroid: `adb shell` prints permission warnings
-                            bootFlag = bootFlag.lines().reduce((a, b) -> b).orElse(null);
-                        }
-                        if (bootFlag != null && "1".equals(bootFlag.trim())) {
-                            return BUSY_WAIT_STATUS.SUCCESS;
-                        }
-                    } catch (IOException | ShellCommandUnresponsiveException e) {
-                        CLog.e("%s failed on: %s", cmd, getSerialNumber());
-                        CLog.e(e);
-                    } catch (TimeoutException e) {
-                        CLog.e("%s failed on %s: timeout", cmd, getSerialNumber());
-                        CLog.e(e);
-                    } catch (AdbCommandRejectedException e) {
-                        CLog.e("%s failed on: %s", cmd, getSerialNumber());
-                        CLog.e(e);
-                        if (e.isDeviceOffline() || e.wasErrorDuringDeviceSelection()) {
-                            offlineCount[0]--;
-                            if (offlineCount[0] <= 0) {
-                                return BUSY_WAIT_STATUS.ABORT;
+        try (CloseableTraceScope ignored = new CloseableTraceScope("waitForBootComplete")) {
+            CLog.i("Waiting %d ms for device %s boot complete", waitTime, getSerialNumber());
+            long start = System.currentTimeMillis();
+            // For the first boot (first adb command after ONLINE state), we allow a few miscall for
+            // stability.
+            int[] offlineCount = new int[1];
+            offlineCount[0] = 5;
+            Callable<BUSY_WAIT_STATUS> bootComplete =
+                    () -> {
+                        final String cmd = "getprop " + BOOTCOMPLETE_PROP;
+                        try {
+                            CollectingOutputReceiver receiver = new CollectingOutputReceiver();
+                            getIDevice()
+                                    .executeShellCommand(
+                                            "getprop " + BOOTCOMPLETE_PROP,
+                                            receiver,
+                                            60000L,
+                                            TimeUnit.MILLISECONDS);
+                            String bootFlag = receiver.getOutput();
+                            if (bootFlag != null) {
+                                // Workaround for microdroid: `adb shell` prints permission warnings
+                                bootFlag = bootFlag.lines().reduce((a, b) -> b).orElse(null);
+                            }
+                            if (bootFlag != null && "1".equals(bootFlag.trim())) {
+                                return BUSY_WAIT_STATUS.SUCCESS;
+                            }
+                        } catch (IOException | ShellCommandUnresponsiveException e) {
+                            CLog.e("%s failed on: %s", cmd, getSerialNumber());
+                            CLog.e(e);
+                        } catch (TimeoutException e) {
+                            CLog.e("%s failed on %s: timeout", cmd, getSerialNumber());
+                            CLog.e(e);
+                        } catch (AdbCommandRejectedException e) {
+                            CLog.e("%s failed on: %s", cmd, getSerialNumber());
+                            CLog.e(e);
+                            if (e.isDeviceOffline() || e.wasErrorDuringDeviceSelection()) {
+                                offlineCount[0]--;
+                                if (offlineCount[0] <= 0) {
+                                    return BUSY_WAIT_STATUS.ABORT;
+                                }
                             }
                         }
+                        return BUSY_WAIT_STATUS.CONTINUE_WAITING;
+                    };
+            boolean result = busyWaitFunction(bootComplete, waitTime);
+            if (!result) {
+                CLog.w(
+                        "Device %s did not boot after %s ms",
+                        getSerialNumber(),
+                        TimeUtil.formatElapsedTime(System.currentTimeMillis() - start));
                     }
-                    return BUSY_WAIT_STATUS.CONTINUE_WAITING;
-                };
-        boolean result = busyWaitFunction(bootComplete, waitTime);
-        if (!result) {
-            CLog.w(
-                    "Device %s did not boot after %s ms",
-                    getSerialNumber(),
-                    TimeUtil.formatElapsedTime(System.currentTimeMillis() - start));
+            return result;
         }
-        return result;
     }
 
     /**
@@ -559,30 +571,35 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
     }
 
     private boolean waitForDeviceState(TestDeviceState state, long time) {
-        String deviceSerial = getSerialNumber();
-        TestDeviceState currentStatus = getDeviceState();
-        if (currentStatus.equals(state)) {
-            CLog.i("Device %s is already %s", deviceSerial, state);
-            return true;
-        }
-        CLog.i(
-                "Waiting for device %s to be in %s mode for '%s'; it is currently in %s mode...",
-                deviceSerial, state, TimeUtil.formatElapsedTime(time), currentStatus);
-        DeviceStateListener listener = new DeviceStateListener(state);
-        addDeviceStateListener(listener);
-        synchronized (listener) {
-            try {
-                listener.wait(time);
-            } catch (InterruptedException e) {
-                CLog.w("wait for device state interrupted");
-                CLog.w(e);
-                throw new RunInterruptedException(
-                        e.getMessage(), e, InfraErrorIdentifier.UNDETERMINED);
-            } finally {
-                removeDeviceStateListener(listener);
+        try {
+            String deviceSerial = getSerialNumber();
+            TestDeviceState currentStatus = getDeviceState();
+            if (currentStatus.equals(state)) {
+                CLog.i("Device %s is already %s", deviceSerial, state);
+                return true;
+            }
+            CLog.i(
+                    "Waiting for device %s to be in %s mode for '%s'; it is currently in %s"
+                            + " mode...",
+                    deviceSerial, state, TimeUtil.formatElapsedTime(time), currentStatus);
+            DeviceStateListener listener = new DeviceStateListener(state, mFinalState);
+            addDeviceStateListener(listener);
+            synchronized (listener) {
+                try {
+                    listener.wait(time);
+                } catch (InterruptedException e) {
+                    CLog.w("wait for device state interrupted");
+                    CLog.w(e);
+                    throw new RunInterruptedException(
+                            e.getMessage(), e, InfraErrorIdentifier.UNDETERMINED);
+                } finally {
+                    removeDeviceStateListener(listener);
+                }
             }
+            return getDeviceState().equals(state);
+        } finally {
+            mFinalState = null;
         }
-        return getDeviceState().equals(state);
     }
 
     /**
@@ -633,9 +650,11 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
 
     private static class DeviceStateListener {
         private final TestDeviceState mExpectedState;
+        private final TestDeviceState mFinalState;
 
-        public DeviceStateListener(TestDeviceState expectedState) {
+        public DeviceStateListener(TestDeviceState expectedState, TestDeviceState finalState) {
             mExpectedState = expectedState;
+            mFinalState = finalState;
         }
 
         public void stateChanged(TestDeviceState newState) {
@@ -644,6 +663,12 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
                     notify();
                 }
             }
+            if (mFinalState != null && mFinalState.equals(newState)) {
+                synchronized (this) {
+                    CLog.e("Reached final state: %s", mFinalState);
+                    notify();
+                }
+            }
         }
     }
 
diff --git a/src/com/android/tradefed/device/TestDevice.java b/src/com/android/tradefed/device/TestDevice.java
index 56681113c..2b210114b 100644
--- a/src/com/android/tradefed/device/TestDevice.java
+++ b/src/com/android/tradefed/device/TestDevice.java
@@ -2891,6 +2891,8 @@ public class TestDevice extends NativeDevice {
                         : "--cpu-topology " + builder.mCpuTopology;
         final String gkiFlag = Strings.isNullOrEmpty(builder.mGki) ? "" : "--gki " + builder.mGki;
         final String hugePagesFlag = builder.mHugePages ? "--hugepages" : "";
+        final String nameFlag =
+                Strings.isNullOrEmpty(builder.mName) ? "" : "--name " + builder.mName;
 
         List<String> args =
                 new ArrayList<>(
@@ -2910,6 +2912,7 @@ public class TestDevice extends NativeDevice {
                                 cpuTopologyFlag,
                                 gkiFlag,
                                 hugePagesFlag,
+                                nameFlag,
                                 builder.mApkPath,
                                 outApkIdsigPath,
                                 builder.mInstanceImg,
@@ -3257,6 +3260,7 @@ public class TestDevice extends NativeDevice {
         private String mInstanceIdFile; // Path to instance_id file
         private String mInstanceImg; // Path to instance_img file
         private boolean mHugePages;
+        private String mName;
 
         /** Creates a builder for the given APK/apkPath and the payload config file in APK. */
         private MicrodroidBuilder(File apkFile, String apkPath, @Nonnull String configPath) {
@@ -3275,6 +3279,7 @@ public class TestDevice extends NativeDevice {
             mAssignedDevices = new ArrayList<>();
             mInstanceIdFile = null;
             mInstanceImg = null;
+            mName = null;
         }
 
         /** Creates a Microdroid builder for the given APK and the payload config file in APK. */
@@ -3441,6 +3446,16 @@ public class TestDevice extends NativeDevice {
             return this;
         }
 
+        /**
+         * Sets name for this VM.
+         *
+         * @return the microdroid builder.
+         */
+        public MicrodroidBuilder name(String name) {
+            mName = name;
+            return this;
+        }
+
         /** Starts a Micrdroid TestDevice on the given TestDevice. */
         public ITestDevice build(@Nonnull TestDevice device) throws DeviceNotAvailableException {
             if (mNumCpus != null) {
diff --git a/src/com/android/tradefed/device/cloud/GceAvdInfo.java b/src/com/android/tradefed/device/cloud/GceAvdInfo.java
index 2edf79fab..e79ee7192 100644
--- a/src/com/android/tradefed/device/cloud/GceAvdInfo.java
+++ b/src/com/android/tradefed/device/cloud/GceAvdInfo.java
@@ -16,6 +16,7 @@
 package com.android.tradefed.device.cloud;
 
 import com.android.tradefed.command.remote.DeviceDescriptor;
+import com.android.tradefed.device.TestDeviceOptions;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.log.LogUtil.CLog;
@@ -54,6 +55,15 @@ public class GceAvdInfo {
     // Patterns to match from Oxygen client's return message to identify error.
     private static final LinkedHashMap<InfraErrorIdentifier, String> OXYGEN_ERROR_PATTERN_MAP;
 
+    private static final Pattern OXYGEN_LEASE_RESPONSE_PATTERN =
+            Pattern.compile(
+                    "session_id:\\s?\"(.*?)\".*?server_url:\\s?\"(.*?)\".*?oxygen_version:\\s?\"(.*?)\"",
+                    Pattern.DOTALL);
+    private static final Pattern OXYGENATION_LEASE_RESPONSE_PATTERN =
+            Pattern.compile(
+                    "session_id:\\s?\"(.*?)\".*?server_url:\\s?\"(.*?)\".*?oxygen_version:\\s?\"(.*?)\".*?device_id:\\s?\"(.*?)\"",
+                    Pattern.DOTALL);
+
     static {
         OXYGEN_ERROR_PATTERN_MAP = new LinkedHashMap<InfraErrorIdentifier, String>();
         // Order the error message matching carefully so it can surface the expected error properly
@@ -158,7 +168,6 @@ public class GceAvdInfo {
     private String mInstanceUser = null;
     // Skip collecting device log if set to true.
     private boolean mSkipDeviceLogCollection = false;
-    private boolean mIsOxygenationDevice = false;
     private String mOxygenationDeviceId = null;
 
     public static enum GceStatus {
@@ -209,22 +218,20 @@ public class GceAvdInfo {
                 + ", mBuildVars="
                 + ", mOxygenationDeviceId="
                 + mOxygenationDeviceId
-                + ", mIsOxygenationDevice="
-                + mIsOxygenationDevice
                 + mBuildVars.toString()
                 + ", mLogs="
                 + mLogs.toString()
                 + "]";
     }
 
-    public boolean isOxygenationDevice() {
-        return mIsOxygenationDevice;
-    }
-
     public String getOxygenationDeviceId() {
         return mOxygenationDeviceId;
     }
 
+    public void setOxygenationDeviceId(String deviceId) {
+        mOxygenationDeviceId = deviceId;
+    }
+
     public String instanceName() {
         return mInstanceName;
     }
@@ -383,7 +390,10 @@ public class GceAvdInfo {
             if (devices != null) {
                 if (devices.length() == 1) {
                     JSONObject d = (JSONObject) devices.get(0);
-                    addCfStartTimeMetrics(d);
+                    // Only log CF boot performance metrics if the device launch is successful.
+                    if (GceStatus.SUCCESS.equals(gceStatus)) {
+                        addCfStartTimeMetrics(d);
+                    }
                     String ip = d.getString("ip");
                     String instanceName = d.getString("instance_name");
                     GceAvdInfo avdInfo =
@@ -425,16 +435,16 @@ public class GceAvdInfo {
      * Parse a given command line output from Oxygen client binary to obtain leased AVD info.
      *
      * @param oxygenRes the {@link CommandResult} from Oxygen client command execution.
-     * @param remoteAdbPort the remote port that should be used for adb connection
+     * @param deviceOptions the {@link TestDeviceOptions} describing the device options
      * @return {@link List} of the devices successfully leased. Will throw {@link TargetSetupError}
      *     if failed to lease a device.
      */
     public static List<GceAvdInfo> parseGceInfoFromOxygenClientOutput(
-            CommandResult oxygenRes, int remoteAdbPort) throws TargetSetupError {
+            CommandResult oxygenRes, TestDeviceOptions deviceOptions) throws TargetSetupError {
         CommandStatus oxygenCliStatus = oxygenRes.getStatus();
         if (CommandStatus.SUCCESS.equals(oxygenCliStatus)) {
             return parseSucceedOxygenClientOutput(
-                    oxygenRes.getStdout() + oxygenRes.getStderr(), remoteAdbPort);
+                    oxygenRes.getStdout() + oxygenRes.getStderr(), deviceOptions);
         } else if (CommandStatus.TIMED_OUT.equals(oxygenCliStatus)) {
             return Arrays.asList(
                     new GceAvdInfo(
@@ -457,33 +467,49 @@ public class GceAvdInfo {
         }
     }
 
-    private static List<GceAvdInfo> parseSucceedOxygenClientOutput(String output, int remoteAdbPort)
-            throws TargetSetupError {
+    private static List<GceAvdInfo> parseSucceedOxygenClientOutput(
+            String output, TestDeviceOptions deviceOptions) throws TargetSetupError {
         CLog.d("Parsing oxygen client output: %s", output);
-
-        Pattern pattern =
-                Pattern.compile(
-                        "session_id:\"(.*?)\".*?server_url:\"(.*?)\".*?oxygen_version:\"(.*?)\"",
-                        Pattern.DOTALL);
-        Matcher matcher = pattern.matcher(output);
-
         List<GceAvdInfo> gceAvdInfos = new ArrayList<>();
-        int deviceOffset = 0;
-        while (matcher.find()) {
-            String sessionId = matcher.group(1);
-            String serverUrl = matcher.group(2);
-            String oxygenVersion = matcher.group(3);
-            gceAvdInfos.add(
-                    new GceAvdInfo(
-                            sessionId,
-                            HostAndPort.fromString(serverUrl)
-                                    .withDefaultPort(remoteAdbPort + deviceOffset),
-                            null,
-                            null,
-                            GceStatus.SUCCESS));
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.CF_OXYGEN_VERSION, oxygenVersion);
-            deviceOffset++;
+        if (deviceOptions.useOxygenationDevice()) {
+            Matcher matcher = OXYGENATION_LEASE_RESPONSE_PATTERN.matcher(output);
+            while (matcher.find()) {
+                String sessionId = matcher.group(1);
+                String serverUrl = matcher.group(2);
+                String oxygenationVersion = matcher.group(3);
+                String deviceId = matcher.group(4);
+                GceAvdInfo gceAvdInfo =
+                        new GceAvdInfo(
+                                sessionId,
+                                HostAndPort.fromString(serverUrl),
+                                null,
+                                null,
+                                GceStatus.SUCCESS);
+                gceAvdInfo.setOxygenationDeviceId(deviceId);
+                gceAvdInfos.add(gceAvdInfo);
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.CF_OXYGENATION_VERSION, oxygenationVersion);
+            }
+        } else {
+            Matcher matcher = OXYGEN_LEASE_RESPONSE_PATTERN.matcher(output);
+            int deviceOffset = 0;
+            while (matcher.find()) {
+                String sessionId = matcher.group(1);
+                String serverUrl = matcher.group(2);
+                String oxygenVersion = matcher.group(3);
+                gceAvdInfos.add(
+                        new GceAvdInfo(
+                                sessionId,
+                                HostAndPort.fromString(serverUrl)
+                                        .withDefaultPort(
+                                                deviceOptions.getRemoteAdbPort() + deviceOffset),
+                                null,
+                                null,
+                                GceStatus.SUCCESS));
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.CF_OXYGEN_VERSION, oxygenVersion);
+                deviceOffset++;
+            }
         }
         if (gceAvdInfos.isEmpty()) {
             throw new TargetSetupError(
diff --git a/src/com/android/tradefed/device/cloud/GceLHPTunnelMonitor.java b/src/com/android/tradefed/device/cloud/GceLHPTunnelMonitor.java
index 0628b1b49..44632e1b0 100644
--- a/src/com/android/tradefed/device/cloud/GceLHPTunnelMonitor.java
+++ b/src/com/android/tradefed/device/cloud/GceLHPTunnelMonitor.java
@@ -15,46 +15,262 @@
  */
 package com.android.tradefed.device.cloud;
 
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.device.IManagedTestDevice;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.RemoteAvdIDevice;
+import com.android.tradefed.device.TestDeviceOptions;
+import com.android.tradefed.device.connection.AbstractConnection;
+import com.android.tradefed.device.connection.AdbTcpConnection;
 import com.android.tradefed.log.ITestLogger;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.FileInputStreamSource;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.avd.OxygenClient;
+import com.android.tradefed.util.avd.OxygenClient.LHPTunnelMode;
 
-// Confirmed in b/323295206, it still needs a tunnel monitor due to some edge-cases can't be
-// recovered by LHP.
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.net.HostAndPort;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/** Thread Monitor for the Gce lab host proxy tunnel used for oxygenation. */
 public class GceLHPTunnelMonitor extends AbstractTunnelMonitor {
+    private static final long WAIT_AFTER_REBOOT = 60 * 1000;
+    private static final int WAIT_FOR_FIRST_CONNECT = 10 * 1000;
+    private static final long DEFAULT_SHORT_CMD_TIMEOUT = 20 * 1000;
+    private ITestDevice mDevice;
+    private TestDeviceOptions mDeviceOptions;
+    private IBuildInfo mBuildInfo;
+    private boolean mQuit = false;
+    private String mInstanceName = null;
+    private String mSessionId = null;
+    private String mDeviceId = null;
+    private String mServerUrl = null;
+    private Process mAdbLHPTunnelProcess;
+    private HostAndPort mLocalHostAndPort;
+    private boolean mAdbRebootCalled = false;
+    private File mAdbConnectionLog = null;
+    private File mAdbLHPTunnelLog = null;
+    private Integer mPortNumber = null;
 
-    public GceLHPTunnelMonitor() {
-        super(String.format("GceSshTunnelMonitor"));
-        // TODO(easoncylee): Constructor to monitor the adb connection to an oxygenation device.
+    /**
+     * Constructor
+     *
+     * @param device {@link ITestDevice} the TF device to associate the remote GCE AVD with.
+     * @param buildInfo {@link ITestDevice} the TF device to associate the remote GCE AVD with.
+     * @param sessionId {@link ITestDevice} the TF device to associate the remote GCE AVD with.
+     * @param deviceId {@link ITestDevice} the TF device to associate the remote GCE AVD with.
+     * @param serverUrl {@link ITestDevice} the TF device to associate the remote GCE AVD with.
+     * @param deviceOptions {@link HostAndPort} of the remote GCE AVD.
+     */
+    public GceLHPTunnelMonitor(
+            ITestDevice device,
+            IBuildInfo buildInfo,
+            String sessionId,
+            String deviceId,
+            String serverUrl,
+            TestDeviceOptions deviceOptions) {
+        super(
+                String.format(
+                        "GceLHPTunnelMonitor-%s-%s-%s-%s-%s-%s",
+                        buildInfo.getBuildBranch(),
+                        buildInfo.getBuildFlavor(),
+                        buildInfo.getBuildId(),
+                        sessionId,
+                        deviceId,
+                        serverUrl));
+        setDaemon(true);
+        mDevice = device;
+        mBuildInfo = buildInfo;
+        mDeviceOptions = deviceOptions;
+        mSessionId = sessionId;
+        mServerUrl = serverUrl;
+        mDeviceId = deviceId;
+    }
+
+    /** Returns the instance of {@link IRunUtil}. */
+    @VisibleForTesting
+    IRunUtil getRunUtil() {
+        return RunUtil.getDefault();
     }
 
     @Override
     public void run() {
-        // TODO(easoncylee): At run method, it would do
-        // 1. Establish adb connection to the oxygenation device through LHP.
-        // 2. Monitor the connection, and re-establish the connection if it's disconnected.
+        FileOutputStream adbLHPTunnel = null;
+        while (!mQuit) {
+            if (mAdbConnectionLog == null) {
+                try {
+                    mAdbConnectionLog = FileUtil.createTempFile("adb-connection", ".txt");
+                } catch (IOException e) {
+                    FileUtil.deleteFile(mAdbConnectionLog);
+                    CLog.e(e);
+                }
+            }
+            if (mAdbConnectionLog != null) {
+                if (mDevice.getConnection() instanceof AdbTcpConnection) {
+                    ((AdbTcpConnection) mDevice.getConnection()).setAdbLogFile(mAdbConnectionLog);
+                }
+            }
+            if (mAdbLHPTunnelLog == null || !mAdbLHPTunnelLog.exists()) {
+                try {
+                    mAdbLHPTunnelLog = FileUtil.createTempFile("lhp-adb-connection", ".txt");
+                    adbLHPTunnel = new FileOutputStream(mAdbLHPTunnelLog, true);
+                } catch (IOException e) {
+                    FileUtil.deleteFile(mAdbLHPTunnelLog);
+                    CLog.e(e);
+                }
+            }
+
+            // Establish the adb connection through LHP, and monitor it.
+            OxygenClient oxygenClient =
+                    OxygenUtil.createOxygenClient(mDeviceOptions.getAvdDriverBinary());
+            if (mPortNumber == null) {
+                mPortNumber = oxygenClient.createServerSocket();
+            }
+            // Create a new RemoteAvdIDevice with serial number to replace with gce-device.
+            String serial = String.format("localhost:%d", mPortNumber);
+            CLog.d("Setting device %s serial to %s", mDevice.getSerialNumber(), serial);
+            ((IManagedTestDevice) mDevice).setIDevice(new RemoteAvdIDevice(serial));
+            // Do not call setDeviceSerial to keep track of it consistently with the placeholder
+            // serial
+            mBuildInfo.addBuildAttribute("virtual-device-serial", serial);
+            mAdbLHPTunnelProcess =
+                    oxygenClient.createTunnelViaLHP(
+                            LHPTunnelMode.ADB,
+                            Integer.toString(mPortNumber),
+                            mSessionId,
+                            mServerUrl,
+                            OxygenUtil.getTargetRegion(mDeviceOptions),
+                            mDeviceOptions.getOxygenAccountingUser(),
+                            mDeviceId,
+                            mDeviceOptions.getExtraOxygenArgs(),
+                            adbLHPTunnel);
+
+            if (mAdbLHPTunnelProcess == null) {
+                CLog.e("Failed creating the adb over LHP tunnel for oxygenation.");
+                return;
+            }
+
+            // Device serial should contain tunnel host and port number.
+            getRunUtil().sleep(WAIT_FOR_FIRST_CONNECT);
+            // Checking if it is actually running.
+            if (isTunnelAlive()) {
+                mLocalHostAndPort = HostAndPort.fromString(mDevice.getSerialNumber());
+                AbstractConnection conn = mDevice.getConnection();
+                if (conn instanceof AdbTcpConnection) {
+                    if (!((AdbTcpConnection) conn)
+                            .adbTcpConnect(
+                                    mLocalHostAndPort.getHost(),
+                                    Integer.toString(mLocalHostAndPort.getPort()))) {
+                        CLog.e("Adb connect failed, re-init GCE connection.");
+                        closeConnection();
+                        continue;
+                    }
+                }
+                try {
+                    mAdbLHPTunnelProcess.waitFor();
+                } catch (InterruptedException e) {
+                    CLog.d("adb tunnel connected through LHP terminated %s", e.getMessage());
+                }
+                CLog.d("Reached end of loop, tunnel is going to re-init.");
+                if (mAdbRebootCalled) {
+                    mAdbRebootCalled = false;
+                    CLog.d(
+                            "Tunnel reached end of loop due to adbReboot, "
+                                    + "waiting a little for device to come online");
+                    getRunUtil().sleep(WAIT_AFTER_REBOOT);
+                }
+            } else {
+                CLog.e(
+                        "adb tunnel connected through LHP isn't alive after starting it. It must "
+                                + "have returned, closing the tunnel...");
+                oxygenClient.closeLHPConnection(mAdbLHPTunnelProcess);
+            }
+        }
     }
 
     /** Returns True if the {@link GceLHPTunnelMonitor} is still alive, false otherwise. */
     @Override
     public boolean isTunnelAlive() {
-        // TODO(easoncylee): Flesh out this section when it's ready, return true for now.
+        if (mAdbLHPTunnelProcess != null) {
+            return mAdbLHPTunnelProcess.isAlive();
+        }
         return false;
     }
 
+    /** Set True when an adb reboot is about to be called to make sure the monitor expect it. */
+    @Override
+    public void isAdbRebootCalled(boolean isCalled) {
+        mAdbRebootCalled = isCalled;
+    }
+
     /** Close the adb connection from the monitor. */
     @Override
     public void closeConnection() {
-        // TODO(easoncylee): Flesh out this section when it's ready.
+        // shutdown adb connection first, if we reached where there could be a connection
+        CLog.d("closeConnection is triggered.");
+        if (mLocalHostAndPort != null) {
+            AbstractConnection conn = mDevice.getConnection();
+            if (conn instanceof AdbTcpConnection) {
+                if (!((AdbTcpConnection) conn)
+                        .adbTcpDisconnect(
+                                mLocalHostAndPort.getHost(),
+                                Integer.toString(mLocalHostAndPort.getPort()))) {
+                    CLog.d("Failed to disconnect from local host %s", mLocalHostAndPort.toString());
+                }
+            }
+        }
+        if (mAdbLHPTunnelProcess != null) {
+            mAdbLHPTunnelProcess.destroy();
+            try {
+                boolean res =
+                        mAdbLHPTunnelProcess.waitFor(
+                                DEFAULT_SHORT_CMD_TIMEOUT, TimeUnit.MILLISECONDS);
+                if (!res) {
+                    CLog.e("adb tunnel connected through LHP may not have properly terminated.");
+                }
+            } catch (InterruptedException e) {
+                CLog.e(
+                        "adb tunnel connected through LHP interrupted during shutdown: %s",
+                        e.getMessage());
+            }
+        }
     }
 
-    /** Log all the interesting log files generated from the ssh tunnel. */
+    /** Log all the interesting log files generated from the adb tunnel connected through LHP. */
     @Override
     public void logSshTunnelLogs(ITestLogger logger) {
-        // TODO(easoncylee): Flesh out this section when it's ready.
+        if (mDevice.getConnection() instanceof AdbTcpConnection) {
+            ((AdbTcpConnection) mDevice.getConnection()).setAdbLogFile(null);
+        }
+        if (mAdbConnectionLog != null) {
+            try (InputStreamSource adbBridge = new FileInputStreamSource(mAdbConnectionLog, true)) {
+                logger.testLog("adb-connect-logs", LogDataType.TEXT, adbBridge);
+            }
+        }
+        if (mAdbLHPTunnelLog != null) {
+            try (InputStreamSource lhpBridge = new FileInputStreamSource(mAdbLHPTunnelLog, true)) {
+                logger.testLog("lhp-bridge-logs", LogDataType.TEXT, lhpBridge);
+            }
+        }
     }
 
     /** Terminate the tunnel monitor */
     @Override
     public void shutdown() {
-        // TODO(easoncylee): Flesh out this section when it's ready.
+        mQuit = true;
+        closeConnection();
+        FileUtil.deleteFile(mAdbLHPTunnelLog);
+        getRunUtil().allowInterrupt(true);
+        getRunUtil().interrupt(this, "shutting down the monitor thread.", null);
+        interrupt();
     }
 }
diff --git a/src/com/android/tradefed/device/cloud/GceManager.java b/src/com/android/tradefed/device/cloud/GceManager.java
index c00dc5d72..694901c04 100644
--- a/src/com/android/tradefed/device/cloud/GceManager.java
+++ b/src/com/android/tradefed/device/cloud/GceManager.java
@@ -40,6 +40,10 @@ import com.android.tradefed.util.GoogleApiClientUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.avd.AcloudUtil;
+import com.android.tradefed.util.avd.HostOrchestratorUtil;
+import com.android.tradefed.util.avd.LogCollector;
+import com.android.tradefed.util.avd.OxygenClient;
 
 import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
 import com.google.api.client.http.HttpRequestInitializer;
@@ -64,7 +68,6 @@ import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -230,8 +233,31 @@ public class GceManager {
         // If ipDevice is specified, skip collecting serial log as the host may not be GCE instance
         // If Oxygen cuttlefish is used, skip collecting serial log due to lack of access.
         mSkipSerialLogCollection =
-                (!Strings.isNullOrEmpty(ipDevice) || getTestDeviceOptions().useOxygen());
-        if (getTestDeviceOptions().useOxygen() || getTestDeviceOptions().useOxygenationDevice()) {
+                (!Strings.isNullOrEmpty(ipDevice)
+                        || getTestDeviceOptions().useOxygen()
+                        || getTestDeviceOptions().useCvdCF());
+        if (getTestDeviceOptions().useOxygen() || getTestDeviceOptions().useCvdCF()) {
+            // Validate binary
+            File clientBinary = getTestDeviceOptions().getAvdDriverBinary();
+            String error = null;
+            if (clientBinary == null) {
+                error = "the Oxygen client binary reference is null";
+            } else if (!clientBinary.exists()) {
+                error =
+                        String.format(
+                                "the Oxygen client binary file does not exist at %s",
+                                clientBinary.getAbsolutePath());
+            } else if (!clientBinary.canExecute()) {
+                error =
+                        String.format(
+                                "the Oxygen client binary file at %s is not executable",
+                                clientBinary.getAbsolutePath());
+            }
+            if (!Strings.isNullOrEmpty(error)) {
+                throw new HarnessRuntimeException(
+                        String.format("Error in instantiating OxygenClient class: %s", error),
+                        InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
+            }
             // Leasing an oxygenation device will still depend on the existing oxygen client tool
             // with more parameters passed in.
             return startGceWithOxygenClient(logger, attributes);
@@ -263,13 +289,34 @@ public class GceManager {
         long startTime = System.currentTimeMillis();
         try (CloseableTraceScope ignore = new CloseableTraceScope("startMultiDevicesGce")) {
             OxygenClient oxygenClient =
-                    new OxygenClient(getTestDeviceOptions().getAvdDriverBinary());
+                    OxygenUtil.createOxygenClient(getTestDeviceOptions().getAvdDriverBinary());
+            List<String> buildTargets = new ArrayList<>();
+            List<String> buildBranches = new ArrayList<>();
+            List<String> buildIds = new ArrayList<>();
+
+            for (IBuildInfo b : buildInfos) {
+                if (b.getBuildAttributes().containsKey("build_target")) {
+                    // If BuildInfo contains the attribute for a build target, use that.
+                    buildTargets.add(b.getBuildAttributes().get("build_target"));
+                } else {
+                    buildTargets.add(b.getBuildFlavor());
+                }
+                buildBranches.add(b.getBuildBranch());
+                buildIds.add(b.getBuildId());
+            }
+
             CommandResult res =
                     oxygenClient.leaseMultipleDevices(
-                            buildInfos, getTestDeviceOptions(), attributes);
-            gceAvdInfos =
-                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(
-                            res, mDeviceOptions.getRemoteAdbPort());
+                            buildTargets,
+                            buildBranches,
+                            buildIds,
+                            OxygenUtil.getTargetRegion(getTestDeviceOptions()),
+                            getTestDeviceOptions().getOxygenAccountingUser(),
+                            getTestDeviceOptions().getOxygenLeaseLength(),
+                            getTestDeviceOptions().getExtraOxygenArgs(),
+                            attributes,
+                            getTestDeviceOptions().getGceCmdTimeout());
+            gceAvdInfos = GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mDeviceOptions);
             mGceAvdInfo = gceAvdInfos.get(0);
             return gceAvdInfos;
         } finally {
@@ -293,9 +340,24 @@ public class GceManager {
         long fetchTime = 0;
         try {
             OxygenClient oxygenClient =
-                    new OxygenClient(getTestDeviceOptions().getAvdDriverBinary());
+                    OxygenUtil.createOxygenClient(getTestDeviceOptions().getAvdDriverBinary());
+            String buildTarget =
+                    mBuildInfo.getBuildAttributes().containsKey("build_target")
+                            ? mBuildInfo.getBuildAttributes().get("build_target")
+                            : mBuildInfo.getBuildFlavor();
             CommandResult res =
-                    oxygenClient.leaseDevice(mBuildInfo, getTestDeviceOptions(), attributes);
+                    oxygenClient.leaseDevice(
+                            buildTarget,
+                            mBuildInfo.getBuildBranch(),
+                            mBuildInfo.getBuildId(),
+                            OxygenUtil.getTargetRegion(getTestDeviceOptions()),
+                            getTestDeviceOptions().getOxygenAccountingUser(),
+                            getTestDeviceOptions().getOxygenLeaseLength(),
+                            getTestDeviceOptions().getGceDriverParams(),
+                            getTestDeviceOptions().getExtraOxygenArgs(),
+                            attributes,
+                            getTestDeviceOptions().getGceCmdTimeout(),
+                            getTestDeviceOptions().useOxygenationDevice());
 
             // Retry lease up to 2x if error code is in list of error codes
             int iteration = 1;
@@ -305,7 +367,19 @@ public class GceManager {
                     break;
                 }
                 CLog.d("Retrying lease call due to earlier failure of %s", identifier);
-                res = oxygenClient.leaseDevice(mBuildInfo, getTestDeviceOptions(), attributes);
+                res =
+                        oxygenClient.leaseDevice(
+                                buildTarget,
+                                mBuildInfo.getBuildBranch(),
+                                mBuildInfo.getBuildId(),
+                                OxygenUtil.getTargetRegion(getTestDeviceOptions()),
+                                getTestDeviceOptions().getOxygenAccountingUser(),
+                                getTestDeviceOptions().getOxygenLeaseLength(),
+                                getTestDeviceOptions().getGceDriverParams(),
+                                getTestDeviceOptions().getExtraOxygenArgs(),
+                                attributes,
+                                getTestDeviceOptions().getGceCmdTimeout(),
+                                getTestDeviceOptions().useOxygenationDevice());
                 // Update Oxygen lease attempt metrics
                 if (res.getStatus() == CommandStatus.SUCCESS) {
                     InvocationMetricLogger.addInvocationMetrics(
@@ -316,17 +390,14 @@ public class GceManager {
                 }
                 iteration++;
             }
+            mGceAvdInfo = GceAvdInfo.parseGceInfoFromOxygenClientOutput(res, mDeviceOptions).get(0);
 
-            mGceAvdInfo =
-                    GceAvdInfo.parseGceInfoFromOxygenClientOutput(
-                                    res, mDeviceOptions.getRemoteAdbPort())
-                            .get(0);
             // Lease may time out, skip remaining logic if lease failed.
             if (mGceAvdInfo.hostAndPort() == null) {
                 CLog.w("Failed to lease a device: %s", mGceAvdInfo);
                 return mGceAvdInfo;
             }
-            if (oxygenClient.noWaitForBootSpecified(getTestDeviceOptions())) {
+            if (getTestDeviceOptions().getExtraOxygenArgs().containsKey("no_wait_for_boot")) {
                 CLog.d(
                         "Device leased without waiting for boot to finish. Poll emulator_stderr.txt"
                                 + " for flag `VIRTUAL_DEVICE_BOOT_COMPLETED`");
@@ -339,34 +410,81 @@ public class GceManager {
                                 + getTestDeviceOptions().getGceCmdTimeout()
                                 - System.currentTimeMillis();
                 startTime = System.currentTimeMillis();
-                final String remoteFile =
-                        CommonLogRemoteFileUtil.OXYGEN_EMULATOR_LOG_DIR + "3/emulator_stderr.txt";
-                // Continuously scan cf boot status and exit immediately when the magic string
-                // VIRTUAL_DEVICE_BOOT_COMPLETED is found
-                String cfBootStatusSshCmd =
-                        "tail -F -n +1 "
-                                + remoteFile
-                                + " | grep -m 1 VIRTUAL_DEVICE_BOOT_COMPLETED";
-                String[] cfBootStatusSshCommand = cfBootStatusSshCmd.split(" ");
-
-                res =
-                        remoteSshCommandExecution(
-                                mGceAvdInfo,
-                                getTestDeviceOptions(),
-                                RunUtil.getDefault(),
-                                timeout,
-                                cfBootStatusSshCommand);
-                if (CommandStatus.SUCCESS.equals(res.getStatus())) {
-                    bootSuccess = true;
-                    CLog.d(
-                            "Device boot completed after %sms, flag located: %s",
-                            System.currentTimeMillis() - startTime, res.getStdout().trim());
+                HostOrchestratorUtil hOUtil = null;
+                if (getTestDeviceOptions().useCvdCF()) {
+                    hOUtil =
+                            new HostOrchestratorUtil(
+                                    getTestDeviceOptions().useOxygenationDevice(),
+                                    getTestDeviceOptions().getExtraOxygenArgs(),
+                                    mGceAvdInfo.instanceName(),
+                                    mGceAvdInfo.hostAndPort() != null
+                                            ? mGceAvdInfo.hostAndPort().getHost()
+                                            : null,
+                                    mGceAvdInfo.getOxygenationDeviceId(),
+                                    OxygenUtil.getTargetRegion(getTestDeviceOptions()),
+                                    getTestDeviceOptions().getOxygenAccountingUser(),
+                                    oxygenClient);
+                    bootSuccess = hOUtil.deviceBootCompleted(timeout);
+                } else {
+                    final String remoteFile =
+                            CommonLogRemoteFileUtil.OXYGEN_EMULATOR_LOG_DIR
+                                    + "3/emulator_stderr.txt";
+                    // Continuously scan cf boot status and exit immediately when the magic string
+                    // VIRTUAL_DEVICE_BOOT_COMPLETED is found
+                    String cfBootStatusSshCmd =
+                            "tail -F -n +1 "
+                                    + remoteFile
+                                    + " | grep -m 1 VIRTUAL_DEVICE_BOOT_COMPLETED";
+                    String[] cfBootStatusSshCommand = cfBootStatusSshCmd.split(" ");
+
+                    res =
+                            remoteSshCommandExecution(
+                                    mGceAvdInfo,
+                                    getTestDeviceOptions(),
+                                    RunUtil.getDefault(),
+                                    timeout,
+                                    cfBootStatusSshCommand);
+                    if (CommandStatus.SUCCESS.equals(res.getStatus())) {
+                        bootSuccess = true;
+                        CLog.d(
+                                "Device boot completed after %sms, flag located: %s",
+                                System.currentTimeMillis() - startTime, res.getStdout().trim());
+                    }
                 }
 
                 if (!bootSuccess) {
                     if (logger != null) {
-                        CommonLogRemoteFileUtil.fetchCommonFiles(
-                                logger, mGceAvdInfo, getTestDeviceOptions(), getRunUtil());
+                        if (hOUtil != null) {
+                            File cvdLogsDir = hOUtil.pullCvdHostLogs();
+                            if (cvdLogsDir != null) {
+                                GceManager.logDirectory(
+                                        cvdLogsDir, null, logger, LogDataType.CUTTLEFISH_LOG);
+                                FileUtil.recursiveDelete(cvdLogsDir);
+                            } else {
+                                CLog.i(
+                                        "CVD Logs is null, no logs collected from host"
+                                                + " orchestrator.");
+                            }
+                            File tempFile =
+                                    hOUtil.collectLogByCommand(
+                                            "host_kernel",
+                                            HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
+                            logAndDeleteFile(tempFile, "host_kernel", logger);
+                            tempFile =
+                                    hOUtil.collectLogByCommand(
+                                            "host_orchestrator", HostOrchestratorUtil.URL_HO_LOG);
+                            logAndDeleteFile(tempFile, "host_orchestrator", logger);
+                            tempFile = hOUtil.getTunnelLog();
+                            logAndDeleteFile(tempFile, "host_orchestrator_tunnel_log", logger);
+                            tempFile =
+                                    hOUtil.collectLogByCommand(
+                                            "oxygen_container_log",
+                                            HostOrchestratorUtil.URL_OXYGEN_CONTAINER_LOG);
+                            logAndDeleteFile(tempFile, "oxygen_container_log", logger);
+                        } else {
+                            CommonLogRemoteFileUtil.fetchCommonFiles(
+                                    logger, mGceAvdInfo, getTestDeviceOptions(), getRunUtil());
+                        }
                     }
                     mGceAvdInfo.setErrorType(InfraErrorIdentifier.OXYGEN_DEVICE_LAUNCHER_TIMEOUT);
                     mGceAvdInfo.setStatus(GceStatus.BOOT_FAIL);
@@ -392,6 +510,15 @@ public class GceManager {
         }
     }
 
+    public static void logAndDeleteFile(File tempFile, String dataName, ITestLogger logger) {
+        if (tempFile == null || logger == null) {
+            CLog.i("Skip logging due to either null file or null logger...");
+            return;
+        }
+        logger.testLog(dataName, LogDataType.CUTTLEFISH_LOG, new FileInputStreamSource(tempFile));
+        FileUtil.deleteFile(tempFile);
+    }
+
     /**
      * Attempt to start a gce instance with Acloud.
      *
@@ -432,8 +559,96 @@ public class GceManager {
             if (user != null) {
                 getTestDeviceOptions().setInstanceUser(user);
             }
+
+            List<String> extraArgs = Lists.newArrayList();
+
+            if (TestDeviceOptions.InstanceType.CHEEPS.equals(
+                    getTestDeviceOptions().getInstanceType())) {
+                extraArgs.add("--avd-type");
+                extraArgs.add("cheeps");
+
+                if (getTestDeviceOptions().getCrosUser() != null
+                        && getTestDeviceOptions().getCrosPassword() != null) {
+                    extraArgs.add("--user");
+                    extraArgs.add(getTestDeviceOptions().getCrosUser());
+                    extraArgs.add("--password");
+                    extraArgs.add(getTestDeviceOptions().getCrosPassword());
+                }
+            }
+
+            String debugOption = null;
+            switch (getTestDeviceOptions().getGceDriverLogLevel()) {
+                case DEBUG:
+                    debugOption = "-v";
+                    break;
+                case VERBOSE:
+                    debugOption = "-vv";
+                    break;
+                default:
+                    break;
+            }
+            if (debugOption != null) {
+                extraArgs.add(debugOption);
+            }
+
+            String buildTarget = mBuildInfo.getBuildFlavor();
+            if (mBuildInfo.getBuildAttributes().containsKey("build_target")) {
+                // If BuildInfo contains the attribute for a build target, use that.
+                buildTarget = mBuildInfo.getBuildAttributes().get("build_target");
+            }
+
+            MultiMap<File, String> extraFiles = getTestDeviceOptions().getExtraFiles();
+            List<String> extraParamsByInstanceType =
+                    TestDeviceOptions.getExtraParamsByInstanceType(
+                            getTestDeviceOptions().getInstanceType(),
+                            getTestDeviceOptions().getBaseImage());
+
+            String hostUser = user != null ? user : getTestDeviceOptions().getInstanceUser();
+            if (offset != null) {
+                getTestDeviceOptions().setRemoteAdbPort(6520 + offset);
+            }
+            String serviceAccountKeyPath = null;
+            if (getTestDeviceOptions().getServiceAccountJsonKeyFile() != null) {
+                serviceAccountKeyPath =
+                        getTestDeviceOptions().getServiceAccountJsonKeyFile().getAbsolutePath();
+            }
+
+            // process any info in the invocation context that should be passed onto GCE driver
+            // as meta data to be associated with the VM instance
+            if (attributes != null) {
+                for (String key : getTestDeviceOptions().getInvocationAttributeToMetadata()) {
+                    for (String value : attributes.get(key)) {
+                        extraArgs.add("--gce-metadata");
+                        extraArgs.add(String.format("%s:%s", key, value));
+                    }
+                }
+            }
+            // Get extra params by instance type
+            extraArgs.addAll(extraParamsByInstanceType);
+            if (getAvdConfigFile() != null) {
+                extraArgs.add("--config_file");
+                extraArgs.add(getAvdConfigFile().getAbsolutePath());
+            }
+
             List<String> gceArgs =
-                    buildGceCmd(reportFile, mBuildInfo, ipDevice, user, offset, attributes);
+                    AcloudUtil.buildGceCmd(
+                            getTestDeviceOptions().getAvdDriverBinary().getAbsolutePath(),
+                            TestDeviceOptions.getCreateCommandByInstanceType(
+                                    getTestDeviceOptions().getInstanceType()),
+                            reportFile,
+                            buildTarget,
+                            mBuildInfo.getBuildBranch(),
+                            mBuildInfo.getBuildId(),
+                            ipDevice,
+                            hostUser,
+                            getTestDeviceOptions().getSshPrivateKeyPath().getAbsolutePath(),
+                            extraArgs,
+                            serviceAccountKeyPath,
+                            offset,
+                            getTestDeviceOptions().getGceAccount(),
+                            getTestDeviceOptions().getGceDriverParams(),
+                            getTestDeviceOptions().getGceDriverFileParams(),
+                            extraFiles);
 
             long driverTimeoutMs = getTestDeviceOptions().getGceCmdTimeout();
             if (!getTestDeviceOptions().allowGceCmdTimeoutOverride()) {
@@ -542,150 +757,13 @@ public class GceManager {
         return null;
     }
 
-    /** Build and return the command to launch GCE. Exposed for testing. */
-    protected List<String> buildGceCmd(
-            File reportFile,
-            IBuildInfo b,
-            String ipDevice,
-            String user,
-            Integer offset,
-            MultiMap<String, String> attributes) {
-        List<String> gceArgs =
-                Lists.newArrayList(getTestDeviceOptions().getAvdDriverBinary().getAbsolutePath());
-        gceArgs.add(
-                TestDeviceOptions.getCreateCommandByInstanceType(
-                        getTestDeviceOptions().getInstanceType()));
-
-        if (TestDeviceOptions.InstanceType.CHEEPS.equals(
-                getTestDeviceOptions().getInstanceType())) {
-            gceArgs.add("--avd-type");
-            gceArgs.add("cheeps");
-
-            if (getTestDeviceOptions().getCrosUser() != null
-                    && getTestDeviceOptions().getCrosPassword() != null) {
-                gceArgs.add("--user");
-                gceArgs.add(getTestDeviceOptions().getCrosUser());
-                gceArgs.add("--password");
-                gceArgs.add(getTestDeviceOptions().getCrosPassword());
-            }
-        }
-
-        /* If args passed by gce-driver-param contain build-target or build_target, or
-        test device options include local-image and cvd-host-package to side load prebuilt virtual
-        device images, there is no need to pass the build info from device BuildInfo to gce
-        arguments. Otherwise, generate gce args from device BuildInfo. Please refer to acloud
-        arguments for the supported format:
-        https://android.googlesource.com/platform/tools/acloud/+/refs/heads/master/create/create_args.py  */
-        List<String> gceDriverParams = getTestDeviceOptions().getGceDriverParams();
-        MultiMap<String, File> gceDriverFileParams =
-                getTestDeviceOptions().getGceDriverFileParams();
-        if (!gceDriverParams.contains("--build-target")
-                && !gceDriverParams.contains("--build_target")
-                && !(gceDriverFileParams.containsKey("local-image")
-                        && gceDriverFileParams.containsKey("cvd-host-package"))) {
-            gceArgs.add("--build-target");
-            if (b.getBuildAttributes().containsKey("build_target")) {
-                // If BuildInfo contains the attribute for a build target, use that.
-                gceArgs.add(b.getBuildAttributes().get("build_target"));
-            } else {
-                gceArgs.add(b.getBuildFlavor());
-            }
-            gceArgs.add("--branch");
-            gceArgs.add(b.getBuildBranch());
-            gceArgs.add("--build-id");
-            gceArgs.add(b.getBuildId());
-        }
-
-        for (Map.Entry<String, File> entry : gceDriverFileParams.entries()) {
-            gceArgs.add("--" + entry.getKey());
-            gceArgs.add(entry.getValue().getAbsolutePath());
-        }
-
-        // process any info in the invocation context that should be passed onto GCE driver
-        // as meta data to be associated with the VM instance
-        if (attributes != null) {
-            for (String key : getTestDeviceOptions().getInvocationAttributeToMetadata()) {
-                for (String value : attributes.get(key)) {
-                    gceArgs.add("--gce-metadata");
-                    gceArgs.add(String.format("%s:%s", key, value));
-                }
-            }
-        }
-
-        MultiMap<File, String> extraFiles = getTestDeviceOptions().getExtraFiles();
-        if (!extraFiles.isEmpty()) {
-            gceArgs.add("--extra-files");
-            for (File local : extraFiles.keySet()) {
-                for (String remoteDestination : extraFiles.get(local)) {
-                    gceArgs.add(local.getAbsolutePath() + "," + remoteDestination);
-                }
-            }
-        }
-
-        // Add additional args passed by gce-driver-param.
-        gceArgs.addAll(gceDriverParams);
-        // Get extra params by instance type
-        gceArgs.addAll(
-                TestDeviceOptions.getExtraParamsByInstanceType(
-                        getTestDeviceOptions().getInstanceType(),
-                        getTestDeviceOptions().getBaseImage()));
-        if (getAvdConfigFile() != null) {
-            gceArgs.add("--config_file");
-            gceArgs.add(getAvdConfigFile().getAbsolutePath());
-        }
-        if (getTestDeviceOptions().getServiceAccountJsonKeyFile() != null) {
-            gceArgs.add("--service-account-json-private-key-path");
-            gceArgs.add(getTestDeviceOptions().getServiceAccountJsonKeyFile().getAbsolutePath());
-        }
-
-        if (ipDevice != null) {
-            gceArgs.add("--host");
-            gceArgs.add(ipDevice);
-            gceArgs.add("--host-user");
-            if (user != null) {
-                gceArgs.add(user);
-            } else {
-                gceArgs.add(getTestDeviceOptions().getInstanceUser());
-            }
-            gceArgs.add("--host-ssh-private-key-path");
-            gceArgs.add(getTestDeviceOptions().getSshPrivateKeyPath().getAbsolutePath());
-        }
-        gceArgs.add("--report_file");
-        gceArgs.add(reportFile.getAbsolutePath());
-
-        // Add base-instance-num args with offset, and override the remote adb port.
-        // When offset is 1, base-instance-num=2 and virtual device adb forward port is 6521.
-        if (offset != null) {
-            getTestDeviceOptions().setRemoteAdbPort(6520 + offset);
-            gceArgs.add("--base-instance-num");
-            gceArgs.add(String.valueOf(offset + 1));
-        }
-        switch (getTestDeviceOptions().getGceDriverLogLevel()) {
-            case DEBUG:
-                gceArgs.add("-v");
-                break;
-            case VERBOSE:
-                gceArgs.add("-vv");
-                break;
-            default:
-                break;
-        }
-        if (getTestDeviceOptions().getGceAccount() != null) {
-            gceArgs.add("--email");
-            gceArgs.add(getTestDeviceOptions().getGceAccount());
-        }
-        // Do not pass flags --logcat_file and --serial_log_file to collect logcat and serial logs.
-
-        return gceArgs;
-    }
-
     /**
      * Shutdown the Gce instance associated with the {@link #startGce()}.
      *
      * @return returns true if gce shutdown was requested as non-blocking.
      */
     public boolean shutdownGce() {
-        if (getTestDeviceOptions().useOxygen() || getTestDeviceOptions().useOxygenationDevice()) {
+        if (getTestDeviceOptions().useOxygen() || getTestDeviceOptions().useCvdCF()) {
             return shutdownGceWithOxygen();
         } else {
             return shutdownGceWithAcloud();
@@ -699,9 +777,39 @@ public class GceManager {
      */
     private boolean shutdownGceWithOxygen() {
         try {
+            // If gceAvdInfo is missing info, then it means the device wasn't get leased
+            // successfully.
+            // In such case, there is no need to release the device.
+            if (mGceAvdInfo == null
+                    || mGceAvdInfo.instanceName() == null
+                    || mGceAvdInfo.hostAndPort() == null
+                    || mGceAvdInfo.hostAndPort().getHost() == null) {
+                return true;
+            }
             OxygenClient oxygenClient =
-                    new OxygenClient(getTestDeviceOptions().getAvdDriverBinary());
-            return oxygenClient.release(mGceAvdInfo, getTestDeviceOptions());
+                    OxygenUtil.createOxygenClient(getTestDeviceOptions().getAvdDriverBinary());
+            CommandResult res =
+                    oxygenClient.release(
+                            mGceAvdInfo.instanceName(),
+                            mGceAvdInfo.hostAndPort().getHost(),
+                            OxygenUtil.getTargetRegion(getTestDeviceOptions()),
+                            getTestDeviceOptions().getOxygenAccountingUser(),
+                            getTestDeviceOptions().getExtraOxygenArgs(),
+                            getTestDeviceOptions().getGceCmdTimeout(),
+                            getTestDeviceOptions().useOxygenationDevice());
+            if (!res.getStatus().equals(CommandStatus.SUCCESS)) {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.OXYGEN_DEVICE_RELEASE_FAILURE_COUNT, 1);
+                if (res.getStderr() != null) {
+                    String error = "Unknown";
+                    if (res.getStderr().contains("context deadline exceeded")) {
+                        error = "SERVER_CALL_TIMEOUT";
+                    }
+                    InvocationMetricLogger.addInvocationMetrics(
+                            InvocationMetricKey.OXYGEN_DEVICE_RELEASE_FAILURE_MESSAGE, error);
+                }
+            }
+            return res.getStatus().equals(CommandStatus.SUCCESS);
         } finally {
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.OXYGEN_DEVICE_DIRECT_RELEASE_COUNT, 1);
@@ -1033,7 +1141,7 @@ public class GceManager {
                     && remoteFile != null) {
                 try (CloseableTraceScope ignore =
                         new CloseableTraceScope("avd:collectErrorSignature")) {
-                    List<String> signatures = OxygenUtil.collectErrorSignatures(remoteFile);
+                    List<String> signatures = LogCollector.collectErrorSignatures(remoteFile);
                     if (signatures.size() > 0) {
                         InvocationMetricLogger.addInvocationMetrics(
                                 InvocationMetricKey.DEVICE_ERROR_SIGNATURES,
@@ -1044,7 +1152,7 @@ public class GceManager {
             if (options.useOxygen() && remoteFile != null) {
                 try (CloseableTraceScope ignore =
                         new CloseableTraceScope("avd:collectDeviceLaunchMetrics")) {
-                    long[] launchMetrics = OxygenUtil.collectDeviceLaunchMetrics(remoteFile);
+                    long[] launchMetrics = LogCollector.collectDeviceLaunchMetrics(remoteFile);
                     if (launchMetrics[0] > 0) {
                         InvocationMetricLogger.addInvocationMetrics(
                                 InvocationMetricKey.CF_FETCH_ARTIFACT_TIME, launchMetrics[0]);
@@ -1054,7 +1162,7 @@ public class GceManager {
                 }
                 try (CloseableTraceScope ignore =
                         new CloseableTraceScope("avd:collectOxygenVersion")) {
-                    String oxygenVersion = OxygenUtil.collectOxygenVersion(remoteFile);
+                    String oxygenVersion = LogCollector.collectOxygenVersion(remoteFile);
                     if (!Strings.isNullOrEmpty(oxygenVersion)) {
                         InvocationMetricLogger.addInvocationMetrics(
                                 InvocationMetricKey.CF_OXYGEN_VERSION, oxygenVersion);
diff --git a/src/com/android/tradefed/device/cloud/GceSshTunnelMonitor.java b/src/com/android/tradefed/device/cloud/GceSshTunnelMonitor.java
index 41b29b6a7..6b03f1003 100644
--- a/src/com/android/tradefed/device/cloud/GceSshTunnelMonitor.java
+++ b/src/com/android/tradefed/device/cloud/GceSshTunnelMonitor.java
@@ -31,7 +31,9 @@ import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.GceRemoteCmdFormatter;
 import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.ProcessUtil;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.StreamUtil;
 
@@ -39,11 +41,9 @@ import com.google.common.annotations.VisibleForTesting;
 import com.google.common.net.HostAndPort;
 
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.ServerSocket;
 import java.net.SocketException;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
@@ -56,7 +56,8 @@ public class GceSshTunnelMonitor extends AbstractTunnelMonitor {
     private static final long ADBD_RETRY_INTERVAL_MS = 15000;
     private static final int ADBD_MAX_RETRIES = 10;
     private static final long DEFAULT_SHORT_CMD_TIMEOUT = 20 * 1000;
-    private static final int WAIT_FOR_FIRST_CONNECT = 10 * 1000;
+    private static final long WAIT_FOR_FIRST_CONNECT = 500L;
+    private static final long WAIT_FOR_FIRST_CONNECT_CHEEPS = 10000L;
     private static final long WAIT_AFTER_REBOOT = 60 * 1000;
 
     // Format string for local hostname.
@@ -141,6 +142,7 @@ public class GceSshTunnelMonitor extends AbstractTunnelMonitor {
     public void shutdown() {
         mQuit = true;
         closeConnection();
+        FileUtil.deleteFile(mSshTunnelLogs);
         getRunUtil().allowInterrupt(true);
         getRunUtil().interrupt(this, "shutting down the monitor thread.", null);
         interrupt();
@@ -288,8 +290,12 @@ public class GceSshTunnelMonitor extends AbstractTunnelMonitor {
                 CLog.e("Failed creating the ssh tunnel to GCE.");
                 return;
             }
-            // Device serial should contain tunnel host and port number.
-            getRunUtil().sleep(WAIT_FOR_FIRST_CONNECT);
+            if (InstanceType.CHEEPS.equals(mDeviceOptions.getInstanceType())) {
+                getRunUtil().sleep(WAIT_FOR_FIRST_CONNECT_CHEEPS);
+            } else {
+                // Device serial should contain tunnel host and port number.
+                getRunUtil().sleep(WAIT_FOR_FIRST_CONNECT);
+            }
             // Checking if it is actually running.
             if (isTunnelAlive()) {
                 mLocalHostAndPort = HostAndPort.fromString(mDevice.getSerialNumber());
@@ -363,24 +369,20 @@ public class GceSshTunnelMonitor extends AbstractTunnelMonitor {
             StreamUtil.close(s);
             // Note there is a race condition here. between when we close
             // the server socket and when we try to connect to the tunnel.
-            List<String> tunnelParam = new ArrayList<>();
-            tunnelParam.add(String.format(TUNNEL_PARAM, mLastUsedPort, remotePort));
-            tunnelParam.add("-N");
-            List<String> sshTunnel =
-                    GceRemoteCmdFormatter.getSshCommand(
-                            getTestDeviceOptions().getSshPrivateKeyPath(),
-                            tunnelParam,
-                            getTestDeviceOptions().getInstanceUser(),
-                            remoteHost,
-                            "" /* no command */);
             if (mSshTunnelLogs == null || !mSshTunnelLogs.exists()) {
                 mSshTunnelLogs = FileUtil.createTempFile("ssh-tunnel-logs", ".txt");
                 FileUtil.writeToFile("=== Beginning ===\n", mSshTunnelLogs);
             }
+
             Process p =
-                    getRunUtil()
-                            .runCmdInBackground(
-                                    sshTunnel, new FileOutputStream(mSshTunnelLogs, true));
+                    ProcessUtil.createSshTunnel(
+                            remoteHost,
+                            mLastUsedPort,
+                            remotePort,
+                            getTestDeviceOptions().getSshPrivateKeyPath(),
+                            getTestDeviceOptions().getInstanceUser(),
+                            mSshTunnelLogs,
+                            getRunUtil());
             return p;
         } catch (IOException e) {
             CLog.d("Failed to connect to remote GCE using ssh tunnel %s", e.getMessage());
diff --git a/src/com/android/tradefed/device/cloud/HostOrchestratorUtil.java b/src/com/android/tradefed/device/cloud/HostOrchestratorUtil.java
deleted file mode 100644
index 88b52e67d..000000000
--- a/src/com/android/tradefed/device/cloud/HostOrchestratorUtil.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.tradefed.device.cloud;
-
-import com.android.ddmlib.Log.LogLevel;
-import com.android.tradefed.device.ITestDevice;
-import com.android.tradefed.device.cloud.OxygenClient.LHPTunnelMode;
-import com.android.tradefed.log.LogUtil.CLog;
-import com.android.tradefed.util.CommandResult;
-import com.android.tradefed.util.CommandStatus;
-import com.android.tradefed.util.IRunUtil;
-import com.android.tradefed.util.RunUtil;
-import com.android.tradefed.util.ZipUtil2;
-import com.google.common.annotations.VisibleForTesting;
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Files;
-import java.util.ArrayList;
-import java.util.List;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-
-/** Utility to execute commands via Host Orchestrator on remote instances. */
-public class HostOrchestratorUtil {
-    private static final long CMD_TIMEOUT_MS = 6 * 5 * 1000 * 1000; // 5 min
-    private static final String OXYGEN_TUNNEL_PARAM = "-L%s:127.0.0.1:2080";
-    private static final String HO_BASE_URL = "http://%s:%s/%s";
-    private static final String HO_PULL_LOG = "runtimeartifacts/:pull";
-    private static final String HO_POWERWASH = "cvds/%s/%s/:powerwash";
-    private static final String CVD_HOST_LOGZ = "cvd_hostlog_zip";
-    private static final String UNSUPPORTED_API_RESPONSE = "404 page not found";
-    private ITestDevice mDevice;
-    private GceAvdInfo mGceAvd;
-    private OxygenClient mOxygenClient;
-
-    public HostOrchestratorUtil(ITestDevice device, GceAvdInfo gceAvd) {
-        this(device, gceAvd, new OxygenClient(device.getOptions().getAvdDriverBinary()));
-    }
-
-    public HostOrchestratorUtil(ITestDevice device, GceAvdInfo gceAvd, OxygenClient oxygenClient) {
-        mDevice = device;
-        mGceAvd = gceAvd;
-        mOxygenClient = oxygenClient;
-    }
-
-    /** Pull CF host logs via Host Orchestrator. */
-    public File pullCvdHostLogs() {
-        // Basically, the rough processes to pull CF host logs are
-        // 1. Portforward the CURL tunnel
-        // 2. Compose CURL command and execute it to pull CF logs.
-        // TODO(easoncylee): Flesh out this section when it's ready.
-        String portNumber = Integer.toString(mOxygenClient.createServerSocket());
-        Process tunnel = null;
-        File cvdLogsDir = null;
-        File cvdLogsZip = null;
-        try {
-            cvdLogsZip = Files.createTempFile(CVD_HOST_LOGZ, ".zip").toFile();
-            tunnel = createHostOrchestratorTunnel(portNumber);
-            if (tunnel == null || !tunnel.isAlive()) {
-                CLog.e("Failed portforwarding Host Orchestrator tunnel.");
-                return null;
-            }
-            CommandResult commandRes =
-                    curlCommandExecution(
-                            mGceAvd.hostAndPort().getHost(),
-                            portNumber,
-                            "POST",
-                            HO_PULL_LOG,
-                            "--output",
-                            cvdLogsZip.getAbsolutePath());
-            if (!CommandStatus.SUCCESS.equals(commandRes.getStatus())) {
-                CLog.e("Failed pulling cvd logs via Host Orchestrator: %s", commandRes.getStdout());
-                return null;
-            }
-            cvdLogsDir = ZipUtil2.extractZipToTemp(cvdLogsZip, "cvd_logs");
-        } catch (IOException e) {
-            CLog.e("Failed pulling cvd logs via Host Orchestrator: %s", e);
-        } finally {
-            mOxygenClient.closeLHPConnection(tunnel);
-            cvdLogsZip.delete();
-        }
-        return cvdLogsDir;
-    }
-
-    /**
-     * Attempt to powerwash a GCE instance via Host Orchestrator.
-     *
-     * @return A {@link CommandResult} containing the status and logs.
-     */
-    public CommandResult powerwashGce() {
-        // Basically, the rough processes to powerwash a GCE instance are
-        // 1. Portforward CURL tunnel
-        // 2. Obtain the necessary information to powerwash a GCE instance via Host Orchestrator.
-        // 3. Attempt to powerwash a GCE instance via Host Orchestrator.
-        // TODO(easoncylee): Flesh out this section when it's ready.
-        String portNumber = Integer.toString(mOxygenClient.createServerSocket());
-        Process tunnel = null;
-        CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
-        try {
-            tunnel = createHostOrchestratorTunnel(portNumber);
-            if (tunnel == null || !tunnel.isAlive()) {
-                String msg = "Failed portforwarding Host Orchestrator tunnel.";
-                CLog.e(msg);
-                curlRes.setStderr(msg);
-                return curlRes;
-            }
-            curlRes =
-                    curlCommandExecution(
-                            mGceAvd.hostAndPort().getHost(), portNumber, "GET", "cvds");
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed getting cvd status via Host Orchestrator: %s", curlRes.getStdout());
-                return curlRes;
-            }
-            String cvdGroup = parseCvdOutput(curlRes.getStdout(), "group");
-            String cvdName = parseCvdOutput(curlRes.getStdout(), "name");
-            if (cvdGroup == null || cvdGroup.isEmpty() || cvdName == null || cvdName.isEmpty()) {
-                CLog.e("Failed parsing cvd group and cvd name.");
-                curlRes.setStatus(CommandStatus.FAILED);
-                return curlRes;
-            }
-            curlRes =
-                    curlCommandExecution(
-                            mGceAvd.hostAndPort().getHost(),
-                            portNumber,
-                            "POST",
-                            String.format(HO_POWERWASH, cvdGroup, cvdName));
-            if (!CommandStatus.SUCCESS.equals(curlRes.getStatus())) {
-                CLog.e("Failed powerwashing cvd via Host Orchestrator: %s", curlRes.getStdout());
-            }
-        } catch (IOException e) {
-            CLog.e("Failed powerwashing gce via Host Orchestrator: %s", e);
-        } finally {
-            mOxygenClient.closeLHPConnection(tunnel);
-        }
-        return curlRes;
-    }
-
-    /** Attempt to stop a Cuttlefish instance via Host Orchestrator. */
-    public CommandResult stopGce() {
-        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
-        return new CommandResult(CommandStatus.EXCEPTION);
-    }
-
-    /** Attempt to snapshot a Cuttlefish instance via Host Orchestrator. */
-    public CommandResult snapshotGce() {
-        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
-        return new CommandResult(CommandStatus.EXCEPTION);
-    }
-
-    /** Attempt to restore snapshot of a Cuttlefish instance via Host Orchestrator. */
-    public CommandResult restoreSnapshotGce() {
-        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
-        return new CommandResult(CommandStatus.EXCEPTION);
-    }
-
-    /**
-     * Create Host Orchestrator Tunnel with a given port number.
-     *
-     * @param portNumber The port number that Host Orchestrator communicates with.
-     * @return A {@link Process} of the Host Orchestrator connection between CuttleFish and TF.
-     */
-    @VisibleForTesting
-    Process createHostOrchestratorTunnel(String portNumber) throws IOException {
-        // Basically, to portforwad the CURL tunnel, the rough process would be
-        // if it's oxygenation device -> portforward the CURL tunnel via LHP.
-        // if `use_cvd` is set -> portforward the CURL tunnel via SSH.
-        // TODO(easoncylee): Flesh out this section when it's ready.
-        if (mDevice.getOptions().useOxygenationDevice()) {
-            CLog.d("Portforwarding Host Orchestrator service via LHP for Oxygenation CF.");
-            return mOxygenClient.createTunnelViaLHP(
-                    LHPTunnelMode.CURL,
-                    portNumber,
-                    mGceAvd.instanceName(),
-                    mGceAvd.getOxygenationDeviceId());
-        } else if (mDevice.getOptions().getExtraOxygenArgs().containsKey("use_cvd")) {
-            CLog.d("Portforarding Host Orchestrator service via SSH tunnel for Oxygen CF.");
-            List<String> tunnelParam = new ArrayList<>();
-            tunnelParam.add(String.format(OXYGEN_TUNNEL_PARAM, portNumber));
-            tunnelParam.add("-N");
-            List<String> cmd =
-                    GceRemoteCmdFormatter.getSshCommand(
-                            mDevice.getOptions().getSshPrivateKeyPath(),
-                            tunnelParam,
-                            mDevice.getOptions().getInstanceUser(),
-                            mGceAvd.hostAndPort().getHost(),
-                            "" /* no command */);
-            return getRunUtil().runCmdInBackground(cmd);
-        }
-        CLog.d("Skip portforwarding Host Orchestrator service for neither Oxygen nor Oxygenation.");
-        return null;
-    }
-
-    /**
-     * Execute a curl command via Host Orchestrator.
-     *
-     * @param hostName The name of the host.
-     * @param portNumber The port number that Host Orchestrator communicates with.
-     * @param method The HTTP Request containing GET, POST, PUT, DELETE, PATCH, etc...
-     * @param api The API that Host Orchestrator supports.
-     * @param commands The command to be executed.
-     * @return A {@link CommandResult} containing the status and logs.
-     */
-    @VisibleForTesting
-    CommandResult curlCommandExecution(
-            String hostName, String portNumber, String method, String api, String... commands) {
-        List<String> cmd = new ArrayList<>();
-        cmd.add("curl");
-        cmd.add("-0");
-        cmd.add("-v");
-        cmd.add("-X");
-        cmd.add(method);
-        cmd.add(String.format(HO_BASE_URL, hostName, portNumber, api));
-        for (String cmdOption : commands) {
-            cmd.add(cmdOption);
-        }
-        CommandResult commandRes =
-                getRunUtil().runTimedCmd(CMD_TIMEOUT_MS, null, null, cmd.toArray(new String[0]));
-        CLog.logAndDisplay(
-                LogLevel.INFO,
-                "Executing Host Orchestrator curl command: %s, Output: %s, Status: %s",
-                cmd,
-                commandRes.getStdout(),
-                commandRes.getStatus());
-        if (commandRes.getStdout().contains(UNSUPPORTED_API_RESPONSE)) {
-            commandRes.setStatus(CommandStatus.FAILED);
-        }
-        return commandRes;
-    }
-
-    /** Return the return by parsing the cvd output with a given keyword. */
-    private String parseCvdOutput(String content, String keyword) {
-        JSONTokener tokener = new JSONTokener(content);
-        String output = null;
-        try {
-            JSONObject root = new JSONObject(tokener);
-            JSONArray array = root.getJSONArray("cvds");
-            JSONObject object = array.getJSONObject(0);
-            output = object.getString(keyword);
-        } catch (JSONException e) {
-            CLog.e(e);
-        }
-        return output;
-    }
-
-    /** Get {@link IRunUtil} to use. Exposed for unit testing. */
-    @VisibleForTesting
-    IRunUtil getRunUtil() {
-        return RunUtil.getDefault();
-    }
-
-    /** Return the unsupported api response. Exposed for unit testing. */
-    @VisibleForTesting
-    String getUnsupportedHoResponse() {
-        return UNSUPPORTED_API_RESPONSE;
-    }
-}
diff --git a/src/com/android/tradefed/device/cloud/OxygenUtil.java b/src/com/android/tradefed/device/cloud/OxygenUtil.java
index bf44fdf92..aec9eac9d 100644
--- a/src/com/android/tradefed/device/cloud/OxygenUtil.java
+++ b/src/com/android/tradefed/device/cloud/OxygenUtil.java
@@ -26,23 +26,22 @@ import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.GCSFileDownloader;
+import com.android.tradefed.util.SystemUtil;
+import com.android.tradefed.util.avd.LogCollector;
+import com.android.tradefed.util.avd.OxygenClient;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
 
 import java.io.BufferedReader;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.InputStreamReader;
 import java.net.HttpURLConnection;
 import java.net.URL;
-import java.nio.file.Files;
 import java.util.AbstractMap;
-import java.util.ArrayList;
-import java.util.Collections;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
-import java.util.Scanner;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -51,8 +50,6 @@ import java.util.stream.Stream;
 
 /** Utility to interact with Oxygen service. */
 public class OxygenUtil {
-    // Maximum size of tailing part of a file to search for error signature.
-    private static final long MAX_FILE_SIZE_FOR_ERROR = 10 * 1024 * 1024;
 
     // URL for retrieving instance metadata related to the computing zone.
     private static final String ZONE_METADATA_URL =
@@ -79,66 +76,6 @@ public class OxygenUtil {
                                     LogDataType.TOMBSTONEZ))
                     .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
 
-    private static final Map<Pattern, AbstractMap.SimpleEntry<String, String>>
-            REMOTE_LOG_NAME_PATTERN_TO_ERROR_SIGNATURE_MAP =
-                    Stream.of(
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "Address already in use",
-                                                    "launch_cvd_port_collision")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "vcpu hw run failure: 0x7",
-                                                    "crosvm_vcpu_hw_run_failure_7")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "Unable to connect to vsock server",
-                                                    "unable_to_connect_to_vsock_server")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "failed to initialize fetch system images",
-                                                    "fetch_cvd_failure")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*vdl_stdout.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "failed to initialize fetch system images",
-                                                    "fetch_cvd_failure")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "failed to read from socket, retry",
-                                                    "rootcanal_socket_error")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "VIRTUAL_DEVICE_BOOT_PENDING: Bluetooth",
-                                                    "bluetooth_pending")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "another cuttlefish device already running",
-                                                    "another_device_running")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "Setup failed for cuttlefish::ConfigServer",
-                                                    "config_server_failed")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile(".*launcher.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "VIRTUAL_DEVICE_BOOT_FAILED: Dependencies not"
-                                                            + " ready after 10 checks: Bluetooth",
-                                                    "bluetooth_failed")),
-                                    new AbstractMap.SimpleEntry<>(
-                                            Pattern.compile("^logcat.*"),
-                                            new AbstractMap.SimpleEntry<>(
-                                                    "System zygote died with fatal exception",
-                                                    "zygote_fatal_exception")))
-                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
 
     /** Default constructor of OxygenUtil */
     public OxygenUtil() {
@@ -168,18 +105,12 @@ public class OxygenUtil {
             errorMessage = String.format("%s %s", errorMessage, error.getCause().getMessage());
         }
 
-        CLog.d("Downloading device launch failure logs based on error message: %s", errorMessage);
-        Pattern pattern = Pattern.compile(".*/storage/browser/(.*)\\?&project=.*", Pattern.DOTALL);
-        Matcher matcher = pattern.matcher(errorMessage);
-        if (!matcher.find()) {
-            CLog.d("Error message doesn't contain expected GCS link.");
+        File localDir = LogCollector.downloadLaunchFailureLogs(errorMessage, mDownloader);
+        if (localDir == null) {
             return;
         }
-        String remoteFilePath = "gs://" + matcher.group(1);
-        File localDir;
         try {
-            localDir = mDownloader.downloadFile(remoteFilePath);
-            String oxygenVersion = collectOxygenVersion(localDir);
+            String oxygenVersion = LogCollector.collectOxygenVersion(localDir);
             if (!Strings.isNullOrEmpty(oxygenVersion)) {
                 InvocationMetricLogger.addInvocationMetrics(
                         InvocationMetricLogger.InvocationMetricKey.CF_OXYGEN_VERSION,
@@ -187,7 +118,7 @@ public class OxygenUtil {
             }
             try (CloseableTraceScope ignore =
                     new CloseableTraceScope("avd:collectErrorSignature")) {
-                List<String> signatures = collectErrorSignatures(localDir);
+                List<String> signatures = LogCollector.collectErrorSignatures(localDir);
                 if (signatures.size() > 0) {
                     InvocationMetricLogger.addInvocationMetrics(
                             InvocationMetricKey.DEVICE_ERROR_SIGNATURES,
@@ -217,7 +148,7 @@ public class OxygenUtil {
                 }
             }
         } catch (Exception e) {
-            CLog.e("Failed to download Oxygen log from %s", remoteFilePath);
+            CLog.e("Failed to parse Oxygen log from %s", localDir);
             CLog.e(e);
         }
     }
@@ -245,184 +176,6 @@ public class OxygenUtil {
         return LogDataType.UNKNOWN;
     }
 
-    /**
-     * Collect error signatures from logs.
-     *
-     * @param logDir directory of logs pulled from remote host.
-     */
-    public static List<String> collectErrorSignatures(File logDir) {
-        CLog.d("Collect error signature from logs under: %s.", logDir);
-        List<String> signatures = new ArrayList<>();
-        try {
-            Set<String> files = FileUtil.findFiles(logDir, ".*");
-            for (String f : files) {
-                File file = new File(f);
-                if (file.isDirectory()) {
-                    continue;
-                }
-                String fileName = file.getName();
-                List<AbstractMap.SimpleEntry<String, String>> pairs = new ArrayList<>();
-                for (Map.Entry<Pattern, AbstractMap.SimpleEntry<String, String>> entry :
-                        REMOTE_LOG_NAME_PATTERN_TO_ERROR_SIGNATURE_MAP.entrySet()) {
-                    Matcher matcher = entry.getKey().matcher(fileName);
-                    if (matcher.find()) {
-                        pairs.add(entry.getValue());
-                    }
-                }
-                if (pairs.size() == 0) {
-                    continue;
-                }
-                try (FileInputStream stream = new FileInputStream(file)) {
-                    long skipSize = Files.size(file.toPath()) - MAX_FILE_SIZE_FOR_ERROR;
-                    if (skipSize > 0) {
-                        stream.skip(skipSize);
-                    }
-                    try (Scanner scanner = new Scanner(stream)) {
-                        List<AbstractMap.SimpleEntry<String, String>> pairsToRemove = new ArrayList<>();
-                        while (scanner.hasNextLine()) {
-                            String line = scanner.nextLine();
-                            for (AbstractMap.SimpleEntry<String, String> pair : pairs) {
-                                if (line.indexOf(pair.getKey()) != -1) {
-                                    pairsToRemove.add(pair);
-                                    signatures.add(pair.getValue());
-                                }
-                            }
-                            if (pairsToRemove.size() > 0) {
-                                pairs.removeAll(pairsToRemove);
-                                if (pairs.size() == 0) {
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        } catch (Exception e) {
-            CLog.e("Failed to collect error signature.");
-            CLog.e(e);
-        }
-        Collections.sort(signatures);
-        return signatures;
-    }
-
-    /**
-     * Collect device launcher metrics from vdl_stdout.
-     *
-     * @param logDir directory of logs pulled from remote host.
-     */
-    public static long[] collectDeviceLaunchMetrics(File logDir) {
-        CLog.d("Collect device launcher metrics from logs under: %s.", logDir);
-        long[] metrics = {-1, -1};
-        try {
-            Set<String> files = FileUtil.findFiles(logDir, "^vdl_stdout\\.txt.*");
-            if (files.size() == 0) {
-                CLog.d("There is no vdl_stdout.txt found.");
-                return metrics;
-            }
-            File vdlStdout = new File(files.iterator().next());
-            // Keep collecting cuttlefish-common for legacy
-            double cuttlefishCommon = 0;
-            // cuttlefish-host-resources and cuttlefish-operator replaces cuttlefish-common
-            // in recent versions of cuttlefish debian packages.
-            double cuttlefishHostResources = 0;
-            double cuttlefishOperator = 0;
-            double launchDevice = 0;
-            double mainstart = 0;
-            Pattern cuttlefishCommonPatteren =
-                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishCommon");
-            Pattern cuttlefishHostResourcesPatteren =
-                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishHostResources");
-            Pattern cuttlefishOperatorPatteren =
-                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishOperator");
-            Pattern launchDevicePatteren =
-                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sLaunchDevice");
-            Pattern mainstartPatteren =
-                    Pattern.compile(".*\\|\\s*(\\d+\\.\\d+)\\s*\\|\\sCuttlefishLauncherMainstart");
-            try (Scanner scanner = new Scanner(vdlStdout)) {
-                boolean metricsPending = false;
-                while (scanner.hasNextLine()) {
-                    String line = scanner.nextLine();
-                    if (!metricsPending) {
-                        if (line.indexOf("launch_cvd exited") != -1) {
-                            metricsPending = true;
-                        } else {
-                            continue;
-                        }
-                    }
-                    Matcher matcher;
-                    if (cuttlefishCommon == 0) {
-                        matcher = cuttlefishCommonPatteren.matcher(line);
-                        if (matcher.find()) {
-                            cuttlefishCommon = Double.parseDouble(matcher.group(1));
-                        }
-                    }
-                    if (cuttlefishHostResources == 0) {
-                        matcher = cuttlefishHostResourcesPatteren.matcher(line);
-                        if (matcher.find()) {
-                            cuttlefishHostResources = Double.parseDouble(matcher.group(1));
-                        }
-                    }
-                    if (cuttlefishOperator == 0) {
-                        matcher = cuttlefishOperatorPatteren.matcher(line);
-                        if (matcher.find()) {
-                            cuttlefishOperator = Double.parseDouble(matcher.group(1));
-                        }
-                    }
-                    if (launchDevice == 0) {
-                        matcher = launchDevicePatteren.matcher(line);
-                        if (matcher.find()) {
-                            launchDevice = Double.parseDouble(matcher.group(1));
-                        }
-                    }
-                    if (mainstart == 0) {
-                        matcher = mainstartPatteren.matcher(line);
-                        if (matcher.find()) {
-                            mainstart = Double.parseDouble(matcher.group(1));
-                        }
-                    }
-                }
-            }
-            if (mainstart > 0) {
-                metrics[0] =
-                        (long)
-                                ((mainstart
-                                                - launchDevice
-                                                - cuttlefishCommon
-                                                - cuttlefishHostResources
-                                                - cuttlefishOperator)
-                                        * 1000);
-                metrics[1] = (long) (launchDevice * 1000);
-            }
-        } catch (Exception e) {
-            CLog.e("Failed to parse device launch time from vdl_stdout.txt.");
-            CLog.e(e);
-        }
-        return metrics;
-    }
-
-    /**
-     * Collect oxygen version info from oxygeen_version.txt.
-     *
-     * @param logDir directory of logs pulled from remote host.
-     */
-    public static String collectOxygenVersion(File logDir) {
-        CLog.d("Collect Oxygen version from logs under: %s.", logDir);
-        try {
-            Set<String> files = FileUtil.findFiles(logDir, "^oxygen_version\\.txt.*");
-            if (files.size() == 0) {
-                CLog.d("There is no oxygen_version.txt found.");
-                return null;
-            }
-            // Trim the tailing spaces and line breakers at the end of the string.
-            return FileUtil.readStringFromFile(new File(files.iterator().next()))
-                    .replaceAll("(?s)\\n+$", "")
-                    .trim();
-        } catch (Exception e) {
-            CLog.e("Failed to read oxygen_version.txt .");
-            CLog.e(e);
-            return null;
-        }
-    }
 
     /**
      * Retrieves the target region based on the provided device options. If the target region is
@@ -470,4 +223,22 @@ public class OxygenUtil {
         int lastDashIndex = region.lastIndexOf("-");
         return region.substring(0, lastDashIndex);
     }
+
+    /**
+     * Helper to create an {@link OxygenClient}.
+     *
+     * @param file the Oxygen client binary file.
+     * @return an {@link OxygenClient} class to create CF devices.
+     */
+    public static OxygenClient createOxygenClient(File file) {
+        if (file.getAbsolutePath().endsWith(".jar")) {
+            List<String> cmdArgs =
+                    Arrays.asList(
+                            SystemUtil.getRunningJavaBinaryPath().getAbsolutePath(),
+                            "-jar",
+                            file.getAbsolutePath());
+            return new OxygenClient(cmdArgs);
+        }
+        return new OxygenClient(Arrays.asList(file.getAbsolutePath()));
+    }
 }
diff --git a/src/com/android/tradefed/device/cloud/RemoteFileUtil.java b/src/com/android/tradefed/device/cloud/RemoteFileUtil.java
index b5dbeab99..297b9a5e7 100644
--- a/src/com/android/tradefed/device/cloud/RemoteFileUtil.java
+++ b/src/com/android/tradefed/device/cloud/RemoteFileUtil.java
@@ -16,12 +16,12 @@
 package com.android.tradefed.device.cloud;
 
 import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.device.cloud.GceRemoteCmdFormatter.ScpMode;
-import com.android.tradefed.device.cloud.OxygenClient.LHPTunnelMode;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.GceRemoteCmdFormatter;
+import com.android.tradefed.util.GceRemoteCmdFormatter.ScpMode;
 import com.android.tradefed.util.IRunUtil;
 
 import java.io.File;
@@ -182,48 +182,16 @@ public class RemoteFileUtil {
             IRunUtil runUtil,
             long timeout,
             String remotePath) {
-        Process sshTunnel = null;
-        CommandResult resSsh = null;
-        OxygenClient oxygenClient = null;
-        try {
-            // In Oxygenation, the existing ssh/scp way would not work since the remote instance
-            // can't be connected by passing $HOST_IP, thus the ssh/scp command would be a bit
-            // different, so we need to differentiate if it's an oxygenation device and compile it.
-            if (remoteInstance.isOxygenationDevice()) {
-                oxygenClient = new OxygenClient(options.getAvdDriverBinary());
-                // To execute ssh/scp on a remote instance, create the ssh tunnel first.
-                Integer portNumber = oxygenClient.createServerSocket();
-                sshTunnel =
-                        oxygenClient.createTunnelViaLHP(
-                                LHPTunnelMode.SSH,
-                                Integer.toString(portNumber),
-                                remoteInstance.instanceName(),
-                                remoteInstance.getOxygenationDeviceId());
-                if (sshTunnel == null || !sshTunnel.isAlive()) {
-                    resSsh = new CommandResult(CommandStatus.EXCEPTION);
-                    resSsh.setStderr("Failed to establish an ssh tunnel via LHP.");
-                    resSsh.setExitCode(-1);
-                    return false;
-                }
-                // TODO(b/330197325): Flesh out the extra ssh parameters when the oxygenation CF
-                // instance launched by cvd is supported.
-            }
-            List<String> sshCmd =
-                    GceRemoteCmdFormatter.getSshCommand(
-                            options.getSshPrivateKeyPath(),
-                            null,
-                            options.getInstanceUser(),
-                            remoteInstance.hostAndPort().getHost(),
-                            "ls",
-                            remotePath);
-            resSsh = runUtil.runTimedCmd(timeout, sshCmd.toArray(new String[0]));
-            return resSsh != null && resSsh.getExitCode() == 0;
-        } finally {
-            if (remoteInstance.isOxygenationDevice()) {
-                // Once the ssh/scp is executed successfully, close the ssh tunnel.
-                oxygenClient.closeLHPConnection(sshTunnel);
-            }
-        }
+        List<String> sshCmd =
+                GceRemoteCmdFormatter.getSshCommand(
+                        options.getSshPrivateKeyPath(),
+                        null,
+                        options.getInstanceUser(),
+                        remoteInstance.hostAndPort().getHost(),
+                        "ls",
+                        remotePath);
+        CommandResult resSsh = runUtil.runTimedCmd(timeout, sshCmd.toArray(new String[0]));
+        return resSsh != null && CommandStatus.SUCCESS.equals(resSsh.getStatus());
     }
 
     /**
@@ -267,63 +235,30 @@ public class RemoteFileUtil {
             String remoteFilePath,
             File localFile,
             ScpMode mode) {
-        Process sshTunnel = null;
-        CommandResult resScp = null;
-        OxygenClient oxygenClient = null;
-        try {
-            // In Oxygenation, the existing ssh/scp way would not work since the remote instance
-            // can't be connected by passing $HOST_IP, thus the ssh/scp command would be a bit
-            // different, so we need to differentiate if it's an oxygenation device and compile it.
-            // TODO(easoncylee/haoch): Flesh out this section when it's ready.
-            if (remoteInstance.isOxygenationDevice()) {
-                oxygenClient = new OxygenClient(options.getAvdDriverBinary());
-                // To execute ssh/scp on a remote instance, create the ssh tunnel first.
-                Integer portNumber = oxygenClient.createServerSocket();
-                sshTunnel =
-                        oxygenClient.createTunnelViaLHP(
-                                LHPTunnelMode.SSH,
-                                Integer.toString(portNumber),
-                                remoteInstance.instanceName(),
-                                remoteInstance.getOxygenationDeviceId());
-                if (sshTunnel == null || !sshTunnel.isAlive()) {
-                    resScp = new CommandResult(CommandStatus.EXCEPTION);
-                    resScp.setStderr("Failed to establish an ssh tunnel via LHP.");
-                    resScp.setExitCode(-1);
-                    return false;
-                }
-                // TODO(b/330197325): Flesh out the extra scp parameters when the oxygenation CF
-                // instance launched by cvd is supported.
-            }
-            List<String> scpCmd =
-                    GceRemoteCmdFormatter.getScpCommand(
-                            options.getSshPrivateKeyPath(),
-                            scpArgs,
-                            options.getInstanceUser(),
-                            remoteInstance.hostAndPort().getHost(),
-                            remoteFilePath,
-                            localFile.getAbsolutePath(),
-                            mode);
-            resScp = runUtil.runTimedCmd(timeout, scpCmd.toArray(new String[0]));
-            if (!CommandStatus.SUCCESS.equals(resScp.getStatus())) {
-                StringBuilder builder = new StringBuilder();
-                builder.append("Issue when ");
-                if (ScpMode.PULL.equals(mode)) {
-                    builder.append("pulling ");
-                } else {
-                    builder.append("pushing ");
-                }
-                builder.append(String.format("file, status: %s", resScp.getStatus()));
-                CLog.e(builder.toString());
-                CLog.e("%s", resScp.getStderr());
-                return false;
+        List<String> scpCmd =
+                GceRemoteCmdFormatter.getScpCommand(
+                        options.getSshPrivateKeyPath(),
+                        scpArgs,
+                        options.getInstanceUser(),
+                        remoteInstance.hostAndPort().getHost(),
+                        remoteFilePath,
+                        localFile.getAbsolutePath(),
+                        mode);
+        CommandResult resScp = runUtil.runTimedCmd(timeout, scpCmd.toArray(new String[0]));
+        if (!CommandStatus.SUCCESS.equals(resScp.getStatus())) {
+            StringBuilder builder = new StringBuilder();
+            builder.append("Issue when ");
+            if (ScpMode.PULL.equals(mode)) {
+                builder.append("pulling ");
             } else {
-                return true;
-            }
-        } finally {
-            if (remoteInstance.isOxygenationDevice()) {
-                // Once the ssh/scp is executed successfully, close the ssh tunnel.
-                oxygenClient.closeLHPConnection(sshTunnel);
+                builder.append("pushing ");
             }
+            builder.append(String.format("file, status: %s", resScp.getStatus()));
+            CLog.e(builder.toString());
+            CLog.e("%s", resScp.getStderr());
+            return false;
+        } else {
+            return true;
         }
     }
 }
diff --git a/src/com/android/tradefed/device/cloud/RemoteSshUtil.java b/src/com/android/tradefed/device/cloud/RemoteSshUtil.java
index 81dbce8fc..74c0da26e 100644
--- a/src/com/android/tradefed/device/cloud/RemoteSshUtil.java
+++ b/src/com/android/tradefed/device/cloud/RemoteSshUtil.java
@@ -16,9 +16,8 @@
 package com.android.tradefed.device.cloud;
 
 import com.android.tradefed.device.TestDeviceOptions;
-import com.android.tradefed.device.cloud.OxygenClient.LHPTunnelMode;
 import com.android.tradefed.util.CommandResult;
-import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.GceRemoteCmdFormatter;
 import com.android.tradefed.util.IRunUtil;
 
 import java.io.OutputStream;
@@ -48,47 +47,14 @@ public class RemoteSshUtil {
             OutputStream stdout,
             OutputStream stderr,
             String... command) {
-        Process sshTunnel = null;
-        CommandResult resSsh = null;
-        OxygenClient oxygenClient = null;
-        try {
-            // In Oxygenation, the existing ssh/scp way would not work since the remote instance
-            // can't be connected by passing $HOST_IP, thus the ssh/scp command would be a bit
-            // different, so we need to differentiate if it's an oxygenation device and compile it.
-            // TODO(easoncylee/haoch): Flesh out this section when it's ready.
-            if (remoteInstance.isOxygenationDevice()) {
-                oxygenClient = new OxygenClient(options.getAvdDriverBinary());
-                // To execute ssh/scp on a remote instance, create the ssh tunnel first.
-                Integer portNumber = oxygenClient.createServerSocket();
-                sshTunnel =
-                        oxygenClient.createTunnelViaLHP(
-                                LHPTunnelMode.SSH,
-                                Integer.toString(portNumber),
-                                remoteInstance.instanceName(),
-                                remoteInstance.getOxygenationDeviceId());
-                if (sshTunnel == null || !sshTunnel.isAlive()) {
-                    resSsh = new CommandResult(CommandStatus.EXCEPTION);
-                    resSsh.setStderr("Failed to establish an ssh tunnel via LHP.");
-                    resSsh.setExitCode(-1);
-                    return resSsh;
-                }
-                // TODO(b/330197325): Flesh out the extra ssh parameters when the oxygenation CF
-                // instance launched by cvd is supported.
-            }
-            List<String> sshCmd =
-                    GceRemoteCmdFormatter.getSshCommand(
-                            options.getSshPrivateKeyPath(),
-                            null,
-                            options.getInstanceUser(),
-                            remoteInstance.hostAndPort().getHost(),
-                            command);
-            return runUtil.runTimedCmd(timeoutMs, stdout, stderr, sshCmd.toArray(new String[0]));
-        } finally {
-            if (remoteInstance.isOxygenationDevice()) {
-                // Once the ssh/scp is executed successfully, close the ssh tunnel.
-                oxygenClient.closeLHPConnection(sshTunnel);
-            }
-        }
+        List<String> sshCmd =
+                GceRemoteCmdFormatter.getSshCommand(
+                        options.getSshPrivateKeyPath(),
+                        null,
+                        options.getInstanceUser(),
+                        remoteInstance.hostAndPort().getHost(),
+                        command);
+        return runUtil.runTimedCmd(timeoutMs, stdout, stderr, sshCmd.toArray(new String[0]));
     }
 
     /**
diff --git a/src/com/android/tradefed/device/connection/AdbSshConnection.java b/src/com/android/tradefed/device/connection/AdbSshConnection.java
index 5358453e4..1547e4af7 100644
--- a/src/com/android/tradefed/device/connection/AdbSshConnection.java
+++ b/src/com/android/tradefed/device/connection/AdbSshConnection.java
@@ -35,13 +35,13 @@ import com.android.tradefed.device.cloud.GceAvdInfo.GceStatus;
 import com.android.tradefed.device.cloud.GceLHPTunnelMonitor;
 import com.android.tradefed.device.cloud.GceManager;
 import com.android.tradefed.device.cloud.GceSshTunnelMonitor;
-import com.android.tradefed.device.cloud.HostOrchestratorUtil;
 import com.android.tradefed.device.cloud.OxygenUtil;
 import com.android.tradefed.device.cloud.RemoteFileUtil;
 import com.android.tradefed.device.cloud.VmRemoteDevice;
 import com.android.tradefed.host.IHostOptions.PermitLimitType;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.InputStreamSource;
@@ -54,6 +54,7 @@ import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.StreamUtil;
+import com.android.tradefed.util.avd.HostOrchestratorUtil;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
@@ -73,6 +74,7 @@ public class AdbSshConnection extends AdbTcpConnection {
     private GceManager mGceHandler = null;
     private AbstractTunnelMonitor mGceTunnelMonitor;
     private DeviceNotAvailableException mTunnelInitFailed = null;
+    private HostOrchestratorUtil mHOUtil = null;
 
     private boolean mIsRemote = false;
     private String mKnownIp = null;
@@ -155,7 +157,7 @@ public class AdbSshConnection extends AdbTcpConnection {
         RecoveryMode previousMode = getDevice().getRecoveryMode();
         getDevice().setRecoveryMode(RecoveryMode.NONE);
         boolean unresponsive = true;
-        try {
+        try (CloseableTraceScope ignored = new CloseableTraceScope("wait_for_device_available")) {
             for (int i = 0; i < WAIT_TIME_DIVISION; i++) {
                 // We don't have a way to bail out of waitForDeviceAvailable if the Gce Avd
                 // boot up and then fail some other setup so we check to make sure the monitor
@@ -278,16 +280,32 @@ public class AdbSshConnection extends AdbTcpConnection {
             if (mGceAvd != null) {
                 if (mGceAvd.getSkipDeviceLogCollection()) {
                     CLog.d("Device log collection is skipped per SkipDeviceLogCollection setting.");
-                } else if (useCvdCF()) {
-                    File cvdLogsDir =
-                            new HostOrchestratorUtil(getDevice(), mGceAvd).pullCvdHostLogs();
+                } else if (getDevice().getOptions().useCvdCF()) {
+                    mHOUtil = createHostOrchestratorUtil(mGceAvd);
+                    File cvdLogsDir = mHOUtil.pullCvdHostLogs();
                     if (cvdLogsDir != null) {
                         GceManager.logDirectory(
                                 cvdLogsDir, null, getLogger(), LogDataType.CUTTLEFISH_LOG);
                         FileUtil.recursiveDelete(cvdLogsDir);
                     } else {
-                        CLog.i("CVD Logs is null, skip logging cvd logs.");
+                        CLog.i("CVD Logs is null, no logs collected from host orchestrator.");
                     }
+                    File tempFile =
+                            mHOUtil.collectLogByCommand(
+                                    "host_kernel", HostOrchestratorUtil.URL_HOST_KERNEL_LOG);
+                    GceManager.logAndDeleteFile(tempFile, "host_kernel", getLogger());
+                    tempFile =
+                            mHOUtil.collectLogByCommand(
+                                    "host_orchestrator", HostOrchestratorUtil.URL_HO_LOG);
+                    GceManager.logAndDeleteFile(tempFile, "host_orchestrator", getLogger());
+                    tempFile = mHOUtil.getTunnelLog();
+                    GceManager.logAndDeleteFile(
+                            tempFile, "host_orchestrator_tunnel_log", getLogger());
+                    tempFile =
+                            mHOUtil.collectLogByCommand(
+                                    "oxygen_container_log",
+                                    HostOrchestratorUtil.URL_OXYGEN_CONTAINER_LOG);
+                    GceManager.logAndDeleteFile(tempFile, "oxygen_container_log", getLogger());
                 } else if (mGceAvd.hostAndPort() != null) {
                     // Host and port can be null in case of acloud timeout
                     // attempt to get a bugreport if Gce Avd is a failure
@@ -396,8 +414,13 @@ public class AdbSshConnection extends AdbTcpConnection {
                         "Failed to start Gce with attempt: %s out of %s. With Exception: %s",
                         attempt + 1, getDevice().getOptions().getGceMaxAttempt(), tse);
                 exception = tse;
-
-                if (getDevice().getOptions().useOxygen()) {
+                // TODO(b/353826394): Refactor when avd_util wrapping is ready.
+                if (getDevice().getOptions().useCvdCF()) {
+                    // TODO(b/353649277): Flesh out this section when it's ready.
+                    // Basically, the rough processes to pull CF host logs are
+                    // 1. establish the CURL connection via LHP or SSH.
+                    // 2. Compose CURL command and execute it to pull CF logs.
+                } else if (getDevice().getOptions().useOxygen()) {
                     OxygenUtil util = new OxygenUtil();
                     util.downloadLaunchFailureLogs(tse, getLogger());
                 }
@@ -424,6 +447,7 @@ public class AdbSshConnection extends AdbTcpConnection {
             }
         }
         createGceTunnelMonitor(getDevice(), buildInfo, mGceAvd, getDevice().getOptions());
+        mHOUtil = createHostOrchestratorUtil(mGceAvd);
     }
 
     /** Create an ssh tunnel, connect to it, and keep the connection alive. */
@@ -433,7 +457,14 @@ public class AdbSshConnection extends AdbTcpConnection {
             GceAvdInfo gceAvdInfo,
             TestDeviceOptions deviceOptions) {
         if (deviceOptions.useOxygenationDevice()) {
-            mGceTunnelMonitor = new GceLHPTunnelMonitor();
+            mGceTunnelMonitor =
+                    new GceLHPTunnelMonitor(
+                            device,
+                            buildInfo,
+                            gceAvdInfo.instanceName(),
+                            gceAvdInfo.getOxygenationDeviceId(),
+                            gceAvdInfo.hostAndPort().getHost(),
+                            deviceOptions);
         } else {
             mGceTunnelMonitor =
                     new GceSshTunnelMonitor(
@@ -445,25 +476,27 @@ public class AdbSshConnection extends AdbTcpConnection {
 
     /** Check if the tunnel monitor is running. */
     protected void waitForTunnelOnline(final long waitTime) throws DeviceNotAvailableException {
-        CLog.i("Waiting %d ms for tunnel to be restarted", waitTime);
-        long startTime = getCurrentTime();
-        while (getCurrentTime() - startTime < waitTime) {
-            if (getGceTunnelMonitor() == null) {
-                CLog.e("Tunnel Thread terminated, something went wrong with the device.");
-                break;
-            }
-            if (getGceTunnelMonitor().isTunnelAlive()) {
-                CLog.d("Tunnel online again, resuming.");
-                return;
+        try (CloseableTraceScope ignored = new CloseableTraceScope("wait_for_tunnel")) {
+            CLog.i("Waiting %d ms for tunnel to be restarted", waitTime);
+            long startTime = getCurrentTime();
+            while (getCurrentTime() - startTime < waitTime) {
+                if (getGceTunnelMonitor() == null) {
+                    CLog.e("Tunnel Thread terminated, something went wrong with the device.");
+                    break;
+                }
+                if (getGceTunnelMonitor().isTunnelAlive()) {
+                    CLog.d("Tunnel online again, resuming.");
+                    return;
+                }
+                getRunUtil().sleep(RETRY_INTERVAL_MS);
             }
-            getRunUtil().sleep(RETRY_INTERVAL_MS);
+            mTunnelInitFailed =
+                    new DeviceNotAvailableException(
+                            String.format("Tunnel did not come back online after %sms", waitTime),
+                            getDevice().getSerialNumber(),
+                            DeviceErrorIdentifier.FAILED_TO_CONNECT_TO_GCE);
+            throw mTunnelInitFailed;
         }
-        mTunnelInitFailed =
-                new DeviceNotAvailableException(
-                        String.format("Tunnel did not come back online after %sms", waitTime),
-                        getDevice().getSerialNumber(),
-                        DeviceErrorIdentifier.FAILED_TO_CONNECT_TO_GCE);
-        throw mTunnelInitFailed;
     }
 
     /**
@@ -484,6 +517,14 @@ public class AdbSshConnection extends AdbTcpConnection {
         return mGceHandler;
     }
 
+    /**
+     * Returns the instance of the {@link com.android.tradefed.device.cloud.HostOrchestratorUtil}.
+     */
+    @VisibleForTesting
+    HostOrchestratorUtil getHostOrchestratorUtil() {
+        return mHOUtil;
+    }
+
     /** Capture a remote bugreport by ssh-ing into the device directly. */
     public void getSshBugreport() {
         if (mGceAvd == null) {
@@ -544,8 +585,8 @@ public class AdbSshConnection extends AdbTcpConnection {
                     getDevice().getDeviceDescriptor(),
                     DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
         }
-        if (useCvdCF()) {
-            powerwashRes = new HostOrchestratorUtil(getDevice(), mGceAvd).powerwashGce();
+        if (getDevice().getOptions().useCvdCF()) {
+            powerwashRes = mHOUtil.powerwashGce();
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
@@ -635,9 +676,6 @@ public class AdbSshConnection extends AdbTcpConnection {
         }
 
         if (getDevice().getOptions().useOxygen()) {
-            if (useCvdCF() && bin.equals("cvd")) {
-                return String.format("/usr/bin/%s %s", bin, args);
-            }
             CommandResult result =
                     GceManager.remoteSshCommandExecution(
                             mGceAvd,
@@ -668,8 +706,6 @@ public class AdbSshConnection extends AdbTcpConnection {
      */
     public CommandResult snapshotGce(String user, Integer offset, String snapshotId)
             throws TargetSetupError {
-        long startTime = System.currentTimeMillis();
-
         CommandResult snapshotRes = null;
         if (mGceAvd == null) {
             String errorMsg = "Can not get GCE AVD Info. launch GCE first?";
@@ -679,36 +715,23 @@ public class AdbSshConnection extends AdbTcpConnection {
                     DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
         }
 
-        if (useCvdCF()) {
-            snapshotRes = new HostOrchestratorUtil(getDevice(), mGceAvd).snapshotGce();
+        if (getDevice().getOptions().useCvdCF()) {
+            snapshotRes = mHOUtil.snapshotGce();
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
                 user = getDevice().getOptions().getInstanceUser();
             }
 
-            String snapshotCommand;
-            if (useCvdCF()) {
-                snapshotCommand =
-                        commandBuilder(
-                                "cvd",
-                                String.format(
-                                        "snapshot_take --force --auto_suspend"
-                                                + " --snapshot_path=/tmp/%s/snapshots/%s",
-                                        user, snapshotId),
-                                user,
-                                offset);
-            } else {
-                snapshotCommand =
-                        commandBuilder(
-                                "snapshot_util_cvd",
-                                String.format(
-                                        "--subcmd=snapshot_take --force --auto_suspend"
-                                                + " --snapshot_path=/tmp/%s/snapshots/%s",
-                                        user, snapshotId),
-                                user,
-                                offset);
-            }
+            String snapshotCommand =
+                    commandBuilder(
+                            "snapshot_util_cvd",
+                            String.format(
+                                    "--subcmd=snapshot_take --force --auto_suspend"
+                                            + " --snapshot_path=/tmp/%s/snapshots/%s",
+                                    user, snapshotId),
+                            user,
+                            offset);
             if (Strings.isNullOrEmpty(snapshotCommand)) {
                 throw new TargetSetupError(
                         "failed to set up snapshot command, invalid path",
@@ -725,17 +748,7 @@ public class AdbSshConnection extends AdbTcpConnection {
                             snapshotCommand.split(" "));
         }
 
-        if (CommandStatus.SUCCESS.equals(snapshotRes.getStatus())) {
-            // Time taken for snapshot this invocation
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_SNAPSHOT_DURATIONS,
-                    Long.toString(System.currentTimeMillis() - startTime));
-
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_SNAPSHOT_SUCCESS_COUNT, 1);
-        } else {
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_SNAPSHOT_FAILURE_COUNT, 1);
+        if (!CommandStatus.SUCCESS.equals(snapshotRes.getStatus())) {
             CLog.e("%s", snapshotRes.getStderr());
             throw new TargetSetupError(
                     String.format("failed to snapshot device: %s", snapshotRes.getStderr()),
@@ -759,35 +772,21 @@ public class AdbSshConnection extends AdbTcpConnection {
     public CommandResult restoreSnapshotGce(String user, Integer offset, String snapshotId)
             throws TargetSetupError {
         stopGce(user, offset);
-        long startTime = System.currentTimeMillis();
         CommandResult restoreRes = null;
-        if (useCvdCF()) {
-            restoreRes = new HostOrchestratorUtil(getDevice(), mGceAvd).restoreSnapshotGce();
+        if (getDevice().getOptions().useCvdCF()) {
+            restoreRes = mHOUtil.restoreSnapshotGce();
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
                 user = getDevice().getOptions().getInstanceUser();
             }
 
-            String restoreCommand;
-            if (useCvdCF()) {
-                restoreCommand =
-                        commandBuilder(
-                                "cvd",
-                                String.format(
-                                        "start --snapshot_path=/tmp/%s/snapshots/%s",
-                                        user, snapshotId),
-                                user,
-                                offset);
-            } else {
-                restoreCommand =
-                        commandBuilder(
-                                "launch_cvd",
-                                String.format(
-                                        "--snapshot_path=/tmp/%s/snapshots/%s", user, snapshotId),
-                                user,
-                                offset);
-            }
+            String restoreCommand =
+                    commandBuilder(
+                            "launch_cvd",
+                            String.format("--snapshot_path=/tmp/%s/snapshots/%s", user, snapshotId),
+                            user,
+                            offset);
             if (restoreCommand.length() == 0) {
                 throw new TargetSetupError(
                         "failed to set up restore command, invalid path",
@@ -803,35 +802,23 @@ public class AdbSshConnection extends AdbTcpConnection {
                             restoreCommand.split(" "));
         }
 
-        if (CommandStatus.SUCCESS.equals(restoreRes.getStatus())) {
-            try {
-                waitForAdbConnect(getDevice().getSerialNumber(), WAIT_FOR_ADB_CONNECT);
-                getDevice().waitForDeviceOnline(WAIT_FOR_DEVICE_ONLINE);
-            } catch (DeviceNotAvailableException e) {
-                InvocationMetricLogger.addInvocationMetrics(
-                        InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_FAILURE_COUNT, 1);
-                CLog.e("%s", e.toString());
-                throw new TargetSetupError(
-                        String.format("failed to restore device: %s", e.toString()),
-                        getDevice().getDeviceDescriptor(),
-                        DeviceErrorIdentifier.DEVICE_FAILED_TO_RESTORE_SNAPSHOT);
-            }
-            // Time taken for restore this invocation
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_DURATIONS,
-                    Long.toString(System.currentTimeMillis() - startTime));
-
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_SUCCESS_COUNT, 1);
-        } else {
-            InvocationMetricLogger.addInvocationMetrics(
-                    InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_FAILURE_COUNT, 1);
+        if (!CommandStatus.SUCCESS.equals(restoreRes.getStatus())) {
             CLog.e("%s", restoreRes.getStderr());
             throw new TargetSetupError(
                     String.format("failed to restore device: %s", restoreRes.getStderr()),
                     getDevice().getDeviceDescriptor(),
                     DeviceErrorIdentifier.DEVICE_FAILED_TO_RESTORE_SNAPSHOT);
         }
+        try {
+            waitForAdbConnect(getDevice().getSerialNumber(), WAIT_FOR_ADB_CONNECT);
+            getDevice().waitForDeviceOnline(WAIT_FOR_DEVICE_ONLINE);
+        } catch (DeviceNotAvailableException e) {
+            CLog.e("%s", e.toString());
+            throw new TargetSetupError(
+                    String.format("failed to restore device: %s", e.toString()),
+                    getDevice().getDeviceDescriptor(),
+                    DeviceErrorIdentifier.DEVICE_FAILED_TO_RESTORE_SNAPSHOT);
+        }
 
         return restoreRes;
     }
@@ -847,20 +834,15 @@ public class AdbSshConnection extends AdbTcpConnection {
     private void stopGce(String user, Integer offset) throws TargetSetupError {
         long startTime = System.currentTimeMillis();
         CommandResult stopRes = null;
-        if (useCvdCF()) {
-            stopRes = new HostOrchestratorUtil(getDevice(), mGceAvd).stopGce();
+        if (getDevice().getOptions().useCvdCF()) {
+            stopRes = mHOUtil.stopGce();
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
                 user = getDevice().getOptions().getInstanceUser();
             }
 
-            String stopCommand;
-            if (useCvdCF()) {
-                stopCommand = commandBuilder("cvd", "stop", user, offset);
-            } else {
-                stopCommand = commandBuilder("stop_cvd", "", user, offset);
-            }
+            String stopCommand = commandBuilder("stop_cvd", "", user, offset);
             if (stopCommand.length() == 0) {
                 throw new TargetSetupError(
                         "failed to set up stop command, invalid path",
@@ -981,12 +963,28 @@ public class AdbSshConnection extends AdbTcpConnection {
         }
     }
 
-    /** Helper to return true if the device is launched by cvd, false otherwise. */
-    private boolean useCvdCF() {
-        TestDeviceOptions options = getDevice().getOptions();
-        if (options.useOxygenationDevice() || options.getExtraOxygenArgs().containsKey("use_cvd")) {
-            return true;
-        }
-        return false;
+    /** Helper to create host orchestrator utility. */
+    HostOrchestratorUtil createHostOrchestratorUtil(GceAvdInfo gceAvdInfo) {
+        if (mHOUtil != null) {
+            CLog.i("Host Orchestrator Util has been initialized...");
+            return mHOUtil;
+        }
+        if (getDevice().getOptions().useCvdCF()) {
+            CLog.i("Creating host orchestrator utility...");
+            mHOUtil =
+                    new HostOrchestratorUtil(
+                            getDevice().getOptions().useOxygenationDevice(),
+                            getDevice().getOptions().getExtraOxygenArgs(),
+                            gceAvdInfo.instanceName(),
+                            gceAvdInfo.hostAndPort() != null
+                                    ? gceAvdInfo.hostAndPort().getHost()
+                                    : null,
+                            gceAvdInfo.getOxygenationDeviceId(),
+                            OxygenUtil.getTargetRegion(getDevice().getOptions()),
+                            getDevice().getOptions().getOxygenAccountingUser(),
+                            OxygenUtil.createOxygenClient(
+                                    getDevice().getOptions().getAvdDriverBinary()));
+        }
+        return mHOUtil;
     }
 }
diff --git a/src/com/android/tradefed/device/connection/AdbTcpConnection.java b/src/com/android/tradefed/device/connection/AdbTcpConnection.java
index b7a09d5f6..6e725f804 100644
--- a/src/com/android/tradefed/device/connection/AdbTcpConnection.java
+++ b/src/com/android/tradefed/device/connection/AdbTcpConnection.java
@@ -21,6 +21,7 @@ import com.android.tradefed.device.RemoteAndroidDevice;
 import com.android.tradefed.device.internal.DeviceResetHandler;
 import com.android.tradefed.device.internal.DeviceSnapshotHandler;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.util.CommandResult;
@@ -129,48 +130,51 @@ public class AdbTcpConnection extends DefaultConnection {
      * @return true if we successfully connected to the device, false otherwise.
      */
     public boolean adbTcpConnect(String host, String port) {
-        for (int i = 0; i < MAX_RETRIES; i++) {
-            CommandResult result = adbConnect(host, port);
-            if (CommandStatus.SUCCESS.equals(result.getStatus())
-                    && result.getStdout().contains(ADB_SUCCESS_CONNECT_TAG)) {
+        try (CloseableTraceScope ignored = new CloseableTraceScope("adbTcpConnect")) {
+            for (int i = 0; i < MAX_RETRIES; i++) {
+                CommandResult result = adbConnect(host, port);
                 CLog.d(
                         "adb connect output: status: %s stdout: %s",
                         result.getStatus(), result.getStdout());
-
-                // It is possible to get a positive result without it being connected because of
-                // the ssh bridge. Retrying to get confirmation, and expecting "already connected".
-                if (confirmAdbTcpConnect(host, port)) {
-                    return true;
+                if (CommandStatus.SUCCESS.equals(result.getStatus())
+                        && result.getStdout().contains(ADB_SUCCESS_CONNECT_TAG)) {
+                    // It is possible to get a positive result without it being connected because of
+                    // the ssh bridge. Retrying to get confirmation, and expecting "already
+                    // connected".
+                    if (confirmAdbTcpConnect(host, port)) {
+                        return true;
+                    }
+                } else if (CommandStatus.SUCCESS.equals(result.getStatus())
+                        && result.getStdout().contains(ADB_CONN_REFUSED)) {
+                    // If we find "Connection Refused", we bail out directly as more connect won't
+                    // help
+                    return false;
                 }
-            } else if (CommandStatus.SUCCESS.equals(result.getStatus())
-                    && result.getStdout().contains(ADB_CONN_REFUSED)) {
-                // If we find "Connection Refused", we bail out directly as more connect won't help
-                return false;
+                CLog.d("adb connect retrying");
+                getRunUtil().sleep((i + 1) * RETRY_INTERVAL_MS);
             }
-            CLog.d(
-                    "adb connect output: status: %s stdout: %s stderr: %s, retrying.",
-                    result.getStatus(), result.getStdout(), result.getStderr());
-            getRunUtil().sleep((i + 1) * RETRY_INTERVAL_MS);
+            return false;
         }
-        return false;
     }
 
     /** Check if the adb connection is enabled. */
     protected void waitForAdbConnect(String serial, final long waitTime)
             throws DeviceNotAvailableException {
-        CLog.i("Waiting %d ms for adb connection.", waitTime);
-        long startTime = System.currentTimeMillis();
-        while (System.currentTimeMillis() - startTime < waitTime) {
-            if (confirmAdbTcpConnect(getHostName(serial), getPortNum(serial))) {
-                CLog.d("Adb connection confirmed.");
-                return;
+        try (CloseableTraceScope ignored = new CloseableTraceScope("wait_for_adb_connect")) {
+            CLog.i("Waiting %d ms for adb connection.", waitTime);
+            long startTime = System.currentTimeMillis();
+            while (System.currentTimeMillis() - startTime < waitTime) {
+                if (confirmAdbTcpConnect(getHostName(serial), getPortNum(serial))) {
+                    CLog.d("Adb connection confirmed.");
+                    return;
+                }
+                getRunUtil().sleep(RETRY_INTERVAL_MS);
             }
-            getRunUtil().sleep(RETRY_INTERVAL_MS);
+            throw new DeviceNotAvailableException(
+                    String.format("No adb connection after %sms.", waitTime),
+                    serial,
+                    DeviceErrorIdentifier.FAILED_TO_CONNECT_TO_TCP_DEVICE);
         }
-        throw new DeviceNotAvailableException(
-                String.format("No adb connection after %sms.", waitTime),
-                serial,
-                DeviceErrorIdentifier.FAILED_TO_CONNECT_TO_TCP_DEVICE);
     }
 
     private boolean confirmAdbTcpConnect(String host, String port) {
diff --git a/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java b/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java
index 658db66ae..59be57969 100644
--- a/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java
+++ b/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java
@@ -112,8 +112,6 @@ public class DeviceSnapshotHandler {
                     InfraErrorIdentifier.UNDETERMINED);
         }
 
-        // TODO: parse snapshot ID from response, and save it to mContext.
-
         // Save snapshot performance data
         Pattern durationPattern = Pattern.compile("Snapshot\\sfinished\\sin (\\d+)\\sms");
         Matcher matcher;
@@ -123,6 +121,9 @@ public class DeviceSnapshotHandler {
                     InvocationMetricKey.DEVICE_SNAPSHOT_SUCCESS_COUNT, 1);
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.DEVICE_SNAPSHOT_DURATIONS, matcher.group(1));
+        } else {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.DEVICE_SNAPSHOT_FAILURE_COUNT, 1);
         }
     }
 
@@ -199,6 +200,9 @@ public class DeviceSnapshotHandler {
                     InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_SUCCESS_COUNT, 1);
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_DURATIONS, matcher.group(1));
+        } else {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_FAILURE_COUNT, 1);
         }
     }
 }
diff --git a/src/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollector.java b/src/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollector.java
index 3b9311167..faf60ab7f 100644
--- a/src/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollector.java
+++ b/src/com/android/tradefed/device/metric/GcovKernelCodeCoverageCollector.java
@@ -25,13 +25,13 @@ import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.DeviceRuntimeException;
 import com.android.tradefed.device.INativeDevice;
-import com.android.tradefed.device.NativeDevice;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.NativeDevice;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
-import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.util.AdbRootElevator;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
@@ -40,6 +40,7 @@ import com.android.tradefed.util.FileUtil;
 import com.google.common.base.Strings;
 
 import java.io.File;
+import java.util.HashSet;
 import java.util.Map;
 
 /**
@@ -60,6 +61,7 @@ public final class GcovKernelCodeCoverageCollector extends BaseDeviceMetricColle
     private IConfiguration mConfiguration;
     private boolean mTestRunStartFail;
     private int mTestCount;
+    private HashSet<String> mDevicesMountedOnStart = new HashSet<>();
 
     public GcovKernelCodeCoverageCollector() {
         setDisableReceiver(false);
@@ -83,6 +85,7 @@ public final class GcovKernelCodeCoverageCollector extends BaseDeviceMetricColle
     public void onTestRunStart(DeviceMetricData runData, int testCount)
             throws DeviceNotAvailableException {
         mTestCount = testCount;
+        mDevicesMountedOnStart.clear();
 
         if (!isGcovKernelCoverageEnabled()) {
             return;
@@ -96,7 +99,10 @@ public final class GcovKernelCodeCoverageCollector extends BaseDeviceMetricColle
         try {
             for (ITestDevice device : getRealDevices()) {
                 try (AdbRootElevator adbRoot = new AdbRootElevator(device)) {
-                    device.mountDebugfs();
+                    if (!device.isDebugfsMounted()) {
+                        device.mountDebugfs();
+                        mDevicesMountedOnStart.add(device.getSerialNumber());
+                    }
                     resetGcovCounts(device);
                 }
             }
@@ -122,7 +128,9 @@ public final class GcovKernelCodeCoverageCollector extends BaseDeviceMetricColle
         for (ITestDevice device : getRealDevices()) {
             try (AdbRootElevator adbRoot = new AdbRootElevator(device)) {
                 collectGcovDebugfsCoverage(device, getTarBasename());
-                device.unmountDebugfs();
+                if (mDevicesMountedOnStart.contains(device.getSerialNumber())) {
+                    device.unmountDebugfs();
+                }
             }
         }
     }
diff --git a/src/com/android/tradefed/device/recovery/BatteryRechargeDeviceRecovery.java b/src/com/android/tradefed/device/recovery/BatteryRechargeDeviceRecovery.java
index fe0a87f8c..f869bf971 100644
--- a/src/com/android/tradefed/device/recovery/BatteryRechargeDeviceRecovery.java
+++ b/src/com/android/tradefed/device/recovery/BatteryRechargeDeviceRecovery.java
@@ -18,6 +18,7 @@ package com.android.tradefed.device.recovery;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.IManagedTestDevice;
+import com.android.tradefed.device.ManagedTestDeviceFactory;
 import com.android.tradefed.device.TestDeviceState;
 
 /** Allow to trigger a command when the battery level of the device goes under a given threshold. */
@@ -36,6 +37,10 @@ public class BatteryRechargeDeviceRecovery extends RunConfigDeviceRecovery {
         if (mMinBattery == null) {
             return true;
         }
+        if (ManagedTestDeviceFactory.isTcpDeviceSerial(device.getSerialNumber())) {
+            // Skip battery check on tcp connected device
+            return true;
+        }
         TestDeviceState state = device.getDeviceState();
         if (TestDeviceState.FASTBOOT.equals(state) || TestDeviceState.FASTBOOTD.equals(state)) {
             return true;
diff --git a/src/com/android/tradefed/device/recovery/UsbResetRunConfigRecovery.java b/src/com/android/tradefed/device/recovery/UsbResetRunConfigRecovery.java
index c71001ed3..5ba4476a2 100644
--- a/src/com/android/tradefed/device/recovery/UsbResetRunConfigRecovery.java
+++ b/src/com/android/tradefed/device/recovery/UsbResetRunConfigRecovery.java
@@ -18,6 +18,7 @@ package com.android.tradefed.device.recovery;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceAllocationState;
 import com.android.tradefed.device.IManagedTestDevice;
+import com.android.tradefed.device.ManagedTestDeviceFactory;
 import com.android.tradefed.device.TestDeviceState;
 
 import java.util.HashSet;
@@ -35,6 +36,10 @@ public class UsbResetRunConfigRecovery extends RunConfigDeviceRecovery {
             // Skip usb reset in recovery mode
             return true;
         }
+        if (ManagedTestDeviceFactory.isTcpDeviceSerial(device.getSerialNumber())) {
+            // Skip usb reset on tcp connected device
+            return true;
+        }
         boolean res = device.isStateBootloaderOrFastbootd();
         // Do not reset available devices
         if (!res && DeviceAllocationState.Available.equals(device.getAllocationState())) {
diff --git a/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java b/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java
index 096b053c8..02f5434d3 100644
--- a/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java
+++ b/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java
@@ -146,6 +146,8 @@ public class DelegatedInvocationExecution extends InvocationExecution {
         commandLine.add(SystemUtil.getRunningJavaBinaryPath().getAbsolutePath());
         mTmpDelegatedDir =
                 FileUtil.createTempDir("delegated-invocation", CurrentInvocation.getWorkFolder());
+        commandLine.add(
+                String.format("-Doriginal.tf.tmpdir=%s", System.getProperty("java.io.tmpdir")));
         commandLine.add(String.format("-Djava.io.tmpdir=%s", mTmpDelegatedDir.getAbsolutePath()));
         commandLine.add("-cp");
         // Add classpath
diff --git a/src/com/android/tradefed/invoker/InvocationExecution.java b/src/com/android/tradefed/invoker/InvocationExecution.java
index 7d0895f51..20357cfbf 100644
--- a/src/com/android/tradefed/invoker/InvocationExecution.java
+++ b/src/com/android/tradefed/invoker/InvocationExecution.java
@@ -665,8 +665,16 @@ public class InvocationExecution implements IInvocationExecution {
                     new CloseableTraceScope("runMultiVirtualDevicesPreInvocationSetup")) {
                 runMultiVirtualDevicesPreInvocationSetup(context, config, logger);
             } catch (TargetSetupError e) {
-                OxygenUtil util = new OxygenUtil();
-                util.downloadLaunchFailureLogs(e, logger);
+                // TODO(b/353826394): Refactor when avd_util wrapping is ready.
+                if (context.getDevices().get(0).getOptions().useCvdCF()) {
+                    // TODO(b/353649277): Flesh out this section when it's ready.
+                    // Basically, the rough processes to pull CF host logs are
+                    // 1. establish the CURL connection via LHP or SSH.
+                    // 2. Compose CURL command and execute it to pull CF logs.
+                } else {
+                    OxygenUtil util = new OxygenUtil();
+                    util.downloadLaunchFailureLogs(e, logger);
+                }
                 throw e;
             }
         } else {
@@ -1210,6 +1218,8 @@ public class InvocationExecution implements IInvocationExecution {
                     if (!decision.isAutoRetryEnabled()
                             || RetryStrategy.NO_RETRY.equals(decision.getRetryStrategy())
                             || test instanceof ITestSuite
+                            // Exclude special launcher
+                            || test.getClass().getSimpleName().equals("CtsTestLauncher")
                             // TODO: Handle auto-retry in local-sharding for non-suite
                             || test instanceof TestsPoolPoller
                             // If test doesn't support auto-retry
@@ -1517,7 +1527,8 @@ public class InvocationExecution implements IInvocationExecution {
         List<ITestInvocationListener> currentTestListeners = new ArrayList<>();
         currentTestListeners.add(mainGranularLevelListener);
         currentTestListeners.add(mainListener);
-        return new RetryLogSaverResultForwarder(config.getLogSaver(), currentTestListeners) {
+        return new RetryLogSaverResultForwarder(
+                config.getLogSaver(), currentTestListeners, config) {
             @Override
             public void testLog(
                     String dataName, LogDataType dataType, InputStreamSource dataStream) {
@@ -1534,7 +1545,7 @@ public class InvocationExecution implements IInvocationExecution {
                 InvocationMetricKey.AUTO_RETRY_TIME, retryTimeMs);
     }
 
-    private void linkExternalDirs(IBuildInfo info, TestInformation testInfo) {
+    protected void linkExternalDirs(IBuildInfo info, TestInformation testInfo) {
         if (info.getProperties().contains(BuildInfoProperties.DO_NOT_LINK_TESTS_DIR)) {
             CLog.d("Skip linking external directory as FileProperty was set.");
             return;
diff --git a/src/com/android/tradefed/invoker/TestInvocation.java b/src/com/android/tradefed/invoker/TestInvocation.java
index 1d36f5d95..b1c1d975d 100644
--- a/src/com/android/tradefed/invoker/TestInvocation.java
+++ b/src/com/android/tradefed/invoker/TestInvocation.java
@@ -26,6 +26,7 @@ import com.android.tradefed.command.CommandScheduler;
 import com.android.tradefed.command.ICommandOptions;
 import com.android.tradefed.command.ICommandScheduler.IScheduledInvocationListener;
 import com.android.tradefed.config.ArgsOptionParser;
+import com.android.tradefed.config.ConfigurationDescriptor;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.DynamicRemoteFileResolver;
 import com.android.tradefed.config.GlobalConfiguration;
@@ -100,6 +101,7 @@ import com.android.tradefed.targetprep.DeviceFailedToBootError;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.testtype.ITestInformationReceiver;
 import com.android.tradefed.testtype.SubprocessTfLauncher;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IDisableable;
@@ -114,6 +116,7 @@ import com.android.tradefed.util.executor.ParallelDeviceExecutor;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
+import com.google.common.base.Strings;
 
 import java.io.File;
 import java.io.IOException;
@@ -1164,9 +1167,10 @@ public class TestInvocation implements ITestInvocation {
                     }
                 }
                 listener =
-                        new LogSaverResultForwarder(config.getLogSaver(), Arrays.asList(forwarder));
+                        new LogSaverResultForwarder(
+                                config.getLogSaver(), Arrays.asList(forwarder), config);
             } else {
-                listener = new LogSaverResultForwarder(config.getLogSaver(), allListeners);
+                listener = new LogSaverResultForwarder(config.getLogSaver(), allListeners, config);
             }
             if (reportPass != null) {
                 reportPass.setLogger(listener);
@@ -1255,7 +1259,8 @@ public class TestInvocation implements ITestInvocation {
                             .getInvocationData()
                             .containsKey(SubprocessTfLauncher.SUBPROCESS_TAG_NAME)
                     && !RunMode.DELEGATED_INVOCATION.equals(mode)) {
-                if (config.getSkipManager().shouldSkipInvocation(info)) {
+                boolean skipInvocation = config.getSkipManager().shouldSkipInvocation(info);
+                if (skipInvocation) {
                     CLog.d("Skipping invocation early.");
                     startInvocation(config, info.getContext(), listener);
                     // Backfill accounting metrics with zeros
@@ -1277,6 +1282,7 @@ public class TestInvocation implements ITestInvocation {
                             InvocationMetricKey.TEST_TEARDOWN_PAIR, timestamp, timestamp);
                     listener.invocationSkipped(
                             new SkipReason(config.getSkipManager().getInvocationSkipReason(), ""));
+                    reportModuleSkip(config, listener);
                     reportHostLog(listener, config);
                     reportInvocationEnded(config, info.getContext(), listener, 0L);
                     return;
@@ -1731,14 +1737,32 @@ public class TestInvocation implements ITestInvocation {
                 String output = device.executeAdbCommand("root");
                 CLog.d("adb recovery root output: %s", output);
                 File recovery_log = device.pullFile(RECOVERY_LOG_DEVICE_PATH);
-                if (recovery_log == null) {
-                    return;
+                if (recovery_log != null) {
+                    try (FileInputStreamSource fis = new FileInputStreamSource(recovery_log)) {
+                        listener.testLog(
+                                String.format("recovery_log_%s.txt", device.getSerialNumber()),
+                                LogDataType.RECOVERY_MODE_LOG,
+                                fis);
+                    }
                 }
-                try (FileInputStreamSource fis = new FileInputStreamSource(recovery_log)) {
-                    listener.testLog(
-                            String.format("recovery_log_%s.txt", device.getSerialNumber()),
-                            LogDataType.RECOVERY_MODE_LOG,
-                            fis);
+                File trustyLog = device.pullFile("/dev/trusty-log0");
+                if (trustyLog != null) {
+                    try (FileInputStreamSource fis = new FileInputStreamSource(trustyLog)) {
+                        listener.testLog(
+                                String.format("trusty-log0_%s.txt", device.getSerialNumber()),
+                                LogDataType.RECOVERY_MODE_LOG,
+                                fis);
+                    }
+                }
+                File lastKmsg = device.pullFile("/sys/fs/pstore/console-ramoops-0");
+                if (lastKmsg != null) {
+                    try (FileInputStreamSource fis = new FileInputStreamSource(lastKmsg)) {
+                        listener.testLog(
+                                String.format("recovery_mode_last_kmsg_%s.txt",
+                                device.getSerialNumber()),
+                                LogDataType.RECOVERY_MODE_LOG,
+                                fis);
+                    }
                 }
             } catch (DeviceNotAvailableException e) {
                 CLog.i("Device unavailable, can't pull recovery.log");
@@ -1896,6 +1920,43 @@ public class TestInvocation implements ITestInvocation {
         return dnae;
     }
 
+    private void reportModuleSkip(IConfiguration config, ITestInvocationListener listener) {
+        if (!config.getSkipManager().reportSkippedModule()) {
+            return;
+        }
+        // Make a heuristic determination of ABI.
+        String abi = "arm64";
+        if (config.getDeviceConfig().get(0).getDeviceRequirements().nullDeviceRequested()
+                || config.getDeviceConfig().get(0).getDeviceRequirements().gceDeviceRequested()) {
+            abi = "x86_64";
+        }
+        String buildTarget =
+                config.getCommandOptions()
+                        .getInvocationData()
+                        .getUniqueMap()
+                        .get("test_result.build_target");
+        if (!Strings.isNullOrEmpty(buildTarget) && buildTarget.contains("cf_arm64")) {
+            abi = "arm64";
+        }
+
+        for (String moduleName : config.getSkipManager().getUnchangedModules()) {
+            IInvocationContext moduleContext = new InvocationContext();
+            ConfigurationDescriptor configDescriptor = new ConfigurationDescriptor();
+            configDescriptor.setModuleName(moduleName);
+
+            moduleContext.setConfigurationDescriptor(configDescriptor);
+            moduleContext.addInvocationAttribute(ModuleDefinition.MODULE_ABI, abi);
+            moduleContext.addInvocationAttribute(ModuleDefinition.MODULE_NAME, moduleName);
+            moduleContext.addInvocationAttribute(
+                    ModuleDefinition.MODULE_ID, abi + " " + moduleName);
+            moduleContext.addInvocationAttribute(
+                    ModuleDefinition.MODULE_SKIPPED,
+                    config.getSkipManager().getInvocationSkipReason());
+            listener.testModuleStarted(moduleContext);
+            listener.testModuleEnded();
+        }
+    }
+
     /**
      * Helper that use the command line to backfill a {@link IBuildInfo} for reporting in case of
      * download failure.
diff --git a/src/com/android/tradefed/invoker/sandbox/SandboxedInvocationExecution.java b/src/com/android/tradefed/invoker/sandbox/SandboxedInvocationExecution.java
index f5941312a..1c9bcd61a 100644
--- a/src/com/android/tradefed/invoker/sandbox/SandboxedInvocationExecution.java
+++ b/src/com/android/tradefed/invoker/sandbox/SandboxedInvocationExecution.java
@@ -73,6 +73,9 @@ public class SandboxedInvocationExecution extends InvocationExecution {
         // Still set the test-tag on build infos for proper reporting
         for (IBuildInfo info : testInfo.getContext().getBuildInfos()) {
             setTestTag(info, config);
+            // Force the linking again in case there was no original testsdir
+            // this is inop if the linking already occurred.
+            super.linkExternalDirs(info, testInfo);
         }
         backFillTestInformation(testInfo, testInfo.getBuildInfo());
         return true;
diff --git a/src/com/android/tradefed/invoker/shard/DynamicShardHelper.java b/src/com/android/tradefed/invoker/shard/DynamicShardHelper.java
index 07a96ec13..051ed08db 100644
--- a/src/com/android/tradefed/invoker/shard/DynamicShardHelper.java
+++ b/src/com/android/tradefed/invoker/shard/DynamicShardHelper.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.invoker.shard;
 
+import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.IRescheduler;
@@ -108,10 +109,9 @@ public class DynamicShardHelper extends StrictShardHelper {
 
         if (shouldDelegate) {
             CLog.d(
-                    "Setting option 'remote-dynamic-sharding' to false since precondition checks"
-                            + " failed.");
-            config.getCommandOptions().setShouldRemoteDynamicShard(false);
-            return super.shardConfig(config, testInfo, rescheduler, logger);
+                    "Re-entering StrictShardHelper with dynamic sharding disabled due to failed"
+                            + " precondition checks.");
+            return shardConfigStrict(config, testInfo, rescheduler, logger);
         }
 
         // Initialize Dynamic Sharding client
@@ -119,7 +119,6 @@ public class DynamicShardHelper extends StrictShardHelper {
 
         String poolId = String.format("invocation-%s", invocationId);
 
-
         Map<String, ITestSuite> moduleMapping = new HashMap<>();
         for (ITestSuite test : allModules) {
             ModuleDefinition moduleDef = test.getDirectModule();
@@ -180,6 +179,16 @@ public class DynamicShardHelper extends StrictShardHelper {
         return false;
     }
 
+    @VisibleForTesting
+    protected boolean shardConfigStrict(
+            IConfiguration config,
+            TestInformation testInfo,
+            IRescheduler rescheduler,
+            ITestLogger logger) {
+        return super.shardConfigInternal(config, testInfo, rescheduler, logger);
+    }
+
+    @VisibleForTesting
     private IDynamicShardingClient getClient() {
         FeatureResponse resp = null;
         try (TradefedFeatureClient featureClient = new TradefedFeatureClient()) {
diff --git a/src/com/android/tradefed/invoker/shard/StrictShardHelper.java b/src/com/android/tradefed/invoker/shard/StrictShardHelper.java
index 9f239c5c7..af726082a 100644
--- a/src/com/android/tradefed/invoker/shard/StrictShardHelper.java
+++ b/src/com/android/tradefed/invoker/shard/StrictShardHelper.java
@@ -52,14 +52,30 @@ public class StrictShardHelper extends ShardHelper {
             TestInformation testInfo,
             IRescheduler rescheduler,
             ITestLogger logger) {
-        // need to look up attempt id somewhere and make sure we only attempt this on attempt 0
         if (config.getCommandOptions().shouldRemoteDynamicShard()) {
-            // We are using dynamic sharding
-            DynamicShardHelper helper = new DynamicShardHelper();
-            // TODO(murj) handle the case where dynamic sharding fails
-            return helper.shardConfig(config, testInfo, rescheduler, logger);
+            return shardConfigDynamic(config, testInfo, rescheduler, logger);
+        } else {
+            return shardConfigInternal(config, testInfo, rescheduler, logger);
         }
+    }
 
+    @VisibleForTesting
+    protected boolean shardConfigDynamic(
+            IConfiguration config,
+            TestInformation testInfo,
+            IRescheduler rescheduler,
+            ITestLogger logger) {
+        // attempt dynamic sharding
+        // may call #shardConfigInternal itself if preconditions are not met
+        DynamicShardHelper helper = new DynamicShardHelper();
+        return helper.shardConfig(config, testInfo, rescheduler, logger);
+    }
+
+    protected boolean shardConfigInternal(
+            IConfiguration config,
+            TestInformation testInfo,
+            IRescheduler rescheduler,
+            ITestLogger logger) {
         Integer shardCount = config.getCommandOptions().getShardCount();
         Integer shardIndex = config.getCommandOptions().getShardIndex();
         boolean optimizeMainline = config.getCommandOptions().getOptimizeMainlineTest();
@@ -106,14 +122,16 @@ public class StrictShardHelper extends ShardHelper {
      * @param tests the {@link IRemoteTest} containing all the tests that need to run.
      */
     private void reorderTestModules(List<IRemoteTest> tests) {
-        Collections.sort(tests, new Comparator<IRemoteTest>() {
-            @Override
-            public int compare(IRemoteTest o1, IRemoteTest o2) {
-                String moduleId1 = ((ITestSuite)o1).getDirectModule().getId();
-                String moduleId2 = ((ITestSuite)o2).getDirectModule().getId();
-                return getMainlineId(moduleId1).compareTo(getMainlineId(moduleId2));
-            }
-        });
+        Collections.sort(
+                tests,
+                new Comparator<IRemoteTest>() {
+                    @Override
+                    public int compare(IRemoteTest o1, IRemoteTest o2) {
+                        String moduleId1 = ((ITestSuite) o1).getDirectModule().getId();
+                        String moduleId2 = ((ITestSuite) o2).getDirectModule().getId();
+                        return getMainlineId(moduleId1).compareTo(getMainlineId(moduleId2));
+                    }
+                });
     }
 
     /**
diff --git a/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java b/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java
index be0d4d7c9..78846fd28 100644
--- a/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java
+++ b/src/com/android/tradefed/invoker/shard/TestsPoolPoller.java
@@ -16,7 +16,6 @@
 package com.android.tradefed.invoker.shard;
 
 import com.android.annotations.VisibleForTesting;
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.BuildRetrievalError;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
@@ -36,9 +35,12 @@ import com.android.tradefed.invoker.logger.CurrentInvocation.IsolationGrade;
 import com.android.tradefed.invoker.shard.token.ITokenRequest;
 import com.android.tradefed.log.ILogRegistry;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.skipped.SkipContext;
+import com.android.tradefed.result.skipped.SkipFeature;
 import com.android.tradefed.suite.checker.ISystemStatusChecker;
 import com.android.tradefed.suite.checker.ISystemStatusCheckerReceiver;
 import com.android.tradefed.testtype.IBuildReceiver;
@@ -115,6 +117,7 @@ public final class TestsPoolPoller
                 }
                 listenerWithCollectors = collector.init(info.getContext(), listenerWithCollectors);
             }
+            SkipContext skipContext = SkipFeature.getSkipContext();
             while (true) {
                 IRemoteTest test = poll();
                 if (test == null) {
@@ -138,6 +141,7 @@ public final class TestsPoolPoller
                 } else if (test instanceof BaseTestSuite) {
                     CLog.d("Applying global filters to BaseTestSuite");
                     mConfig.getGlobalFilters().applyFiltersToTest((BaseTestSuite) test);
+                    ((BaseTestSuite) test).setSkipContext(skipContext);
                 }
                 IConfiguration validationConfig = new Configuration("validation", "validation");
                 try {
diff --git a/src/com/android/tradefed/log/BaseLeveledLogOutput.java b/src/com/android/tradefed/log/BaseLeveledLogOutput.java
index 91219cb5f..cedcb8e79 100644
--- a/src/com/android/tradefed/log/BaseLeveledLogOutput.java
+++ b/src/com/android/tradefed/log/BaseLeveledLogOutput.java
@@ -15,9 +15,9 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.Option;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogUtil.CLog;
 
 import com.google.common.collect.ImmutableMap;
diff --git a/src/com/android/tradefed/log/BaseStreamLogger.java b/src/com/android/tradefed/log/BaseStreamLogger.java
index 3703132ba..1adf32540 100644
--- a/src/com/android/tradefed/log/BaseStreamLogger.java
+++ b/src/com/android/tradefed/log/BaseStreamLogger.java
@@ -15,9 +15,9 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.Option.Importance;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.util.StreamUtil;
 
 import java.io.IOException;
@@ -55,6 +55,11 @@ public abstract class BaseStreamLogger<OS extends OutputStream> extends BaseLeve
         mLogLevelDisplay = logLevel;
     }
 
+    /** For compatibility */
+    public void setLogLevelDisplay(com.android.ddmlib.Log.LogLevel logLevel) {
+        mLogLevelDisplay = LogLevel.convertFromDdmlib(logLevel);
+    }
+
     /** @return current minimum {@link LogLevel} to display on stdout. */
     public LogLevel getLogLevelDisplay() {
         return mLogLevelDisplay;
@@ -82,7 +87,7 @@ public abstract class BaseStreamLogger<OS extends OutputStream> extends BaseLeve
      */
     private void internalPrintLog(
             LogLevel logLevel, String tag, String message, boolean forceStdout) {
-        String outMessage = LogUtil.getLogFormatString(logLevel, tag, message);
+        String outMessage = Log.getLogFormatString(logLevel, tag, message);
         if (shouldDisplay(forceStdout, mLogLevelDisplay, logLevel, tag)) {
             System.out.print(outMessage);
         }
diff --git a/src/com/android/tradefed/log/HistoryLogger.java b/src/com/android/tradefed/log/HistoryLogger.java
index d71316347..c0f48c38a 100644
--- a/src/com/android/tradefed/log/HistoryLogger.java
+++ b/src/com/android/tradefed/log/HistoryLogger.java
@@ -15,9 +15,9 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.OptionCopier;
 import com.android.tradefed.log.ILogRegistry.EventType;
+import com.android.tradefed.log.Log.LogLevel;
 
 import org.json.JSONObject;
 
diff --git a/src/com/android/tradefed/log/ILeveledLogOutput.java b/src/com/android/tradefed/log/ILeveledLogOutput.java
index 31ee5a733..4b6bcbb4c 100644
--- a/src/com/android/tradefed/log/ILeveledLogOutput.java
+++ b/src/com/android/tradefed/log/ILeveledLogOutput.java
@@ -15,8 +15,8 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.ILogOutput;
-import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.log.Log.ILogOutput;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.result.InputStreamSource;
 
 import java.io.BufferedInputStream;
diff --git a/src/com/android/tradefed/log/ILogRegistry.java b/src/com/android/tradefed/log/ILogRegistry.java
index 860890a0a..2efa2d346 100644
--- a/src/com/android/tradefed/log/ILogRegistry.java
+++ b/src/com/android/tradefed/log/ILogRegistry.java
@@ -16,8 +16,8 @@
 
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.ILogOutput;
-import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.log.Log.ILogOutput;
+import com.android.tradefed.log.Log.LogLevel;
 
 import java.util.Map;
 
@@ -29,6 +29,7 @@ public interface ILogRegistry extends ILogOutput {
 
     /** Events that are useful to be logged */
     public enum EventType {
+        TRADEFED_STARTED,
         DEVICE_CONNECTED,
         DEVICE_CONNECTED_OFFLINE,
         DEVICE_DISCONNECTED,
diff --git a/src/com/android/tradefed/log/LogRegistry.java b/src/com/android/tradefed/log/LogRegistry.java
index 8231d0c25..bf52c715f 100644
--- a/src/com/android/tradefed/log/LogRegistry.java
+++ b/src/com/android/tradefed/log/LogRegistry.java
@@ -15,8 +15,7 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log;
-import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.util.FileUtil;
 
@@ -26,6 +25,7 @@ import java.io.InputStream;
 import java.text.SimpleDateFormat;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
@@ -50,6 +50,18 @@ public class LogRegistry implements ILogRegistry {
     private FileLogger mGlobalLogger;
     private HistoryLogger mHistoryLogger;
 
+    private static ThreadLocal<ThreadGroup> sLocal = new ThreadLocal<>();
+
+    /** Tracks a localized context when using the properties inside the gRPC server */
+    public static void setLocalGroup(ThreadGroup tg) {
+        sLocal.set(tg);
+    }
+
+    /** Resets the localized context. */
+    public static void resetLocalGroup() {
+        sLocal.remove();
+    }
+
     /**
      * Package-private constructor; callers should use {@link #getLogRegistry} to get an instance of
      * the {@link LogRegistry}.
@@ -65,6 +77,8 @@ public class LogRegistry implements ILogRegistry {
         try {
             mHistoryLogger = new HistoryLogger();
             mHistoryLogger.init();
+            mHistoryLogger.logEvent(
+                    LogLevel.DEBUG, EventType.TRADEFED_STARTED, new HashMap<String, String>());
         } catch (IOException e) {
             System.err.println("Failed to create history logger");
             throw new IllegalStateException(e);
@@ -157,6 +171,9 @@ public class LogRegistry implements ILogRegistry {
      * @return the ThreadGroup that the current thread belongs to
      */
     ThreadGroup getCurrentThreadGroup() {
+        if (sLocal.get() != null) {
+            return sLocal.get();
+        }
         return Thread.currentThread().getThreadGroup();
     }
 
@@ -276,7 +293,7 @@ public class LogRegistry implements ILogRegistry {
             FileUtil.writeToFile(logData.createInputStream(), tradefedLog);
             // Align format to our standard logger
             String message =
-                    LogUtil.getLogFormatString(
+                    Log.getLogFormatString(
                             LogLevel.VERBOSE,
                             this.getClass().getSimpleName(),
                             String.format("Saved log to %s", tradefedLog.getAbsolutePath()));
diff --git a/src/com/android/tradefed/log/StdoutLogger.java b/src/com/android/tradefed/log/StdoutLogger.java
index d19dd44db..ada19fbe3 100644
--- a/src/com/android/tradefed/log/StdoutLogger.java
+++ b/src/com/android/tradefed/log/StdoutLogger.java
@@ -15,10 +15,10 @@
  */
 package com.android.tradefed.log;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.Option.Importance;
 import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.result.InputStreamSource;
 
 import java.io.IOException;
@@ -47,7 +47,7 @@ public class StdoutLogger implements ILeveledLogOutput {
      */
     @Override
     public void printLog(LogLevel logLevel, String tag, String message) {
-        LogUtil.printLog(logLevel, tag, message);
+        Log.printLog(logLevel, tag, message);
     }
 
     /**
diff --git a/src/com/android/tradefed/result/LogSaverResultForwarder.java b/src/com/android/tradefed/result/LogSaverResultForwarder.java
index 06d7758a8..cfdfb3528 100644
--- a/src/com/android/tradefed/result/LogSaverResultForwarder.java
+++ b/src/com/android/tradefed/result/LogSaverResultForwarder.java
@@ -17,6 +17,7 @@
 package com.android.tradefed.result;
 
 import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.TestInvocation;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
@@ -35,11 +36,13 @@ import java.util.List;
 public class LogSaverResultForwarder extends ResultForwarder implements ILogSaverListener {
 
     ILogSaver mLogSaver;
+    IConfiguration mConfig;
 
-    public LogSaverResultForwarder(ILogSaver logSaver,
-            List<ITestInvocationListener> listeners) {
+    public LogSaverResultForwarder(
+            ILogSaver logSaver, List<ITestInvocationListener> listeners, IConfiguration config) {
         super(listeners);
         mLogSaver = logSaver;
+        mConfig = config;
         for (ITestInvocationListener listener : listeners) {
             if (listener instanceof ILogSaverListener) {
                 ((ILogSaverListener) listener).setLogSaver(mLogSaver);
@@ -75,7 +78,11 @@ public class LogSaverResultForwarder extends ResultForwarder implements ILogSave
             CLog.e("Caught runtime exception from log saver: %s", mLogSaver.getClass().getName());
             CLog.e(e);
         }
-        reportEndHostLog(getListeners(), mLogSaver, TestInvocation.TRADEFED_END_HOST_LOG);
+        String endHostLogName = TestInvocation.TRADEFED_END_HOST_LOG;
+        if (mConfig.getCommandOptions().getHostLogSuffix() != null) {
+            endHostLogName += mConfig.getCommandOptions().getHostLogSuffix();
+        }
+        reportEndHostLog(getListeners(), mLogSaver, endHostLogName);
     }
 
     /** Log a final file before completion */
diff --git a/src/com/android/tradefed/result/TestRunResultListener.java b/src/com/android/tradefed/result/TestRunResultListener.java
new file mode 100644
index 000000000..0d02111f7
--- /dev/null
+++ b/src/com/android/tradefed/result/TestRunResultListener.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.result;
+
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/** Listener that allows to read the final test run status. */
+public final class TestRunResultListener implements ITestInvocationListener {
+    private Map<String, Set<String>> mFailedRuns = new HashMap<>();
+    private String mCurrentTestRun = null;
+
+    /** {@inheritDoc} */
+    @Override
+    public void testRunStarted(String runName, int testCount) {
+        if (mCurrentTestRun != null) {
+            throw new RuntimeException(
+                    "Failed to clean the current test run name before starting a new test run.");
+        }
+        mCurrentTestRun = runName;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void testRunEnded(long elapsedTime, HashMap<String, Metric> runMetrics) {
+        mCurrentTestRun = null;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void testRunFailed(String errorMessage) {
+        handleFailure(null);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void testRunFailed(FailureDescription failure) {
+        handleFailure(null);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void testFailed(TestDescription test, String trace) {
+        handleFailure(test.getTestName());
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void testFailed(TestDescription test, FailureDescription failure) {
+        handleFailure(test.getTestName());
+    }
+
+    public boolean isTestRunFailed(String testRunName) {
+        return mFailedRuns.containsKey(testRunName);
+    }
+
+    public boolean isTestFailed(String testName) {
+        if (!mFailedRuns.containsKey(mCurrentTestRun)) {
+            return false;
+        }
+        Set<String> failedTests = mFailedRuns.get(mCurrentTestRun);
+        return failedTests.isEmpty() || failedTests.contains(testName);
+    }
+
+    private void handleFailure(String testName) {
+        if (mCurrentTestRun == null) {
+            throw new RuntimeException(
+                    "Failed to catch the test run start before the test run failed.");
+        }
+        Set<String> failedTests = mFailedRuns.getOrDefault(mCurrentTestRun, new HashSet<>());
+        // If the test name is null, the whole test run is failed and the failed test set is empty.
+        if (testName != null) {
+            failedTests.add(testName);
+        }
+        mFailedRuns.put(mCurrentTestRun, failedTests);
+    }
+}
diff --git a/src/com/android/tradefed/result/ddmlib/AndroidTestOrchestratorRemoteTestRunner.java b/src/com/android/tradefed/result/ddmlib/AndroidTestOrchestratorRemoteTestRunner.java
index 3f005e80c..0c007f1ba 100644
--- a/src/com/android/tradefed/result/ddmlib/AndroidTestOrchestratorRemoteTestRunner.java
+++ b/src/com/android/tradefed/result/ddmlib/AndroidTestOrchestratorRemoteTestRunner.java
@@ -17,7 +17,6 @@
 package com.android.tradefed.result.ddmlib;
 
 import com.android.ddmlib.IDevice;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java b/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java
index f2bfb1123..138d5bb69 100644
--- a/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java
+++ b/src/com/android/tradefed/result/ddmlib/DefaultRemoteAndroidTestRunner.java
@@ -19,7 +19,6 @@ import com.android.ddmlib.IShellEnabledDevice;
 import com.android.ddmlib.testrunner.IInstrumentationResultParser;
 import com.android.ddmlib.testrunner.ITestRunListener;
 import com.android.ddmlib.testrunner.InstrumentationResultParser;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 
 import java.util.Collection;
 
diff --git a/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java b/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java
new file mode 100644
index 000000000..3c5cc8d22
--- /dev/null
+++ b/src/com/android/tradefed/result/ddmlib/RemoteAndroidTestRunner.java
@@ -0,0 +1,462 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.IShellEnabledDevice;
+import com.android.ddmlib.ShellCommandUnresponsiveException;
+import com.android.ddmlib.TimeoutException;
+import com.android.ddmlib.testrunner.IInstrumentationResultParser;
+import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
+import com.android.ddmlib.testrunner.ITestRunListener;
+import com.android.ddmlib.testrunner.InstrumentationProtoResultParser;
+import com.android.ddmlib.testrunner.InstrumentationResultParser;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+
+/** Runs a Android test command remotely and reports results. */
+public class RemoteAndroidTestRunner implements IRemoteAndroidTestRunner {
+
+    /** Represents a status reporter mode in am instrument command options. */
+    public enum StatusReporterMode {
+        /**
+         * Use raw text message to receive status from am instrument command.
+         *
+         * @deprecated Use {@link #PROTO_STD} for API level 26 and above.
+         */
+        @Deprecated
+        RAW_TEXT("-r", 0, InstrumentationResultParser::new),
+        /**
+         * Use instrumentationData protobuf status reporter to receive status from am instrument
+         * command.
+         */
+        PROTO_STD("-m", 26, InstrumentationProtoResultParser::new);
+
+        StatusReporterMode(
+                String amInstrumentCommandArg,
+                int minApiLevel,
+                BiFunction<String, Collection<ITestRunListener>, IInstrumentationResultParser>
+                        parserFactory) {
+            this.amInstrumentCommandArg = amInstrumentCommandArg;
+            this.minApiLevel = minApiLevel;
+            this.parserFactory = parserFactory;
+        }
+
+        private final String amInstrumentCommandArg;
+        private final int minApiLevel;
+        private final BiFunction<String, Collection<ITestRunListener>, IInstrumentationResultParser>
+                parserFactory;
+
+        /**
+         * Returns a command line arg for am instrument command to specify this status reporter
+         * mode.
+         */
+        public String getAmInstrumentCommandArg() {
+            return amInstrumentCommandArg;
+        }
+
+        /**
+         * Returns the minimum Android API level which supports this instrumentation status report
+         * type.
+         */
+        public int getMinimumApiLevel() {
+            return minApiLevel;
+        }
+
+        /**
+         * Create the {@link InstrumentationResultParser} that can be used to parse the
+         * instrumentation output.
+         *
+         * @param runName The name of the run to use.
+         * @param listeners The listeners where to report the results.
+         * @return An instance of {@link InstrumentationResultParser}.
+         */
+        public IInstrumentationResultParser createInstrumentationResultParser(
+                @NonNull String runName, @NonNull Collection<ITestRunListener> listeners) {
+            return parserFactory.apply(runName, listeners);
+        }
+    }
+
+    private final StatusReporterMode mStatusReporterMode;
+    private final String mPackageName;
+    private final String mRunnerName;
+    private IShellEnabledDevice mRemoteDevice;
+    // default to no timeout
+    private long mMaxTimeoutMs = 0L;
+    private long mMaxTimeToOutputResponseMs = 0L;
+    private String mRunName = null;
+
+    /** map of name-value instrumentation argument pairs */
+    private Map<String, String> mArgMap;
+
+    private IInstrumentationResultParser mParser;
+    private static final String LOG_TAG = "RemoteAndroidTest";
+    private static final String DEFAULT_RUNNER_NAME = "android.test.InstrumentationTestRunner";
+    private static final char CLASS_SEPARATOR = ',';
+    private static final char METHOD_SEPARATOR = '#';
+    private static final char RUNNER_SEPARATOR = '/';
+    // defined instrumentation argument names
+    private static final String CLASS_ARG_NAME = "class";
+    private static final String LOG_ARG_NAME = "log";
+    private static final String DEBUG_ARG_NAME = "debug";
+    private static final String COVERAGE_ARG_NAME = "coverage";
+    private static final String PACKAGE_ARG_NAME = "package";
+    private static final String SIZE_ARG_NAME = "size";
+    private static final String DELAY_MSEC_ARG_NAME = "delay_msec";
+    private String mRunOptions = "";
+    private static final int TEST_COLLECTION_TIMEOUT = 2 * 60 * 1000; // 2 min
+
+    /**
+     * Creates a remote Android test runner.
+     *
+     * @param packageName the Android application package that contains the tests to run
+     * @param runnerName the instrumentation test runner to execute. If null, will use default
+     *     runner
+     * @param remoteDevice the Android device to execute tests on
+     * @param statusReporterMode the status reporter mode to be used for am instrument command
+     */
+    public RemoteAndroidTestRunner(
+            String packageName,
+            String runnerName,
+            IShellEnabledDevice remoteDevice,
+            StatusReporterMode statusReporterMode) {
+        mPackageName = packageName;
+        mRunnerName = runnerName;
+        mRemoteDevice = remoteDevice;
+        mStatusReporterMode = statusReporterMode;
+        mArgMap = new Hashtable<String, String>();
+    }
+
+    /**
+     * Alternate constructor. Uses default {@code statusReporterMode}.
+     *
+     * @param packageName the Android application package that contains the tests to run
+     * @param runnerName the instrumentation test runner to execute. If null, will use default
+     *     runner
+     * @param remoteDevice the Android device to execute tests on
+     */
+    public RemoteAndroidTestRunner(
+            String packageName, String runnerName, IShellEnabledDevice remoteDevice) {
+        this(packageName, runnerName, remoteDevice, StatusReporterMode.RAW_TEXT);
+    }
+
+    /**
+     * Alternate constructor. Uses default instrumentation runner.
+     *
+     * @param packageName the Android application package that contains the tests to run
+     * @param remoteDevice the Android device to execute tests on
+     */
+    public RemoteAndroidTestRunner(String packageName, IShellEnabledDevice remoteDevice) {
+        this(packageName, null, remoteDevice);
+    }
+
+    @Override
+    public String getPackageName() {
+        return mPackageName;
+    }
+
+    @Override
+    public String getRunnerName() {
+        if (mRunnerName == null) {
+            return DEFAULT_RUNNER_NAME;
+        }
+        return mRunnerName;
+    }
+
+    /** Returns the complete instrumentation component path. */
+    protected String getRunnerPath() {
+        return getPackageName() + RUNNER_SEPARATOR + getRunnerName();
+    }
+
+    @Override
+    public void setClassName(String className) {
+        // The class name may contain the dollar sign, so needs to be quoted.
+        addInstrumentationArg(CLASS_ARG_NAME, "'" + className + "'");
+    }
+
+    @Override
+    public void setClassNames(String[] classNames) {
+        StringBuilder classArgBuilder = new StringBuilder();
+        for (int i = 0; i < classNames.length; i++) {
+            if (i != 0) {
+                classArgBuilder.append(CLASS_SEPARATOR);
+            }
+            classArgBuilder.append(classNames[i]);
+        }
+        setClassName(classArgBuilder.toString());
+    }
+
+    @Override
+    public void setMethodName(String className, String testName) {
+        setClassName(className + METHOD_SEPARATOR + testName);
+    }
+
+    @Override
+    public void setTestPackageName(String packageName) {
+        addInstrumentationArg(PACKAGE_ARG_NAME, packageName);
+    }
+
+    @Override
+    public void addInstrumentationArg(String name, String value) {
+        if (name == null || value == null) {
+            throw new IllegalArgumentException("name or value arguments cannot be null");
+        }
+        mArgMap.put(name, value);
+    }
+
+    @Override
+    public void removeInstrumentationArg(String name) {
+        if (name == null) {
+            throw new IllegalArgumentException("name argument cannot be null");
+        }
+        mArgMap.remove(name);
+    }
+
+    @Override
+    public void addBooleanArg(String name, boolean value) {
+        addInstrumentationArg(name, Boolean.toString(value));
+    }
+
+    @Override
+    public void setLogOnly(boolean logOnly) {
+        addBooleanArg(LOG_ARG_NAME, logOnly);
+    }
+
+    @Override
+    public void setDebug(boolean debug) {
+        addBooleanArg(DEBUG_ARG_NAME, debug);
+    }
+
+    @Override
+    public void setAdditionalTestOutputLocation(String additionalTestDataPath) {
+        addInstrumentationArg("additionalTestOutputDir", additionalTestDataPath);
+    }
+
+    @Override
+    public void setCoverage(boolean coverage) {
+        addBooleanArg(COVERAGE_ARG_NAME, coverage);
+    }
+
+    @Override
+    public void setCoverageReportLocation(String reportPath) {
+        addInstrumentationArg("coverageFile", reportPath);
+    }
+
+    @Override
+    public CoverageOutput getCoverageOutputType() {
+        return CoverageOutput.FILE;
+    }
+
+    @Override
+    public void setTestSize(TestSize size) {
+        addInstrumentationArg(SIZE_ARG_NAME, "small");
+    }
+
+    @Override
+    public void setTestCollection(boolean collect) {
+        if (collect) {
+            // skip test execution
+            setLogOnly(true);
+            // force a timeout for test collection
+            setMaxTimeToOutputResponse(TEST_COLLECTION_TIMEOUT, TimeUnit.MILLISECONDS);
+            if (getApiLevel() < 16) {
+                // On older platforms, collecting tests can fail for large volume of tests.
+                // Insert a small delay between each test to prevent this
+                addInstrumentationArg(DELAY_MSEC_ARG_NAME, "15" /* ms */);
+            }
+        } else {
+            setLogOnly(false);
+            // restore timeout to its original set value
+            setMaxTimeToOutputResponse(mMaxTimeToOutputResponseMs, TimeUnit.MILLISECONDS);
+            if (getApiLevel() < 16) {
+                // remove delay
+                removeInstrumentationArg(DELAY_MSEC_ARG_NAME);
+            }
+        }
+    }
+
+    /**
+     * Attempts to retrieve the Api level of the Android device
+     *
+     * @return the api level or -1 if the communication with the device wasn't successful
+     */
+    private int getApiLevel() {
+        try {
+            return Integer.parseInt(
+                    mRemoteDevice.getSystemProperty(IDevice.PROP_BUILD_API_LEVEL).get());
+        } catch (Exception e) {
+            return -1;
+        }
+    }
+
+    @Deprecated
+    @Override
+    public void setMaxtimeToOutputResponse(int maxTimeToOutputResponse) {
+        setMaxTimeToOutputResponse(maxTimeToOutputResponse, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void setMaxTimeToOutputResponse(long maxTimeToOutputResponse, TimeUnit maxTimeUnits) {
+        mMaxTimeToOutputResponseMs = maxTimeUnits.toMillis(maxTimeToOutputResponse);
+    }
+
+    @Override
+    public void setMaxTimeout(long maxTimeout, TimeUnit maxTimeUnits) {
+        mMaxTimeoutMs = maxTimeUnits.toMillis(maxTimeout);
+    }
+
+    @Override
+    public void setRunName(String runName) {
+        mRunName = runName;
+    }
+
+    @Override
+    public void run(ITestRunListener... listeners)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        run(Arrays.asList(listeners));
+    }
+
+    @Override
+    public void run(Collection<ITestRunListener> listeners)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        final String runCaseCommandStr = getAmInstrumentCommand();
+        CLog.i("Running %1$s on %2$s", runCaseCommandStr, mRemoteDevice.getName());
+        String runName = mRunName == null ? mPackageName : mRunName;
+        mParser = createParser(runName, listeners);
+        try {
+            mRemoteDevice.executeShellCommand(
+                    runCaseCommandStr,
+                    mParser,
+                    mMaxTimeoutMs,
+                    mMaxTimeToOutputResponseMs,
+                    TimeUnit.MILLISECONDS);
+        } catch (IOException e) {
+            Log.w(
+                    LOG_TAG,
+                    String.format(
+                            "IOException %1$s when running tests %2$s on %3$s",
+                            e.toString(), getPackageName(), mRemoteDevice.getName()));
+            // rely on parser to communicate results to listeners
+            mParser.handleTestRunFailed(e.toString());
+            throw e;
+        } catch (ShellCommandUnresponsiveException e) {
+            Log.w(
+                    LOG_TAG,
+                    String.format(
+                            "ShellCommandUnresponsiveException %1$s when running tests %2$s on"
+                                    + " %3$s",
+                            e.toString(), getPackageName(), mRemoteDevice.getName()));
+            mParser.handleTestRunFailed(
+                    String.format(
+                            "Failed to receive adb shell test output within %1$d ms. Test may have "
+                                    + "timed out, or adb connection to device became unresponsive",
+                            mMaxTimeToOutputResponseMs));
+            throw e;
+        } catch (TimeoutException e) {
+            Log.w(
+                    LOG_TAG,
+                    String.format(
+                            "TimeoutException when running tests %1$s on %2$s",
+                            getPackageName(), mRemoteDevice.getName()));
+            mParser.handleTestRunFailed(e.toString());
+            throw e;
+        } catch (AdbCommandRejectedException e) {
+            Log.w(
+                    LOG_TAG,
+                    String.format(
+                            "AdbCommandRejectedException %1$s when running tests %2$s on %3$s",
+                            e.toString(), getPackageName(), mRemoteDevice.getName()));
+            mParser.handleTestRunFailed(e.toString());
+            throw e;
+        }
+    }
+
+    /**
+     * Create the {@link InstrumentationResultParser} that will be used to parse the instrumentation
+     * output.
+     *
+     * @param runName The name of the run to use.
+     * @param listeners The listeners where to report the results.
+     * @return An instance of {@link InstrumentationResultParser}.
+     */
+    @NonNull
+    public IInstrumentationResultParser createParser(
+            @NonNull String runName, @NonNull Collection<ITestRunListener> listeners) {
+        return mStatusReporterMode.createInstrumentationResultParser(runName, listeners);
+    }
+
+    @NonNull
+    public String getAmInstrumentCommand() {
+        return String.format(
+                "am instrument -w %1$s %2$s %3$s %4$s",
+                mStatusReporterMode.getAmInstrumentCommandArg(),
+                getRunOptions(),
+                getArgsCommand(),
+                getRunnerPath());
+    }
+
+    /** Returns options for the am instrument command. */
+    @NonNull
+    public String getRunOptions() {
+        return mRunOptions;
+    }
+
+    /**
+     * Sets options for the am instrument command. See com/android/commands/am/Am.java for full list
+     * of options.
+     */
+    public void setRunOptions(@NonNull String options) {
+        mRunOptions = options;
+    }
+
+    @Override
+    public void cancel() {
+        if (mParser != null) {
+            mParser.cancel();
+        }
+    }
+
+    /**
+     * Returns the full instrumentation command line syntax for the provided instrumentation
+     * arguments. Returns an empty string if no arguments were specified.
+     */
+    protected String getArgsCommand() {
+        StringBuilder commandBuilder = new StringBuilder();
+        for (Entry<String, String> argPair : mArgMap.entrySet()) {
+            final String argCmd =
+                    String.format(" -e %1$s %2$s", argPair.getKey(), argPair.getValue());
+            commandBuilder.append(argCmd);
+        }
+        return commandBuilder.toString();
+    }
+}
diff --git a/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java b/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java
new file mode 100644
index 000000000..de992e1d0
--- /dev/null
+++ b/src/com/android/tradefed/result/proto/ModuleProtoResultReporter.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.proto;
+
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.proto.InvocationContext.Context;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.proto.TestRecordProto.TestRecord;
+import com.android.tradefed.result.proto.TestRecordProto.TestStatus;
+import com.android.tradefed.util.proto.TestRecordProtoUtil;
+
+import com.google.common.base.Strings;
+import com.google.protobuf.Any;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A result reporter meant to report only the module level results. No re-entry is supported in this
+ * module. The intent of this reporter is primarily for caching at module level.
+ */
+public class ModuleProtoResultReporter extends FileProtoResultReporter {
+
+    public static final String INVOCATION_ID_KEY = "invocation_id";
+    private boolean mStopCache = false;
+    private String mInvocationId = null;
+
+    public ModuleProtoResultReporter() {
+        setPeriodicWriting(false);
+        setDelimitedOutput(false);
+    }
+
+    public ModuleProtoResultReporter(IInvocationContext mainInvocationContext) {
+        this();
+        copyAttributes(mainInvocationContext);
+    }
+
+    @Override
+    protected void beforeModuleStart() {
+        IInvocationContext stubContext = new InvocationContext();
+        if (mInvocationId != null) {
+            CLog.d("Copying property into module results: %s", mInvocationId);
+            stubContext.addInvocationAttribute(INVOCATION_ID_KEY, mInvocationId);
+        }
+        invocationStarted(stubContext);
+    }
+
+    @Override
+    protected void afterModuleEnd() {
+        invocationEnded(0);
+    }
+
+    @Override
+    public void processTestCaseEnded(TestRecord testCaseRecord) {
+        super.processTestCaseEnded(testCaseRecord);
+        if (testCaseRecord.getStatus().equals(TestStatus.FAIL)) {
+            mStopCache = true;
+        }
+    }
+
+    @Override
+    public void processTestRunEnded(TestRecord runRecord, boolean moduleInProgress) {
+        super.processTestRunEnded(runRecord, moduleInProgress);
+        if (runRecord.hasDebugInfo()) {
+            mStopCache = true;
+        }
+    }
+
+    @Override
+    public void processTestModuleEnd(TestRecord moduleRecord) {
+        super.processTestModuleEnd(moduleRecord);
+        if (moduleRecord.hasSkipReason()) {
+            mStopCache = true;
+        }
+    }
+
+    public boolean stopCaching() {
+        return mStopCache;
+    }
+
+    private void copyAttributes(IInvocationContext mainContext) {
+        String invocationId = mainContext.getAttribute(INVOCATION_ID_KEY);
+        if (!Strings.isNullOrEmpty(invocationId)) {
+            mInvocationId = invocationId;
+        }
+    }
+
+    /** Parsing util to extract metadata we might have transferred */
+    public static Map<String, String> parseResultsMetadata(File protoResults) {
+        if (protoResults == null) {
+            CLog.w("Proto result file is null, cannot parse it.");
+            return new HashMap<>();
+        }
+        try {
+            TestRecord record = TestRecordProtoUtil.readFromFile(protoResults, false);
+            Any anyDescription = record.getDescription();
+            if (!anyDescription.is(Context.class)) {
+                throw new RuntimeException("Expected Any description of type Context");
+            }
+            IInvocationContext receivedContext =
+                    InvocationContext.fromProto(anyDescription.unpack(Context.class));
+            Map<String, String> receivedAttributes = receivedContext.getAttributes().getUniqueMap();
+            CLog.d("Attributes received from cached results: %s", receivedAttributes);
+            return receivedAttributes;
+        } catch (IOException | RuntimeException e) {
+            CLog.e(e);
+        }
+        return new HashMap<>();
+    }
+}
diff --git a/src/com/android/tradefed/result/proto/ProtoResultParser.java b/src/com/android/tradefed/result/proto/ProtoResultParser.java
index cb9fcd67c..437ab94b6 100644
--- a/src/com/android/tradefed/result/proto/ProtoResultParser.java
+++ b/src/com/android/tradefed/result/proto/ProtoResultParser.java
@@ -290,7 +290,7 @@ public class ProtoResultParser {
     private void evalProto(TestRecord childProto, boolean isInRun) {
         if (isInRun) {
             // test case
-            String[] info = childProto.getTestRecordId().split("#");
+            String[] info = childProto.getTestRecordId().split("#", 2);
             TestDescription description = new TestDescription(info[0], info[1]);
             mListener.testStarted(description, timeStampToMillis(childProto.getStartTime()));
             handleTestCaseEnd(description, childProto);
diff --git a/src/com/android/tradefed/result/proto/ProtoResultReporter.java b/src/com/android/tradefed/result/proto/ProtoResultReporter.java
index e46c7c8ab..e24c64db6 100644
--- a/src/com/android/tradefed/result/proto/ProtoResultReporter.java
+++ b/src/com/android/tradefed/result/proto/ProtoResultReporter.java
@@ -256,6 +256,7 @@ public abstract class ProtoResultReporter
 
     @Override
     public final void testModuleStarted(IInvocationContext moduleContext) {
+        beforeModuleStart();
         if (mModuleInProgress) {
             // If we had a module in progress, and a new module start occurs, complete the call
             testModuleEnded();
@@ -301,6 +302,15 @@ public abstract class ProtoResultReporter
             CLog.e("Failed to process test module end:");
             CLog.e(e);
         }
+        afterModuleEnd();
+    }
+
+    protected void beforeModuleStart() {
+        // Empty on purpose
+    }
+
+    protected void afterModuleEnd() {
+        // Empty on purpose
     }
 
     // Run events
diff --git a/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java b/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java
index adc8ff2dd..ff68f3470 100644
--- a/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java
+++ b/src/com/android/tradefed/result/skipped/ArtifactsAnalyzer.java
@@ -14,14 +14,13 @@
  * limitations under the License.
  */
 package com.android.tradefed.result.skipped;
-
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.content.ContentAnalysisContext;
+import com.android.tradefed.build.content.ContentAnalysisContext.AnalysisMethod;
 import com.android.tradefed.build.content.ContentAnalysisResults;
 import com.android.tradefed.build.content.ImageContentAnalyzer;
 import com.android.tradefed.build.content.TestContentAnalyzer;
-import com.android.tradefed.build.content.ContentAnalysisContext.AnalysisMethod;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.NullDevice;
 import com.android.tradefed.invoker.TestInformation;
@@ -29,19 +28,22 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.testtype.suite.SuiteResultCacheUtil;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.SystemUtil;
 
+import build.bazel.remote.execution.v2.Digest;
+
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 
 /** A utility that helps analyze the build artifacts for insight. */
 public class ArtifactsAnalyzer {
-
     // A build attribute describing that the device image didn't change from base build
     public static final String DEVICE_IMAGE_NOT_CHANGED = "DEVICE_IMAGE_NOT_CHANGED";
-
     private final TestInformation information;
     private final MultiMap<ITestDevice, ContentAnalysisContext> mImageAnalysis;
     private final List<ContentAnalysisContext> mTestArtifactsAnalysisContent;
@@ -104,6 +106,9 @@ public class ArtifactsAnalyzer {
                     } else {
                         CLog.d("%s", analysisResults.toString());
                         finalReport.setChangesInTests(analysisResults.hasAnyTestsChange());
+                        if (!analysisResults.hasSharedFolderChanges()) {
+                            finalReport.addUnchangedModules(analysisResults.getUnchangedModules());
+                        }
                     }
                 } catch (RuntimeException e) {
                     CLog.e(e);
@@ -119,6 +124,7 @@ public class ArtifactsAnalyzer {
             Entry<ITestDevice, IBuildInfo> deviceBuild, List<ContentAnalysisContext> context) {
         ITestDevice device = deviceBuild.getKey();
         IBuildInfo build = deviceBuild.getValue();
+        Map<String, Digest> imageToDigest = new LinkedHashMap<>();
         boolean deviceImageChanged = true; // anchor toward changing
         if (device.getIDevice() != null
                 && device.getIDevice().getClass().isAssignableFrom(NullDevice.class)) {
@@ -142,7 +148,9 @@ public class ArtifactsAnalyzer {
                 ContentAnalysisResults res = analyze.evaluate();
                 if (res == null) {
                     deviceImageChanged = true;
+                    imageToDigest.put(SuiteResultCacheUtil.DEVICE_IMAGE_KEY, null);
                 } else {
+                    imageToDigest.putAll(res.getImageToDigest());
                     if (hasOneDeviceAnalysis) {
                         if (res.hasDeviceImageChanges()) {
                             CLog.d("Changes in device image.");
@@ -170,6 +178,7 @@ public class ArtifactsAnalyzer {
                 && build.getFile(BuildInfoFileKey.ROOT_DIRECTORY) == null) {
             hasTestsArtifacts = false;
         }
-        return new BuildAnalysis(deviceImageChanged, hasTestsArtifacts);
+        return new BuildAnalysis(deviceImageChanged, hasTestsArtifacts)
+                .addImageDigestMapping(imageToDigest);
     }
 }
diff --git a/src/com/android/tradefed/result/skipped/BuildAnalysis.java b/src/com/android/tradefed/result/skipped/BuildAnalysis.java
index 9ecafb4ba..266e99f01 100644
--- a/src/com/android/tradefed/result/skipped/BuildAnalysis.java
+++ b/src/com/android/tradefed/result/skipped/BuildAnalysis.java
@@ -15,35 +15,54 @@
  */
 package com.android.tradefed.result.skipped;
 
+import build.bazel.remote.execution.v2.Digest;
+
+import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 /** Represents the results of a single build analysis. */
 public class BuildAnalysis {
-
     private final boolean mDeviceImageChanged;
     private final boolean mHasTestsArtifacts;
     private boolean mHasChangesInTests = false;
+    private Set<String> mUnchangedModules = new HashSet<>();
+    private Map<String, Digest> mImageToDigest = new LinkedHashMap<>();
 
     public BuildAnalysis(boolean deviceImageChanged, boolean hasTestsArtifacts) {
         this.mDeviceImageChanged = deviceImageChanged;
         this.mHasTestsArtifacts = hasTestsArtifacts;
     }
-
     public boolean deviceImageChanged() {
         return mDeviceImageChanged;
     }
-
     public boolean hasTestsArtifacts() {
         return mHasTestsArtifacts;
     }
-
     public boolean hasChangesInTestsArtifacts() {
         return mHasChangesInTests;
     }
-
     public void setChangesInTests(boolean hasChanges) {
         mHasChangesInTests = hasChanges;
     }
+    public void addUnchangedModules(Set<String> unchangedModules) {
+        mUnchangedModules.addAll(unchangedModules);
+    }
+
+    public BuildAnalysis addImageDigestMapping(Map<String, Digest> imageToDigest) {
+        mImageToDigest.putAll(imageToDigest);
+        return this;
+    }
+
+    public Set<String> getUnchangedModules() {
+        return mUnchangedModules;
+    }
+
+    public Map<String, Digest> getImageToDigest() {
+        return mImageToDigest;
+    }
 
     @Override
     public String toString() {
@@ -53,17 +72,21 @@ public class BuildAnalysis {
                 + mHasTestsArtifacts
                 + ", mHasChangesInTests="
                 + mHasChangesInTests
+                + ", imageDigests="
+                + mImageToDigest
                 + "]";
     }
-
     public static BuildAnalysis mergeReports(List<BuildAnalysis> reports) {
         boolean deviceImageChanged = false;
         boolean hasTestsArtifacts = false;
+        Map<String, Digest> mergedImageToDigest = new LinkedHashMap<>();
         // Anchor toward things changing
         for (BuildAnalysis rep : reports) {
             deviceImageChanged |= rep.deviceImageChanged();
             hasTestsArtifacts |= rep.hasTestsArtifacts();
+            mergedImageToDigest.putAll(rep.getImageToDigest());
         }
-        return new BuildAnalysis(deviceImageChanged, hasTestsArtifacts);
+        return new BuildAnalysis(deviceImageChanged, hasTestsArtifacts)
+                .addImageDigestMapping(mergedImageToDigest);
     }
 }
diff --git a/src/com/android/tradefed/result/skipped/SkipContext.java b/src/com/android/tradefed/result/skipped/SkipContext.java
new file mode 100644
index 000000000..d5aadcb5c
--- /dev/null
+++ b/src/com/android/tradefed/result/skipped/SkipContext.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.skipped;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import java.util.Map;
+import java.util.Set;
+
+/** Representation of the context surrounding decision about skipping or caching of results. */
+public class SkipContext {
+
+    private final Set<String> unchangedModules;
+    private final boolean presubmit;
+    private final Map<String, Digest> imageToDigest;
+
+    public SkipContext(
+            boolean presubmit, Set<String> unchangedModules, Map<String, Digest> imageToDigest) {
+        this.presubmit = presubmit;
+        this.unchangedModules = unchangedModules;
+        this.imageToDigest = imageToDigest;
+    }
+
+    /**
+     * Only skip unchanged modules in presubmit. At this stage the unchanged modules are known
+     * (based on unchanged device image and test artifacts)
+     */
+    public boolean shouldSkipModule(String moduleName) {
+        return presubmit && unchangedModules.contains(moduleName);
+    }
+
+    /** Reports whether to use caching or not. */
+    public boolean shouldUseCache() {
+        return !presubmit; // For now, we only allow caching in postsubmit.
+    }
+
+    public Map<String, Digest> getImageToDigest() {
+        return imageToDigest;
+    }
+}
diff --git a/src/com/android/tradefed/result/skipped/SkipFeature.java b/src/com/android/tradefed/result/skipped/SkipFeature.java
new file mode 100644
index 000000000..240b64665
--- /dev/null
+++ b/src/com/android/tradefed/result/skipped/SkipFeature.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.skipped;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.service.IRemoteFeature;
+import com.android.tradefed.service.TradefedFeatureClient;
+import com.android.tradefed.testtype.ITestInformationReceiver;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Strings;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.proto.tradefed.feature.ErrorInfo;
+import com.proto.tradefed.feature.FeatureRequest;
+import com.proto.tradefed.feature.FeatureResponse;
+import com.proto.tradefed.feature.MultiPartResponse;
+import com.proto.tradefed.feature.PartResponse;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/** A feature allowing to access some of the {@link SkipManager} information. */
+public class SkipFeature
+        implements IRemoteFeature, IConfigurationReceiver, ITestInformationReceiver {
+    public static final String SKIP_FEATURE = "skipFeature";
+    public static final String SKIPPED_MODULES = "skipModules";
+    public static final String IMAGE_DIGESTS = "imageDigests";
+    public static final String PRESUBMIT = "presubmit";
+    public static final String DELIMITER_NAME = "delimiter";
+    private static final String DELIMITER = "+,";
+    private static final String ESCAPED_DELIMITER = "\\+,";
+    private IConfiguration mConfig;
+    private TestInformation mInfo;
+
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfig = configuration;
+    }
+
+    @Override
+    public void setTestInformation(TestInformation testInformation) {
+        mInfo = testInformation;
+    }
+
+    @Override
+    public TestInformation getTestInformation() {
+        return mInfo;
+    }
+
+    @Override
+    public String getName() {
+        return SKIP_FEATURE;
+    }
+
+    @Override
+    public FeatureResponse execute(FeatureRequest request) {
+        FeatureResponse.Builder responseBuilder = FeatureResponse.newBuilder();
+        if (mConfig != null) {
+            // Currently only support presubmit
+            boolean presubmit = "WORK_NODE".equals(mInfo.getContext().getAttribute("trigger"));
+            if (mConfig.getSkipManager().reportSkippedModule()) {
+                MultiPartResponse.Builder multiPartBuilder = MultiPartResponse.newBuilder();
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(DELIMITER_NAME)
+                                .setValue(ESCAPED_DELIMITER));
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(PRESUBMIT)
+                                .setValue(Boolean.toString(presubmit)));
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(SKIPPED_MODULES)
+                                .setValue(
+                                        Joiner.on(DELIMITER)
+                                                .join(
+                                                        mConfig.getSkipManager()
+                                                                .getUnchangedModules())));
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(IMAGE_DIGESTS)
+                                .setValue(
+                                        Joiner.on(DELIMITER)
+                                                .join(
+                                                        serializeDigest(
+                                                                mConfig.getSkipManager()
+                                                                        .getImageToDigest()))));
+                responseBuilder.setMultiPartResponse(multiPartBuilder);
+            } else {
+                responseBuilder.setErrorInfo(
+                        ErrorInfo.newBuilder().setErrorTrace("report-module-skipped is disabled."));
+            }
+        } else {
+            responseBuilder.setErrorInfo(
+                    ErrorInfo.newBuilder().setErrorTrace("Configuration not set."));
+        }
+        return responseBuilder.build();
+    }
+
+    /** Fetch and populate unchanged modules if needed. */
+    public static SkipContext getSkipContext() {
+        boolean isPresubmit = false;
+        Set<String> unchangedModulesSet = new HashSet<>();
+        Map<String, Digest> imageToDigestMap = new LinkedHashMap<String, Digest>();
+        try (TradefedFeatureClient client = new TradefedFeatureClient()) {
+            FeatureResponse unchangedModules =
+                    client.triggerFeature(SkipFeature.SKIP_FEATURE, new HashMap<String, String>());
+            if (unchangedModules.hasMultiPartResponse()) {
+                String delimiter = DELIMITER;
+                for (PartResponse rep :
+                        unchangedModules.getMultiPartResponse().getResponsePartList()) {
+                    if (rep.getKey().equals(DELIMITER_NAME)) {
+                        delimiter = rep.getValue().trim();
+                    }
+                }
+                for (PartResponse rep :
+                        unchangedModules.getMultiPartResponse().getResponsePartList()) {
+                    if (rep.getKey().equals(SKIPPED_MODULES)) {
+                        unchangedModulesSet.addAll(splitStringFilters(delimiter, rep.getValue()));
+                    } else if (rep.getKey().equals(PRESUBMIT)) {
+                        isPresubmit = Boolean.parseBoolean(rep.getValue());
+                    } else if (rep.getKey().equals(IMAGE_DIGESTS)) {
+                        imageToDigestMap = parseDigests(delimiter, rep.getValue());
+                    } else if (rep.getKey().equals(DELIMITER_NAME)) {
+                        // Ignore
+                    } else {
+                        CLog.w("Unexpected response key '%s' for unchanged modules", rep.getKey());
+                    }
+                }
+            } else {
+                CLog.w("Unexpected response for unchanged modules: %s", unchangedModules);
+            }
+        } catch (Exception e) {
+            CLog.e(e);
+        }
+        return new SkipContext(isPresubmit, unchangedModulesSet, imageToDigestMap);
+    }
+
+    private static List<String> splitStringFilters(String delimiter, String value) {
+        if (Strings.isNullOrEmpty(value)) {
+            return new ArrayList<String>();
+        }
+        return Arrays.asList(value.split(delimiter));
+    }
+
+    private static List<String> serializeDigest(Map<String, Digest> imageToDigest) {
+        List<String> serializedItems = new ArrayList<>();
+        for (Entry<String, Digest> entry : imageToDigest.entrySet()) {
+            if (entry.getValue() == null) {
+                serializedItems.add(String.format("%s=null=null", entry.getKey()));
+            } else {
+                serializedItems.add(
+                        String.format(
+                                "%s=%s=%s",
+                                entry.getKey(),
+                                entry.getValue().getHash(),
+                                entry.getValue().getSizeBytes()));
+            }
+        }
+        return serializedItems;
+    }
+
+    public static Map<String, Digest> parseDigests(String delimiter, String serializedString)
+            throws InvalidProtocolBufferException {
+        Map<String, Digest> imageToDigest = new LinkedHashMap<>();
+        if (Strings.isNullOrEmpty(serializedString)) {
+            return imageToDigest;
+        }
+        for (String sub : serializedString.split(delimiter)) {
+            String[] keyValue = sub.split("=");
+            if ("null".equals(keyValue[1])) {
+                imageToDigest.put(keyValue[0], null);
+            } else {
+                imageToDigest.put(
+                        keyValue[0],
+                        Digest.newBuilder()
+                                .setHash(keyValue[1])
+                                .setSizeBytes(Long.parseLong(keyValue[2]))
+                                .build());
+            }
+        }
+        return imageToDigest;
+    }
+}
diff --git a/src/com/android/tradefed/result/skipped/SkipManager.java b/src/com/android/tradefed/result/skipped/SkipManager.java
index 0f7ecc16e..373c63615 100644
--- a/src/com/android/tradefed/result/skipped/SkipManager.java
+++ b/src/com/android/tradefed/result/skipped/SkipManager.java
@@ -30,15 +30,19 @@ import com.android.tradefed.service.TradefedFeatureClient;
 import com.android.tradefed.util.IDisableable;
 import com.android.tradefed.util.MultiMap;
 
+import build.bazel.remote.execution.v2.Digest;
+
 import com.proto.tradefed.feature.FeatureResponse;
 import com.proto.tradefed.feature.PartResponse;
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 
 /**
  * Based on a variety of criteria the skip manager helps to decide what should be skipped at
@@ -80,6 +84,12 @@ public class SkipManager implements IDisableable {
     @Option(name = "analysis-level", description = "Alter assumptions level of the analysis.")
     private AnalysisHeuristic mAnalysisLevel = AnalysisHeuristic.REMOVE_EXEMPTION;
 
+    @Option(
+            name = "report-module-skipped",
+            description =
+                    "Report a placeholder skip when module are skipped as unchanged in presubmit.")
+    private boolean mReportModuleSkipped = true;
+
     // Contains the filter and reason for demotion
     private final Map<String, SkipReason> mDemotionFilters = new LinkedHashMap<>();
 
@@ -90,6 +100,8 @@ public class SkipManager implements IDisableable {
     private List<String> mDependencyFiles = new ArrayList<String>();
 
     private String mReasonForSkippingInvocation = "SkipManager decided to skip.";
+    private Set<String> mUnchangedModules = new HashSet<>();
+    private Map<String, Digest> mImageFileToDigest = new LinkedHashMap<>();
 
     /** Setup and initialize the skip manager. */
     public void setup(IConfiguration config, IInvocationContext context) {
@@ -110,6 +122,18 @@ public class SkipManager implements IDisableable {
         return mDemotionFilters;
     }
 
+    /**
+     * Returns the list of unchanged modules. Modules are only unchanged if device image is also
+     * unchanged.
+     */
+    public Set<String> getUnchangedModules() {
+        return mUnchangedModules;
+    }
+
+    public Map<String, Digest> getImageToDigest() {
+        return mImageFileToDigest;
+    }
+
     public void setImageAnalysis(ITestDevice device, ContentAnalysisContext analysisContext) {
         CLog.d(
                 "Received image artifact analysis '%s' for %s",
@@ -199,6 +223,7 @@ public class SkipManager implements IDisableable {
         if (results == null) {
             return false;
         }
+        mImageFileToDigest.putAll(results.getImageToDigest());
         boolean presubmit = "WORK_NODE".equals(information.getContext().getAttribute("trigger"));
         if (results.deviceImageChanged()) {
             return false;
@@ -206,6 +231,8 @@ public class SkipManager implements IDisableable {
         InvocationMetricLogger.addInvocationMetrics(
                 InvocationMetricKey.DEVICE_IMAGE_NOT_CHANGED, 1);
         if (results.hasTestsArtifacts()) {
+            // Keep track of the set or sub-set of modules that didn't change.
+            mUnchangedModules.addAll(results.getUnchangedModules());
             if (results.hasChangesInTestsArtifacts()) {
                 InvocationMetricLogger.addInvocationMetrics(
                         InvocationMetricKey.TEST_ARTIFACT_CHANGE_ONLY, 1);
@@ -282,4 +309,8 @@ public class SkipManager implements IDisableable {
     public String getInvocationSkipReason() {
         return mReasonForSkippingInvocation;
     }
+
+    public boolean reportSkippedModule() {
+        return mReportModuleSkipped;
+    }
 }
diff --git a/src/com/android/tradefed/result/suite/XmlSuiteResultFormatter.java b/src/com/android/tradefed/result/suite/XmlSuiteResultFormatter.java
index 4a57e3e47..bf4b8b727 100644
--- a/src/com/android/tradefed/result/suite/XmlSuiteResultFormatter.java
+++ b/src/com/android/tradefed/result/suite/XmlSuiteResultFormatter.java
@@ -145,6 +145,29 @@ public class XmlSuiteResultFormatter implements IFormatterGenerator {
         public String hostName;
     }
 
+    /** Sanitizes a string to escape the special characters. */
+    public static String sanitizeXmlContent(String s) {
+        return XmlEscapers.xmlContentEscaper().escape(s);
+    }
+
+    /** Truncates the full stack trace with maximum {@link STACK_TRACE_MAX_SIZE} characters. */
+    public static String truncateStackTrace(String fullStackTrace, String testCaseName) {
+        if (fullStackTrace == null) {
+            return null;
+        }
+        if (fullStackTrace.length() > STACK_TRACE_MAX_SIZE) {
+            CLog.i(
+                    "The stack trace for test case %s contains %d characters, and has been"
+                            + " truncated to %d characters in %s.",
+                    testCaseName,
+                    fullStackTrace.length(),
+                    STACK_TRACE_MAX_SIZE,
+                    TEST_RESULT_FILE_NAME);
+            return fullStackTrace.substring(0, STACK_TRACE_MAX_SIZE);
+        }
+        return fullStackTrace;
+    }
+
     /**
      * Allows to add some attributes to the <Result> tag via {@code serializer.attribute}.
      *
@@ -409,7 +432,7 @@ public class XmlSuiteResultFormatter implements IFormatterGenerator {
             }
             ErrorIdentifier errorIdentifier =
                     testResult.getValue().getFailure().getErrorIdentifier();
-            String truncatedStackTrace = getTruncatedStackTrace(fullStack, testResult.getKey());
+            String truncatedStackTrace = truncateStackTrace(fullStack, testResult.getKey());
             serializer.startTag(NS, FAILURE_TAG);
 
             serializer.attribute(NS, MESSAGE_ATTR, sanitizeXmlContent(message));
@@ -425,24 +448,6 @@ public class XmlSuiteResultFormatter implements IFormatterGenerator {
         }
     }
 
-    /** Truncates the full stack trace with maximum {@link STACK_TRACE_MAX_SIZE} characters. */
-    private static String getTruncatedStackTrace(String fullStackTrace, String testCaseName) {
-        if (fullStackTrace == null) {
-            return null;
-        }
-        if (fullStackTrace.length() > STACK_TRACE_MAX_SIZE) {
-            CLog.i(
-                    "The stack trace for test case %s contains %d characters, and has been"
-                            + " truncated to %d characters in %s.",
-                    testCaseName,
-                    fullStackTrace.length(),
-                    STACK_TRACE_MAX_SIZE,
-                    TEST_RESULT_FILE_NAME);
-            return fullStackTrace.substring(0, STACK_TRACE_MAX_SIZE);
-        }
-        return fullStackTrace;
-    }
-
     /** Add files captured on test failures. */
     private static void HandleLoggedFiles(
             XmlSerializer serializer, Entry<String, TestResult> testResult)
@@ -746,11 +751,6 @@ public class XmlSuiteResultFormatter implements IFormatterGenerator {
         return metrics;
     }
 
-    @VisibleForTesting
-    protected String sanitizeXmlContent(String s) {
-        return XmlEscapers.xmlContentEscaper().escape(s);
-    }
-
     private static String sanitizeAttributesKey(String attribute) {
         return attribute.replace(":", "_");
     }
diff --git a/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java b/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java
index 87a6e189c..26c5f1f45 100644
--- a/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java
+++ b/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.retry;
 
+import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.result.ILogSaver;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.LogSaverResultForwarder;
@@ -25,10 +26,11 @@ import java.util.List;
 public class RetryLogSaverResultForwarder extends LogSaverResultForwarder {
 
     private int mAttemptNumber = 0;
+    private IConfiguration mConfig;
 
     public RetryLogSaverResultForwarder(
-            ILogSaver logSaver, List<ITestInvocationListener> listeners) {
-        super(logSaver, listeners);
+            ILogSaver logSaver, List<ITestInvocationListener> listeners, IConfiguration config) {
+        super(logSaver, listeners, config);
     }
 
     @Override
diff --git a/src/com/android/tradefed/sandbox/SandboxConfigDump.java b/src/com/android/tradefed/sandbox/SandboxConfigDump.java
index d5fcb48ab..c7a980241 100644
--- a/src/com/android/tradefed/sandbox/SandboxConfigDump.java
+++ b/src/com/android/tradefed/sandbox/SandboxConfigDump.java
@@ -15,7 +15,6 @@
  */
 package com.android.tradefed.sandbox;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.StubBuildProvider;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
@@ -26,6 +25,7 @@ import com.android.tradefed.config.SandboxConfigurationFactory;
 import com.android.tradefed.device.IDeviceSelection;
 import com.android.tradefed.log.FileLogger;
 import com.android.tradefed.log.ILeveledLogOutput;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.result.FileSystemLogSaver;
 import com.android.tradefed.result.ILogSaver;
 import com.android.tradefed.result.ITestInvocationListener;
@@ -219,7 +219,7 @@ public class SandboxConfigDump {
             if (m.matches() && m.groupCount() > 0) {
                 String key = m.group(2);
                 String keyValue = keyClient.fetchKey(key);
-                String newValue = argList.get(i).replaceAll("USE_KEYSTORE@" + key, keyValue);
+                String newValue = argList.get(i).replace("USE_KEYSTORE@" + key, keyValue);
                 argList.set(i, newValue);
             }
         }
diff --git a/src/com/android/tradefed/sandbox/SandboxOptions.java b/src/com/android/tradefed/sandbox/SandboxOptions.java
index c91717a25..85ef985db 100644
--- a/src/com/android/tradefed/sandbox/SandboxOptions.java
+++ b/src/com/android/tradefed/sandbox/SandboxOptions.java
@@ -96,7 +96,7 @@ public final class SandboxOptions {
                 "The time we should wait for all events to complete after the "
                         + "sandbox is done running."
     )
-    private long mWaitForEventsTimeoutMs = 30000L;
+    private long mWaitForEventsTimeoutMs = 60000L;
 
     @Option(
             name = ENABLE_DEBUG_THREAD,
diff --git a/src/com/android/tradefed/service/TradefedFeatureServer.java b/src/com/android/tradefed/service/TradefedFeatureServer.java
index d824e6203..6e4e94311 100644
--- a/src/com/android/tradefed/service/TradefedFeatureServer.java
+++ b/src/com/android/tradefed/service/TradefedFeatureServer.java
@@ -24,6 +24,7 @@ import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.invoker.tracing.TracingLogger;
+import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.service.internal.IRemoteScheduledListenersFeature;
 import com.android.tradefed.testtype.ITestInformationReceiver;
@@ -35,6 +36,10 @@ import com.proto.tradefed.feature.FeatureRequest;
 import com.proto.tradefed.feature.FeatureResponse;
 import com.proto.tradefed.feature.TradefedInformationGrpc.TradefedInformationImplBase;
 
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.stub.StreamObserver;
+
 import java.io.IOException;
 import java.util.List;
 import java.util.Map;
@@ -42,10 +47,6 @@ import java.util.ServiceLoader;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 
-import io.grpc.Server;
-import io.grpc.ServerBuilder;
-import io.grpc.stub.StreamObserver;
-
 /** A server that responds to requests for triggering features. */
 public class TradefedFeatureServer extends TradefedInformationImplBase {
 
@@ -158,6 +159,7 @@ public class TradefedFeatureServer extends TradefedInformationImplBase {
                 CurrentInvocation.setLocalGroup(mRegisteredGroup.get(request.getReferenceId()));
                 InvocationMetricLogger.setLocalGroup(
                         mRegisteredGroup.get(request.getReferenceId()));
+                LogRegistry.setLocalGroup(mRegisteredGroup.get(request.getReferenceId()));
                 if (feature instanceof IConfigurationReceiver) {
                     ((IConfigurationReceiver) feature)
                             .setConfiguration(mRegisteredInvocation.get(request.getReferenceId()));
@@ -184,6 +186,7 @@ public class TradefedFeatureServer extends TradefedInformationImplBase {
                                 TracingLogger.getActiveTraceForGroup(
                                         mRegisteredGroup.get(request.getReferenceId())),
                                 feature.getName())) {
+                    CLog.d("Executing %s with [%s]", feature, request);
                     FeatureResponse rep = feature.execute(request);
                     if (rep == null) {
                         return FeatureResponse.newBuilder()
@@ -204,6 +207,7 @@ public class TradefedFeatureServer extends TradefedInformationImplBase {
                     TracingLogger.resetLocalGroup();
                     InvocationMetricLogger.resetLocalGroup();
                     CurrentInvocation.resetLocalGroup();
+                    LogRegistry.resetLocalGroup();
                 }
             }
         }
diff --git a/src/com/android/tradefed/service/management/DeviceManagementGrpcServer.java b/src/com/android/tradefed/service/management/DeviceManagementGrpcServer.java
index 46bc13a1d..88c4769f3 100644
--- a/src/com/android/tradefed/service/management/DeviceManagementGrpcServer.java
+++ b/src/com/android/tradefed/service/management/DeviceManagementGrpcServer.java
@@ -1,9 +1,13 @@
 package com.android.tradefed.service.management;
 
 import com.android.annotations.VisibleForTesting;
+import com.android.tradefed.cluster.ClusterHostUtil;
+import com.android.tradefed.cluster.ClusterOptions;
+import com.android.tradefed.cluster.IClusterOptions;
 import com.android.tradefed.command.CommandScheduler;
 import com.android.tradefed.command.ICommandScheduler;
 import com.android.tradefed.command.remote.DeviceDescriptor;
+import com.android.tradefed.config.GlobalConfiguration;
 import com.android.tradefed.device.DeviceAllocationState;
 import com.android.tradefed.device.DeviceSelectionOptions;
 import com.android.tradefed.device.FreeDeviceState;
@@ -25,17 +29,17 @@ import com.proto.tradefed.device.ReserveDeviceResponse.Result;
 import com.proto.tradefed.device.StopLeasingRequest;
 import com.proto.tradefed.device.StopLeasingResponse;
 
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.stub.ServerCallStreamObserver;
+import io.grpc.stub.StreamObserver;
+
 import java.io.IOException;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 
-import io.grpc.Server;
-import io.grpc.ServerBuilder;
-import io.grpc.stub.ServerCallStreamObserver;
-import io.grpc.stub.StreamObserver;
-
 /** GRPC server allowing to reserve a device from Tradefed. */
 public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
     private static final String TF_DEVICE_MANAGEMENT_PORT = "TF_DEVICE_MANAGEMENT_PORT";
@@ -45,6 +49,8 @@ public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
     private final ICommandScheduler mCommandScheduler;
     private final Map<String, ReservationInformation> mSerialToReservation =
             new ConcurrentHashMap<>();
+    private String mRunTargetFormat = null;
+    private Map<String, String> mDeviceTags = null;
 
     /** Returns the port used by the server. */
     public static Integer getPort() {
@@ -53,6 +59,17 @@ public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
                 : null;
     }
 
+    private void initRunTargetInfo() {
+        final IClusterOptions clusterOptions =
+                (IClusterOptions)
+                        GlobalConfiguration.getInstance()
+                                .getConfigurationObject(ClusterOptions.TYPE_NAME);
+        if (clusterOptions != null) {
+            mRunTargetFormat = clusterOptions.getRunTargetFormat();
+            mDeviceTags = clusterOptions.getDeviceTag();
+        }
+    }
+
     public DeviceManagementGrpcServer(
             int port, IDeviceManager deviceManager, ICommandScheduler scheduler) {
         this(ServerBuilder.forPort(port), deviceManager, scheduler);
@@ -66,6 +83,7 @@ public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
         mServer = serverBuilder.addService(this).build();
         mDeviceManager = deviceManager;
         mCommandScheduler = scheduler;
+        initRunTargetInfo();
     }
 
     @VisibleForTesting
@@ -74,6 +92,7 @@ public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
         mServer = server;
         mDeviceManager = deviceManager;
         mCommandScheduler = scheduler;
+        initRunTargetInfo();
     }
 
     /** Start the grpc server. */
@@ -101,7 +120,8 @@ public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
             StreamObserver<GetDevicesStatusResponse> responseObserver) {
         GetDevicesStatusResponse.Builder responseBuilder = GetDevicesStatusResponse.newBuilder();
         if (request.getDeviceIdList().isEmpty()) {
-            for (DeviceDescriptor descriptor : mDeviceManager.listAllDevices(true)) {
+            // query device manager for full device descriptor to ensure we get all device props
+            for (DeviceDescriptor descriptor : mDeviceManager.listAllDevices(false)) {
                 responseBuilder.addDeviceStatus(descriptorToStatus(descriptor));
             }
         } else {
@@ -261,6 +281,8 @@ public class DeviceManagementGrpcServer extends DeviceManagementImplBase {
     private DeviceStatus descriptorToStatus(DeviceDescriptor descriptor) {
         DeviceStatus.Builder deviceStatusBuilder = DeviceStatus.newBuilder();
         deviceStatusBuilder.setDeviceId(descriptor.getSerial());
+        deviceStatusBuilder.setRunTarget(
+                ClusterHostUtil.getRunTarget(descriptor, mRunTargetFormat, mDeviceTags));
         deviceStatusBuilder.setReservationStatus(
                 allocationStateToReservation(descriptor.getState(), descriptor.getSerial()));
         return deviceStatusBuilder.build();
diff --git a/src/com/android/tradefed/suite/checker/baseline/CommandBaselineSetter.java b/src/com/android/tradefed/suite/checker/baseline/CommandBaselineSetter.java
index 4ef3a370a..50f174fd6 100644
--- a/src/com/android/tradefed/suite/checker/baseline/CommandBaselineSetter.java
+++ b/src/com/android/tradefed/suite/checker/baseline/CommandBaselineSetter.java
@@ -18,6 +18,7 @@ package com.android.tradefed.suite.checker.baseline;
 
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 
@@ -37,6 +38,10 @@ public class CommandBaselineSetter extends DeviceBaselineSetter {
     @Override
     public boolean setBaseline(ITestDevice mDevice) throws DeviceNotAvailableException {
         CommandResult result = mDevice.executeShellV2Command(mCommand);
-        return result != null && CommandStatus.SUCCESS.equals(result.getStatus());
+        if (CommandStatus.SUCCESS.equals(result.getStatus())) {
+            CLog.d("%s returns %s", mCommand, result.getStdout());
+            return true;
+        }
+        return false;
     }
 }
diff --git a/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java b/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java
index 65623e2c3..f0dba8629 100644
--- a/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java
+++ b/src/com/android/tradefed/suite/checker/baseline/LockSettingsBaselineSetter.java
@@ -18,6 +18,8 @@ package com.android.tradefed.suite.checker.baseline;
 
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
 
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -32,6 +34,7 @@ public class LockSettingsBaselineSetter extends DeviceBaselineSetter {
     private static final String GET_LOCK_SCREEN_COMMAND = "locksettings get-disabled";
     private static final String LOCK_SCREEN_OFF_COMMAND = "locksettings set-disabled true";
     private static final String CLEAR_PWD_COMMAND = "locksettings clear --old %s";
+    private static final String KEYCODE_MENU_COMMAND = "input keyevent KEYCODE_MENU";
 
     public LockSettingsBaselineSetter(JSONObject object, String name) throws JSONException {
         super(object, name);
@@ -45,15 +48,25 @@ public class LockSettingsBaselineSetter extends DeviceBaselineSetter {
 
     @Override
     public boolean setBaseline(ITestDevice mDevice) throws DeviceNotAvailableException {
-        if ("true".equals(mDevice.executeShellCommand(GET_LOCK_SCREEN_COMMAND).trim())) {
-            return true;
+        if (!isLockScreenDisabled(mDevice)) {
+            // Clear old passwords.
+            for (String command : mClearPwdCommands) {
+                mDevice.executeShellV2Command(command);
+            }
+            // Turn off lock-screen option.
+            mDevice.executeShellV2Command(LOCK_SCREEN_OFF_COMMAND);
         }
-        // Clear old passwords.
-        for (String command : mClearPwdCommands) {
-            mDevice.executeShellCommand(command);
+        if (!isLockScreenDisabled(mDevice)) {
+            return false;
         }
-        // Turn off lock-screen option.
-        mDevice.executeShellCommand(LOCK_SCREEN_OFF_COMMAND);
-        return "true".equals(mDevice.executeShellCommand(GET_LOCK_SCREEN_COMMAND).trim());
+        CommandResult result = mDevice.executeShellV2Command(KEYCODE_MENU_COMMAND);
+        return CommandStatus.SUCCESS.equals(result.getStatus());
+    }
+
+    private boolean isLockScreenDisabled(ITestDevice mDevice) throws DeviceNotAvailableException {
+        CommandResult result = mDevice.executeShellV2Command(GET_LOCK_SCREEN_COMMAND);
+        return CommandStatus.SUCCESS.equals(result.getStatus())
+                && result.getStdout() != null
+                && "true".equals(result.getStdout().trim());
     }
 }
diff --git a/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java b/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
index c873e4db4..afe159b14 100644
--- a/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
+++ b/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
@@ -47,6 +47,7 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.image.DeviceImageTracker;
 import com.android.tradefed.util.image.IncrementalImageUtil;
@@ -165,6 +166,13 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
             description = "Allow doing incremental update across release build configs.")
     private boolean mAllowIncrementalCrossRelease = false;
 
+    @Option(
+            name = "ignore-incremental-host-options",
+            description =
+                    "Ignore the HostOptions to disable incremental flashing. This can be useful for"
+                            + " boot tests in various environments.")
+    private boolean mIgnoreHostOptions = false;
+
     @Option(
             name = "apply-snapshot",
             description =
@@ -172,6 +180,16 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                             + "This changes the baseline and does require reverting.")
     private boolean mApplySnapshot = false;
 
+    @Option(
+            name = "wipe-after-apply-snapshot",
+            description = "Whether to issue a wipe after applying snapshots.")
+    private boolean mWipeAfterApplySnapshot = false;
+
+    @Option(
+            name = "use-new-incremental-update-flow",
+            description = "A new update flow possible with latest incremental features.")
+    private boolean mNewIncrementalFlow = false;
+
     @Option(
             name = "snapuserd-wait-phase",
             description =
@@ -190,6 +208,7 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
 
     private IncrementalImageUtil mIncrementalImageUtil;
     private IConfiguration mConfig;
+    private MultiMap<String, String> mAllowedBranchTransition = new MultiMap<>();
 
     @Override
     public void setConfiguration(IConfiguration configuration) {
@@ -282,11 +301,13 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
         long flashingTime = -1;
         long start = -1;
         // HostOptions can force the incremental flashing to true.
-        if (getHostOptions().isIncrementalFlashingEnabled()) {
-            mUseIncrementalFlashing = true;
-        }
-        if (getHostOptions().isOptOutOfIncrementalFlashing()) {
-            mUseIncrementalFlashing = false;
+        if (!mIgnoreHostOptions) {
+            if (getHostOptions().isIncrementalFlashingEnabled()) {
+                mUseIncrementalFlashing = true;
+            }
+            if (getHostOptions().isOptOutOfIncrementalFlashing()) {
+                mUseIncrementalFlashing = false;
+            }
         }
         if (mConfig != null) {
             for (IDeviceConfiguration deviceConfig : mConfig.getDeviceConfig()) {
@@ -330,7 +351,10 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                                 mCreateSnapshotBinary,
                                 isIsolated,
                                 mAllowIncrementalCrossRelease,
+                                mAllowedBranchTransition,
                                 mApplySnapshot,
+                                mWipeAfterApplySnapshot,
+                                mNewIncrementalFlow,
                                 mWaitPhase);
                 if (mIncrementalImageUtil == null) {
                     useIncrementalFlashing = false;
@@ -559,8 +583,14 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
         // could be an AppBuildInfo and return app build id. Need to be more explicit that we
         // check for the device build here.
         if (!mSkipPostFlashBuildIdCheck) {
-            checkBuildAttribute(deviceBuild.getDeviceBuildId(), device.getBuildId(),
-                    device.getSerialNumber());
+            String dbid = deviceBuild.getDeviceBuildId();
+            if (IDeviceBuildInfo.UNKNOWN_BUILD_ID.equals(dbid)) {
+                // if the device build isn't set, use the build id instead
+                // this happens when device image download is skipped, which could happen when
+                // other kinds of build artifact is used instead for "flashing", e.g. OTA package
+                dbid = deviceBuild.getBuildId();
+            }
+            checkBuildAttribute(dbid, device.getBuildId(), device.getSerialNumber());
         }
     }
 
@@ -662,7 +692,19 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
         mApplySnapshot = applySnapshot;
     }
 
+    public void setWipeAfterApplySnapshot(boolean wipeAfterApplySnapshot) {
+        mWipeAfterApplySnapshot = wipeAfterApplySnapshot;
+    }
+
     public void setAllowUnzipBaseline(boolean allowUnzipBaseline) {
         mAllowUnzippedBaseline = allowUnzipBaseline;
     }
+
+    public void setIgnoreHostOptions(boolean ignoreHostOptions) {
+        mIgnoreHostOptions = ignoreHostOptions;
+    }
+
+    public void addBranchTransitionInIncremental(String origin, String destination) {
+        mAllowedBranchTransition.put(origin, destination);
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/DeviceSetup.java b/src/com/android/tradefed/targetprep/DeviceSetup.java
index ed90627b6..9b997d27c 100644
--- a/src/com/android/tradefed/targetprep/DeviceSetup.java
+++ b/src/com/android/tradefed/targetprep/DeviceSetup.java
@@ -16,6 +16,8 @@
 
 package com.android.tradefed.targetprep;
 
+import static com.android.tradefed.targetprep.VisibleBackgroundUserPreparer.INVALID_DISPLAY;
+
 import com.android.ddmlib.IDevice;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
@@ -415,6 +417,13 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
             description = "Feature to evaluate a faster non-persistent props setup.")
     private boolean mOptimizeNonPersistentSetup = true;
 
+    @Option(
+            name = "delay-reboot",
+            description =
+                    "Should reboot be needed in the setup, delay it because we know it will occur"
+                            + " later.")
+    private boolean mDelayReboot = false;
+
     @Option(
             name = "dismiss-setup-wizard",
             description = "Attempt to dismiss the setup wizard if present.")
@@ -430,6 +439,11 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
             description = "Number of times to retry to dismiss setup wizard.")
     private int mDismissSetupWizardRetry = 2;
 
+    @Option(
+            name = "check-launcher-package-name",
+            description = "Check the launcher package name to verify setup wizard is dismissed.")
+    private boolean mCheckLauncherPackageName = true;
+
     private Map<String, String> mPreviousSystemSettings = new HashMap<>();
     private Map<String, String> mPreviousSecureSettings = new HashMap<>();
     private Map<String, String> mPreviousGlobalSettings = new HashMap<>();
@@ -518,6 +532,13 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
     private static final String PERSIST_PREFIX = "persist.";
     private static final String MEMTAG_BOOTCTL = "arm64.memtag.bootctl";
 
+    @Option(
+            name = "enable-testing-secondary-user-on-secondary-display",
+            description = "Enable testing secondary user on secondary display")
+    private boolean mEnableTestingSecondaryUserOnSecondaryDisplay = false;
+
+    private int mTestRunningDisplayId;
+
     private static final List<String> PROPERTIES_NEEDING_REBOOT =
             List.of(
                     // MEMTAG_BOOTCTL stores a value in the misc partition that gets applied on
@@ -538,6 +559,25 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
         ITestDevice device = getDevice(testInfo);
         CLog.i("Performing setup on %s", device.getSerialNumber());
 
+        mTestRunningDisplayId = INVALID_DISPLAY;
+        // When testing with a visible background user,
+        // it is necessary to use the displayId being tested.
+        if (mEnableTestingSecondaryUserOnSecondaryDisplay
+                && device.isVisibleBackgroundUsersSupported()) {
+            int testRunningUserId = UserHelper.getRunTestsAsUser(testInfo);
+            CommandResult displayIdByUser = device.executeShellV2Command(
+                    "cmd car_service get-display-by-user " + testRunningUserId);
+            if (CommandStatus.SUCCESS.equals(displayIdByUser.getStatus())
+                    && !Strings.isNullOrEmpty(displayIdByUser.getStdout())) {
+                try {
+                    mTestRunningDisplayId = Integer.parseInt(displayIdByUser.getStdout().trim());
+                    CLog.d("Running test on displayId: %d", mTestRunningDisplayId);
+                } catch (Exception e) {
+                    CLog.e("Failed to parse the displayId due to " + e);
+                }
+            }
+        }
+
         if (mForceRoot && device.getOptions().isEnableAdbRoot()) {
             if (!device.enableAdbRoot()) {
                 throw new TargetSetupError(
@@ -1015,8 +1055,12 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
         }
 
         if (needsReboot) {
-            CLog.i("Rebooting %s due to system property change", device.getSerialNumber());
-            device.reboot();
+            if (mDelayReboot) {
+                CLog.i("Delay the reboot to later in the setup.");
+            } else {
+                CLog.i("Rebooting %s due to system property change", device.getSerialNumber());
+                device.reboot();
+            }
         }
 
         // Log nonpersistent device properties (that change/lose values after reboot).
@@ -1038,6 +1082,14 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
         }
     }
 
+    private String getInputKeyEventCommand(int keycode) {
+        String inputKeyEventCommand = "input keyevent " + keycode;
+        if (mTestRunningDisplayId != INVALID_DISPLAY) {
+            inputKeyEventCommand = "input -d " + mTestRunningDisplayId + " keyevent " + keycode;
+        }
+        return inputKeyEventCommand;
+    }
+
     /**
      * Handles screen always on settings.
      * <p>
@@ -1063,7 +1115,8 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
                         CLog.d("Output of dismiss-keyguard: %s", res);
                     } else {
                         // send MENU press in case keyguard needs to be dismissed again
-                        CommandResult inputKey = device.executeShellV2Command("input keyevent 82");
+                        CommandResult inputKey =
+                                device.executeShellV2Command(getInputKeyEventCommand(82));
                         CLog.d("Output of input keyevent 82: %s", inputKey);
                     }
                     // send HOME press in case keyguard was already dismissed, so we bring device
@@ -1073,7 +1126,8 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
                     // instead of the home screen
                     if ((device instanceof TestDevice)
                             && !device.hasFeature("android.hardware.type.watch")) {
-                        CommandResult inputKey = device.executeShellV2Command("input keyevent 3");
+                        CommandResult inputKey =
+                                device.executeShellV2Command(getInputKeyEventCommand(3));
                         CLog.d("Output of input keyevent 3: %s", inputKey);
                     }
                     break;
@@ -1322,16 +1376,41 @@ public class DeviceSetup extends BaseTargetPreparer implements IExternalDependen
         boolean dismissed = false;
         long startTime = System.currentTimeMillis();
         while (System.currentTimeMillis() - startTime < mDismissSetupWizardTimeout) {
-            CommandResult cmdOut =
+            // check the current focus
+            CommandResult dumpsysCmdOut =
                     device.executeShellV2Command("dumpsys window displays | grep mCurrentFocus");
-            if (CommandStatus.SUCCESS.equals(cmdOut.getStatus())
-                    && !cmdOut.getStdout().contains("setupwizard")) {
-                CLog.d("Setup wizard is dismissed.");
-                dismissed = true;
-                break;
+            if (CommandStatus.SUCCESS.equals(dumpsysCmdOut.getStatus())
+                    && !dumpsysCmdOut.getStdout().contains("setupwizard")) {
+                if (mCheckLauncherPackageName) {
+                    // Additionally check the launcher package name
+                    CommandResult pkgCmdOut =
+                            device.executeShellV2Command(
+                                    "cmd package resolve-activity"
+                                            + " -c android.intent.category.HOME"
+                                            + " -a android.intent.action.MAIN");
+                    if (CommandStatus.SUCCESS.equals(pkgCmdOut.getStatus())
+                            && !pkgCmdOut
+                                    .getStdout()
+                                    .contains("packageName=com.google.android.setupwizard")) {
+                        CLog.d("Setup wizard is dismissed.");
+                        dismissed = true;
+                        break;
+                    } else {
+                        // Log the package cmd output for debugging purpose
+                        CLog.d("Package cmd output: %s", pkgCmdOut.getStdout());
+                        CLog.d("Package cmd stderr: %s", pkgCmdOut.getStderr());
+                    }
+                } else {
+                    CLog.d("Setup wizard is dismissed.");
+                    dismissed = true;
+                    break;
+                }
             } else {
-                RunUtil.getDefault().sleep(2 * 1000);
+                // Log the dumpsys cmd output for debugging purpose
+                CLog.d("Dumpsys cmd output: %s", dumpsysCmdOut.getStdout());
+                CLog.d("Dumpsys cmd stderr: %s", dumpsysCmdOut.getStderr());
             }
+            RunUtil.getDefault().sleep(2 * 1000);
         }
         if (!dismissed) {
             CLog.w(
diff --git a/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java b/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
index d5332461e..5e44c14ba 100644
--- a/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
@@ -192,25 +192,43 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         if (TestDeviceState.ONLINE.equals(device.getDeviceState())) {
             setSystemBuildInfo(device.getBuildId(), device.getBuildFlavor());
         }
-
-        if (!initialStateFastbootD) {
-            device.rebootIntoBootloader();
-        }
-
         downloadFlashingResources(device, deviceBuild);
-        preFlashSetup(device, deviceBuild);
         if (device instanceof IManagedTestDevice) {
             String fastbootVersion = ((IManagedTestDevice) device).getFastbootVersion();
             if (fastbootVersion != null) {
                 deviceBuild.addBuildAttribute(FASTBOOT_VERSION, fastbootVersion);
             }
         }
+
+        if (mIncrementalFlashing != null && mIncrementalFlashing.useUpdatedFlow()) {
+            try {
+                mIncrementalFlashing.updateDeviceWithNewFlow(
+                        deviceBuild.getBootloaderImageFile(), deviceBuild.getBasebandImageFile());
+            } catch (TargetSetupError e) {
+                mIncrementalFlashing = null;
+                // In case of TargetSetupError for incremental flashing,
+                // fallback to full flashing.
+                CLog.e(e);
+                DeviceImageTracker.getDefaultCache().invalidateTracking(device.getSerialNumber());
+                if (TestDeviceState.ONLINE.equals(device.getDeviceState())) {
+                    device.rebootIntoBootloader();
+                }
+            }
+        } else {
+            if (!initialStateFastbootD) {
+                device.rebootIntoBootloader();
+            }
+        }
+        preFlashSetup(device, deviceBuild);
     }
 
     /** {@inheritDoc} */
     @Override
     public void flash(ITestDevice device, IDeviceBuildInfo deviceBuild)
             throws TargetSetupError, DeviceNotAvailableException {
+        if (mIncrementalFlashing != null && mIncrementalFlashing.updateCompleted()) {
+            return;
+        }
         handleUserDataFlashing(device, deviceBuild);
         checkAndFlashBootloader(device, deviceBuild);
         checkAndFlashBaseband(device, deviceBuild);
@@ -944,6 +962,11 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         }
     }
 
+    protected String getImageVersion(ITestDevice device, String imageName)
+            throws DeviceNotAvailableException, TargetSetupError {
+        return fetchImageVersion(getRunUtil(), device, imageName);
+    }
+
     /**
      * Helper method to get the current image version on device.
      *
@@ -953,7 +976,7 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
      * @throws DeviceNotAvailableException if device is not available
      * @throws TargetSetupError if fastboot command fails or version could not be determined
      */
-    protected String getImageVersion(ITestDevice device, String imageName)
+    public static String fetchImageVersion(IRunUtil runUtil, ITestDevice device, String imageName)
             throws DeviceNotAvailableException, TargetSetupError {
         int attempts = 0;
         String versionQuery = String.format("version-%s", imageName);
@@ -961,7 +984,10 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         Pattern versionOutputPattern = Pattern.compile(patternString);
 
         while (attempts < MAX_RETRY_ATTEMPTS) {
-            String queryOutput = executeFastbootCmd(device, "getvar", versionQuery);
+            CLog.v("Executing short fastboot command 'getvar %s'", versionQuery);
+            CommandResult result = device.executeFastbootCommand("getvar", versionQuery);
+            String queryOutput =
+                    internalHandleFastbootResult(device, result, "getvar", versionQuery);
             Matcher matcher = versionOutputPattern.matcher(queryOutput);
             if (matcher.find()) {
                 return matcher.group(1);
@@ -970,8 +996,9 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
                 CLog.w(
                         "Could not find version for '%s'. Output '%s', retrying.",
                         imageName, queryOutput);
-                getRunUtil().sleep(RETRY_SLEEP * (attempts - 1)
-                        + new Random(System.currentTimeMillis()).nextInt(RETRY_SLEEP));
+                runUtil.sleep(
+                        RETRY_SLEEP * (attempts - 1)
+                                + new Random(System.currentTimeMillis()).nextInt(RETRY_SLEEP));
                 continue;
             }
         }
@@ -1084,15 +1111,27 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     @VisibleForTesting
     String handleFastbootResult(ITestDevice device, CommandResult result, String... cmdArgs)
             throws TargetSetupError {
+        try {
+            String res = internalHandleFastbootResult(device, result, cmdArgs);
+            mFbCmdStatus = CommandStatus.SUCCESS;
+            return res;
+        } catch (TargetSetupError e) {
+            mFbCmdStatus = CommandStatus.FAILED;
+            throw e;
+        }
+    }
+
+    private static String internalHandleFastbootResult(
+            ITestDevice device, CommandResult result, String... cmdArgs) throws TargetSetupError {
         CLog.v("fastboot stdout: " + result.getStdout());
         CLog.v("fastboot stderr: " + result.getStderr());
-        mFbCmdStatus = result.getStatus();
+        CommandStatus status = result.getStatus();
         ErrorIdentifier errorIdentifier = null;
         boolean diskErrorIdentified = false;
         for (String diskError : DISK_SPACE_ERRORS) {
             if (result.getStderr().contains(diskError)) {
                 errorIdentifier = InfraErrorIdentifier.NO_DISK_SPACE;
-                mFbCmdStatus = CommandStatus.FAILED;
+                status = CommandStatus.FAILED;
                 diskErrorIdentified = true;
                 break;
             }
@@ -1100,9 +1139,9 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
 
         if (!diskErrorIdentified && result.getStderr().contains("FAILED")) {
             // if output contains "FAILED", just override to failure
-            mFbCmdStatus = CommandStatus.FAILED;
+            status = CommandStatus.FAILED;
         }
-        if (mFbCmdStatus != CommandStatus.SUCCESS) {
+        if (status != CommandStatus.SUCCESS) {
             if (errorIdentifier == null) {
                 errorIdentifier = DeviceErrorIdentifier.ERROR_AFTER_FLASHING;
             }
diff --git a/src/com/android/tradefed/targetprep/FlashingMethod.java b/src/com/android/tradefed/targetprep/FlashingMethod.java
index 5681eb8c9..726fcc9c6 100644
--- a/src/com/android/tradefed/targetprep/FlashingMethod.java
+++ b/src/com/android/tradefed/targetprep/FlashingMethod.java
@@ -47,5 +47,8 @@ public enum FlashingMethod {
     /**
      * The device was flashed via a `fastboot flashall` command on a directory of partition images
      */
-    FASTBOOT_FLASH_ALL
+    FASTBOOT_FLASH_ALL,
+
+    /** The device was flashed via a simulated OTA while in userspace */
+    USERSPACE_OTA
 }
diff --git a/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java b/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java
index 924fbaf6d..7524baa27 100644
--- a/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java
+++ b/src/com/android/tradefed/targetprep/GkiDeviceFlashPreparer.java
@@ -22,8 +22,8 @@ import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.DeviceUnresponsiveException;
 import com.android.tradefed.device.ITestDevice;
-import com.android.tradefed.device.SnapuserdWaitPhase;
 import com.android.tradefed.device.ITestDevice.RecoveryMode;
+import com.android.tradefed.device.SnapuserdWaitPhase;
 import com.android.tradefed.device.TestDeviceState;
 import com.android.tradefed.host.IHostOptions;
 import com.android.tradefed.host.IHostOptions.PermitLimitType;
@@ -53,10 +53,14 @@ import java.io.PrintWriter;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Enumeration;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
@@ -93,6 +97,11 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
             description = "The file name in BuildInfo that provides ramdisk image.")
     private String mRamdiskImageName = "ramdisk.img";
 
+    @Option(
+            name = "initramfs-image-name",
+            description = "The file name in BuildInfo that provides initramfs image.")
+    private String mInitramfsImageName = "initramfs.img";
+
     @Option(
             name = "vendor-boot-image-name",
             description = "The file name in BuildInfo that provides vendor boot image.")
@@ -177,9 +186,17 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
             description = "Whether to wipe device after GKI boot image flash.")
     private boolean mShouldWipeDevice = true;
 
+    @Option(name = "disable-verity", description = "Whether to disable-verity.")
+    private boolean mShouldDisableVerity = false;
+
     @Option(name = "oem-disable-verity", description = "Whether to run oem disable-verity.")
     private boolean mShouldDisableOemVerity = false;
 
+    @Option(
+            name = "fastboot-flash-option",
+            description = "additional options to pass with fastboot flash command.")
+    private Collection<String> mFastbootFlashOptions = new ArrayList<>();
+
     @Option(
             name = "boot-header-version",
             description = "The version of the boot.img header. Set to 3 by default.")
@@ -194,6 +211,7 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
 
     private File mBootImg = null;
     private File mSystemDlkmImg = null;
+    private Collection<String> mFlashOptions = new ArrayList<>();
 
     /** {@inheritDoc} */
     @Override
@@ -205,6 +223,8 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
         ITestDevice device = testInfo.getDevice();
         IBuildInfo buildInfo = testInfo.getBuildInfo();
 
+        mFlashOptions =
+                mFastbootFlashOptions.stream().map(String::trim).collect(Collectors.toList());
         File tmpDir = null;
         try {
             tmpDir = FileUtil.createTempDir("gki_preparer");
@@ -275,6 +295,11 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
      */
     private void flashGki(ITestDevice device, IBuildInfo buildInfo, File tmpDir)
             throws TargetSetupError, DeviceNotAvailableException {
+        if (mShouldDisableVerity) {
+            device.enableAdbRoot();
+            device.executeAdbCommand("disable-verity");
+            device.reboot();
+        }
         device.rebootIntoBootloader();
         if (mShouldDisableOemVerity) {
             executeFastbootCmd(device, "oem disable-verity");
@@ -308,6 +333,16 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
                 executeFastbootCmd(device, "flash", "vendor_kernel_boot",
                                 vendorKernelBootImg.getAbsolutePath());
             }
+            if (buildInfo.getFile(mInitramfsImageName) != null) {
+                File initramfsImg =
+                        getRequestedFile(
+                                device,
+                                mInitramfsImageName,
+                                buildInfo.getFile(mInitramfsImageName),
+                                tmpDir);
+                executeFastbootCmd(
+                        device, "flash", "vendor_boot:dlkm", initramfsImg.getAbsolutePath());
+            }
             if (buildInfo.getFile(mDtboImageName) != null) {
                 File dtboImg =
                         getRequestedFile(
@@ -653,6 +688,7 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
         String cmd =
                 String.format(
                         "%s add_hashtree_footer --do_not_generate_fec "
+                                + "--hash_algorithm sha256 "
                                 + "--image %s "
                                 + "--partition_name system_dlkm",
                         avbtool.getAbsolutePath(), mSystemDlkmImg.getAbsolutePath());
@@ -832,10 +868,17 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
      */
     private String executeFastbootCmd(ITestDevice device, String... cmdArgs)
             throws DeviceNotAvailableException, TargetSetupError {
+        List<String> fastbootCmdArgs = new ArrayList<>();
+        if ("flash".equals(cmdArgs[0])) {
+            fastbootCmdArgs.addAll(mFlashOptions);
+        }
+        fastbootCmdArgs.addAll(Arrays.asList(cmdArgs));
         CLog.i(
-                "Execute fastboot command %s on %s",
-                Arrays.toString(cmdArgs), device.getSerialNumber());
-        CommandResult result = device.executeLongFastbootCommand(cmdArgs);
+                "Execute fastboot command '%s' on %s",
+                String.join(" ", fastbootCmdArgs), device.getSerialNumber());
+        CommandResult result =
+                device.executeLongFastbootCommand(
+                        fastbootCmdArgs.toArray(new String[fastbootCmdArgs.size()]));
         CLog.v("fastboot stdout: " + result.getStdout());
         CLog.v("fastboot stderr: " + result.getStderr());
         CommandStatus cmdStatus = result.getStatus();
@@ -847,8 +890,8 @@ public class GkiDeviceFlashPreparer extends BaseTargetPreparer implements ILabPr
         if (cmdStatus != CommandStatus.SUCCESS) {
             throw new TargetSetupError(
                     String.format(
-                            "fastboot command %s failed in device %s. stdout: %s, stderr: %s",
-                            Arrays.toString(cmdArgs),
+                            "fastboot command '%s' failed in device %s. stdout: %s, stderr: %s",
+                            String.join(" ", fastbootCmdArgs),
                             device.getSerialNumber(),
                             result.getStdout(),
                             result.getStderr()),
diff --git a/src/com/android/tradefed/targetprep/InstallApexModuleTargetPreparer.java b/src/com/android/tradefed/targetprep/InstallApexModuleTargetPreparer.java
index ea3d65dcc..b8614c0d7 100644
--- a/src/com/android/tradefed/targetprep/InstallApexModuleTargetPreparer.java
+++ b/src/com/android/tradefed/targetprep/InstallApexModuleTargetPreparer.java
@@ -171,6 +171,17 @@ public class InstallApexModuleTargetPreparer extends SuiteApkInstaller {
                             + " --timeout-millis for bundletool install-apks.")
     private long mStagedReadyTimeoutMs = 0;
 
+    // Option used to ignore specific, known (and presumed harmless) crashes of critical services
+    // with updatable components, that would otherwise trigger a rollback of the updated APEX
+    // modules (see `system/core/init/README.md` for more information about critical services).
+    @Option(
+            name = "non-fatal-service",
+            description =
+                    "Services (declared as \"critical\" in `init`) whose repeated crashes are no"
+                        + " longer consider fatal and will not trigger a rollback of the updated"
+                        + " APEX modules (via a reboot).")
+    private List<String> mNonFatalServices = new ArrayList<String>();
+
     @Override
     public void setUp(TestInformation testInfo)
             throws TargetSetupError, BuildError, DeviceNotAvailableException {
@@ -276,6 +287,23 @@ public class InstallApexModuleTargetPreparer extends SuiteApkInstaller {
             // in case its first execution inside reboot() was not at a right time.
             device.postBootSetup();
         }
+        // Instruct `init` to stop considering crashes of `mNonFatalServices` as fatal, thus
+        // preventing rollbacks triggered by such crashes.
+        for (String service : mNonFatalServices) {
+            String cmd = String.format("setprop init.svc_debug.no_fatal.%s true", service);
+            // Shell v2 with command status checks.
+            CommandResult result = device.executeShellV2Command(cmd);
+            // Ensure the command ran successfully.
+            if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
+                CLog.d(
+                        "cmd: '%s' failed, returned:\nstdout:%s\nstderr:%s",
+                        cmd, result.getStdout(), result.getStderr());
+            } else {
+                CLog.d(
+                        "cmd: '%s', returned:\nstdout:%s\nstderr:%s",
+                        cmd, result.getStdout(), result.getStderr());
+            }
+        }
     }
 
     /**
@@ -485,14 +513,33 @@ public class InstallApexModuleTargetPreparer extends SuiteApkInstaller {
             throws DeviceNotAvailableException, HarnessRuntimeException {
         String rollbackState = ROLLBACK_STATE_UNKNOWN;
         String rollbacks = device.executeShellCommand("dumpsys rollback");
-        // On Android R, the SessionId line is on the third line of the dumpsys rollback output,
-        // while on Android S/T it is on the fourth line.
-        // On Android R/S, "stagedSessionId" identifier is used in the dumpsys rollback output. On
-        // Android T, "originalSessionId" identifier is used. Both identifiers will need to be
-        // supported in pattern matching.
+
+        // Log output from rollback dumpsys for debugging
+        CLog.d("Rollback status on device: \n%s", rollbacks);
+
+        // Construct a regex pattern to extract rollback information for a
+        // session id. There are a few things to consider
+        // 1. The session id is named as "stagedSessionId" on R, wheres it is
+        //    named as "originalSessionId" on S+ platforms.
+        // 2. And, the session id is in different line for different Android
+        //    platforms.
+        //
+        // Here's an example rollback status dump
+        // 235429677:
+        //   -state: available
+        //   -stateDescription:
+        //   -timestamp: 2024-06-28T17:44:07.066049Z
+        //   -rollbackLifetimeMillis: 0
+        //   -isStaged: true
+        //   -originalSessionId: 236876998
+        //   -packages:
+        //     com.google.android.ipsec 352090000 -> 340914280 [0]
+        //   -extensionVersions:
+        //     {30=10, 31=10, 33=10, 34=10, 1000000=10}
+
         Pattern rollbackPattern =
                 Pattern.compile(
-                        "(.*[\\r\\n]+){3,4}.*-(staged|original)SessionId\\:\\s" + sessionId);
+                        "(\\d+:[\\r\\n]+)(.*[\\r\\n]+){2,6}.*-.*SessionId\\:\\s" + sessionId);
         Matcher rollbackMatcher = rollbackPattern.matcher(rollbacks);
         if (rollbackMatcher.find()) {
             Matcher stateMatcher = ROLLBACK_STATE_PATTERN.matcher(rollbackMatcher.group());
@@ -524,6 +571,13 @@ public class InstallApexModuleTargetPreparer extends SuiteApkInstaller {
             CLog.e("Device %s is not available. Teardown() skipped.", device.getSerialNumber());
             return;
         }
+        // Log activated APEXes during device tearDown
+        Set<ApexInfo> activatedApexes = device.getActiveApexes();
+        CLog.i("Activated apex packages before device tearDown:");
+        for (ApexInfo info : activatedApexes) {
+            CLog.i("Activated apex: %s", info.toString());
+        }
+
         // Check if mainline modules were rolled-back before tearDown()
         if (mDetectModuleRollback && !Strings.isNullOrEmpty(mParentSessionId)) {
             detectModuleRollback(mParentSessionId, device);
diff --git a/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java b/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java
new file mode 100644
index 000000000..3782d695b
--- /dev/null
+++ b/src/com/android/tradefed/targetprep/InstallKernelModulePreparer.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.targetprep;
+
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.Option.Importance;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.util.KernelModuleUtils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A target preparer that install kernel modules. Please see
+ * https://source.android.com/docs/core/architecture/kernel/modules for details.
+ */
+@OptionClass(alias = "install-kernel-module-preparer")
+public class InstallKernelModulePreparer extends BaseTargetPreparer implements ILabPreparer {
+
+    @Option(
+            name = "module-path",
+            description = "the filesystem path of the module to install. Can be repeated.",
+            importance = Importance.IF_UNSET)
+    private Collection<String> mModulePaths = new ArrayList<String>();
+
+    @Option(
+            name = "install-arg",
+            description = "Additional arguments to be passed to kernel module install command")
+    private Collection<String> mInstallArgs = new ArrayList<String>();
+
+    @Option(
+            name = "install-module-timeout",
+            isTimeVal = true,
+            description = "Timeout applied to each module installation.")
+    private long mInstallModuleTimeout = 5 * 60 * 1000L;
+
+    private boolean mPreExistingAdbRootState;
+
+    /** {@inheritDoc} */
+    @Override
+    public void setUp(TestInformation testInfo)
+            throws TargetSetupError, BuildError, DeviceNotAvailableException {
+        ITestDevice device = testInfo.getDevice();
+
+        mPreExistingAdbRootState = device.isAdbRoot();
+
+        for (String modulePath : mModulePaths) {
+            KernelModuleUtils.removeModule(device, modulePath);
+        }
+
+        for (String modulePath : mModulePaths) {
+            KernelModuleUtils.installModule(
+                    device, modulePath, String.join(" ", mInstallArgs), mInstallModuleTimeout);
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void tearDown(TestInformation testInfo, Throwable e) throws DeviceNotAvailableException {
+        ITestDevice device = testInfo.getDevice();
+        List<String> reversedModulePaths = new ArrayList<>(mModulePaths);
+        Collections.reverse(reversedModulePaths);
+        for (String modulePath : reversedModulePaths) {
+            KernelModuleUtils.removeModule(device, modulePath);
+        }
+        if (!mPreExistingAdbRootState) {
+            device.disableAdbRoot();
+        }
+    }
+}
diff --git a/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java b/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
new file mode 100644
index 000000000..9493ff219
--- /dev/null
+++ b/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.targetprep;
+
+import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtil;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A device flasher that triggers system/update_engine/scripts/update_device.py script with a full
+ * or incremental OTA package to update the device image. To properly use this flasher, the device
+ * build info must contain a file entry named 'update-device-script' which points at the
+ * above-mentioned script.
+ */
+public class OtaUpdateDeviceFlasher implements IDeviceFlasher {
+
+    protected static final String UPDATE_DEVICE_SCRIPT = "update-device-script";
+    protected static final String OTA_DOWNGRADE_PROP = "ro.ota.allow_downgrade";
+    private static final long APPLY_OTA_PACKAGE_TIMEOUT_MINS = 25;
+    protected static final String IN_ZIP_SCRIPT_PATH =
+            String.join(File.separator, "bin", "update_device");
+
+    private UserDataFlashOption mUserDataFlashOptions = null;
+    private File mUpdateDeviceScript = null;
+    private File mOtaPackage = null;
+    private CommandStatus mOtaCommandStatus = null;
+
+    @Override
+    public void overrideDeviceOptions(ITestDevice device) {
+        // no-op
+    }
+
+    @Override
+    public void setFlashingResourcesRetriever(IFlashingResourcesRetriever retriever) {
+        // no-op
+    }
+
+    @Override
+    public void setUserDataFlashOption(UserDataFlashOption flashOption) {
+        if (!UserDataFlashOption.RETAIN.equals(flashOption)) {
+            if (!UserDataFlashOption.WIPE.equals(flashOption)) {
+                CLog.i(
+                        "Userdata flash option %s ignored, will use %s instead",
+                        flashOption, UserDataFlashOption.WIPE);
+            }
+            // if not RETAIN then it's always WIPE
+            mUserDataFlashOptions = UserDataFlashOption.WIPE;
+        } else {
+            mUserDataFlashOptions = UserDataFlashOption.RETAIN;
+        }
+    }
+
+    @Override
+    public void setDataWipeSkipList(Collection<String> dataWipeSkipList) {
+        // no-op
+    }
+
+    @Override
+    public UserDataFlashOption getUserDataFlashOption() {
+        return mUserDataFlashOptions;
+    }
+
+    @Override
+    public void setWipeTimeout(long timeout) {
+        // no-op
+    }
+
+    @Override
+    public void setForceSystemFlash(boolean forceSystemFlash) {
+        // no-op
+    }
+
+    @Override
+    public void preFlashOperations(ITestDevice device, IDeviceBuildInfo deviceBuild)
+            throws TargetSetupError, DeviceNotAvailableException {
+        // check that the update_device script path is specified
+        mUpdateDeviceScript =
+                new File(deviceBuild.getFile(UPDATE_DEVICE_SCRIPT), IN_ZIP_SCRIPT_PATH);
+        if (mUpdateDeviceScript == null) {
+            throw new TargetSetupError(
+                    String.format(
+                            "Missing %s entry in build info which should point at the update_device"
+                                    + " script",
+                            UPDATE_DEVICE_SCRIPT),
+                    device.getDeviceDescriptor());
+        }
+        if (!mUpdateDeviceScript.exists() || !mUpdateDeviceScript.isFile()) {
+            throw new TargetSetupError(
+                    String.format(
+                            "Specified update_device script at %s does not exist or is not a"
+                                    + " regular file",
+                            mUpdateDeviceScript.getAbsolutePath()),
+                    device.getDeviceDescriptor());
+        }
+        if (!mUpdateDeviceScript.setExecutable(true)) {
+            throw new TargetSetupError(
+                    "Failed to set executable for " + mUpdateDeviceScript.getAbsolutePath(),
+                    device.getDeviceDescriptor());
+        }
+        // check that the OTA package is present
+        mOtaPackage = deviceBuild.getOtaPackageFile();
+        if (mOtaPackage == null) {
+            throw new TargetSetupError(
+                    "Device build info is missing OTA package.", device.getDeviceDescriptor());
+        }
+    }
+
+    @Override
+    public void flash(ITestDevice device, IDeviceBuildInfo deviceBuild)
+            throws TargetSetupError, DeviceNotAvailableException {
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricKey.FLASHING_METHOD, FlashingMethod.USERSPACE_OTA.toString());
+        device.enableAdbRoot();
+        // allow OTA downgrade since it can't be assumed that incoming builds are always newer
+        device.setProperty(OTA_DOWNGRADE_PROP, "1");
+        // trigger the actual flashing
+        CommandResult result =
+                getRunUtil()
+                        .runTimedCmd(
+                                TimeUnit.MINUTES.toMillis(APPLY_OTA_PACKAGE_TIMEOUT_MINS),
+                                mUpdateDeviceScript.getAbsolutePath(), // the script
+                                "-s",
+                                device.getSerialNumber(),
+                                UserDataFlashOption.WIPE.equals(mUserDataFlashOptions)
+                                        ? "--wipe-user-data"
+                                        : "",
+                                mOtaPackage.getAbsolutePath() // the OTA package
+                                );
+        mOtaCommandStatus = result.getStatus();
+        CLog.v("OTA script stdout: " + result.getStdout());
+        CLog.v("OTA script stderr: " + result.getStderr());
+        if (!CommandStatus.SUCCESS.equals(mOtaCommandStatus)) {
+            throw new TargetSetupError(
+                    String.format(
+                            "Failed to apply OTA update to device. Exit Code: %d, Command Status:"
+                                    + " %s. See host log for details.",
+                            result.getExitCode(), mOtaCommandStatus),
+                    device.getDeviceDescriptor(),
+                    DeviceErrorIdentifier.ERROR_AFTER_FLASHING);
+        }
+        // reboot to apply OTA and ensures that device is online before returning
+        device.rebootUntilOnline();
+    }
+
+    protected IRunUtil getRunUtil() {
+        return RunUtil.getDefault();
+    }
+
+    @Override
+    public CommandStatus getSystemFlashingStatus() {
+        return mOtaCommandStatus;
+    }
+}
diff --git a/src/com/android/tradefed/targetprep/TestAppInstallSetup.java b/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
index 149d89427..7383bcf9c 100644
--- a/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
+++ b/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
@@ -16,6 +16,7 @@
 package com.android.tradefed.targetprep;
 
 import static com.android.tradefed.targetprep.UserHelper.RUN_TESTS_AS_USER_KEY;
+import static com.android.tradefed.targetprep.VisibleBackgroundUserPreparer.INSTALL_TEST_APK_FOR_ALL_USERS;
 
 import com.android.annotations.VisibleForTesting;
 import com.android.incfs.install.IncrementalInstallSession;
@@ -215,6 +216,10 @@ public class TestAppInstallSetup extends BaseTargetPreparer
     private IAbi mAbi = null;
     private Integer mUserId = null;
     private Boolean mGrantPermission = null;
+    // TODO: b/367468564 - Remove this flag once we have fixed the tests so that installation
+    // for the system user is no longer required when conducting tests for
+    // the secondary_user_on_secondary_display user type.
+    private boolean mInstallForAllUsers  = false;
 
     private Set<String> mPackagesInstalled = new HashSet<>();
     private TestInformation mTestInfo;
@@ -392,6 +397,11 @@ public class TestAppInstallSetup extends BaseTargetPreparer
             }
         }
 
+        if (testInfo.properties().get(INSTALL_TEST_APK_FOR_ALL_USERS) != null) {
+            mInstallForAllUsers = testInfo.properties().get(INSTALL_TEST_APK_FOR_ALL_USERS)
+                    .equals("true");
+        }
+
         if (mForceQueryable == null) {
             // Do not add --force-queryable if the device api level >= 34. Ideally,
             // checkApiLevelAgainstNextRelease(34) should only return true for api 34 devices. But,
@@ -682,7 +692,7 @@ public class TestAppInstallSetup extends BaseTargetPreparer
     private String installPackage(ITestDevice device, List<File> appFiles)
             throws DeviceNotAvailableException {
         // Handle the different install use cases (with or without a user)
-        if (mUserId == null) {
+        if (mUserId == null || mInstallForAllUsers) {
             if (appFiles.size() == 1) {
                 return device.installPackage(
                         appFiles.get(0), true, mInstallArgs.toArray(new String[] {}));
@@ -721,7 +731,7 @@ public class TestAppInstallSetup extends BaseTargetPreparer
     protected void uninstallPackage(ITestDevice device, String packageName)
             throws DeviceNotAvailableException {
         String msg;
-        if (mUserId == null) {
+        if (mUserId == null || mInstallForAllUsers) {
             msg = device.uninstallPackage(packageName);
         } else {
             msg = device.uninstallPackageForUser(packageName, mUserId);
diff --git a/src/com/android/tradefed/targetprep/VisibleBackgroundUserPreparer.java b/src/com/android/tradefed/targetprep/VisibleBackgroundUserPreparer.java
index 2c5a91222..34baaae6f 100644
--- a/src/com/android/tradefed/targetprep/VisibleBackgroundUserPreparer.java
+++ b/src/com/android/tradefed/targetprep/VisibleBackgroundUserPreparer.java
@@ -16,6 +16,7 @@
 package com.android.tradefed.targetprep;
 
 import static com.android.tradefed.targetprep.UserHelper.RUN_TESTS_AS_USER_KEY;
+
 import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
@@ -36,6 +37,13 @@ public class VisibleBackgroundUserPreparer extends BaseTargetPreparer {
     @VisibleForTesting public static final int INVALID_DISPLAY = -1; // same as android.view.Display
     @VisibleForTesting public static final int DEFAULT_DISPLAY = 0; // same as android.view.Display
 
+    /**
+     * Property used to indicate whether to install test apk for all users.
+     * TODO: b/367468564 - Remove this property once we have fixed the tests so that
+     * installation for the system user is no longer required
+     */
+    static final String INSTALL_TEST_APK_FOR_ALL_USERS = "INSTALL_TEST_APK_FOR_ALL_USERS";
+
     @Option(
             name = "reuse-test-user",
             description =
@@ -131,6 +139,9 @@ public class VisibleBackgroundUserPreparer extends BaseTargetPreparer {
 
         CLog.i("Setting test property %s=%d", RUN_TESTS_AS_USER_KEY, mUserId);
         testInfo.properties().put(RUN_TESTS_AS_USER_KEY, Integer.toString(mUserId));
+        // TODO: b/367468564 - Remove this property once we have fixed the tests so that
+        // installation for the system user is no longer required
+        testInfo.properties().put(INSTALL_TEST_APK_FOR_ALL_USERS, "true");
     }
 
     @Override
diff --git a/src/com/android/tradefed/testtype/NoisyDryRunTest.java b/src/com/android/tradefed/testtype/NoisyDryRunTest.java
index e2f4e2c66..4390dc7df 100644
--- a/src/com/android/tradefed/testtype/NoisyDryRunTest.java
+++ b/src/com/android/tradefed/testtype/NoisyDryRunTest.java
@@ -177,6 +177,11 @@ public class NoisyDryRunTest implements IRemoteTest {
             try {
                 TradefedDelegator delegator = CommandScheduler.checkDelegation(args);
                 if (delegator.shouldUseDelegation()) {
+                    if (delegator.getTfRootDir().getPath().isEmpty()) {
+                        listener.testFailed(
+                                parseCmdTest,
+                                "Delegation option was set, but path was empty string");
+                    }
                     // TODO: Add some validation of delegated config.
                     return;
                 }
diff --git a/src/com/android/tradefed/testtype/SubprocessTfLauncher.java b/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
index 6f5bbf1da..313d27b73 100644
--- a/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
+++ b/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
@@ -157,6 +157,8 @@ public abstract class SubprocessTfLauncher
                             // Aosp Tf jars
                             "tradefed.jar",
                             "tradefed-tests.jar",
+                            // AVD util test jar
+                            "^tradefed-avd-util-tests.jar",
                             // libs
                             "tools-common-prebuilt.jar",
                             // jar in older branches
diff --git a/src/com/android/tradefed/testtype/suite/BaseTestSuite.java b/src/com/android/tradefed/testtype/suite/BaseTestSuite.java
index 0f8dba1eb..ff16c940a 100644
--- a/src/com/android/tradefed/testtype/suite/BaseTestSuite.java
+++ b/src/com/android/tradefed/testtype/suite/BaseTestSuite.java
@@ -371,6 +371,7 @@ public class BaseTestSuite extends ITestSuite {
             testsDirectories.add(testsDir);
             // Actual loading of the configurations.
             long start = System.currentTimeMillis();
+            CLog.d("Loading tests from %s", testsDirectories);
             LinkedHashMap<String, IConfiguration> loadedTests =
                     loadingStrategy(mAbis, testsDirectories, mSuitePrefix, mSuiteTag);
             long duration = System.currentTimeMillis() - start;
diff --git a/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java b/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
index d73cedf64..d0d85de65 100644
--- a/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
+++ b/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
@@ -242,7 +242,9 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
             currentTestListener.add(mRemoteTestTimeOutEnforcer);
         }
 
-        mRetryAttemptForwarder = new RetryLogSaverResultForwarder(mLogSaver, currentTestListener);
+        mRetryAttemptForwarder =
+                new RetryLogSaverResultForwarder(
+                        mLogSaver, currentTestListener, mModuleConfiguration);
         ITestInvocationListener runListener = mRetryAttemptForwarder;
 
         // The module collectors itself are added: this list will be very limited.
diff --git a/src/com/android/tradefed/testtype/suite/ITestSuite.java b/src/com/android/tradefed/testtype/suite/ITestSuite.java
index 88c1f100a..bf8d941e8 100644
--- a/src/com/android/tradefed/testtype/suite/ITestSuite.java
+++ b/src/com/android/tradefed/testtype/suite/ITestSuite.java
@@ -56,8 +56,8 @@ import com.android.tradefed.log.ITestLogger;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.postprocessor.IPostProcessor;
-import com.android.tradefed.result.ByteArrayInputStreamSource;
 import com.android.tradefed.result.FailureDescription;
+import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.ITestLoggerReceiver;
 import com.android.tradefed.result.InputStreamSource;
@@ -66,6 +66,9 @@ import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.result.error.TestErrorIdentifier;
+import com.android.tradefed.result.proto.ModuleProtoResultReporter;
+import com.android.tradefed.result.skipped.SkipContext;
+import com.android.tradefed.result.skipped.SkipFeature;
 import com.android.tradefed.retry.IRetryDecision;
 import com.android.tradefed.retry.RetryStrategy;
 import com.android.tradefed.service.TradefedFeatureClient;
@@ -84,21 +87,25 @@ import com.android.tradefed.testtype.IReportNotExecuted;
 import com.android.tradefed.testtype.IRuntimeHintProvider;
 import com.android.tradefed.testtype.IShardableTest;
 import com.android.tradefed.testtype.ITestCollector;
+import com.android.tradefed.testtype.suite.SuiteResultCacheUtil.CacheResultDescriptor;
 import com.android.tradefed.util.AbiFormatter;
 import com.android.tradefed.util.AbiUtils;
+import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.SearchArtifactUtil;
 import com.android.tradefed.util.StreamUtil;
 import com.android.tradefed.util.TimeUtil;
 
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.proto.tradefed.feature.FeatureResponse;
 
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -155,11 +162,13 @@ public abstract class ITestSuite
     public static final String RANDOM_SEED = "random-seed";
     public static final String SKIP_STAGING_ARTIFACTS = "skip-staging-artifacts";
     public static final String STAGE_MODULE_ARTIFACTS = "stage-module-artifacts";
+    public static final String ENABLE_RESOLVE_SYM_LINKS = "enable-resolve-sym-links";
 
     private static final String PRODUCT_CPU_ABI_KEY = "ro.product.cpu.abi";
 
     public static final String TEST_TYPE_KEY = "test-type";
     public static final String TEST_TYPE_VALUE_PERFORMANCE = "performance";
+    public static final String BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY = "flag-overrides";
 
     private static final Set<String> ALLOWED_PREPARERS_CONFIGS =
             ImmutableSet.of("/suite/allowed-preparers.txt", "/suite/google-allowed-preparers.txt");
@@ -217,6 +226,9 @@ public abstract class ITestSuite
     )
     private Set<String> mSystemStatusCheckBlacklist = new HashSet<>();
 
+    @Option(name = ENABLE_RESOLVE_SYM_LINKS, description = "Enable symlinks resolving")
+    protected boolean mEnableResolveSymlinks = false;
+
     @Option(
         name = "report-system-checkers",
         description = "Whether reporting system checkers as test or not."
@@ -407,6 +419,8 @@ public abstract class ITestSuite
     // Current modules to run, null if not started to run yet.
     private List<ModuleDefinition> mRunModules = null;
     private ModuleDefinition mModuleInProgress = null;
+    private SkipContext mSkipContext = null;
+
     // Logger to be used to files.
     private ITestLogger mCurrentLogger = null;
     // Whether or not we are currently in split
@@ -504,9 +518,11 @@ public abstract class ITestSuite
             }
             filterPreparers(config.getValue(), mAllowedPreparers);
 
-            // Copy the CoverageOptions from the main configuration to the module configuration.
             if (mMainConfiguration != null) {
+                // Copy the CoverageOptions from the main configuration to the module configuration.
                 config.getValue().setCoverageOptions(mMainConfiguration.getCoverageOptions());
+                // Copy the CommandOptions from the main configuration to the module configuration.
+                config.getValue().setCommandOptions(mMainConfiguration.getCommandOptions());
             }
 
             filteredConfig.put(config.getKey(), config.getValue());
@@ -570,8 +586,9 @@ public abstract class ITestSuite
                         destination = mBuildInfo.getBuildAttributes().get("ROOT_DIR");
                     }
                     CLog.d(
-                            "downloading to destination: %s the following include_filters: %s",
-                            destination, includeFilters);
+                            "resolve symlinks:[%s] downloading to destination: %s the following"
+                                    + " include_filters: %s",
+                            mEnableResolveSymlinks, destination, includeFilters);
                     args.put(ResolvePartialDownload.DESTINATION_DIR, destination);
                     args.put(
                             ResolvePartialDownload.INCLUDE_FILTERS,
@@ -585,6 +602,7 @@ public abstract class ITestSuite
                                     .map(p -> p.toString())
                                     .collect(Collectors.joining(";"));
                     args.put(ResolvePartialDownload.REMOTE_PATHS, remotePaths);
+                    args.put(ENABLE_RESOLVE_SYM_LINKS, String.valueOf(mEnableResolveSymlinks));
                     FeatureResponse rep =
                             client.triggerFeature(
                                     ResolvePartialDownload.RESOLVE_PARTIAL_DOWNLOAD_FEATURE_NAME,
@@ -599,9 +617,13 @@ public abstract class ITestSuite
                             e.getMessage(), e, InfraErrorIdentifier.ARTIFACT_DOWNLOAD_ERROR);
                 }
             } else {
+                CLog.d("Not using feature server to download %s remoteFile", mDynamicResolver);
                 mDynamicResolver.setDevice(device);
                 mDynamicResolver.addExtraArgs(
                         mMainConfiguration.getCommandOptions().getDynamicDownloadArgs());
+                mDynamicResolver.addExtraArgs(
+                        ImmutableMap.of(
+                                ENABLE_RESOLVE_SYM_LINKS, String.valueOf(mEnableResolveSymlinks)));
                 for (File remoteFile : mBuildInfo.getRemoteFiles()) {
                     try {
                         mDynamicResolver.resolvePartialDownloadZip(
@@ -812,16 +834,13 @@ public abstract class ITestSuite
                 if (((AdbTcpConnection) connection).getSuiteSnapshots().containsKey(mDevice)) {
                     CLog.d("Suite snapshot already taken for '%s'", mDevice.getSerialNumber());
                 } else {
-                    ((AdbTcpConnection) connection)
-                            .snapshotDevice(mDevice, mContext.getInvocationId());
-                    ((AdbTcpConnection) connection)
-                            .getSuiteSnapshots()
-                            .put(mDevice, mContext.getInvocationId());
-                }
-                if (mUseSnapshotBeforeFirstModule) {
-                    String snapshot =
-                            ((AdbTcpConnection) connection).getSuiteSnapshots().get(mDevice);
-                    ((AdbTcpConnection) connection).recoverVirtualDevice(mDevice, snapshot, null);
+                    String snapshotId = mContext.getInvocationId();
+                    ((AdbTcpConnection) connection).snapshotDevice(mDevice, snapshotId);
+                    ((AdbTcpConnection) connection).getSuiteSnapshots().put(mDevice, snapshotId);
+                    if (mUseSnapshotBeforeFirstModule) {
+                        ((AdbTcpConnection) connection)
+                                .recoverVirtualDevice(mDevice, snapshotId, null);
+                    }
                 }
             }
         }
@@ -836,6 +855,9 @@ public abstract class ITestSuite
                     mRunModules);
         }
 
+        if (mSkipContext == null) {
+            mSkipContext = SkipFeature.getSkipContext();
+        }
         /** Run all the module, make sure to reduce the list to release resources as we go. */
         try {
             while (!mRunModules.isEmpty()) {
@@ -903,6 +925,42 @@ public abstract class ITestSuite
                             }
                         }
                     }
+                    File moduleConfig = dumpModuleConfig(module);
+                    String baseModuleName =
+                            module.getModuleInvocationContext()
+                                    .getConfigurationDescriptor()
+                                    .getModuleName();
+                    ModuleProtoResultReporter moduleReporter = null;
+                    CacheResultDescriptor cacheDescriptor = null;
+                    File moduleDir = SearchArtifactUtil.findModuleDir(baseModuleName, true);
+                    if (moduleDir == null) {
+                        InvocationMetricLogger.addInvocationMetrics(
+                                InvocationMetricKey.MODULE_CACHE_NO_DIR, 1);
+                    }
+                    if (mMainConfiguration.getCommandOptions().shouldUploadCacheResults()
+                            && moduleDir != null
+                            && mMainConfiguration.getCommandOptions().getRemoteCacheInstanceName()
+                                    != null) {
+                        cacheDescriptor =
+                                SuiteResultCacheUtil.lookUpModuleResults(
+                                        mMainConfiguration,
+                                        module.getId(),
+                                        moduleConfig,
+                                        moduleDir,
+                                        mSkipContext);
+                        if (!cacheDescriptor.isCacheHit()) {
+                            try {
+                                File protoResults =
+                                        FileUtil.createTempFile("module-results", ".proto");
+                                moduleReporter =
+                                        new ModuleProtoResultReporter(testInfo.getContext());
+                                moduleReporter.setOutputFile(protoResults);
+                                moduleListeners.add(moduleReporter);
+                            } catch (IOException e) {
+                                CLog.e(e);
+                            }
+                        }
+                    }
                     module.getModuleInvocationContext()
                             .addInvocationAttribute(
                                     MODULE_START_TIME, Long.toString(System.currentTimeMillis()));
@@ -911,18 +969,66 @@ public abstract class ITestSuite
                     // Trigger module start on module level listener too
                     new ResultForwarder(moduleListeners)
                             .testModuleStarted(module.getModuleInvocationContext());
+                    if (moduleConfig != null) {
+                        try (InputStreamSource source =
+                                new FileInputStreamSource(moduleConfig, false)) {
+                            listener.testLog(
+                                    "module-configuration", LogDataType.HARNESS_CONFIG, source);
+                        }
+                    }
                     TestInformation moduleInfo =
                             TestInformation.createModuleTestInfo(
                                     testInfo, module.getModuleInvocationContext());
-                    logModuleConfig(listener, module);
+                    boolean moduleRan = true;
                     try {
-                        runSingleModule(module, moduleInfo, listener, moduleListeners);
+                        if (mSkipContext.shouldSkipModule(baseModuleName)) {
+                            moduleRan = false;
+                            CLog.d(
+                                    "Skipping module '%s' due to no changes in artifacts.",
+                                    baseModuleName);
+                            module.getModuleInvocationContext()
+                                    .addInvocationAttribute(
+                                            ModuleDefinition.MODULE_SKIPPED,
+                                            "No relevant changes to device image or test artifacts"
+                                                    + " detected.");
+                            InvocationMetricLogger.addInvocationMetrics(
+                                    InvocationMetricKey.PARTIAL_SKIP_MODULE_UNCHANGED_COUNT, 1);
+                        } else if (cacheDescriptor != null
+                                && cacheDescriptor.isCacheHit()
+                                && mMainConfiguration.getCommandOptions().reportCacheResults()
+                                && mSkipContext.shouldUseCache()) {
+                            CLog.d("Reporting cached results for module %s", module.getId());
+                            // TODO: Include pointer to base results
+                            module.getModuleInvocationContext()
+                                    .addInvocationAttribute(
+                                            ModuleDefinition.MODULE_SKIPPED,
+                                            cacheDescriptor.getDetails());
+                        } else {
+                            runSingleModule(module, moduleInfo, listener, moduleListeners);
+                        }
                     } finally {
                         module.getModuleInvocationContext()
                                 .addInvocationAttribute(
                                         MODULE_END_TIME, Long.toString(System.currentTimeMillis()));
                         // Trigger module end on module level listener too
                         new ResultForwarder(moduleListeners).testModuleEnded();
+                        if (mMainConfiguration.getCommandOptions().shouldUploadCacheResults()
+                                && moduleReporter != null) {
+                            File protoResults = moduleReporter.getOutputFile();
+                            if (!moduleReporter.stopCaching()) {
+                                SuiteResultCacheUtil.uploadModuleResults(
+                                        mMainConfiguration,
+                                        testInfo,
+                                        module.getId(),
+                                        moduleConfig,
+                                        protoResults,
+                                        moduleDir,
+                                        mSkipContext);
+                            }
+                            FileUtil.deleteFile(protoResults);
+                            moduleListeners.remove(moduleReporter);
+                        }
+                        FileUtil.deleteFile(moduleConfig);
                         // clear out module invocation context since we are now done with module
                         // execution
                         listenerWithCollectors.testModuleEnded();
@@ -930,8 +1036,10 @@ public abstract class ITestSuite
                         // Following modules will not be isolated if no action is taken
                         CurrentInvocation.setModuleIsolation(IsolationGrade.NOT_ISOLATED);
                     }
-                    // Module isolation routine
-                    moduleIsolation(mContext, listener);
+                    if (moduleRan) {
+                        // Module isolation routine
+                        moduleIsolation(mContext, listener);
+                    }
                 }
             }
         } catch (DeviceNotAvailableException e) {
@@ -972,25 +1080,30 @@ public abstract class ITestSuite
     }
 
     /** Log the module configuration. */
-    private void logModuleConfig(ITestLogger logger, ModuleDefinition module) {
-        try (StringWriter configXmlWriter = new StringWriter();
-                PrintWriter wrapperWriter = new PrintWriter(configXmlWriter)) {
-            module.getModuleConfiguration()
-                    .dumpXml(
-                            wrapperWriter,
-                            new ArrayList<String>(Configuration.NON_MODULE_OBJECTS),
-                            true,
-                            false);
-            wrapperWriter.flush();
-            // Specified UTF-8 encoding for an abundance of caution, but its possible we could want
-            // something else in the future
-            byte[] configXmlByteArray = configXmlWriter.toString().getBytes("UTF-8");
-            try (InputStreamSource source = new ByteArrayInputStreamSource(configXmlByteArray)) {
-                logger.testLog("module-configuration", LogDataType.HARNESS_CONFIG, source);
+    private File dumpModuleConfig(ModuleDefinition module) {
+        try {
+            File configFile =
+                    FileUtil.createTempFile(
+                            module.getModuleConfiguration()
+                                    .getConfigurationDescription()
+                                    .getModuleName(),
+                            ".xml",
+                            CurrentInvocation.getWorkFolder());
+            try (FileOutputStream stream = new FileOutputStream(configFile);
+                    PrintWriter pw = new PrintWriter(stream, true)) {
+                module.getModuleConfiguration()
+                        .dumpXml(
+                                pw,
+                                new ArrayList<String>(Configuration.NON_MODULE_OBJECTS),
+                                true,
+                                false);
+                pw.flush();
+                return configFile;
             }
         } catch (RuntimeException | IOException e) {
             CLog.e(e);
         }
+        return null;
     }
 
     /**
@@ -1325,6 +1438,7 @@ public abstract class ITestSuite
             // to carry these extra data.
             cleanUpSuiteSetup();
 
+            SkipContext skipContext = SkipFeature.getSkipContext();
             // create an association of one ITestSuite <=> one ModuleDefinition as the smallest
             // execution unit supported.
             List<IRemoteTest> splitTests = new ArrayList<>();
@@ -1333,6 +1447,7 @@ public abstract class ITestSuite
                 OptionCopier.copyOptionsNoThrow(this, suite);
                 suite.mIsSharded = true;
                 suite.mDirectModule = m;
+                suite.setSkipContext(skipContext);
                 splitTests.add(suite);
             }
             // return the list of ITestSuite with their ModuleDefinition assigned
@@ -1808,4 +1923,8 @@ public abstract class ITestSuite
     public boolean getIntraModuleSharding() {
         return mIntraModuleSharding;
     }
+
+    public void setSkipContext(SkipContext skipContext) {
+        mSkipContext = skipContext;
+    }
 }
diff --git a/src/com/android/tradefed/testtype/suite/ModuleDefinition.java b/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
index 1781ab783..c7f173ac8 100644
--- a/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
+++ b/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
@@ -15,7 +15,6 @@
  */
 package com.android.tradefed.testtype.suite;
 
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.build.BuildRetrievalError;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.config.Configuration;
@@ -50,6 +49,7 @@ import com.android.tradefed.invoker.shard.token.TokenProperty;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.ILogRegistry.EventType;
 import com.android.tradefed.log.ITestLogger;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
@@ -135,6 +135,10 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
     public static final String MODULE_ISOLATED = "module-isolated";
     /** This property is set to true if the test module results were cached. */
     public static final String MODULE_CACHED = "module-cached";
+
+    /** This property is set to true if the test module was skipped */
+    public static final String MODULE_SKIPPED = "module-skipped";
+
     /** This property is set to true if only module level events are reported. */
     public static final String SPARSE_MODULE = "sparse-module";
 
@@ -148,6 +152,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
     public static final String ISOLATION_COST = "ISOLATION_COST";
     public static final String RETRY_SUCCESS_COUNT = "MODULE_RETRY_SUCCESS";
     public static final String RETRY_FAIL_COUNT = "MODULE_RETRY_FAILED";
+    public static final String MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY =
+            "module-flag-overrides";
 
     private final IInvocationContext mModuleInvocationContext;
     private final IConfiguration mModuleConfiguration;
@@ -420,7 +426,6 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
      * @param moduleInfo the {@link TestInformation} for the module.
      * @param listener the {@link ITestInvocationListener} where to report results.
      * @param moduleLevelListeners The list of listeners at the module level.
-     * @param failureListener a particular listener to collect logs on testFail. Can be null.
      * @param maxRunLimit the max number of runs for each testcase.
      * @throws DeviceNotAvailableException in case of device going offline.
      */
@@ -448,6 +453,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         }
 
         CLog.logAndDisplay(LogLevel.DEBUG, "Running module %s", getId());
+        // set the module context so it's available widely during the module run period.
+        CurrentInvocation.setModuleContext(mModuleInvocationContext);
         // Exception generated during setUp or run of the tests
         Throwable preparationException;
         DeviceNotAvailableException runException = null;
@@ -473,6 +480,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                                     .getDeviceConfigByName(device)
                                     .addSpecificConfig(preparer);
                         } catch (ConfigurationException e) {
+                            // unset the module context since module run is ending.
+                            CurrentInvocation.setModuleContext(null);
                             // Shouldn't happen;
                             throw new RuntimeException(e);
                         }
@@ -505,6 +514,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                     mTargetPreparerRetryCount,
                     shouldFailRun);
             if (shouldFailRun) {
+                // unset the module context since module run is ending.
+                CurrentInvocation.setModuleContext(null);
                 return;
             }
             mTargetPreparerRetryCount++;
@@ -744,6 +755,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                         }
                     }
                 }
+                // unset the module context since module run is ending.
+                CurrentInvocation.setModuleContext(null);
             }
         }
     }
diff --git a/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java b/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java
new file mode 100644
index 000000000..459c75a15
--- /dev/null
+++ b/src/com/android/tradefed/testtype/suite/SuiteResultCacheUtil.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.testtype.suite;
+
+import com.android.tradefed.cache.DigestCalculator;
+import com.android.tradefed.cache.ExecutableAction;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.device.NullDevice;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.proto.ModuleProtoResultReporter;
+import com.android.tradefed.result.skipped.SkipContext;
+import com.android.tradefed.util.CacheClientFactory;
+import com.android.tradefed.util.FileUtil;
+
+import build.bazel.remote.execution.v2.Digest;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/** Utility to upload and download cache results for a test module. */
+public class SuiteResultCacheUtil {
+
+    public static final String DEVICE_IMAGE_KEY = "device_image";
+
+    /** Describes the cache results. */
+    public static class CacheResultDescriptor {
+        private final boolean cacheHit;
+        private final String cacheExplanation;
+
+        public CacheResultDescriptor(boolean cacheHit, String explanation) {
+            this.cacheHit = cacheHit;
+            this.cacheExplanation = explanation;
+        }
+
+        public boolean isCacheHit() {
+            return cacheHit;
+        }
+
+        public String getDetails() {
+            return cacheExplanation;
+        }
+    }
+
+    /**
+     * Upload results to RBE
+     *
+     * @param mainConfig
+     * @param moduleConfig
+     * @param protoResults
+     * @param moduleDir
+     * @param skipContext
+     */
+    public static void uploadModuleResults(
+            IConfiguration mainConfig,
+            TestInformation testInfo,
+            String moduleId,
+            File moduleConfig,
+            File protoResults,
+            File moduleDir,
+            SkipContext skipContext) {
+        //  TODO: We don't support multi-devices
+        if (testInfo.getDevices().size() > 1) {
+            return;
+        }
+        if (!(testInfo.getDevice().getIDevice() instanceof NullDevice)
+                && !skipContext.getImageToDigest().containsKey(DEVICE_IMAGE_KEY)) {
+            CLog.d("We have device but no device digest.");
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.MODULE_RESULTS_CACHE_DEVICE_MISMATCH, 1);
+            return;
+        }
+        if (skipContext.getImageToDigest().containsValue(null)) {
+            CLog.d("No digest for device.");
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.MODULE_RESULTS_CACHE_DEVICE_MISMATCH, 1);
+            return;
+        }
+        // TODO: Ensure we have the link to the results
+        try (CloseableTraceScope ignored = new CloseableTraceScope("upload_module_results")) {
+            String cacheInstance = mainConfig.getCommandOptions().getRemoteCacheInstanceName();
+            ICacheClient cacheClient =
+                    CacheClientFactory.createCacheClient(
+                            CurrentInvocation.getWorkFolder(), cacheInstance);
+            Map<String, String> environment = new HashMap<>();
+            for (Entry<String, Digest> entry : skipContext.getImageToDigest().entrySet()) {
+                environment.put(entry.getKey(), entry.getValue().getHash());
+            }
+            Digest configDigest = DigestCalculator.compute(moduleConfig);
+            environment.put("module_config", configDigest.getHash());
+            ExecutableAction action =
+                    ExecutableAction.create(
+                            moduleDir, Arrays.asList(moduleId), environment, 60000L);
+            ExecutableActionResult result = ExecutableActionResult.create(0, protoResults, null);
+            CLog.d("Uploading cache for %s and %s", action, protoResults);
+            cacheClient.uploadCache(action, result);
+        } catch (IOException | RuntimeException | InterruptedException e) {
+            CLog.e(e);
+        }
+    }
+
+    /**
+     * Look up results in RBE for the test module.
+     *
+     * @param mainConfig
+     * @param moduleId
+     * @param moduleConfig
+     * @param moduleDir
+     * @param skipContext
+     * @return a {@link CacheResultDescriptor} describing the cache result.
+     */
+    public static CacheResultDescriptor lookUpModuleResults(
+            IConfiguration mainConfig,
+            String moduleId,
+            File moduleConfig,
+            File moduleDir,
+            SkipContext skipContext) {
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricKey.MODULE_RESULTS_CHECKING_CACHE, 1);
+        if (skipContext.getImageToDigest().containsValue(null)) {
+            CLog.d("No digest for device.");
+            return new CacheResultDescriptor(false, null);
+        }
+        try (CloseableTraceScope ignored = new CloseableTraceScope("lookup_module_results")) {
+            String cacheInstance = mainConfig.getCommandOptions().getRemoteCacheInstanceName();
+            ICacheClient cacheClient =
+                    CacheClientFactory.createCacheClient(
+                            CurrentInvocation.getWorkFolder(), cacheInstance);
+            Map<String, String> environment = new HashMap<>();
+            for (Entry<String, Digest> entry : skipContext.getImageToDigest().entrySet()) {
+                environment.put(entry.getKey(), entry.getValue().getHash());
+            }
+            Digest configDigest = DigestCalculator.compute(moduleConfig);
+            environment.put("module_config", configDigest.getHash());
+            ExecutableAction action =
+                    ExecutableAction.create(
+                            moduleDir, Arrays.asList(moduleId), environment, 60000L);
+            CLog.d("Looking up cache for %s", action);
+            ExecutableActionResult cachedResults = cacheClient.lookupCache(action);
+            if (cachedResults == null) {
+                CLog.d("No cached results for %s", moduleId);
+            } else {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.MODULE_RESULTS_CACHE_HIT, 1);
+                String details = "Cached results.";
+                Map<String, String> metadata =
+                        ModuleProtoResultReporter.parseResultsMetadata(cachedResults.stdOut());
+                if (metadata.containsKey(ModuleProtoResultReporter.INVOCATION_ID_KEY)) {
+                    details +=
+                            String.format(
+                                    " origin of results: http://ab/%s",
+                                    metadata.get(ModuleProtoResultReporter.INVOCATION_ID_KEY));
+                    CLog.d(details);
+                }
+                FileUtil.deleteFile(cachedResults.stdOut());
+                FileUtil.deleteFile(cachedResults.stdErr());
+                return new CacheResultDescriptor(true, details);
+            }
+        } catch (IOException | RuntimeException | InterruptedException e) {
+            CLog.e(e);
+        }
+        return new CacheResultDescriptor(false, null);
+    }
+}
diff --git a/src/com/android/tradefed/testtype/suite/retry/ResultsPlayer.java b/src/com/android/tradefed/testtype/suite/retry/ResultsPlayer.java
index fda571344..e76af6e70 100644
--- a/src/com/android/tradefed/testtype/suite/retry/ResultsPlayer.java
+++ b/src/com/android/tradefed/testtype/suite/retry/ResultsPlayer.java
@@ -16,7 +16,6 @@
 package com.android.tradefed.testtype.suite.retry;
 
 import com.android.annotations.VisibleForTesting;
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.device.DeviceNotAvailableException;
@@ -24,6 +23,7 @@ import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Measurements;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
diff --git a/src/com/android/tradefed/util/CacheClientFactory.java b/src/com/android/tradefed/util/CacheClientFactory.java
new file mode 100644
index 000000000..502c13a59
--- /dev/null
+++ b/src/com/android/tradefed/util/CacheClientFactory.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.cache.remote.ByteStreamDownloader;
+import com.android.tradefed.cache.remote.ByteStreamUploader;
+import com.android.tradefed.cache.remote.RemoteCacheClient;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import io.grpc.CallCredentials;
+import io.grpc.ManagedChannel;
+import io.grpc.ManagedChannelBuilder;
+import io.grpc.auth.MoreCallCredentials;
+
+import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Collection;
+import java.util.Collections;
+
+/** A factory that creates a singleton instance of {@link ICacheClient}. */
+public final class CacheClientFactory {
+    private static ICacheClient sCacheClient = null;
+
+    /** A list of default Google Cloud authentication scopes. */
+    private static final Collection<String> GOOGLE_AUTH_SCOPES =
+            Collections.singleton("https://www.googleapis.com/auth/cloud-platform");
+
+    /**
+     * The key of the json key file for {@link HostOptions}'s service-account-json-key-file option.
+     */
+    private static final String REMOTE_CACHE_JSON_KEY = "gcs-json-key";
+
+    /** The URI of remote API used to setup channel. */
+    private static final String REMOTE_API_URI = "remotebuildexecution.googleapis.com";
+
+    /**
+     * Creates a singleton instance of {@link ICacheClient}.
+     *
+     * <p>Only one singleton instance will be created and shared everywhere in this invocation. This
+     * method is thread-safe.
+     *
+     * @param workFolder The work folder where the client creates temporary files.
+     * @param instanceName The instance name of the remote execution API.
+     * @return An instance of {@link ICacheClient}.
+     */
+    public static ICacheClient createCacheClient(File workFolder, String instanceName) {
+        if (sCacheClient == null) {
+            synchronized (RemoteCacheClient.class) {
+                if (sCacheClient == null) {
+                    CallCredentials callCredentials;
+                    try {
+                        callCredentials =
+                                MoreCallCredentials.from(
+                                        GoogleApiClientUtil.createCredential(
+                                                GOOGLE_AUTH_SCOPES,
+                                                true,
+                                                null,
+                                                REMOTE_CACHE_JSON_KEY));
+                    } catch (IOException | GeneralSecurityException e) {
+                        CLog.e("Exception occurred when creating call credentials!");
+                        CLog.e(e);
+                        return null;
+                    }
+                    ManagedChannel channel =
+                            ManagedChannelBuilder.forTarget(REMOTE_API_URI).build();
+                    sCacheClient =
+                            new RemoteCacheClient(
+                                    workFolder,
+                                    instanceName,
+                                    channel,
+                                    callCredentials,
+                                    new ByteStreamDownloader(
+                                            instanceName,
+                                            channel,
+                                            callCredentials,
+                                            RemoteCacheClient.REMOTE_TIMEOUT),
+                                    new ByteStreamUploader(
+                                            instanceName,
+                                            channel,
+                                            callCredentials,
+                                            RemoteCacheClient.REMOTE_TIMEOUT));
+                }
+            }
+        }
+        return sCacheClient;
+    }
+}
diff --git a/src/com/android/tradefed/util/GCSCommon.java b/src/com/android/tradefed/util/GCSCommon.java
index d3d2b1d94..e226d19f6 100644
--- a/src/com/android/tradefed/util/GCSCommon.java
+++ b/src/com/android/tradefed/util/GCSCommon.java
@@ -30,7 +30,12 @@ import java.security.GeneralSecurityException;
 import java.util.Collection;
 
 /**
- * Base class for Gcs operation like download and upload. {@link GCSFileDownloader} and {@link
+ * Obsoleted! Use com.android.tradefed.util.gcs.GCSCommon instead.
+ *
+ * <p>This class is kept for backwards compatibility, so tradefed prebuilt can be used to build
+ * tests on older branches.
+ *
+ * <p>Base class for Gcs operation like download and upload. {@link GCSFileDownloader} and {@link
  * GCSFileUploader}.
  */
 public abstract class GCSCommon {
diff --git a/src/com/android/tradefed/util/GCSFileDownloader.java b/src/com/android/tradefed/util/GCSFileDownloader.java
index a67a33c69..218039a2f 100644
--- a/src/com/android/tradefed/util/GCSFileDownloader.java
+++ b/src/com/android/tradefed/util/GCSFileDownloader.java
@@ -21,62 +21,34 @@ import com.android.tradefed.build.IFileDownloader;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.util.gcs.GCSFileDownloaderBase;
 
-import com.google.api.client.googleapis.json.GoogleJsonResponseException;
 import com.google.api.services.storage.Storage;
-import com.google.api.services.storage.model.Objects;
 import com.google.api.services.storage.model.StorageObject;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.math.BigInteger;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
 import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /** File downloader to download file from google cloud storage (GCS). */
-public class GCSFileDownloader extends GCSCommon implements IFileDownloader {
-    public static final String GCS_PREFIX = "gs://";
-    public static final String GCS_APPROX_PREFIX = "gs:/";
-
-    private static final Pattern GCS_PATH_PATTERN = Pattern.compile("gs://([^/]*)/(.*)");
-    private static final String PATH_SEP = "/";
-    private static final Collection<String> SCOPES =
-            Collections.singleton("https://www.googleapis.com/auth/devstorage.read_only");
-    private static final long LIST_BATCH_SIZE = 100;
-
-    // Allow downloader to create empty files instead of throwing exception.
-    private Boolean mCreateEmptyFile = false;
+public class GCSFileDownloader extends GCSFileDownloaderBase implements IFileDownloader {
 
     // Cache the freshness
     private final LoadingCache<String, Boolean> mFreshnessCache;
 
-    public GCSFileDownloader(File jsonKeyFile) {
-        this(false);
-        setJsonKeyFile(jsonKeyFile);
-    }
-
     public GCSFileDownloader(Boolean createEmptyFile) {
-        mCreateEmptyFile = createEmptyFile;
+        super(createEmptyFile);
         mFreshnessCache =
                 CacheBuilder.newBuilder()
                         .maximumSize(50)
@@ -94,34 +66,25 @@ public class GCSFileDownloader extends GCSCommon implements IFileDownloader {
         this(false);
     }
 
-    protected void clearCache() {
-        mFreshnessCache.invalidateAll();
+    public GCSFileDownloader(File jsonKeyFile) {
+        this(false);
+        mJsonKeyFile = jsonKeyFile;
     }
 
-    private Storage getStorage() throws IOException {
-        return getStorage(SCOPES);
+    /**
+     * Override the implementation in base to support credential based on TF options.
+     *
+     * @param scopes specific scopes to request credential for.
+     * @return {@link Storage} object of the GCS bucket
+     * @throws IOException
+     */
+    @Override
+    protected Storage getStorage(Collection<String> scopes) throws IOException {
+        return GCSHelper.getStorage(scopes, mJsonKeyFile);
     }
 
-    @VisibleForTesting
-    StorageObject getRemoteFileMetaData(String bucketName, String remoteFilename)
-            throws IOException {
-        int i = 0;
-        do {
-            i++;
-            try {
-                return getStorage().objects().get(bucketName, remoteFilename).execute();
-            } catch (GoogleJsonResponseException e) {
-                if (e.getStatusCode() == 404) {
-                    return null;
-                }
-                throw e;
-            } catch (SocketTimeoutException e) {
-                // Allow one retry in case of flaky connection.
-                if (i >= 2) {
-                    throw e;
-                }
-            }
-        } while (true);
+    protected void clearCache() {
+        mFreshnessCache.invalidateAll();
     }
 
     /**
@@ -135,7 +98,7 @@ public class GCSFileDownloader extends GCSCommon implements IFileDownloader {
      */
     @Override
     public File downloadFile(String remoteFilePath) throws BuildRetrievalError {
-        File destFile = createTempFile(remoteFilePath, null);
+        File destFile = createTempFileForRemote(remoteFilePath, null);
         try {
             downloadFile(remoteFilePath, destFile);
             return destFile;
@@ -145,29 +108,6 @@ public class GCSFileDownloader extends GCSCommon implements IFileDownloader {
         }
     }
 
-    /**
-     * Download a file from a GCS bucket file.
-     *
-     * @param bucketName GCS bucket name
-     * @param filename the filename
-     * @return {@link InputStream} with the file content.
-     */
-    public InputStream downloadFile(String bucketName, String filename) throws IOException {
-        InputStream remoteInput = null;
-        ByteArrayOutputStream tmpStream = null;
-        try {
-            remoteInput =
-                    getStorage().objects().get(bucketName, filename).executeMediaAsInputStream();
-            // The input stream from api call can not be reset. Change it to ByteArrayInputStream.
-            tmpStream = new ByteArrayOutputStream();
-            StreamUtil.copyStreams(remoteInput, tmpStream);
-            return new ByteArrayInputStream(tmpStream.toByteArray());
-        } finally {
-            StreamUtil.close(remoteInput);
-            StreamUtil.close(tmpStream);
-        }
-    }
-
     @Override
     public void downloadFile(String remotePath, File destFile) throws BuildRetrievalError {
         String[] pathParts = parseGcsPath(remotePath);
@@ -175,37 +115,13 @@ public class GCSFileDownloader extends GCSCommon implements IFileDownloader {
     }
 
     @VisibleForTesting
-    void downloadFile(String bucketName, String remoteFilename, File localFile)
+    @Override
+    protected void downloadFile(String bucketName, String remoteFilename, File localFile)
             throws BuildRetrievalError {
-        int i = 0;
         try {
-            do {
-                i++;
-                try {
-                    if (!isRemoteFolder(bucketName, remoteFilename)) {
-                        fetchRemoteFile(bucketName, remoteFilename, localFile);
-                        return;
-                    }
-                    remoteFilename = sanitizeDirectoryName(remoteFilename);
-                    recursiveDownloadFolder(bucketName, remoteFilename, localFile);
-                    return;
-                } catch (SocketException se) {
-                    // Allow one retry in case of flaky connection.
-                    if (i >= 2) {
-                        throw se;
-                    }
-                    CLog.e(
-                            "Error '%s' while downloading gs://%s/%s. retrying.",
-                            se.getMessage(), bucketName, remoteFilename);
-                }
-            } while (true);
-        } catch (IOException e) {
-            String message =
-                    String.format(
-                            "Failed to download gs://%s/%s due to: %s",
-                            bucketName, remoteFilename, e.getMessage());
-            CLog.e(message);
-            throw new BuildRetrievalError(message, e, InfraErrorIdentifier.GCS_ERROR);
+            super.downloadFile(bucketName, remoteFilename, localFile);
+        } catch (Exception e) {
+            throw new BuildRetrievalError(e.getMessage(), e, InfraErrorIdentifier.GCS_ERROR);
         }
     }
 
@@ -298,203 +214,22 @@ public class GCSFileDownloader extends GCSCommon implements IFileDownloader {
         return subFilenames.isEmpty();
     }
 
-    void listRemoteFilesUnderFolder(
-            String bucketName, String folder, List<StorageObject> subFiles, List<String> subFolders)
-            throws IOException {
-        String pageToken = null;
-        while (true) {
-            com.google.api.services.storage.Storage.Objects.List listOperation =
-                    getStorage()
-                            .objects()
-                            .list(bucketName)
-                            .setPrefix(folder)
-                            .setDelimiter(PATH_SEP)
-                            .setMaxResults(LIST_BATCH_SIZE);
-            if (pageToken != null) {
-                listOperation.setPageToken(pageToken);
-            }
-            Objects objects = listOperation.execute();
-            if (objects.getItems() != null && !objects.getItems().isEmpty()) {
-                for (int i = 0; i < objects.getItems().size(); i++) {
-                    if (objects.getItems().get(i).getName().equals(folder)) {
-                        // If the folder is created from UI, the folder itself
-                        // is a size 0 text file and its name will be
-                        // the folder's name, we should ignore this file.
-                        continue;
-                    }
-                    subFiles.add(objects.getItems().get(i));
-                }
-            }
-            if (objects.getPrefixes() != null && !objects.getPrefixes().isEmpty()) {
-                // size 0 sub-folders will also be listed under the prefix.
-                // So this includes all the sub-folders.
-                subFolders.addAll(objects.getPrefixes());
-            }
-            pageToken = objects.getNextPageToken();
-            if (pageToken == null) {
-                return;
-            }
-        }
-    }
-
-    String[] parseGcsPath(String remotePath) throws BuildRetrievalError {
-        if (remotePath.startsWith(GCS_APPROX_PREFIX) && !remotePath.startsWith(GCS_PREFIX)) {
-            // File object remove double // so we have to rebuild it in some cases
-            remotePath = remotePath.replaceAll(GCS_APPROX_PREFIX, GCS_PREFIX);
-        }
-        Matcher m = GCS_PATH_PATTERN.matcher(remotePath);
-        if (!m.find()) {
+    @Override
+    protected String[] parseGcsPath(String remotePath) throws BuildRetrievalError {
+        try {
+            return super.parseGcsPath(remotePath);
+        } catch (Exception e) {
             throw new BuildRetrievalError(
-                    String.format("Only GCS path is supported, %s is not supported", remotePath),
-                    InfraErrorIdentifier.ARTIFACT_UNSUPPORTED_PATH);
+                    e.getMessage(), InfraErrorIdentifier.ARTIFACT_UNSUPPORTED_PATH);
         }
-        return new String[] {m.group(1), m.group(2)};
     }
 
-    String sanitizeDirectoryName(String name) {
-        /** Folder name should end with "/" */
-        if (!name.endsWith(PATH_SEP)) {
-            name += PATH_SEP;
-        }
-        return name;
-    }
-
-    /**
-     * Check given filename is a folder or not.
-     *
-     * <p>There 2 types of folders in gcs: 1. Created explicitly from UI. The folder is a size 0
-     * text file (it's an object). 2. When upload a file, all its parent folders will be created,
-     * but these folders doesn't exist (not objects) in gcs. This function work for both cases. But
-     * we should not try to download the size 0 folders.
-     *
-     * @param bucketName is the gcs bucket name.
-     * @param filename is the relative path to the bucket.
-     * @return true if the filename is a folder, otherwise false.
-     */
-    @VisibleForTesting
-    boolean isRemoteFolder(String bucketName, String filename) throws IOException {
-        filename = sanitizeDirectoryName(filename);
-        Objects objects =
-                getStorage()
-                        .objects()
-                        .list(bucketName)
-                        .setPrefix(filename)
-                        .setDelimiter(PATH_SEP)
-                        .setMaxResults(1L)
-                        .execute();
-        if (objects.getItems() != null && !objects.getItems().isEmpty()) {
-            // The filename is end with '/', if there are objects use filename as prefix
-            // then filename must be a folder.
-            return true;
-        }
-        if (objects.getPrefixes() != null && !objects.getPrefixes().isEmpty()) {
-            // This will happen when the folder only contains folders but no objects.
-            // objects.getItems() will be empty, but objects.getPrefixes will list
-            // sub-folders.
-            return true;
-        }
-        return false;
-    }
-
-    private void fetchRemoteFile(String bucketName, String remoteFilename, File localFile)
-            throws IOException, BuildRetrievalError {
-        CLog.d("Fetching gs://%s/%s to %s.", bucketName, remoteFilename, localFile.toString());
-        StorageObject meta = getRemoteFileMetaData(bucketName, remoteFilename);
-        if (meta == null || meta.getSize().equals(BigInteger.ZERO)) {
-            if (!mCreateEmptyFile) {
-                throw new BuildRetrievalError(
-                        String.format(
-                                "File (not folder) gs://%s/%s doesn't exist or is size 0.",
-                                bucketName, remoteFilename),
-                        InfraErrorIdentifier.GCS_ERROR);
-            } else {
-                // Create the empty file.
-                CLog.d("GCS file is empty: gs://%s/%s", bucketName, remoteFilename);
-                localFile.createNewFile();
-                return;
-            }
-        }
-        try (OutputStream writeStream = new FileOutputStream(localFile)) {
-            getStorage()
-                    .objects()
-                    .get(bucketName, remoteFilename)
-                    .executeMediaAndDownloadTo(writeStream);
-        }
-    }
-
-    /**
-     * Recursively download remote folder to local folder.
-     *
-     * @param bucketName the gcs bucket name
-     * @param remoteFolderName remote folder name, must end with "/"
-     * @param localFolder local folder
-     * @throws IOException
-     * @throws BuildRetrievalError
-     */
-    private void recursiveDownloadFolder(
-            String bucketName, String remoteFolderName, File localFolder)
-            throws IOException, BuildRetrievalError {
-        CLog.d("Downloading folder gs://%s/%s.", bucketName, remoteFolderName);
-        if (!localFolder.exists()) {
-            FileUtil.mkdirsRWX(localFolder);
-        }
-        if (!localFolder.isDirectory()) {
-            String error =
-                    String.format(
-                            "%s is not a folder. (gs://%s/%s)",
-                            localFolder, bucketName, remoteFolderName);
-            CLog.e(error);
-            throw new IOException(error);
-        }
-        Set<String> subFilenames = new HashSet<>(Arrays.asList(localFolder.list()));
-        List<String> subRemoteFolders = new ArrayList<>();
-        List<StorageObject> subRemoteFiles = new ArrayList<>();
-        listRemoteFilesUnderFolder(bucketName, remoteFolderName, subRemoteFiles, subRemoteFolders);
-        for (StorageObject subRemoteFile : subRemoteFiles) {
-            String subFilename = Paths.get(subRemoteFile.getName()).getFileName().toString();
-            fetchRemoteFile(
-                    bucketName, subRemoteFile.getName(), new File(localFolder, subFilename));
-            subFilenames.remove(subFilename);
-        }
-        for (String subRemoteFolder : subRemoteFolders) {
-            String subFolderName = Paths.get(subRemoteFolder).getFileName().toString();
-            File subFolder = new File(localFolder, subFolderName);
-            if (new File(localFolder, subFolderName).exists()
-                    && !new File(localFolder, subFolderName).isDirectory()) {
-                CLog.w("%s exists as a non-directory.", subFolder);
-                subFolder = new File(localFolder, subFolderName + "_folder");
-            }
-            recursiveDownloadFolder(bucketName, subRemoteFolder, subFolder);
-            subFilenames.remove(subFolder.getName());
-        }
-        for (String subFilename : subFilenames) {
-            FileUtil.recursiveDelete(new File(localFolder, subFilename));
-        }
-    }
-
-    @VisibleForTesting
-    File createTempFile(String remoteFilePath, File rootDir) throws BuildRetrievalError {
-        return createTempFileForRemote(remoteFilePath, rootDir);
-    }
-
-    /**
-     * Creates a unique file on temporary disk to house downloaded file with given path.
-     *
-     * <p>Constructs the file name based on base file name from path
-     *
-     * @param remoteFilePath the remote path to construct the name from
-     */
     public static File createTempFileForRemote(String remoteFilePath, File rootDir)
             throws BuildRetrievalError {
         try {
-            // create a unique file.
-            File tmpFile = FileUtil.createTempFileForRemote(remoteFilePath, rootDir);
-            // now delete it so name is available
-            tmpFile.delete();
-            return tmpFile;
-        } catch (IOException e) {
-            String msg = String.format("Failed to create tmp file for %s", remoteFilePath);
-            throw new BuildRetrievalError(msg, e);
+            return GCSFileDownloaderBase.createTempFileForRemote(remoteFilePath, rootDir);
+        } catch (Exception e) {
+            throw new BuildRetrievalError(e.getMessage(), e);
         }
     }
 }
diff --git a/src/com/android/tradefed/util/GCSFileUploader.java b/src/com/android/tradefed/util/GCSFileUploader.java
index 38376ef68..3108fe0f9 100644
--- a/src/com/android/tradefed/util/GCSFileUploader.java
+++ b/src/com/android/tradefed/util/GCSFileUploader.java
@@ -17,6 +17,7 @@
 package com.android.tradefed.util;
 
 import com.android.tradefed.log.LogUtil;
+import com.android.tradefed.util.gcs.GCSCommon;
 
 import com.google.api.client.http.InputStreamContent;
 import com.google.api.services.storage.Storage;
@@ -34,11 +35,13 @@ public class GCSFileUploader extends GCSCommon {
             Collections.singleton("https://www.googleapis.com/auth/devstorage.read_write");
 
     public GCSFileUploader(File jsonKeyFile) {
-        super(jsonKeyFile);
+        super();
+        mJsonKeyFile = jsonKeyFile;
     }
 
     public GCSFileUploader() {}
 
+
     /**
      * Upload data to a GCS bucket file. gs://[bucketName]/[gcsFileName]
      *
@@ -79,4 +82,16 @@ public class GCSFileUploader extends GCSCommon {
     private Storage getWritableStorage() throws IOException {
         return getStorage(WRITE_SCOPE);
     }
+
+    /**
+     * Override the implementation in base to support credential based on TF options.
+     *
+     * @param scopes specific scopes to request credential for.
+     * @return {@link Storage} object of the GCS bucket
+     * @throws IOException
+     */
+    @Override
+    protected Storage getStorage(Collection<String> scopes) throws IOException {
+        return GCSHelper.getStorage(scopes, mJsonKeyFile);
+    }
 }
diff --git a/src/com/android/tradefed/util/GCSHelper.java b/src/com/android/tradefed/util/GCSHelper.java
new file mode 100644
index 000000000..15397c4dc
--- /dev/null
+++ b/src/com/android/tradefed/util/GCSHelper.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.host.HostOptions;
+import com.android.tradefed.util.gcs.GCSCommon;
+
+import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
+import com.google.api.client.http.HttpRequestInitializer;
+import com.google.api.client.json.gson.GsonFactory;
+import com.google.api.services.storage.Storage;
+import com.google.auth.Credentials;
+import com.google.auth.http.HttpCredentialsAdapter;
+
+import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Collection;
+
+public class GCSHelper {
+
+    /** This is the key for {@link HostOptions}'s service-account-json-key-file option. */
+    private static final String GCS_JSON_KEY = "gcs-json-key";
+
+    /**
+     * Get {@link Storage} object for the remote GCS bucket with credential based on TF options.
+     *
+     * @param scopes specific scopes to request credential for.
+     * @return {@link Storage} object of the GCS bucket
+     * @throws IOException
+     */
+    public static Storage getStorage(Collection<String> scopes, File keyFile) throws IOException {
+        Credentials credential = null;
+        try {
+            credential = GoogleApiClientUtil.createCredential(scopes, true, keyFile, GCS_JSON_KEY);
+            HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credential);
+            return new Storage.Builder(
+                            GoogleNetHttpTransport.newTrustedTransport(),
+                            GsonFactory.getDefaultInstance(),
+                            GoogleApiClientUtil.configureRetryStrategy(
+                                    GoogleApiClientUtil.setHttpTimeout(
+                                            requestInitializer,
+                                            GCSCommon.DEFAULT_TIMEOUT,
+                                            GCSCommon.DEFAULT_TIMEOUT)))
+                    .setApplicationName(GoogleApiClientUtil.APP_NAME)
+                    .build();
+
+        } catch (GeneralSecurityException e) {
+            throw new IOException(e);
+        }
+    }
+}
diff --git a/src/com/android/tradefed/util/GoogleApiClientUtil.java b/src/com/android/tradefed/util/GoogleApiClientUtil.java
index 8221b0916..24d85fcef 100644
--- a/src/com/android/tradefed/util/GoogleApiClientUtil.java
+++ b/src/com/android/tradefed/util/GoogleApiClientUtil.java
@@ -19,22 +19,13 @@ import com.android.tradefed.auth.ICredentialFactory;
 import com.android.tradefed.config.GlobalConfiguration;
 import com.android.tradefed.host.HostOptions;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.gcs.GoogleApiClientUtilBase;
 
 import com.google.api.client.auth.oauth2.Credential;
-import com.google.api.client.http.HttpBackOffUnsuccessfulResponseHandler;
-import com.google.api.client.http.HttpRequest;
-import com.google.api.client.http.HttpRequestInitializer;
-import com.google.api.client.http.HttpResponse;
-import com.google.api.client.http.HttpUnsuccessfulResponseHandler;
-import com.google.api.client.util.ExponentialBackOff;
 import com.google.auth.Credentials;
-import com.google.auth.oauth2.ComputeEngineCredentials;
-import com.google.auth.oauth2.GoogleCredentials;
 import com.google.common.annotations.VisibleForTesting;
 
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
@@ -43,9 +34,8 @@ import java.util.Collection;
 import java.util.List;
 
 /** Utils for create Google API client. */
-public class GoogleApiClientUtil {
+public class GoogleApiClientUtil extends GoogleApiClientUtilBase {
 
-    public static final String APP_NAME = "tradefed";
     private static GoogleApiClientUtil sInstance = null;
 
     private static GoogleApiClientUtil getInstance() {
@@ -55,28 +45,7 @@ public class GoogleApiClientUtil {
         return sInstance;
     }
 
-    /**
-     * Create credential from json key file.
-     *
-     * @param file is the p12 key file
-     * @param scopes is the API's scope.
-     * @return a {@link Credential}.
-     * @throws FileNotFoundException
-     * @throws IOException
-     * @throws GeneralSecurityException
-     */
-    public static Credentials createCredentialFromJsonKeyFile(File file, Collection<String> scopes)
-            throws IOException, GeneralSecurityException {
-        return getInstance().doCreateCredentialFromJsonKeyFile(file, scopes);
-    }
 
-    @VisibleForTesting
-    Credentials doCreateCredentialFromJsonKeyFile(File file, Collection<String> scopes)
-            throws IOException, GeneralSecurityException {
-        Credentials credentail =
-                GoogleCredentials.fromStream(new FileInputStream(file)).createScoped(scopes);
-        return credentail;
-    }
 
     /**
      * Try to create credential with different key files or from local host.
@@ -183,6 +152,7 @@ public class GoogleApiClientUtil {
         return doCreateDefaultCredential(scopes);
     }
 
+
     @VisibleForTesting
     Credentials doCreateCredentialFromCredentialFactory(Collection<String> scopes)
             throws IOException {
@@ -201,104 +171,5 @@ public class GoogleApiClientUtil {
         return null;
     }
 
-    @VisibleForTesting
-    Credentials doCreateDefaultCredential(Collection<String> scopes) throws IOException {
-        try {
-            CLog.d("Using local authentication.");
-            return ComputeEngineCredentials.getApplicationDefault().createScoped(scopes);
-        } catch (IOException e) {
-            CLog.e(
-                    "Try 'gcloud auth application-default login' to login for "
-                            + "personal account; Or 'export "
-                            + "GOOGLE_APPLICATION_CREDENTIALS=/path/to/key.json' "
-                            + "for service account.");
-            throw e;
-        }
-    }
-
-    /**
-     * @param requestInitializer a {@link HttpRequestInitializer}, normally it's {@link Credential}.
-     * @param connectTimeout connect timeout in milliseconds.
-     * @param readTimeout read timeout in milliseconds.
-     * @return a {@link HttpRequestInitializer} with timeout.
-     */
-    public static HttpRequestInitializer setHttpTimeout(
-            final HttpRequestInitializer requestInitializer, int connectTimeout, int readTimeout) {
-        return new HttpRequestInitializer() {
-            @Override
-            public void initialize(HttpRequest request) throws IOException {
-                requestInitializer.initialize(request);
-                request.setConnectTimeout(connectTimeout);
-                request.setReadTimeout(readTimeout);
-            }
-        };
-    }
 
-    /**
-     * Setup a retry strategy for the provided HttpRequestInitializer. In case of server errors
-     * requests will be automatically retried with an exponential backoff.
-     *
-     * @param initializer - an initializer which will setup a retry strategy.
-     * @return an initializer that will retry failed requests automatically.
-     */
-    public static HttpRequestInitializer configureRetryStrategyAndTimeout(
-            HttpRequestInitializer initializer, int connectTimeout, int readTimeout) {
-        return new HttpRequestInitializer() {
-            @Override
-            public void initialize(HttpRequest request) throws IOException {
-                initializer.initialize(request);
-                request.setConnectTimeout(connectTimeout);
-                request.setReadTimeout(readTimeout);
-                request.setUnsuccessfulResponseHandler(new RetryResponseHandler());
-            }
-        };
-    }
-
-    /**
-     * Setup a retry strategy for the provided HttpRequestInitializer. In case of server errors
-     * requests will be automatically retried with an exponential backoff.
-     *
-     * @param initializer - an initializer which will setup a retry strategy.
-     * @return an initializer that will retry failed requests automatically.
-     */
-    public static HttpRequestInitializer configureRetryStrategy(
-            HttpRequestInitializer initializer) {
-        return new HttpRequestInitializer() {
-            @Override
-            public void initialize(HttpRequest request) throws IOException {
-                initializer.initialize(request);
-                request.setUnsuccessfulResponseHandler(new RetryResponseHandler());
-            }
-        };
-    }
-
-    private static class RetryResponseHandler implements HttpUnsuccessfulResponseHandler {
-        // Initial interval to wait before retrying if a request fails.
-        private static final int INITIAL_RETRY_INTERVAL = 1000;
-        private static final int MAX_RETRY_INTERVAL = 3 * 60000; // Set max interval to 3 minutes.
-
-        private final HttpUnsuccessfulResponseHandler backOffHandler;
-
-        public RetryResponseHandler() {
-            backOffHandler =
-                    new HttpBackOffUnsuccessfulResponseHandler(
-                            new ExponentialBackOff.Builder()
-                                    .setInitialIntervalMillis(INITIAL_RETRY_INTERVAL)
-                                    .setMaxIntervalMillis(MAX_RETRY_INTERVAL)
-                                    .build());
-        }
-
-        @Override
-        public boolean handleResponse(
-                HttpRequest request, HttpResponse response, boolean supportsRetry)
-                throws IOException {
-            CLog.w(
-                    "Request to %s failed: %d %s",
-                    request.getUrl(), response.getStatusCode(), response.getStatusMessage());
-            if (response.getStatusCode() == 400) {
-                return false;
-            }
-            return backOffHandler.handleResponse(request, response, supportsRetry);
-        }
-    }
 }
diff --git a/src/com/android/tradefed/util/KernelModuleUtils.java b/src/com/android/tradefed/util/KernelModuleUtils.java
new file mode 100644
index 000000000..eaf750fad
--- /dev/null
+++ b/src/com/android/tradefed/util/KernelModuleUtils.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.util;
+
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.targetprep.TargetSetupError;
+
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class KernelModuleUtils {
+
+    /** Remove `.ko` extension if present */
+    public static String removeKoExtension(String s) {
+        return s.endsWith(".ko") ? s.substring(0, s.length() - 3) : s;
+    }
+
+    /**
+     * Return module name as it's displayed after loading.
+     *
+     * <p>For example, see the difference between the file name and that returned by `lsmod`:
+     *
+     * <pre>{@code
+     * $ insmod kunit.ko
+     * $ lsmod | grep kunit
+     * kunit 20480 0
+     * }</pre>
+     */
+    public static String getDisplayedModuleName(String fullPath) {
+
+        // Extract filename from full path
+        int sepPos = fullPath.lastIndexOf('/');
+        String moduleName = sepPos == -1 ? fullPath : fullPath.substring(sepPos + 1);
+        if (moduleName.isEmpty()) {
+            throw new IllegalArgumentException("input should not end with \"/\"");
+        }
+
+        // Remove `.ko` extension if present
+        moduleName = removeKoExtension(moduleName);
+
+        // Replace all '-' with '_'
+        return moduleName.replace('-', '_');
+    }
+
+    /**
+     * Return the names of the modules that the given module depends on.
+     *
+     * <p>For example, if the given module is `kunit`, and the `lsmod` output is:
+     *
+     * <pre>{@code
+     * $ lsmod
+     * Module        Size    Used by
+     * kunit_test    663552  0
+     * time_test     663558  0
+     * kunit         57344   15 kunit_test,time_test
+     * }</pre>
+     *
+     * Then this method will return an array containing `kunit_test` and `time_test`.
+     */
+    public static String[] getDependentModules(String modName, String lsmodOutput) {
+
+        Pattern pattern =
+                Pattern.compile(
+                        String.format("^%s\\s+\\d+\\s+\\d+\\s+(\\S*)$", modName),
+                        Pattern.MULTILINE);
+        Matcher matcher = pattern.matcher(lsmodOutput);
+        if (matcher.find()) {
+            String dependModNames = matcher.group(1);
+            CLog.i("%s has depending modules: %s", modName, dependModNames);
+            return dependModNames.split(",");
+        } else {
+            return new String[0];
+        }
+    }
+
+    /**
+     * Install a kernel module on the given device.
+     *
+     * @param device the device to install the module on
+     * @param modulePath the path to the module to install
+     * @param arg the argument to pass to the install command
+     * @param timeoutMs the timeout in milliseconds
+     * @throws TargetSetupError if the module cannot be installed
+     * @throws DeviceNotAvailableException if the device is not available
+     */
+    public static void installModule(
+            ITestDevice device, String modulePath, String arg, long timeoutMs)
+            throws TargetSetupError, DeviceNotAvailableException {
+
+        String kernelModule = getDisplayedModuleName(modulePath);
+
+        String command = String.format("insmod %s %s", modulePath, arg);
+        CLog.i("Installing %s on %s", modulePath, device.getSerialNumber());
+        CommandResult result =
+                device.executeShellV2Command(command, timeoutMs, TimeUnit.MILLISECONDS);
+        if (result == null) {
+            throw new TargetSetupError(
+                    String.format(
+                            "Failed to get return from command '%s' from %s",
+                            command, device.getSerialNumber()),
+                    DeviceErrorIdentifier.KERNEL_MODULE_INSTALLATION_FAILED);
+        }
+        if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
+            String errorMessage =
+                    String.format(
+                            "shell command %s failed with exit code: %d, stderr: %s, stdout:"
+                                    + " %s",
+                            command, result.getExitCode(), result.getStderr(), result.getStdout());
+            CLog.e("Unable to install module '%s'. Error message: %s", kernelModule, errorMessage);
+            throw new TargetSetupError(
+                    String.format(
+                            "Failed to install %s on %s. Error message: '%s'",
+                            kernelModule, device.getSerialNumber(), errorMessage),
+                    DeviceErrorIdentifier.KERNEL_MODULE_INSTALLATION_FAILED);
+        }
+    }
+
+    /**
+     * Remove a kernel module and dependent modules from the given device.
+     *
+     * <p>This method attempts to remove the target kernel module from the device. If the module has
+     * any dependencies, those dependent modules will be removed before the target module with best
+     * effort.
+     *
+     * @param device the device to remove the module from
+     * @param module the name or the path to the module to remove
+     * @throws DeviceNotAvailableException if the device is not available
+     */
+    public static void removeModule(ITestDevice device, String module)
+            throws DeviceNotAvailableException {
+
+        String kernelModule = getDisplayedModuleName(module);
+        String command;
+
+        CLog.i("Remove kernel module %s from %s", kernelModule, device.getSerialNumber());
+
+        String output = device.executeShellCommand("lsmod");
+        CLog.d("lsmod output: %s from %s", output, device.getSerialNumber());
+        for (String modName : getDependentModules(kernelModule, output)) {
+            String trimmedName = modName.trim();
+            command = String.format("rmmod %s", trimmedName);
+            output = device.executeShellCommand(command);
+            CLog.i("'%s' returned %s.", command, output);
+        }
+
+        // Clean up, unload module with best effort
+        command = String.format("rmmod %s", kernelModule);
+        output = device.executeShellCommand(command);
+        CLog.i("'%s' returned %s.", command, output);
+    }
+}
diff --git a/src/com/android/tradefed/util/TestFilterHelper.java b/src/com/android/tradefed/util/TestFilterHelper.java
index 8f8c77dc4..1c73d53f4 100644
--- a/src/com/android/tradefed/util/TestFilterHelper.java
+++ b/src/com/android/tradefed/util/TestFilterHelper.java
@@ -33,6 +33,7 @@ import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.regex.PatternSyntaxException;
 
 /**
  * Helper class for filtering tests
@@ -256,8 +257,13 @@ public class TestFilterHelper {
             // passes 'testFoo':
             //   #testFoo
             //   #testFooAndBar
-            if (methodName.matches(filter)) {
-                return true;
+            try {
+                if (methodName.matches(filter)) {
+                    return true;
+                }
+            } catch (PatternSyntaxException pse) {
+                // Ignore names that form a bad regex,
+                // like ones using a versioned parameter or module MyClass#myTest[foo-1.23]
             }
         }
         return false;
@@ -334,11 +340,15 @@ public class TestFilterHelper {
         }
         for (String filter : mExcludeFilters) {
             // The whole method name must match so user must pass .* on ends.
-            if (methodName.matches(filter)) {
-                return false;
+            try {
+                if (methodName.matches(filter)) {
+                    return false;
+                }
+            } catch (PatternSyntaxException pse) {
+                // Ignore names that form a bad regex,
+                // like ones using a versioned parameter or module MyClass#myTest[foo-1.23]
             }
         }
-
         return true;
     }
 }
diff --git a/src/com/android/tradefed/util/flag/DeviceFeatureFlag.java b/src/com/android/tradefed/util/flag/DeviceFeatureFlag.java
index adf54b858..867c4cde6 100644
--- a/src/com/android/tradefed/util/flag/DeviceFeatureFlag.java
+++ b/src/com/android/tradefed/util/flag/DeviceFeatureFlag.java
@@ -32,7 +32,7 @@ public class DeviceFeatureFlag {
     private final String flagValue;
 
     /**
-     * Constructor to create a new DeviceFeatureFlag object.
+     * Constructor to create a new DeviceFeatureFlag object with a flag string.
      *
      * @param flagString A device config flag string in the format of "namespace/flagName=flagValue"
      * @throws IllegalArgumentException if the flagString parameter cannot be parsed
@@ -48,6 +48,19 @@ public class DeviceFeatureFlag {
         flagValue = match.group("value");
     }
 
+    /**
+     * Constructor to create a new DeviceFeatureFlag object with flag attributes.
+     *
+     * @param namespace The namespace of a flag, in String format.
+     * @param flagName The name of a flag, in String format.
+     * @param flagValue The value of a flag, in String format.
+     */
+    public DeviceFeatureFlag(String namespace, String flagName, String flagValue) {
+        this.namespace = namespace;
+        this.flagName = flagName;
+        this.flagValue = flagValue;
+    }
+
     /**
      * Get the namespace of the DeviceFeatureFlag. E.g. "namespace" in flag string
      * "namespace/flagName=flagValue".
diff --git a/src/com/android/tradefed/util/image/DeviceImageTracker.java b/src/com/android/tradefed/util/image/DeviceImageTracker.java
index a94a8178c..6f3e0dc3e 100644
--- a/src/com/android/tradefed/util/image/DeviceImageTracker.java
+++ b/src/com/android/tradefed/util/image/DeviceImageTracker.java
@@ -150,7 +150,7 @@ public class DeviceImageTracker {
         }
         try {
             if (deviceImage.isDirectory()) {
-                CLog.d("Tracking device image as directory.");
+                CLog.d("Tracking device image as directory: %s", copyInCacheDeviceImage);
                 FileUtil.recursiveHardlink(deviceImage, copyInCacheDeviceImage);
             } else {
                 FileUtil.hardlinkFile(deviceImage, copyInCacheDeviceImage);
diff --git a/src/com/android/tradefed/util/image/IncrementalImageUtil.java b/src/com/android/tradefed/util/image/IncrementalImageUtil.java
index 44e567410..7db933701 100644
--- a/src/com/android/tradefed/util/image/IncrementalImageUtil.java
+++ b/src/com/android/tradefed/util/image/IncrementalImageUtil.java
@@ -19,10 +19,13 @@ import static org.junit.Assert.assertTrue;
 
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.device.DeviceDisconnectedException;
 import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.IManagedTestDevice;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.ITestDevice.RecoveryMode;
 import com.android.tradefed.device.SnapuserdWaitPhase;
+import com.android.tradefed.device.TestDeviceState;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
@@ -31,12 +34,16 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetr
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.invoker.tracing.TracePropagatingExecutorService;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.targetprep.FastbootDeviceFlasher;
+import com.android.tradefed.targetprep.FlashingResourcesParser;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.ZipUtil;
 import com.android.tradefed.util.ZipUtil2;
@@ -83,6 +90,8 @@ public class IncrementalImageUtil {
     private final ITestDevice mDevice;
     private final File mCreateSnapshotBinary;
     private final boolean mApplySnapshot;
+    private final boolean mWipeAfterApplySnapshot;
+    private boolean mNewFlow;
     private final SnapuserdWaitPhase mWaitPhase;
 
     private boolean mAllowSameBuildFlashing = false;
@@ -102,7 +111,10 @@ public class IncrementalImageUtil {
             File createSnapshot,
             boolean isIsolatedSetup,
             boolean allowCrossRelease,
+            MultiMap<String, String> allowedbranchTransition,
             boolean applySnapshot,
+            boolean wipeAfterApply,
+            boolean newFlow,
             SnapuserdWaitPhase waitPhase)
             throws DeviceNotAvailableException {
         // With apply snapshot, device reset is supported
@@ -110,11 +122,11 @@ public class IncrementalImageUtil {
             CLog.d("test is configured with isolation grade, doesn't support incremental yet.");
             return null;
         }
+        String serialNumber = device.getSerialNumber();
         FileCacheTracker tracker =
-                DeviceImageTracker.getDefaultCache()
-                        .getBaselineDeviceImage(device.getSerialNumber());
+                DeviceImageTracker.getDefaultCache().getBaselineDeviceImage(serialNumber);
         if (tracker == null) {
-            CLog.d("Not tracking current baseline image.");
+            CLog.d("Not tracking current baseline image for %s", serialNumber);
             return null;
         }
         String deviceBuildId = device.getBuildId();
@@ -127,8 +139,17 @@ public class IncrementalImageUtil {
             return null;
         }
         if (!tracker.branch.equals(build.getBuildBranch())) {
-            CLog.d("Newer build is not on the same branch.");
-            return null;
+            if (applySnapshot
+                    && wipeAfterApply
+                    && allowedbranchTransition.containsKey(tracker.branch)
+                    && allowedbranchTransition
+                            .get(tracker.branch)
+                            .contains(build.getBuildBranch())) {
+                CLog.d("Allowing transition from %s => %s", tracker.branch, build.getBuildBranch());
+            } else {
+                CLog.d("Newer build is not on the same branch.");
+                return null;
+            }
         }
         boolean crossRelease = false;
         if (!tracker.flavor.equals(build.getBuildFlavor())) {
@@ -150,9 +171,12 @@ public class IncrementalImageUtil {
 
         String splTarget = getSplVersion(build);
         String splBaseline = device.getProperty("ro.build.version.security_patch");
-        if (splTarget != null && !splBaseline.equals(splTarget)) {
-            CLog.d("Target SPL is '%s', while baseline is '%s", splTarget, splBaseline);
-            return null;
+        // When we wipe, do not consider security_patch
+        if (!wipeAfterApply) {
+            if (splTarget != null && !splBaseline.equals(splTarget)) {
+                CLog.d("Target SPL is '%s', while baseline is '%s", splTarget, splBaseline);
+                return null;
+            }
         }
         if (crossRelease) {
             InvocationMetricLogger.addInvocationMetrics(
@@ -188,6 +212,8 @@ public class IncrementalImageUtil {
                 build.getDeviceImageFile(),
                 createSnapshot,
                 applySnapshot,
+                wipeAfterApply,
+                newFlow,
                 waitPhase);
     }
 
@@ -199,12 +225,16 @@ public class IncrementalImageUtil {
             File targetImage,
             File createSnapshot,
             boolean applySnapshot,
+            boolean wipeAfterApply,
+            boolean newFlow,
             SnapuserdWaitPhase waitPhase) {
         mDevice = device;
         mSrcImage = deviceImage;
         mSrcBootloader = bootloader;
         mSrcBaseband = baseband;
         mApplySnapshot = applySnapshot;
+        mWipeAfterApplySnapshot = wipeAfterApply;
+        mNewFlow = newFlow;
         mWaitPhase = waitPhase;
 
         mTargetImage = targetImage;
@@ -299,6 +329,10 @@ public class IncrementalImageUtil {
         mAllowUnzipBaseline = true;
     }
 
+    public boolean useUpdatedFlow() {
+        return mNewFlow;
+    }
+
     /** Returns whether device is currently using snapshots or not. */
     public static boolean isSnapshotInUse(ITestDevice device) throws DeviceNotAvailableException {
         CommandResult dumpOutput = device.executeShellV2Command("snapshotctl dump");
@@ -309,6 +343,21 @@ public class IncrementalImageUtil {
         return true;
     }
 
+    public void updateDeviceWithNewFlow(File currentBootloader, File currentRadio)
+            throws DeviceNotAvailableException, TargetSetupError {
+        if (!mNewFlow || !mApplySnapshot || !mWipeAfterApplySnapshot) {
+            mNewFlow = false;
+            return;
+        }
+        // If device isn't online, we can't use the new flow
+        if (!TestDeviceState.ONLINE.equals(mDevice.getDeviceState())) {
+            mNewFlow = false;
+            return;
+        }
+        InvocationMetricLogger.addInvocationMetrics(InvocationMetricKey.INCREMENTAL_NEW_FLOW, 1);
+        updateDevice(currentBootloader, currentRadio);
+    }
+
     /** Updates the device using the snapshot logic. */
     public void updateDevice(File currentBootloader, File currentRadio)
             throws DeviceNotAvailableException, TargetSetupError {
@@ -362,7 +411,9 @@ public class IncrementalImageUtil {
         }
         // We need a few seconds after boot complete for update_engine to finish
         // TODO: we could improve by listening to some update_engine messages.
-        RunUtil.getDefault().sleep(5000L);
+        if (!mNewFlow) {
+            RunUtil.getDefault().sleep(5000L);
+        }
         File srcDirectory = mParallelSetup.getSrcDirectory();
         File targetDirectory = mParallelSetup.getTargetDirectory();
         File workDir = mParallelSetup.getWorkDir();
@@ -424,8 +475,11 @@ public class IncrementalImageUtil {
             CLog.d("stdout: %s, stderr: %s", listSnapshots.getStdout(), listSnapshots.getStderr());
 
             if (mApplySnapshot) {
-                CommandResult mapOutput =
-                        mDevice.executeShellV2Command("snapshotctl apply-update /data/ndb/");
+                String applyCommand = "snapshotctl apply-update /data/ndb/";
+                if (mWipeAfterApplySnapshot) {
+                    applyCommand += " -w";
+                }
+                CommandResult mapOutput = mDevice.executeShellV2Command(applyCommand);
                 CLog.d("stdout: %s, stderr: %s", mapOutput.getStdout(), mapOutput.getStderr());
                 if (!CommandStatus.SUCCESS.equals(mapOutput.getStatus())) {
                     InvocationMetricLogger.addInvocationMetrics(
@@ -451,8 +505,21 @@ public class IncrementalImageUtil {
                             InfraErrorIdentifier.INCREMENTAL_FLASHING_ERROR);
                 }
             }
+            mDevice.rebootIntoBootloader();
             if (mApplySnapshot) {
-                attemptBootloaderAndRadioFlashing(true, currentBootloader, currentRadio);
+                if (mWipeAfterApplySnapshot) {
+                    CommandResult cancelResults =
+                            mDevice.executeFastbootCommand("snapshot-update", "cancel");
+                    CLog.d("Cancel status: %s", cancelResults.getStatus());
+                    CLog.d("Cancel stdout: %s", cancelResults.getStdout());
+                    CLog.d("Cancel stderr: %s", cancelResults.getStderr());
+                    CommandResult wipeResults = mDevice.executeFastbootCommand("-w");
+                    CLog.d("wipe status: %s", wipeResults.getStatus());
+                    CLog.d("wipe stdout: %s", wipeResults.getStdout());
+                    CLog.d("wipe stderr: %s", wipeResults.getStderr());
+                }
+                updateBootloaderAndBasebandIfNeeded(
+                        targetDirectory, currentBootloader, currentRadio);
             }
             flashStaticPartition(targetDirectory);
             mSourceDirectory = srcDirectory;
@@ -519,7 +586,7 @@ public class IncrementalImageUtil {
                 return;
             }
             try (CloseableTraceScope ignored = new CloseableTraceScope("teardownDevice")) {
-                attemptBootloaderAndRadioFlashing(false, mSrcBootloader, mSrcBaseband);
+                revertBootloaderAndBasebandifNeeded(mSrcBootloader, mSrcBaseband);
                 if (mDevice.isStateBootloaderOrFastbootd()) {
                     mDevice.reboot();
                 }
@@ -535,7 +602,15 @@ public class IncrementalImageUtil {
                             InvocationMetricKey.INCREMENTAL_FLASHING_TEARDOWN_FAILURE, 1);
                 }
                 if (mSourceDirectory != null) {
-                    flashStaticPartition(mSourceDirectory);
+                    // flash all static partition in bootloader
+                    mDevice.rebootIntoBootloader();
+                    try {
+                        flashStaticPartition(mSourceDirectory);
+                    } catch (TargetSetupError e) {
+                        CLog.e(e);
+                        throw new DeviceDisconnectedException(
+                                e.getMessage(), e, mDevice.getSerialNumber());
+                    }
                 }
                 if (mSourceDirectory != null && mAllowUnzipBaseline) {
                     DeviceImageTracker.getDefaultCache()
@@ -572,10 +647,41 @@ public class IncrementalImageUtil {
         }
     }
 
-    private void attemptBootloaderAndRadioFlashing(
-            boolean forceFlashing, File bootloader, File baseband)
+    private void updateBootloaderAndBasebandIfNeeded(
+            File deviceImageUnzipped, File bootloader, File baseband)
+            throws DeviceNotAvailableException, TargetSetupError {
+        FlashingResourcesParser parser = new FlashingResourcesParser(deviceImageUnzipped);
+        if (bootloader == null) {
+            CLog.w("No bootloader file to flash.");
+        } else {
+            if (shouldFlashBootloader(mDevice, parser.getRequiredBootloaderVersion())) {
+                CommandResult bootloaderFlashTarget =
+                        mDevice.executeFastbootCommand(
+                                "flash", "bootloader", bootloader.getAbsolutePath());
+                CLog.d("Status: %s", bootloaderFlashTarget.getStatus());
+                CLog.d("stdout: %s", bootloaderFlashTarget.getStdout());
+                CLog.d("stderr: %s", bootloaderFlashTarget.getStderr());
+                mDevice.rebootIntoBootloader();
+            }
+        }
+        if (baseband == null) {
+            CLog.w("No baseband file to flash");
+        } else {
+            if (shouldFlashBaseband(mDevice, parser.getRequiredBasebandVersion())) {
+                CommandResult radioFlashTarget =
+                        mDevice.executeFastbootCommand(
+                                "flash", "radio", baseband.getAbsolutePath());
+                CLog.d("Status: %s", radioFlashTarget.getStatus());
+                CLog.d("stdout: %s", radioFlashTarget.getStdout());
+                CLog.d("stderr: %s", radioFlashTarget.getStderr());
+                mDevice.rebootIntoBootloader();
+            }
+        }
+    }
+
+    private void revertBootloaderAndBasebandifNeeded(File bootloader, File baseband)
             throws DeviceNotAvailableException {
-        if (mBootloaderNeedsFlashing || forceFlashing) {
+        if (mBootloaderNeedsFlashing) {
             if (bootloader == null) {
                 CLog.w("No bootloader file to flash.");
             } else {
@@ -589,7 +695,7 @@ public class IncrementalImageUtil {
                 CLog.d("stderr: %s", bootloaderFlashTarget.getStderr());
             }
         }
-        if (mBasebandNeedsFlashing || forceFlashing) {
+        if (mBasebandNeedsFlashing) {
             if (baseband == null) {
                 CLog.w("No baseband file to flash");
             } else {
@@ -629,9 +735,8 @@ public class IncrementalImageUtil {
         }
     }
 
-    private boolean flashStaticPartition(File imageDirectory) throws DeviceNotAvailableException {
-        // flash all static partition in bootloader
-        mDevice.rebootIntoBootloader();
+    private boolean flashStaticPartition(File imageDirectory)
+            throws DeviceNotAvailableException, TargetSetupError {
         Map<String, String> envMap = new HashMap<>();
         envMap.put("ANDROID_PRODUCT_OUT", imageDirectory.getAbsolutePath());
         CommandResult fastbootResult =
@@ -646,12 +751,45 @@ public class IncrementalImageUtil {
         if (!CommandStatus.SUCCESS.equals(fastbootResult.getStatus())) {
             return false;
         }
-        mDevice.waitForDeviceAvailable(5 * 60 * 1000L);
+        RecoveryMode recoveryMode = mDevice.getRecoveryMode();
+        try {
+            mDevice.setRecoveryMode(RecoveryMode.NONE);
+            ((IManagedTestDevice) mDevice).getMonitor().attachFinalState(TestDeviceState.RECOVERY);
+            boolean available = mDevice.waitForDeviceAvailable(5 * 60 * 1000L);
+            if (!available) {
+                if (mApplySnapshot) {
+                    if (TestDeviceState.RECOVERY.equals(mDevice.getDeviceState())) {
+                        InvocationMetricLogger.addInvocationMetrics(
+                                InvocationMetricKey.INCREMENTAL_RECOVERY_FALLBACK, 1);
+                        // Go back to bootloader for fallback flashing
+                        mDevice.rebootIntoBootloader();
+                        CommandResult result = mDevice.executeFastbootCommand("-w");
+                        CLog.d("wipe status: %s", result.getStatus());
+                        CLog.d("wipe stdout: %s", result.getStdout());
+                        CLog.d("wipe stderr: %s", result.getStderr());
+                        throw new TargetSetupError(
+                                "Device went to recovery unexpectedly",
+                                DeviceErrorIdentifier.DEVICE_UNEXPECTED_RESPONSE);
+                    }
+                } else {
+                    throw new DeviceNotAvailableException(
+                            "device did not become available after flashing.",
+                            mDevice.getSerialNumber(),
+                            DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
+                }
+            }
+        } finally {
+            mDevice.setRecoveryMode(recoveryMode);
+        }
         return true;
     }
 
     private void logPatchesInformation(File patchesDirectory) {
         for (File patch : patchesDirectory.listFiles()) {
+            if (patch == null) {
+                CLog.w("Something went wrong listing %s", patchesDirectory);
+                return;
+            }
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationGroupMetricKey.INCREMENTAL_FLASHING_PATCHES_SIZE,
                     patch.getName(),
@@ -661,6 +799,10 @@ public class IncrementalImageUtil {
 
     private void logTargetInformation(File targetDirectory) {
         for (File patch : targetDirectory.listFiles()) {
+            if (patch == null) {
+                CLog.w("Something went wrong listing target %s", targetDirectory);
+                return;
+            }
             if (DYNAMIC_PARTITIONS_TO_DIFF.contains(patch.getName())) {
                 InvocationMetricLogger.addInvocationMetrics(
                         InvocationGroupMetricKey.INCREMENTAL_FLASHING_TARGET_SIZE,
@@ -670,6 +812,32 @@ public class IncrementalImageUtil {
         }
     }
 
+    private boolean shouldFlashBootloader(ITestDevice device, String bootloaderVersion)
+            throws DeviceNotAvailableException, TargetSetupError {
+        String currentBootloaderVersion =
+                FastbootDeviceFlasher.fetchImageVersion(mRunUtil, device, "bootloader");
+        if (bootloaderVersion != null && !bootloaderVersion.equals(currentBootloaderVersion)) {
+            CLog.i("Flashing bootloader %s", bootloaderVersion);
+            return true;
+        } else {
+            CLog.i("Bootloader is already version %s, skipping flashing", currentBootloaderVersion);
+            return false;
+        }
+    }
+
+    private boolean shouldFlashBaseband(ITestDevice device, String basebandVersion)
+            throws DeviceNotAvailableException, TargetSetupError {
+        String currentBaseBandVersion =
+                FastbootDeviceFlasher.fetchImageVersion(mRunUtil, device, "baseband");
+        if (basebandVersion != null && !basebandVersion.equals(currentBaseBandVersion)) {
+            CLog.i("Flashing bootloader %s", basebandVersion);
+            return true;
+        } else {
+            CLog.i("Bootloader is already version %s, skipping flashing", currentBaseBandVersion);
+            return false;
+        }
+    }
+
     private static String getSplVersion(IBuildInfo build) {
         File buildProp = build.getFile("build.prop");
         if (buildProp == null) {
diff --git a/test_framework/Android.bp b/test_framework/Android.bp
index ed90fd660..1aee02151 100644
--- a/test_framework/Android.bp
+++ b/test_framework/Android.bp
@@ -30,6 +30,8 @@ tradefed_java_library_host {
         "perfetto_metrics-full",
         "test-composers",
         "truth",
+        "grpc-java-api",
+        "grpc-java-auth",
         "platformprotos",
     ],
     libs: [
diff --git a/test_framework/com/android/tradefed/targetprep/CdmaDeviceFlasher.java b/test_framework/com/android/tradefed/targetprep/CdmaDeviceFlasher.java
index 5da95e051..2a5fab9fa 100644
--- a/test_framework/com/android/tradefed/targetprep/CdmaDeviceFlasher.java
+++ b/test_framework/com/android/tradefed/targetprep/CdmaDeviceFlasher.java
@@ -155,10 +155,12 @@ public class CdmaDeviceFlasher extends FastbootDeviceFlasher {
         if (mShouldFlashBaseband) {
             // Unpack updater zip and flash partitions manually
             CLog.i("MANUALLY flashing individual partitions on %s.", device.getSerialNumber());
-            File updateDir = null;
+            File updateDir = deviceBuild.getDeviceImageFile();
             try {
-                // unzip
-                updateDir = extractSystemZip(deviceBuild);
+                if (updateDir == null || !updateDir.isDirectory()) {
+                    // unzip
+                    updateDir = extractSystemZip(deviceBuild);
+                }
 
                 // Expect updateDir to contain boot.img, recovery.img, system.img
                 flashNamedPartition(device, updateDir, "boot");
@@ -168,7 +170,7 @@ public class CdmaDeviceFlasher extends FastbootDeviceFlasher {
                 throw new TargetSetupError(String.format("Got IOException: %s", e.getMessage()),
                         device.getDeviceDescriptor());
             } finally {
-                if (updateDir != null) {
+                if (updateDir != null && !updateDir.equals(deviceBuild.getDeviceImageFile())) {
                     FileUtil.recursiveDelete(updateDir);
                     updateDir = null;
                 }
diff --git a/test_framework/com/android/tradefed/targetprep/FeatureFlagTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/FeatureFlagTargetPreparer.java
index 338200c56..b784153e3 100644
--- a/test_framework/com/android/tradefed/targetprep/FeatureFlagTargetPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/FeatureFlagTargetPreparer.java
@@ -15,17 +15,22 @@
  */
 package com.android.tradefed.targetprep;
 
+import static com.android.tradefed.testtype.suite.ITestSuite.BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY;
+import static com.android.tradefed.testtype.suite.ModuleDefinition.MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY;
+
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
-import com.android.tradefed.util.flag.DeviceFeatureFlag;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.flag.DeviceFeatureFlag;
 
 import com.google.common.base.Strings;
 
@@ -37,9 +42,11 @@ import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
 import java.util.stream.Collectors;
 
 /**
@@ -81,11 +88,13 @@ public class FeatureFlagTargetPreparer extends BaseTargetPreparer {
     private boolean mRebootBetweenFlagFiles = false;
 
     private final Map<String, Map<String, String>> mFlagsToRestore = new HashMap<>();
+    private final Set<DeviceFeatureFlag> mFlagsOverridden = new HashSet<>();
 
     @Override
     public void setUp(TestInformation testInformation)
             throws TargetSetupError, BuildError, DeviceNotAvailableException {
         ITestDevice device = testInformation.getDevice();
+        IInvocationContext context = testInformation.getContext();
         if (mFlagFiles.isEmpty() && mFlagValues.isEmpty()) {
             CLog.i("No flag-file or flag-value option provided, skipping");
             return;
@@ -132,6 +141,7 @@ public class FeatureFlagTargetPreparer extends BaseTargetPreparer {
                 continue; // No flags to update.
             }
             updateFlags(device, targetFlags);
+            updateContext(context, device);
             flagsUpdated = true;
             if (mRebootBetweenFlagFiles) {
                 device.reboot();
@@ -244,6 +254,23 @@ public class FeatureFlagTargetPreparer extends BaseTargetPreparer {
         }
     }
 
+    private void updateContext(IInvocationContext context, ITestDevice device) {
+        if (mFlagsOverridden.isEmpty()) {
+            return;
+        }
+        String flagsOverriddenString =
+                mFlagsOverridden.stream().map(f -> f.toString()).collect(Collectors.joining(" "));
+        if (!Strings.isNullOrEmpty(context.getAttribute(ModuleDefinition.MODULE_NAME))) {
+            // Add flags overridden to module invocation attribute, if module exists.
+            context.addInvocationAttribute(
+                    MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY, flagsOverriddenString);
+        } else {
+            // Add flags overridden to build info by default.
+            context.getBuildInfo(device)
+                    .addBuildAttribute(BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY, flagsOverriddenString);
+        }
+    }
+
     private void updateFlag(ITestDevice device, String namespace, String name, String value)
             throws DeviceNotAvailableException, TargetSetupError {
         if (Strings.isNullOrEmpty(value)) { // `device_config put` does not support empty values.
@@ -252,6 +279,7 @@ public class FeatureFlagTargetPreparer extends BaseTargetPreparer {
             runCommand(
                     device,
                     String.format("device_config put '%s' '%s' '%s'", namespace, name, value));
+            mFlagsOverridden.add(new DeviceFeatureFlag(namespace, name, value));
         }
     }
 
diff --git a/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java
index 08c1db9c1..b89b07f37 100644
--- a/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java
@@ -209,7 +209,12 @@ public class MixKernelTargetPreparer extends BaseTargetPreparer
         }
         File dstFile = new File(destDir, newFileName);
         CLog.i("Copy %s to %s", srcFile.toString(), dstFile.toString());
-        FileUtil.hardlinkFile(srcFile, dstFile);
+        // The device image can be a zip file or an uncompressed directory.
+        if (srcFile.isDirectory()) {
+            FileUtil.symlinkFile(srcFile, dstFile);
+        } else {
+            FileUtil.hardlinkFile(srcFile, dstFile);
+        }
     }
 
     /**
diff --git a/test_framework/com/android/tradefed/testtype/ArtRunTest.java b/test_framework/com/android/tradefed/testtype/ArtRunTest.java
index 69dbcec48..6038f1973 100644
--- a/test_framework/com/android/tradefed/testtype/ArtRunTest.java
+++ b/test_framework/com/android/tradefed/testtype/ArtRunTest.java
@@ -16,6 +16,8 @@
 
 package com.android.tradefed.testtype;
 
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
@@ -30,6 +32,7 @@ import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.testtype.coverage.CoverageOptions;
 import com.android.tradefed.util.AbiUtils;
 import com.android.tradefed.util.ArrayUtil;
 import com.android.tradefed.util.CommandResult;
@@ -60,7 +63,12 @@ import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
 /** A test runner to run ART run-tests. */
-public class ArtRunTest implements IRemoteTest, IAbiReceiver, ITestFilterReceiver, ITestCollector {
+public class ArtRunTest
+        implements IRemoteTest,
+                IAbiReceiver,
+                ITestFilterReceiver,
+                ITestCollector,
+                IConfigurationReceiver {
 
     private static final String RUNTEST_TAG = "ArtRunTest";
 
@@ -93,6 +101,7 @@ public class ArtRunTest implements IRemoteTest, IAbiReceiver, ITestFilterReceive
 
     private ITestDevice mDevice = null;
     private IAbi mAbi = null;
+    private IConfiguration mConfiguration = null;
     private final Set<String> mIncludeFilters = new LinkedHashSet<>();
     private final Set<String> mExcludeFilters = new LinkedHashSet<>();
 
@@ -120,6 +129,12 @@ public class ArtRunTest implements IRemoteTest, IAbiReceiver, ITestFilterReceive
         mIncludeFilters.add(filter);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+    }
+
     /** {@inheritDoc} */
     @Override
     public void addAllIncludeFilters(Set<String> filters) {
@@ -292,7 +307,7 @@ public class ArtRunTest implements IRemoteTest, IAbiReceiver, ITestFilterReceive
 
             // Check the test's exit code.
             Optional<String> exitCodeError = checkExitCode(exitCode);
-            exitCodeError.ifPresent(e -> errors.add(e));
+            exitCodeError.ifPresent(errors::add);
 
             // Check the test's standard output.
             Optional<String> stdoutError =
@@ -323,9 +338,11 @@ public class ArtRunTest implements IRemoteTest, IAbiReceiver, ITestFilterReceive
             }
 
             // If the test is a Checker test, run Checker and check its output.
-            if (mRunTestName.contains("-checker-")) {
+            // Do not run Checker tests in code coverage runs, as the Checker assumption might fail
+            // because of the added instrumentation code (see b/356852324).
+            if (mRunTestName.contains("-checker-") && !isJavaCoverageEnabled()) {
                 Optional<String> checkerError = executeCheckerTest(testInfo, listener);
-                checkerError.ifPresent(e -> errors.add(e));
+                checkerError.ifPresent(errors::add);
             }
 
             // Process potential errors.
@@ -351,6 +368,16 @@ public class ArtRunTest implements IRemoteTest, IAbiReceiver, ITestFilterReceive
         }
     }
 
+    /** Returns whether Java code coverage is enabled */
+    private boolean isJavaCoverageEnabled() {
+        return mConfiguration != null
+                && mConfiguration.getCoverageOptions().isCoverageEnabled()
+                && mConfiguration
+                        .getCoverageOptions()
+                        .getCoverageToolchains()
+                        .contains(CoverageOptions.Toolchain.JACOCO);
+    }
+
     /**
      * Create a local temporary directory within the test's dependencies folder, to collect test
      * outputs pulled from the device-under-test.
diff --git a/test_framework/com/android/tradefed/testtype/GTestBase.java b/test_framework/com/android/tradefed/testtype/GTestBase.java
index e21295e37..78acce987 100644
--- a/test_framework/com/android/tradefed/testtype/GTestBase.java
+++ b/test_framework/com/android/tradefed/testtype/GTestBase.java
@@ -25,6 +25,7 @@ import com.android.tradefed.config.OptionCopier;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.util.ArrayUtil;
 import com.android.tradefed.util.FileUtil;
 
@@ -64,6 +65,11 @@ public abstract class GTestBase
     @Option(name = "run-disable-tests", description = "Determine to run disable tests or not.")
     private boolean mRunDisabledTests = false;
 
+    @Option(
+            name = "collect-disable-tests",
+            description = "Determine to collect disable tests or not.")
+    private boolean mCollectDisabledTests = false;
+
     @Option(name = "module-name", description = "The name of the native test module to run.")
     private String mTestModule = null;
 
@@ -643,7 +649,8 @@ public abstract class GTestBase
     IShellOutputReceiver createResultParser(String runName, ITestInvocationListener listener) {
         IShellOutputReceiver receiver = null;
         if (mCollectTestsOnly) {
-            GTestListTestParser resultParser = new GTestListTestParser(runName, listener);
+            GTestListTestParser resultParser =
+                    new GTestListTestParser(runName, listener, mCollectDisabledTests);
             resultParser.setPrependFileName(mPrependFileName);
             receiver = resultParser;
         } else {
@@ -807,11 +814,14 @@ public abstract class GTestBase
      * reports duplicate tests if mDisabledDuplicateCheck is false. Otherwise, returns the passed-in
      * listener.
      */
-    protected ITestInvocationListener getGTestListener(ITestInvocationListener listener) {
+    protected ITestInvocationListener getGTestListener(ITestInvocationListener... listeners) {
+        ITestInvocationListener listener = null;
         if (mTestCaseTimeout.toMillis() > 0L) {
             listener =
                     new TestTimeoutEnforcer(
-                            mTestCaseTimeout.toMillis(), TimeUnit.MILLISECONDS, listener);
+                            mTestCaseTimeout.toMillis(), TimeUnit.MILLISECONDS, listeners);
+        } else {
+            listener = new ResultForwarder(listeners);
         }
         if (mDisableDuplicateCheck) {
             return listener;
diff --git a/test_framework/com/android/tradefed/testtype/GTestListTestParser.java b/test_framework/com/android/tradefed/testtype/GTestListTestParser.java
index 23ddc74d4..5456dcd0f 100644
--- a/test_framework/com/android/tradefed/testtype/GTestListTestParser.java
+++ b/test_framework/com/android/tradefed/testtype/GTestListTestParser.java
@@ -26,6 +26,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 /**
  * A result parser for gtest dry run mode with "--gtest_list_tests" parameter.
  *
@@ -53,6 +54,8 @@ public class GTestListTestParser extends MultiLineReceiver {
     /** Track if we have already reported {@link #done()} */
     private boolean mIsDone = false;
 
+    private boolean mCollectDisabledTests = false;
+
     /**
      * Creates the GTestListTestParser for a single listener.
      *
@@ -67,6 +70,22 @@ public class GTestListTestParser extends MultiLineReceiver {
         setTrimLine(false);
     }
 
+    /**
+     * Creates the GTestListTestParser for a single listener.
+     *
+     * @param testRunName the test run name to provide to {@link
+     *     ITestInvocationListener#testRunStarted(String, int)}
+     * @param listener informed of test results as the tests are executing
+     * @param shouldCollectDisabledTest collect disabled tests or not
+     */
+    public GTestListTestParser(
+            String testRunName,
+            ITestInvocationListener listener,
+            boolean shouldCollectDisabledTest) {
+        this(testRunName, listener);
+        mCollectDisabledTests = shouldCollectDisabledTest;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -108,8 +127,11 @@ public class GTestListTestParser extends MultiLineReceiver {
                         "parsed new test case name %s but no test class name has been set", line));
             }
             // Test method name found
-            mTests.add(
-                    new TestDescription(getTestClass(mLastTestClassName), methodMatcher.group(1)));
+            if (!methodMatcher.group(1).startsWith("DISABLED_") || mCollectDisabledTests) {
+                mTests.add(
+                        new TestDescription(
+                                getTestClass(mLastTestClassName), methodMatcher.group(1)));
+            }
         } else {
             CLog.v("line ignored: %s", line);
         }
diff --git a/test_framework/com/android/tradefed/testtype/HostGTest.java b/test_framework/com/android/tradefed/testtype/HostGTest.java
index caee08b40..bdc57e77f 100644
--- a/test_framework/com/android/tradefed/testtype/HostGTest.java
+++ b/test_framework/com/android/tradefed/testtype/HostGTest.java
@@ -22,12 +22,15 @@ import com.android.ddmlib.IShellOutputReceiver;
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.DeviceBuildInfo;
 import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.invoker.TestInvocation;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.log.ITestLogger;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
@@ -35,8 +38,10 @@ import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.TestRunResultListener;
 import com.android.tradefed.result.error.TestErrorIdentifier;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
+import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.ClangProfileIndexer;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
@@ -46,6 +51,8 @@ import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.ShellOutputReceiverStream;
 import com.android.tradefed.util.TestRunnerUtil;
 
+import com.google.common.base.Strings;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -73,12 +80,26 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
             description = "Whether to use the updated logic for retry with sharding.")
     private boolean mUseUpdatedShardRetry = true;
 
+    @Option(
+            name = "enable-cache",
+            description = "Used to enable/disable caching for specific modules.")
+    private boolean mEnableCache = false;
+
+    @Option(
+            name = "inherit-env-vars",
+            description =
+                    "Whether the subprocess should inherit environment variables from the main"
+                            + " process.")
+    private boolean mInheritEnvVars = true;
+
     /** Whether any incomplete test is found in the current run. */
     private boolean mIncompleteTestFound = false;
 
     /** List of tests that failed in the current test run when test run was complete. */
     private Set<String> mCurFailedTests = new LinkedHashSet<>();
 
+    private TestRunResultListener mTestRunResultListener;
+
     @Override
     public void setBuild(IBuildInfo buildInfo) {
         this.mBuildInfo = buildInfo;
@@ -115,7 +136,7 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
             long timeoutMs,
             IShellOutputReceiver receiver,
             ITestLogger logger) {
-        RunUtil runUtil = new RunUtil();
+        RunUtil runUtil = new RunUtil(mInheritEnvVars);
         String[] cmds = cmd.split("\\s+");
 
         if (getShardCount() > 0) {
@@ -133,10 +154,16 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
         // Set the working dir to the folder containing the binary to execute from the same path.
         runUtil.setWorkingDir(gtestFile.getParentFile());
 
+        String instanceName =
+                mEnableCache
+                        ? getConfiguration().getCommandOptions().getRemoteCacheInstanceName()
+                        : null;
+
         String separator = System.getProperty("path.separator");
         List<String> paths = new ArrayList<>();
-        paths.add(System.getenv("PATH"));
-        paths.add(gtestFile.getParentFile().getAbsolutePath());
+        paths.add("/usr/bin");
+        paths.add("/usr/sbin");
+        paths.add(".");
         String path = paths.stream().distinct().collect(Collectors.joining(separator));
         CLog.d("Using updated $PATH: %s", path);
         runUtil.setEnvVariablePriority(EnvPriority.SET);
@@ -165,13 +192,19 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
         // command output will just be ignored.
         CommandResult result = null;
         File stdout = null;
+        ICacheClient cacheClient =
+                Strings.isNullOrEmpty(instanceName)
+                        ? null
+                        : getCacheClient(CurrentInvocation.getWorkFolder(), instanceName);
         try {
             stdout =
                     FileUtil.createTempFile(
                             String.format("%s-output", gtestFile.getName()), ".txt");
             try (ShellOutputReceiverStream stream =
                     new ShellOutputReceiverStream(receiver, new FileOutputStream(stdout))) {
-                result = runUtil.runTimedCmd(timeoutMs, stream, null, cmds);
+                result =
+                        runUtil.runTimedCmdWithOutputMonitor(
+                                timeoutMs, 0, stream, null, cacheClient, cmds);
             } catch (IOException e) {
                 throw new RuntimeException(
                         "Should never happen, ShellOutputReceiverStream.close is a no-op", e);
@@ -200,6 +233,12 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
                             source);
                 }
             }
+            if (!result.isCached()
+                    && !mTestRunResultListener.isTestRunFailed(gtestFile.getName())) {
+                runUtil.uploadCache(
+                        cacheClient,
+                        ExecutableActionResult.create(result.getExitCode(), stdout, null));
+            }
             FileUtil.deleteFile(stdout);
 
             if (isClangCoverageEnabled()) {
@@ -310,6 +349,7 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
     public void run(TestInformation testInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException { // DNAE is part of IRemoteTest.
         try {
+            mTestRunResultListener = new TestRunResultListener();
             // Reset flags that are used to track results of current test run.
             mIncompleteTestFound = false;
             mCurFailedTests = new LinkedHashSet<>();
@@ -368,7 +408,7 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
                     continue;
                 }
 
-                listener = getGTestListener(listener);
+                listener = getGTestListener(listener, mTestRunResultListener);
                 // TODO: Need to support XML test output based on isEnableXmlOutput
                 IShellOutputReceiver resultParser =
                         createResultParser(gTestFile.getName(), listener);
@@ -463,4 +503,8 @@ public class HostGTest extends GTestBase implements IBuildReceiver {
         return getConfiguration().getCoverageOptions().isCoverageEnabled()
                 && getConfiguration().getCoverageOptions().getCoverageToolchains().contains(CLANG);
     }
+
+    ICacheClient getCacheClient(File workFolder, String instanceName) {
+        return CacheClientFactory.createCacheClient(workFolder, instanceName);
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/InstrumentationTest.java b/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
index 15b499e78..7affdc415 100644
--- a/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
+++ b/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
@@ -22,7 +22,6 @@ import static com.google.common.base.Preconditions.checkState;
 import com.android.ddmlib.IDevice;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner.TestSize;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
@@ -51,6 +50,7 @@ import com.android.tradefed.result.TestRunResult;
 import com.android.tradefed.result.TestStatus;
 import com.android.tradefed.result.ddmlib.AndroidTestOrchestratorRemoteTestRunner;
 import com.android.tradefed.result.ddmlib.DefaultRemoteAndroidTestRunner;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
diff --git a/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java b/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
index 82f31c9f3..185a76165 100644
--- a/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
@@ -17,6 +17,9 @@ package com.android.tradefed.testtype;
 
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.cache.ExecutableAction;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
@@ -40,20 +43,29 @@ import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.result.proto.FileProtoResultReporter;
+import com.android.tradefed.result.proto.ProtoResultParser;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
+import com.android.tradefed.result.proto.TestRecordProto.TestRecord;
+import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.ResourceUtil;
+import com.android.tradefed.util.RunInterruptedException;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.StreamUtil;
 import com.android.tradefed.util.SystemUtil;
+import com.android.tradefed.util.proto.TestRecordProtoUtil;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.InputStream;
 import java.lang.ProcessBuilder.Redirect;
 import java.net.ServerSocket;
 import java.net.Socket;
@@ -67,7 +79,9 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
@@ -180,7 +194,20 @@ public class IsolatedHostTest
                             + "the Java command line.")
     private boolean mRavenwoodResources = false;
 
+    @Option(
+            name = "enable-cache",
+            description = "Used to enable/disable caching for specific modules.")
+    private boolean mEnableCache = false;
+
+    @Option(
+            name = "inherit-env-vars",
+            description =
+                    "Whether the subprocess should inherit environment variables from the main"
+                            + " process.")
+    private boolean mInheritEnvVars = true;
+
     private static final String QUALIFIED_PATH = "/com/android/tradefed/isolation";
+    private static final String ISOLATED_JAVA_LOG = "isolated-java-logs";
     private IBuildInfo mBuildInfo;
     private Set<String> mIncludeFilters = new HashSet<>();
     private Set<String> mExcludeFilters = new HashSet<>();
@@ -200,6 +227,8 @@ public class IsolatedHostTest
 
     private File mCoverageExecFile;
 
+    private boolean mCached = false;
+
     public void setDebug(boolean debug) {
         this.debug = debug;
     }
@@ -211,35 +240,144 @@ public class IsolatedHostTest
         mReportedFailure = false;
         Process isolationRunner = null;
         File artifactsDir = null;
+        mCached = false;
 
         try {
+            File workFolder = CurrentInvocation.getWorkFolder();
+            String instanceName =
+                    mEnableCache ? mConfig.getCommandOptions().getRemoteCacheInstanceName() : null;
+            ICacheClient cacheClient =
+                    Strings.isNullOrEmpty(instanceName)
+                            ? null
+                            : getCacheClient(workFolder, instanceName);
+
+            // Note the below chooses a working directory based on the jar that happens to
+            // be first in the list of configured jars.  The baked-in assumption is that
+            // all configured jars are in the same parent directory, otherwise the behavior
+            // here is non-deterministic.
+            mWorkDir = findJarDirectory();
+
             mServer = new ServerSocket(0);
             if (!this.debug) {
                 mServer.setSoTimeout(mSocketTimeout);
             }
             artifactsDir = FileUtil.createTempDir("robolectric-screenshot-artifacts");
-            String classpath = this.compileClassPath();
-            List<String> cmdArgs = this.compileCommandArgs(classpath, artifactsDir);
+            Set<File> classpathFiles = this.getClasspathFiles();
+            if (cacheClient != null) {
+                Map<String, File> nameToSymlink = new HashMap<>();
+                for (File f : classpathFiles) {
+                    if (nameToSymlink.containsKey(f.getName())) {
+                        throw new RuntimeException(
+                                "Jar files with same name have not been supported when caching is"
+                                        + " enabled. Please file a feature request!");
+                    }
+                    nameToSymlink.put(f.getName(), linkFileToWorkingDir("classpath", f));
+                }
+                classpathFiles = new HashSet<>(nameToSymlink.values());
+            }
+            String classpath = this.compileClassPath(classpathFiles);
+            List<String> cmdArgs =
+                    this.compileCommand(classpath, artifactsDir, cacheClient != null);
             CLog.v(String.join(" ", cmdArgs));
-            RunUtil runner = new RunUtil();
+            RunUtil runner = new RunUtil(mInheritEnvVars);
 
             String ldLibraryPath = this.compileLdLibraryPath();
             if (ldLibraryPath != null) {
                 runner.setEnvVariable("LD_LIBRARY_PATH", ldLibraryPath);
             }
 
-            // Note the below chooses a working directory based on the jar that happens to
-            // be first in the list of configured jars.  The baked-in assumption is that
-            // all configured jars are in the same parent directory, otherwise the behavior
-            // here is non-deterministic.
-            mWorkDir = findJarDirectory();
             runner.setWorkingDir(mWorkDir);
             CLog.v("Using PWD: %s", mWorkDir.getAbsolutePath());
 
             mSubprocessLog = FileUtil.createTempFile("subprocess-logs", "");
             runner.setRedirectStderrToStdout(true);
 
-            isolationRunner = runner.runCmdInBackground(Redirect.to(mSubprocessLog), cmdArgs);
+            List<String> testJarAbsPaths = getJarPaths(mJars, cacheClient != null);
+            TestParameters.Builder paramsBuilder =
+                    TestParameters.newBuilder()
+                            .addAllTestClasses(new TreeSet(mClasses))
+                            .addAllTestJarAbsPaths(testJarAbsPaths)
+                            .addAllExcludePaths(new TreeSet(mExcludePaths))
+                            .setDryRun(mCollectTestsOnly);
+
+            if (!mIncludeFilters.isEmpty()
+                    || !mExcludeFilters.isEmpty()
+                    || !mIncludeAnnotations.isEmpty()
+                    || !mExcludeAnnotations.isEmpty()) {
+                paramsBuilder.setFilter(
+                        FilterSpec.newBuilder()
+                                .addAllIncludeFilters(new TreeSet(mIncludeFilters))
+                                .addAllExcludeFilters(new TreeSet(mExcludeFilters))
+                                .addAllIncludeAnnotations(new TreeSet(mIncludeAnnotations))
+                                .addAllExcludeAnnotations(new TreeSet(mExcludeAnnotations)));
+            }
+
+            RunnerMessage runnerMessage =
+                    RunnerMessage.newBuilder()
+                            .setCommand(RunnerOp.RUNNER_OP_RUN_TEST)
+                            .setParams(paramsBuilder.build())
+                            .build();
+
+            ProcessBuilder processBuilder =
+                    runner.createProcessBuilder(Redirect.to(mSubprocessLog), cmdArgs, false);
+
+            ExecutableAction action = null;
+            ExecutableActionResult actionResult = null;
+            if (cacheClient != null) {
+                try {
+                    action =
+                            ExecutableAction.create(
+                                    processBuilder.directory(),
+                                    Arrays.asList(runnerMessage.toString()),
+                                    processBuilder.environment(),
+                                    mSocketTimeout);
+                    actionResult = cacheClient.lookupCache(action);
+                    if (actionResult != null) {
+                        CLog.d(
+                                "Cache is hit with action:\n"
+                                        + "%s\n"
+                                        + "runner configuration:\n"
+                                        + "%s\n"
+                                        + "environment:\n"
+                                        + "%s",
+                                action.action(),
+                                runnerMessage.toString(),
+                                processBuilder.environment());
+                        ProtoResultParser parser =
+                                new ProtoResultParser(
+                                        listener, testInfo.getContext(), false, "cached-");
+                        parser.setMergeInvocationContext(false);
+                        TestRecord record = TestRecordProtoUtil.readFromFile(actionResult.stdOut());
+                        parser.processFinalizedProto(record);
+                        // TODO(b/357695016): Use output dir for subprocess log instead of the field
+                        // for stderr.
+                        try (FileInputStreamSource source =
+                                new FileInputStreamSource(actionResult.stdErr())) {
+                            listener.testLog(ISOLATED_JAVA_LOG, LogDataType.TEXT, source);
+                        }
+                        mCached = true;
+                        return;
+                    }
+                    CLog.d(
+                            "Caching action:\n%s\nwith runner configuration:\n%s\nenvironment:\n%s",
+                            action.action(),
+                            runnerMessage.toString(),
+                            processBuilder.environment());
+                } catch (IOException e) {
+                    CLog.e("Failed to lookup cache!");
+                    CLog.e(e);
+                } catch (InterruptedException e) {
+                    throw new RunInterruptedException(
+                            e.getMessage(), e, InfraErrorIdentifier.UNDETERMINED);
+                } finally {
+                    if (actionResult != null) {
+                        FileUtil.deleteFile(actionResult.stdOut());
+                        FileUtil.deleteFile(actionResult.stdErr());
+                    }
+                }
+            }
+
+            isolationRunner = processBuilder.start();
             CLog.v("Started subprocess.");
 
             if (this.debug) {
@@ -254,27 +392,39 @@ public class IsolatedHostTest
             }
             CLog.v("Connected to subprocess.");
 
-            List<String> testJarAbsPaths = getJarPaths(mJars);
+            File cacheResults = null;
+            FileProtoResultReporter protoResultReporter = null;
+            if (cacheClient != null && action != null) {
+                cacheResults =
+                        FileUtil.createTempFile("results-to-upload", ".textproto", workFolder);
+                cacheResults.deleteOnExit();
+                protoResultReporter = new FileProtoResultReporter();
+                protoResultReporter.setFileOutput(cacheResults);
+                // Call invocationStarted since the proto machinery doesn't work well without it.
+                protoResultReporter.invocationStarted(testInfo.getContext());
+                listener = new ResultForwarder(List.of(listener, protoResultReporter));
+            }
 
-            TestParameters.Builder paramsBuilder =
-                    TestParameters.newBuilder()
-                            .addAllTestClasses(mClasses)
-                            .addAllTestJarAbsPaths(testJarAbsPaths)
-                            .addAllExcludePaths(mExcludePaths)
-                            .setDryRun(mCollectTestsOnly);
+            boolean runSuccess = executeTests(socket, listener, runnerMessage);
 
-            if (!mIncludeFilters.isEmpty()
-                    || !mExcludeFilters.isEmpty()
-                    || !mIncludeAnnotations.isEmpty()
-                    || !mExcludeAnnotations.isEmpty()) {
-                paramsBuilder.setFilter(
-                        FilterSpec.newBuilder()
-                                .addAllIncludeFilters(mIncludeFilters)
-                                .addAllExcludeFilters(mExcludeFilters)
-                                .addAllIncludeAnnotations(mIncludeAnnotations)
-                                .addAllExcludeAnnotations(mExcludeAnnotations));
+            if (cacheClient != null && action != null && cacheResults != null && runSuccess) {
+                // It should not matter what we provide here since invocation-level reporting is not
+                // being done.
+                protoResultReporter.invocationEnded(1000);
+                try {
+                    CLog.d("Uploading cache for action: %s", action.action());
+                    // TODO(b/357695016): Use output dir for subprocess log instead of the field
+                    // for stderr.
+                    cacheClient.uploadCache(
+                            action, ExecutableActionResult.create(0, cacheResults, mSubprocessLog));
+                } catch (IOException e) {
+                    CLog.e("Failed to upload cache!");
+                    CLog.e(e);
+                } catch (InterruptedException e) {
+                    throw new RunInterruptedException(
+                            e.getMessage(), e, InfraErrorIdentifier.UNDETERMINED);
+                }
             }
-            executeTests(socket, listener, paramsBuilder.build());
 
             RunnerMessage.newBuilder()
                     .setCommand(RunnerOp.RUNNER_OP_STOP)
@@ -290,6 +440,7 @@ public class IsolatedHostTest
                 listener.testRunEnded(0L, new HashMap<String, Metric>());
             }
         } finally {
+            FileUtil.deleteFile(mSubprocessLog);
             try {
                 // Ensure the subprocess finishes
                 if (isolationRunner != null) {
@@ -334,23 +485,30 @@ public class IsolatedHostTest
 
     /** Assembles the command arguments to execute the subprocess runner. */
     public List<String> compileCommandArgs(String classpath, File artifactsDir) {
+        return compileCommand(classpath, artifactsDir, false);
+    }
+
+    private List<String> compileCommand(String classpath, File artifactsDir, boolean enableCache) {
         List<String> cmdArgs = new ArrayList<>();
 
+        File javaExec;
         if (mJdkFolder == null) {
-            cmdArgs.add(SystemUtil.getRunningJavaBinaryPath().getAbsolutePath());
+            javaExec = SystemUtil.getRunningJavaBinaryPath();
             CLog.v("Using host java version.");
         } else {
-            File javaExec = FileUtil.findFile(mJdkFolder, "java");
+            javaExec = FileUtil.findFile(mJdkFolder, "java");
             if (javaExec == null) {
                 throw new IllegalArgumentException(
                         String.format(
                                 "Couldn't find java executable in given JDK folder: %s",
                                 mJdkFolder.getAbsolutePath()));
             }
-            String javaPath = javaExec.getAbsolutePath();
-            cmdArgs.add(javaPath);
-            CLog.v("Using java executable at %s", javaPath);
+            CLog.v("Using java executable at %s", javaExec.getAbsolutePath());
         }
+        if (enableCache) {
+            javaExec = linkFileToWorkingDir("java_binary", javaExec);
+        }
+        cmdArgs.add(javaExec.getAbsolutePath());
         if (isCoverageEnabled()) {
             if (mConfig.getCoverageOptions().getJaCoCoAgentPath() != null) {
                 try {
@@ -485,21 +643,34 @@ public class IsolatedHostTest
      * @return a string specifying the colon separated classpath.
      */
     public String compileClassPath() {
+        return compileClassPath(getClasspathFiles());
+    }
+
+    private String compileClassPath(Set<File> paths) {
+        return String.join(
+                java.io.File.pathSeparator,
+                getClasspathFiles().stream()
+                        .map(f -> f.getAbsolutePath())
+                        .collect(Collectors.toList()));
+    }
+
+    private Set<File> getClasspathFiles() {
         // Use LinkedHashSet because we don't want duplicates, but we still
         // want to preserve the insertion order. e.g. mIsolationJar should always be the
         // first one.
-        Set<String> paths = new LinkedHashSet<>();
+        Set<File> paths = new LinkedHashSet<>();
         File testDir = findTestDirectory();
 
         try {
             mIsolationJar = getIsolationJar(CurrentInvocation.getWorkFolder());
-            paths.add(mIsolationJar.getAbsolutePath());
+            paths.add(mIsolationJar);
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
 
         if (mClasspathOverride != null) {
-            paths.add(mClasspathOverride);
+            Arrays.asList(mClasspathOverride.split(java.io.File.pathSeparator)).stream()
+                    .forEach(p -> paths.add(new File(p)));
         } else {
             if (mRobolectricResources) {
                 // This is contingent on the current android-all version.
@@ -509,7 +680,7 @@ public class IsolatedHostTest
                             "Could not find android-all jar needed for test execution.",
                             InfraErrorIdentifier.ARTIFACT_NOT_FOUND);
                 }
-                paths.add(androidAllJar.getAbsolutePath());
+                paths.add(androidAllJar);
             } else if (mRavenwoodResources) {
                 addAllFilesUnder(paths, getRavenwoodRuntimeDir(testDir));
             }
@@ -517,24 +688,22 @@ public class IsolatedHostTest
             for (String jar : mJars) {
                 File f = FileUtil.findFile(testDir, jar);
                 if (f != null && f.exists()) {
-                    paths.add(f.getAbsolutePath());
+                    paths.add(f);
                     addAllFilesUnder(paths, f.getParentFile());
                 }
             }
         }
 
-        String jarClasspath = String.join(java.io.File.pathSeparator, paths);
-
-        return jarClasspath;
+        return paths;
     }
 
     /** Add all files under {@code File} sorted by filename to {@code paths}. */
-    private static void addAllFilesUnder(Set<String> paths, File parentDirectory) {
+    private static void addAllFilesUnder(Set<File> paths, File parentDirectory) {
         var files = parentDirectory.listFiles((f) -> f.isFile());
         Arrays.sort(files, Comparator.comparing(File::getName));
 
         for (File file : files) {
-            paths.add(file.getAbsolutePath());
+            paths.add(file);
         }
     }
 
@@ -543,6 +712,11 @@ public class IsolatedHostTest
         return System.getenv(key);
     }
 
+    @VisibleForTesting
+    void setWorkDir(File workDir) {
+        mWorkDir = workDir;
+    }
+
     /**
      * Return LD_LIBRARY_PATH for tests that require native library.
      *
@@ -599,7 +773,7 @@ public class IsolatedHostTest
         // add it to LD_LIBRARY_PATH.
         String libs[] = {"lib", "lib64"};
 
-        Set<String> result = new LinkedHashSet<>();
+        Set<File> result = new LinkedHashSet<>();
 
         for (String dir : dirs) {
             File path = new File(dir);
@@ -611,14 +785,17 @@ public class IsolatedHostTest
                 File libFile = new File(path, lib);
 
                 if (libFile.isDirectory()) {
-                    result.add(libFile.getAbsolutePath());
+                    result.add(libFile);
                 }
             }
         }
         if (result.isEmpty()) {
             return null;
         }
-        return String.join(java.io.File.pathSeparator, result);
+        return result.stream()
+                .map(f -> RunUtil.toRelative(mWorkDir, f))
+                .sorted()
+                .collect(Collectors.joining(java.io.File.pathSeparator));
     }
 
     private List<String> compileRobolectricOptions(File artifactsDir) {
@@ -638,7 +815,7 @@ public class IsolatedHostTest
         }
         options.add("-Drobolectric.offline=true");
         options.add("-Drobolectric.logging=stdout");
-        options.add("-Drobolectric.resourcesMode=binary");
+        options.add("-Drobolectric.resourcesMode=BINARY");
         options.add("-Drobolectric.usePreinstrumentedJars=false");
         // TODO(rexhoffman) figure out how to get the local conscrypt working - shared objects and
         // such.
@@ -655,178 +832,165 @@ public class IsolatedHostTest
      *
      * @param socket A socket connected to the subprocess control socket
      * @param listener The TradeFed invocation listener from run()
-     * @param params The tests to run and their options
+     * @param runnerMessage The configuration proto message used by the runner to run the test
+     * @return True if the test execution succeeds, otherwise False
      * @throws IOException
      */
-    private void executeTests(
-            Socket socket, ITestInvocationListener listener, TestParameters params)
+    private boolean executeTests(
+            Socket socket, ITestInvocationListener listener, RunnerMessage runnerMessage)
             throws IOException {
         // If needed apply the wrapping listeners like timeout enforcer.
         listener = wrapListener(listener);
-        RunnerMessage.newBuilder()
-                .setCommand(RunnerOp.RUNNER_OP_RUN_TEST)
-                .setParams(params)
-                .build()
-                .writeDelimitedTo(socket.getOutputStream());
+        runnerMessage.writeDelimitedTo(socket.getOutputStream());
 
-        TestDescription currentTest = null;
         Instant start = Instant.now();
+        try {
+            return processRunnerReply(socket.getInputStream(), listener);
+        } catch (SocketTimeoutException e) {
+            mReportedFailure = true;
+            FailureDescription failure =
+                    FailureDescription.create(
+                            StreamUtil.getStackTrace(e), FailureStatus.INFRA_FAILURE);
+            listener.testRunFailed(failure);
+            listener.testRunEnded(
+                    Duration.between(start, Instant.now()).toMillis(),
+                    new HashMap<String, Metric>());
+            return false;
+        } finally {
+            // This will get associated with the module since it can contains several test runs
+            try (FileInputStreamSource source = new FileInputStreamSource(mSubprocessLog)) {
+                listener.testLog(ISOLATED_JAVA_LOG, LogDataType.TEXT, source);
+            }
+        }
+    }
+
+    private boolean processRunnerReply(InputStream input, ITestInvocationListener listener)
+            throws IOException {
+        TestDescription currentTest = null;
         CloseableTraceScope methodScope = null;
         CloseableTraceScope runScope = null;
         boolean runStarted = false;
-        try {
-            mainLoop:
-            while (true) {
-                try {
-                    RunnerReply reply = RunnerReply.parseDelimitedFrom(socket.getInputStream());
-                    if (reply == null) {
-                        if (currentTest != null) {
-                            // Subprocess has hard crashed
-                            listener.testFailed(currentTest, "Subprocess died unexpectedly.");
-                            listener.testEnded(
-                                    currentTest,
-                                    System.currentTimeMillis(),
-                                    new HashMap<String, Metric>());
-                        }
-                        // Try collecting the hs_err logs that the JVM dumps when it segfaults.
-                        List<File> logFiles =
-                                Arrays.stream(mWorkDir.listFiles())
-                                        .filter(
-                                                f ->
-                                                        f.getName().startsWith("hs_err")
-                                                                && f.getName().endsWith(".log"))
-                                        .collect(Collectors.toList());
-
-                        if (!runStarted) {
-                            listener.testRunStarted(this.getClass().getCanonicalName(), 0);
-                        }
-                        for (File f : logFiles) {
-                            try (FileInputStreamSource source =
-                                    new FileInputStreamSource(f, true)) {
-                                listener.testLog("hs_err_log-VM-crash", LogDataType.TEXT, source);
-                            }
-                        }
-                        mReportedFailure = true;
-                        FailureDescription failure =
-                                FailureDescription.create(
-                                                "The subprocess died unexpectedly.",
-                                                FailureStatus.TEST_FAILURE)
-                                        .setFullRerun(false);
-                        listener.testRunFailed(failure);
-                        listener.testRunEnded(0L, new HashMap<String, Metric>());
-                        break mainLoop;
+        boolean success = true;
+        while (true) {
+            RunnerReply reply = RunnerReply.parseDelimitedFrom(input);
+            if (reply == null) {
+                if (currentTest != null) {
+                    // Subprocess has hard crashed
+                    listener.testFailed(currentTest, "Subprocess died unexpectedly.");
+                    listener.testEnded(
+                            currentTest, System.currentTimeMillis(), new HashMap<String, Metric>());
+                }
+                // Try collecting the hs_err logs that the JVM dumps when it segfaults.
+                List<File> logFiles =
+                        Arrays.stream(mWorkDir.listFiles())
+                                .filter(
+                                        f ->
+                                                f.getName().startsWith("hs_err")
+                                                        && f.getName().endsWith(".log"))
+                                .collect(Collectors.toList());
+
+                if (!runStarted) {
+                    listener.testRunStarted(this.getClass().getCanonicalName(), 0);
+                }
+                for (File f : logFiles) {
+                    try (FileInputStreamSource source = new FileInputStreamSource(f, true)) {
+                        listener.testLog("hs_err_log-VM-crash", LogDataType.TEXT, source);
                     }
-                    switch (reply.getRunnerStatus()) {
-                        case RUNNER_STATUS_FINISHED_OK:
-                            CLog.v("Received message that runner finished successfully");
-                            break mainLoop;
-                        case RUNNER_STATUS_FINISHED_ERROR:
-                            CLog.e("Received message that runner errored");
-                            CLog.e("From Runner: " + reply.getMessage());
-                            if (!runStarted) {
-                                listener.testRunStarted(this.getClass().getCanonicalName(), 0);
-                            }
-                            FailureDescription failure =
-                                    FailureDescription.create(
-                                            reply.getMessage(), FailureStatus.INFRA_FAILURE);
-                            listener.testRunFailed(failure);
-                            listener.testRunEnded(0L, new HashMap<String, Metric>());
-                            break mainLoop;
-                        case RUNNER_STATUS_STARTING:
-                            CLog.v("Received message that runner is starting");
-                            break;
-                        default:
-                            if (reply.hasTestEvent()) {
-                                JUnitEvent event = reply.getTestEvent();
-                                TestDescription desc;
-                                switch (event.getTopic()) {
-                                    case TOPIC_FAILURE:
-                                        desc =
-                                                new TestDescription(
-                                                        event.getClassName(),
-                                                        event.getMethodName());
-                                        listener.testFailed(desc, event.getMessage());
-                                        break;
-                                    case TOPIC_ASSUMPTION_FAILURE:
-                                        desc =
-                                                new TestDescription(
-                                                        event.getClassName(),
-                                                        event.getMethodName());
-                                        listener.testAssumptionFailure(desc, reply.getMessage());
-                                        break;
-                                    case TOPIC_STARTED:
-                                        desc =
-                                                new TestDescription(
-                                                        event.getClassName(),
-                                                        event.getMethodName());
-                                        listener.testStarted(desc, event.getStartTime());
-                                        currentTest = desc;
-                                        methodScope = new CloseableTraceScope(desc.toString());
-                                        break;
-                                    case TOPIC_FINISHED:
-                                        desc =
-                                                new TestDescription(
-                                                        event.getClassName(),
-                                                        event.getMethodName());
-                                        listener.testEnded(
-                                                desc,
-                                                event.getEndTime(),
-                                                new HashMap<String, Metric>());
-                                        currentTest = null;
-                                        if (methodScope != null) {
-                                            methodScope.close();
-                                            methodScope = null;
-                                        }
-                                        break;
-                                    case TOPIC_IGNORED:
-                                        desc =
-                                                new TestDescription(
-                                                        event.getClassName(),
-                                                        event.getMethodName());
-                                        // Use endTime for both events since
-                                        // ignored test do not really run.
-                                        listener.testStarted(desc, event.getEndTime());
-                                        listener.testIgnored(desc);
-                                        listener.testEnded(
-                                                desc,
-                                                event.getEndTime(),
-                                                new HashMap<String, Metric>());
-                                        break;
-                                    case TOPIC_RUN_STARTED:
-                                        runStarted = true;
-                                        listener.testRunStarted(
-                                                event.getClassName(), event.getTestCount());
-                                        runScope = new CloseableTraceScope(event.getClassName());
-                                        break;
-                                    case TOPIC_RUN_FINISHED:
-                                        listener.testRunEnded(
-                                                event.getElapsedTime(),
-                                                new HashMap<String, Metric>());
-                                        if (runScope != null) {
-                                            runScope.close();
-                                            runScope = null;
-                                        }
-                                        break;
-                                    default:
-                                }
-                            }
+                }
+                mReportedFailure = true;
+                FailureDescription failure =
+                        FailureDescription.create(
+                                        "The subprocess died unexpectedly.",
+                                        FailureStatus.TEST_FAILURE)
+                                .setFullRerun(false);
+                listener.testRunFailed(failure);
+                listener.testRunEnded(0L, new HashMap<String, Metric>());
+                return false;
+            }
+            switch (reply.getRunnerStatus()) {
+                case RUNNER_STATUS_FINISHED_OK:
+                    CLog.v("Received message that runner finished successfully");
+                    return success;
+                case RUNNER_STATUS_FINISHED_ERROR:
+                    CLog.e("Received message that runner errored");
+                    CLog.e("From Runner: " + reply.getMessage());
+                    if (!runStarted) {
+                        listener.testRunStarted(this.getClass().getCanonicalName(), 0);
                     }
-                } catch (SocketTimeoutException e) {
-                    mReportedFailure = true;
                     FailureDescription failure =
                             FailureDescription.create(
-                                    StreamUtil.getStackTrace(e), FailureStatus.INFRA_FAILURE);
+                                    reply.getMessage(), FailureStatus.INFRA_FAILURE);
                     listener.testRunFailed(failure);
-                    listener.testRunEnded(
-                            Duration.between(start, Instant.now()).toMillis(),
-                            new HashMap<String, Metric>());
-                    break mainLoop;
-                }
-            }
-        } finally {
-            // This will get associated with the module since it can contains several test runs
-            try (FileInputStreamSource source = new FileInputStreamSource(mSubprocessLog, true)) {
-                listener.testLog("isolated-java-logs", LogDataType.TEXT, source);
+                    listener.testRunEnded(0L, new HashMap<String, Metric>());
+                    return false;
+                case RUNNER_STATUS_STARTING:
+                    CLog.v("Received message that runner is starting");
+                    break;
+                default:
+                    if (reply.hasTestEvent()) {
+                        JUnitEvent event = reply.getTestEvent();
+                        TestDescription desc;
+                        switch (event.getTopic()) {
+                            case TOPIC_FAILURE:
+                                desc =
+                                        new TestDescription(
+                                                event.getClassName(), event.getMethodName());
+                                listener.testFailed(desc, event.getMessage());
+                                success = false;
+                                break;
+                            case TOPIC_ASSUMPTION_FAILURE:
+                                desc =
+                                        new TestDescription(
+                                                event.getClassName(), event.getMethodName());
+                                listener.testAssumptionFailure(desc, reply.getMessage());
+                                break;
+                            case TOPIC_STARTED:
+                                desc =
+                                        new TestDescription(
+                                                event.getClassName(), event.getMethodName());
+                                listener.testStarted(desc, event.getStartTime());
+                                currentTest = desc;
+                                methodScope = new CloseableTraceScope(desc.toString());
+                                break;
+                            case TOPIC_FINISHED:
+                                desc =
+                                        new TestDescription(
+                                                event.getClassName(), event.getMethodName());
+                                listener.testEnded(
+                                        desc, event.getEndTime(), new HashMap<String, Metric>());
+                                currentTest = null;
+                                if (methodScope != null) {
+                                    methodScope.close();
+                                    methodScope = null;
+                                }
+                                break;
+                            case TOPIC_IGNORED:
+                                desc =
+                                        new TestDescription(
+                                                event.getClassName(), event.getMethodName());
+                                // Use endTime for both events since
+                                // ignored test do not really run.
+                                listener.testStarted(desc, event.getEndTime());
+                                listener.testIgnored(desc);
+                                listener.testEnded(
+                                        desc, event.getEndTime(), new HashMap<String, Metric>());
+                                break;
+                            case TOPIC_RUN_STARTED:
+                                runStarted = true;
+                                listener.testRunStarted(event.getClassName(), event.getTestCount());
+                                runScope = new CloseableTraceScope(event.getClassName());
+                                break;
+                            case TOPIC_RUN_FINISHED:
+                                listener.testRunEnded(
+                                        event.getElapsedTime(), new HashMap<String, Metric>());
+                                if (runScope != null) {
+                                    runScope.close();
+                                    runScope = null;
+                                }
+                                break;
+                            default:
+                        }
+                    }
             }
         }
     }
@@ -836,15 +1000,18 @@ public class IsolatedHostTest
      * implementation, but somewhat difficult to extract well due to the various method calls it
      * uses.
      */
-    private List<String> getJarPaths(Set<String> jars) throws FileNotFoundException {
+    private List<String> getJarPaths(Set<String> jars, boolean enableCache)
+            throws FileNotFoundException {
         Set<String> output = new HashSet<>();
 
         for (String jar : jars) {
-            File jarFile = getJarFile(jar, mBuildInfo);
-            output.add(jarFile.getAbsolutePath());
+            output.add(
+                    enableCache
+                            ? RunUtil.toRelative(mWorkDir, FileUtil.findFile(mWorkDir, jar))
+                            : getJarFile(jar, mBuildInfo).getAbsolutePath());
         }
 
-        return output.stream().collect(Collectors.toList());
+        return output.stream().sorted().collect(Collectors.toList());
     }
 
     /**
@@ -1051,7 +1218,12 @@ public class IsolatedHostTest
     }
 
     private File getIsolationJar(File workDir) throws IOException {
-        File isolationJar = FileUtil.createTempFile("tradefed-isolation", ".jar", workDir);
+        File isolationJar = new File(mWorkDir, "classpath/tradefed-isolation.jar");
+        if (isolationJar.exists()) {
+            return isolationJar;
+        }
+        isolationJar.getParentFile().mkdirs();
+        isolationJar.createNewFile();
         boolean res =
                 ResourceUtil.extractResourceWithAltAsFile(
                         "/tradefed-isolation.jar",
@@ -1069,4 +1241,25 @@ public class IsolatedHostTest
             FileUtil.deleteFile(mIsolationJar);
         }
     }
+
+    @VisibleForTesting
+    boolean isCached() {
+        return mCached;
+    }
+
+    @VisibleForTesting
+    ICacheClient getCacheClient(File workFolder, String instanceName) {
+        return CacheClientFactory.createCacheClient(workFolder, instanceName);
+    }
+
+    /** Links a target file to another place under {@code mWorkDir}. */
+    private File linkFileToWorkingDir(String relToWorkingDir, File target) {
+        try {
+            return RunUtil.linkFile(mWorkDir, relToWorkingDir, target);
+        } catch (IOException e) {
+            CLog.e("Failed to symlink %s.", target);
+            CLog.e(e);
+            return target;
+        }
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java b/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java
index b4f61796f..dc7a74857 100644
--- a/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java
+++ b/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.testtype;
 
+import com.android.annotations.VisibleForTesting;
 import com.android.ddmlib.MultiLineReceiver;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.log.LogUtil.CLog;
@@ -36,6 +37,7 @@ import java.util.Set;
 import java.util.regex.MatchResult;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 /**
  * Interprets the output of tests run with Python's unittest framework and translates it into calls
@@ -470,7 +472,8 @@ public class PythonUnitTestResultParser extends MultiLineReceiver {
     private void reportNonFailureTestResult() throws PythonUnitTestParseException {
         TestDescription testId = new TestDescription(mCurrentTestClass, mCurrentTestName);
 
-        if (shouldSkipCurrentTest()) {
+        if (shouldSkipCurrentTest(
+                mCurrentTestClass, mCurrentTestName, mIncludeFilters, mExcludeFilters)) {
             // Force to skip any test not listed in include filters, or listed in exclude filters.
             mTestResultCache.put(testId, SKIPPED_ENTRY);
         } else if (PATTERN_TEST_SUCCESS.matcher(mCurrentTestStatus).matches()) {
@@ -489,7 +492,8 @@ public class PythonUnitTestResultParser extends MultiLineReceiver {
     /** Record a failed test case and its traceback message. */
     private void reportFailureTestResult() {
         TestDescription testId = new TestDescription(mCurrentTestClass, mCurrentTestName);
-        if (shouldSkipCurrentTest()) {
+        if (shouldSkipCurrentTest(
+                mCurrentTestClass, mCurrentTestName, mIncludeFilters, mExcludeFilters)) {
             mTestResultCache.put(testId, SKIPPED_ENTRY);
         } else {
             mTestResultCache.put(testId, mCurrentTraceback.toString());
@@ -501,28 +505,67 @@ public class PythonUnitTestResultParser extends MultiLineReceiver {
      *
      * @return true if the test should be skipped.
      */
-    private boolean shouldSkipCurrentTest() {
+    @VisibleForTesting
+    boolean shouldSkipCurrentTest(
+            String testClass,
+            String testName,
+            Set<String> includeFilters,
+            Set<String> excludeFilters) {
         // Force to skip any test not listed in include filters, or listed in exclude filters.
         // exclude filters have highest priority.
-        if (mExcludeFilters.contains(mCurrentTestClass + "#" + mCurrentTestName)
-                || mExcludeFilters.contains(mCurrentTestClass)) {
+        if (excludeFilters.contains(testClass + "#" + testName)
+                || excludeFilters.contains(testClass)) {
             return true;
         }
-        if (!mIncludeFilters.isEmpty()) {
-            if (mIncludeFilters.contains(mCurrentTestClass + "#" + mCurrentTestName)
-                    || mIncludeFilters.contains(mCurrentTestClass)) {
+        if (!includeFilters.isEmpty()) {
+            if (includeFilters.contains(testClass + "#" + testName)
+                    || includeFilters.contains(testClass)) {
                 return false;
             }
-            for (String filter : mIncludeFilters) {
-                if ((mCurrentTestClass + "#" + mCurrentTestName).matches(filter)) {
+            for (String filter : includeFilters) {
+                // If the filter is in fnMatch format, assume the tests have already been filtered.
+                if (isFnMatchFormat(filter)) {
                     return false;
                 }
+                // Also ensure the filter matches the fully.qualified.ClassName
+                String fullyQualifiedClassNameFilter = "(\\w*\\.)*" + filter;
+                try {
+                    if (testClass.matches(fullyQualifiedClassNameFilter)
+                            || (testClass + "#" + testName)
+                                    .matches(fullyQualifiedClassNameFilter)) {
+                        return false;
+                    }
+                } catch (PatternSyntaxException pse) {
+                    // Ignore.
+                }
+                // If the filter is not in Class#method format, apply it broadly as a pattern.
+                try {
+                    if (!filter.matches("(\\w*\\.)*\\w*#\\w*")) {
+                        if ((testClass + "#" + testName).matches(".*" + filter + ".*")) {
+                            return false;
+                        }
+                    }
+                } catch (PatternSyntaxException pse) {
+                    // Ignore.
+                }
             }
             return true;
         }
         return false;
     }
 
+    private boolean isFnMatchFormat(String filter) {
+        // A Fnmatch-formatted filter can contain any of the following characters:
+        // '*', '?', set of square brackets '[' and ']', '!'.
+        if (filter.matches(".*\\*.*")
+                || filter.matches(".*\\?.*")
+                || filter.matches(".*\\[.*].*")
+                || filter.matches(".*\\!.*")) {
+            return true;
+        }
+        return false;
+    }
+
     @Override
     public boolean isCancelled() {
         return false;
diff --git a/test_framework/com/android/tradefed/testtype/binary/ExecutableBaseTest.java b/test_framework/com/android/tradefed/testtype/binary/ExecutableBaseTest.java
index d9b0a51e6..26c8735be 100644
--- a/test_framework/com/android/tradefed/testtype/binary/ExecutableBaseTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/ExecutableBaseTest.java
@@ -15,7 +15,9 @@
  */
 package com.android.tradefed.testtype.binary;
 
-import com.google.common.annotations.VisibleForTesting;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionCopier;
 import com.android.tradefed.device.DeviceNotAvailableException;
@@ -25,7 +27,11 @@ import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.observatory.IDiscoverDependencies;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.TestRunResultListener;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.IAbi;
 import com.android.tradefed.testtype.IAbiReceiver;
 import com.android.tradefed.testtype.IRemoteTest;
@@ -34,10 +40,9 @@ import com.android.tradefed.testtype.IShardableTest;
 import com.android.tradefed.testtype.ITestCollector;
 import com.android.tradefed.testtype.ITestFilterReceiver;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
-import com.android.tradefed.result.error.InfraErrorIdentifier;
-import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.util.StreamUtil;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -57,6 +62,7 @@ import java.util.Set;
 /** Base class for executable style of tests. For example: binaries, shell scripts. */
 public abstract class ExecutableBaseTest
         implements IRemoteTest,
+                IConfigurationReceiver,
                 IRuntimeHintProvider,
                 ITestCollector,
                 IShardableTest,
@@ -105,6 +111,8 @@ public abstract class ExecutableBaseTest
     private TestInformation mTestInfo;
     private Set<String> mIncludeFilters = new LinkedHashSet<>();
     private Set<String> mExcludeFilters = new LinkedHashSet<>();
+    private IConfiguration mConfiguration = null;
+    private TestRunResultListener mTestRunResultListener;
 
     /**
      * Get test commands.
@@ -138,6 +146,10 @@ public abstract class ExecutableBaseTest
         return false;
     }
 
+    protected boolean isTestFailed(String testName) {
+        return mTestRunResultListener.isTestFailed(testName);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void addIncludeFilter(String filter) {
@@ -189,6 +201,8 @@ public abstract class ExecutableBaseTest
     @Override
     public void run(TestInformation testInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
+        mTestRunResultListener = new TestRunResultListener();
+        listener = new ResultForwarder(listener, mTestRunResultListener);
         setTestInfo(testInfo);
         String moduleId = getModuleId(testInfo.getContext());
         Map<String, String> testCommands = getAllTestCommands();
@@ -209,41 +223,41 @@ public abstract class ExecutableBaseTest
                 String testName = description.getTestName();
                 String cmd = testCommands.get(testName);
                 String path = findBinary(cmd);
-                try {
-                    if (path == null) {
+
+                if (path == null) {
+                    listener.testStarted(description);
+                    listener.testFailed(
+                            description,
+                            FailureDescription.create(
+                                            String.format(NO_BINARY_ERROR, cmd),
+                                            FailureStatus.TEST_FAILURE)
+                                    .setErrorIdentifier(
+                                            InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND));
+                    listener.testEnded(description, new HashMap<String, Metric>());
+                } else {
+                    try {
+                        if (!doesRunBinaryGenerateTestResults()) {
+                            listener.testStarted(description);
+                        }
+
+                        if (!getCollectTestsOnly()) {
+                            // Do not actually run the test if we are dry running it.
+                            runBinary(path, listener, description);
+                        }
+                    } catch (IOException e) {
                         listener.testFailed(
                                 description,
-                                FailureDescription.create(
-                                                String.format(NO_BINARY_ERROR, cmd),
-                                                FailureStatus.TEST_FAILURE)
-                                        .setErrorIdentifier(
-                                                InfraErrorIdentifier
-                                                        .CONFIGURED_ARTIFACT_NOT_FOUND));
-                    } else {
-                        try {
-                            if (!doesRunBinaryGenerateTestResults()) {
-                                listener.testStarted(description);
-                            }
-
-                            if (!getCollectTestsOnly()) {
-                                // Do not actually run the test if we are dry running it.
-                                runBinary(path, listener, description);
-                            }
-                        } catch (IOException e) {
-                            listener.testFailed(
-                                    description,
-                                    FailureDescription.create(StreamUtil.getStackTrace(e)));
-                            if (doesRunBinaryGenerateTestResults()) {
-                                // We can't rely on the `testEnded()` call in the finally
-                                // clause if `runBinary()` is responsible for generating test
-                                // results, therefore we call it here.
-                                listener.testEnded(description, new HashMap<String, Metric>());
-                            }
+                                FailureDescription.create(StreamUtil.getStackTrace(e)));
+                        if (doesRunBinaryGenerateTestResults()) {
+                            // We can't rely on the `testEnded()` call in the finally
+                            // clause if `runBinary()` is responsible for generating test
+                            // results, therefore we call it here.
+                            listener.testEnded(description, new HashMap<String, Metric>());
+                        }
+                    } finally {
+                        if (!doesRunBinaryGenerateTestResults()) {
+                            listener.testEnded(description, new HashMap<String, Metric>());
                         }
-                    }
-                } finally {
-                    if (!doesRunBinaryGenerateTestResults()) {
-                        listener.testEnded(description, new HashMap<String, Metric>());
                     }
                 }
             }
@@ -442,8 +456,7 @@ public abstract class ExecutableBaseTest
      *
      * @return a Map{@link LinkedHashMap}<String, String> of testCommands.
      */
-    @VisibleForTesting
-    Map<String, String> getAllTestCommands() {
+    protected Map<String, String> getAllTestCommands() {
         Map<String, String> testCommands = new LinkedHashMap<>(mTestCommands);
         for (String binary : mBinaryPaths) {
             testCommands.put(new File(binary).getName(), binary);
@@ -457,4 +470,22 @@ public abstract class ExecutableBaseTest
         deps.addAll(mBinaryPaths);
         return deps;
     }
+
+    /**
+     * Returns the test configuration.
+     *
+     * @return an IConfiguration
+     */
+    protected IConfiguration getConfiguration() {
+        if (mConfiguration == null) {
+            return new Configuration("", "");
+        }
+        return mConfiguration;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/binary/ExecutableHostTest.java b/test_framework/com/android/tradefed/testtype/binary/ExecutableHostTest.java
index e5b58368a..8e71f6d84 100644
--- a/test_framework/com/android/tradefed/testtype/binary/ExecutableHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/ExecutableHostTest.java
@@ -15,14 +15,19 @@
  */
 package com.android.tradefed.testtype.binary;
 
+import static com.android.tradefed.util.EnvironmentVariableUtil.buildPathWithRelativePaths;
+
 import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
 import com.android.tradefed.config.GlobalConfiguration;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.StubDevice;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.log.ITestLogger;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.FailureDescription;
@@ -34,17 +39,22 @@ import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.IDeviceTest;
 import com.android.tradefed.util.AdbUtils;
+import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.SystemUtil;
 import com.android.tradefed.util.TestRunnerUtil;
 
+import com.google.common.base.Strings;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -68,6 +78,18 @@ public class ExecutableHostTest extends ExecutableBaseTest {
     )
     private boolean mExecuteRelativeToScript = false;
 
+    @Option(
+            name = "enable-cache",
+            description = "Used to enable/disable caching for specific modules.")
+    private boolean mEnableCache = false;
+
+    @Option(
+            name = "inherit-env-vars",
+            description =
+                    "Whether the subprocess should inherit environment variables from the main"
+                            + " process.")
+    private boolean mInheritEnvVars = true;
+
     @Override
     public String findBinary(String binary) {
         File bin = new File(binary);
@@ -116,40 +138,70 @@ public class ExecutableHostTest extends ExecutableBaseTest {
         String ldLibraryPath = TestRunnerUtil.getLdLibraryPath(new File(binaryPath));
         // Also add the directory of the binary path as the test may package library as data
         // dependency.
-        String cwd = new File(binaryPath).getParentFile().getAbsolutePath();
+        File workingDir = new File(binaryPath).getParentFile();
+        runUtil.setWorkingDir(workingDir);
         if (ldLibraryPath != null) {
-            ldLibraryPath = String.format("%s%s%s", ldLibraryPath, java.io.File.pathSeparator, cwd);
+            ldLibraryPath =
+                    String.format(
+                            "%s%s%s",
+                            ldLibraryPath,
+                            java.io.File.pathSeparator,
+                            workingDir.getAbsolutePath());
         } else {
-            ldLibraryPath = cwd;
+            ldLibraryPath = workingDir.getAbsolutePath();
         }
         runUtil.setEnvVariable(LD_LIBRARY_PATH, ldLibraryPath);
 
-        // Set Tradefed adb on $PATH of binary
-        AdbUtils.updateAdb(getTestInfo(), runUtil, getAdbPath());
+        // Update Tradefed adb on $PATH of binary
+        File adbBinary = AdbUtils.getAdbToUpdate(getTestInfo(), getAdbPath());
+        runUtil.setEnvVariable(
+                "PATH",
+                buildPathWithRelativePaths(
+                        workingDir,
+                        Collections.singleton(
+                                adbBinary != null ? adbBinary.getAbsolutePath() : "adb"),
+                        String.format(
+                                "%s:/usr/bin",
+                                SystemUtil.getRunningJavaBinaryPath()
+                                        .getParentFile()
+                                        .getAbsolutePath())));
         // Ensure its executable
         FileUtil.chmodRWXRecursively(new File(binaryPath));
 
         List<String> command = new ArrayList<>();
         String scriptName = new File(binaryPath).getName();
         if (mExecuteRelativeToScript) {
-            String parentDir = new File(binaryPath).getParent();
-            command.add("bash");
-            command.add("-c");
-            command.add(String.format("pushd %s; ./%s;", parentDir, scriptName));
+            command.add(String.format("./%s", scriptName));
         } else {
             command.add(binaryPath);
         }
         File stdout = FileUtil.createTempFile(scriptName + LOG_STDOUT_TAG, ".txt");
         File stderr = FileUtil.createTempFile(scriptName + LOG_STDERR_TAG, ".txt");
+        ICacheClient cacheClient = null;
 
         try (FileOutputStream stdoutStream = new FileOutputStream(stdout);
                 FileOutputStream stderrStream = new FileOutputStream(stderr); ) {
+            String instanceName =
+                    mEnableCache
+                            ? getConfiguration().getCommandOptions().getRemoteCacheInstanceName()
+                            : null;
+            if (!Strings.isNullOrEmpty(instanceName)) {
+                cacheClient = getCacheClient(CurrentInvocation.getWorkFolder(), instanceName);
+            }
             CommandResult res =
-                    runUtil.runTimedCmd(
-                            getTimeoutPerBinaryMs(),
-                            stdoutStream,
-                            stderrStream,
-                            command.toArray(new String[0]));
+                    cacheClient == null
+                            ? runUtil.runTimedCmd(
+                                    getTimeoutPerBinaryMs(),
+                                    stdoutStream,
+                                    stderrStream,
+                                    command.toArray(new String[0]))
+                            : runUtil.runTimedCmdWithOutputMonitor(
+                                    getTimeoutPerBinaryMs(),
+                                    0,
+                                    stdoutStream,
+                                    stderrStream,
+                                    cacheClient,
+                                    command.toArray(new String[0]));
             if (!CommandStatus.SUCCESS.equals(res.getStatus())) {
                 FailureStatus status = FailureStatus.TEST_FAILURE;
                 // Everything should be outputted in stdout with our redirect above.
@@ -164,6 +216,10 @@ public class ExecutableHostTest extends ExecutableBaseTest {
                 listener.testFailed(
                         description,
                         FailureDescription.create(errorMessage).setFailureStatus(status));
+            } else if (!res.isCached() && !isTestFailed(description.getTestName())) {
+                runUtil.uploadCache(
+                        cacheClient,
+                        ExecutableActionResult.create(res.getExitCode(), stdout, stderr));
             }
         } finally {
             logFile(stdout, listener);
@@ -191,7 +247,12 @@ public class ExecutableHostTest extends ExecutableBaseTest {
 
     @VisibleForTesting
     IRunUtil createRunUtil() {
-        return new RunUtil();
+        return new RunUtil(mInheritEnvVars);
+    }
+
+    @VisibleForTesting
+    ICacheClient getCacheClient(File workFolder, String instanceName) {
+        return CacheClientFactory.createCacheClient(workFolder, instanceName);
     }
 
     @VisibleForTesting
diff --git a/test_framework/com/android/tradefed/testtype/binary/KTapResultParser.java b/test_framework/com/android/tradefed/testtype/binary/KTapResultParser.java
index 32144761d..6bf74c881 100644
--- a/test_framework/com/android/tradefed/testtype/binary/KTapResultParser.java
+++ b/test_framework/com/android/tradefed/testtype/binary/KTapResultParser.java
@@ -56,7 +56,8 @@ public class KTapResultParser {
 
     public enum ParseResolution {
         INDIVIDUAL_LEAVES,
-        AGGREGATED_TOP_LEVEL,
+        AGGREGATED_SUITE,
+        AGGREGATED_MODULE,
     }
 
     enum ResultDirective {
@@ -144,14 +145,45 @@ public class KTapResultParser {
     static final Predicate<String> IS_PLAN = PLAN_PATTERN.asPredicate();
     static final Predicate<String> IS_TEST_CASE_RESULT = TEST_CASE_RESULT_PATTERN.asPredicate();
 
+    private static TestDescription individualLeavesTestDescription(
+            String testRunName, String testName) {
+        // Rearrange the test description (class and method) in testStarted() for INDIVIDUAL_LEAVES.
+        // For example, transform `kunit_example_test#example.example_simple_test` into
+        // `kunit_example_test.example#example_simple_test` to better match the pattern
+        // <package>.<class>#<method>. In this case, package = kunit_example_test, class = example,
+        // method = example_simple_test.
+
+        int firstDotIndex = testName.indexOf(".");
+
+        if (firstDotIndex != -1) {
+            testRunName = String.format("%s.%s", testRunName, testName.substring(0, firstDotIndex));
+            testName = testName.substring(firstDotIndex + 1);
+        }
+        return new TestDescription(testRunName, testName);
+    }
+
     public static void applyKTapResultToListener(
             ITestInvocationListener listener,
             String testRunName,
-            String ktapFileContent,
+            List<String> ktapFileContentList,
             ParseResolution resolution) {
+        applyKTapResultToListener(listener, testRunName, ktapFileContentList, resolution, false);
+    }
+
+    public static void applyKTapResultToListener(
+            ITestInvocationListener listener,
+            String testRunName,
+            List<String> ktapFileContentList,
+            ParseResolution resolution,
+            boolean rearrangeClassMethod) {
         KTapResultParser parser = new KTapResultParser();
-        TestResult root = parser.processResultsFileContent(ktapFileContent);
-        parser.applyToListener(listener, testRunName, root, resolution);
+        List<TestResult> rootList = new ArrayList<>();
+        for (String ktapFileContent : ktapFileContentList) {
+            TestResult root = parser.processResultsFileContent(ktapFileContent);
+            rootList.add(root);
+        }
+        // rearrangeClassMethod takes effect only when parser resolution is INDIVIDUAL_LEAVES now
+        parser.applyToListener(listener, testRunName, rootList, resolution, rearrangeClassMethod);
     }
 
     @VisibleForTesting
@@ -274,52 +306,99 @@ public class KTapResultParser {
         processLines(currentTest, lineIterator);
     }
 
+    private boolean aggregateTestResults(List<TestResult> tests, StringBuilder testName) {
+        testName.append(tests.get(0).name);
+        boolean isOk = tests.get(0).isOk;
+        for (int i = 1; i < tests.size(); ++i) {
+            testName.append(".").append(tests.get(i).name);
+            isOk &= tests.get(i).isOk;
+        }
+        return isOk;
+    }
+
     private void applyToListener(
             ITestInvocationListener listener,
             String testRunName,
-            TestResult root,
-            ParseResolution resolution) {
+            List<TestResult> rootList,
+            ParseResolution resolution,
+            boolean rearrangeClassMethod) {
         if (resolution == ParseResolution.INDIVIDUAL_LEAVES) {
-            applySubtestLeavesToListener(listener, testRunName, root, "");
-        } else if (resolution == ParseResolution.AGGREGATED_TOP_LEVEL) {
-            applyAggregatedTopLevelToListener(listener, testRunName, root, "");
+            applySubtestLeavesToListener(listener, testRunName, rootList, "", rearrangeClassMethod);
+        } else if (resolution == ParseResolution.AGGREGATED_SUITE) {
+            applyAggregatedSuiteToListener(listener, testRunName, rootList, "");
+        } else if (resolution == ParseResolution.AGGREGATED_MODULE) {
+            applyAggregatedModuleToListener(listener, testRunName, rootList, "");
         }
     }
 
     private void applySubtestLeavesToListener(
-            ITestInvocationListener listener, String testRunName, TestResult test, String prefix) {
-        String testName = prefix == null || prefix.isEmpty() ? test.name : prefix + "." + test.name;
-        if (test.subtests.size() > 0) {
-            for (TestResult subtest : test.subtests) {
-                applySubtestLeavesToListener(listener, testRunName, subtest, testName);
+            ITestInvocationListener listener,
+            String testRunName,
+            List<TestResult> testList,
+            String prefix,
+            boolean rearrangeClassMethod) {
+        for (TestResult test : testList) {
+            String testName =
+                    prefix == null || prefix.isEmpty() ? test.name : prefix + "." + test.name;
+            if (test.subtests.size() > 0) {
+                applySubtestLeavesToListener(
+                        listener, testRunName, test.subtests, testName, rearrangeClassMethod);
+            } else {
+                applyTestResultToListener(
+                        listener, testRunName, testName, test, rearrangeClassMethod);
             }
-        } else {
-            applyTestResultToListener(listener, testRunName, testName, test);
         }
     }
 
-    private void applyAggregatedTopLevelToListener(
+    private void applyAggregatedSuiteToListener(
             ITestInvocationListener listener,
             String testRunName,
-            TestResult root,
+            List<TestResult> rootList,
             String fullKTapResult) {
-        // Here we want to apply a single test result based on the one or more top level KTAP
-        // results. If there are more than one top level result, their names are concatenated
-        // and pass/fail results are AND'd into a final value.
+        // Here we want to apply a test result for each suite based on the one or more top
+        // level KTAP results. If there are more than one top level result, their names are
+        // concatenated and pass/fail results are AND'd into a final value.
+
+        for (TestResult root : rootList) {
+            if (root.subtests.isEmpty()) {
+                throw new IllegalArgumentException(
+                        "No valid test results in KTAP results. " + fullKTapResult);
+            }
 
-        if (root.subtests.isEmpty()) {
-            throw new IllegalArgumentException(
-                    "No valid test results in KTAP results. " + fullKTapResult);
-        }
+            StringBuilder testName = new StringBuilder();
+            boolean isOk = aggregateTestResults(root.subtests, testName);
 
-        String testName = root.subtests.get(0).name;
-        boolean isOk = root.subtests.get(0).isOk;
-        for (int i = 1; i < root.subtests.size(); ++i) {
-            testName += "." + root.subtests.get(i).name;
-            isOk &= root.subtests.get(i).isOk;
+            TestDescription testDescription = new TestDescription(testRunName, testName.toString());
+            listener.testStarted(testDescription);
+            if (!isOk) {
+                listener.testFailed(testDescription, fullKTapResult);
+            }
+            listener.testEnded(testDescription, new HashMap<String, Metric>());
         }
+    }
 
-        TestDescription testDescription = new TestDescription(testRunName, testName);
+    private void applyAggregatedModuleToListener(
+            ITestInvocationListener listener,
+            String testRunName,
+            List<TestResult> rootList,
+            String fullKTapResult) {
+        // Here we want to apply a test result for each module. A module can include
+        // several suites. If there are more than one suite result in the module,
+        // their names are concatenated and pass/fail results are AND'd into a final value.
+
+        StringBuilder testName = new StringBuilder();
+        boolean isOk = true;
+
+        for (TestResult root : rootList) {
+            if (root.subtests.isEmpty()) {
+                throw new IllegalArgumentException(
+                        "No valid test results in KTAP results. " + fullKTapResult);
+            }
+
+            testName.append(",");
+            isOk &= aggregateTestResults(root.subtests, testName);
+        }
+        TestDescription testDescription = new TestDescription(testRunName, testName.substring(1));
         listener.testStarted(testDescription);
         if (!isOk) {
             listener.testFailed(testDescription, fullKTapResult);
@@ -331,8 +410,12 @@ public class KTapResultParser {
             ITestInvocationListener listener,
             String testRunName,
             String testName,
-            TestResult test) {
-        TestDescription testDescription = new TestDescription(testRunName, testName);
+            TestResult test,
+            boolean rearrangeClassMethod) {
+        TestDescription testDescription =
+                rearrangeClassMethod
+                        ? individualLeavesTestDescription(testRunName, testName)
+                        : new TestDescription(testRunName, testName);
         listener.testStarted(testDescription);
         switch (test.directive) {
             case NOTSET:
diff --git a/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java b/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java
index 1ce25b5e1..c8edad261 100644
--- a/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/KUnitModuleTest.java
@@ -15,29 +15,40 @@
  */
 package com.android.tradefed.testtype.binary;
 
+import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.NativeDevice;
-import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
+import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 
 import java.io.IOException;
-import java.util.concurrent.TimeUnit;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
 
 /** Test runner for running KUnit test modules on device. */
 @OptionClass(alias = "kunit-module-test")
 public class KUnitModuleTest extends ExecutableTargetTest {
 
+    @Option(
+            name = "ktap-result-parser-resolution",
+            description = "Parser resolution for KTap results.")
+    private KTapResultParser.ParseResolution mKTapResultParserResolution =
+            KTapResultParser.ParseResolution.AGGREGATED_MODULE;
+
     public static final String RMMOD_COMMAND_FMT = "rmmod %s";
     public static final String INSMOD_COMMAND_FMT = "insmod %s";
     public static final String KUNIT_DEBUGFS_PATH =
@@ -45,6 +56,11 @@ public class KUnitModuleTest extends ExecutableTargetTest {
     public static final String KUNIT_RESULTS_FMT =
             String.format("%s/%%s/results", KUNIT_DEBUGFS_PATH);
 
+    /** Remove `.ko` extension if present */
+    private static String removeKoExtension(String s) {
+        return s.endsWith(".ko") ? s.substring(0, s.length() - 3) : s;
+    }
+
     /**
      * Return module name as it's displayed after loading.
      *
@@ -66,10 +82,7 @@ public class KUnitModuleTest extends ExecutableTargetTest {
         }
 
         // Remove `.ko` extension if present
-        moduleName =
-                moduleName.endsWith(".ko")
-                        ? moduleName.substring(0, moduleName.length() - 3)
-                        : moduleName;
+        moduleName = removeKoExtension(moduleName);
 
         // Replace all '-' with '_'
         return moduleName.replace('-', '_');
@@ -89,6 +102,16 @@ public class KUnitModuleTest extends ExecutableTargetTest {
         return false;
     }
 
+    @Override
+    protected Map<String, String> getAllTestCommands() {
+        Map<String, String> originalTestCommands = super.getAllTestCommands();
+        Map<String, String> modifiedTestCommands = new LinkedHashMap<>();
+        for (Map.Entry<String, String> entry : originalTestCommands.entrySet()) {
+            modifiedTestCommands.put(removeKoExtension(entry.getKey()), entry.getValue());
+        }
+        return modifiedTestCommands;
+    }
+
     @Override
     public String findBinary(String binary) throws DeviceNotAvailableException {
         return getSkipBinaryCheck() || getDevice().doesFileExist(binary) ? binary : null;
@@ -168,28 +191,31 @@ public class KUnitModuleTest extends ExecutableTargetTest {
                 listener.testEnded(description, new HashMap<String, Metric>());
             }
 
+            List<String> ktapResultsList = new ArrayList<>();
             for (String testSuite : kunitTestSuitesAfter) {
                 String ktapResults =
                         getDevice().pullFileContents(String.format(KUNIT_RESULTS_FMT, testSuite));
                 CLog.i(
-                        "KUnit module '%s' KTAP result:\n%s",
-                        description.getTestName(), ktapResults);
-
-                try {
-                    KTapResultParser.applyKTapResultToListener(
-                            listener,
-                            description.getTestName(),
-                            ktapResults,
-                            KTapResultParser.ParseResolution.AGGREGATED_TOP_LEVEL);
-                } catch (RuntimeException exception) {
-                    CLog.e("KTAP parse error: %s", exception.toString());
-                    listener.testStarted(description);
-                    listener.testFailed(
-                            description,
-                            FailureDescription.create(exception.toString())
-                                    .setFailureStatus(FailureStatus.TEST_FAILURE));
-                    listener.testEnded(description, new HashMap<String, Metric>());
-                }
+                        "KUnit module '%s' suite '%s' KTAP result:\n%s",
+                        description.getTestName(), testSuite, ktapResults);
+                ktapResultsList.add(ktapResults);
+            }
+
+            try {
+                KTapResultParser.applyKTapResultToListener(
+                        listener,
+                        description.getTestName(),
+                        ktapResultsList,
+                        mKTapResultParserResolution,
+                        true);
+            } catch (RuntimeException exception) {
+                CLog.e("KTAP parse error: %s", exception.toString());
+                listener.testStarted(description);
+                listener.testFailed(
+                        description,
+                        FailureDescription.create(exception.toString())
+                                .setFailureStatus(FailureStatus.TEST_FAILURE));
+                listener.testEnded(description, new HashMap<String, Metric>());
             }
 
             // Clean up, unload module.
@@ -205,10 +231,157 @@ public class KUnitModuleTest extends ExecutableTargetTest {
                 CLog.w("Unable to unload module '%s'. %s", kunitModule, errorMessage);
             }
         } finally {
-            if (debugfsAlreadyMounted) {
-                // If debugfs was already mounted before this test, then keep it mounted.
+            if (!debugfsAlreadyMounted) {
+                // If debugfs was not mounted before this test, unmount it.
                 getDevice().unmountDebugfs();
             }
         }
     }
+
+    @Override
+    public void run(TestInformation testInfo, ITestInvocationListener listener)
+            throws DeviceNotAvailableException {
+
+        if (mKTapResultParserResolution == KTapResultParser.ParseResolution.AGGREGATED_MODULE) {
+            super.run(testInfo, listener);
+            return;
+        }
+
+        // KUnit does not support querying for number of test cases.
+        // This listener delays all events and counts the number of testStarted calls.
+        // After the tests end, it calls testRunStarted with the correct number.
+        List<Runnable> testEvents = new ArrayList<Runnable>();
+        int[] testCount = {0};
+        ITestInvocationListener delayListener =
+                new ITestInvocationListener() {
+                    @Override
+                    public void testRunStarted(String runName, int ignoredTestCount) {
+                        testEvents.add(() -> listener.testRunStarted(runName, testCount[0]));
+                    }
+
+                    @Override
+                    public void testRunStarted(
+                            String runName, int ignoredTestCount, int attemptNumber) {
+                        testEvents.add(
+                                () ->
+                                        listener.testRunStarted(
+                                                runName, testCount[0], attemptNumber));
+                    }
+
+                    @Override
+                    public void testRunStarted(
+                            String runName,
+                            int ignoredTestCount,
+                            int attemptNumber,
+                            long startTime) {
+                        testEvents.add(
+                                () ->
+                                        listener.testRunStarted(
+                                                runName, testCount[0], attemptNumber, startTime));
+                    }
+
+                    @Override
+                    public void testRunFailed(String errorMessage) {
+                        testEvents.add(() -> listener.testRunFailed(errorMessage));
+                    }
+
+                    @Override
+                    public void testRunFailed(FailureDescription failure) {
+                        testEvents.add(() -> listener.testRunFailed(failure));
+                    }
+
+                    @Override
+                    public void testRunEnded(
+                            long elapsedTimeMillis, Map<String, String> runMetrics) {
+                        testEvents.add(() -> listener.testRunEnded(elapsedTimeMillis, runMetrics));
+                    }
+
+                    @Override
+                    public void testRunEnded(
+                            long elapsedTimeMillis, HashMap<String, Metric> runMetrics) {
+                        testEvents.add(() -> listener.testRunEnded(elapsedTimeMillis, runMetrics));
+                    }
+
+                    @Override
+                    public void testRunStopped(long elapsedTime) {
+                        testEvents.add(() -> listener.testRunStopped(elapsedTime));
+                    }
+
+                    @Override
+                    public void testStarted(TestDescription test) {
+                        testEvents.add(() -> listener.testStarted(test));
+                        testCount[0]++;
+                    }
+
+                    @Override
+                    public void testStarted(TestDescription test, long startTime) {
+                        testEvents.add(() -> listener.testStarted(test, startTime));
+                        testCount[0]++;
+                    }
+
+                    @Override
+                    public void testFailed(TestDescription test, String trace) {
+                        testEvents.add(() -> listener.testFailed(test, trace));
+                    }
+
+                    @Override
+                    public void testFailed(TestDescription test, FailureDescription failure) {
+                        testEvents.add(() -> listener.testFailed(test, failure));
+                    }
+
+                    @Override
+                    public void testAssumptionFailure(TestDescription test, String trace) {
+                        testEvents.add(() -> listener.testAssumptionFailure(test, trace));
+                    }
+
+                    @Override
+                    public void testAssumptionFailure(
+                            TestDescription test, FailureDescription failure) {
+                        testEvents.add(() -> listener.testAssumptionFailure(test, failure));
+                    }
+
+                    @Override
+                    public void testIgnored(TestDescription test) {
+                        testEvents.add(() -> listener.testIgnored(test));
+                    }
+
+                    @Override
+                    public void testSkipped(TestDescription test, SkipReason reason) {
+                        testEvents.add(() -> listener.testSkipped(test, reason));
+                    }
+
+                    @Override
+                    public void testEnded(TestDescription test, Map<String, String> testMetrics) {
+                        testEvents.add(() -> listener.testEnded(test, testMetrics));
+                    }
+
+                    @Override
+                    public void testEnded(
+                            TestDescription test, HashMap<String, Metric> testMetrics) {
+                        testEvents.add(() -> listener.testEnded(test, testMetrics));
+                    }
+
+                    @Override
+                    public void testEnded(
+                            TestDescription test, long endTime, Map<String, String> testMetrics) {
+                        testEvents.add(() -> listener.testEnded(test, endTime, testMetrics));
+                    }
+
+                    @Override
+                    public void testEnded(
+                            TestDescription test,
+                            long endTime,
+                            HashMap<String, Metric> testMetrics) {
+                        testEvents.add(() -> listener.testEnded(test, endTime, testMetrics));
+                    }
+                };
+
+        try {
+            super.run(testInfo, delayListener);
+        } finally {
+            for (Runnable testEvent : testEvents) {
+                testEvent.run();
+            }
+        }
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/binary/KernelTargetTest.java b/test_framework/com/android/tradefed/testtype/binary/KernelTargetTest.java
index e988eab6b..bc20436d6 100644
--- a/test_framework/com/android/tradefed/testtype/binary/KernelTargetTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/KernelTargetTest.java
@@ -21,8 +21,8 @@ import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.DeviceRuntimeException;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.invoker.TestInformation;
-import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
@@ -34,6 +34,7 @@ import com.android.tradefed.util.CommandStatus;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -168,8 +169,8 @@ public class KernelTargetTest extends ExecutableTargetTest {
                 KTapResultParser.applyKTapResultToListener(
                         listener,
                         description.getTestName(),
-                        result.getStdout(),
-                        KTapResultParser.ParseResolution.AGGREGATED_TOP_LEVEL);
+                        List.of(result.getStdout()),
+                        KTapResultParser.ParseResolution.AGGREGATED_SUITE);
             } catch (RuntimeException exception) {
                 CLog.e("KTAP parse error: %s", exception.toString());
                 listener.testStarted(description);
diff --git a/test_framework/com/android/tradefed/testtype/junit4/BaseHostJUnit4Test.java b/test_framework/com/android/tradefed/testtype/junit4/BaseHostJUnit4Test.java
index 5933c9985..3cd3de958 100644
--- a/test_framework/com/android/tradefed/testtype/junit4/BaseHostJUnit4Test.java
+++ b/test_framework/com/android/tradefed/testtype/junit4/BaseHostJUnit4Test.java
@@ -20,7 +20,6 @@ import static org.junit.Assert.assertTrue;
 
 import com.android.annotations.VisibleForTesting;
 import com.android.ddmlib.Log.LogLevel;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
@@ -34,6 +33,7 @@ import com.android.tradefed.result.TestResult;
 import com.android.tradefed.result.TestRunResult;
 import com.android.tradefed.result.TestStatus;
 import com.android.tradefed.result.ddmlib.DefaultRemoteAndroidTestRunner;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.targetprep.BuildError;
 import com.android.tradefed.targetprep.TargetSetupError;
 import com.android.tradefed.targetprep.suite.SuiteApkInstaller;
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
index e988ce58e..4a0525885 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
@@ -315,10 +315,6 @@ public class MoblyBinaryHostTest
             return true;
         }
 
-        public boolean isMatched() {
-            return mMatched;
-        }
-
         @Override
         public String toString() {
             return mFilter;
@@ -370,34 +366,6 @@ public class MoblyBinaryHostTest
             tests.add(testName);
             if (!excluded && (included || includeFilters.isEmpty())) includedTests.add(testName);
         }
-        if (!includeFilters.isEmpty()) {
-            String invalidIncludeFilters =
-                    includeFilters.stream()
-                            .filter(filter -> !filter.isMatched())
-                            .map(filter -> filter.toString())
-                            .collect(Collectors.joining(", "));
-            if (!invalidIncludeFilters.isEmpty()) {
-                reportFailure(
-                        listener,
-                        runName,
-                        "Invalid include filters: [" + invalidIncludeFilters + "]");
-                return Optional.empty();
-            }
-        }
-        if (!excludeFilters.isEmpty()) {
-            String invalidExcludeFilters =
-                    excludeFilters.stream()
-                            .filter(filter -> !filter.isMatched())
-                            .map(filter -> filter.toString())
-                            .collect(Collectors.joining(", "));
-            if (!invalidExcludeFilters.isEmpty()) {
-                reportFailure(
-                        listener,
-                        runName,
-                        "Invalid exclude filters: [" + invalidExcludeFilters + "]");
-                return Optional.empty();
-            }
-        }
         return Optional.of(new Pair<>(tests, includedTests));
     }
 
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
index 6d7088a46..58ae60dfa 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
@@ -21,6 +21,7 @@ import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.proto.TestRecordProto;
+import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.testtype.mobly.IMoblyYamlResultHandler.ITestResult;
 import com.android.tradefed.testtype.mobly.MoblyYamlResultHandlerFactory.InvalidResultTypeException;
 
@@ -135,7 +136,13 @@ public class MoblyYamlResultParser {
                         listener.testStarted(testDescription, record.getBeginTime());
                         if (MoblyYamlResultRecordHandler.RecordResult.SKIP.equals(
                                 record.getResult())) {
-                            listener.testIgnored(testDescription);
+                            // In case of run failed, the most likely is that test did not execute
+                            if (mRunFailed) {
+                                SkipReason reason = new SkipReason(record.getStackTrace(), "");
+                                listener.testSkipped(testDescription, reason);
+                            } else {
+                                listener.testIgnored(testDescription);
+                            }
                         } else if (!MoblyYamlResultRecordHandler.RecordResult.PASS.equals(
                                 record.getResult())) {
                             listener.testFailed(testDescription, failureDescription);
diff --git a/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java b/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java
index 08ba4e814..f90d01ac2 100644
--- a/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java
+++ b/test_framework/com/android/tradefed/testtype/pandora/PtsBotTest.java
@@ -1,4 +1,5 @@
 /*
+ *
  * Copyright 2018 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -37,9 +38,13 @@ import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.PythonVirtualenvHelper;
 import com.android.tradefed.util.RunUtil;
 
+import com.google.gson.Gson;
+import com.google.gson.JsonSyntaxException;
+
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.text.SimpleDateFormat;
@@ -111,6 +116,20 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
     private static final String HFP_HF_PROPERTY = "bluetooth.profile.hfp.hf.enabled";
     private static final String HFP_AG_PROPERTY = "bluetooth.profile.hfp.ag.enabled";
 
+    private static final String NATIVE_BLUETOOTH_FLAG =
+            "setprop persist.device_config.aconfig_flags.bluetooth.com.android.bluetooth.flags";
+
+    public class TestFlagConfiguration {
+        List<FlagConfig> flags;
+
+        public class FlagConfig {
+            List<String> flags;
+            List<String> tests;
+        }
+    }
+
+    private TestFlagConfiguration testFlagConfiguration;
+
     private IRunUtil mRunUtil = new RunUtil();
 
     @Option(name = "pts-bot-path", description = "pts-bot binary path.")
@@ -204,6 +223,10 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
         excludeFilters.clear();
     }
 
+    public TestFlagConfiguration getTestFlagConfiguration() {
+        return testFlagConfiguration;
+    }
+
     private int shardIndex = 0;
     private int totalShards = 1;
 
@@ -286,6 +309,10 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
 
         ITestDevice testDevice = testInfo.getDevice();
 
+        // Parse the flags config file and initialize the default
+        // flags value.
+        initFlagsConfig(testDevice, testsConfigFile);
+
         // Forward allocated host Pandora Server port to actual DUT Pandora
         // Server ports.
         hostPandoraServerPort = adbForwardPort(testDevice, 0, PANDORA_SERVER_PORT);
@@ -471,20 +498,87 @@ public class PtsBotTest implements IRemoteTest, ITestFilterReceiver, IShardableT
                 Map<String, String> runMetrics = new HashMap<>();
 
                 listener.testRunStarted(profile, profileTests.length);
+                ITestDevice testDevice = testInfo.getDevice();
                 long startTimestamp = System.currentTimeMillis();
                 for (String testName : profileTests) {
-                    toggleA2dpSinkIfNeeded(testInfo.getDevice(), testName);
-                    toggleHfpHfIfNeeded(testInfo.getDevice(), testName);
-                    runPtsBotTest(profile, testName, testInfo, listener);
+                    toggleA2dpSinkIfNeeded(testDevice, testName);
+                    toggleHfpHfIfNeeded(testDevice, testName);
+                    boolean matchingFlagConfig = false;
+                    boolean unflagged = false;
+                    for (TestFlagConfiguration.FlagConfig flagConfig :
+                            testFlagConfiguration.flags) {
+                        if (flagConfig.tests.stream().anyMatch(testName::startsWith)) {
+                            matchingFlagConfig = true;
+                            flagConfig.flags.forEach(flag -> enableBluetoothFlag(testDevice, flag));
+                            runPtsBotTest(profile, testName, testInfo, listener);
+                            flagConfig.flags.forEach(
+                                    flag -> restoreBluetoothFlag(testDevice, flag));
+
+                            if (flagConfig.flags.stream().anyMatch("unflagged"::equals)) {
+                                unflagged = true;
+                            }
+                        }
+                    }
+                    if (!matchingFlagConfig || unflagged) {
+                        runPtsBotTest(profile, testName, testInfo, listener);
+                    }
+                    long endTimestamp = System.currentTimeMillis();
+                    listener.testRunEnded(endTimestamp - startTimestamp, runMetrics);
                 }
-                long endTimestamp = System.currentTimeMillis();
-                listener.testRunEnded(endTimestamp - startTimestamp, runMetrics);
             } else {
                 CLog.i("No tests applicable for %s", profile);
             }
         }
     }
 
+    private void shell(ITestDevice testDevice, String cmd) {
+        try {
+            CommandResult cmdResult = testDevice.executeShellV2Command(cmd);
+            if (cmdResult.getExitCode() != 0) {
+                CLog.e("Failed to run_cmd: " + cmdResult.getStderr());
+            }
+        } catch (DeviceNotAvailableException e) {
+            CLog.e("Device not available: " + e);
+        }
+    }
+
+    private void enableBluetoothFlag(ITestDevice testDevice, String flag) {
+        String setNativeFlagCmd = String.format("%s.%s true", NATIVE_BLUETOOTH_FLAG, flag);
+        shell(testDevice, setNativeFlagCmd);
+
+        String overrideFlagCmd =
+                String.format(
+                        "device_config override bluetooth com.android.bluetooth.flags.%s true",
+                        flag);
+        shell(testDevice, overrideFlagCmd);
+    }
+
+    private void restoreBluetoothFlag(ITestDevice testDevice, String flag) {
+        String clearOverrideCmd =
+                String.format(
+                        "device_config clear_override bluetooth com.android.bluetooth.flags.%s",
+                        flag);
+        shell(testDevice, clearOverrideCmd);
+
+        String restoreNativeFlagCmd = String.format("%s.%s \\\"\\\"", NATIVE_BLUETOOTH_FLAG, flag);
+        shell(testDevice, restoreNativeFlagCmd);
+    }
+
+    public void initFlagsConfig(ITestDevice testDevice, File testConfigFile) {
+        CLog.i("initFlagsConfig");
+        try {
+            Gson gson = new Gson();
+            FileReader reader = new FileReader(testConfigFile);
+            testFlagConfiguration = gson.fromJson(reader, TestFlagConfiguration.class);
+            List<TestFlagConfiguration.FlagConfig> flags = testFlagConfiguration.flags;
+            if (flags.isEmpty()) {
+                return;
+            }
+        } catch (IOException | JsonSyntaxException e) {
+            CLog.e("Error initFlagsConfig: " + e);
+        }
+    }
+
     private void toggleA2dpSinkIfNeeded(ITestDevice testDevice, String testName) {
         CLog.i("toggleA2dpSinkIfNeeded: " + testName);
         if (testName.startsWith("A2DP/SNK")
diff --git a/test_framework/com/android/tradefed/testtype/python/PythonBinaryHostTest.java b/test_framework/com/android/tradefed/testtype/python/PythonBinaryHostTest.java
index 8f6c76f2e..bebda62b6 100644
--- a/test_framework/com/android/tradefed/testtype/python/PythonBinaryHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/python/PythonBinaryHostTest.java
@@ -16,13 +16,19 @@
 package com.android.tradefed.testtype.python;
 
 import com.android.annotations.VisibleForTesting;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.GlobalConfiguration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.invoker.ExecutionFiles.FilesKey;
 import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.ByteArrayInputStreamSource;
@@ -32,13 +38,16 @@ import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.ResultForwarder;
+import com.android.tradefed.result.TestRunResultListener;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.IRemoteTest;
 import com.android.tradefed.testtype.ITestFilterReceiver;
 import com.android.tradefed.testtype.PythonUnitTestResultParser;
 import com.android.tradefed.testtype.TestTimeoutEnforcer;
 import com.android.tradefed.util.AdbUtils;
+import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.DeviceActionUtil;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.IRunUtil.EnvPriority;
@@ -60,8 +69,12 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
+import javax.annotation.Nullable;
+
 /**
  * Host test meant to run a python binary file from the Android Build system (Soong)
  *
@@ -70,7 +83,8 @@ import java.util.stream.Collectors;
  * exclude-filter will still be executed.
  */
 @OptionClass(alias = "python-host")
-public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
+public class PythonBinaryHostTest
+        implements IRemoteTest, ITestFilterReceiver, IConfigurationReceiver {
 
     protected static final String ANDROID_SERIAL_VAR = "ANDROID_SERIAL";
     protected static final String LD_LIBRARY_PATH = "LD_LIBRARY_PATH";
@@ -137,13 +151,37 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
                             + "in the expected format.")
     private boolean mUseTestOutputFile = false;
 
+    @Option(
+            name = "enable-cache",
+            description = "Used to enable/disable caching for specific modules.")
+    private boolean mEnableCache = false;
+
+    @Option(
+            name = "inherit-env-vars",
+            description =
+                    "Whether the subprocess should inherit environment variables from the main"
+                            + " process.")
+    private boolean mInheritEnvVars = true;
+
     @Option(
             name = TestTimeoutEnforcer.TEST_CASE_TIMEOUT_OPTION,
             description = TestTimeoutEnforcer.TEST_CASE_TIMEOUT_DESCRIPTION)
     private Duration mTestCaseTimeout = Duration.ofSeconds(0L);
 
+    // TODO(b/335688080): Remove this option once the caching is stable and no test needs this
+    // option.
+    @Option(
+            name = "additional-paths",
+            description =
+                    "Additional paths that will be appended to the `PATH` of the subprocess used to"
+                        + " execute the test. Note, the content of these paths won't be included in"
+                        + " the cache key set and using this option could cause false cache hit.")
+    private Set<String> mAdditionalPaths = new LinkedHashSet<>();
+
     private TestInformation mTestInfo;
     private IRunUtil mRunUtil;
+    private IConfiguration mConfiguration = new Configuration("", "");
+    private TestRunResultListener mTestRunResultListener;
 
     /** {@inheritDoc} */
     @Override
@@ -193,9 +231,17 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
         return mExcludeFilters;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+    }
+
     @Override
     public final void run(TestInformation testInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
+        mTestRunResultListener = new TestRunResultListener();
+        listener = new ResultForwarder(listener, mTestRunResultListener);
         mTestInfo = testInfo;
         File testDir = mTestInfo.executionFiles().get(FilesKey.HOST_TESTS_DIRECTORY);
         if (testDir == null || !testDir.exists()) {
@@ -264,13 +310,37 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
             commandLine.add(mTestInfo.getDevice().getSerialNumber());
         }
         // Set the process working dir as the directory of the main binary
-        getRunUtil().setWorkingDir(pyFile.getParentFile());
+        File workingDir = pyFile.getParentFile();
+        getRunUtil().setWorkingDir(workingDir);
         // Set the parent dir on the PATH
         String separator = System.getProperty("path.separator");
         List<String> paths = new ArrayList<>();
+        // Link adb and aapt to working dir as default dependencies.
+        String runtimeDepsFolderName = "runtime_deps";
+        try {
+            RunUtil.linkFile(workingDir, runtimeDepsFolderName, getAdb());
+        } catch (IOException | DeviceActionUtil.DeviceActionConfigError e) {
+            CLog.e("Failed to link adb to working dir %s", workingDir);
+            CLog.e(e);
+        }
+        try {
+            // This is for backward compatibility. Nowaday we only use aapt2, but in some older
+            // branches, such as git_tm-dev, aapt is still required.
+            RunUtil.linkFile(workingDir, runtimeDepsFolderName, getAapt());
+        } catch (IOException | DeviceActionUtil.DeviceActionConfigError e) {
+            CLog.e("Failed to link aapt to working dir %s", workingDir);
+            CLog.e(e);
+        }
+        try {
+            RunUtil.linkFile(workingDir, runtimeDepsFolderName, getAapt2());
+        } catch (IOException | DeviceActionUtil.DeviceActionConfigError e) {
+            CLog.e("Failed to link aapt2 to working dir %s", workingDir);
+            CLog.e(e);
+        }
         // Bundle binaries / dependencies have priorities over existing PATH
-        paths.addAll(findAllSubdir(pyFile.getParentFile(), new ArrayList<>()));
-        paths.add(System.getenv("PATH"));
+        paths.addAll(toRelative(workingDir, findAllSubdir(workingDir, new ArrayList<>())));
+        paths.addAll(mAdditionalPaths);
+        paths.add("/usr/bin");
         String path = paths.stream().distinct().collect(Collectors.joining(separator));
         CLog.d("Using updated $PATH: %s", path);
         getRunUtil().setEnvVariablePriority(EnvPriority.SET);
@@ -305,6 +375,21 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
         }
 
         AdbUtils.updateAdb(testInfo, getRunUtil(), getAdbPath());
+
+        // Pass the test filters to python's unittest framework.
+        for (String filter : mIncludeFilters) {
+            // Python's unittest filter will accept the fully qualified class name without
+            // the method name.
+            // If a method name is passed, replace the filter by the method name only.
+            mTestOptions.add("-k");
+            String testName = getTestNameFromFullyQualifiedName(filter);
+            if (testName != null) {
+                mTestOptions.add(testName);
+                continue;
+            }
+            mTestOptions.add(filter);
+        }
+
         // Add all the other options
         commandLine.addAll(mTestOptions);
 
@@ -320,9 +405,18 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
         PythonUnitTestResultParser pythonParser =
                 new PythonUnitTestResultParser(
                         Arrays.asList(receiver), "python-run", mIncludeFilters, mExcludeFilters);
+        String instanceName =
+                mEnableCache
+                        ? mConfiguration.getCommandOptions().getRemoteCacheInstanceName()
+                        : null;
+        ICacheClient cacheClient =
+                Strings.isNullOrEmpty(instanceName)
+                        ? null
+                        : getCacheClient(CurrentInvocation.getWorkFolder(), instanceName);
 
         CommandResult result = null;
         File stderrFile = null;
+        File stdoutFile = null;
         try {
             stderrFile = FileUtil.createTempFile("python-res", ".txt");
             if (mUseTestOutputFile) {
@@ -330,16 +424,26 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
             } else {
                 try (FileOutputStream fileOutputParser = new FileOutputStream(stderrFile)) {
                     result =
-                            getRunUtil()
-                                    .runTimedCmd(
-                                            mTestTimeout,
-                                            null,
-                                            fileOutputParser,
-                                            commandLine.toArray(new String[0]));
+                            cacheClient == null
+                                    ? getRunUtil()
+                                            .runTimedCmd(
+                                                    mTestTimeout,
+                                                    null,
+                                                    fileOutputParser,
+                                                    commandLine.toArray(new String[0]))
+                                    : getRunUtil()
+                                            .runTimedCmdWithOutputMonitor(
+                                                    mTestTimeout,
+                                                    0,
+                                                    null,
+                                                    fileOutputParser,
+                                                    cacheClient,
+                                                    commandLine.toArray(new String[0]));
                     fileOutputParser.flush();
                 }
             }
 
+            stdoutFile = FileUtil.createTempFile("python-stdout", ".txt");
             if (!Strings.isNullOrEmpty(result.getStdout())) {
                 CLog.i("\nstdout:\n%s", result.getStdout());
                 try (InputStreamSource data =
@@ -349,6 +453,7 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
                             LogDataType.TEXT,
                             data);
                 }
+                FileUtil.writeToFile(result.getStdout(), stdoutFile);
             }
             if (!Strings.isNullOrEmpty(result.getStderr())) {
                 CLog.i("\nstderr:\n%s", result.getStderr());
@@ -364,6 +469,13 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
             }
             String testOutput = FileUtil.readStringFromFile(testOutputFile);
             pythonParser.processNewLines(testOutput.split("\n"));
+            if (!result.isCached() && !mTestRunResultListener.isTestRunFailed(runName)) {
+                getRunUtil()
+                        .uploadCache(
+                                cacheClient,
+                                ExecutableActionResult.create(
+                                        result.getExitCode(), stdoutFile, stderrFile));
+            }
         } catch (RuntimeException e) {
             StringBuilder message = new StringBuilder();
             String stderr = "";
@@ -407,19 +519,50 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
                     CLog.e(e);
                 }
             }
+            FileUtil.deleteFile(stdoutFile);
             FileUtil.deleteFile(stderrFile);
             FileUtil.deleteFile(tempTestOutputFile);
         }
     }
 
+    @Nullable
+    private String getTestNameFromFullyQualifiedName(String fullyQualifiedName) {
+        Pattern p = Pattern.compile(".*#(\\w*)");
+        Matcher matcher = p.matcher(fullyQualifiedName);
+        if (!matcher.matches()) {
+            return null;
+        }
+        return matcher.group(1);
+    }
+
     @VisibleForTesting
     IRunUtil getRunUtil() {
         if (mRunUtil == null) {
-            mRunUtil = new RunUtil();
+            mRunUtil = new RunUtil(mInheritEnvVars);
         }
         return mRunUtil;
     }
 
+    @VisibleForTesting
+    ICacheClient getCacheClient(File workFolder, String instanceName) {
+        return CacheClientFactory.createCacheClient(workFolder, instanceName);
+    }
+
+    @VisibleForTesting
+    File getAapt() throws DeviceActionUtil.DeviceActionConfigError {
+        return DeviceActionUtil.findExecutableOnPath("aapt");
+    }
+
+    @VisibleForTesting
+    File getAapt2() throws DeviceActionUtil.DeviceActionConfigError {
+        return DeviceActionUtil.findExecutableOnPath("aapt2");
+    }
+
+    @VisibleForTesting
+    File getAdb() throws DeviceActionUtil.DeviceActionConfigError {
+        return DeviceActionUtil.findExecutableOnPath("adb");
+    }
+
     @VisibleForTesting
     String getAdbPath() {
         return GlobalConfiguration.getDeviceManagerInstance().getAdbPath();
@@ -441,6 +584,13 @@ public class PythonBinaryHostTest implements IRemoteTest, ITestFilterReceiver {
         return subDir;
     }
 
+    private static List<String> toRelative(File start, List<String> paths) {
+        return paths.stream()
+                .map(p -> RunUtil.toRelative(start, p))
+                .sorted()
+                .collect(Collectors.toList());
+    }
+
     private void reportFailure(
             ITestInvocationListener listener, String runName, String errorMessage) {
         listener.testRunStarted(runName, 0);
diff --git a/test_framework/com/android/tradefed/testtype/rust/RustBinaryHostTest.java b/test_framework/com/android/tradefed/testtype/rust/RustBinaryHostTest.java
index 99a51c588..a1668c607 100644
--- a/test_framework/com/android/tradefed/testtype/rust/RustBinaryHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/rust/RustBinaryHostTest.java
@@ -15,24 +15,34 @@
  */
 package com.android.tradefed.testtype.rust;
 
+import static com.android.tradefed.testtype.coverage.CoverageOptions.Toolchain.CLANG;
+import static com.android.tradefed.util.EnvironmentVariableUtil.buildPathWithRelativePaths;
+
 import com.android.annotations.VisibleForTesting;
 import com.android.ddmlib.IShellOutputReceiver;
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.cache.ExecutableActionResult;
+import com.android.tradefed.cache.ICacheClient;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.invoker.logger.CurrentInvocation;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.ResultForwarder;
+import com.android.tradefed.result.TestRunResultListener;
 import com.android.tradefed.result.error.TestErrorIdentifier;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.IBuildReceiver;
+import com.android.tradefed.util.CacheClientFactory;
+import com.android.tradefed.util.ClangProfileIndexer;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
@@ -40,10 +50,13 @@ import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.TestRunnerUtil;
 
+import com.google.common.base.Strings;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -59,7 +72,21 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
     @Option(name = "test-file", description = "The test file name or file path.")
     private Set<String> mBinaryNames = new HashSet<>();
 
+    @Option(
+            name = "enable-cache",
+            description = "Used to enable/disable caching for specific modules.")
+    private boolean mEnableCache = false;
+
+    @Option(
+            name = "inherit-env-vars",
+            description =
+                    "Whether the subprocess should inherit environment variables from the main"
+                            + " process.")
+    private boolean mInheritEnvVars = true;
+
+    private File mCoverageDir;
     private IBuildInfo mBuildInfo;
+    private TestRunResultListener mTestRunResultListener;
 
     @Override
     public void setBuild(IBuildInfo buildInfo) {
@@ -70,6 +97,8 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
     public final void run(TestInformation testInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
         try {
+            mTestRunResultListener = new TestRunResultListener();
+            listener = new ResultForwarder(listener, mTestRunResultListener);
             List<File> rustFilesList = findFiles();
             for (File file : rustFilesList) {
                 if (!file.exists()) {
@@ -143,7 +172,6 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
                         }
                     }
                 }
-
             }
             if (res == null) {
                 throw new RuntimeException(
@@ -156,6 +184,7 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
 
     private void runSingleRustFile(ITestInvocationListener listener, File file) {
         CLog.d("Run single Rust File: %s", file.getAbsolutePath());
+        String runName = file.getName();
         List<Invocation> invocations = generateInvocations(file);
 
         Set<String> foundTests = new HashSet<>();
@@ -165,7 +194,7 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
                 FailureDescription failure =
                         FailureDescription.create(
                                 "Could not count the number of tests", FailureStatus.TEST_FAILURE);
-                listener.testRunStarted(file.getName(), 0);
+                listener.testRunStarted(runName, 0);
                 listener.testRunFailed(failure);
                 listener.testRunEnded(0, new HashMap<String, Metric>());
                 CLog.e(failure.getErrorMessage());
@@ -175,16 +204,39 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
         int testCount = foundTests.size();
         CLog.d("Total test count: %d", testCount);
         long startTimeMs = System.currentTimeMillis();
-        listener.testRunStarted(file.getName(), testCount, 0, startTimeMs);
+        listener.testRunStarted(runName, testCount, 0, startTimeMs);
         if (testCount > 0) {
             for (Invocation invocation : invocations) {
+                File profdata = null;
                 try {
-                    runTest(listener, invocation, file.getName());
+                    runTest(listener, invocation, runName);
+                    if (isClangCoverageEnabled()) {
+                        Set<String> profraws = FileUtil.findFiles(mCoverageDir, ".*\\.profraw");
+                        ClangProfileIndexer indexer =
+                                new ClangProfileIndexer(
+                                        getConfiguration()
+                                                .getCoverageOptions()
+                                                .getLlvmProfdataPath());
+                        profdata = FileUtil.createTempFile(runName, ".profdata");
+                        indexer.index(profraws, profdata);
+
+                        try (FileInputStreamSource source =
+                                new FileInputStreamSource(profdata, true)) {
+                            listener.testLog(runName, LogDataType.CLANG_COVERAGE, source);
+                        }
+                    }
                 } catch (IOException e) {
                     listener.testRunFailed(e.getMessage());
                     long testTimeMs = System.currentTimeMillis() - startTimeMs;
                     listener.testRunEnded(testTimeMs, new HashMap<String, Metric>());
                     throw new RuntimeException(e);
+                } finally {
+                    if (isClangCoverageEnabled()) {
+                        FileUtil.deleteFile(profdata);
+                        FileUtil.recursiveDelete(mCoverageDir);
+                        mCoverageDir = null;
+                    }
+                    profdata = null;
                 }
             }
         }
@@ -193,7 +245,7 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
     }
 
     private boolean countTests(Invocation invocation, Set<String> foundTests) {
-        CommandResult listResult = runInvocation(invocation, "--list");
+        CommandResult listResult = runInvocation(invocation, null, getRunUtil(), "--list");
         // TODO: Do we want to handle non-standard test harnesses without a
         // --list param? Currently we will report 0 tests, which will cause an
         // overall failure, but we don't know how to parse arbitrary test
@@ -211,8 +263,11 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
         }
     }
 
-    private CommandResult runInvocation(final Invocation invocation, final String... extraArgs) {
-        IRunUtil runUtil = getRunUtil();
+    private CommandResult runInvocation(
+            final Invocation invocation,
+            ICacheClient cacheClient,
+            IRunUtil runUtil,
+            final String... extraArgs) {
         runUtil.setWorkingDir(invocation.workingDir);
         runUtil.unsetEnvVariable(
                 "TERM"); // Environment TERM can affect output format and fail parser
@@ -230,16 +285,43 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
                 runUtil.setEnvVariable("LD_LIBRARY_PATH", ldLibraryPath);
             }
         }
+        if (isClangCoverageEnabled()) {
+            try {
+                mCoverageDir = FileUtil.createTempDir("clang");
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+            runUtil.setEnvVariable(
+                    "LLVM_PROFILE_FILE", mCoverageDir.getAbsolutePath() + "/clang-%m.profraw");
+        }
+
+        runUtil.setEnvVariable(
+                "PATH",
+                buildPathWithRelativePaths(
+                        invocation.workingDir, Collections.singleton("adb"), "/usr/bin"));
         ArrayList<String> command = new ArrayList<String>(Arrays.asList(invocation.command));
         command.addAll(Arrays.asList(extraArgs));
-        return runUtil.runTimedCmd(mTestTimeout, command.toArray(new String[0]));
+        return cacheClient == null
+                ? runUtil.runTimedCmd(mTestTimeout, command.toArray(new String[0]))
+                : runUtil.runTimedCmdWithOutputMonitor(
+                        mTestTimeout, 0, null, null, cacheClient, command.toArray(new String[0]));
     }
 
     private void runTest(
             ITestInvocationListener listener, final Invocation invocation, final String runName)
             throws IOException {
 
-        CommandResult result = runInvocation(invocation);
+        String instanceName =
+                mEnableCache
+                        ? getConfiguration().getCommandOptions().getRemoteCacheInstanceName()
+                        : null;
+        ICacheClient cacheClient =
+                Strings.isNullOrEmpty(instanceName)
+                        ? null
+                        : getCacheClient(CurrentInvocation.getWorkFolder(), instanceName);
+
+        IRunUtil runUtil = getRunUtil();
+        CommandResult result = runInvocation(invocation, cacheClient, runUtil);
 
         if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
             String message =
@@ -254,19 +336,21 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
             CLog.e(message);
         }
 
-        File resultFile = null;
+        File stdoutFile = null;
+        File stderrFile = null;
         try {
-            resultFile = FileUtil.createTempFile("rust-res", ".txt");
+            stdoutFile = FileUtil.createTempFile("rust-stdout", ".txt");
+            stderrFile = FileUtil.createTempFile("rust-stderr", ".txt");
             if (result.getStderr().length() > 0) {
-                FileUtil.writeToFile(result.getStderr(), resultFile);
-                try (FileInputStreamSource data = new FileInputStreamSource(resultFile)) {
+                FileUtil.writeToFile(result.getStderr(), stderrFile);
+                try (FileInputStreamSource data = new FileInputStreamSource(stderrFile)) {
                     listener.testLog(
                             String.format(RUST_LOG_STDERR_FORMAT, runName), LogDataType.TEXT, data);
                 }
             }
             if (result.getStdout().length() > 0) {
-                FileUtil.writeToFile(result.getStdout(), resultFile);
-                try (FileInputStreamSource data = new FileInputStreamSource(resultFile)) {
+                FileUtil.writeToFile(result.getStdout(), stdoutFile);
+                try (FileInputStreamSource data = new FileInputStreamSource(stdoutFile)) {
                     listener.testLog(
                             String.format(RUST_LOG_STDOUT_FORMAT, runName), LogDataType.TEXT, data);
                 }
@@ -274,17 +358,34 @@ public class RustBinaryHostTest extends RustTestBase implements IBuildReceiver {
             IShellOutputReceiver parser = createParser(listener, runName);
             parser.addOutput(result.getStdout().getBytes(), 0, result.getStdout().length());
             parser.flush();
+            if (!result.isCached() && !mTestRunResultListener.isTestRunFailed(runName)) {
+                runUtil.uploadCache(
+                        cacheClient,
+                        ExecutableActionResult.create(
+                                result.getExitCode(), stdoutFile, stderrFile));
+            }
         } catch (RuntimeException e) {
             listener.testRunFailed(
                     String.format("Failed to parse the rust test output: %s", e.getMessage()));
             CLog.e(e);
         } finally {
-            FileUtil.deleteFile(resultFile);
+            FileUtil.deleteFile(stdoutFile);
+            FileUtil.deleteFile(stderrFile);
         }
     }
 
     @VisibleForTesting
     IRunUtil getRunUtil() {
-        return new RunUtil();
+        return new RunUtil(mInheritEnvVars);
+    }
+
+    @VisibleForTesting
+    ICacheClient getCacheClient(File workFolder, String instanceName) {
+        return CacheClientFactory.createCacheClient(workFolder, instanceName);
+    }
+
+    private boolean isClangCoverageEnabled() {
+        return getConfiguration().getCoverageOptions().isCoverageEnabled()
+                && getConfiguration().getCoverageOptions().getCoverageToolchains().contains(CLANG);
     }
-}
+}
\ No newline at end of file
diff --git a/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java b/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java
index 3eb494207..231ceab34 100644
--- a/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java
+++ b/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java
@@ -16,14 +16,17 @@
 package com.android.tradefed.testtype.rust;
 
 import com.android.ddmlib.IShellOutputReceiver;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.ITestInvocationListener;
-import com.android.tradefed.testtype.IRemoteTest;
-import com.android.tradefed.testtype.ITestFilterReceiver;
 import com.android.tradefed.testtype.IAbi;
 import com.android.tradefed.testtype.IAbiReceiver;
+import com.android.tradefed.testtype.IRemoteTest;
+import com.android.tradefed.testtype.ITestFilterReceiver;
 
 import com.google.common.annotations.VisibleForTesting;
 
@@ -35,7 +38,8 @@ import java.util.Set;
 
 /** Base class of RustBinaryHostTest and RustBinaryTest */
 @OptionClass(alias = "rust-test")
-public abstract class RustTestBase implements IRemoteTest, ITestFilterReceiver, IAbiReceiver {
+public abstract class RustTestBase
+        implements IRemoteTest, ITestFilterReceiver, IAbiReceiver, IConfigurationReceiver {
     protected class EnvPair {
         public String key;
         public String val;
@@ -104,6 +108,8 @@ public abstract class RustTestBase implements IRemoteTest, ITestFilterReceiver,
                             + "for 64-bit tests.")
     private String mLdLibraryPath64 = null;
 
+    private IConfiguration mConfiguration = null;
+
     private IAbi mAbi;
 
     @Override
@@ -264,4 +270,22 @@ public abstract class RustTestBase implements IRemoteTest, ITestFilterReceiver,
 
         return out;
     }
+
+    /**
+     * Returns the test configuration.
+     *
+     * @return an IConfiguration
+     */
+    protected IConfiguration getConfiguration() {
+        if (mConfiguration == null) {
+            return new Configuration("", "");
+        }
+        return mConfiguration;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+    }
 }
diff --git a/test_framework/com/android/tradefed/util/AdbUtils.java b/test_framework/com/android/tradefed/util/AdbUtils.java
index eb8d2ca7d..9b3ced352 100644
--- a/test_framework/com/android/tradefed/util/AdbUtils.java
+++ b/test_framework/com/android/tradefed/util/AdbUtils.java
@@ -16,8 +16,8 @@
 
 package com.android.tradefed.util;
 
-import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.invoker.ExecutionFiles.FilesKey;
+import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.LogUtil.CLog;
 
 import java.io.File;
@@ -36,22 +36,7 @@ public class AdbUtils {
      * @param adbPath The path to the adb binary.
      */
     public static void updateAdb(TestInformation testInfo, IRunUtil runUtil, String adbPath) {
-        File updatedAdb = testInfo.executionFiles().get(FilesKey.ADB_BINARY);
-        if (updatedAdb == null) {
-            // Don't check if it's the adb on the $PATH
-            if (!adbPath.equals("adb")) {
-                updatedAdb = new File(adbPath);
-                if (!updatedAdb.exists()) {
-                    CLog.w(
-                            String.format(
-                                    "adb path %s doesn't exist. Fall back on the abd in $PATH",
-                                    adbPath));
-                    updatedAdb = null;
-                }
-            } else {
-                CLog.d("Use the adb in the $PATH.");
-            }
-        }
+        File updatedAdb = getAdbToUpdate(testInfo, adbPath);
         if (updatedAdb == null) {
             return;
         }
@@ -80,4 +65,31 @@ public class AdbUtils {
         CLog.d("%s", versionRes.getStdout());
         CLog.d("%s", versionRes.getStderr());
     }
+
+    /**
+     * Gets the special adb set in test information that should be set in PATH.
+     *
+     * @param testInfo A {@link TestInformation} object.
+     * @param adbPath The path to the adb binary.
+     * @return The adb that should be set in PATH.
+     */
+    public static File getAdbToUpdate(TestInformation testInfo, String adbPath) {
+        File updatedAdb = testInfo.executionFiles().get(FilesKey.ADB_BINARY);
+        if (updatedAdb == null) {
+            // Don't check if it's the adb on the $PATH
+            if (!adbPath.equals("adb")) {
+                updatedAdb = new File(adbPath);
+                if (!updatedAdb.exists()) {
+                    CLog.w(
+                            String.format(
+                                    "adb path %s doesn't exist. Fall back on the abd in $PATH",
+                                    adbPath));
+                    updatedAdb = null;
+                }
+            } else {
+                CLog.d("Use the adb in the $PATH.");
+            }
+        }
+        return updatedAdb;
+    }
 }
diff --git a/test_framework/com/android/tradefed/util/DeviceActionUtil.java b/test_framework/com/android/tradefed/util/DeviceActionUtil.java
index 8c36d1ccf..36ffe51ec 100644
--- a/test_framework/com/android/tradefed/util/DeviceActionUtil.java
+++ b/test_framework/com/android/tradefed/util/DeviceActionUtil.java
@@ -232,7 +232,7 @@ public class DeviceActionUtil {
         }
     }
 
-    private static File findExecutableOnPath(String name) throws DeviceActionConfigError {
+    public static File findExecutableOnPath(String name) throws DeviceActionConfigError {
         return Splitter.on(File.pathSeparator).splitToList(System.getenv(PATH)).stream()
                 .map(dir -> new File(dir, name))
                 .filter(f -> f.isFile() && f.canExecute())
diff --git a/test_framework/com/android/tradefed/util/EnvironmentVariableUtil.java b/test_framework/com/android/tradefed/util/EnvironmentVariableUtil.java
new file mode 100644
index 000000000..b3c3e4ba1
--- /dev/null
+++ b/test_framework/com/android/tradefed/util/EnvironmentVariableUtil.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.util;
+
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Set;
+
+/** A collection of helper methods to prepare environment variables. */
+public class EnvironmentVariableUtil {
+
+    /**
+     * Builds the value of PATH with relative paths to the {@code workingDir}.
+     *
+     * @param workingDir The root of the relative paths in the return.
+     * @param tools A list of tools that will be linked to a folder named `runtime_deps` under the
+     *     {@code workingDir} and included in the return.
+     * @param addition The String that will be appended to the end of the return.
+     * @return The value of PATH.
+     */
+    public static String buildPathWithRelativePaths(
+            File workingDir, Set<String> tools, String addition) {
+        String runtimeDepsFolderName = "runtime_deps";
+        for (String t : tools) {
+            try {
+                File tool = new File(t);
+                RunUtil.linkFile(
+                        workingDir,
+                        runtimeDepsFolderName,
+                        tool.exists() ? tool : DeviceActionUtil.findExecutableOnPath(t));
+            } catch (IOException | DeviceActionUtil.DeviceActionConfigError e) {
+                CLog.e("Failed to link %s to working dir %s", t, workingDir);
+                CLog.e(e);
+            }
+        }
+
+        return String.format(".:%s:%s", runtimeDepsFolderName, addition);
+    }
+}
diff --git a/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java b/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java
index fe7b843bc..6d1508bab 100644
--- a/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java
+++ b/test_observatory/com/android/tradefed/observatory/TestDiscoveryExecutor.java
@@ -18,8 +18,6 @@ package com.android.tradefed.observatory;
 
 import com.android.annotations.VisibleForTesting;
 import com.android.ddmlib.DdmPreferences;
-import com.android.ddmlib.Log;
-import com.android.ddmlib.Log.LogLevel;
 import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.ConfigurationFactory;
@@ -28,6 +26,8 @@ import com.android.tradefed.config.IConfigurationFactory;
 import com.android.tradefed.invoker.tracing.ActiveTrace;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.invoker.tracing.TracingLogger;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogRegistry;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.log.StdoutLogger;
@@ -378,37 +378,47 @@ public class TestDiscoveryExecutor {
         }
         CLog.d("Seaching parent configs.");
         try (CloseableTraceScope ignored = new CloseableTraceScope("find parent configs")) {
-            Set<File> testCasesDirs = FileUtil.findFilesObject(new File(rootDirPath), "testcases");
+            Set<File> testCasesDirs = new LinkedHashSet<File>();
+            if (new File(rootDirPath, "host/testcases/").exists()) {
+                testCasesDirs.add(new File(rootDirPath, "host/testcases/"));
+            }
+            if (new File(rootDirPath, "target/testcases/").exists()) {
+                testCasesDirs.add(new File(rootDirPath, "target/testcases/"));
+            }
+            CLog.d("testcases folders: %s", testCasesDirs);
             Set<String> moduleDirs = Collections.synchronizedSet(new HashSet<>());
-            testCasesDirs.parallelStream()
-                    .forEach(
-                            f -> {
-                                String[] modules = f.list();
-                                if (modules != null) {
-                                    moduleDirs.addAll(Arrays.asList(modules));
-                                }
-                            });
+            try (CloseableTraceScope listDirs = new CloseableTraceScope("list_module_dirs")) {
+                testCasesDirs.parallelStream()
+                        .forEach(
+                                f -> {
+                                    String[] modules = f.list();
+                                    if (modules != null) {
+                                        moduleDirs.addAll(Arrays.asList(modules));
+                                    }
+                                });
+            }
             Set<String> moduleNameMismatch =
                     moduleNames.parallelStream()
                             .filter(m -> !moduleDirs.contains(m))
                             .collect(Collectors.toSet());
             // Only search the mismatch
-            moduleNameMismatch.parallelStream()
-                    .forEach(
-                            name -> {
-                                File config =
-                                        FileUtil.findFile(new File(rootDirPath), name + ".config");
-                                if (config != null) {
-                                    if (!config.getParentFile().getName().equals(name)) {
-                                        CLog.d(
-                                                "Parent: %s being added for the extra configs",
-                                                config.getParentFile().getName());
-                                        parentModules.add(config.getParentFile().getName());
+            try (CloseableTraceScope listDirs = new CloseableTraceScope("search_mismatch")) {
+                moduleNameMismatch.parallelStream()
+                        .forEach(
+                                name -> {
+                                    File config =
+                                            FileUtil.findFile(
+                                                    new File(rootDirPath), name + ".config");
+                                    if (config != null) {
+                                        if (!config.getParentFile().getName().equals(name)) {
+                                            CLog.d(
+                                                    "Parent: %s being added for the extra configs",
+                                                    config.getParentFile().getName());
+                                            parentModules.add(config.getParentFile().getName());
+                                        }
                                     }
-                                }
-                            });
-        } catch (IOException e) {
-            CLog.e(e);
+                                });
+            }
         }
         CLog.d("Done searching parent configs.");
         return parentModules;
diff --git a/tools/content_uploader.py b/tools/content_uploader.py
index 33318dd18..ab37b5f6c 100644
--- a/tools/content_uploader.py
+++ b/tools/content_uploader.py
@@ -14,444 +14,57 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
-"""The script to upload generated artifacts from build server to CAS."""
-import argparse
-import copy
-import dataclasses
+"""The script to invoke content_uploader binary to upload artifacts to CAS."""
 import glob
-import json
 import logging
 import os
-import shutil
 import subprocess
-import tempfile
-import time
-import re
+import sys
 
-
-@dataclasses.dataclass
-class ArtifactConfig:
-    """Configuration of an artifact to be uploaded to CAS.
-
-    Attributes:
-        source_path: path to the artifact that relative to the root of source code.
-        unzip: true if the artifact should be unzipped and uploaded as a directory.
-        chunk: true if the artifact should be uploaded with chunking.
-        chunk_fallback: true if a regular version (no chunking) of the artifact should be uploaded.
-        exclude_filters: a list of regular expressions for files that are excluded from uploading.
-    """
-    source_path: str
-    unzip: bool
-    chunk: bool = False
-    chunk_fallback: bool = False
-    exclude_filters: list[str] = dataclasses.field(default_factory=list)
-
-
-@dataclasses.dataclass
-class CasInfo:
-    """Basic information of CAS server and client.
-
-    Attributes:
-        cas_instance: the instance name of CAS service.
-        cas_service: the address of CAS service.
-        client_path: path to the CAS uploader client.
-        version: version of the CAS uploader client, in turple format.
-    """
-    cas_instance: str
-    cas_service: str
-    client_path: str
-    client_version: tuple
-
-
-@dataclasses.dataclass
-class UploadResult:
-    """Result of uploading a single artifact with CAS client.
-
-    Attributes:
-        digest: root digest of the artifact.
-        content_details: detail information of all uploaded files inside the uploaded artifact.
-    """
-    digest: str
-    content_details: list[dict[str,any]]
-
-
-CAS_UPLOADER_PREBUILT_PATH = 'tools/tradefederation/prebuilts/'
-CAS_UPLOADER_PATH = 'tools/content_addressed_storage/prebuilts/'
-CAS_UPLOADER_BIN = 'casuploader'
-
-UPLOADER_TIMEOUT_SECS = 600 # 10 minutes
-AVG_CHUNK_SIZE_IN_KB = 128
-
-DIGESTS_PATH = 'cas_digests.json'
+CONTENT_PLOADER_PREBUILT_PATH = 'tools/tradefederation/prebuilts/'
+CONTENT_UPLOADER_BIN = 'content_uploader'
+CONTENT_UPLOADER_TIMEOUT_SECS = 1800 # 30 minutes
 LOG_PATH = 'logs/cas_uploader.log'
-CONTENT_DETAILS_PATH = 'logs/cas_content_details.json'
-CHUNKED_ARTIFACT_NAME_PREFIX = "_chunked_"
-CHUNKED_DIR_ARTIFACT_NAME_PREFIX = "_chunked_dir_"
-
-# Configurations of artifacts will be uploaded to CAS.
-# TODO(b/298890453) Add artifacts after this script is attached to build process.
-# If configs share files, chunking enabled artifacts should come first.
-ARTIFACTS = [
-    # test_suite targets
-    ArtifactConfig('android-catbox.zip', True),
-    ArtifactConfig('android-csuite.zip', True),
-    ArtifactConfig('android-cts.zip', True, exclude_filters=['android-cts/jdk/.*']),
-    ArtifactConfig('android-gcatbox.zip', True),
-    ArtifactConfig('android-gts.zip', True, exclude_filters=['android-gts/jdk/.*']),
-    ArtifactConfig('android-mcts.zip', True),
-    ArtifactConfig('android-mts.zip', True, exclude_filters=['android-mts/jdk/.*']),
-    ArtifactConfig('android-pts.zip', True, exclude_filters=['android-pts/jdk/.*']),
-    ArtifactConfig('android-sts.zip', True),
-    ArtifactConfig('android-vts.zip', True),
-    ArtifactConfig('android-wts.zip', True, exclude_filters=['android-wts/jdk/.*']),
-    ArtifactConfig('art-host-tests.zip', True),
-    ArtifactConfig('bazel-test-suite.zip', True),
-    ArtifactConfig('host-unit-tests.zip', True),
-    ArtifactConfig('general-tests.zip', True),
-    ArtifactConfig('general-tests_configs.zip', True),
-    ArtifactConfig('general-tests_host-shared-libs.zip', True),
-    ArtifactConfig('tradefed.zip', True),
-    ArtifactConfig('google-tradefed.zip', True),
-    ArtifactConfig('robolectric-tests.zip', True),
-    ArtifactConfig('ravenwood-tests.zip', True),
-    ArtifactConfig('test_mappings.zip', True),
-
-    # Mainline artifacts
-    ArtifactConfig('*.apex', False),
-    ArtifactConfig('*.apk', False),
-
-    # Device target artifacts
-    ArtifactConfig('androidTest.zip', True),
-    ArtifactConfig('device-tests.zip', True),
-    ArtifactConfig('device-tests_configs.zip', True),
-    ArtifactConfig('device-tests_host-shared-libs.zip', True),
-    ArtifactConfig('performance-tests.zip', True),
-    ArtifactConfig('device-platinum-tests.zip', True),
-    ArtifactConfig('device-platinum-tests_configs.zip', True),
-    ArtifactConfig('device-platinum-tests_host-shared-libs.zip', True),
-    ArtifactConfig('device-pixel-tests.zip', True),
-    ArtifactConfig('device-pixel-tests_configs.zip', True),
-    ArtifactConfig('device-pixel-tests_host-shared-libs.zip', True),
-    ArtifactConfig('*-tests-*zip', True),
-    ArtifactConfig('*-continuous_instrumentation_tests-*zip', True),
-    ArtifactConfig('*-continuous_instrumentation_metric_tests-*zip', True),
-    ArtifactConfig('*-continuous_native_tests-*zip', True),
-    ArtifactConfig('cvd-host_package.tar.gz', False),
-    ArtifactConfig('bootloader.img', False),
-    ArtifactConfig('radio.img', False),
-    ArtifactConfig('*-target_files-*.zip', True),
-    ArtifactConfig('*-img-*zip', True, True, True)
-]
-
-# Artifacts will be uploaded if the config name is set in arguments `--experiment_artifacts`.
-# These configs are usually used to upload artifacts in partial branches/targets for experiment
-# purpose.
-# A sample entry:
-#   "device_image_target_files": ArtifactConfig('*-target_files-*.zip', True)
-EXPERIMENT_ARTIFACT_CONFIGS = {
-    "device_image_proguard_dict": ArtifactConfig('*-proguard-dict-*.zip', False, True, True),
-}
-
-def _init_cas_info() -> CasInfo:
-    client_path = _get_client()
-    return CasInfo(
-        _get_env_var('RBE_instance', check=True),
-        _get_env_var('RBE_service', check=True),
-        client_path,
-        _get_client_version(client_path)
-    )
-
-
-def _get_client() -> str:
-    if CAS_UPLOADER_PREBUILT_PATH in os.path.abspath(__file__):
-        return _get_prebuilt_client()
-    bin_path = os.path.join(CAS_UPLOADER_PATH, CAS_UPLOADER_BIN)
-    if os.path.isfile(bin_path):
-        logging.info('Using client at %s', bin_path)
-        return bin_path
-    return _get_prebuilt_client()
-
-
-def _get_prebuilt_client() -> str:
-    client = glob.glob(CAS_UPLOADER_PREBUILT_PATH + '**/' + CAS_UPLOADER_BIN, recursive=True)
-    if not client:
-        raise ValueError('Could not find casuploader binary')
-    logging.info('Using client at %s', client[0])
-    return client[0]
-
-
-def _get_client_version(client_path: str) -> int:
-    """Get the version of CAS client in turple format."""
-    version_output = ''
-    try:
-        version_output = subprocess.check_output([client_path, '-version']).decode('utf-8').strip()
-        matched = re.findall(r'version: (\d+\.\d+)', version_output)
-        if not matched:
-            logging.warning('Failed to parse CAS client version. Output: %s', version_output)
-            return (0, 0)
-        version = tuple(map(int, matched[0].split('.')))
-        logging.info('CAS client version is %s', version)
-        return version
-    # pylint: disable=broad-exception-caught
-    except Exception as e:
-    # pylint: enable=broad-exception-caught
-        logging.warning('Failed to get CAS client version. Output: %s. Error %s', version_output, e)
-        return (0, 0)
 
+def _get_prebuilt_uploader() -> str:
+    uploader = glob.glob(CONTENT_PLOADER_PREBUILT_PATH + '**/' + CONTENT_UPLOADER_BIN,
+                         recursive=True)
+    if not uploader:
+        logging.error('%s not found in Tradefed prebuilt', CONTENT_UPLOADER_BIN)
+        raise ValueError(f'Error: {CONTENT_UPLOADER_BIN} not found in Tradefed prebuilt')
+    return uploader[0]
 
 def _get_env_var(key: str, default=None, check=False):
     value = os.environ.get(key, default)
     if check and not value:
+        logging.error('the environment variable %s is not set', key)
         raise ValueError(f'Error: the environment variable {key} is not set')
     return value
 
-
-def _parse_additional_artifacts(args) -> list[ArtifactConfig]:
-    additional_artifacts = []
-    for config in args.experiment_artifacts:
-        if config not in EXPERIMENT_ARTIFACT_CONFIGS:
-            logging.warning('Ignore invalid experiment_artifacts: %s', config)
-        else:
-            additional_artifacts.append(EXPERIMENT_ARTIFACT_CONFIGS[config])
-            logging.info(
-                'Added experiment artifact from arguments %s',
-                EXPERIMENT_ARTIFACT_CONFIGS[config].source_path,
-            )
-    return additional_artifacts
-
-
-def _upload(
-        cas_info: CasInfo,
-        artifact: ArtifactConfig,
-        working_dir: str,
-        log_file: str,
-) -> str:
-    """Upload the artifact to CAS by casuploader binary.
-
-    Args:
-      cas_info: the basic CAS server information.
-      artifact: the artifact to be uploaded to CAS.
-      working_dir: the directory for intermediate files.
-      log_file: the file where to add the upload logs.
-
-    Returns: the digest of the uploaded artifact, formatted as "<hash>/<size>".
-      returns None if artifact upload fails.
-    """
-    # `-dump-file-details` only supports on cas uploader V1.0 or later.
-    dump_file_details = cas_info.client_version >= (1, 0)
-    if not dump_file_details:
-        logging.warning('-dump-file-details is not enabled')
-
-    with tempfile.NamedTemporaryFile(mode='w+') as digest_file, tempfile.NamedTemporaryFile(
-      mode='w+') as content_details_file:
-        logging.info(
-            'Uploading %s to CAS instance %s', artifact.source_path, cas_info.cas_instance
-        )
-
-        cmd = [
-            cas_info.client_path,
-            '-cas-instance',
-            cas_info.cas_instance,
-            '-cas-addr',
-            cas_info.cas_service,
-            '-dump-digest',
-            digest_file.name,
-            '-use-adc',
-        ]
-
-        cmd = cmd + _path_for_artifact(artifact, working_dir)
-
-        if artifact.chunk:
-            cmd = cmd + ['-chunk', '-avg-chunk-size', str(AVG_CHUNK_SIZE_IN_KB)]
-
-        for exclude_filter in artifact.exclude_filters:
-            cmd = cmd + ['-exclude-filters', exclude_filter]
-
-        if dump_file_details:
-            cmd = cmd + ['-dump-file-details', content_details_file.name]
-
-        try:
-            logging.info('Running command: %s', cmd)
-            with open(log_file, 'a', encoding='utf8') as outfile:
-                subprocess.run(
-                    cmd,
-                    check=True,
-                    text=True,
-                    stdout=outfile,
-                    stderr=subprocess.STDOUT,
-                    encoding='utf-8',
-                    timeout=UPLOADER_TIMEOUT_SECS
-                )
-        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
-            logging.warning(
-                'Failed to upload %s to CAS instance %s. Skip.\nError message: %s\nLog: %s',
-                artifact.source_path, cas_info.cas_instance, e, e.stdout,
-            )
-            return None
-        except subprocess.SubprocessError as e:
-            logging.warning('Failed to upload %s to CAS instance %s. Skip.\n. Error %s',
-                artifact.source_path, cas_info.cas_instance, e)
-            return None
-
-        # Read digest of the root directory or file from dumped digest file.
-        digest = digest_file.read()
-        if digest:
-            logging.info('Uploaded %s to CAS. Digest: %s', artifact.source_path, digest)
-        else:
-            logging.warning(
-                'No digest is dumped for file %s, the uploading may fail.', artifact.source_path)
-            return None
-
-        content_details = None
-        if dump_file_details:
-            try:
-                content_details = json.loads(content_details_file.read())
-            except json.JSONDecodeError as e:
-                logging.warning('Failed to parse uploaded content details: %s', e)
-
-        return UploadResult(digest, content_details)
-
-
-def _path_for_artifact(artifact: ArtifactConfig, working_dir: str) -> [str]:
-    if artifact.unzip:
-        return ['-zip-path', artifact.source_path]
-    if artifact.chunk:
-        return ['-file-path', artifact.source_path]
-    # TODO(b/250643926) This is a workaround to handle non-directory files.
-    tmp_dir = tempfile.mkdtemp(dir=working_dir)
-    target_path = os.path.join(tmp_dir, os.path.basename(artifact.source_path))
-    shutil.copy(artifact.source_path, target_path)
-    return ['-dir-path', tmp_dir]
-
-
-def _output_results(
-        cas_info: CasInfo,
-        output_dir: str,
-        digests: dict[str, str],
-        content_details: list[dict[str, any]],
-):
-    digests_output = {
-        'cas_instance': cas_info.cas_instance,
-        'cas_service': cas_info.cas_service,
-        'client_version': '.'.join(map(str, cas_info.client_version)),
-        'files': digests,
-    }
-    output_path = os.path.join(output_dir, DIGESTS_PATH)
-    with open(output_path, 'w', encoding='utf8') as writer:
-        writer.write(json.dumps(digests_output, sort_keys=True, indent=2))
-    logging.info('Output digests to %s', output_path)
-
-    output_path = os.path.join(output_dir, CONTENT_DETAILS_PATH)
-    with open(output_path, 'w', encoding='utf8') as writer:
-        writer.write(json.dumps(content_details, sort_keys=True, indent=2))
-    logging.info('Output uploaded content details to %s', output_path)
-
-
-def _upload_all_artifacts(cas_info: CasInfo, all_artifacts: ArtifactConfig,
-    dist_dir: str, working_dir: str, log_file:str):
-    file_digests = {}
-    content_details = []
-    skip_files = []
-    _add_fallback_artifacts(all_artifacts)
-    for artifact in all_artifacts:
-        source_path = artifact.source_path
-        for f in glob.glob(dist_dir + '/**/' + source_path, recursive=True):
-            start = time.time()
-            basename = os.path.basename(f)
-            name = _artifact_name(basename, artifact.chunk, artifact.unzip)
-
-            # Avoid redundant upload if multiple ArtifactConfigs share files.
-            if name in file_digests or name in skip_files:
-                continue
-
-            artifact.source_path = f
-            result = _upload(cas_info, artifact, working_dir, log_file)
-
-            if result and result.digest:
-                file_digests[name] = result.digest
-                if artifact.chunk and (not artifact.chunk_fallback or artifact.unzip):
-                    # Skip the regular version even it matches other configs.
-                    skip_files.append(basename)
-            else:
-                logging.warning(
-                    'Skip to save the digest of file %s, the uploading may fail', name
-                )
-            if result and result.content_details:
-                content_details.append({"artifact": name, "details": result.content_details})
-            else:
-                logging.warning('Skip to save the content details of file %s', name)
-
-            logging.info(
-                'Elapsed time of uploading %s: %d seconds\n\n',
-                artifact.source_path,
-                time.time() - start,
-            )
-    _output_results(
-        cas_info,
-        dist_dir,
-        file_digests,
-        content_details,
-    )
-
-
-def _add_fallback_artifacts(artifacts: list[ArtifactConfig]):
-    """Add a fallback artifact if chunking is enabled for an artifact.
-
-    For unzip artifacts, the fallback is the zipped chunked version.
-    For the rest, the fallback is the standard version (not chunked).
-    """
-    for artifact in artifacts:
-        if artifact.chunk and artifact.chunk_fallback:
-            fallback_artifact = copy.copy(artifact)
-            if artifact.unzip:
-                fallback_artifact.unzip = False
-            else:
-                fallback_artifact.chunk = False
-            artifacts.append(fallback_artifact)
-
-
-def _artifact_name(basename: str, chunk: bool, unzip: bool) -> str:
-    if not chunk:
-        return basename
-    if unzip:
-        return CHUNKED_DIR_ARTIFACT_NAME_PREFIX + basename
-    return CHUNKED_ARTIFACT_NAME_PREFIX + basename
-
-
-def main():
-    """Uploads the specified artifacts to CAS."""
-    parser = argparse.ArgumentParser()
-    parser.add_argument(
-        '--experiment_artifacts',
-        required=False,
-        action='append',
-        default=[],
-        help='Name of configuration which artifact to upload',
-    )
-    args = parser.parse_args()
-
+def _setup_logging() -> str:
     dist_dir = _get_env_var('DIST_DIR', check=True)
     log_file = os.path.join(dist_dir, LOG_PATH)
-    print('content_uploader.py will export logs to:', log_file)
     logging.basicConfig(
         level=logging.DEBUG,
         format='%(asctime)s %(levelname)s %(message)s',
         filename=log_file,
     )
-    logging.info('Environment variables of running server: %s', os.environ)
+    return log_file
 
-    additional_artifacts = _parse_additional_artifacts(args)
-    cas_info = _init_cas_info()
+def main():
+    """Call content_uploader and pass all arguments as-is."""
+    log_file = _setup_logging()
 
-    with tempfile.TemporaryDirectory() as working_dir:
-        logging.info('The working dir is %s', working_dir)
-        start = time.time()
-        _upload_all_artifacts(cas_info, ARTIFACTS + additional_artifacts,
-            dist_dir, working_dir, log_file)
-        logging.info('Total time of uploading build artifacts to CAS: %d seconds',
-                     time.time() - start)
+    uploader = _get_prebuilt_uploader()
+    arguments = sys.argv[1:]
 
+    try:
+        result = subprocess.run([uploader] + arguments, capture_output=True, text=True,
+                                check=True, timeout=CONTENT_UPLOADER_TIMEOUT_SECS)
+        print(result.stdout)
+    except FileNotFoundError:
+        print(f'content_uploader.py will export logs to: {log_file}')
+        logging.error('Uploader not found: %s', log_file)
 
 if __name__ == '__main__':
     main()
-
diff --git a/tools/content_uploader/Android.bp b/tools/content_uploader/Android.bp
new file mode 100644
index 000000000..82f1b7dd9
--- /dev/null
+++ b/tools/content_uploader/Android.bp
@@ -0,0 +1,43 @@
+// Copyright 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+python_binary_host {
+    name: "content_uploader",
+    main: "content_uploader_script.py",
+    srcs: [
+        "content_uploader_script.py",
+    ],
+    libs: [
+        "cas_metrics_proto",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
+}
+
+python_library_host {
+    name: "cas_metrics_proto",
+    srcs: [
+        "cas_metrics.proto",
+    ],
+    proto: {
+        canonical_path_from_root: false,
+    },
+}
diff --git a/tools/content_uploader/cas_metrics.proto b/tools/content_uploader/cas_metrics.proto
new file mode 100644
index 000000000..90cea9fa2
--- /dev/null
+++ b/tools/content_uploader/cas_metrics.proto
@@ -0,0 +1,36 @@
+// Copyright 2024 Google Inc. All Rights Reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package cas_metrics_proto;
+
+// Contains metrics pertaining to one artifact.
+message ArtifactMetrics {
+  string digest = 1;            // CAS root digest of the artifact ("hash/size").
+  int64 time_ms = 2;            // End to end time to upload the artifact.
+  int64 unzip_time_ms = 3;      // Time to unzip the artifact if it is a zip file.
+  int64 chunk_time_ms = 4;      // Time to chunk files if chunking is enabled.
+  int64 size_bytes = 5;         // Size of the artifact in bytes.
+  int64 uploaded_size_bytes = 6;// Size of uploaded entries in bytes.
+  int32 entries = 7;            // Number of entries.
+  int32 uploaded_entries = 8;   // Number of uploaded entries.
+}
+
+// Contains metrics for a CAS upload session.
+message CasMetrics {
+  int64 time_ms = 1;            // End to end time for the upload session.
+  repeated ArtifactMetrics artifacts = 2;
+  string client_version = 3;    // CAS uploader client version.
+}
\ No newline at end of file
diff --git a/tools/content_uploader/content_uploader_script.py b/tools/content_uploader/content_uploader_script.py
new file mode 100644
index 000000000..f5aebf475
--- /dev/null
+++ b/tools/content_uploader/content_uploader_script.py
@@ -0,0 +1,500 @@
+#!/usr/bin/env python3
+#
+#  Copyright (C) 2022 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+"""The script to upload generated artifacts from build server to CAS."""
+import argparse
+import copy
+import dataclasses
+import glob
+import json
+import logging
+import os
+import re
+import shutil
+import subprocess
+import tempfile
+import time
+import cas_metrics_pb2  # type: ignore
+from google.protobuf import json_format
+
+
+@dataclasses.dataclass
+class ArtifactConfig:
+    """Configuration of an artifact to be uploaded to CAS.
+
+    Attributes:
+        source_path: path to the artifact that relative to the root of source code.
+        unzip: true if the artifact should be unzipped and uploaded as a directory.
+        chunk: true if the artifact should be uploaded with chunking.
+        chunk_fallback: true if a regular version (no chunking) of the artifact should be uploaded.
+        exclude_filters: a list of regular expressions for files that are excluded from uploading.
+    """
+    source_path: str
+    unzip: bool
+    chunk: bool = False
+    chunk_fallback: bool = False
+    exclude_filters: list[str] = dataclasses.field(default_factory=list)
+
+
+@dataclasses.dataclass
+class CasInfo:
+    """Basic information of CAS server and client.
+
+    Attributes:
+        cas_instance: the instance name of CAS service.
+        cas_service: the address of CAS service.
+        client_path: path to the CAS uploader client.
+        version: version of the CAS uploader client, in turple format.
+    """
+    cas_instance: str
+    cas_service: str
+    client_path: str
+    client_version: tuple
+
+
+@dataclasses.dataclass
+class UploadResult:
+    """Result of uploading a single artifact with CAS client.
+
+    Attributes:
+        digest: root digest of the artifact.
+        content_details: detail information of all uploaded files inside the uploaded artifact.
+    """
+    digest: str
+    content_details: list[dict[str,any]]
+
+
+CAS_UPLOADER_PREBUILT_PATH = 'tools/tradefederation/prebuilts/'
+CAS_UPLOADER_PATH = 'tools/content_addressed_storage/prebuilts/'
+CAS_UPLOADER_BIN = 'casuploader'
+
+UPLOADER_TIMEOUT_SECS = 600 # 10 minutes
+AVG_CHUNK_SIZE_IN_KB = 128
+
+DIGESTS_PATH = 'cas_digests.json'
+LOG_PATH = 'logs/cas_uploader.log'
+CAS_METRICS_PATH = 'logs/cas_metrics.pb'
+METRICS_PATH = 'logs/artifact_metrics.json'
+CONTENT_DETAILS_PATH = 'logs/cas_content_details.json'
+CHUNKED_ARTIFACT_NAME_PREFIX = "_chunked_"
+CHUNKED_DIR_ARTIFACT_NAME_PREFIX = "_chunked_dir_"
+
+# Configurations of artifacts will be uploaded to CAS.
+# TODO(b/298890453) Add artifacts after this script is attached to build process.
+# If configs share files, chunking enabled artifacts should come first.
+ARTIFACTS = [
+    # test_suite targets
+    ArtifactConfig('android-catbox.zip', True),
+    ArtifactConfig('android-csuite.zip', True),
+    ArtifactConfig('android-cts.zip', True, exclude_filters=['android-cts/jdk/.*']),
+    ArtifactConfig('android-gcatbox.zip', True),
+    ArtifactConfig('android-gts.zip', True, exclude_filters=['android-gts/jdk/.*']),
+    ArtifactConfig('android-mcts.zip', True),
+    ArtifactConfig('android-mts.zip', True, exclude_filters=['android-mts/jdk/.*']),
+    ArtifactConfig('android-pts.zip', True, exclude_filters=['android-pts/jdk/.*']),
+    ArtifactConfig('android-sts.zip', True),
+    ArtifactConfig('android-vts.zip', True),
+    ArtifactConfig('android-wts.zip', True, exclude_filters=['android-wts/jdk/.*']),
+    ArtifactConfig('art-host-tests.zip', True),
+    ArtifactConfig('bazel-test-suite.zip', True),
+    ArtifactConfig('host-unit-tests.zip', True),
+    ArtifactConfig('general-tests.zip', True),
+    ArtifactConfig('general-tests_configs.zip', True),
+    ArtifactConfig('general-tests_host-shared-libs.zip', True),
+    ArtifactConfig('tradefed.zip', True),
+    ArtifactConfig('google-tradefed.zip', True),
+    ArtifactConfig('robolectric-tests.zip', True),
+    ArtifactConfig('ravenwood-tests.zip', True),
+    ArtifactConfig('test_mappings.zip', True),
+
+    # Mainline artifacts
+    ArtifactConfig('*.apex', False),
+    ArtifactConfig('*.apk', False),
+
+    # Device target artifacts
+    ArtifactConfig('androidTest.zip', True),
+    ArtifactConfig('device-tests.zip', True),
+    ArtifactConfig('device-tests_configs.zip', True),
+    ArtifactConfig('device-tests_host-shared-libs.zip', True),
+    ArtifactConfig('performance-tests.zip', True),
+    ArtifactConfig('device-platinum-tests.zip', True),
+    ArtifactConfig('device-platinum-tests_configs.zip', True),
+    ArtifactConfig('device-platinum-tests_host-shared-libs.zip', True),
+    ArtifactConfig('camera-hal-tests.zip', True),
+    ArtifactConfig('camera-hal-tests_configs.zip', True),
+    ArtifactConfig('camera-hal-tests_host-shared-libs.zip', True),
+    ArtifactConfig('device-pixel-tests.zip', True),
+    ArtifactConfig('device-pixel-tests_configs.zip', True),
+    ArtifactConfig('device-pixel-tests_host-shared-libs.zip', True),
+    ArtifactConfig('*-tests-*zip', True),
+    ArtifactConfig('*-continuous_instrumentation_tests-*zip', True),
+    ArtifactConfig('*-continuous_instrumentation_metric_tests-*zip', True),
+    ArtifactConfig('*-continuous_native_tests-*zip', True),
+    ArtifactConfig('cvd-host_package.tar.gz', False),
+    ArtifactConfig('bootloader.img', False),
+    ArtifactConfig('radio.img', False),
+    ArtifactConfig('*-target_files-*.zip', True),
+    ArtifactConfig('*-img-*zip', True, True, True)
+]
+
+# Artifacts will be uploaded if the config name is set in arguments `--experiment_artifacts`.
+# These configs are usually used to upload artifacts in partial branches/targets for experiment
+# purpose.
+# A sample entry:
+#   "device_image_target_files": ArtifactConfig('*-target_files-*.zip', True)
+EXPERIMENT_ARTIFACT_CONFIGS = {
+    "device_image_proguard_dict": ArtifactConfig('*-proguard-dict-*.zip', False, True, True),
+}
+
+def _init_cas_info() -> CasInfo:
+    client_path = _get_client()
+    return CasInfo(
+        _get_env_var('RBE_instance', check=True),
+        _get_env_var('RBE_service', check=True),
+        client_path,
+        _get_client_version(client_path)
+    )
+
+
+def _get_client() -> str:
+    if CAS_UPLOADER_PREBUILT_PATH in os.path.abspath(__file__):
+        return _get_prebuilt_client()
+    bin_path = os.path.join(CAS_UPLOADER_PATH, CAS_UPLOADER_BIN)
+    if os.path.isfile(bin_path):
+        logging.info('Using client at %s', bin_path)
+        return bin_path
+    return _get_prebuilt_client()
+
+
+def _get_prebuilt_client() -> str:
+    client = glob.glob(CAS_UPLOADER_PREBUILT_PATH + '**/' + CAS_UPLOADER_BIN, recursive=True)
+    if not client:
+        raise ValueError('Could not find casuploader binary')
+    logging.info('Using client at %s', client[0])
+    return client[0]
+
+
+def _get_client_version(client_path: str) -> int:
+    """Get the version of CAS client in turple format."""
+    version_output = ''
+    try:
+        version_output = subprocess.check_output([client_path, '-version']).decode('utf-8').strip()
+        matched = re.findall(r'version: (\d+\.\d+)', version_output)
+        if not matched:
+            logging.warning('Failed to parse CAS client version. Output: %s', version_output)
+            return (0, 0)
+        version = tuple(map(int, matched[0].split('.')))
+        logging.info('CAS client version is %s', version)
+        return version
+    # pylint: disable=broad-exception-caught
+    except Exception as e:
+    # pylint: enable=broad-exception-caught
+        logging.warning('Failed to get CAS client version. Output: %s. Error %s', version_output, e)
+        return (0, 0)
+
+
+def _get_env_var(key: str, default=None, check=False):
+    value = os.environ.get(key, default)
+    if check and not value:
+        raise ValueError(f'Error: the environment variable {key} is not set')
+    return value
+
+
+def _parse_additional_artifacts(args) -> list[ArtifactConfig]:
+    additional_artifacts = []
+    for config in args.experiment_artifacts:
+        if config not in EXPERIMENT_ARTIFACT_CONFIGS:
+            logging.warning('Ignore invalid experiment_artifacts: %s', config)
+        else:
+            additional_artifacts.append(EXPERIMENT_ARTIFACT_CONFIGS[config])
+            logging.info(
+                'Added experiment artifact from arguments %s',
+                EXPERIMENT_ARTIFACT_CONFIGS[config].source_path,
+            )
+    return additional_artifacts
+
+
+def _upload(
+        cas_info: CasInfo,
+        artifact: ArtifactConfig,
+        working_dir: str,
+        log_file: str,
+        metrics_file: str,
+) -> str:
+    """Upload the artifact to CAS by casuploader binary.
+
+    Args:
+      cas_info: the basic CAS server information.
+      artifact: the artifact to be uploaded to CAS.
+      working_dir: the directory for intermediate files.
+      log_file: the file where to add the upload logs.
+      metrics_file: the metrics_file for the artifact.
+
+    Returns: the digest of the uploaded artifact, formatted as "<hash>/<size>".
+      returns None if artifact upload fails.
+    """
+    # `-dump-file-details` only supports on cas uploader V1.0 or later.
+    dump_file_details = cas_info.client_version >= (1, 0)
+    if not dump_file_details:
+        logging.warning('-dump-file-details is not enabled')
+
+    # `-dump-metrics` only supports on cas uploader V1.3 or later.
+    dump_metrics = cas_info.client_version >= (1, 3)
+    if not dump_metrics:
+        logging.warning('-dump-metrics is not enabled')
+
+    with tempfile.NamedTemporaryFile(mode='w+') as digest_file, tempfile.NamedTemporaryFile(
+      mode='w+') as content_details_file:
+        logging.info(
+            'Uploading %s to CAS instance %s', artifact.source_path, cas_info.cas_instance
+        )
+
+        cmd = [
+            cas_info.client_path,
+            '-cas-instance',
+            cas_info.cas_instance,
+            '-cas-addr',
+            cas_info.cas_service,
+            '-dump-digest',
+            digest_file.name,
+            '-use-adc',
+        ]
+
+        cmd = cmd + _path_for_artifact(artifact, working_dir)
+
+        if artifact.chunk:
+            cmd = cmd + ['-chunk', '-avg-chunk-size', str(AVG_CHUNK_SIZE_IN_KB)]
+
+        for exclude_filter in artifact.exclude_filters:
+            cmd = cmd + ['-exclude-filters', exclude_filter]
+
+        if dump_file_details:
+            cmd = cmd + ['-dump-file-details', content_details_file.name]
+
+        if dump_metrics:
+            cmd = cmd + ['-dump-metrics', metrics_file]
+
+        try:
+            logging.info('Running command: %s', cmd)
+            with open(log_file, 'a', encoding='utf8') as outfile:
+                subprocess.run(
+                    cmd,
+                    check=True,
+                    text=True,
+                    stdout=outfile,
+                    stderr=subprocess.STDOUT,
+                    encoding='utf-8',
+                    timeout=UPLOADER_TIMEOUT_SECS
+                )
+        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
+            logging.warning(
+                'Failed to upload %s to CAS instance %s. Skip.\nError message: %s\nLog: %s',
+                artifact.source_path, cas_info.cas_instance, e, e.stdout,
+            )
+            return None
+        except subprocess.SubprocessError as e:
+            logging.warning('Failed to upload %s to CAS instance %s. Skip.\n. Error %s',
+                artifact.source_path, cas_info.cas_instance, e)
+            return None
+
+        # Read digest of the root directory or file from dumped digest file.
+        digest = digest_file.read()
+        if digest:
+            logging.info('Uploaded %s to CAS. Digest: %s', artifact.source_path, digest)
+        else:
+            logging.warning(
+                'No digest is dumped for file %s, the uploading may fail.', artifact.source_path)
+            return None
+
+        content_details = None
+        if dump_file_details:
+            try:
+                content_details = json.loads(content_details_file.read())
+            except json.JSONDecodeError as e:
+                logging.warning('Failed to parse uploaded content details: %s', e)
+
+        return UploadResult(digest, content_details)
+
+
+def _path_for_artifact(artifact: ArtifactConfig, working_dir: str) -> [str]:
+    if artifact.unzip:
+        return ['-zip-path', artifact.source_path]
+    if artifact.chunk:
+        return ['-file-path', artifact.source_path]
+    # TODO(b/250643926) This is a workaround to handle non-directory files.
+    tmp_dir = tempfile.mkdtemp(dir=working_dir)
+    target_path = os.path.join(tmp_dir, os.path.basename(artifact.source_path))
+    shutil.copy(artifact.source_path, target_path)
+    return ['-dir-path', tmp_dir]
+
+
+def _output_results(
+        cas_info: CasInfo,
+        output_dir: str,
+        digests: dict[str, str],
+        content_details: list[dict[str, any]],
+):
+    digests_output = {
+        'cas_instance': cas_info.cas_instance,
+        'cas_service': cas_info.cas_service,
+        'client_version': '.'.join(map(str, cas_info.client_version)),
+        'files': digests,
+    }
+    output_path = os.path.join(output_dir, DIGESTS_PATH)
+    with open(output_path, 'w', encoding='utf8') as writer:
+        writer.write(json.dumps(digests_output, sort_keys=True, indent=2))
+    logging.info('Output digests to %s', output_path)
+
+    output_path = os.path.join(output_dir, CONTENT_DETAILS_PATH)
+    with open(output_path, 'w', encoding='utf8') as writer:
+        writer.write(json.dumps(content_details, sort_keys=True, indent=2))
+    logging.info('Output uploaded content details to %s', output_path)
+
+
+def _upload_all_artifacts(cas_info: CasInfo, all_artifacts: ArtifactConfig,
+    dist_dir: str, working_dir: str, log_file:str, cas_metrics: cas_metrics_pb2.CasMetrics):
+    file_digests = {}
+    content_details = []
+    skip_files = []
+    _add_fallback_artifacts(all_artifacts)
+    for artifact in all_artifacts:
+        for f in glob.glob(dist_dir + '/**/' + artifact.source_path, recursive=True):
+            start = time.time()
+            name = _artifact_name(os.path.basename(f), artifact.chunk, artifact.unzip)
+
+            # Avoid redundant upload if multiple ArtifactConfigs share files.
+            if name in file_digests or name in skip_files:
+                continue
+
+            artifact.source_path = f
+            metrics_file = os.path.join(dist_dir, METRICS_PATH)
+            result = _upload(cas_info, artifact, working_dir, log_file, metrics_file)
+
+            if result and result.digest:
+                file_digests[name] = result.digest
+                if artifact.chunk and (not artifact.chunk_fallback or artifact.unzip):
+                    # Skip the regular version even it matches other configs.
+                    skip_files.append(os.path.basename(f))
+            else:
+                logging.warning(
+                    'Skip to save the digest of file %s, the uploading may fail', name
+                )
+            if result and result.content_details:
+                content_details.append({"artifact": name, "details": result.content_details})
+            else:
+                logging.warning('Skip to save the content details of file %s', name)
+
+            if os.path.exists(metrics_file):
+                _add_artifact_metrics(metrics_file, cas_metrics)
+                os.remove(metrics_file)
+
+            logging.info(
+                'Elapsed time of uploading %s: %d seconds\n\n',
+                artifact.source_path,
+                time.time() - start,
+            )
+    _output_results(
+        cas_info,
+        dist_dir,
+        file_digests,
+        content_details,
+    )
+
+
+def _add_artifact_metrics(metrics_file: str, cas_metrics: cas_metrics_pb2.CasMetrics):
+    try:
+        with open(metrics_file, "r", encoding='utf8') as file:
+            json_metrics = json.load(file)
+            cas_metrics.artifacts.append(
+                json_format.ParseDict(json_metrics, cas_metrics_pb2.ArtifactMetrics())
+            )
+
+    except FileNotFoundError:
+        logging.exception("File not found: %s", metrics_file)
+    except json_format.ParseError as e:  # Catch any other unexpected errors
+        logging.exception("Error converting Json to protobuf: %s", e)
+
+
+def _add_fallback_artifacts(artifacts: list[ArtifactConfig]):
+    """Add a fallback artifact if chunking is enabled for an artifact.
+
+    For unzip artifacts, the fallback is the zipped chunked version.
+    For the rest, the fallback is the standard version (not chunked).
+    """
+    for artifact in artifacts:
+        if artifact.chunk and artifact.chunk_fallback:
+            fallback_artifact = copy.copy(artifact)
+            if artifact.unzip:
+                fallback_artifact.unzip = False
+            else:
+                fallback_artifact.chunk = False
+            artifacts.append(fallback_artifact)
+
+
+def _artifact_name(basename: str, chunk: bool, unzip: bool) -> str:
+    if not chunk:
+        return basename
+    if unzip:
+        return CHUNKED_DIR_ARTIFACT_NAME_PREFIX + basename
+    return CHUNKED_ARTIFACT_NAME_PREFIX + basename
+
+
+def main():
+    """Uploads the specified artifacts to CAS."""
+    parser = argparse.ArgumentParser()
+    parser.add_argument(
+        '--experiment_artifacts',
+        required=False,
+        action='append',
+        default=[],
+        help='Name of configuration which artifact to upload',
+    )
+    args = parser.parse_args()
+
+    dist_dir = _get_env_var('DIST_DIR', check=True)
+    log_file = os.path.join(dist_dir, LOG_PATH)
+    print('content_uploader.py will export logs to:', log_file)
+    logging.basicConfig(
+        level=logging.DEBUG,
+        format='%(asctime)s %(levelname)s %(message)s',
+        filename=log_file,
+    )
+    logging.info('Environment variables of running server: %s', os.environ)
+
+    additional_artifacts = _parse_additional_artifacts(args)
+    cas_info = _init_cas_info()
+
+    with tempfile.TemporaryDirectory() as working_dir:
+        logging.info('The working dir is %s', working_dir)
+        start = time.time()
+        cas_metrics = cas_metrics_pb2.CasMetrics()
+        _upload_all_artifacts(cas_info, ARTIFACTS + additional_artifacts,
+            dist_dir, working_dir, log_file, cas_metrics)
+        elapsed = time.time() - start
+        logging.info('Total time of uploading build artifacts to CAS: %d seconds',
+                     elapsed)
+        cas_metrics.time_ms = int(elapsed * 1000)
+        cas_metrics.client_version = '.'.join([str(num) for num in cas_info.client_version])
+        serialized_metrics = cas_metrics.SerializeToString()
+        if serialized_metrics:
+            cas_metrics_file = os.path.join(dist_dir, CAS_METRICS_PATH)
+            with open(cas_metrics_file, "wb") as file:
+                file.write(serialized_metrics)
+            logging.info('Output cas metrics to: %s', cas_metrics_file)
+
+
+if __name__ == '__main__':
+    main()
diff --git a/util_apps/ContentProvider/main/java/android/tradefed/contentprovider/AndroidManifest.xml b/util_apps/ContentProvider/main/java/android/tradefed/contentprovider/AndroidManifest.xml
index 3f869f803..a742ee5b8 100644
--- a/util_apps/ContentProvider/main/java/android/tradefed/contentprovider/AndroidManifest.xml
+++ b/util_apps/ContentProvider/main/java/android/tradefed/contentprovider/AndroidManifest.xml
@@ -20,6 +20,8 @@
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
+    <!-- We need this permission see b/339295745 for context -->
+    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" />
 
     <uses-sdk android:minSdkVersion="24"
               android:targetSdkVersion="26" />
```

