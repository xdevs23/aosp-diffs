```diff
diff --git a/.idea/kotlinc.xml b/.idea/kotlinc.xml
index 93489dd78..bb2d78993 100644
--- a/.idea/kotlinc.xml
+++ b/.idea/kotlinc.xml
@@ -4,6 +4,6 @@
     <option name="sourceMapEmbedSources" />
   </component>
   <component name="KotlinJpsPluginSettings">
-    <option name="version" value="2.0.0" />
+    <option name="version" value="2.0.20" />
   </component>
 </project>
\ No newline at end of file
diff --git a/OWNERS b/OWNERS
index dbd010fe8..255f2bbdd 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,14 +1,14 @@
+# Bug component: 463936
+
 # AndroidX
 tnorbye@google.com
-jeffrygaston@google.com
 asfalcone@google.com
 alanv@google.com
 aurimas@google.com
-emberrose@google.com
 juliamcclellan@google.com
+
 # Android
 amhk@google.com
-gurpreetgs@google.com
-hansson@google.com
+michaelwr@google.com
 paulduffin@google.com
 jham@google.com #{LAST_RESORT_SUGGESTION}
diff --git a/README.md b/README.md
index d7c0e2d4d..eb62c255a 100644
--- a/README.md
+++ b/README.md
@@ -393,8 +393,7 @@ signature or stub data:
     class SignatureWriter(
             private val writer: PrintWriter,
             private val generateDefaultConstructors: Boolean,
-            private val filter: (Item) -> Boolean) : ApiVisitor(
-            visitConstructorsAsMethods = false) {
+            private val filter: (Item) -> Boolean) : ApiVisitor() {
 
     ....
 
diff --git a/USAGE.md b/USAGE.md
index f2fb9fa46..bb4fbd7ba 100644
--- a/USAGE.md
+++ b/USAGE.md
@@ -22,7 +22,7 @@ platform and AndroidX libraries.
 - Rewriting of nullness annotations to @RecentlyNull/NonNull (`--migrate-nullness`,
 `--force-convert-to-warning-nullability-annotations`) for SDK
 - Tracking @removed APIs (`--removed-api`)
-- DEX API signature generation (`--dex-api`) for for hidden API enforcement
+- DEX API signature generation (`signature-to-dex`) for for hidden API enforcement
 - XML API signature generation (`--api-xml`) for CTS tests and test coverage infrastructure
 - Annotation include, exclude, rewrite, passthrough in stubs (`--include-annotations`, `--exclude-all-annotations`,
 `--pass-through-annotation`, `--exclude-annotation`)
diff --git a/androidx-studio-integration.sh b/androidx-studio-integration.sh
index e6618c15e..55b272447 100755
--- a/androidx-studio-integration.sh
+++ b/androidx-studio-integration.sh
@@ -14,7 +14,7 @@ mkdir -p "$DIST_DIR"
 export OUT_DIR=out
 export DIST_DIR="$DIST_DIR"
 
-JAVA_HOME="$(pwd)/prebuilts/studio/jdk/jdk17/linux" tools/gradlew -p tools/ publishLocal --stacktrace
+JAVA_HOME="$(pwd)/prebuilts/studio/jdk/jbr-next/linux" tools/gradlew -p tools/ publishLocal --stacktrace
 
 # Depend on the generated version.properties file, as the version depends on
 # the release flag
@@ -23,7 +23,7 @@ versionProperties="$OUT_DIR/build/base/builder-model/build/resources/main/com/an
 export LINT_VERSION=`perl -nle'print $& while m{(?<=baseVersion=).*}g' $versionProperties`
 export LINT_REPO="$(pwd)/out/repo"
 
-JAVA_HOME="$(pwd)/prebuilts/jdk/jdk17/linux-x86/" tools/gradlew -p tools/metalava \
+JAVA_HOME="$(pwd)/prebuilts/jdk/jdk21/linux-x86/" tools/gradlew -p tools/metalava \
   --no-daemon \
   --stacktrace \
    --dependency-verification=off
diff --git a/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt b/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt
index caaa7025c..088120362 100644
--- a/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt
+++ b/buildSrc/src/main/kotlin/com/android/tools/metalava/buildinfo/LibraryBuildInfo.kt
@@ -48,6 +48,7 @@ abstract class CreateLibraryBuildInfoTask : DefaultTask() {
     @get:Input abstract val projectZipPath: Property<String>
     @get:Input abstract val projectDirectoryRelativeToRootProject: Property<String>
     @get:Input abstract val dependencyList: ListProperty<LibraryBuildInfoFile.Dependency>
+    @get:Input abstract val target: Property<String>
 
     @get:OutputFile abstract val outputFile: Property<File>
 
@@ -62,6 +63,7 @@ abstract class CreateLibraryBuildInfoTask : DefaultTask() {
         info.sha = sha.get()
         info.projectZipPath = projectZipPath.get()
         info.dependencies = dependencyList.get()
+        info.target = target.get()
         info.checks = arrayListOf()
         val gson = GsonBuilder().setPrettyPrinting().create()
         val serializedInfo: String = gson.toJson(info)
@@ -107,6 +109,8 @@ internal fun configureBuildInfoTask(
                 )
             }
         )
+        // This should always be "metalava" unless the target changes
+        it.target.set("metalava")
     }
 }
 
@@ -138,6 +142,7 @@ fun List<Dependency>.asBuildInfoDependencies() =
  *   the same version
  * @property dependencies a list of dependencies on other androidx libraries
  * @property checks arraylist of [Check]s that is used by Jetpad
+ * @property target the target for metalava, used by Jetpad
  */
 class LibraryBuildInfoFile {
     var groupId: String? = null
@@ -149,6 +154,7 @@ class LibraryBuildInfoFile {
     var groupIdRequiresSameVersion: Boolean? = null
     var dependencies: List<Dependency> = arrayListOf()
     var checks: ArrayList<Check> = arrayListOf()
+    var target: String? = null
 
     /** @property isTipOfTree boolean that specifies whether the dependency is tip-of-tree */
     class Dependency : Serializable {
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 18c3f6d59..f8e1e0cbc 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,9 +1,9 @@
 [versions]
-kotlin = "2.0.0"
-androidLint = "31.5.0-alpha05"
+kotlin = "2.0.20"
+androidLint = "31.7.0-alpha09"
 
 [libraries]
-androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.5.0-alpha05" }
+androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.7.0-alpha09" }
 androidLint = { module = "com.android.tools.lint:lint", version.ref = "androidLint" }
 androidLintApi = { module = "com.android.tools.lint:lint-api", version.ref = "androidLint" }
 androidLintChecks = { module = "com.android.tools.lint:lint-checks", version.ref = "androidLint" }
@@ -21,7 +21,7 @@ clikt = { module = "com.github.ajalt.clikt:clikt-jvm", version = "3.5.3" }
 gson = { module = "com.google.code.gson:gson", version = "2.8.9" }
 junit4 = { module = "junit:junit", version = "4.13.2" }
 kotlinGradlePlugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
-kotlinStdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib-jdk8", version.ref = "kotlin" }
+kotlinStdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "kotlin" }
 kotlinTest = { module = "org.jetbrains.kotlin:kotlin-test", version.ref = "kotlin" }
 truth = { module = "com.google.truth:truth", version = "1.1.3" }
 turbine = {module = "com.google.turbine:turbine", version = "0.2.1"}
diff --git a/gradle/verification-keyring.keys b/gradle/verification-keyring.keys
index 251608623..52dd92f49 100644
--- a/gradle/verification-keyring.keys
+++ b/gradle/verification-keyring.keys
@@ -4006,6 +4006,330 @@ BzoVWrw=
 =fJQM
 -----END PGP PUBLIC KEY BLOCK-----
 
+pub    7721F63BD38B4796
+sub    4EB27DB2A3B88B8B
+sub    1397BC53640DB551
+sub    78BD65473CB3BD13
+sub    6494C6D6997C215E
+sub    32EE5355A6BC6E42
+sub    E88979FB9B30ACF2
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+Version: BCPG v1.68
+
+mQINBFcMjNMBEAC6Wr5QuLIFgz1V1EFPlg8ty2TsjQEl4VWftUAqWlMevJFWvYEx
+BOsOZ6kNFfBfjAxgJNWTkxZrHzDl74R7KW/nUx6X57bpFjUyRaB8F3/NpWKSeIGS
+pJT+0m2SgUNhLAn1WY/iNJGNaMl7lgUnaP+/ZsSNT9hyTBiH3Ev5VvAtMGhVI/u8
+P0EtTjXp4o2U+VqFTBGmZ6PJVhCFjZUeRByloHw8dGOshfXKgriebpioHvU8iQ2U
+GV3WNIirB2Rq1wkKxXJ/9Iw+4l5m4GmXMs7n3XaYQoBj28H86YA1cYWSm5LR5iU2
+TneI1fJ3vwF2vpSXVBUUDk67PZhg6ZwGRT7GFWskC0z8PsWd5jwK20mA8EVKq0vN
+BFmMK6i4fJU+ux17Rgvnc9tDSCzFZ1/4f43EZ41uTmmNXIDsaPCqwjvSS5ICadt2
+xeqTWDlzONUpOs5yBjF1cfJSdVxsfshvln2JXUwgIdKl4DLbZybuNFXnPffNLb2v
+PtRJHO48O2UbeXS8n27PcuMoLRd7+r7TsqG2vBH4t/cB/1vsvWMbqnQlaJ5VsjeW
+Tp8Gv9FJiKuU8PKiWsF4EGR/kAFyCB8QbJeQ6HrOT0CXLOaYHRu2TvJ4taY9doXn
+98TgU03XTLcYoSp49cdkkis4K+9hd2dUqARVCG7UVd9PY60VVCKi47BVKQARAQAB
+uQINBGF4DJ8BEACk2Gwau+s/pKmOTnGLMnB3ybQsiVGLRhsw2SqSTvSyBthAyW1U
+AqdRqNA8/FdMlvVuppG8+vCLXPmpP63C+9M2tyQeOR2aVQp+u1EIwN4lPu4wrh6v
+dtgSRim8uxBdLIHG16z0xxVhE2rM/Ot/gucfkpoEw289VaR7sPmIxfVTm1QcqCGi
+FQl3rZnma6Bz8UOXJoE8wO+LK5WkcdmFz6+Z3BLSb5IL9lhsArFToNq5dN2SSTbC
+TdHRzrRuoCdefYHdxoLCM4kJfggRRgWhKoEJro+ZipESq1T5yHV/iAJy+3DuC8Lb
+YLvsjt9VZYARw8xIGb90Vj3ThWuMoVr/IVmKT7foC5Whe0PTI/b2frNaWCxxC4cR
+VxMusiBX66mclQ4Mvzwj50G1WKygULYcvPQ81Tg0pvgTKqgxwL9luN9MiDVtkn9C
+Zx7NFlszVr+ic7nVJjANnJebFHCEZfJbQo4uIwKfYbhopUkCa41iXpesbVzAKqNw
+ePgyNTAMFyYnjAUE8FVUmx7ZJVb15iEbMs38gJKJ/Wb8wtJRflAfkhrEzh1M/43W
+UAU3RfPmXTrGeyDCYKTHiXTnj748uH6U40sB9q+qeEhZdTj0KufjgtWaFWsZTkVr
+tGOaI6xfX6py/k3hjU3es+7ddElxhPBcqNE3pkPRqb9wz+exSdM7hiUzNwARAQAB
+iQRbBBgBCAAPBQJheAyfAhsCBQkFo5qAAkAJEHch9jvTi0eWwV0gBBkBCAAGBQJh
+eAyfAAoJEE6yfbKjuIuLggkP/1INRyRToLmY1ms9DTWMQ0lwbBL8J3xu/neKIOKV
+GOdw9zcWlGugUoOthSbT8bjvuybH1Vjx4wFM+cnuMVfjD58Xu6ZpgCHN1wXYMuzY
+weBFKaMg4oSwTKuAJBJ2IhfEm/cAryVvKY2zY+uyzgizx3vAg3sjkAPDcrSCJP2n
+kuHcJ3nzUbKNAjmdMsnWDrqqZVwP99nuyMk8bAtueZ0SKvIpCv2wIeYO7zkj61vu
+QOFOGhl98OBui5wUhtgQw//esTWYiGNKSmD3derd2JHVA01tBmCWV4KMLDbg3CcM
+MQ1x3V1me6EG3giwBL1I9xTsBUbEa6eEN9U0zdKvoMbSogON5wCuxAzO/CXGMreJ
+tBUupHEc69oTuwe426Ihi3AbRrPAg3tnGGFCt11HoQFNnRPWb3unF8UlA2rSytvw
+FyQi3pzBYt5VsTIA7NEHGuJs+/Oor6AOInzht1cp7AfmDGfGy2N5ow+4GI6FPe2U
+qIg2+nFiGr9hRZOvXRgLQL8dlDnFChymldxm/J/UFdJGSWRldEDsPrzHQESKvsV9
+EjnJQR5p5zkQK6jx0zqSlDgiNG2GT3/CSvwIdCih6Cl9HThHtYNm3ZYN0bU9W2je
+oLh3AINNTcrp0tAHZuQLFxukbj56O5eB+nfk67/X2iNii46ZdJQNwbT9YN6CstQz
++CnqFiEE60wb/U8EL23dzOyRdyH2O9OLR5aDtg//cbpjo0chCCBeeVgiLeLA3vaE
+SASrPq8hErzuUEZbavd5DRwNm4Tf7lDgVhyLD4HZEp4OGN2Y8fKkDmj5GIDIjsk5
+nAlqWoc7efAkbmyvStHNwmxsa+lvOyjYm5PJNRG/i0E2rjlv3LRB3O3k+k2s8ltA
+AMlaf4daxtUkHmBYFN2hBiCnJOvzidDKxxYBQVNFuYe+2MIJ8t29TzAzu5sBDkPC
+LWkAFG21EAy48D3gfNoEXnJeSCHEemdbQhxcaLCByH0tDJo71VJGGI8fqvlm6Tsq
+8aEemHtILkmBSf28maanXNx3SZdDZmHwzzUndGLeIY8czYKqmUDFc1siufO1sQmE
+3Yj7vubvdnh34rWK+DrFCG15JmHCHHv9ndOX5TaNg4QUif9QWZXdTFFIlr+NBFyO
+8wqmtKni0BnbIkjdtpuNFuLGBQS2UrXTn8l6nFwB3D2+izE7+tHtWoLO7Ryil3EL
+QYAfyiD4D3/cs+GVEbLdCF/OPL0kdYePgQiyiXTYFLz51a8Chh6uS970736Hr8Hn
+Az9ieD0GNP46s2+R+aorZyykFfBh506sLi5ZxSa54RWu/k/gUXfrAn56O89Lq91P
+FVN0teOi5QfBNBBlWU2NZjdwjKPTednX1z5vfT7YXMb+5Kdv949axEtjsjLPjKCv
+x63B4E+cQi+PCkBnE665Ag0EVwyNyAEQAKsv2AeF2vqBBfhkwDmyWnrbzE6scKx0
+s7nhY109Ep4UdcmpJImLd+zwXEFYjgWd6N4pQZsX4ys6UWkqoQvFoyN7tvBnJqne
+LPO1kezM/diY6hMEm9EQYp0KQvzZwuwKFgP8+uATxyu+SFKer169ywoCfOIzGD/A
+MIKFQvcS+qjb0F6gHzV/4T3CStRMwJP+RXG3ekZFqUpfRSGu0qumbzJF+O58l/CO
+R3CC+KeREZnYatYePgvMxuL3+51holnrpjDSERThRLFQH2822ZIWtvgQH3VPauFz
+rx2BDiNgEjsrgRtvxdpYDFv4gCrfWXVSSIQDfYXipQygvqsKEHjLqcfE6dO+z5cR
+vlMHBdWiCMtEpNCzlT8dX2XuP4cByGTnLeKbY3ZQqYzEeqi289llRk91oJHFR51B
+/2BHTItlX5T0FwO7CPMv/OOu2E1liUQYnodn9MtJOnh0Mf65e4uoxVbLmKq4q2du
+uc1NC2/m3AP4COmDLrRgs4n1hqIngaOJ86nNKTzd7Wsnen+lfoHk1ZCKdUtknPHJ
+46iHeIyN2YINKcRcusKZi/mDqPJX9Zt3gZgW4wrxNPv49B1Ytxtn8vFznDSz5zv5
+/k5+Ypc7ko8eedSysXkMFopE+NJynB49CK3F4iCVSAQwOQ2u4GG7U/MLF3cG1eC7
+74rdZ2gfdVyDABEBAAGJBFsEGAECAA8FAlcMjcgCGwIFCQWjmoACQAkQdyH2O9OL
+R5bBXSAEGQECAAYFAlcMjcgACgkQE5e8U2QNtVFBJg//QTCvdPt7SyhPPyDhAkst
+WpkNl1fwh7PTiJ00e68C7QDB1nbCXQL60yQPuXhHZojoEp7/3A+d2T80l75lhwP+
+7PKIoglAPjw+uJ82fC8e70DzSsTgGmlCemUQ16GJttZoY0lA40YUnHtBNiUWNLks
+2UbUBfqZCPG9vjbfM5ZI6YRqZhdgGZjIwbq+Sv9dM/OyV2TLxcW4+slRmyUv9aXH
+fVdDUiu2Qcc5ipbCvSFNznT/Y7wfR7CX90FkurcSaKdln62xO6Ch/SPhJvFiGmXD
+32cbBs3W5fLgvz91Y5Redjk6BpMpk8XXnNEzFc30V7KUFVimnmTOt7+tEjqZDaVp
+9gd1uO93uvIcXkm9hOhINd3SbMXacvObqPCw7zjtk13kZ1MPr+9x5/Ugm1rWdLAD
++GEu2C2XPr+02dyneUR0KMAzHb2Ng8Nf4uqz0kDFwke5+vzajrAz1MXbhDytrw1u
+8Hreh1WJ0J+Ieg6wgUNStrMfxe5pDPJmQjRtvMuaAwC8w7q7XM9979Mrot0mDsB4
+ApJw4lLfwPmabBoPVsAGvrt5sD9fkd1qiZIMpV1Rhp7B9MYEiytaYKYql1v5Z9fi
+h0Wk3Ndb+qySIGnlZJ6wq83VBSQslkNkPWTPb75e6XkH3uzkvEtMtHC+Aug1pQWv
+eWd6PM0uB0Gl/oWeQDn2zJEWIQTrTBv9TwQvbd3M7JF3IfY704tHllLiD/44gGdr
+ic11Sj3kSajBi/lHth4lRHvIpmt0kCHHqlvIyku3OzYnOnTFsYJw6ZObSZlY64H3
+NGvXNRWOBqJlAW2RY/o+9/lkZNxGlSiLLcvsc+PPq5SY3WBVQiaNCaeu4441zreh
+Dh054jgPwDbc0SMwzJ1q8CWewMQhieGIy0oZHETPUt9F9IrgJMTSC1/vkjTnfGqn
+NmxaH8kwpHG5OgiHNVtNL3379UBkzY7LTaVUpffm0ZpSQ6iVpwxpOTZeDXKnfF+d
+VdLWBIOlhCuDjPN8MeRMP03U0auYyZGwrthmDWjTTYF1u210r0+VSDW7j+nZm4tf
+/LNIyiUDhASN0ccaAftNQ4MfWHTX47AjN4b0L8pGljAC3mSKc218VddfGPUEFCEX
+ti/uF2QAhAIVo49itcD+zgxk0K6zOKuLCMNZd5e8jvWl1ze5YpAAHXU+FhKRldAo
+qK0Xjidcv7CiUSUiP56TdVCu8DGs2fss4cTdKsxvLKkRCiUJzbrhkEP6iBm/6HuH
+TztBYoQFBpFqGtG4LRlYozeX0EmzG1edJGWKmmvRpzUEZ3IZmW/qStsS3CvOYQ9Z
+6d+/wJuaNoIKDjY96iNyWkR7GWjrNaj0HMneOjsiBVKRySH5OJ3swwqEGHfd21lB
+qg8MSP5/wrHTtN+ucqgzvwA7HHoZVanQLqVb9okEWwQYAQgAJgIbAhYhBOtMG/1P
+BC9t3czskXch9jvTi0eWBQJXDI3IBQkFo5qAAikJEHch9jvTi0eWwV0gBBkBAgAG
+BQJXDI3IAAoJEBOXvFNkDbVRQSYP/0Ewr3T7e0soTz8g4QJLLVqZDZdX8Iez04id
+NHuvAu0AwdZ2wl0C+tMkD7l4R2aI6BKe/9wPndk/NJe+ZYcD/uzyiKIJQD48Prif
+NnwvHu9A80rE4BppQnplENehibbWaGNJQONGFJx7QTYlFjS5LNlG1AX6mQjxvb42
+3zOWSOmEamYXYBmYyMG6vkr/XTPzsldky8XFuPrJUZslL/Wlx31XQ1IrtkHHOYqW
+wr0hTc50/2O8H0ewl/dBZLq3EminZZ+tsTugof0j4SbxYhplw99nGwbN1uXy4L8/
+dWOUXnY5OgaTKZPF15zRMxXN9FeylBVYpp5kzre/rRI6mQ2lafYHdbjvd7ryHF5J
+vYToSDXd0mzF2nLzm6jwsO847ZNd5GdTD6/vcef1IJta1nSwA/hhLtgtlz6/tNnc
+p3lEdCjAMx29jYPDX+Lqs9JAxcJHufr82o6wM9TF24Q8ra8NbvB63odVidCfiHoO
+sIFDUrazH8XuaQzyZkI0bbzLmgMAvMO6u1zPfe/TK6LdJg7AeAKScOJS38D5mmwa
+D1bABr67ebA/X5HdaomSDKVdUYaewfTGBIsrWmCmKpdb+WfX4odFpNzXW/qskiBp
+5WSesKvN1QUkLJZDZD1kz2++Xul5B97s5LxLTLRwvgLoNaUFr3lnejzNLgdBpf6F
+nkA59syRVo8P/2OVSzfPFfPUhJSwzmgNX2WsW6WN91wtbf0oUpORK4otjJETUTvu
+rVHPin473mSAeIypzMO1pHS6Q1uyPj5Em8x7BgGza1hBLUTvTIpRfS+J54hoaQL6
+XGnrE3/QIl/AxGK5aqc9h7EqsTbhPckg6BELWueKg1PpCGWtQ1igCcsTUt/kgJ54
+TjT7dUyuFCAapVgY6lMlEta4dIYJdbeQWkZR043o6u7R0HvYHl0P13thD41guhdZ
+sPNah6km5hd7IEXuBNo/HReSHniIzCKolpIkJyn9X1g+SKJ5aQ6MvFd2L4pkqJKt
++nNvkoQXITw9yExDHJSQChX5QnweeJoU0S2Qc6W9jL9qyOw3U+su2/oPzTk2xRu1
+CwiYLeNjZSNYhU9Az78CsvNrZUUKCmiZrkmN8tRlFFps3TaF/fodwuYfWPC/R9Wp
+Kbtaqjjz3PqXHYbh5NyURVw/EqvMy1yP26PsQn41tE5Ebndl6P2YzjAZQLKNTc58
+4BXq7Tqj55jeeH/sS2XXv5gF2S+tm9+Nwyuavl1mC5CNaL+KbkX6w/OadINUOArQ
+W2HC1SwqP184fN9cJCx3NeB24kKg84M42qQPUOIHfiu0R06JKaPWibk9WAU6ssQL
+crbRs5NZ0ySqJWU0tpS/W4Zlz1YjYtnce0VAbz25OAACZ0adKnWgKv8OuQINBF01
+/K4BEACskZL08crrKfX2aD2w8OUS3jVGSW7K10Jr/dgl6ZB7Xx/y3c9lhBim7oRI
+sl6tpR/DBP50UnTIgBbvynbJ6tbWGptt64AznI7el9pH0k63DOKcfqRUgJKTM4OU
+ZSkcuqQ2qnkvn+g0oiJ3VhaVYOJdJfJF/pLj5Oi3UEL2afoEd048/lZEaATRvEqL
+j+h2pSfETEl5wCWyRnuMSu6ay9NmVzRxiJhPDGW2ppQTxJuaKj+6Vqw5WISu9nsR
+xTPE1DW8f7LYyPBwgultuSYKZoCdfoYE8ff471oZIuCKcGSSBHQbR6MBTD6KJtqz
+BzpfJ8zZJmVO4lg0CJgp9xX2QZ8hPkpaBbnq2JCMS1zriCMN8iGhW6ZHYmZQJtWu
+ubuZt51VL9QmEUUhCF1t+3ld11SaowY4NFKILUdYbC2zAOQIEEJkWRIHKleuc2zY
+SNSoXl06oGgwCKQb5l+LlcYHx4+/F3+KzyAq0NqBC1rMnhbn3tcckdZyhLEpnx9/
+y33ypo6ZZ0s6dLGrmSpJpedEz6zr8siBa4uT3IvVF4xjfpzSt3cMD/Lzhbnk5onU
+fkmoCmQ/pkuKpMr35hHtdDxshLcLPFkTncMjEVAOBToHDbKDSplueyJm48ELPi9Z
+muyNu7WsB8TWVEAkUShxdeHALVpY1D+MjXK+Z5ap6/tppj+fmwARAQABiQRbBBgB
+CAAPBQJdNfyuAhsCBQkFo5qAAkAJEHch9jvTi0eWwV0gBBkBCAAGBQJdNfyuAAoJ
+EHi9ZUc8s70TzUAP/1Qq69M1CMd302TMnp1Yh1O06wkCPFGnMFMVwYRXH5ggoYUb
+3IoCOmIAHOEn6v9fho0rYImS+oRDFeE08dOxeI+Co0xVisVHJ1JJvdnu216BaXEs
+ztZ0KGyUlFidXROrwndlpE3qlz4t1wh/EEaUH2TaQjRJ+O1mXJtF6vLB1+YvMTMz
+3+/3aeX/elDz9aatHSpjBVS2NzbHurb9g7mqD45nB80yTBsPYT7439O9m70Oqsxj
+oDqe0bL/XlIXsM9w3ei/Us7rSfSY5zgIKf7/iu+aJcMAQC9Zir7XASUVsbBZywfp
+o2v4/ACWCHJ63lFST2Qrlf4Rjj1PhF0ifvB2XMR6SewNkDgVlQV+YRPO1XwTOmlo
+FU8qepkt8nm0QM1lhdOQdKVe0QyNn6btyUCKI7p4pKc8/yfZm5j6EboXiGAb3XCc
+SFhR6pFrad12YMcKBhFYvLCaCN6g1q5sSDxvxqfRETvEFVwqOzlfiUH9KVY3WJcO
+Z3Cpbeu3QCpPkTiVZgbnR+WU9JSGQFEi7iZTrT8tct4hIg1Pa35B1lGZIlpYmzvd
+N5YoV9ohJoa1Bxj7qialTT/Su1Eb/toOOkOlqQ7B+1NBXzv9FmiBntC4afykHIeE
+IESNX9LdmvB+kQMW7d1d7Bs0aW2okPDt02vgwH2VEtQTtfq5B98jbwNW9mbXFiEE
+60wb/U8EL23dzOyRdyH2O9OLR5ZO8xAAooIqX4fxPvZZ256qA8ocSRcNm0mZOfqf
+Kd5iURO92YcYQhvV6PG4nlRGUBidyJj6S9JD9ugqNUc0aZ/r4kF7F34eo+GR57G1
+XolyeaLjscO8hT9NLKeG6pl4r/dJkBXsRKpCXjarvCbs+rDR2S/iOMUJHEMD5CrZ
+ofqzMnsNnFNFap9Hdlt7vw3IVVcrGEVA7vbMfMLekW78CTn2GZNTbfKhdWjm37k7
+5DbWRfZ1u4t3o/HVudP4SbKd6g8/USZ5rmOCzDb8QKoee823pxun7jZdiV0aH48E
+cGa5wLcyfuwAtqMd7mTZeQ2V9uNI2Wa63FAUfWqr2uH8lXLEk0d4bNXkbS2KYDB9
+0kVTMTW81Tk/TDg7wesKxfkRx+BzDYFD288ITc58b7XXGnqiI0xFWxHmlO7tGIjU
+FADIgJZRb/Be6GEeSTA1OLB9yIl9UDxyQ6JG5uKTyB4Qflug7GB4BoG7rK6xBUed
+FHIbjCND6qxaj7AMj1Yx22k0bW2gmtJQvg5hrihfdiiBK/mEattgho/gfA7o7ahM
+ydLSVEgYk6psRByYpRr+dZP/c2KlOdjPIyMyURB7z1gqN37fa2Mx85J0g6/AIZpO
+LN1aco8XvuoH0PS/wL/sB0eYQWp/Zlfy8rfVppj5mk9YbkgeV/p/9u4gwFqUk7Eg
+F694GrFwfBCJBFsEGAEIACYCGwIWIQTrTBv9TwQvbd3M7JF3IfY704tHlgUCXTX8
+rgUJBaOagAIpCRB3IfY704tHlsFdIAQZAQgABgUCXTX8rgAKCRB4vWVHPLO9E81A
+D/9UKuvTNQjHd9NkzJ6dWIdTtOsJAjxRpzBTFcGEVx+YIKGFG9yKAjpiABzhJ+r/
+X4aNK2CJkvqEQxXhNPHTsXiPgqNMVYrFRydSSb3Z7ttegWlxLM7WdChslJRYnV0T
+q8J3ZaRN6pc+LdcIfxBGlB9k2kI0SfjtZlybRerywdfmLzEzM9/v92nl/3pQ8/Wm
+rR0qYwVUtjc2x7q2/YO5qg+OZwfNMkwbD2E++N/TvZu9DqrMY6A6ntGy/15SF7DP
+cN3ov1LO60n0mOc4CCn+/4rvmiXDAEAvWYq+1wElFbGwWcsH6aNr+PwAlghyet5R
+Uk9kK5X+EY49T4RdIn7wdlzEeknsDZA4FZUFfmETztV8EzppaBVPKnqZLfJ5tEDN
+ZYXTkHSlXtEMjZ+m7clAiiO6eKSnPP8n2ZuY+hG6F4hgG91wnEhYUeqRa2nddmDH
+CgYRWLywmgjeoNaubEg8b8an0RE7xBVcKjs5X4lB/SlWN1iXDmdwqW3rt0AqT5E4
+lWYG50fllPSUhkBRIu4mU60/LXLeISINT2t+QdZRmSJaWJs73TeWKFfaISaGtQcY
++6ompU0/0rtRG/7aDjpDpakOwftTQV87/RZogZ7QuGn8pByHhCBEjV/S3ZrwfpED
+Fu3dXewbNGltqJDw7dNr4MB9lRLUE7X6uQffI28DVvZm1yw+EAC5FNOwkABxZZ1C
+8K4wUDl2Oe7mewVRhVNqvTWS4uibvFax78HDyLNqKmfi+yRHSQsDAkKr9GzmBc1D
+Oabp4V+IRwj0vADHbcpwoGM7EJ2Go/0RtdZiTP98B8DMACu17NwjM1l5EUExqjGE
+eXp3jEZGMSE8vqjq8djkvl8s5mUMj09Wpj3Gl464NNQ/gnB0P/2sp11T0BVb2u32
+zNLJKh0ZP9QxXT3z93UBOeiT9BzRhqFMyl04xpt5rqYDUdiL7y+tZDR28INZZ7aY
+sCs4NkA22Fh6nI3v43Us38+Kroru09ipLE8A5fx3G5LxMwtWJA+zZisrrky86JYE
+FOULGpFuKrklP2bRyaHePjMeqOzDY5/n5unqk4+EZAPWIM4LFOwDtTD1BWmuDdpP
+/RjPuPZUhoMSW0p/Vv/FuBAnpgVQ9D/kXI3xaAxKgaPp+AzQN50dCosmn643zAGr
+ZTiIDIp1VtXVRFAVinN/mbJkqQJv8zM/x0bc6EUNb/K8BP/JJp+x5D13DjtXYUEG
+8TFHz6YKZe9QzlhK5rZY/FttwqvyKvIKanXEjOf5/azkdOGlSN6Z74G4l22tui3y
+3CM+vmRrlMiBbLkCTuPfw8rS6uziB5No8PYBwovbqNvpm+dGNHySFTvNyJhzWmvC
+Vt8FZ+c4tqOmwd/D+fhon0Pg42bu+bkCDQRYhr/MARAAra5iu3Ndg38ZDwCUg9dl
+Wp8Sy7742FtChFisTekzEUAmsC4RsBX+xSzaWm/NvQxTIQXDVYCfGlNGCCLvXx66
+CGhovm5AZA5ElhIUk5WGuiEnwZ+mZPQBgVgf0iHpTp3LgHCPyJOgXQ8yF5wze3F7
+DIFdape4yG3W7HV+t8GRBcKm2oi9RlneAVCoY9B+OmUxFQS5dDHxzZWJfl94m/Vq
+UUuogQBjlrPCqsOcVRO6CZvQw111jnT1BPPxVbYvm5js/iAsEBE2PSNhJsjV8lBt
+4mirNO1QH+0jx4YMgRJDJ4LeWRnB+ILNZtpfxxUNErTRTYV7s5R70IQ83fTNZ6qb
+LRHvn/AGTIMjZzPrhhyavVVbWjZ8LTA2rLbzZFDrPmrjF2zcLJecvzumT1+SOSLy
+ZlIW0odFDoLhjySlLv25eubYXmoc+BxgQNEOZ84DS11ZlOmonNeN4oscTJPv6gOf
+SOinpYFho/UATwB1OvP/yeHTxbZbESme7yNLw9eMJzL2iRb+rck0oDXVrEDglovp
+9eqxnzMdSzWUztWzukxOvmS7rznIRiU2D+C2wnliy/Kg23X896Eih1KcmpRCyZY8
+4p+q96qAN06r6BiuTlqxaM7oVq1rd7SLaOd6Cd+LyQrEWdKryg5/T0F/a96OeoSo
+Z/Bvc/1+bTZX683kmIpFkHEAEQEAAYkEWwQYAQIADwUCWIa/zAIbAgUJBaOagAJA
+CRB3IfY704tHlsFdIAQZAQIABgUCWIa/zAAKCRBklMbWmXwhXluJD/4mavm5UQ84
+EczsNesfNL8gY3zzlCnfvnUlJHK+CoYub4wcoDXVUlnCmWgSlZHQZgr3/qfW2MM3
+y/kXcbxhL/FijUzY3WlnCdnIVNjuB+QJt0LHbkP7En/o085ZzHuzaXxfZ97qN+KP
+sRBTjnJ8hd3B64cVjgnXva1+pG51EK4iDF2bXiWPHvUbPiL+Og6C9XjpWrwIA1CW
+yH/4i7dtfTnbViO2aqKQNHfrXJ+xS938Lr8r5+VmUWByHqweBGIASOmwsJeSUHoz
+kZYbmMdaJJ8j458zyfS6LO+HIa3+zhzidOoiEH9c5QvVf54gNsYjPTcHj7U0Dgkx
+CVQeiBKBLR+q6M6QHa4qax/X0Z2ZCcSDTZwqGJNaKfcFYd8X1B2zgrxkGweeHKjf
+mpqfXRKrggHumLdVqHU7KS9cz1yeTL+Nw7ne+kzRMEA8sLnm4ODRUJwUz12RqS0G
+G1FYV0rjJVWVzRFMfMUs+7xAptEuMdoddkQSmytkXyOKAqv8KQ9XUEbGWikmCxW2
+cOY9spOpwQa7X2oXe7FlV9RfmHYrG03k+YlIREgFqlvWwsgpzURculd+CIFvT3vc
+i7vFm1UiQBb5wC8bHOoRsr7OXW1267lipouZr5OrQhVnRZQVa64cdUIKjLXEt479
+0uxh8ggNwktZRILIn2JHjgEQICdYWeQb1BYhBOtMG/1PBC9t3czskXch9jvTi0eW
+urUP+wb66lIhDB0U9NuFdJUTc6nO/1cy3i9mGCVoqwmTcB1BJ9E1hncMUP1/MvrA
+gkBBrAWJiD2Xj9QV/uBozA7nLxrV7cf1de9OLgH4eNEfX25xj8BBPYnyVyHsyk5Z
+HDhjj9SaurfvlFWYi13i5ieMpyLVJV4+r2Wi1x1UgKVAlB78sHYnbDzSoHPLBcIx
+tIKp30LJ0PEkat8SG7G2wgtv1RdhmcZEBV05vMnrGGO991e+pKzRNPYH8rD3VQKJ
+lvaFwsJuBTW42gZ3KfpUNKI2ugCcnRNpoHFWNCrzlJ0CFI48LMlmUSs+7i/l+QGl
+eaLKQxRTNNpAmevLrS7ga4Iq0IEqxey6VW6RSk/Z1Z37J8B7PISSR0rZn6TeyQgF
+Wf/FOLw6OtwOquGmMeGSqj2UzxybygtsvUZz0BxYymoWFd4F8sp43oL2TXU6Wp7Q
+IpBaFgkSf/UQxfR6wcQ3ivafeS1lg8vUFuMfuMLto6T0JiZw8uKSuDWltSReF+FX
+Vnhawz72BZMy8RIoshGdpWHn/YbN6L+JOuxZnvkMAZvSLT3c0H4XCDYtEfK2mJMq
+D2ynX5tGR8Fy3GAaEjhx36TvzTjCXRmJ+FnlSW1p77x+UjFUFcpY8skv+f0Gip30
+iynAb1hoAdibIDab612OWi/4vX0DaM6t68Uq8rsabeJYsZG4iQRbBBgBCAAmAhsC
+FiEE60wb/U8EL23dzOyRdyH2O9OLR5YFAliGv8wFCQWjmoACKQkQdyH2O9OLR5bB
+XSAEGQECAAYFAliGv8wACgkQZJTG1pl8IV5biQ/+Jmr5uVEPOBHM7DXrHzS/IGN8
+85Qp3751JSRyvgqGLm+MHKA11VJZwploEpWR0GYK9/6n1tjDN8v5F3G8YS/xYo1M
+2N1pZwnZyFTY7gfkCbdCx25D+xJ/6NPOWcx7s2l8X2fe6jfij7EQU45yfIXdweuH
+FY4J172tfqRudRCuIgxdm14ljx71Gz4i/joOgvV46Vq8CANQlsh/+Iu3bX0521Yj
+tmqikDR361yfsUvd/C6/K+flZlFgch6sHgRiAEjpsLCXklB6M5GWG5jHWiSfI+Of
+M8n0uizvhyGt/s4c4nTqIhB/XOUL1X+eIDbGIz03B4+1NA4JMQlUHogSgS0fqujO
+kB2uKmsf19GdmQnEg02cKhiTWin3BWHfF9Qds4K8ZBsHnhyo35qan10Sq4IB7pi3
+Vah1OykvXM9cnky/jcO53vpM0TBAPLC55uDg0VCcFM9dkaktBhtRWFdK4yVVlc0R
+THzFLPu8QKbRLjHaHXZEEpsrZF8jigKr/CkPV1BGxlopJgsVtnDmPbKTqcEGu19q
+F3uxZVfUX5h2KxtN5PmJSERIBapb1sLIKc1EXLpXfgiBb0973Iu7xZtVIkAW+cAv
+GxzqEbK+zl1tduu5YqaLma+Tq0IVZ0WUFWuuHHVCCoy1xLeO/dLsYfIIDcJLWUSC
+yJ9iR44BECAnWFnkG9T3MA/8DRZi0s7SLQwaQiJrT7GrACsIMjYo6SapUVxDMF28
+QfANW809ANpq2Let+yADmEibSgpiDiO7rq6PvYnHmPyxmTbEwMtm1bDi0j55/Tyb
+nNN6hnUo8F+o0ywCJjfoT8GDuBX50ODoOYUMmIoYwyMz/UtNi8iHtxTBPR5b7l1V
+t8EfUb3wrwGa4i22mjgLKU49h7Oyi1VYZRrM+0hlrmaLF79tT9msDnn83mgq9qef
+kJuU4nBqUXui/CY5b8vJXC+8tD+q1wCiUM8uv2LJs/5JyK80zFJbkBXA/ZCYtU0L
+JEpUf7HjbIAdCMDWjpc4j+IyjU+Axv+NkMLgYRhaadnPRVzqY8f2T2Bs+EQWk2i6
+1BVQMqakGtwBWIMCp2fnGDCxIL/FCN1kIA0J0h9ommhMgZdOJaAktsddr/LwVh/h
+cYX8Mfy94vPs+E3Kb6OiiwPkkN6umQvdFa9Rhh9SUNvmtXzMo3WELLobtvVKC+fd
+FVatDsJurTRKLDKEvPjSxFlJ/T8t9yItTBAZ7+ab4nJhWoEbzkVTgNizLCJNmdAE
+tiKa9dEZOZl0DVmxBhB1aqMfHA3S5UhZXmGBHwCF6PcpnM3C4XY2MjQ/sRxdFa7/
+HFBKOO176h6HyujQ/AyOllmvJCCg9Hz0Wk0tjTMFsnAbh7dB2GTNQwBNZ60gUCWR
++mG5Ag0EZbladgEQAMSm1QPtyjArXdM1i2Y6439Jc/AJy3ykVjxTaDi6n5z7lgQi
+paQBSpWbwun4Op0W5fs1t8rYE2iPA/KKoqVoEA3o3Hts71uNK+VttkGtUneYv6Tv
+GsV1MYt4NJJOUQF6yPsVcrXMrtJb0BXefjmWY4sBdMLXdVDcrRIRdv7r0XBevfX+
+Lng2BN8z/UtwlmEihHoy60ckJJgq47pkfFho51+PjwEZJaPtEgRsXn2sgTMNHukG
+TrV8ub/aKWVNBPF0wYYF5LA2NHgVp148nS11F4OgiNpCkAZmJQCPlyp4emYfxkih
+jh+TZKw6KcrxwOCx7YeceKK6wWvrHHrwjJxl2nhatDIYNIlnVkqTlBp4A9gTdCxm
+ciZ1xXb+QllLycBYMWgu2lo1Kk40NOfVljIKLatY88XwmJUySYLGyX5kePI29kc+
+yVGycYHsSgoOlyM/Vw+GXfuj/BRinKItjITxb6YM25wfhgctUer/NAao7dXprFMD
+UOz6C720dX/f7ISsiqmi7X1U588omNgLvJ/O8gPnyMtk1gWrwhFZDlVYI5AlYxx3
+MwoHntLZlvm8iEmR+X9LkhIwZcNdvfafIpV+8LlOaIxt+uzNzcMsDHCGomUAf/GY
+XbI8/x1iHoopZIh99UZObfyxyz2SSbVtUEBHXyKXHp0bFWM1Iz2LfQwxeNRRABEB
+AAGJBHIEGAEKACYWIQTrTBv9TwQvbd3M7JF3IfY704tHlgUCZbladgIbAgUJBaOa
+gAJACRB3IfY704tHlsF0IAQZAQoAHRYhBA8G/4a+6vTnGGbuUjLuU1WmvG5CBQJl
+uVp2AAoJEDLuU1WmvG5CmB4P/1RnXKHryp3UlaOAq/UAF2YKFS9NAggVwH8PhsFc
+6nZpruc+CFU1s5jwCuW9aiWgQ+TjBFvQ0h/bHLbujlTSmfyyyo/Ij+4vSxRzlmUa
+8lHPqyqv7fIsQ82AAs8WE/mV8Dif24hsxJSZEH130DTkRqtnXS0FB6sOQPGj5EKA
+Ft3v0vN/Z1QRX2eLmZc2jO7QfkdRstrvF3borb7xdt26/PM8g8RgYaG+fqIJ/NtG
+QF0XI+WUxuQ+mtRGEyVpL4qnwwnokyxjsMxsJvvGIaPULKR1CahGJD4tAlyE3DvN
+ikMRI2SDojaGyh5cw24mJJVZmx467Q3tE4dwmAu8pCGCldUQBG6eprTL/WauyJcm
+kJr1qsSK7gyx+Uy8mwXESY/s5bwDkzhlzaJ0WjBxqXfoHFIElHJfhLS0efqIr6NF
+mPUu4cBKJKoZoFBwTPTTEmWz7tE2mDgVO9Z6Q9fq7CwZS6J/GchieQgAy3Rxm5Bi
+zBZsWisY3BQ4JX1w6wH0Cae4rYCebkutFFWBg7JA3j2nkgfzsD3kYHYf5BllL2yV
+589dEocNjPios56vPi5kg9UQOFO1SaX4Efu1eArNcNteBxKf5pH8okDcgjqj9yXZ
+Rs6fI2Uk9zzz0UL63+iRSqSj8Kv6iepLCzOph1DHnY2tFghpSFYqlayhdprMJVk7
+GmLFoiYP/1nT6wq8k/RDS3/W7HEBJ8Rtxs1vL51nU0e5K7jgbUT9kaG2KBmlnRbg
+kELjvu0lX6zLFiyPcc5JkvE2AyfZ7t5cIfanOS4hc0W9C66RQo2cvUxkn2gtCrM7
+KCTc16Iwe/uMC2RNEneNLiCetwc5DhpjYExR59szzQ9Npx31pefsmkSwKdutEz8W
+96l29yHYgIDoLYW3b6nuBRBfp4nAXQ1gWqfEmFNFlKZBa2pPsKNlFgpchC+EiMQ/
+db1ElVNyW38K7IOx6hNGpEBJwbPuHNef9WU3n2DIIgMBHTHPvbNHiCNTfuOM1+/B
+MbmK59RmW66TS0UaxZsswHHLZt7vNN7SKzXsveT9+A1d6wZlVoy8Y3gykBKnBHGR
+aGO0zaXczHt4YsUA4L3is6lAjbIopU5M3j2F1RFKRr95+HZT/NXNeGbFvsdKmvP4
+ELtDAuYVMgYR8GqjI5yP/ccVMsi/mhT+cUxO/F7+7nixw1Go637Jqr/NF5kjjrBD
+8EiGy8QrGm6uBR3NGad0BnMWKa2YoYKF1m3Fs/evBkcymR+hSwFzkXm6WSOb8hzJ
+IayFa6kAc7uSKyR5iG00p/neibbqM1aUAQDBwV7g9wPmcdRIjJS2MtK1JXHZCR1g
+VKb+EObct6RJOVw8s58ES5O9wGZmbVtIZ+JHTbuH+tg0EoRNcCbzuQINBGPs+VgB
+EADKbgLL+vAabKV2rGSDgY+IttTAtg9w9Uor1+Q/CIWGxi/JQy7l7XTKjmS0wvdw
+U+9f/eGsjxigbvAcSsV1szyKfVQQFT2m9KhDrBqNCAvQ5Tg6ZQdNe51oHwjiIQ1i
+7z8QoT22VucdTYqcMLAHe+g0aNqLLSSWLAiW4z+nerclinjiTRCw/aWZJR1ozQd2
+eKwAw6rk19bHcihXo2E0K1EDmdHcNA8ytypxwWWXBftCYRWXi5J02GeZazxmx/DU
+LnFgy2J4G0ULTqGWsbf/tCt22jqgyX+vFj/sJPn+l3IJqpyNY5yBG6GcejeP9vRo
+QrapGqHkcx+37f2vjwmpj5548JI52KEC1yZeFwp8HjGLp+zGajpnokrKd4XJHniW
+9+bPLq7Yp7PNn65MaYvZUjv5enKd45fFK6vJ3Ys/fx6PBXKKBs9flRIgdXOKSvtV
++bGIG0I/p/JEZ/wPxRgxHPDK5jbcI6KBVm3Uk+CHFC4IBAtzdSh6H4Zfw1EH3dQZ
+MLVBB/Sj34UQhlwAOlAXtZH3vks/KpclWK8gnqz3i8HN0ezvcnQlRiRO8IqlN9/P
+mFqZeNTerklT7Tt0jXqiopLHL0FXR2LsndeORfxDE1rhVOUxloeuIsY8x6gO8h2b
+Gg41YapROjYxZZEcakg9Nch4XAlxeqB4ISttfbiVxeL2DQARAQABiQRbBBgBCAAm
+AhsCFiEE60wb/U8EL23dzOyRdyH2O9OLR5YFAmPs+VgFCQWjmoACKQkQdyH2O9OL
+R5bBXSAEGQEIAAYFAmPs+VgACgkQ6Il5+5swrPJG5Q/+PMhN1qYugsPEQc6trsy3
+ZLql4evdcxulYR1GUDW/OXsBoxg7vw9ubtiRa4QHJpczq8YILy+GvFmrT10Gj6g2
+WkoeNXpTNWGtAu3DUKu8TVQNKXDeW0Pil12TLkGgPPQQpU0lyE8+o+DuKb4QBvMv
+ENhPTL+1GGrNDoQ4M1SK8trNaNj5pdao5W/Y3LTvXK0VIher/UbvWkJIBh2LeLsj
+9x8yg36Dbs1/1l9ztBZvDTaZyZOqmbCysIO7pFHSTiBCGyyzS1PWWJsrN8DbQyjH
+5uE+/Wm0jcDSJ+HXeYWqR/QQLgyZ5OFpxTmqfQEGT4CV9llygtg10GXkl9VV6SN6
+6+xUm0nnPHeW4rcO7NtF1skAdvmaHrUcTYEddOBiIfy2o7WrSyhXPTZz/UpoXsvJ
+68VWRceh7l7Jxjj5G47IhWDLMbT1WJzu9pwQ0wz+GXoyzmmstirQm/KSZAh/FNIL
+qrgxlXfktNl8feO3r8rx6hreVdMlRTw+7gLuwOUAWF77XLc6vd0tY2QyKDD/dznv
+FaVK1wQX4s8x1cT+lVJsTPeyBPoI1UajfT7jK6dg/chAVBpOOH0Fuc8rrqJmGnOz
+Kcdn51oBgPwJfboNrr0uKCM1MixCcaXOjPEWJbmnEiIxYAooLnEbL0wcupaGxtRT
+L50Ms3uvnwHim26yvOTrgNTPGRAAmgSihpu4US/JoWnR/aeiFf9upobXVDnBnqOA
+XiMUaFeS+hUuh5EWUhDLIWYvXXhPacvbpUOlxwLsLIdPRQGGSp1/rqhVRnmWsJ34
+DoAKxG7Elq8EArK/pF+v4wSUMegjAPJQevIcLvm83z+jHmbk1AEeioBYTq45Rbzl
+HmyLmGK/zT13KnBUWE3sFkECoco+vMli8oPeL+JMfiMgPb2vDs+58YlHq5W26pe0
+8BwGzY5LQM7Jt52oxsqgXEX/N95QqgScsc625wCIE8/Qo5pXT0TKk+5ViFojs2Ei
+3mgXHBXFgISdAtWBEmqN9TESqPPrHzfnFk9t6mPg1r5Nt37IKO7oTzu7/SXrJlXP
+IQ99Nlq6HO/mMVdYjbWFBPw8+NGVGemQchOODZsksvHJGV4gjMpW1FC37MRNsiai
+1UMraVxzsrCte4/oqpa7bY8VdWw6p5mvfdroLkwHW2cS2lgC8ft7e4npiHXXLAIi
+b+sFHcrIkZu0uJxGCJOkUwkaDrAFKWzZYHc2YUrW5XN7CNBo/fe90r1W9/4esn59
+SM2mTMarrUn1fiExwFiUci4U+3/7U4IiViNeNoZ2J1+hqxudlx1OT7Ae2Wg4dLAS
+oEHaMKby4+JVVicA8jdlocrCbpEv1hVV47hwiKc+VTQGvCZqs8eT+pbnw1Recd13
+J9Ny7bOJBFsEGAEIAA8FAmPs+VgCGwIFCQWjmoACQAkQdyH2O9OLR5bBXSAEGQEI
+AAYFAmPs+VgACgkQ6Il5+5swrPJG5Q/+PMhN1qYugsPEQc6trsy3ZLql4evdcxul
+YR1GUDW/OXsBoxg7vw9ubtiRa4QHJpczq8YILy+GvFmrT10Gj6g2WkoeNXpTNWGt
+Au3DUKu8TVQNKXDeW0Pil12TLkGgPPQQpU0lyE8+o+DuKb4QBvMvENhPTL+1GGrN
+DoQ4M1SK8trNaNj5pdao5W/Y3LTvXK0VIher/UbvWkJIBh2LeLsj9x8yg36Dbs1/
+1l9ztBZvDTaZyZOqmbCysIO7pFHSTiBCGyyzS1PWWJsrN8DbQyjH5uE+/Wm0jcDS
+J+HXeYWqR/QQLgyZ5OFpxTmqfQEGT4CV9llygtg10GXkl9VV6SN66+xUm0nnPHeW
+4rcO7NtF1skAdvmaHrUcTYEddOBiIfy2o7WrSyhXPTZz/UpoXsvJ68VWRceh7l7J
+xjj5G47IhWDLMbT1WJzu9pwQ0wz+GXoyzmmstirQm/KSZAh/FNILqrgxlXfktNl8
+feO3r8rx6hreVdMlRTw+7gLuwOUAWF77XLc6vd0tY2QyKDD/dznvFaVK1wQX4s8x
+1cT+lVJsTPeyBPoI1UajfT7jK6dg/chAVBpOOH0Fuc8rrqJmGnOzKcdn51oBgPwJ
+fboNrr0uKCM1MixCcaXOjPEWJbmnEiIxYAooLnEbL0wcupaGxtRTL50Ms3uvnwHi
+m26yvOTrgNQWIQTrTBv9TwQvbd3M7JF3IfY704tHlqW3EACfsMyLwntqn+Qu8r3k
+/6IRn0i9XV/bhStE2y6iHUmqs5sd7dfkmVI7bspoOuDKFIErdTephH09E0hvQDJE
+RnMm+rh8TlZtOS/wYywx+2ahSh5Jt3dI5L48ozR+WJbExiXq8ZqTnpn/EQGQ8MoM
++S2dS+czX85ZL+m3ig+tKHwaaXdvGcYI3h8WwQnX3IBUFCur8WSdfcoGyiQ4cpTX
+cI11GgGgkypxM8wxxoLVCTttpCBRCpPf8/PLKMCK0/k3u4QShtp1WDDQVhFm/E6o
+fG9TSGIKcJmsHHQY7rukEp6lSIvmL0ZjByRah4nK5zoc2j89sNpyuemZwr9X+V9L
+OjF7vQTO/8y3cBBNCt0R5lrxeBvRze15k0DzShuHyPhg2PBqfPOS7RnUiF2FeI+z
+Q7xFnLqoD6ckI76RRAf7w0sqnvMlDRpjVU+cDyupR5NdB79oPXJpHltKg4kaQ4O5
+x6BXHVEpAMhJc8bPvmfAiTFac5f0ycibf2R5tNlzbKMD/BxVrzXMghsJ5PWmAiUb
+qPv1II5kLw51b6Bzvl8KzJI0h+ySiUGb86yecfHGbF7zPRch2Kt5+7t0fgEjAVcM
+RfcgHsfQn8EYP9zoczp5Gw7LvR8BBDq1dsTEEEPTDre+HyGxpDN4c8LNGrDaCFdX
+nOdlNV/zT9VvBk/RkV+Tl/Lk4g==
+=z1hR
+-----END PGP PUBLIC KEY BLOCK-----
+
 pub    78178478013521D0
 sub    FA84183FDD6A6B98
 -----BEGIN PGP PUBLIC KEY BLOCK-----
diff --git a/gradle/verification-metadata.xml b/gradle/verification-metadata.xml
index 864d30f5a..62f4431f2 100644
--- a/gradle/verification-metadata.xml
+++ b/gradle/verification-metadata.xml
@@ -3,15 +3,20 @@
    <configuration>
       <verify-metadata>true</verify-metadata>
       <verify-signatures>true</verify-signatures>
-      <key-servers enabled="false"/>
+      <keyring-format>armored</keyring-format>
+      <key-servers enabled="false">
+         <key-server uri="https://keyserver.ubuntu.com"/>
+         <key-server uri="https://keys.openpgp.org"/>
+      </key-servers>
       <trusted-artifacts>
          <trust group="androidx.databinding"/>
+         <trust group="com.android.tools.build" name="bundletool" reason="b/215430394"/>
+         <trust group="com.android.tools.build.jetifier" reason="b/215430394"/>
          <trust group="com.google.testing.platform"/>
          <trust group="gradle" name="gradle"/>
          <trust file=".*-javadoc[.]jar" regex="true"/>
          <trust file=".*-sources[.]jar" regex="true"/>
          <trust group="^androidx($|([.].*))" regex="true" reason="not signed yet"/>
-         <trust group="^com.android($|([.].*))" regex="true"/>
       </trusted-artifacts>
       <trusted-keys>
          <trusted-key id="03C123038C20AAE9E286C857479D601F3A7B5C1A" group="com.github.ajalt.clikt" name="clikt-jvm"/>
@@ -171,6 +176,22 @@
          <trusted-key id="E85AED155021AF8A6C6B7A4A7C7D8456294423BA" group="org.objenesis"/>
          <trusted-key id="EA23DB1360D9029481E7F2EFECDFEA3CB4493B94" group="jline"/>
          <trusted-key id="EB1B3DE71713C9EC2E87CC26EE92349AD86DE446" group="com.google.j2objc"/>
+         <trusted-key id="A5F483CD733A4EBAEA378B2AE88979FB9B30ACF2">
+            <trusting group="com.android"/>
+            <trusting group="com.android.databinding"/>
+            <trusting group="com.android.kotlin.multiplatform.library"/>
+            <trusting group="com.android.tools"/>
+            <trusting group="com.android.tools.analytics-library"/>
+            <trusting group="com.android.tools.build"/>
+            <trusting group="com.android.tools.build.jetifier"/>
+            <trusting group="com.android.tools.ddms"/>
+            <trusting group="com.android.tools.emulator"/>
+            <trusting group="com.android.tools.external.com-intellij"/>
+            <trusting group="com.android.tools.external.org-jetbrains"/>
+            <trusting group="com.android.tools.layoutlib"/>
+            <trusting group="com.android.tools.lint"/>
+            <trusting group="com.android.tools.utp"/>
+         </trusted-key>
          <trusted-key id="EE0CA873074092F806F59B65D364ABAA39A47320">
             <trusting group="com.google.errorprone"/>
             <trusting group="com.google.turbine"/>
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 739c32bb4..b8d661d2f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,7 +1,7 @@
 #Tue May 30 13:39:24 PDT 2023
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
-distributionSha256Sum=544c35d6bd849ae8a5ed0bcea39ba677dc40f49df7d1835561582da2009b961d
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
+distributionSha256Sum=5b9c5eb3f9fc2c94abaea57d90bd78747ca117ddbbf96c859d3741181a12bf2a
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
index dc1be701c..0efa87555 100755
--- a/gradlew
+++ b/gradlew
@@ -83,7 +83,7 @@ if [ $darwin == "true" ]; then
 else
     plat="linux"
 fi
-export JAVA_HOME="$APP_HOME/../../prebuilts/jdk/jdk17/$plat-x86"
+export JAVA_HOME="$APP_HOME/../../prebuilts/jdk/jdk21/$plat-x86"
 # --------------------- end of metalava changes ------------------------
 
 # Determine the Java command to use to start the JVM.
diff --git a/integration/api_lint.ignore b/integration/api_lint.ignore
index 0e31469a3..f000ff8b3 100644
--- a/integration/api_lint.ignore
+++ b/integration/api_lint.ignore
@@ -7,10 +7,14 @@ GetterSetterNames: androidx.compose.foundation.gestures.ScrollableState#getCanSc
     Getter for boolean property `canScrollBackward` is named `getCanScrollBackward` but should match the property name. Use `@get:JvmName` to rename.
 GetterSetterNames: androidx.compose.foundation.gestures.ScrollableState#getCanScrollForward():
     Getter for boolean property `canScrollForward` is named `getCanScrollForward` but should match the property name. Use `@get:JvmName` to rename.
+GetterSetterNames: androidx.compose.foundation.lazy.LazyListLayoutInfo#reverseLayout:
+    Invalid name for boolean property `reverseLayout`. Should start with one of `has`, `can`, `should`, `is`.
 GetterSetterNames: androidx.compose.foundation.lazy.LazyListState#getCanScrollBackward():
     Getter for boolean property `canScrollBackward` is named `getCanScrollBackward` but should match the property name. Use `@get:JvmName` to rename.
 GetterSetterNames: androidx.compose.foundation.lazy.LazyListState#getCanScrollForward():
     Getter for boolean property `canScrollForward` is named `getCanScrollForward` but should match the property name. Use `@get:JvmName` to rename.
+GetterSetterNames: androidx.compose.foundation.lazy.grid.LazyGridLayoutInfo#reverseLayout:
+    Invalid name for boolean property `reverseLayout`. Should start with one of `has`, `can`, `should`, `is`.
 GetterSetterNames: androidx.compose.foundation.lazy.grid.LazyGridState#getCanScrollBackward():
     Getter for boolean property `canScrollBackward` is named `getCanScrollBackward` but should match the property name. Use `@get:JvmName` to rename.
 GetterSetterNames: androidx.compose.foundation.lazy.grid.LazyGridState#getCanScrollForward():
@@ -23,11 +27,5 @@ GetterSetterNames: androidx.compose.foundation.pager.PagerState#getCanScrollBack
     Getter for boolean property `canScrollBackward` is named `getCanScrollBackward` but should match the property name. Use `@get:JvmName` to rename.
 GetterSetterNames: androidx.compose.foundation.pager.PagerState#getCanScrollForward():
     Getter for boolean property `canScrollForward` is named `getCanScrollForward` but should match the property name. Use `@get:JvmName` to rename.
-GetterSetterNames: androidx.compose.foundation.text2.input.TextFieldBufferWithSelection#getHasSelection():
-    Getter for boolean property `hasSelection` is named `getHasSelection` but should match the property name. Use `@get:JvmName` to rename.
-GetterSetterNames: field KeyboardOptions.autoCorrect:
+GetterSetterNames: androidx.compose.foundation.text.KeyboardOptions#autoCorrect:
     Invalid name for boolean property `autoCorrect`. Should start with one of `has`, `can`, `should`, `is`.
-GetterSetterNames: field LazyGridLayoutInfo.reverseLayout:
-    Invalid name for boolean property `reverseLayout`. Should start with one of `has`, `can`, `should`, `is`.
-GetterSetterNames: field LazyListLayoutInfo.reverseLayout:
-    Invalid name for boolean property `reverseLayout`. Should start with one of `has`, `can`, `should`, `is`.
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt
index 591fbae14..390f5c7b9 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt
@@ -16,30 +16,13 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.Reporter
 import com.intellij.psi.JavaDocTokenType
 import com.intellij.psi.JavaPsiFacade
-import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiElement
-import com.intellij.psi.PsiJavaCodeReferenceElement
-import com.intellij.psi.PsiMember
 import com.intellij.psi.PsiMethod
-import com.intellij.psi.PsiReference
-import com.intellij.psi.PsiTypeParameter
-import com.intellij.psi.PsiWhiteSpace
-import com.intellij.psi.impl.source.SourceTreeToPsiMap
-import com.intellij.psi.impl.source.javadoc.PsiDocMethodOrFieldRef
-import com.intellij.psi.impl.source.tree.CompositePsiElement
-import com.intellij.psi.impl.source.tree.JavaDocElementType
 import com.intellij.psi.javadoc.PsiDocComment
 import com.intellij.psi.javadoc.PsiDocTag
 import com.intellij.psi.javadoc.PsiDocToken
-import com.intellij.psi.javadoc.PsiInlineDocTag
-import org.intellij.lang.annotations.Language
 
 /*
  * Various utilities for handling javadoc, such as
@@ -273,253 +256,6 @@ internal fun insertInto(existingDoc: String, newText: String, initialOffset: Int
     }
 }
 
-/** Converts from package.html content to a package-info.java javadoc string. */
-@Language("JAVA")
-fun packageHtmlToJavadoc(@Language("HTML") packageHtml: String?): String {
-    packageHtml ?: return ""
-    if (packageHtml.isBlank()) {
-        return ""
-    }
-
-    val body = getBodyContents(packageHtml).trim()
-    if (body.isBlank()) {
-        return ""
-    }
-    // Combine into comment lines prefixed by asterisk, ,and make sure we don't
-    // have end-comment markers in the HTML that will escape out of the javadoc comment
-    val comment = body.lines().joinToString(separator = "\n") { " * $it" }.replace("*/", "&#42;/")
-    @Suppress("DanglingJavadoc") return "/**\n$comment\n */\n"
-}
-
-/**
- * Returns the body content from the given HTML document. Attempts to tokenize the HTML properly
- * such that it doesn't get confused by comments or text that looks like tags.
- */
-@Suppress("LocalVariableName")
-private fun getBodyContents(html: String): String {
-    val length = html.length
-    val STATE_TEXT = 1
-    val STATE_SLASH = 2
-    val STATE_ATTRIBUTE_NAME = 3
-    val STATE_IN_TAG = 4
-    val STATE_BEFORE_ATTRIBUTE = 5
-    val STATE_ATTRIBUTE_BEFORE_EQUALS = 6
-    val STATE_ATTRIBUTE_AFTER_EQUALS = 7
-    val STATE_ATTRIBUTE_VALUE_NONE = 8
-    val STATE_ATTRIBUTE_VALUE_SINGLE = 9
-    val STATE_ATTRIBUTE_VALUE_DOUBLE = 10
-    val STATE_CLOSE_TAG = 11
-    val STATE_ENDING_TAG = 12
-
-    var bodyStart = -1
-    var htmlStart = -1
-
-    var state = STATE_TEXT
-    var offset = 0
-    var tagStart = -1
-    var tagEndStart = -1
-    var prev = -1
-    loop@ while (offset < length) {
-        if (offset == prev) {
-            // Purely here to prevent potential bugs in the state machine from looping
-            // infinitely
-            offset++
-            if (offset == length) {
-                break
-            }
-        }
-        prev = offset
-
-        val c = html[offset]
-        when (state) {
-            STATE_TEXT -> {
-                if (c == '<') {
-                    state = STATE_SLASH
-                    offset++
-                    continue@loop
-                }
-
-                // Other text is just ignored
-                offset++
-            }
-            STATE_SLASH -> {
-                if (c == '!') {
-                    if (html.startsWith("!--", offset)) {
-                        // Comment
-                        val end = html.indexOf("-->", offset + 3)
-                        if (end == -1) {
-                            offset = length
-                        } else {
-                            offset = end + 3
-                            state = STATE_TEXT
-                        }
-                        continue@loop
-                    } else if (html.startsWith("![CDATA[", offset)) {
-                        val end = html.indexOf("]]>", offset + 8)
-                        if (end == -1) {
-                            offset = length
-                        } else {
-                            state = STATE_TEXT
-                            offset = end + 3
-                        }
-                        continue@loop
-                    } else {
-                        val end = html.indexOf('>', offset + 2)
-                        if (end == -1) {
-                            offset = length
-                            state = STATE_TEXT
-                        } else {
-                            offset = end + 1
-                            state = STATE_TEXT
-                        }
-                        continue@loop
-                    }
-                } else if (c == '/') {
-                    state = STATE_CLOSE_TAG
-                    offset++
-                    tagEndStart = offset
-                    continue@loop
-                } else if (c == '?') {
-                    // XML Prologue
-                    val end = html.indexOf('>', offset + 2)
-                    if (end == -1) {
-                        offset = length
-                        state = STATE_TEXT
-                    } else {
-                        offset = end + 1
-                        state = STATE_TEXT
-                    }
-                    continue@loop
-                }
-                state = STATE_IN_TAG
-                tagStart = offset
-            }
-            STATE_CLOSE_TAG -> {
-                if (c == '>') {
-                    state = STATE_TEXT
-                    if (html.startsWith("body", tagEndStart, true)) {
-                        val bodyEnd = tagEndStart - 2 // </
-                        if (bodyStart != -1) {
-                            return html.substring(bodyStart, bodyEnd)
-                        }
-                    }
-                    if (html.startsWith("html", tagEndStart, true)) {
-                        val htmlEnd = tagEndStart - 2
-                        if (htmlEnd != -1) {
-                            return html.substring(htmlStart, htmlEnd)
-                        }
-                    }
-                }
-                offset++
-            }
-            STATE_IN_TAG -> {
-                val whitespace = Character.isWhitespace(c)
-                if (whitespace || c == '>') {
-                    if (html.startsWith("body", tagStart, true)) {
-                        bodyStart = html.indexOf('>', offset) + 1
-                    }
-                    if (html.startsWith("html", tagStart, true)) {
-                        htmlStart = html.indexOf('>', offset) + 1
-                    }
-                }
-
-                when {
-                    whitespace -> state = STATE_BEFORE_ATTRIBUTE
-                    c == '>' -> {
-                        state = STATE_TEXT
-                    }
-                    c == '/' -> state = STATE_ENDING_TAG
-                }
-                offset++
-            }
-            STATE_ENDING_TAG -> {
-                if (c == '>') {
-                    if (html.startsWith("body", tagEndStart, true)) {
-                        val bodyEnd = tagEndStart - 1
-                        if (bodyStart != -1) {
-                            return html.substring(bodyStart, bodyEnd)
-                        }
-                    }
-                    if (html.startsWith("html", tagEndStart, true)) {
-                        val htmlEnd = tagEndStart - 1
-                        if (htmlEnd != -1) {
-                            return html.substring(htmlStart, htmlEnd)
-                        }
-                    }
-                    offset++
-                    state = STATE_TEXT
-                }
-            }
-            STATE_BEFORE_ATTRIBUTE -> {
-                if (c == '>') {
-                    state = STATE_TEXT
-                } else if (c == '/') {
-                    // we expect an '>' next to close the tag
-                } else if (!Character.isWhitespace(c)) {
-                    state = STATE_ATTRIBUTE_NAME
-                }
-                offset++
-            }
-            STATE_ATTRIBUTE_NAME -> {
-                when {
-                    c == '>' -> state = STATE_TEXT
-                    c == '=' -> state = STATE_ATTRIBUTE_AFTER_EQUALS
-                    Character.isWhitespace(c) -> state = STATE_ATTRIBUTE_BEFORE_EQUALS
-                    c == ':' -> {}
-                }
-                offset++
-            }
-            STATE_ATTRIBUTE_BEFORE_EQUALS -> {
-                if (c == '=') {
-                    state = STATE_ATTRIBUTE_AFTER_EQUALS
-                } else if (c == '>') {
-                    state = STATE_TEXT
-                } else if (!Character.isWhitespace(c)) {
-                    // Attribute value not specified (used for some boolean attributes)
-                    state = STATE_ATTRIBUTE_NAME
-                }
-                offset++
-            }
-            STATE_ATTRIBUTE_AFTER_EQUALS -> {
-                if (c == '\'') {
-                    // a='b'
-                    state = STATE_ATTRIBUTE_VALUE_SINGLE
-                } else if (c == '"') {
-                    // a="b"
-                    state = STATE_ATTRIBUTE_VALUE_DOUBLE
-                } else if (!Character.isWhitespace(c)) {
-                    // a=b
-                    state = STATE_ATTRIBUTE_VALUE_NONE
-                }
-                offset++
-            }
-            STATE_ATTRIBUTE_VALUE_SINGLE -> {
-                if (c == '\'') {
-                    state = STATE_BEFORE_ATTRIBUTE
-                }
-                offset++
-            }
-            STATE_ATTRIBUTE_VALUE_DOUBLE -> {
-                if (c == '"') {
-                    state = STATE_BEFORE_ATTRIBUTE
-                }
-                offset++
-            }
-            STATE_ATTRIBUTE_VALUE_NONE -> {
-                if (c == '>') {
-                    state = STATE_TEXT
-                } else if (Character.isWhitespace(c)) {
-                    state = STATE_BEFORE_ATTRIBUTE
-                }
-                offset++
-            }
-            else -> assert(false) { state }
-        }
-    }
-
-    return html
-}
-
 fun containsLinkTags(documentation: String): Boolean {
     var index = 0
     while (true) {
@@ -541,535 +277,3 @@ fun containsLinkTags(documentation: String): Boolean {
         index++
     }
 }
-
-// ------------------------------------------------------------------------------------
-// Expanding javadocs into fully qualified documentation
-// ------------------------------------------------------------------------------------
-
-internal class DocQualifier(private val reporter: Reporter) {
-
-    fun toFullyQualifiedDocumentation(owner: PsiItem, documentation: String): String {
-        if (documentation.isBlank() || !containsLinkTags(documentation)) {
-            return documentation
-        }
-
-        val codebase = owner.codebase
-        val comment =
-            try {
-                codebase.getComment(documentation, owner.psi())
-            } catch (throwable: Throwable) {
-                // TODO: Get rid of line comments as documentation
-                // Invalid comment
-                if (documentation.startsWith("//") && documentation.contains("/**")) {
-                    return toFullyQualifiedDocumentation(
-                        owner,
-                        documentation.substring(documentation.indexOf("/**"))
-                    )
-                }
-                codebase.getComment(documentation, owner.psi())
-            }
-        val sb = StringBuilder(documentation.length)
-        expand(owner, comment, sb)
-
-        return sb.toString()
-    }
-
-    private fun reportUnresolvedDocReference(owner: Item, unresolved: String) {
-        @Suppress("ConstantConditionIf")
-        if (!REPORT_UNRESOLVED_SYMBOLS) {
-            return
-        }
-
-        if (unresolved.startsWith("{@") && !unresolved.startsWith("{@link")) {
-            return
-        }
-
-        // References are sometimes split across lines and therefore have newlines, leading
-        // asterisks
-        // etc in the middle: clean this up before emitting reference into error message
-        val cleaned = unresolved.replace("\n", "").replace("*", "").replace("  ", " ")
-
-        reporter.report(
-            Issues.UNRESOLVED_LINK,
-            owner,
-            "Unresolved documentation reference: $cleaned"
-        )
-    }
-
-    private fun expand(owner: PsiItem, element: PsiElement, sb: StringBuilder) {
-        when {
-            element is PsiWhiteSpace -> {
-                sb.append(element.text)
-            }
-            element is PsiDocToken -> {
-                assert(element.firstChild == null)
-                val text = element.text
-                // Auto-fix some docs in the framework which starts with R.styleable in @attr
-                if (text.startsWith("R.styleable#") && owner.documentation.contains("@attr")) {
-                    sb.append("android.")
-                }
-
-                sb.append(text)
-            }
-            element is PsiDocMethodOrFieldRef -> {
-                val text = element.text
-                var resolved = element.reference?.resolve()
-
-                // Workaround: relative references doesn't work from a class item to its members
-                if (resolved == null && owner is ClassItem) {
-                    // For some reason, resolving relative methods and field references at the root
-                    // level isn't working right.
-                    if (PREPEND_LOCAL_CLASS && text.startsWith("#")) {
-                        var end = text.indexOf('(')
-                        if (end == -1) {
-                            // definitely a field
-                            end = text.length
-                            val fieldName = text.substring(1, end)
-                            val field = owner.findField(fieldName)
-                            if (field != null) {
-                                resolved = (field as? PsiFieldItem)?.psi()
-                            }
-                        }
-                        if (resolved == null) {
-                            val methodName = text.substring(1, end)
-                            resolved =
-                                (owner as PsiClassItem)
-                                    .psi()
-                                    .findMethodsByName(methodName, true)
-                                    .firstOrNull()
-                        }
-                    }
-                }
-
-                if (resolved is PsiMember) {
-                    val containingClass = resolved.containingClass
-                    if (containingClass != null && !samePackage(owner, containingClass)) {
-                        val referenceText = element.reference?.element?.text ?: text
-                        if (!PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
-                            sb.append(text)
-                            return
-                        }
-
-                        var className = containingClass.qualifiedName
-
-                        if (
-                            element.firstChildNode.elementType ===
-                                JavaDocElementType.DOC_REFERENCE_HOLDER
-                        ) {
-                            val firstChildPsi =
-                                SourceTreeToPsiMap.treeElementToPsi(
-                                    element.firstChildNode.firstChildNode
-                                )
-                            if (firstChildPsi is PsiJavaCodeReferenceElement) {
-                                val referenceElement = firstChildPsi as PsiJavaCodeReferenceElement?
-                                val referencedElement = referenceElement!!.resolve()
-                                if (referencedElement is PsiClass) {
-                                    className = referencedElement.qualifiedName
-                                }
-                            }
-                        }
-
-                        sb.append(className)
-                        sb.append('#')
-                        sb.append(resolved.name)
-                        val index = text.indexOf('(')
-                        if (index != -1) {
-                            sb.append(text.substring(index))
-                        }
-                    } else {
-                        sb.append(text)
-                    }
-                } else {
-                    if (resolved == null) {
-                        val referenceText = element.reference?.element?.text ?: text
-                        if (text.startsWith("#") && owner is ClassItem) {
-                            // Unfortunately resolving references is broken from class javadocs
-                            // to members using just a relative reference, #.
-                        } else {
-                            reportUnresolvedDocReference(owner, referenceText)
-                        }
-                    }
-                    sb.append(text)
-                }
-            }
-            element is PsiJavaCodeReferenceElement -> {
-                val resolved = element.resolve()
-                if (resolved is PsiClass) {
-                    if (samePackage(owner, resolved) || resolved is PsiTypeParameter) {
-                        sb.append(element.text)
-                    } else {
-                        sb.append(resolved.qualifiedName)
-                    }
-                } else if (resolved is PsiMember) {
-                    val text = element.text
-                    sb.append(resolved.containingClass?.qualifiedName)
-                    sb.append('#')
-                    sb.append(resolved.name)
-                    val index = text.indexOf('(')
-                    if (index != -1) {
-                        sb.append(text.substring(index))
-                    }
-                } else {
-                    val text = element.text
-                    if (resolved == null) {
-                        reportUnresolvedDocReference(owner, text)
-                    }
-                    sb.append(text)
-                }
-            }
-            element is PsiInlineDocTag -> {
-                val handled = handleTag(element, owner, sb)
-                if (!handled) {
-                    sb.append(element.text)
-                }
-            }
-            element.firstChild != null -> {
-                var curr = element.firstChild
-                while (curr != null) {
-                    expand(owner, curr, sb)
-                    curr = curr.nextSibling
-                }
-            }
-            else -> {
-                val text = element.text
-                sb.append(text)
-            }
-        }
-    }
-
-    fun handleTag(element: PsiInlineDocTag, owner: PsiItem, sb: StringBuilder): Boolean {
-        val name = element.name
-        if (name == "code" || name == "literal") {
-            // @code: don't attempt to rewrite this
-            sb.append(element.text)
-            return true
-        }
-
-        val reference = extractReference(element)
-        val referenceText = reference?.element?.text ?: element.text
-        val customLinkText = extractCustomLinkText(element)
-        val displayText = customLinkText?.text ?: referenceText
-        if (!PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
-            val suffix = element.text
-            if (suffix.contains("(") && suffix.contains(")")) {
-                expandArgumentList(element, suffix, sb)
-            } else {
-                sb.append(suffix)
-            }
-            return true
-        }
-
-        // TODO: If referenceText is already absolute, e.g.
-        // android.Manifest.permission#BIND_CARRIER_SERVICES,
-        // try to short circuit this?
-
-        val valueElement = element.valueElement
-        if (valueElement is CompositePsiElement) {
-            if (
-                valueElement.firstChildNode.elementType === JavaDocElementType.DOC_REFERENCE_HOLDER
-            ) {
-                val firstChildPsi =
-                    SourceTreeToPsiMap.treeElementToPsi(valueElement.firstChildNode.firstChildNode)
-                if (firstChildPsi is PsiJavaCodeReferenceElement) {
-                    val referenceElement = firstChildPsi as PsiJavaCodeReferenceElement?
-                    val referencedElement = referenceElement!!.resolve()
-                    if (referencedElement is PsiClass) {
-                        var className = PsiClassItem.computeFullClassName(referencedElement)
-                        if (className.indexOf('.') != -1 && !referenceText.startsWith(className)) {
-                            val simpleName = referencedElement.name
-                            if (simpleName != null && referenceText.startsWith(simpleName)) {
-                                className = simpleName
-                            }
-                        }
-                        if (referenceText.startsWith(className)) {
-                            sb.append("{@")
-                            sb.append(element.name)
-                            sb.append(' ')
-                            sb.append(referencedElement.qualifiedName)
-                            val suffix = referenceText.substring(className.length)
-                            if (suffix.contains("(") && suffix.contains(")")) {
-                                expandArgumentList(element, suffix, sb)
-                            } else {
-                                sb.append(suffix)
-                            }
-                            sb.append(' ')
-                            sb.append(displayText)
-                            sb.append("}")
-                            return true
-                        }
-                    }
-                }
-            }
-        }
-
-        var resolved = reference?.resolve()
-        if (resolved == null && owner is ClassItem) {
-            // For some reason, resolving relative methods and field references at the root
-            // level isn't working right.
-            if (PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
-                var end = referenceText.indexOf('(')
-                if (end == -1) {
-                    // definitely a field
-                    end = referenceText.length
-                    val fieldName = referenceText.substring(1, end)
-                    val field = owner.findField(fieldName)
-                    if (field != null) {
-                        resolved = (field as? PsiFieldItem)?.psi()
-                    }
-                }
-                if (resolved == null) {
-                    val methodName = referenceText.substring(1, end)
-                    resolved =
-                        (owner as PsiClassItem)
-                            .psi()
-                            .findMethodsByName(methodName, true)
-                            .firstOrNull()
-                }
-            }
-        }
-
-        if (resolved != null) {
-            when (resolved) {
-                is PsiClass -> {
-                    val text = element.text
-                    if (samePackage(owner, resolved)) {
-                        sb.append(text)
-                        return true
-                    }
-                    val qualifiedName =
-                        resolved.qualifiedName
-                            ?: run {
-                                sb.append(text)
-                                return true
-                            }
-                    if (referenceText == qualifiedName) {
-                        // Already absolute
-                        sb.append(text)
-                        return true
-                    }
-                    val append =
-                        when {
-                            valueElement != null -> {
-                                val start = valueElement.startOffsetInParent
-                                val end = start + valueElement.textLength
-                                text.substring(0, start) + qualifiedName + text.substring(end)
-                            }
-                            name == "see" -> {
-                                val suffix =
-                                    text.substring(
-                                        text.indexOf(referenceText) + referenceText.length
-                                    )
-                                "@see $qualifiedName$suffix"
-                            }
-                            text.startsWith("{") -> "{@$name $qualifiedName $displayText}"
-                            else -> "@$name $qualifiedName $displayText"
-                        }
-                    sb.append(append)
-                    return true
-                }
-                is PsiMember -> {
-                    val text = element.text
-                    val containing =
-                        resolved.containingClass
-                            ?: run {
-                                sb.append(text)
-                                return true
-                            }
-                    if (samePackage(owner, containing)) {
-                        sb.append(text)
-                        return true
-                    }
-                    val qualifiedName =
-                        containing.qualifiedName
-                            ?: run {
-                                sb.append(text)
-                                return true
-                            }
-                    if (referenceText.startsWith(qualifiedName)) {
-                        // Already absolute
-                        sb.append(text)
-                        return true
-                    }
-
-                    // It may also be the case that the reference is already fully qualified
-                    // but to some different class. For example, the link may be to
-                    // android.os.Bundle#getInt, but the resolved method actually points to
-                    // an inherited method into android.os.Bundle from android.os.BaseBundle.
-                    // In that case we don't want to rewrite the link.
-                    for (c in referenceText) {
-                        if (c == '.') {
-                            // Already qualified
-                            sb.append(text)
-                            return true
-                        } else if (!Character.isJavaIdentifierPart(c)) {
-                            break
-                        }
-                    }
-
-                    if (valueElement != null) {
-                        val start = valueElement.startOffsetInParent
-
-                        var nameEnd = -1
-                        var close = start
-                        var balance = 0
-                        while (close < text.length) {
-                            val c = text[close]
-                            if (c == '(') {
-                                if (nameEnd == -1) {
-                                    nameEnd = close
-                                }
-                                balance++
-                            } else if (c == ')') {
-                                balance--
-                                if (balance == 0) {
-                                    close++
-                                    break
-                                }
-                            } else if (c == '}') {
-                                if (nameEnd == -1) {
-                                    nameEnd = close
-                                }
-                                break
-                            } else if (balance == 0 && c == '#') {
-                                if (nameEnd == -1) {
-                                    nameEnd = close
-                                }
-                            } else if (balance == 0 && !Character.isJavaIdentifierPart(c)) {
-                                break
-                            }
-                            close++
-                        }
-                        val memberPart = text.substring(nameEnd, close)
-                        val append =
-                            "${text.substring(0, start)}$qualifiedName$memberPart $displayText}"
-                        sb.append(append)
-                        return true
-                    }
-                }
-            }
-        } else {
-            reportUnresolvedDocReference(owner, referenceText)
-        }
-
-        return false
-    }
-
-    private fun expandArgumentList(element: PsiInlineDocTag, suffix: String, sb: StringBuilder) {
-        val elementFactory = JavaPsiFacade.getElementFactory(element.project)
-        // Try to rewrite the types to fully qualified names as well
-        val begin = suffix.indexOf('(')
-        sb.append(suffix.substring(0, begin + 1))
-        var index = begin + 1
-        var balance = 0
-        var argBegin = index
-        while (index < suffix.length) {
-            val c = suffix[index++]
-            if (c == '<' || c == '(') {
-                balance++
-            } else if (c == '>') {
-                balance--
-            } else if (c == ')' && balance == 0 || c == ',') {
-                // Strip off javadoc header
-                while (argBegin < index) {
-                    val p = suffix[argBegin]
-                    if (p != '*' && !p.isWhitespace()) {
-                        break
-                    }
-                    argBegin++
-                }
-                if (index > argBegin + 1) {
-                    val arg = suffix.substring(argBegin, index - 1).trim()
-                    val space = arg.indexOf(' ')
-                    // Strip off parameter name (shouldn't be there but happens
-                    // in some Android sources sine tools didn't use to complain
-                    val typeString =
-                        if (space == -1) {
-                            arg
-                        } else {
-                            if (space < arg.length - 1 && !arg[space + 1].isJavaIdentifierStart()) {
-                                // Example: "String []"
-                                arg
-                            } else {
-                                // Example "String name"
-                                arg.substring(0, space)
-                            }
-                        }
-                    var insert = arg
-                    if (typeString[0].isUpperCase()) {
-                        try {
-                            val type = elementFactory.createTypeFromText(typeString, element)
-                            insert = type.canonicalText
-                        } catch (ignore: com.intellij.util.IncorrectOperationException) {
-                            // Not a valid type - just leave what was in the parameter text
-                        }
-                    }
-                    sb.append(insert)
-                    sb.append(c)
-                    if (c == ')') {
-                        break
-                    }
-                } else if (c == ')') {
-                    sb.append(')')
-                    break
-                }
-                argBegin = index
-            } else if (c == ')') {
-                balance--
-            }
-        }
-        while (index < suffix.length) {
-            sb.append(suffix[index++])
-        }
-    }
-
-    private fun samePackage(owner: PsiItem, cls: PsiClass): Boolean {
-        @Suppress("ConstantConditionIf")
-        if (INCLUDE_SAME_PACKAGE) {
-            // doclava seems to have REAL problems with this
-            return false
-        }
-        val pkg = packageName(owner) ?: return false
-        return cls.qualifiedName == "$pkg.${cls.name}"
-    }
-
-    private fun packageName(owner: PsiItem): String? {
-        var curr: Item? = owner
-        while (curr != null) {
-            if (curr is PackageItem) {
-                return curr.qualifiedName()
-            }
-            curr = curr.parent()
-        }
-
-        return null
-    }
-
-    // Copied from UnnecessaryJavaDocLinkInspection and tweaked a bit
-    private fun extractReference(tag: PsiDocTag): PsiReference? {
-        val valueElement = tag.valueElement
-        if (valueElement != null) {
-            return valueElement.reference
-        }
-        // hack around the fact that a reference to a class is apparently
-        // not a PsiDocTagValue
-        val dataElements = tag.dataElements
-        if (dataElements.isEmpty()) {
-            return null
-        }
-        val salientElement: PsiElement =
-            dataElements.firstOrNull { it !is PsiWhiteSpace && it !is PsiDocToken } ?: return null
-        val child = salientElement.firstChild
-        return if (child !is PsiReference) null else child
-    }
-
-    private fun extractCustomLinkText(tag: PsiDocTag): PsiDocToken? {
-        val dataElements = tag.dataElements
-        if (dataElements.isEmpty()) {
-            return null
-        }
-        val salientElement: PsiElement =
-            dataElements.lastOrNull { it !is PsiWhiteSpace && it !is PsiDocMethodOrFieldRef }
-                ?: return null
-        return if (salientElement !is PsiDocToken) null else salientElement
-    }
-}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
index d33b988dc..c84ed3982 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
@@ -18,14 +18,13 @@ package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.TypeNullability
 import com.intellij.psi.PsiElement
-import org.jetbrains.kotlin.analysis.api.KtAnalysisSession
+import org.jetbrains.kotlin.analysis.api.KaSession
 import org.jetbrains.kotlin.analysis.api.analyze
-import org.jetbrains.kotlin.analysis.api.components.buildClassType
-import org.jetbrains.kotlin.analysis.api.symbols.KtNamedClassOrObjectSymbol
-import org.jetbrains.kotlin.analysis.api.types.KtNonErrorClassType
-import org.jetbrains.kotlin.analysis.api.types.KtType
-import org.jetbrains.kotlin.analysis.api.types.KtTypeNullability
-import org.jetbrains.kotlin.analysis.api.types.KtTypeParameterType
+import org.jetbrains.kotlin.analysis.api.symbols.KaNamedClassSymbol
+import org.jetbrains.kotlin.analysis.api.types.KaClassType
+import org.jetbrains.kotlin.analysis.api.types.KaType
+import org.jetbrains.kotlin.analysis.api.types.KaTypeNullability
+import org.jetbrains.kotlin.analysis.api.types.KaTypeParameterType
 import org.jetbrains.kotlin.psi.KtCallableDeclaration
 import org.jetbrains.kotlin.psi.KtClass
 import org.jetbrains.kotlin.psi.KtElement
@@ -47,46 +46,46 @@ import org.jetbrains.uast.getContainingUMethod
  */
 internal class KotlinTypeInfo
 private constructor(
-    val analysisSession: KtAnalysisSession?,
-    ktType: KtType?,
+    val analysisSession: KaSession?,
+    kaType: KaType?,
     val context: PsiElement,
     /**
      * Override list of type arguments that should have been, but for some reason could not be,
-     * encapsulated within [ktType].
+     * encapsulated within [kaType].
      */
     val overrideTypeArguments: List<KotlinTypeInfo>? = null,
 ) {
     constructor(context: PsiElement) : this(null, null, context)
 
     /** Make sure that any typealiases are fully expanded. */
-    val ktType =
-        analysisSession?.run { ktType?.fullyExpandedType }
-            ?: ktType?.let {
-                error("cannot have non-null ktType ($ktType) with a null analysisSession")
+    val kaType =
+        analysisSession?.run { kaType?.fullyExpandedType }
+            ?: kaType?.let {
+                error("cannot have non-null kaType ($kaType) with a null analysisSession")
             }
 
     override fun toString(): String {
-        return "KotlinTypeInfo($ktType for $context)"
+        return "KotlinTypeInfo(${this@KotlinTypeInfo.kaType} for $context)"
     }
 
     fun copy(
-        ktType: KtType? = this.ktType,
+        kaType: KaType? = this.kaType,
         overrideTypeArguments: List<KotlinTypeInfo>? = this.overrideTypeArguments,
-    ) = KotlinTypeInfo(analysisSession, ktType, context, overrideTypeArguments)
+    ) = KotlinTypeInfo(analysisSession, kaType, context, overrideTypeArguments)
 
     /**
-     * Finds the nullability of the [ktType]. If there is no [analysisSession] or [ktType], defaults
+     * Finds the nullability of the [kaType]. If there is no [analysisSession] or [kaType], defaults
      * to `null` to allow for other sources, like annotations and inferred nullability to take
      * effect.
      */
     fun nullability(): TypeNullability? {
-        return if (analysisSession != null && ktType != null) {
+        return if (analysisSession != null && kaType != null) {
             analysisSession.run {
-                if (analysisSession.isInheritedGenericType(ktType)) {
+                if (useSiteSession.isInheritedGenericType(kaType)) {
                     TypeNullability.UNDEFINED
-                } else if (ktType.nullability == KtTypeNullability.NULLABLE) {
+                } else if (kaType.nullability == KaTypeNullability.NULLABLE) {
                     TypeNullability.NULLABLE
-                } else if (ktType.nullability == KtTypeNullability.NON_NULLABLE) {
+                } else if (kaType.nullability == KaTypeNullability.NON_NULLABLE) {
                     TypeNullability.NONNULL
                 } else {
                     // No nullability information, possibly a propagated platform type.
@@ -99,12 +98,12 @@ private constructor(
     }
 
     /**
-     * Creates [KotlinTypeInfo] for the component type of this [ktType], assuming it is an array.
+     * Creates [KotlinTypeInfo] for the component type of this [kaType], assuming it is an array.
      */
     fun forArrayComponentType(): KotlinTypeInfo {
         return KotlinTypeInfo(
             analysisSession,
-            analysisSession?.run { ktType?.getArrayElementType() },
+            analysisSession?.run { kaType?.arrayElementType },
             context,
         )
     }
@@ -120,8 +119,8 @@ private constructor(
         return KotlinTypeInfo(
             analysisSession,
             analysisSession?.run {
-                when (ktType) {
-                    is KtNonErrorClassType -> ktType.ownTypeArguments.getOrNull(index)?.type
+                when (kaType) {
+                    is KaClassType -> kaType.typeArguments.getOrNull(index)?.type
                     else -> null
                 }
             },
@@ -130,16 +129,16 @@ private constructor(
     }
 
     /**
-     * Creates [KotlinTypeInfo] for the outer class type of this [ktType], assuming it is a class.
+     * Creates [KotlinTypeInfo] for the outer class type of this [kaType], assuming it is a class.
      */
     fun forOuterClass(): KotlinTypeInfo {
         return KotlinTypeInfo(
             analysisSession,
             analysisSession?.run {
-                (ktType as? KtNonErrorClassType)?.classId?.outerClassId?.let { outerClassId ->
+                (kaType as? KaClassType)?.classId?.outerClassId?.let { outerClassId ->
                     buildClassType(outerClassId) {
                         // Add the parameters of the class type with nullability information.
-                        ktType.qualifiers
+                        kaType.qualifiers
                             .firstOrNull { it.name == outerClassId.shortClassName }
                             ?.typeArguments
                             ?.forEach { argument(it) }
@@ -151,7 +150,7 @@ private constructor(
     }
 
     /** Get a [KotlinTypeInfo] that represents a suspend function's `Continuation` parameter. */
-    fun forSyntheticContinuationParameter(returnType: KtType): KotlinTypeInfo {
+    fun forSyntheticContinuationParameter(returnType: KaType): KotlinTypeInfo {
         // This cast is safe as this will only be called for a lambda function whose context will
         // be [KtFunction].
         val ktElement = context as KtElement
@@ -163,7 +162,7 @@ private constructor(
         // This cast is safe as this will only be called for a lambda function whose context will
         // be [KtFunction].
         val ktElement = context as KtElement
-        return analyze(ktElement) { KotlinTypeInfo(this, builtinTypes.NULLABLE_ANY, context) }
+        return analyze(ktElement) { KotlinTypeInfo(this, builtinTypes.nullableAny, context) }
     }
 
     companion object {
@@ -200,10 +199,10 @@ private constructor(
                             when {
                                 // If the context is the backing field then use the type of the
                                 // delegate, if any.
-                                context is UField -> ktElement.delegateExpression?.getKtType()
+                                context is UField -> ktElement.delegateExpression?.expressionType
                                 else -> null
                             }
-                                ?: ktElement.getReturnKtType()
+                                ?: ktElement.returnType
                         KotlinTypeInfo(this, ktType, ktElement)
                     }
                 }
@@ -213,26 +212,24 @@ private constructor(
                             if (ktElement is KtFunction && ktElement.isSuspend()) {
                                 // A suspend function is transformed by Kotlin to return Any?
                                 // instead of its actual return type.
-                                builtinTypes.NULLABLE_ANY
+                                builtinTypes.nullableAny
                             } else {
-                                ktElement.getReturnKtType()
+                                ktElement.returnType
                             }
                         KotlinTypeInfo(this, ktType, ktElement)
                     }
                 }
                 is KtTypeReference ->
-                    analyze(ktElement) { KotlinTypeInfo(this, ktElement.getKtType(), ktElement) }
+                    analyze(ktElement) { KotlinTypeInfo(this, ktElement.type, ktElement) }
                 is KtPropertyAccessor ->
-                    analyze(ktElement) {
-                        KotlinTypeInfo(this, ktElement.getReturnKtType(), ktElement)
-                    }
+                    analyze(ktElement) { KotlinTypeInfo(this, ktElement.returnType, ktElement) }
                 is KtClass -> {
                     analyze(ktElement) {
                         // If this is a named class or object then return a KotlinTypeInfo for the
                         // class. If it is generic then the type parameters will be used as the
                         // type arguments.
-                        (ktElement.getSymbol() as? KtNamedClassOrObjectSymbol)?.let { symbol ->
-                            KotlinTypeInfo(this, symbol.buildSelfClassType(), ktElement)
+                        (ktElement.symbol as? KaNamedClassSymbol)?.let { symbol ->
+                            KotlinTypeInfo(this, symbol.defaultType, ktElement)
                         }
                     }
                 }
@@ -283,7 +280,7 @@ private constructor(
                         // Compute the [KotlinTypeInfo] for the suspend function's synthetic
                         // [kotlin.coroutines.Continuation] parameter.
                         analyze(sourcePsi) {
-                            val returnKtType = sourcePsi.getReturnKtType()
+                            val returnKtType = sourcePsi.returnType
                             syntheticContinuationParameter(sourcePsi, returnKtType)
                         }
                     } else null
@@ -316,12 +313,12 @@ private constructor(
          * and stores the suspend function's return type in [KotlinTypeInfo.overrideTypeArguments]
          * from where it will be retrieved.
          */
-        internal fun KtAnalysisSession.syntheticContinuationParameter(
+        internal fun KaSession.syntheticContinuationParameter(
             context: PsiElement,
-            returnKtType: KtType
+            returnKtType: KaType
         ): KotlinTypeInfo {
             val returnTypeInfo = KotlinTypeInfo(this, returnKtType, context)
-            val fakeContinuationKtType = builtinTypes.ANY
+            val fakeContinuationKtType = builtinTypes.any
             return KotlinTypeInfo(this, fakeContinuationKtType, context, listOf(returnTypeInfo))
         }
 
@@ -341,7 +338,7 @@ private constructor(
                         analyze(ktParameter) {
                             KotlinTypeInfo(
                                 this,
-                                ktParameter.getReturnKtType(),
+                                ktParameter.returnType,
                                 ktParameter,
                             )
                         }
@@ -351,8 +348,8 @@ private constructor(
             }
 
         // Mimic `hasInheritedGenericType` in `...uast.kotlin.FirKotlinUastResolveProviderService`
-        fun KtAnalysisSession.isInheritedGenericType(ktType: KtType): Boolean {
-            return ktType is KtTypeParameterType &&
+        fun KaSession.isInheritedGenericType(ktType: KaType): Boolean {
+            return ktType is KaTypeParameterType &&
                 // explicitly nullable, e.g., T?
                 !ktType.isMarkedNullable &&
                 // non-null upper bound, e.g., T : Any
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
index 868a26810..d09ae4bdc 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
@@ -22,7 +22,7 @@ import com.android.tools.metalava.model.AnnotationAttribute
 import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationTarget
-import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
 import com.android.tools.metalava.model.DefaultAnnotationAttribute
 import com.android.tools.metalava.model.DefaultAnnotationItem
@@ -45,16 +45,19 @@ import com.intellij.psi.PsiReference
 import com.intellij.psi.impl.JavaConstantExpressionEvaluator
 import org.jetbrains.kotlin.asJava.elements.KtLightNullabilityAnnotation
 
-class PsiAnnotationItem
+internal class PsiAnnotationItem
 private constructor(
     override val codebase: PsiBasedCodebase,
     val psiAnnotation: PsiAnnotation,
-    originalName: String?
+    originalName: String,
+    qualifiedName: String,
 ) :
     DefaultAnnotationItem(
-        codebase,
-        originalName,
-        { getAnnotationAttributes(codebase, psiAnnotation) }
+        codebase = codebase,
+        fileLocation = PsiFileLocation.fromPsiElement(psiAnnotation),
+        originalName = originalName,
+        qualifiedName = qualifiedName,
+        attributesGetter = { getAnnotationAttributes(codebase, psiAnnotation) },
     ) {
 
     override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
@@ -63,9 +66,7 @@ private constructor(
         return sb.toString()
     }
 
-    override fun resolve(): ClassItem? {
-        return codebase.findOrCreateClass(originalName ?: return null)
-    }
+    override fun snapshot(targetCodebase: Codebase) = this
 
     override fun isNonNull(): Boolean {
         if (psiAnnotation is KtLightNullabilityAnnotation<*> && originalName == "") {
@@ -76,7 +77,7 @@ private constructor(
     }
 
     override val targets: Set<AnnotationTarget> by lazy {
-        codebase.annotationManager.computeTargets(this, codebase::findOrCreateClass)
+        codebase.annotationManager.computeTargets(this, codebase::resolveClass)
     }
 
     companion object {
@@ -98,9 +99,16 @@ private constructor(
         fun create(
             codebase: PsiBasedCodebase,
             psiAnnotation: PsiAnnotation,
-            qualifiedName: String? = psiAnnotation.qualifiedName
-        ): AnnotationItem {
-            return PsiAnnotationItem(codebase, psiAnnotation, qualifiedName)
+        ): AnnotationItem? {
+            val originalName = psiAnnotation.qualifiedName ?: return null
+            val qualifiedName =
+                codebase.annotationManager.normalizeInputName(originalName) ?: return null
+            return PsiAnnotationItem(
+                codebase = codebase,
+                psiAnnotation = psiAnnotation,
+                originalName = originalName,
+                qualifiedName = qualifiedName,
+            )
         }
 
         private fun getAttributes(
@@ -321,7 +329,7 @@ private fun createValue(
     }
 }
 
-class PsiAnnotationSingleAttributeValue(
+internal class PsiAnnotationSingleAttributeValue(
     private val codebase: PsiBasedCodebase,
     private val psiValue: PsiAnnotationMemberValue
 ) : DefaultAnnotationSingleAttributeValue({ psiValue.text }, { getValue(psiValue) }) {
@@ -352,7 +360,7 @@ class PsiAnnotationSingleAttributeValue(
             when (val resolved = psiValue.resolve()) {
                 is PsiField -> return codebase.findField(resolved)
                 is PsiClass -> return codebase.findOrCreateClass(resolved)
-                is PsiMethod -> return codebase.findMethod(resolved)
+                is PsiMethod -> return codebase.findCallableByPsiMethod(resolved)
             }
         }
         return null
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
index 2e3f7e546..a71e794a9 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
@@ -20,6 +20,7 @@ import com.android.tools.lint.UastEnvironment
 import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.reporter.Reporter
 import com.intellij.psi.JavaPsiFacade
 import com.intellij.psi.search.GlobalSearchScope
@@ -41,17 +42,20 @@ internal class PsiBasedClassResolver(
         javaPsiFacade = JavaPsiFacade.getInstance(project)
         searchScope = GlobalSearchScope.everythingScope(project)
 
-        classpathCodebase =
-            PsiBasedCodebase(
-                location = File("classpath"),
-                description = "Codebase from classpath",
-                annotationManager = annotationManager,
-                reporter = reporter,
-                fromClasspath = true,
-                allowReadingComments = allowReadingComments,
-            )
-        val emptyPackageDocs = PackageDocs(mutableMapOf(), mutableMapOf(), mutableSetOf())
-        classpathCodebase.initializeFromSources(uastEnvironment, emptyList(), emptyPackageDocs)
+        val assembler =
+            PsiCodebaseAssembler(uastEnvironment) { assembler ->
+                PsiBasedCodebase(
+                    location = File("classpath"),
+                    description = "Codebase from classpath",
+                    annotationManager = annotationManager,
+                    reporter = reporter,
+                    fromClasspath = true,
+                    allowReadingComments = allowReadingComments,
+                    assembler = assembler,
+                )
+            }
+        assembler.initializeFromSources(SourceSet.empty())
+        classpathCodebase = assembler.codebase
     }
 
     override fun resolveClass(erasedName: String): ClassItem? {
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
index 155f4fcbd..58d5b46d9 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
@@ -16,792 +16,109 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.SdkConstants
-import com.android.tools.lint.UastEnvironment
-import com.android.tools.metalava.model.ANDROIDX_NONNULL
-import com.android.tools.metalava.model.ANDROIDX_NULLABLE
-import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationManager
-import com.android.tools.metalava.model.CLASS_ESTIMATE
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultCodebase
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PackageList
-import com.android.tools.metalava.model.TypeParameterScope
-import com.android.tools.metalava.model.source.SourceCodebase
-import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.model.MutableCodebase
+import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.reporter.Reporter
-import com.intellij.openapi.application.ApplicationManager
 import com.intellij.openapi.project.Project
-import com.intellij.psi.JavaPsiFacade
-import com.intellij.psi.JavaRecursiveElementVisitor
-import com.intellij.psi.PsiAnnotation
-import com.intellij.psi.PsiArrayType
 import com.intellij.psi.PsiClass
-import com.intellij.psi.PsiClassOwner
-import com.intellij.psi.PsiClassType
-import com.intellij.psi.PsiCodeBlock
-import com.intellij.psi.PsiElement
-import com.intellij.psi.PsiErrorElement
 import com.intellij.psi.PsiField
-import com.intellij.psi.PsiFile
-import com.intellij.psi.PsiImportStatement
-import com.intellij.psi.PsiJavaFile
 import com.intellij.psi.PsiMethod
-import com.intellij.psi.PsiPackage
-import com.intellij.psi.PsiSubstitutor
-import com.intellij.psi.PsiType
-import com.intellij.psi.PsiTypeParameter
-import com.intellij.psi.TypeAnnotationProvider
-import com.intellij.psi.javadoc.PsiDocComment
-import com.intellij.psi.search.GlobalSearchScope
-import com.intellij.psi.util.PsiTreeUtil
 import java.io.File
-import java.io.IOException
-import java.util.zip.ZipFile
-import org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade
-import org.jetbrains.kotlin.name.FqName
-import org.jetbrains.uast.UClass
-import org.jetbrains.uast.UFile
 import org.jetbrains.uast.UMethod
-import org.jetbrains.uast.UastFacade
-import org.jetbrains.uast.kotlin.BaseKotlinUastResolveProviderService
 
-const val PACKAGE_ESTIMATE = 500
 const val METHOD_ESTIMATE = 1000
 
 /**
  * A codebase containing Java, Kotlin, or UAST PSI classes
  *
- * After creation, a list of PSI file is passed to [initializeFromSources] or a JAR file is passed
- * to [initializeFromJar]. This creates package and class items along with their members. This
- * process is broken into two phases:
+ * After creation, a list of PSI file is passed to [PsiCodebaseAssembler.initializeFromSources] or a
+ * JAR file is passed to [PsiCodebaseAssembler.initializeFromJar]. This creates package and class
+ * items along with their members. Any classes defined in those files will have [ClassItem.origin]
+ * set based on [fromClasspath].
  *
- * First, [initializing] is set to true, and class items are created from the supplied sources. If
- * [fromClasspath] is false, these are main classes of the codebase and have [ClassItem.emit] set to
- * true and [ClassItem.isFromClassPath] set to false. While creating these, package names are
- * reserved and associated with their classes in [packageClasses].
- *
- * If [fromClasspath] is true, all classes are assumed to be from the classpath, so [ClassItem.emit]
- * is set to false and [ClassItem.isFromClassPath] is set to true for all classes created.
- *
- * Next, package items are created for source classes based on the contents of [packageClasses] with
- * [PackageItem.emit] set to true.
- *
- * Then [initializing] is set to false and the second pass begins. This path iteratively resolves
- * supertypes of class items until all are fully resolved, creating new class and package items as
- * needed. Since all the source class and package items have been created, new items are assumed to
- * originate from the classpath and have [Item.emit] set to false and [Item.isFromClassPath] set to
- * true.
+ * Classes that are created through [findOrCreateClass] will have [ClassItem.origin] set to
+ * [ClassOrigin.SOURCE_PATH] or [ClassOrigin.CLASS_PATH] depending on whether the class is defined
+ * on the source path or on the class path respectively.
  */
-open class PsiBasedCodebase(
+internal class PsiBasedCodebase(
     location: File,
     description: String = "Unknown",
     annotationManager: AnnotationManager,
-    private val reporter: Reporter,
+    override val reporter: Reporter,
     val allowReadingComments: Boolean,
     val fromClasspath: Boolean = false,
-) : DefaultCodebase(location, description, false, annotationManager), SourceCodebase {
-    private lateinit var uastEnvironment: UastEnvironment
-    internal val project: Project
-        get() = uastEnvironment.ideaProject
+    assembler: PsiCodebaseAssembler,
+) :
+    DefaultCodebase(
+        location = location,
+        description = description,
+        preFiltered = false,
+        annotationManager = annotationManager,
+        trustedApi = false,
+        supportsDocumentation = true,
+        assembler = assembler,
+    ),
+    MutableCodebase {
+
+    internal val psiAssembler = assembler
 
-    /**
-     * Returns the compilation units used in this codebase (may be empty when the codebase is not
-     * loaded from source, such as from .jar files or from signature files)
-     */
-    private var units: List<PsiFile> = emptyList()
+    internal val project: Project
+        get() = psiAssembler.project
 
     /**
      * Printer which can convert PSI, UAST and constants into source code, with ability to filter
      * out elements that are not part of a codebase etc
      */
-    @Suppress("LeakingThis") internal val printer = CodePrinter(this, reporter)
-
-    /** Supports fully qualifying Javadoc. */
-    internal val docQualifier = DocQualifier(reporter)
-
-    /** Map from class name to class item. Classes are added via [registerClass] */
-    private val classMap: MutableMap<String, PsiClassItem> = HashMap(CLASS_ESTIMATE)
-
-    /**
-     * Map from classes to the set of methods for each (but only for classes where we've called
-     * [findMethod]
-     */
-    private lateinit var methodMap: MutableMap<PsiClassItem, MutableMap<PsiMethod, PsiMethodItem>>
-
-    /** Map from package name to the corresponding package item */
-    private lateinit var packageMap: MutableMap<String, PsiPackageItem>
-
-    /**
-     * Map from package name to list of classes in that package. Initialized in [initializeFromJar]
-     * and [initializeFromSources], updated by [registerPackageClass], and used and cleared in
-     * [fixUpTypeNullability].
-     */
-    private var packageClasses: MutableMap<String, MutableList<PsiClassItem>>? = null
-
-    /** A set of packages to hide */
-    private lateinit var hiddenPackages: MutableMap<String, Boolean?>
+    internal val printer = CodePrinter(this, reporter)
 
     /**
-     * A list of the top-level classes declared in the codebase's source (rather than on its
-     * classpath).
+     * Map from classes to the set of callables for each (but only for classes where we've called
+     * [findCallableByPsiMethod]
      */
-    private lateinit var topLevelClassesFromSource: MutableList<PsiClassItem>
-
-    /**
-     * Set to true in [initializeFromJar] and [initializeFromSources] for the first pass of creating
-     * class items for all classes in the codebase sources and false for the second pass of creating
-     * class items for the supertypes of the codebase classes. New class items created in the
-     * supertypes pass must come from the classpath (dependencies) since all source classes have
-     * been created.
-     *
-     * This information is used in [createClass] to set [ClassItem.emit] to true for source classes
-     * and [ClassItem.isFromClassPath] to true for classpath classes. It is also used in
-     * [registerPackage] to set [PackageItem.emit] to true for source packages.
-     */
-    private var initializing = false
-
-    private var hideClassesFromJars = true
+    private val methodMap: MutableMap<ClassItem, MutableMap<PsiMethod, PsiCallableItem>> =
+        HashMap(METHOD_ESTIMATE)
 
     /** [PsiTypeItemFactory] used to create [PsiTypeItem]s. */
-    internal val globalTypeItemFactory = PsiTypeItemFactory(this, TypeParameterScope.empty)
-
-    private lateinit var emptyPackage: PsiPackageItem
-
-    internal fun initializeFromSources(
-        uastEnvironment: UastEnvironment,
-        psiFiles: List<PsiFile>,
-        packages: PackageDocs,
-    ) {
-        initializing = true
-        this.units = psiFiles
-
-        this.uastEnvironment = uastEnvironment
-        // there are currently ~230 packages in the public SDK, but here we need to account for
-        // internal ones too
-        val hiddenPackages: MutableSet<String> = packages.hiddenPackages
-        val packageDocs = packages.packageDocs
-        this.hiddenPackages = HashMap(100)
-        for (pkgName in hiddenPackages) {
-            this.hiddenPackages[pkgName] = true
-        }
-
-        packageMap = HashMap(PACKAGE_ESTIMATE)
-        packageClasses = HashMap(PACKAGE_ESTIMATE)
-        packageClasses!![""] = ArrayList()
-        this.methodMap = HashMap(METHOD_ESTIMATE)
-        topLevelClassesFromSource = ArrayList(CLASS_ESTIMATE)
-
-        // A set to track @JvmMultifileClasses that have already been added to
-        // [topLevelClassesFromSource]
-        val multifileClassNames = HashSet<FqName>()
-
-        // Make sure we only process the files once; sometimes there's overlap in the source lists
-        for (psiFile in psiFiles.asSequence().distinct()) {
-            // Visiting psiFile directly would eagerly load the entire file even though we only need
-            // the importList here.
-            (psiFile as? PsiJavaFile)
-                ?.importList
-                ?.accept(
-                    object : JavaRecursiveElementVisitor() {
-                        override fun visitImportStatement(element: PsiImportStatement) {
-                            super.visitImportStatement(element)
-                            if (element.resolve() == null) {
-                                reporter.report(
-                                    Issues.UNRESOLVED_IMPORT,
-                                    element,
-                                    "Unresolved import: `${element.qualifiedName}`"
-                                )
-                            }
-                        }
-                    }
-                )
-
-            var classes = (psiFile as? PsiClassOwner)?.classes?.toList() ?: emptyList()
-            if (classes.isEmpty()) {
-                val uFile =
-                    UastFacade.convertElementWithParent(psiFile, UFile::class.java) as? UFile?
-                classes = uFile?.classes?.map { it }?.toList() ?: emptyList()
-            }
-            when {
-                classes.isEmpty() && psiFile is PsiJavaFile -> {
-                    // package-info.java ?
-                    val packageStatement = psiFile.packageStatement
-                    // Look for javadoc on the package statement; this is NOT handed to us on
-                    // the PsiPackage!
-                    if (packageStatement != null) {
-                        val comment =
-                            PsiTreeUtil.getPrevSiblingOfType(
-                                packageStatement,
-                                PsiDocComment::class.java
-                            )
-                        if (comment != null) {
-                            val packageName = packageStatement.packageName
-                            val text = comment.text
-                            if (text.contains("@hide")) {
-                                this.hiddenPackages[packageName] = true
-                            }
-                            if (packageDocs[packageName] != null) {
-                                reporter.report(
-                                    Issues.BOTH_PACKAGE_INFO_AND_HTML,
-                                    psiFile,
-                                    "It is illegal to provide both a package-info.java file and " +
-                                        "a package.html file for the same package"
-                                )
-                            }
-                            packageDocs[packageName] = text
-                        }
-                    }
-                }
-                else -> {
-                    for (psiClass in classes) {
-                        psiClass.accept(
-                            object : JavaRecursiveElementVisitor() {
-                                override fun visitErrorElement(element: PsiErrorElement) {
-                                    super.visitErrorElement(element)
-                                    reporter.report(
-                                        Issues.INVALID_SYNTAX,
-                                        element,
-                                        "Syntax error: `${element.errorDescription}`"
-                                    )
-                                }
-
-                                override fun visitCodeBlock(block: PsiCodeBlock) {
-                                    // Ignore to avoid eagerly parsing all method bodies.
-                                }
-
-                                override fun visitDocComment(comment: PsiDocComment) {
-                                    // Ignore to avoid eagerly parsing all doc comments.
-                                    // Doc comments cannot contain error elements.
-                                }
-                            }
-                        )
-
-                        // Multifile classes appear identically from each file they're defined in,
-                        // don't add duplicates
-                        val ktLightClass = (psiClass as? UClass)?.javaPsi as? KtLightClassForFacade
-                        if (ktLightClass?.multiFileClass == true) {
-                            if (multifileClassNames.contains(ktLightClass.facadeClassFqName)) {
-                                continue
-                            } else {
-                                multifileClassNames.add(ktLightClass.facadeClassFqName)
-                            }
-                        }
-                        topLevelClassesFromSource += createTopLevelClassAndContents(psiClass)
-                    }
-                }
-            }
-        }
-
-        finishInitialization(packages)
-    }
-
-    /**
-     * Finish initializing a [PsiClassItem].
-     *
-     * This must only be called when [initializing] is `false`.
-     */
-    private fun finishClassInitialization(classItem: PsiClassItem) {
-        if (initializing) {
-            error("incorrectly called on $classItem when initializing=`true`")
-        }
-
-        val pkgName = getPackageName(classItem.psiClass)
-        val pkg = findPackage(pkgName)
-        if (pkg == null) {
-            val psiPackage = findPsiPackage(pkgName)
-            if (psiPackage != null) {
-                val packageItem = registerPackage(pkgName, psiPackage, null)
-                packageItem.addClass(classItem)
-            }
-        } else {
-            pkg.addClass(classItem)
-        }
-    }
-
-    /**
-     * Finish initialising this codebase.
-     *
-     * Involves:
-     * * Constructing packages, setting [emptyPackage].
-     * * Finalizing [PsiClassItem]s which may involve creating some more, e.g. super classes and
-     *   interfaces referenced from the source code but provided on the class path.
-     */
-    private fun finishInitialization(packages: PackageDocs?) {
-
-        // Next construct packages
-        val packageDocs = packages?.packageDocs ?: emptyMap()
-        val overviewDocs = packages?.overviewDocs ?: emptyMap()
-        for ((pkgName, classes) in packageClasses!!) {
-            val psiPackage = findPsiPackage(pkgName)
-            if (psiPackage == null) {
-                println("Could not find package $pkgName")
-                continue
-            }
-
-            val sortedClasses = classes.toMutableList().sortedWith(ClassItem.fullNameComparator)
-            registerPackage(
-                pkgName,
-                psiPackage,
-                sortedClasses,
-                packageDocs[pkgName],
-                overviewDocs[pkgName],
-            )
-        }
-
-        // Not used after this point.
-        packageClasses = null
-
-        initializing = false
-
-        emptyPackage = findPackage("")!!
-
-        // Resolve the super types of all the classes that have been loaded.
-        resolveSuperTypes()
-
-        // Point to "parent" packages, since doclava treats packages as nested (e.g. an @hide on
-        // android.foo will also apply to android.foo.bar)
-        addParentPackages(packageMap.values)
-    }
+    internal val globalTypeItemFactory
+        get() = psiAssembler.globalTypeItemFactory
 
     override fun dispose() {
-        uastEnvironment.dispose()
+        psiAssembler.dispose()
         super.dispose()
     }
 
-    private fun addParentPackages(packages: Collection<PsiPackageItem>) {
-        val missingPackages =
-            packages
-                .mapNotNull {
-                    val name = it.qualifiedName()
-                    val index = name.lastIndexOf('.')
-                    val parent =
-                        if (index != -1) {
-                            name.substring(0, index)
-                        } else {
-                            ""
-                        }
-                    if (packageMap.containsKey(parent)) {
-                        // Already registered
-                        null
-                    } else {
-                        parent
-                    }
-                }
-                .toSet()
-
-        // Create PackageItems for any packages that weren't in the source
-        for (pkgName in missingPackages) {
-            val psiPackage = findPsiPackage(pkgName) ?: continue
-            val sortedClasses = emptyList<PsiClassItem>()
-            registerPackage(pkgName, psiPackage, sortedClasses)
-        }
-
-        // Connect up all the package items
-        for (pkg in packageMap.values) {
-            var name = pkg.qualifiedName()
-            // Find parent package; we have to loop since we don't always find a PSI package
-            // for intermediate elements; e.g. we may jump from java.lang straight up to the default
-            // package
-            while (name.isNotEmpty()) {
-                val index = name.lastIndexOf('.')
-                name =
-                    if (index != -1) {
-                        name.substring(0, index)
-                    } else {
-                        ""
-                    }
-                val parent = findPackage(name) ?: continue
-                pkg.containingPackageField = parent
-                break
-            }
-        }
-    }
-
-    private fun registerPackage(
-        pkgName: String,
-        psiPackage: PsiPackage,
-        sortedClasses: List<PsiClassItem>?,
-        packageHtml: String? = null,
-        overviewHtml: String? = null,
-    ): PsiPackageItem {
-        val packageItem =
-            PsiPackageItem.create(
-                this,
-                psiPackage,
-                packageHtml,
-                overviewHtml,
-                fromClassPath = fromClasspath || !initializing
-            )
-        packageItem.emit = !packageItem.isFromClassPath()
-
-        packageMap[pkgName] = packageItem
-        if (isPackageHidden(pkgName)) {
-            packageItem.hidden = true
-        }
-
-        sortedClasses?.let { packageItem.addClasses(it) }
-        return packageItem
-    }
-
-    internal fun initializeFromJar(
-        uastEnvironment: UastEnvironment,
-        jarFile: File,
-    ) {
-        initializing = true
-        hideClassesFromJars = false
-
-        this.uastEnvironment = uastEnvironment
-
-        // Find all classes referenced from the class
-        val facade = JavaPsiFacade.getInstance(project)
-        val scope = GlobalSearchScope.allScope(project)
-
-        hiddenPackages = HashMap(100)
-        packageMap = HashMap(PACKAGE_ESTIMATE)
-        packageClasses = HashMap(PACKAGE_ESTIMATE)
-        packageClasses!![""] = ArrayList()
-        this.methodMap = HashMap(1000)
-        val packageToClasses: MutableMap<String, MutableList<PsiClassItem>> =
-            HashMap(PACKAGE_ESTIMATE)
-        packageToClasses[""] = ArrayList() // ensure we construct one for the default package
-
-        topLevelClassesFromSource = ArrayList(CLASS_ESTIMATE)
-
-        try {
-            ZipFile(jarFile).use { jar ->
-                val enumeration = jar.entries()
-                while (enumeration.hasMoreElements()) {
-                    val entry = enumeration.nextElement()
-                    val fileName = entry.name
-                    if (fileName.contains("$")) {
-                        // skip inner classes
-                        continue
-                    }
-                    if (fileName.endsWith(SdkConstants.DOT_CLASS)) {
-                        val qualifiedName =
-                            fileName.removeSuffix(SdkConstants.DOT_CLASS).replace('/', '.')
-                        if (qualifiedName.endsWith(".package-info")) {
-                            // Ensure we register a package for this, even if empty
-                            val packageName = qualifiedName.removeSuffix(".package-info")
-                            var list = packageToClasses[packageName]
-                            if (list == null) {
-                                list = mutableListOf()
-                                packageToClasses[packageName] = list
-                            }
-                            continue
-                        } else {
-                            val psiClass = facade.findClass(qualifiedName, scope) ?: continue
-
-                            val classItem = createTopLevelClassAndContents(psiClass)
-                            topLevelClassesFromSource.add(classItem)
-
-                            val packageName = getPackageName(psiClass)
-                            var list = packageToClasses[packageName]
-                            if (list == null) {
-                                list = mutableListOf(classItem)
-                                packageToClasses[packageName] = list
-                            } else {
-                                list.add(classItem)
-                            }
-                        }
-                    }
-                }
-            }
-        } catch (e: IOException) {
-            reporter.report(Issues.IO_ERROR, jarFile, e.message ?: e.toString())
-        }
-
-        hideClassesFromJars = true
-
-        // When loading from a jar there is no package documentation.
-        finishInitialization(null)
-    }
-
-    private fun registerPackageClass(packageName: String, cls: PsiClassItem) {
-        var list = packageClasses!![packageName]
-        if (list == null) {
-            list = ArrayList()
-            packageClasses!![packageName] = list
-        }
-
-        list.add(cls)
-    }
-
-    private fun isPackageHidden(packageName: String): Boolean {
-        val hidden = hiddenPackages[packageName]
-        if (hidden == true) {
-            return true
-        } else if (hidden == null) {
-            // Compute for all prefixes of this package
-            var pkg = packageName
-            while (true) {
-                if (hiddenPackages[pkg] != null) {
-                    hiddenPackages[packageName] = hiddenPackages[pkg]
-                    if (hiddenPackages[pkg] == true) {
-                        return true
-                    }
-                }
-                val last = pkg.lastIndexOf('.')
-                if (last == -1) {
-                    hiddenPackages[packageName] = false
-                    break
-                } else {
-                    pkg = pkg.substring(0, last)
-                }
-            }
-        }
-
-        return false
-    }
-
-    /**
-     * Create top level classes, their inner classes and all the other members.
-     *
-     * All the classes are registered by name and so can be found by [findOrCreateClass].
-     */
-    private fun createTopLevelClassAndContents(psiClass: PsiClass): PsiClassItem {
-        if (psiClass.containingClass != null) error("$psiClass is not a top level class")
-        return createClass(psiClass, null, globalTypeItemFactory)
-    }
-
-    internal fun createClass(
-        psiClass: PsiClass,
-        containingClassItem: PsiClassItem?,
-        enclosingClassTypeItemFactory: PsiTypeItemFactory,
-    ): PsiClassItem {
-        // If initializing is true, this class is from source
-        val classItem =
-            PsiClassItem.create(
-                this,
-                psiClass,
-                containingClassItem,
-                enclosingClassTypeItemFactory,
-                fromClassPath = fromClasspath || !initializing,
-            )
-        // Set emit to true for source classes but false for classpath classes
-        classItem.emit = !classItem.isFromClassPath()
-
-        if (!initializing) {
-            // Workaround: we're pulling in .aidl files from .jar files. These are
-            // marked @hide, but since we only see the .class files we don't know that.
-            if (
-                classItem.simpleName().startsWith("I") &&
-                    classItem.isFromClassPath() &&
-                    psiClass.interfaces.any { it.qualifiedName == "android.os.IInterface" }
-            ) {
-                classItem.hidden = true
-            }
-        }
-
-        if (initializing) {
-            // If initializing then keep track of the class in [packageClasses]. This is not needed
-            // after initializing as [packageClasses] is not needed then.
-            // TODO: Cache for adjacent files!
-            val packageName = getPackageName(psiClass)
-            registerPackageClass(packageName, classItem)
-        }
-
-        return classItem
-    }
-
-    override fun getPackages(): PackageList {
-        // TODO: Sorting is probably not necessary here!
-        return PackageList(
-            this,
-            packageMap.values.toMutableList().sortedWith(PackageItem.comparator)
-        )
-    }
-
-    override fun size(): Int {
-        return packageMap.size
-    }
-
-    override fun findPackage(pkgName: String): PsiPackageItem? {
-        return packageMap[pkgName]
-    }
-
-    internal fun findPsiPackage(pkgName: String): PsiPackage? {
-        return JavaPsiFacade.getInstance(project).findPackage(pkgName)
-    }
-
-    override fun findClass(className: String): PsiClassItem? {
-        return classMap[className]
-    }
-
-    override fun resolveClass(className: String): ClassItem? = findOrCreateClass(className)
-
-    open fun findClass(psiClass: PsiClass): PsiClassItem? {
-        val qualifiedName: String = psiClass.qualifiedName ?: psiClass.name!!
-        return classMap[qualifiedName]
-    }
-
-    internal fun findOrCreateClass(qualifiedName: String): PsiClassItem? {
-        // Check to see if the class has already been seen and if so return it immediately.
-        findClass(qualifiedName)?.let {
-            return it
-        }
-
-        // The following cannot find a class whose name does not correspond to the file name, e.g.
-        // in Java a class that is a second top level class.
-        val finder = JavaPsiFacade.getInstance(project)
-        val psiClass =
-            finder.findClass(qualifiedName, GlobalSearchScope.allScope(project)) ?: return null
-        return findOrCreateClass(psiClass)
-    }
-
-    /**
-     * Identifies a point in the [PsiClassItem] nesting structure where new [PsiClassItem]s need
-     * inserting.
-     */
-    data class NewClassInsertionPoint(
-        /**
-         * The [PsiClass] that is the root of the nested classes that need creation, is a top level
-         * class if [containingClassItem] is `null`.
-         */
-        val missingPsiClass: PsiClass,
-
-        /** The containing class item, or `null` if the top level. */
-        val containingClassItem: PsiClassItem?,
-    )
-
-    /**
-     * Called when no [PsiClassItem] was found by [findClass]`([PsiClass]) when called on
-     * [psiClass].
-     *
-     * The purpose of this is to find where a new [PsiClassItem] should be inserted in the nested
-     * class structure. It finds the outermost [PsiClass] with no associated [PsiClassItem] but
-     * which is either a top level class or whose containing [PsiClass] does have an associated
-     * [PsiClassItem]. That is the point where new classes need to be created.
-     *
-     * e.g. if the nesting structure is `A.B.C` and `A` has already been created then the insertion
-     * point would consist of [PsiClassItem] for `A` (the containing class item) and the [PsiClass]
-     * for `B` (the outermost [PsiClass] with no associated item).
-     *
-     * If none had already been created then it would return an insertion point consisting of no
-     * containing class item and the [PsiClass] for `A`.
-     */
-    private fun findNewClassInsertionPoint(psiClass: PsiClass): NewClassInsertionPoint {
-        var current = psiClass
-        do {
-            // If the current has no containing class then it has reached the top level class so
-            // return an insertion point that has no containing class item and the current class.
-            val containing = current.containingClass ?: return NewClassInsertionPoint(current, null)
-
-            // If the containing class has a matching class item then return an insertion point that
-            // uses that containing class item and the current class.
-            findClass(containing)?.let { containingClassItem ->
-                return NewClassInsertionPoint(current, containingClassItem)
-            }
-            current = containing
-        } while (true)
-    }
-
-    internal fun findOrCreateClass(psiClass: PsiClass): PsiClassItem {
-        if (psiClass is PsiTypeParameter) {
-            error(
-                "Must not be called with PsiTypeParameter; call findOrCreateTypeParameter(...) instead"
-            )
-        }
-
-        // If it has already been created then return it.
-        findClass(psiClass)?.let {
-            return it
-        }
-
-        // Otherwise, find an insertion point at which new classes should be created.
-        val (missingPsiClass, containingClassItem) = findNewClassInsertionPoint(psiClass)
-
-        // Create a top level or nested class as appropriate.
-        val createdClassItem =
-            if (containingClassItem == null) {
-                createTopLevelClassAndContents(missingPsiClass)
-            } else {
-                createClass(
-                    missingPsiClass,
-                    containingClassItem,
-                    globalTypeItemFactory.from(containingClassItem)
-                )
-            }
-
-        // Make sure that the created class has been properly initialized.
-        finishClassInitialization(createdClassItem)
-
-        // Select the class item to return.
-        return if (missingPsiClass == psiClass) {
-            // The created class item was what was requested so just return it.
-            createdClassItem
-        } else {
-            // Otherwise, a nested class was requested so find it. It was created when its
-            // containing class was created.
-            findClass(psiClass)!!
-        }
-    }
-
-    internal fun findClass(psiType: PsiType): PsiClassItem? {
-        if (psiType is PsiClassType) {
-            val cls = psiType.resolve() ?: return null
-            return findOrCreateClass(cls)
-        } else if (psiType is PsiArrayType) {
-            var componentType = psiType.componentType
-            // We repeatedly get the component type because the array may have multiple dimensions
-            while (componentType is PsiArrayType) {
-                componentType = componentType.componentType
-            }
-            if (componentType is PsiClassType) {
-                val cls = componentType.resolve() ?: return null
-                return findOrCreateClass(cls)
-            }
-        }
-        return null
+    fun findClass(psiClass: PsiClass): ClassItem? {
+        val qualifiedName: String = psiClass.classQualifiedName
+        return findClass(qualifiedName)
     }
 
-    internal fun getClassType(cls: PsiClass): PsiClassType =
-        getFactory().createType(cls, PsiSubstitutor.EMPTY)
-
-    internal fun getComment(string: String, parent: PsiElement? = null): PsiDocComment =
-        getFactory().createDocCommentFromText(string, parent)
-
-    private fun getPackageName(clz: PsiClass): String {
-        var top: PsiClass? = clz
-        while (top?.containingClass != null) {
-            top = top.containingClass
-        }
-        top ?: return ""
-
-        val name = top.name
-        val fullName = top.qualifiedName ?: return ""
-
-        if (name == fullName) {
-            return ""
-        }
-
-        return fullName.substring(0, fullName.length - 1 - name!!.length)
-    }
+    internal fun findOrCreateClass(psiClass: PsiClass) = psiAssembler.findOrCreateClass(psiClass)
 
-    internal fun findMethod(method: PsiMethod): PsiMethodItem {
+    internal fun findCallableByPsiMethod(method: PsiMethod): PsiCallableItem {
         val containingClass = method.containingClass
         val cls = findOrCreateClass(containingClass!!)
 
         // Ensure initialized/registered via [#registerMethods]
         if (methodMap[cls] == null) {
-            val map = HashMap<PsiMethod, PsiMethodItem>(40)
-            registerMethods(cls.methods(), map)
-            registerMethods(cls.constructors(), map)
+            val map = HashMap<PsiMethod, PsiCallableItem>(40)
+            registerCallablesByPsiMethod(cls.methods(), map)
+            registerCallablesByPsiMethod(cls.constructors(), map)
             methodMap[cls] = map
         }
 
         val methods = methodMap[cls]!!
         val methodItem = methods[method]
         if (methodItem == null) {
-            // Probably switched psi classes (e.g. used source PsiClass in registry but
-            // found duplicate class in .jar library and we're now pointing to it; in that
-            // case, find the equivalent method by signature
-            val psiClass = cls.psiClass
+            // Probably switched psi classes (e.g. used source PsiClass in registry but found
+            // duplicate class in .jar library, and we're now pointing to it; in that case, find the
+            // equivalent method by signature
+            val psiClass = (cls as PsiClassItem).psiClass
             val updatedMethod = psiClass.findMethodBySignature(method, true)
             val result = methods[updatedMethod!!]
             if (result == null) {
@@ -824,97 +141,25 @@ open class PsiBasedCodebase(
         return cls.findField(field.name)
     }
 
-    private fun registerMethods(
-        methods: List<MethodItem>,
-        map: MutableMap<PsiMethod, PsiMethodItem>
+    private fun registerCallablesByPsiMethod(
+        callables: List<CallableItem>,
+        map: MutableMap<PsiMethod, PsiCallableItem>
     ) {
-        for (method in methods) {
-            val psiMethod = (method as PsiMethodItem).psiMethod
-            map[psiMethod] = method
+        for (callable in callables) {
+            val psiMethod = (callable as PsiCallableItem).psiMethod
+            map[psiMethod] = callable
             if (psiMethod is UMethod) {
                 // Register LC method as a key too
-                // so that we can find the corresponding [MethodItem]
-                // Otherwise, we will end up creating a new [MethodItem]
+                // so that we can find the corresponding [CallableItem]
+                // Otherwise, we will end up creating a new [CallableItem]
                 // without source PSI, resulting in wrong modifier.
-                map[psiMethod.javaPsi] = method
+                map[psiMethod.javaPsi] = callable
             }
         }
     }
 
-    override fun getTopLevelClassesFromSource(): List<ClassItem> {
-        return topLevelClassesFromSource
-    }
-
-    internal fun createPsiMethod(s: String, parent: PsiElement? = null): PsiMethod =
-        getFactory().createMethodFromText(s, parent)
-
-    internal fun createPsiType(s: String, parent: PsiElement? = null): PsiType =
-        getFactory().createTypeFromText(s, parent)
-
-    private fun createPsiAnnotation(s: String, parent: PsiElement? = null): PsiAnnotation =
-        getFactory().createAnnotationFromText(s, parent)
-
-    private fun getFactory() = JavaPsiFacade.getElementFactory(project)
-
-    private var nonNullAnnotationProvider: TypeAnnotationProvider? = null
-    private var nullableAnnotationProvider: TypeAnnotationProvider? = null
-
-    /** Type annotation provider which provides androidx.annotation.NonNull */
-    internal fun getNonNullAnnotationProvider(): TypeAnnotationProvider {
-        return nonNullAnnotationProvider
-            ?: run {
-                val provider =
-                    TypeAnnotationProvider.Static.create(
-                        arrayOf(createPsiAnnotation("@$ANDROIDX_NONNULL"))
-                    )
-                nonNullAnnotationProvider
-                provider
-            }
-    }
-
-    /** Type annotation provider which provides androidx.annotation.Nullable */
-    internal fun getNullableAnnotationProvider(): TypeAnnotationProvider {
-        return nullableAnnotationProvider
-            ?: run {
-                val provider =
-                    TypeAnnotationProvider.Static.create(
-                        arrayOf(createPsiAnnotation("@$ANDROIDX_NULLABLE"))
-                    )
-                nullableAnnotationProvider
-                provider
-            }
-    }
-
-    override fun createAnnotation(
-        source: String,
-        context: Item?,
-    ): AnnotationItem {
-        val psiAnnotation = createPsiAnnotation(source, (context as? PsiItem)?.psi())
-        return PsiAnnotationItem.create(this, psiAnnotation)
-    }
-
-    override fun supportsDocumentation(): Boolean = true
-
-    override fun toString(): String = description
+    override fun isFromClassPath() = fromClasspath
 
-    /** Add a class to the codebase. Called from [PsiClassItem.create]. */
-    internal fun registerClass(classItem: PsiClassItem) {
-        val qualifiedName = classItem.qualifiedName()
-        val existing = classMap.put(qualifiedName, classItem)
-        if (existing != null) {
-            reporter.report(
-                Issues.DUPLICATE_SOURCE_CLASS,
-                classItem,
-                "Ignoring this duplicate definition of $qualifiedName; previous definition was loaded from ${existing.fileLocation.path}"
-            )
-            return
-        }
-
-        addClass(classItem)
-    }
-
-    internal val uastResolveService: BaseKotlinUastResolveProviderService? by lazy {
-        ApplicationManager.getApplication()
-            .getService(BaseKotlinUastResolveProviderService::class.java)
-    }
+    override fun createAnnotation(source: String, context: Item?) =
+        psiAssembler.createAnnotation(source, context)
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt
new file mode 100644
index 000000000..92aaab2b8
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.CallableBody
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.reporter.Issues
+import com.intellij.psi.JavaRecursiveElementVisitor
+import com.intellij.psi.PsiClassObjectAccessExpression
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiField
+import com.intellij.psi.PsiModifier
+import com.intellij.psi.PsiReferenceExpression
+import com.intellij.psi.PsiReturnStatement
+import com.intellij.psi.PsiSynchronizedStatement
+import com.intellij.psi.PsiThisExpression
+import org.jetbrains.uast.UAnnotation
+import org.jetbrains.uast.UCallExpression
+import org.jetbrains.uast.UClassLiteralExpression
+import org.jetbrains.uast.UElement
+import org.jetbrains.uast.UMethod
+import org.jetbrains.uast.UQualifiedReferenceExpression
+import org.jetbrains.uast.USimpleNameReferenceExpression
+import org.jetbrains.uast.UThisExpression
+import org.jetbrains.uast.UThrowExpression
+import org.jetbrains.uast.UTryExpression
+import org.jetbrains.uast.UastErrorType
+import org.jetbrains.uast.getParentOfType
+import org.jetbrains.uast.toUElement
+import org.jetbrains.uast.visitor.AbstractUastVisitor
+
+internal class PsiCallableBody(private val callable: PsiCallableItem) : CallableBody {
+
+    /**
+     * Access [codebase] on demand as [callable] is not properly initialized during initialization
+     * of this class.
+     */
+    private val codebase
+        get() = callable.codebase
+
+    /**
+     * Access [psiMethod] on demand as [callable] is not properly initialized during initialization
+     * of this class.
+     */
+    private val psiMethod
+        get() = callable.psiMethod
+
+    override fun duplicate(callableItem: CallableItem): CallableBody {
+        // It is ok to cast here as `duplicate` will always be called with a `callableItem` from the
+        // same type of `Codebase` as this is.
+        return PsiCallableBody(callableItem as PsiCallableItem)
+    }
+
+    // Cannot create a copy of this as callableItem cannot be cast to PsiCallableItem. There is no
+    // easy way to capture the state of this sufficiently well to implement the necessary behavior
+    // so just pretend it is unavailable for now.
+    override fun snapshot(callableItem: CallableItem): CallableBody {
+        return CallableBody.UNAVAILABLE
+    }
+
+    override fun findThrownExceptions(): Set<ClassItem> {
+        if (!callable.isKotlin()) {
+            return emptySet()
+        }
+
+        val exceptions = mutableSetOf<ClassItem>()
+
+        val method = psiMethod as? UMethod ?: return emptySet()
+        method.accept(
+            object : AbstractUastVisitor() {
+                override fun visitThrowExpression(node: UThrowExpression): Boolean {
+                    val type = node.thrownExpression.getExpressionType()
+                    // TODO: after KTIJ-31242, go back to null check only
+                    if (type != null && type != UastErrorType) {
+                        val typeItemFactory = codebase.globalTypeItemFactory.from(callable)
+                        val exceptionClass = typeItemFactory.getType(type).asClass()
+                        if (exceptionClass != null && !isCaught(exceptionClass, node)) {
+                            exceptions.add(exceptionClass)
+                        }
+                    }
+                    return super.visitThrowExpression(node)
+                }
+
+                private fun isCaught(exceptionClass: ClassItem, node: UThrowExpression): Boolean {
+                    var current: UElement = node
+                    while (true) {
+                        val tryExpression =
+                            current.getParentOfType<UTryExpression>(
+                                UTryExpression::class.java,
+                                true,
+                                UMethod::class.java
+                            )
+                                ?: return false
+
+                        for (catchClause in tryExpression.catchClauses) {
+                            for (type in catchClause.types) {
+                                val qualifiedName = type.canonicalText
+                                if (exceptionClass.extends(qualifiedName)) {
+                                    return true
+                                }
+                            }
+                        }
+
+                        current = tryExpression
+                    }
+                }
+            }
+        )
+
+        return exceptions
+    }
+
+    override fun findVisiblySynchronizedLocations(): List<FileLocation> {
+        return buildList {
+            val psiMethod = psiMethod
+            if (psiMethod is UMethod) {
+                psiMethod.accept(
+                    object : AbstractUastVisitor() {
+                        override fun afterVisitCallExpression(node: UCallExpression) {
+                            super.afterVisitCallExpression(node)
+
+                            if (node.methodName == "synchronized" && node.receiver == null) {
+                                val arg = node.valueArguments.firstOrNull()
+                                if (
+                                    arg is UThisExpression ||
+                                        arg is UClassLiteralExpression ||
+                                        arg is UQualifiedReferenceExpression &&
+                                            arg.receiver is UClassLiteralExpression
+                                ) {
+                                    val psi = arg.sourcePsi ?: node.sourcePsi ?: node.javaPsi
+                                    add(PsiFileLocation.fromPsiElement(psi))
+                                }
+                            }
+                        }
+                    }
+                )
+            } else {
+                psiMethod.body?.accept(
+                    object : JavaRecursiveElementVisitor() {
+                        override fun visitSynchronizedStatement(
+                            statement: PsiSynchronizedStatement
+                        ) {
+                            super.visitSynchronizedStatement(statement)
+
+                            val lock = statement.lockExpression
+                            if (
+                                lock == null ||
+                                    lock is PsiThisExpression ||
+                                    // locking on any class is visible
+                                    lock is PsiClassObjectAccessExpression
+                            ) {
+                                val psi = lock ?: statement
+                                add(PsiFileLocation.fromPsiElement(psi))
+                            }
+                        }
+                    }
+                )
+            }
+        }
+    }
+
+    /**
+     * Given a method whose return value is annotated with a typedef, runs checks on the typedef and
+     * flags any returned constants not in the list.
+     */
+    override fun verifyReturnedConstants(
+        typeDefAnnotation: AnnotationItem,
+        typeDefClass: ClassItem,
+    ) {
+        val uAnnotation = typeDefAnnotation.uAnnotation ?: return
+        val body = psiMethod.body ?: return
+
+        body.accept(
+            object : JavaRecursiveElementVisitor() {
+                private var constants: List<String>? = null
+
+                override fun visitReturnStatement(statement: PsiReturnStatement) {
+                    val value = statement.returnValue
+                    if (value is PsiReferenceExpression) {
+                        val resolved = value.resolve() as? PsiField ?: return
+                        val modifiers = resolved.modifierList ?: return
+                        if (
+                            modifiers.hasModifierProperty(PsiModifier.STATIC) &&
+                                modifiers.hasModifierProperty(PsiModifier.FINAL)
+                        ) {
+                            if (resolved.type.arrayDimensions > 0) {
+                                return
+                            }
+                            val name = resolved.name
+
+                            // Make sure this is one of the allowed annotations
+                            val names =
+                                constants
+                                    ?: run {
+                                        constants = computeValidConstantNames(uAnnotation)
+                                        constants!!
+                                    }
+                            if (names.isNotEmpty() && !names.contains(name)) {
+                                val expected = names.joinToString { it }
+                                codebase.reporter.report(
+                                    Issues.RETURNING_UNEXPECTED_CONSTANT,
+                                    value as PsiElement,
+                                    "Returning unexpected constant $name; is @${typeDefClass.simpleName()} missing this constant? Expected one of $expected"
+                                )
+                            }
+                        }
+                    }
+                }
+            }
+        )
+    }
+
+    private fun computeValidConstantNames(annotation: UAnnotation): List<String> {
+        val constants = annotation.findAttributeValue(ANNOTATION_ATTR_VALUE) ?: return emptyList()
+        if (constants is UCallExpression) {
+            return constants.valueArguments
+                .mapNotNull { (it as? USimpleNameReferenceExpression)?.identifier }
+                .toList()
+        }
+
+        return emptyList()
+    }
+}
+
+/** Public for use only in ExtractAnnotations */
+val AnnotationItem.uAnnotation: UAnnotation?
+    get() =
+        when (this) {
+            is UAnnotationItem -> uAnnotation
+            is PsiAnnotationItem ->
+                // Imported annotation
+                psiAnnotation.toUElement(UAnnotation::class.java)
+            else -> null
+        }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableItem.kt
new file mode 100644
index 000000000..a70551b5e
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableItem.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.type.MethodFingerprint
+import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiParameter
+import org.jetbrains.uast.UMethod
+
+internal interface PsiCallableItem : CallableItem, PsiItem {
+
+    override fun psi() = psiMethod
+
+    val psiMethod: PsiMethod
+
+    companion object {
+        /**
+         * Create a list of [PsiParameterItem]s.
+         *
+         * The [codebase] and [psiMethod] parameters are added here, rather than retrieving from
+         * [containingCallable]'s [PsiCallableItem.codebase] and [PsiCallableItem.psi] properties
+         * respectively, because at the time this is called [containingCallable] is in the process
+         * of being initialized and those properties have not yet been initialized.
+         */
+        internal fun parameterList(
+            codebase: PsiBasedCodebase,
+            psiMethod: PsiMethod,
+            containingCallable: PsiCallableItem,
+            enclosingTypeItemFactory: PsiTypeItemFactory,
+            psiParameters: List<PsiParameter> = psiMethod.psiParameters,
+        ): List<PsiParameterItem> {
+            val fingerprint = MethodFingerprint(containingCallable.name(), psiParameters.size)
+            return psiParameters.mapIndexed { index, parameter ->
+                PsiParameterItem.create(
+                    codebase,
+                    containingCallable,
+                    fingerprint,
+                    parameter,
+                    index,
+                    enclosingTypeItemFactory
+                )
+            }
+        }
+
+        internal fun throwsTypes(
+            psiMethod: PsiMethod,
+            enclosingTypeItemFactory: PsiTypeItemFactory,
+        ): List<ExceptionTypeItem> {
+            val throwsClassTypes = psiMethod.throwsList.referencedTypes
+            if (throwsClassTypes.isEmpty()) {
+                return emptyList()
+            }
+
+            return throwsClassTypes
+                // Convert the PsiType to an ExceptionTypeItem and wrap it in a ThrowableType.
+                .map { psiType -> enclosingTypeItemFactory.getExceptionType(PsiTypeInfo(psiType)) }
+                // We're sorting the names here even though outputs typically do their own sorting,
+                // since for example the MethodItem.sameSignature check wants to do an
+                // element-by-element comparison to see if the signature matches, and that should
+                // match overrides even if they specify their elements in different orders.
+                .sortedWith(ExceptionTypeItem.fullNameComparator)
+        }
+    }
+}
+
+/** Get the [PsiParameter]s for a [PsiMethod]. */
+val PsiMethod.psiParameters: List<PsiParameter>
+    get() = if (this is UMethod) uastParameters else parameterList.parameters.toList()
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
index 3cbc166d2..edf87edd8 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
@@ -16,183 +16,71 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationRetention
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SourceFile
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.isRetention
-import com.android.tools.metalava.model.updateCopiedMethodState
+import com.android.tools.metalava.model.item.DefaultClassItem
 import com.intellij.psi.PsiClass
-import com.intellij.psi.PsiClassType
 import com.intellij.psi.PsiCompiledFile
-import com.intellij.psi.PsiMethod
-import com.intellij.psi.PsiModifier
-import com.intellij.psi.PsiType
-import com.intellij.psi.PsiTypeParameter
-import com.intellij.psi.util.PsiUtil
-import org.jetbrains.kotlin.psi.KtParameter
-import org.jetbrains.kotlin.psi.KtProperty
-import org.jetbrains.kotlin.psi.KtPropertyAccessor
-import org.jetbrains.kotlin.psi.KtTypeReference
-import org.jetbrains.kotlin.psi.psiUtil.isPropertyParameter
+import org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade
 import org.jetbrains.uast.UClass
 import org.jetbrains.uast.UFile
 import org.jetbrains.uast.getParentOfType
 
-open class PsiClassItem
+internal class PsiClassItem
 internal constructor(
-    codebase: PsiBasedCodebase,
+    override val codebase: PsiBasedCodebase,
     val psiClass: PsiClass,
-    private val name: String,
-    private val fullName: String,
-    private val qualifiedName: String,
-    private val hasImplicitDefaultConstructor: Boolean,
-    override val classKind: ClassKind,
-    override val typeParameterList: TypeParameterList,
-    private val superClassType: ClassTypeItem?,
-    private var interfaceTypes: List<ClassTypeItem>,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    /** True if this class is from the class path (dependencies). Exposed in [isFromClassPath]. */
-    private val fromClassPath: Boolean
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    classKind: ClassKind,
+    containingClass: ClassItem?,
+    containingPackage: PackageItem,
+    qualifiedName: String,
+    typeParameterList: TypeParameterList,
+    origin: ClassOrigin,
+    superClassType: ClassTypeItem?,
+    interfaceTypes: List<ClassTypeItem>
 ) :
-    PsiItem(
+    DefaultClassItem(
         codebase = codebase,
+        fileLocation = PsiFileLocation.fromPsiElement(psiClass),
+        itemLanguage = psiClass.itemLanguage,
         modifiers = modifiers,
-        documentation = documentation,
-        element = psiClass
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
+        source = null,
+        classKind = classKind,
+        containingClass = containingClass,
+        containingPackage = containingPackage,
+        qualifiedName = qualifiedName,
+        typeParameterList = typeParameterList,
+        origin = origin,
+        superClassType = superClassType,
+        interfaceTypes = interfaceTypes,
     ),
-    ClassItem {
-
-    init {
-        emit = !modifiers.isExpect()
-    }
-
-    lateinit var containingPackage: PsiPackageItem
-
-    override fun containingPackage(): PackageItem =
-        containingClass?.containingPackage() ?: containingPackage
-
-    override fun simpleName(): String = name
-
-    override fun fullName(): String = fullName
-
-    override fun qualifiedName(): String = qualifiedName
+    ClassItem,
+    PsiItem {
 
     override fun psi() = psiClass
 
-    override fun isFromClassPath(): Boolean = fromClassPath
-
-    override fun hasImplicitDefaultConstructor(): Boolean = hasImplicitDefaultConstructor
-
-    override fun superClass(): ClassItem? = superClassType?.asClass()
-
-    override fun superClassType(): ClassTypeItem? = superClassType
-
-    override var stubConstructor: ConstructorItem? = null
-    override var artifact: String? = null
-
-    private var containingClass: PsiClassItem? = null
-
-    override fun containingClass(): PsiClassItem? = containingClass
-
-    override var hasPrivateConstructor: Boolean = false
-
-    override fun interfaceTypes(): List<ClassTypeItem> = interfaceTypes
-
-    override fun setInterfaceTypes(interfaceTypes: List<ClassTypeItem>) {
-        this.interfaceTypes = interfaceTypes
-    }
-
-    private var allInterfaces: List<ClassItem>? = null
-
-    override fun allInterfaces(): Sequence<ClassItem> {
-        if (allInterfaces == null) {
-            val classes = mutableSetOf<PsiClass>()
-            var curr: PsiClass? = psiClass
-            while (curr != null) {
-                if (curr.isInterface && !classes.contains(curr)) {
-                    classes.add(curr)
-                }
-                addInterfaces(classes, curr.interfaces)
-                curr = curr.superClass
-            }
-            val result = mutableListOf<ClassItem>()
-            for (cls in classes) {
-                val item = codebase.findOrCreateClass(cls)
-                result.add(item)
-            }
-
-            allInterfaces = result
-        }
-
-        return allInterfaces!!.asSequence()
-    }
-
-    private fun addInterfaces(result: MutableSet<PsiClass>, interfaces: Array<out PsiClass>) {
-        for (itf in interfaces) {
-            if (itf.isInterface && !result.contains(itf)) {
-                result.add(itf)
-                addInterfaces(result, itf.interfaces)
-                val superClass = itf.superClass
-                if (superClass != null) {
-                    addInterfaces(result, arrayOf(superClass))
-                }
-            }
-        }
-    }
-
-    private lateinit var innerClasses: List<PsiClassItem>
-    private lateinit var constructors: List<PsiConstructorItem>
-    private lateinit var methods: MutableList<PsiMethodItem>
-    private lateinit var properties: List<PsiPropertyItem>
-    private lateinit var fields: List<FieldItem>
-
-    /**
-     * If this item was created by filtering down a different codebase, this temporarily points to
-     * the original item during construction. This is used to let us initialize for example throws
-     * lists later, when all classes in the codebase have been initialized.
-     */
-    internal var source: PsiClassItem? = null
+    override var primaryConstructor: ConstructorItem? = null
+        internal set
 
-    override fun innerClasses(): List<PsiClassItem> = innerClasses
-
-    override fun constructors(): List<ConstructorItem> = constructors
-
-    override fun methods(): List<PsiMethodItem> = methods
-
-    override fun properties(): List<PropertyItem> = properties
-
-    override fun fields(): List<FieldItem> = fields
-
-    final override var primaryConstructor: PsiConstructorItem? = null
-        private set
-
-    /** Must only be used by [type] to cache its result. */
-    private lateinit var classTypeItem: PsiClassTypeItem
-
-    override fun type(): ClassTypeItem {
-        if (!::classTypeItem.isInitialized) {
-            classTypeItem = codebase.globalTypeItemFactory.getClassTypeForClass(this)
-        }
-        return classTypeItem
-    }
-
-    override fun hasTypeVariables(): Boolean = psiClass.hasTypeParameters()
+    override fun createClassTypeItemForThis() =
+        codebase.globalTypeItemFactory.getClassTypeForClass(this)
 
     override fun getSourceFile(): SourceFile? {
-        if (isInnerClass()) {
+        if (isNestedClass()) {
             return null
         }
 
@@ -211,492 +99,14 @@ internal constructor(
         return PsiSourceFile(codebase, containingFile, uFile)
     }
 
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is ClassItem && qualifiedName == other.qualifiedName()
-    }
-
     /** Creates a constructor in this class */
-    override fun createDefaultConstructor(): ConstructorItem {
-        return PsiConstructorItem.createDefaultConstructor(codebase, this, psiClass)
-    }
-
-    override fun inheritMethodFromNonApiAncestor(template: MethodItem): MethodItem {
-        val method = template as PsiMethodItem
-        require(method.codebase == codebase) {
-            "Unexpected attempt to copy $method from one codebase (${method.codebase.location}) to another (${codebase.location})"
-        }
-        val newMethod = PsiMethodItem.create(this, method)
-
-        // Remember which class this method was copied from.
-        newMethod.inheritedFrom = template.containingClass()
-
-        newMethod.updateCopiedMethodState()
-
-        return newMethod
+    override fun createDefaultConstructor(visibility: VisibilityLevel): PsiConstructorItem {
+        return PsiConstructorItem.createDefaultConstructor(codebase, this, psiClass, visibility)
     }
 
-    override fun addMethod(method: MethodItem) {
-        methods.add(method as PsiMethodItem)
+    override fun isFileFacade(): Boolean {
+        return psiClass.isKotlin() &&
+            psiClass is UClass &&
+            psiClass.javaPsi is KtLightClassForFacade
     }
-
-    private var retention: AnnotationRetention? = null
-
-    override fun getRetention(): AnnotationRetention {
-        retention?.let {
-            return it
-        }
-
-        if (!isAnnotationType()) {
-            error("getRetention() should only be called on annotation classes")
-        }
-
-        retention = ClassItem.findRetention(this)
-        return retention!!
-    }
-
-    override fun hashCode(): Int = qualifiedName.hashCode()
-
-    companion object {
-        private fun hasExplicitRetention(
-            modifiers: DefaultModifierList,
-            psiClass: PsiClass,
-            isKotlin: Boolean
-        ): Boolean {
-            if (modifiers.hasAnnotation(AnnotationItem::isRetention)) {
-                return true
-            }
-            if (isKotlin && psiClass is UClass) {
-                // In Kotlin some annotations show up on the Java facade only; for example,
-                // a @DslMarker annotation will imply a runtime annotation which is present
-                // in the java facade, not in the source list of annotations
-                val modifierList = psiClass.modifierList
-                if (
-                    modifierList != null &&
-                        modifierList.annotations.any { isRetention(it.qualifiedName) }
-                ) {
-                    return true
-                }
-            }
-            return false
-        }
-
-        internal fun create(
-            codebase: PsiBasedCodebase,
-            psiClass: PsiClass,
-            containingClassItem: PsiClassItem?,
-            enclosingClassTypeItemFactory: PsiTypeItemFactory,
-            fromClassPath: Boolean,
-        ): PsiClassItem {
-            if (psiClass is PsiTypeParameter) {
-                error(
-                    "Must not be called with PsiTypeParameter; use PsiTypeParameterItem.create(...) instead"
-                )
-            }
-            val simpleName = psiClass.name!!
-            val fullName = computeFullClassName(psiClass)
-            val qualifiedName = psiClass.qualifiedName ?: simpleName
-            val hasImplicitDefaultConstructor = hasImplicitDefaultConstructor(psiClass)
-            val classKind = getClassKind(psiClass)
-
-            val commentText = javadoc(psiClass, codebase.allowReadingComments)
-            val modifiers = PsiModifierItem.create(codebase, psiClass, commentText)
-
-            // Create the TypeParameterList for this before wrapping any of the other types used by
-            // it as they may reference a type parameter in the list.
-            val (typeParameterList, classTypeItemFactory) =
-                PsiTypeParameterList.create(
-                    codebase,
-                    enclosingClassTypeItemFactory,
-                    "class $qualifiedName",
-                    psiClass
-                )
-
-            val (superClassType, interfaceTypes) =
-                computeSuperTypes(psiClass, classKind, classTypeItemFactory)
-
-            val item =
-                PsiClassItem(
-                    codebase = codebase,
-                    psiClass = psiClass,
-                    name = simpleName,
-                    fullName = fullName,
-                    qualifiedName = qualifiedName,
-                    classKind = classKind,
-                    typeParameterList = typeParameterList,
-                    superClassType = superClassType,
-                    interfaceTypes = interfaceTypes,
-                    hasImplicitDefaultConstructor = hasImplicitDefaultConstructor,
-                    documentation = commentText,
-                    modifiers = modifiers,
-                    fromClassPath = fromClassPath,
-                )
-            item.containingClass = containingClassItem
-
-            // Register this class now.
-            codebase.registerClass(item)
-
-            // Construct the children
-            val psiMethods = psiClass.methods
-            val methods: MutableList<PsiMethodItem> = ArrayList(psiMethods.size)
-            val isKotlin = psiClass.isKotlin()
-
-            if (
-                classKind == ClassKind.ANNOTATION_TYPE &&
-                    !hasExplicitRetention(modifiers, psiClass, isKotlin)
-            ) {
-                // By policy, include explicit retention policy annotation if missing
-                val defaultRetentionPolicy = AnnotationRetention.getDefault(isKotlin)
-                modifiers.addAnnotation(
-                    codebase.createAnnotation(
-                        buildString {
-                            append('@')
-                            append(java.lang.annotation.Retention::class.qualifiedName)
-                            append('(')
-                            append(java.lang.annotation.RetentionPolicy::class.qualifiedName)
-                            append('.')
-                            append(defaultRetentionPolicy.name)
-                            append(')')
-                        },
-                        item,
-                    )
-                )
-            }
-
-            // create methods
-            val constructors: MutableList<PsiConstructorItem> = ArrayList(5)
-            var hasConstructorWithOnlyOptionalArgs = false
-            var noArgConstructor: PsiConstructorItem? = null
-            for (psiMethod in psiMethods) {
-                if (psiMethod.isConstructor) {
-                    val constructor =
-                        PsiConstructorItem.create(
-                            codebase,
-                            item,
-                            psiMethod,
-                            classTypeItemFactory,
-                        )
-                    // After KT-13495, "all constructors of `sealed` classes now have `protected`
-                    // visibility by default," and (S|U)LC follows that (hence the same in UAST).
-                    // However, that change was made to allow more flexible class hierarchy and
-                    // nesting. If they're compiled to JVM bytecode, sealed class's ctor is still
-                    // technically `private` to block instantiation from outside class hierarchy.
-                    // Another synthetic constructor, along with an internal ctor marker, is added
-                    // for subclasses of a sealed class. Therefore, from Metalava's perspective,
-                    // it is not necessary to track such semantically protected ctor. Here we force
-                    // set the visibility to `private` back to ignore it during signature writing.
-                    if (item.modifiers.isSealed()) {
-                        constructor.modifiers.setVisibilityLevel(VisibilityLevel.PRIVATE)
-                    }
-                    if (constructor.areAllParametersOptional()) {
-                        if (constructor.parameters().isNotEmpty()) {
-                            constructors.add(constructor)
-                            // uast reported a constructor having only optional arguments, so if we
-                            // later find an explicit no-arg constructor, we can skip it because
-                            // its existence is implied
-                            hasConstructorWithOnlyOptionalArgs = true
-                        } else {
-                            noArgConstructor = constructor
-                        }
-                    } else {
-                        constructors.add(constructor)
-                    }
-                } else if (classKind == ClassKind.ENUM && psiMethod.isSyntheticEnumMethod()) {
-                    // skip
-                } else {
-                    val method =
-                        PsiMethodItem.create(codebase, item, psiMethod, classTypeItemFactory)
-                    methods.add(method)
-                }
-            }
-
-            // Add the no-arg constructor back in if no constructors have only optional arguments
-            // or if an all-optional constructor created it as part of @JvmOverloads
-            if (
-                noArgConstructor != null &&
-                    (!hasConstructorWithOnlyOptionalArgs ||
-                        noArgConstructor.modifiers.isAnnotatedWith("kotlin.jvm.JvmOverloads"))
-            ) {
-                constructors.add(noArgConstructor)
-            }
-
-            // Note that this is dependent on the constructor filtering above. UAST sometimes
-            // reports duplicate primary constructors, e.g.: the implicit no-arg constructor
-            constructors.singleOrNull { it.isPrimary }?.let { item.primaryConstructor = it }
-
-            if (hasImplicitDefaultConstructor) {
-                assert(constructors.isEmpty())
-                constructors.add(
-                    PsiConstructorItem.createDefaultConstructor(codebase, item, psiClass)
-                )
-            }
-
-            val fields: MutableList<PsiFieldItem> = mutableListOf()
-            val psiFields = psiClass.fields
-            if (psiFields.isNotEmpty()) {
-                psiFields.asSequence().mapTo(fields) {
-                    PsiFieldItem.create(codebase, item, it, classTypeItemFactory)
-                }
-            }
-
-            if (classKind == ClassKind.INTERFACE) {
-                // All members are implicitly public, fields are implicitly static, non-static
-                // methods are abstract
-                // (except in Java 1.9, where they can be private
-                for (method in methods) {
-                    if (!method.isPrivate) {
-                        method.mutableModifiers().setVisibilityLevel(VisibilityLevel.PUBLIC)
-                    }
-                }
-                for (method in fields) {
-                    val m = method.mutableModifiers()
-                    m.setVisibilityLevel(VisibilityLevel.PUBLIC)
-                    m.setStatic(true)
-                }
-            }
-
-            item.constructors = constructors
-            item.methods = methods
-            item.fields = fields
-
-            item.properties = emptyList()
-
-            if (isKotlin && methods.isNotEmpty()) {
-                val getters = mutableMapOf<String, PsiMethodItem>()
-                val setters = mutableMapOf<String, PsiMethodItem>()
-                val backingFields = fields.associateBy { it.name() }
-                val constructorParameters =
-                    item.primaryConstructor
-                        ?.parameters()
-                        ?.filter { (it.sourcePsi as? KtParameter)?.isPropertyParameter() ?: false }
-                        ?.associateBy { it.name() }
-                        .orEmpty()
-
-                for (method in methods) {
-                    if (method.isKotlinProperty()) {
-                        val name =
-                            when (val sourcePsi = method.sourcePsi) {
-                                is KtProperty -> sourcePsi.name
-                                is KtPropertyAccessor -> sourcePsi.property.name
-                                is KtParameter -> sourcePsi.name
-                                else -> null
-                            }
-                                ?: continue
-
-                        if (method.parameters().isEmpty()) {
-                            if (!method.name().startsWith("component")) {
-                                getters[name] = method
-                            }
-                        } else {
-                            setters[name] = method
-                        }
-                    }
-                }
-
-                val properties = mutableListOf<PsiPropertyItem>()
-                for ((name, getter) in getters) {
-                    val type = getter.returnType() as? PsiTypeItem ?: continue
-                    properties +=
-                        PsiPropertyItem.create(
-                            codebase = codebase,
-                            containingClass = item,
-                            name = name,
-                            type = type,
-                            getter = getter,
-                            setter = setters[name],
-                            constructorParameter = constructorParameters[name],
-                            backingField = backingFields[name]
-                        )
-                }
-                item.properties = properties
-            }
-
-            val psiInnerClasses = psiClass.innerClasses
-            item.innerClasses =
-                if (psiInnerClasses.isEmpty()) {
-                    emptyList()
-                } else {
-                    val result =
-                        psiInnerClasses
-                            .asSequence()
-                            .map {
-                                codebase.createClass(
-                                    psiClass = it,
-                                    containingClassItem = item,
-                                    enclosingClassTypeItemFactory = classTypeItemFactory
-                                )
-                            }
-                            .toMutableList()
-                    result
-                }
-
-            return item
-        }
-
-        /**
-         * Compute the super types for the class.
-         *
-         * Returns a pair of the optional super class type and the possibly empty list of interface
-         * types.
-         */
-        private fun computeSuperTypes(
-            psiClass: PsiClass,
-            classKind: ClassKind,
-            classTypeItemFactory: PsiTypeItemFactory
-        ): Pair<ClassTypeItem?, List<ClassTypeItem>> {
-
-            // A map from the qualified type name to the corresponding [KtTypeReference]. This is
-            // empty for non-Kotlin code, otherwise it maps from the qualified type name of a
-            // super type to the associated [KtTypeReference]. The qualified name is used to map
-            // between them because Kotlin does not differentiate between `implements` and `extends`
-            // lists and just has one super type list. The qualified name is safe because a class
-            // cannot implement/extend the same generic type multiple times with different type
-            // arguments so the qualified name should be unique among the super type list.
-            // The [KtTypeReference] is needed to access the type nullability of the generic type
-            // arguments.
-            val qualifiedNameToKt =
-                if (psiClass is UClass) {
-                    psiClass.uastSuperTypes.associateBy({ it.getQualifiedName() }) {
-                        it.sourcePsi as KtTypeReference
-                    }
-                } else emptyMap()
-
-            // Get the [KtTypeReference], if any, associated with ths [PsiType] which must be a
-            // [PsiClassType] as that is the only type allowed in an extends/implements list.
-            fun PsiType.ktTypeReference(): KtTypeReference? {
-                val qualifiedName = (this as PsiClassType).computeQualifiedName()
-                return qualifiedNameToKt[qualifiedName]
-            }
-
-            // Construct the super class type if needed and available.
-            val superClassType =
-                if (classKind != ClassKind.INTERFACE) {
-                    val superClassPsiType = psiClass.superClassType as? PsiType
-                    superClassPsiType?.let { superClassType ->
-                        val ktTypeRef = superClassType.ktTypeReference()
-                        classTypeItemFactory.getSuperClassType(
-                            PsiTypeInfo(superClassType, ktTypeRef)
-                        )
-                    }
-                } else null
-
-            // Get the interfaces from the appropriate list.
-            val interfaces =
-                if (classKind == ClassKind.INTERFACE || classKind == ClassKind.ANNOTATION_TYPE) {
-                    // An interface uses "extends <interfaces>", either explicitly for normal
-                    // interfaces or implicitly for annotations.
-                    psiClass.extendsListTypes
-                } else {
-                    // A class uses "extends <interfaces>".
-                    psiClass.implementsListTypes
-                }
-
-            // Map them to PsiTypeItems.
-            val interfaceTypes =
-                interfaces.map { interfaceType ->
-                    val ktTypeRef = interfaceType.ktTypeReference()
-                    classTypeItemFactory.getInterfaceType(PsiTypeInfo(interfaceType, ktTypeRef))
-                }
-            return Pair(superClassType, interfaceTypes)
-        }
-
-        private fun getClassKind(psiClass: PsiClass): ClassKind {
-            return when {
-                psiClass.isAnnotationType -> ClassKind.ANNOTATION_TYPE
-                psiClass.isInterface -> ClassKind.INTERFACE
-                psiClass.isEnum -> ClassKind.ENUM
-                psiClass is PsiTypeParameter ->
-                    error("Must not call this with a PsiTypeParameter - $psiClass")
-                else -> ClassKind.CLASS
-            }
-        }
-
-        /**
-         * Computes the "full" class name; this is not the qualified class name (e.g. with package)
-         * but for an inner class it includes all the outer classes
-         */
-        fun computeFullClassName(cls: PsiClass): String {
-            if (cls.containingClass == null) {
-                val name = cls.name
-                return name!!
-            } else {
-                val list = mutableListOf<String>()
-                var curr: PsiClass? = cls
-                while (curr != null) {
-                    val name = curr.name
-                    curr =
-                        if (name != null) {
-                            list.add(name)
-                            curr.containingClass
-                        } else {
-                            break
-                        }
-                }
-                return list.asReversed().joinToString(separator = ".") { it }
-            }
-        }
-
-        private fun hasImplicitDefaultConstructor(psiClass: PsiClass): Boolean {
-            if (psiClass.name?.startsWith("-") == true) {
-                // Deliberately hidden; see examples like
-                //     @file:JvmName("-ViewModelExtensions") // Hide from Java sources in the IDE.
-                return false
-            }
-            if (psiClass is UClass && psiClass.sourcePsi == null) {
-                // Top level kt classes (FooKt for Foo.kt) do not have implicit default constructor
-                return false
-            }
-
-            val constructors = psiClass.constructors
-            if (
-                constructors.isEmpty() &&
-                    !psiClass.isInterface &&
-                    !psiClass.isAnnotationType &&
-                    !psiClass.isEnum
-            ) {
-                if (PsiUtil.hasDefaultConstructor(psiClass)) {
-                    return true
-                }
-
-                // The above method isn't always right; for example, for the
-                // ContactsContract.Presence class
-                // in the framework, which looks like this:
-                //    @Deprecated
-                //    public static final class Presence extends StatusUpdates {
-                //    }
-                // javac makes a default constructor:
-                //    public final class android.provider.ContactsContract$Presence extends
-                // android.provider.ContactsContract$StatusUpdates {
-                //        public android.provider.ContactsContract$Presence();
-                //    }
-                // but the above method returns false. So add some of our own heuristics:
-                if (
-                    psiClass.hasModifierProperty(PsiModifier.FINAL) &&
-                        !psiClass.hasModifierProperty(PsiModifier.ABSTRACT) &&
-                        psiClass.hasModifierProperty(PsiModifier.PUBLIC)
-                ) {
-                    return true
-                }
-            }
-
-            return false
-        }
-    }
-}
-
-/**
- * Check whether the method is a synthetic enum method.
- *
- * i.e. `getEntries()` from Kotlin and `values()` and `valueOf(String)` from both Java and Kotlin.
- */
-private fun PsiMethod.isSyntheticEnumMethod(): Boolean {
-    if (containingClass?.isEnum != true) return false
-    val parameterCount = parameterList.parametersCount
-    return (parameterCount == 0 && (name == "values" || name == "getEntries")) ||
-        (parameterCount == 1 &&
-            name == "valueOf" &&
-            (parameterList.parameters[0].type as? PsiClassType)?.computeQualifiedName() ==
-                "java.lang.String")
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
new file mode 100644
index 000000000..199b724a5
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
@@ -0,0 +1,1029 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.SdkConstants
+import com.android.tools.lint.UastEnvironment
+import com.android.tools.lint.annotations.Extractor
+import com.android.tools.metalava.model.ANDROIDX_NONNULL
+import com.android.tools.metalava.model.ANDROIDX_NULLABLE
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.JAVA_PACKAGE_INFO
+import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.TypeParameterScope
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.addDefaultRetentionPolicyAnnotation
+import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.isRetention
+import com.android.tools.metalava.model.item.CodebaseAssembler
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.MutablePackageDoc
+import com.android.tools.metalava.model.item.PackageDoc
+import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.model.source.SourceSet
+import com.android.tools.metalava.model.source.utils.gatherPackageJavadoc
+import com.android.tools.metalava.reporter.Issues
+import com.intellij.openapi.application.ApplicationManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.JavaPsiFacade
+import com.intellij.psi.JavaRecursiveElementVisitor
+import com.intellij.psi.PsiAnnotation
+import com.intellij.psi.PsiArrayType
+import com.intellij.psi.PsiClass
+import com.intellij.psi.PsiClassOwner
+import com.intellij.psi.PsiClassType
+import com.intellij.psi.PsiCodeBlock
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiEllipsisType
+import com.intellij.psi.PsiErrorElement
+import com.intellij.psi.PsiFile
+import com.intellij.psi.PsiImportStatement
+import com.intellij.psi.PsiJavaFile
+import com.intellij.psi.PsiManager
+import com.intellij.psi.PsiPackage
+import com.intellij.psi.PsiParameter
+import com.intellij.psi.PsiSubstitutor
+import com.intellij.psi.PsiType
+import com.intellij.psi.PsiTypeParameter
+import com.intellij.psi.TypeAnnotationProvider
+import com.intellij.psi.impl.file.PsiPackageImpl
+import com.intellij.psi.javadoc.PsiDocComment
+import com.intellij.psi.search.GlobalSearchScope
+import com.intellij.psi.util.PsiTreeUtil
+import java.io.File
+import java.io.IOException
+import java.util.zip.ZipFile
+import org.jetbrains.kotlin.analysis.api.types.KaTypeNullability
+import org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.JvmStandardClassIds
+import org.jetbrains.kotlin.psi.KtFunction
+import org.jetbrains.kotlin.psi.KtParameter
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.psi.KtPropertyAccessor
+import org.jetbrains.kotlin.psi.KtTypeReference
+import org.jetbrains.kotlin.psi.psiUtil.isPropertyParameter
+import org.jetbrains.uast.UClass
+import org.jetbrains.uast.UFile
+import org.jetbrains.uast.UMethod
+import org.jetbrains.uast.UParameter
+import org.jetbrains.uast.UastFacade
+import org.jetbrains.uast.kotlin.BaseKotlinUastResolveProviderService
+
+internal class PsiCodebaseAssembler(
+    private val uastEnvironment: UastEnvironment,
+    codebaseFactory: (PsiCodebaseAssembler) -> PsiBasedCodebase
+) : CodebaseAssembler {
+
+    internal val codebase = codebaseFactory(this)
+
+    internal val globalTypeItemFactory = PsiTypeItemFactory(this, TypeParameterScope.empty)
+
+    internal val project: Project = uastEnvironment.ideaProject
+
+    private val reporter
+        get() = codebase.reporter
+
+    /**
+     * Map from qualified class name to the heavyweight [PsiClass] implementations corresponding to
+     * a source class.
+     *
+     * Psi can represent classes with a number of different implementations of [PsiClass] that have
+     * different capabilities and provide different, and inconsistent, information. This keeps track
+     * of the heavyweight [PsiClass] implementations for source classes which do not contribute
+     * directly to an API surface (and so do not have a [ClassItem] created in the initialization of
+     * the [PsiBasedCodebase]) but which may contribute indirectly, e.g. through inherited methods.
+     * If a [ClassItem] needs to be created during processing, e.g. because it is a super type, then
+     * the [PsiClass] corresponding to it will be removed from this map (if it exists) and used. If
+     * it does not exist then it will be looked up using [JavaPsiFacade].
+     */
+    private val deferredHeavyweightPsiClasses = mutableMapOf<String, PsiClass>()
+
+    fun dispose() {
+        uastEnvironment.dispose()
+    }
+
+    private fun getFactory() = JavaPsiFacade.getElementFactory(project)
+
+    internal fun getClassType(cls: PsiClass): PsiClassType =
+        getFactory().createType(cls, PsiSubstitutor.EMPTY)
+
+    internal fun getComment(documentation: String, parent: PsiElement? = null): PsiDocComment =
+        getFactory().createDocCommentFromText(documentation, parent)
+
+    internal fun createPsiType(s: String, parent: PsiElement? = null): PsiType =
+        getFactory().createTypeFromText(s, parent)
+
+    private fun createPsiAnnotation(s: String, parent: PsiElement? = null): PsiAnnotation =
+        getFactory().createAnnotationFromText(s, parent)
+
+    internal fun findPsiPackage(pkgName: String): PsiPackage? {
+        return JavaPsiFacade.getInstance(project).findPackage(pkgName)
+    }
+
+    override fun createPackageItem(
+        packageName: String,
+        packageDoc: PackageDoc,
+        containingPackage: PackageItem?
+    ): DefaultPackageItem {
+        val psiPackage =
+            findPsiPackage(packageName)
+                ?: run {
+                    // This can happen if a class's package statement does not match its file path.
+                    // In that case, this fakes up a PsiPackageImpl that matches the package
+                    // statement as that is the source of truth.
+                    val manager = PsiManager.getInstance(codebase.project)
+                    PsiPackageImpl(manager, packageName)
+                }
+        return PsiPackageItem.create(
+            codebase = codebase,
+            psiPackage = psiPackage,
+            packageDoc = packageDoc,
+            containingPackage = containingPackage,
+        )
+    }
+
+    override fun createClassFromUnderlyingModel(qualifiedName: String) =
+        findOrCreateClass(qualifiedName)
+
+    /** Check if the [BaseModifierList] is accsssible. */
+    private val BaseModifierList.isAccessible
+        get() =
+            when (getVisibilityLevel()) {
+                VisibilityLevel.PUBLIC,
+                VisibilityLevel.PROTECTED -> true
+                VisibilityLevel.INTERNAL -> annotations().any { it.showability.show() }
+                else -> false
+            }
+
+    /**
+     * Create a possible API class, i.e. a class that has a possibility of being part of an API
+     * surface.
+     *
+     * This will ignore any class that is inaccessible as it cannot be part of the API. A
+     * [ClassItem] may be created for it later if needed, e.g. if it is a super class of an
+     * accessible class.
+     */
+    private fun createPossibleApiClass(
+        psiClass: PsiClass,
+        origin: ClassOrigin,
+    ): ClassItem? {
+        if (psiClass.containingClass != null) error("$psiClass is not a top level class")
+
+        // Ignore inaccessible classes.
+        val modifiers = PsiModifierItem.create(codebase, psiClass)
+        if (!modifiers.isAccessible) {
+            deferredHeavyweightPsiClasses[psiClass.qualifiedName!!] = psiClass
+            return null
+        }
+
+        return createTopLevelClassAndContents(psiClass, origin, modifiers)
+    }
+
+    /** Create a top level class, their inner classes and all the other members. */
+    private fun createTopLevelClassAndContents(
+        psiClass: PsiClass,
+        origin: ClassOrigin,
+        modifiers: MutableModifierList = PsiModifierItem.create(codebase, psiClass),
+    ): ClassItem {
+        if (psiClass.containingClass != null) error("$psiClass is not a top level class")
+        return createClass(
+            psiClass,
+            null,
+            globalTypeItemFactory,
+            origin,
+            modifiers = modifiers,
+        )
+    }
+
+    private fun createClass(
+        psiClass: PsiClass,
+        containingClassItem: ClassItem?,
+        enclosingClassTypeItemFactory: PsiTypeItemFactory,
+        origin: ClassOrigin,
+        modifiers: MutableModifierList = PsiModifierItem.create(codebase, psiClass),
+    ): ClassItem {
+        val packageName = getPackageName(psiClass)
+
+        // If the package could not be found then report an error.
+        findPsiPackage(packageName)
+            ?: run {
+                val directory =
+                    psiClass.containingFile.containingDirectory.virtualFile.canonicalPath
+                reporter.report(
+                    Issues.INVALID_PACKAGE,
+                    psiClass,
+                    "Could not find package $packageName for class ${psiClass.qualifiedName}." +
+                        " This is most likely due to a mismatch between the package statement" +
+                        " and the directory $directory"
+                )
+            }
+
+        val packageItem = codebase.packageTracker.findOrCreatePackage(packageName)
+
+        if (psiClass is PsiTypeParameter) {
+            error(
+                "Must not be called with PsiTypeParameter; use PsiTypeParameterItem.create(...) instead"
+            )
+        }
+        val qualifiedName = psiClass.classQualifiedName
+        val classKind = getClassKind(psiClass)
+        val isKotlin = psiClass.isKotlin()
+        if (
+            classKind == ClassKind.ANNOTATION_TYPE &&
+                !hasExplicitRetention(modifiers, psiClass, isKotlin)
+        ) {
+            modifiers.addDefaultRetentionPolicyAnnotation(codebase, isKotlin)
+        }
+        // Create the TypeParameterList for this before wrapping any of the other types used by
+        // it as they may reference a type parameter in the list.
+        val (typeParameterList, classTypeItemFactory) =
+            PsiTypeParameterList.create(
+                codebase,
+                enclosingClassTypeItemFactory,
+                "class $qualifiedName",
+                psiClass
+            )
+        val (superClassType, interfaceTypes) =
+            computeSuperTypes(psiClass, classKind, classTypeItemFactory)
+        val classItem =
+            PsiClassItem(
+                codebase = codebase,
+                psiClass = psiClass,
+                modifiers = modifiers,
+                documentationFactory = PsiItemDocumentation.factory(psiClass, codebase),
+                classKind = classKind,
+                containingClass = containingClassItem,
+                containingPackage = packageItem,
+                qualifiedName = qualifiedName,
+                typeParameterList = typeParameterList,
+                origin = origin,
+                superClassType = superClassType,
+                interfaceTypes = interfaceTypes,
+            )
+        // Construct the children
+        val psiMethods = psiClass.methods
+        // create methods
+        for (psiMethod in psiMethods) {
+            if (psiMethod.isConstructor) {
+                val constructor =
+                    PsiConstructorItem.create(
+                        codebase,
+                        classItem,
+                        psiMethod,
+                        classTypeItemFactory,
+                    )
+                addOverloadedKotlinConstructorsIfNecessary(
+                    classItem,
+                    classTypeItemFactory,
+                    constructor
+                )
+                classItem.addConstructor(constructor)
+            } else {
+                val method =
+                    PsiMethodItem.create(codebase, classItem, psiMethod, classTypeItemFactory)
+                if (!method.isEnumSyntheticMethod()) {
+                    classItem.addMethod(method)
+                }
+            }
+        }
+        // Note that this is dependent on the constructor filtering above. UAST sometimes
+        // reports duplicate primary constructors, e.g.: the implicit no-arg constructor
+        val constructors = classItem.constructors()
+        constructors.singleOrNull { it.isPrimary }?.let { classItem.primaryConstructor = it }
+        val hasImplicitDefaultConstructor = hasImplicitDefaultConstructor(psiClass)
+        if (hasImplicitDefaultConstructor) {
+            assert(constructors.isEmpty())
+            classItem.addConstructor(classItem.createDefaultConstructor())
+        }
+        val psiFields = psiClass.fields
+        if (psiFields.isNotEmpty()) {
+            for (psiField in psiFields) {
+                val fieldItem =
+                    PsiFieldItem.create(codebase, classItem, psiField, classTypeItemFactory)
+                classItem.addField(fieldItem)
+            }
+        }
+        val methods = classItem.methods()
+        if (isKotlin && methods.isNotEmpty()) {
+            val getters = mutableMapOf<String, PsiMethodItem>()
+            val setters = mutableMapOf<String, PsiMethodItem>()
+            val backingFields = classItem.fields().associateBy({ it.name() }) { it as PsiFieldItem }
+            val constructorParameters =
+                classItem.primaryConstructor
+                    ?.parameters()
+                    ?.map { it as PsiParameterItem }
+                    ?.filter { (it.sourcePsi as? KtParameter)?.isPropertyParameter() ?: false }
+                    ?.associateBy { it.name() }
+                    .orEmpty()
+
+            for (method in methods) {
+                if (method.isKotlinProperty()) {
+                    method as PsiMethodItem
+                    val name =
+                        when (val sourcePsi = method.sourcePsi) {
+                            is KtProperty -> sourcePsi.name
+                            is KtPropertyAccessor -> sourcePsi.property.name
+                            is KtParameter -> sourcePsi.name
+                            else -> null
+                        }
+                            ?: continue
+
+                    if (method.parameters().isEmpty()) {
+                        if (!method.name().startsWith("component")) {
+                            getters[name] = method
+                        }
+                    } else {
+                        setters[name] = method
+                    }
+                }
+            }
+
+            for ((name, getter) in getters) {
+                val type = getter.returnType() as? PsiTypeItem ?: continue
+                val propertyItem =
+                    PsiPropertyItem.create(
+                        codebase = codebase,
+                        containingClass = classItem,
+                        name = name,
+                        type = type,
+                        getter = getter,
+                        setter = setters[name],
+                        constructorParameter = constructorParameters[name],
+                        backingField = backingFields[name]
+                    )
+                classItem.addProperty(propertyItem)
+            }
+        }
+        // This actually gets all nested classes not just inner, i.e. non-static nested,
+        // classes.
+        val psiNestedClasses = psiClass.innerClasses
+        for (psiNestedClass in psiNestedClasses) {
+            createClass(
+                psiClass = psiNestedClass,
+                containingClassItem = classItem,
+                enclosingClassTypeItemFactory = classTypeItemFactory,
+                origin = origin,
+            )
+        }
+        return classItem
+    }
+
+    private fun hasExplicitRetention(
+        modifiers: BaseModifierList,
+        psiClass: PsiClass,
+        isKotlin: Boolean
+    ): Boolean {
+        if (modifiers.hasAnnotation(AnnotationItem::isRetention)) {
+            return true
+        }
+        if (isKotlin && psiClass is UClass) {
+            // In Kotlin some annotations show up on the Java facade only; for example,
+            // a @DslMarker annotation will imply a runtime annotation which is present
+            // in the java facade, not in the source list of annotations
+            val modifierList = psiClass.modifierList
+            if (
+                modifierList != null &&
+                    modifierList.annotations.any { isRetention(it.qualifiedName) }
+            ) {
+                return true
+            }
+        }
+        return false
+    }
+
+    /**
+     * Compute the super types for the class.
+     *
+     * Returns a pair of the optional super class type and the possibly empty list of interface
+     * types.
+     */
+    private fun computeSuperTypes(
+        psiClass: PsiClass,
+        classKind: ClassKind,
+        classTypeItemFactory: PsiTypeItemFactory
+    ): Pair<ClassTypeItem?, List<ClassTypeItem>> {
+
+        // A map from the qualified type name to the corresponding [KtTypeReference]. This is
+        // empty for non-Kotlin code, otherwise it maps from the qualified type name of a
+        // super type to the associated [KtTypeReference]. The qualified name is used to map
+        // between them because Kotlin does not differentiate between `implements` and `extends`
+        // lists and just has one super type list. The qualified name is safe because a class
+        // cannot implement/extend the same generic type multiple times with different type
+        // arguments so the qualified name should be unique among the super type list.
+        // The [KtTypeReference] is needed to access the type nullability of the generic type
+        // arguments.
+        val qualifiedNameToKt =
+            if (psiClass is UClass) {
+                psiClass.uastSuperTypes.associateBy({ it.getQualifiedName() }) {
+                    it.sourcePsi as KtTypeReference
+                }
+            } else emptyMap()
+
+        // Get the [KtTypeReference], if any, associated with ths [PsiType] which must be a
+        // [PsiClassType] as that is the only type allowed in an extends/implements list.
+        fun PsiType.ktTypeReference(): KtTypeReference? {
+            val qualifiedName = (this as PsiClassType).computeQualifiedName()
+            return qualifiedNameToKt[qualifiedName]
+        }
+
+        // Construct the super class type if needed and available.
+        val superClassType =
+            if (classKind != ClassKind.INTERFACE) {
+                val superClassPsiType = psiClass.superClassType as? PsiType
+                superClassPsiType?.let { superClassType ->
+                    val ktTypeRef = superClassType.ktTypeReference()
+                    classTypeItemFactory.getSuperClassType(PsiTypeInfo(superClassType, ktTypeRef))
+                }
+            } else null
+
+        // Get the interfaces from the appropriate list.
+        val interfaces =
+            if (classKind == ClassKind.INTERFACE || classKind == ClassKind.ANNOTATION_TYPE) {
+                // An interface uses "extends <interfaces>", either explicitly for normal
+                // interfaces or implicitly for annotations.
+                psiClass.extendsListTypes
+            } else {
+                // A class uses "extends <interfaces>".
+                psiClass.implementsListTypes
+            }
+
+        // Map them to PsiTypeItems.
+        val interfaceTypes =
+            interfaces.map { interfaceType ->
+                val ktTypeRef = interfaceType.ktTypeReference()
+                classTypeItemFactory.getInterfaceType(PsiTypeInfo(interfaceType, ktTypeRef))
+            }
+        return Pair(superClassType, interfaceTypes)
+    }
+
+    private fun getClassKind(psiClass: PsiClass): ClassKind {
+        return when {
+            psiClass.isAnnotationType -> ClassKind.ANNOTATION_TYPE
+            psiClass.isInterface -> ClassKind.INTERFACE
+            psiClass.isEnum -> ClassKind.ENUM
+            psiClass is PsiTypeParameter ->
+                error("Must not call this with a PsiTypeParameter - $psiClass")
+            else -> ClassKind.CLASS
+        }
+    }
+
+    private fun hasImplicitDefaultConstructor(psiClass: PsiClass): Boolean {
+        if (psiClass.name?.startsWith("-") == true) {
+            // Deliberately hidden; see examples like
+            //     @file:JvmName("-ViewModelExtensions") // Hide from Java sources in the IDE.
+            return false
+        }
+
+        if (psiClass is UClass && psiClass.sourcePsi == null) {
+            // Top level kt classes (FooKt for Foo.kt) do not have implicit default constructor
+            return false
+        }
+
+        val constructors = psiClass.constructors
+        return constructors.isEmpty() &&
+            !psiClass.isInterface &&
+            !psiClass.isAnnotationType &&
+            !psiClass.isEnum
+    }
+
+    /**
+     * Returns true if overloads of this constructor should be checked separately when checking the
+     * signature of this constructor.
+     *
+     * This works around the issue of actual callable not generating overloads for @JvmOverloads
+     * annotation when the default is specified on expect side
+     * (https://youtrack.jetbrains.com/issue/KT-57537).
+     */
+    private fun PsiConstructorItem.shouldExpandOverloads(): Boolean {
+        val ktFunction = (psiMethod as? UMethod)?.sourcePsi as? KtFunction ?: return false
+        return modifiers.isActual() &&
+            psiMethod.hasAnnotation(JvmStandardClassIds.JVM_OVERLOADS_FQ_NAME.asString()) &&
+            // It is /technically/ invalid to have actual functions with default values, but
+            // some places suppress the compiler error, so we should handle it here too.
+            ktFunction.valueParameters.none { it.hasDefaultValue() } &&
+            parameters().any { it.hasDefaultValue() }
+    }
+
+    /**
+     * Add overloads of [constructor] if necessary.
+     *
+     * Workaround for https://youtrack.jetbrains.com/issue/KT-57537.
+     *
+     * For each parameter with a default value in [constructor] this adds a [ConstructorItem] that
+     * excludes that parameter and all following parameters with default values.
+     */
+    private fun addOverloadedKotlinConstructorsIfNecessary(
+        classItem: PsiClassItem,
+        enclosingClassTypeItemFactory: PsiTypeItemFactory,
+        constructor: PsiConstructorItem,
+    ) {
+        if (!constructor.shouldExpandOverloads()) {
+            return
+        }
+
+        val parameters = constructor.parameters()
+
+        // Create an overload of the constructor for each parameter that has a default value. The
+        // constructor will exclude that parameter and all following parameters that have default
+        // values.
+        for (currentParameterIndex in parameters.indices) {
+            val currentParameter = parameters[currentParameterIndex]
+            // There is no need to create an overload if the parameter does not have default value.
+            if (!currentParameter.hasDefaultValue()) continue
+
+            // Create an overloaded constructor.
+            val overloadConstructor =
+                PsiConstructorItem.create(
+                    codebase,
+                    classItem,
+                    constructor.psiMethod,
+                    enclosingClassTypeItemFactory,
+                    psiParametersGetter = {
+                        parameters.mapIndexedNotNull { index, parameterItem ->
+                            // Ignore the current parameter as well as any following parameters
+                            // with default values.
+                            if (index >= currentParameterIndex && parameterItem.hasDefaultValue())
+                                null
+                            else (parameterItem as PsiParameterItem).psiParameter
+                        }
+                    },
+                )
+
+            classItem.addConstructor(overloadConstructor)
+        }
+    }
+
+    private fun findOrCreateClass(qualifiedName: String): ClassItem? {
+        // Check to see if the class has already been seen and if so return it immediately.
+        codebase.findClass(qualifiedName)?.let {
+            return it
+        }
+
+        // Create the ClassItem from a heavyweight PsiClass, if available.
+        deferredHeavyweightPsiClasses.remove(qualifiedName)?.let {
+            return findOrCreateClass(it)
+        }
+
+        // The following cannot find a class whose name does not correspond to the file name, e.g.
+        // in Java a class that is a second top level class.
+        val finder = JavaPsiFacade.getInstance(project)
+        val psiClass =
+            finder.findClass(qualifiedName, GlobalSearchScope.allScope(project)) ?: return null
+        return findOrCreateClass(psiClass)
+    }
+
+    /**
+     * Identifies a point in the [ClassItem] nesting structure where new [ClassItem]s need
+     * inserting.
+     */
+    data class NewClassInsertionPoint(
+        /**
+         * The [PsiClass] that is the root of the nested classes that need creation, is a top level
+         * class if [containingClassItem] is `null`.
+         */
+        val missingPsiClass: PsiClass,
+
+        /** The containing class item, or `null` if the top level. */
+        val containingClassItem: ClassItem?,
+    )
+
+    /**
+     * Called when no [ClassItem] was found by [PsiBasedCodebase.findClass]`([PsiClass]) when called
+     * on [psiClass].
+     *
+     * The purpose of this is to find where a new [ClassItem] should be inserted in the nested class
+     * structure. It finds the outermost [PsiClass] with no associated [ClassItem] but which is
+     * either a top level class or whose containing [PsiClass] does have an associated [ClassItem].
+     * That is the point where new classes need to be created.
+     *
+     * e.g. if the nesting structure is `A.B.C` and `A` has already been created then the insertion
+     * point would consist of [ClassItem] for `A` (the containing class item) and the [PsiClass] for
+     * `B` (the outermost [PsiClass] with no associated item).
+     *
+     * If none had already been created then it would return an insertion point consisting of no
+     * containing class item and the [PsiClass] for `A`.
+     */
+    private fun findNewClassInsertionPoint(psiClass: PsiClass): NewClassInsertionPoint {
+        var current = psiClass
+        do {
+            // If the current has no containing class then it has reached the top level class so
+            // return an insertion point that has no containing class item and the current class.
+            val containing = current.containingClass ?: return NewClassInsertionPoint(current, null)
+
+            // If the containing class has a matching class item then return an insertion point that
+            // uses that containing class item and the current class.
+            codebase.findClass(containing)?.let { containingClassItem ->
+                return NewClassInsertionPoint(current, containingClassItem)
+            }
+            current = containing
+        } while (true)
+    }
+
+    internal fun findOrCreateClass(psiClass: PsiClass): ClassItem {
+        if (psiClass is PsiTypeParameter) {
+            error(
+                "Must not be called with PsiTypeParameter; call findOrCreateTypeParameter(...) instead"
+            )
+        }
+
+        // If it has already been created then return it.
+        codebase.findClass(psiClass)?.let {
+            return it
+        }
+
+        // Otherwise, find an insertion point at which new classes should be created.
+        val (missingPsiClass, containingClassItem) = findNewClassInsertionPoint(psiClass)
+
+        // Create a top level or nested class as appropriate.
+        val createdClassItem =
+            if (containingClassItem == null) {
+                // Try and determine the origin of the class.
+                val containingFile = missingPsiClass.containingFile
+                val origin =
+                    if (containingFile == null || containingFile.name.endsWith(".class"))
+                        ClassOrigin.CLASS_PATH
+                    else ClassOrigin.SOURCE_PATH
+
+                createTopLevelClassAndContents(
+                    missingPsiClass,
+                    origin,
+                )
+            } else {
+                createClass(
+                    missingPsiClass,
+                    containingClassItem,
+                    globalTypeItemFactory.from(containingClassItem),
+                    origin = containingClassItem.origin,
+                )
+            }
+
+        // Select the class item to return.
+        return if (missingPsiClass == psiClass) {
+            // The created class item was what was requested so just return it.
+            createdClassItem
+        } else {
+            // Otherwise, a nested class was requested so find it. It was created when its
+            // containing class was created.
+            codebase.findClass(psiClass)!!
+        }
+    }
+
+    private fun getPackageName(clz: PsiClass): String {
+        var top: PsiClass? = clz
+        while (top?.containingClass != null) {
+            top = top.containingClass
+        }
+        top ?: return ""
+
+        val simpleName = top.simpleName
+        val qualifiedName = top.classQualifiedName
+
+        if (simpleName == qualifiedName) {
+            return ""
+        }
+
+        return qualifiedName.substring(0, qualifiedName.length - 1 - simpleName.length)
+    }
+
+    internal fun createAnnotation(
+        source: String,
+        context: Item?,
+    ): AnnotationItem? {
+        val psiAnnotation = createPsiAnnotation(source, (context as? PsiItem)?.psi())
+        return PsiAnnotationItem.create(codebase, psiAnnotation)
+    }
+
+    fun getPsiTypeForPsiParameter(psiParameter: PsiParameter): PsiType {
+        // UAST workaround: nullity of element type in last `vararg` parameter's array type
+        val psiType = psiParameter.type
+        return if (
+            psiParameter is UParameter &&
+                psiParameter.sourcePsi is KtParameter &&
+                psiParameter.isVarArgs && // last `vararg`
+                psiType is PsiArrayType
+        ) {
+            val ktParameter = psiParameter.sourcePsi as KtParameter
+            val annotationProvider =
+                when (uastResolveService?.nullability(ktParameter)) {
+                    KaTypeNullability.NON_NULLABLE -> getNonNullAnnotationProvider()
+                    KaTypeNullability.NULLABLE -> getNullableAnnotationProvider()
+                    else -> null
+                }
+            val annotatedType =
+                if (annotationProvider != null) {
+                    psiType.componentType.annotate(annotationProvider)
+                } else {
+                    psiType.componentType
+                }
+            PsiEllipsisType(annotatedType, annotatedType.annotationProvider)
+        } else {
+            psiType
+        }
+    }
+
+    private val uastResolveService: BaseKotlinUastResolveProviderService? by lazy {
+        ApplicationManager.getApplication()
+            .getService(BaseKotlinUastResolveProviderService::class.java)
+    }
+
+    private var nonNullAnnotationProvider: TypeAnnotationProvider? = null
+    private var nullableAnnotationProvider: TypeAnnotationProvider? = null
+
+    /** Type annotation provider which provides androidx.annotation.NonNull */
+    private fun getNonNullAnnotationProvider(): TypeAnnotationProvider {
+        return nonNullAnnotationProvider
+            ?: run {
+                val provider =
+                    TypeAnnotationProvider.Static.create(
+                        arrayOf(createPsiAnnotation("@$ANDROIDX_NONNULL"))
+                    )
+                nonNullAnnotationProvider = provider
+                provider
+            }
+    }
+
+    /** Type annotation provider which provides androidx.annotation.Nullable */
+    private fun getNullableAnnotationProvider(): TypeAnnotationProvider {
+        return nullableAnnotationProvider
+            ?: run {
+                val provider =
+                    TypeAnnotationProvider.Static.create(
+                        arrayOf(createPsiAnnotation("@$ANDROIDX_NULLABLE"))
+                    )
+                nullableAnnotationProvider = provider
+                provider
+            }
+    }
+
+    internal fun initializeFromJar(jarFile: File) {
+        // Extract the list of class names from the jar file.
+        val classNames = buildList {
+            try {
+                ZipFile(jarFile).use { jar ->
+                    for (entry in jar.entries().iterator()) {
+                        val fileName = entry.name
+                        if (fileName.contains("$")) {
+                            // skip inner classes
+                            continue
+                        }
+                        if (!fileName.endsWith(SdkConstants.DOT_CLASS)) {
+                            // skip entries that are not .class files.
+                            continue
+                        }
+
+                        val qualifiedName =
+                            fileName.removeSuffix(SdkConstants.DOT_CLASS).replace('/', '.')
+                        if (qualifiedName.endsWith(".package-info")) {
+                            // skip package-info files.
+                            continue
+                        }
+
+                        add(qualifiedName)
+                    }
+                }
+            } catch (e: IOException) {
+                reporter.report(Issues.IO_ERROR, jarFile, e.message ?: e.toString())
+            }
+        }
+
+        // Create the initial set of packages that were found in the jar files. When loading from a
+        // jar there is no package documentation so this will only create the root package.
+        codebase.packageTracker.createInitialPackages(PackageDocs.EMPTY)
+
+        // Find all classes referenced from the class
+        val facade = JavaPsiFacade.getInstance(project)
+        val scope = GlobalSearchScope.allScope(project)
+
+        val isFromClassPath = codebase.isFromClassPath()
+        val origin = if (isFromClassPath) ClassOrigin.CLASS_PATH else ClassOrigin.COMMAND_LINE
+        for (className in classNames) {
+            val psiClass = facade.findClass(className, scope) ?: continue
+
+            val classItem = createPossibleApiClass(psiClass, origin) ?: continue
+            codebase.addTopLevelClassFromSource(classItem)
+        }
+    }
+
+    internal fun initializeFromSources(sourceSet: SourceSet) {
+        // Get the list of `PsiFile`s from the `SourceSet`.
+        val psiFiles = Extractor.createUnitsForFiles(uastEnvironment.ideaProject, sourceSet.sources)
+
+        // Split the `PsiFile`s into `PsiClass`es and `package-info.java` `PsiJavaFile`s.
+        val (packageInfoFiles, psiClasses) = splitPsiFilesIntoClassesAndPackageInfoFiles(psiFiles)
+
+        // Gather all package related javadoc.
+        val packageDocs =
+            gatherPackageJavadoc(
+                reporter,
+                sourceSet,
+                packageNameFilter = { findPsiPackage(it) != null },
+                packageInfoFiles,
+                packageInfoDocExtractor = { getOptionalPackageDocFromPackageInfoFile(it) },
+            )
+
+        // Create the initial set of packages that were found in the source files.
+        codebase.packageTracker.createInitialPackages(packageDocs)
+
+        // Process the `PsiClass`es.
+        for (psiClass in psiClasses) {
+            val classItem =
+                createPossibleApiClass(
+                    psiClass,
+                    // Sources always come from the command line.
+                    ClassOrigin.COMMAND_LINE,
+                )
+                    ?: continue
+            codebase.addTopLevelClassFromSource(classItem)
+        }
+    }
+
+    /**
+     * Split the [psiFiles] into separate `package-info.java` [PsiJavaFile]s and [PsiClass]es.
+     *
+     * During the processing this checks each [PsiFile] for unresolved imports and each [PsiClass]
+     * for syntax errors.
+     */
+    private fun splitPsiFilesIntoClassesAndPackageInfoFiles(
+        psiFiles: List<PsiFile>
+    ): Pair<List<PsiJavaFile>, List<PsiClass>> {
+        // A set to track `@JvmMultifileClass`es that have already been added to psiClasses.
+        val multiFileClassNames = HashSet<FqName>()
+
+        val psiClasses = mutableListOf<PsiClass>()
+        val packageInfoFiles = mutableListOf<PsiJavaFile>()
+
+        // Make sure we only process the files once; sometimes there's overlap in the source lists
+        for (psiFile in psiFiles.asSequence().distinct()) {
+            checkForUnresolvedImports(psiFile)
+
+            val classes = getPsiClassesFromPsiFile(psiFile)
+            when {
+                classes.isEmpty() && psiFile is PsiJavaFile -> {
+                    if (psiFile.name == JAVA_PACKAGE_INFO) {
+                        packageInfoFiles.add(psiFile)
+                    }
+                }
+                else -> {
+                    for (psiClass in classes) {
+                        checkForSyntaxErrors(psiClass)
+
+                        // Multi file classes appear identically from each file they're defined in,
+                        // don't add duplicates
+                        val multiFileClassName = getOptionalMultiFileClassName(psiClass)
+                        if (multiFileClassName != null) {
+                            if (multiFileClassName in multiFileClassNames) {
+                                continue
+                            } else {
+                                multiFileClassNames.add(multiFileClassName)
+                            }
+                        }
+
+                        psiClasses.add(psiClass)
+                    }
+                }
+            }
+        }
+        return Pair(packageInfoFiles, psiClasses)
+    }
+
+    /** Check to see if [psiFile] contains any unresolved imports. */
+    private fun checkForUnresolvedImports(psiFile: PsiFile?) {
+        // Visiting psiFile directly would eagerly load the entire file even though we only need
+        // the importList here.
+        (psiFile as? PsiJavaFile)
+            ?.importList
+            ?.accept(
+                object : JavaRecursiveElementVisitor() {
+                    override fun visitImportStatement(element: PsiImportStatement) {
+                        super.visitImportStatement(element)
+                        if (element.resolve() == null) {
+                            reporter.report(
+                                Issues.UNRESOLVED_IMPORT,
+                                element,
+                                "Unresolved import: `${element.qualifiedName}`"
+                            )
+                        }
+                    }
+                }
+            )
+    }
+
+    /** Get, the possibly empty, list of [PsiClass]es from the [psiFile]. */
+    private fun getPsiClassesFromPsiFile(psiFile: PsiFile): List<PsiClass> {
+        // First, check for Java classes, return any that are found.
+        (psiFile as? PsiClassOwner)?.classes?.toList()?.let { if (it.isNotEmpty()) return it }
+
+        // Then, check for Kotlin classes, returning any that are found, or an empty list.
+        val uFile = UastFacade.convertElementWithParent(psiFile, UFile::class.java) as? UFile?
+        return uFile?.classes?.map { it }?.toList() ?: emptyList()
+    }
+
+    /**
+     * Get the optional [MutablePackageDoc] from [psiFile].
+     *
+     * @param psiFile must be a `package-info.java` file.
+     */
+    private fun getOptionalPackageDocFromPackageInfoFile(psiFile: PsiJavaFile): MutablePackageDoc? {
+        val packageStatement = psiFile.packageStatement ?: return null
+        val packageName = packageStatement.packageName
+
+        // Make sure that this is actually a package.
+        findPsiPackage(packageName) ?: return null
+
+        // Look for javadoc on the package statement; this is NOT handed to us on the PsiPackage!
+        val comment = PsiTreeUtil.getPrevSiblingOfType(packageStatement, PsiDocComment::class.java)
+        if (comment != null) {
+            return MutablePackageDoc(
+                qualifiedName = packageName,
+                fileLocation = PsiFileLocation.fromPsiElement(psiFile),
+                commentFactory =
+                    PsiItemDocumentation.factory(packageStatement, codebase, comment.text),
+            )
+        }
+
+        // No comment could be found.
+        return null
+    }
+
+    /** Check the [psiClass] for any syntax errors. */
+    private fun checkForSyntaxErrors(psiClass: PsiClass) {
+        psiClass.accept(
+            object : JavaRecursiveElementVisitor() {
+                override fun visitErrorElement(element: PsiErrorElement) {
+                    super.visitErrorElement(element)
+                    reporter.report(
+                        Issues.INVALID_SYNTAX,
+                        element,
+                        "Syntax error: `${element.errorDescription}`"
+                    )
+                }
+
+                override fun visitCodeBlock(block: PsiCodeBlock) {
+                    // Ignore to avoid eagerly parsing all method bodies.
+                }
+
+                override fun visitDocComment(comment: PsiDocComment) {
+                    // Ignore to avoid eagerly parsing all doc comments.
+                    // Doc comments cannot contain error elements.
+                }
+            }
+        )
+    }
+
+    /** Get the optional multi file class name. */
+    private fun getOptionalMultiFileClassName(psiClass: PsiClass): FqName? {
+        val ktLightClass = (psiClass as? UClass)?.javaPsi as? KtLightClassForFacade
+        val multiFileClassName =
+            if (ktLightClass?.multiFileClass == true) {
+                ktLightClass.facadeClassFqName
+            } else {
+                null
+            }
+        return multiFileClassName
+    }
+}
+
+/**
+ * Get the simple name of a named class or type parameter.
+ *
+ * A [PsiClass] is used to represent named classes, type parameters, anonymous and local classes.
+ * So, its [PsiClass.getName] can sometimes be `null`. However, Metalava only gets the name for
+ * named classes and type parameters which never return `null`. So, this extension property forces
+ * it to be non-null.
+ */
+internal val PsiClass.simpleName
+    get() = name!!
+
+/**
+ * Get the qualified name of a name class.
+ *
+ * A [PsiClass] is used to represent named classes, type parameters, anonymous and local classes.
+ * So, its [PsiClass.getQualifiedName] can sometimes be `null`. However, Metalava only gets the
+ * qualified name for name classes which never return `null`. So, this extension property forces it
+ * to be non-null.
+ */
+internal val PsiClass.classQualifiedName
+    get() = qualifiedName!!
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
index cceeacb24..0d2e3df4c 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
@@ -16,71 +16,88 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PACKAGE_PRIVATE
 import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.model.item.DefaultConstructorItem
+import com.android.tools.metalava.model.item.ParameterItemsFactory
+import com.android.tools.metalava.model.psi.PsiCallableItem.Companion.parameterList
+import com.android.tools.metalava.model.psi.PsiCallableItem.Companion.throwsTypes
 import com.android.tools.metalava.reporter.FileLocation
 import com.intellij.psi.JavaPsiFacade
 import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiParameter
 import org.jetbrains.kotlin.psi.KtClassOrObject
 import org.jetbrains.kotlin.psi.KtPrimaryConstructor
 import org.jetbrains.uast.UMethod
 
-class PsiConstructorItem
+internal class PsiConstructorItem
 private constructor(
-    codebase: PsiBasedCodebase,
-    psiMethod: PsiMethod,
+    override val codebase: PsiBasedCodebase,
+    override val psiMethod: PsiMethod,
     fileLocation: FileLocation = PsiFileLocation(psiMethod),
-    containingClass: PsiClassItem,
+    containingClass: ClassItem,
     name: String,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    parameters: List<PsiParameterItem>,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    parameterItemsFactory: ParameterItemsFactory,
     returnType: ClassTypeItem,
     typeParameterList: TypeParameterList,
     throwsTypes: List<ExceptionTypeItem>,
-    val implicitConstructor: Boolean = false,
+    implicitConstructor: Boolean = false,
     override val isPrimary: Boolean = false
 ) :
-    PsiMethodItem(
+    DefaultConstructorItem(
         codebase = codebase,
-        modifiers = modifiers,
-        documentation = documentation,
-        psiMethod = psiMethod,
         fileLocation = fileLocation,
-        containingClass = containingClass,
+        itemLanguage = psiMethod.itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
         name = name,
-        returnType = returnType,
-        parameters = parameters,
+        containingClass = containingClass,
         typeParameterList = typeParameterList,
+        returnType = returnType,
+        parameterItemsFactory = parameterItemsFactory,
         throwsTypes = throwsTypes,
+        callableBodyFactory = { PsiCallableBody(it as PsiCallableItem) },
+        implicitConstructor = implicitConstructor,
     ),
-    ConstructorItem {
-
-    override fun isImplicitConstructor(): Boolean = implicitConstructor
-
-    override fun isConstructor(): Boolean = true
-
-    override var superConstructor: ConstructorItem? = null
-
-    override fun superMethods(): List<MethodItem> = emptyList()
+    PsiCallableItem {
 
     companion object {
         internal fun create(
             codebase: PsiBasedCodebase,
-            containingClass: PsiClassItem,
+            containingClass: ClassItem,
             psiMethod: PsiMethod,
             enclosingClassTypeItemFactory: PsiTypeItemFactory,
+            psiParametersGetter: (PsiMethod) -> List<PsiParameter> = { it.psiParameters },
         ): PsiConstructorItem {
             assert(psiMethod.isConstructor)
             val name = psiMethod.name
-            val commentText = javadoc(psiMethod, codebase.allowReadingComments)
-            val modifiers = modifiers(codebase, psiMethod, commentText)
+            val modifiers = PsiModifierItem.create(codebase, psiMethod)
+
+            // After KT-13495, "all constructors of `sealed` classes now have `protected`
+            // visibility by default," and (S|U)LC follows that (hence the same in UAST).
+            // However, that change was made to allow more flexible class hierarchy and
+            // nesting. If they're compiled to JVM bytecode, sealed class's ctor is still
+            // technically `private` to block instantiation from outside class hierarchy.
+            // Another synthetic constructor, along with an internal ctor marker, is added
+            // for subclasses of a sealed class. Therefore, from Metalava's perspective,
+            // it is not necessary to track such semantically protected ctor. Here we force
+            // set the visibility to `private` back to ignore it during signature writing.
+            if (containingClass.modifiers.isSealed()) {
+                modifiers.setVisibilityLevel(VisibilityLevel.PRIVATE)
+            }
+
             // Create the TypeParameterList for this before wrapping any of the other types used by
             // it as they may reference a type parameter in the list.
             val (typeParameterList, constructorTypeItemFactory) =
@@ -90,36 +107,43 @@ private constructor(
                     "constructor $name",
                     psiMethod
                 )
-            val parameters = parameterList(codebase, psiMethod, constructorTypeItemFactory)
             val constructor =
                 PsiConstructorItem(
                     codebase = codebase,
                     psiMethod = psiMethod,
                     containingClass = containingClass,
                     name = name,
-                    documentation = commentText,
                     modifiers = modifiers,
-                    parameters = parameters,
+                    documentationFactory = PsiItemDocumentation.factory(psiMethod, codebase),
+                    parameterItemsFactory = { containingCallable ->
+                        parameterList(
+                            codebase,
+                            psiMethod,
+                            containingCallable as PsiCallableItem,
+                            constructorTypeItemFactory,
+                            psiParametersGetter(psiMethod),
+                        )
+                    },
                     returnType = containingClass.type(),
-                    implicitConstructor = false,
-                    isPrimary = (psiMethod as? UMethod)?.isPrimaryConstructor ?: false,
                     typeParameterList = typeParameterList,
                     throwsTypes = throwsTypes(psiMethod, constructorTypeItemFactory),
+                    implicitConstructor = false,
+                    isPrimary = (psiMethod as? UMethod)?.isPrimaryConstructor ?: false,
                 )
             return constructor
         }
 
         fun createDefaultConstructor(
             codebase: PsiBasedCodebase,
-            containingClass: PsiClassItem,
+            containingClass: ClassItem,
             psiClass: PsiClass,
+            visibilityLevel: VisibilityLevel,
         ): PsiConstructorItem {
             val name = psiClass.name!!
 
             val factory = JavaPsiFacade.getInstance(psiClass.project).elementFactory
             val psiMethod = factory.createConstructor(name, psiClass)
-            val modifiers = DefaultModifierList(codebase, PACKAGE_PRIVATE, null)
-            modifiers.setVisibilityLevel(containingClass.modifiers.getVisibilityLevel())
+            val modifiers = createImmutableModifiers(visibilityLevel)
 
             val item =
                 PsiConstructorItem(
@@ -130,13 +154,13 @@ private constructor(
                     fileLocation = containingClass.fileLocation,
                     containingClass = containingClass,
                     name = name,
-                    documentation = "",
                     modifiers = modifiers,
-                    parameters = emptyList(),
+                    documentationFactory = ItemDocumentation.NONE_FACTORY,
+                    parameterItemsFactory = { emptyList() },
                     returnType = containingClass.type(),
-                    implicitConstructor = true,
                     typeParameterList = TypeParameterList.NONE,
                     throwsTypes = emptyList(),
+                    implicitConstructor = true,
                 )
             return item
         }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
new file mode 100644
index 000000000..befae9ad6
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.findAnnotation
+import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.item.DefaultValue
+import org.jetbrains.kotlin.analysis.api.KaExperimentalApi
+import org.jetbrains.kotlin.analysis.api.analyze
+import org.jetbrains.kotlin.analysis.api.symbols.KaFunctionSymbol
+import org.jetbrains.kotlin.analysis.api.symbols.KaNamedFunctionSymbol
+import org.jetbrains.kotlin.analysis.api.symbols.KaParameterSymbol
+import org.jetbrains.kotlin.analysis.api.symbols.KaValueParameterSymbol
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtFunction
+import org.jetbrains.kotlin.psi.KtParameter
+import org.jetbrains.kotlin.psi.psiUtil.hasActualModifier
+import org.jetbrains.uast.UExpression
+import org.jetbrains.uast.UMethod
+import org.jetbrains.uast.UastFacade
+
+internal class PsiDefaultValue(private val item: PsiParameterItem) : DefaultValue {
+
+    override fun duplicate(parameter: ParameterItem) =
+        PsiDefaultValue(parameter as PsiParameterItem)
+
+    private var defaultValueAsString: String? = null
+
+    private fun defaultValueAsString(): String? {
+        if (defaultValueAsString == null) {
+            defaultValueAsString = item.computeDefaultValue()
+        }
+        return defaultValueAsString
+    }
+
+    override fun hasDefaultValue() = isDefaultValueKnown()
+
+    override fun isDefaultValueKnown(): Boolean {
+        val psiParameter = item.psiParameter
+        return if (psiParameter.isKotlin()) {
+            defaultValueAsString() != INVALID_VALUE
+        } else {
+            // Java: Look for @ParameterName annotation
+            item.modifiers.hasAnnotation(AnnotationItem::isDefaultValue)
+        }
+    }
+
+    override fun value() = defaultValueAsString()
+
+    @OptIn(KaExperimentalApi::class)
+    private fun PsiParameterItem.computeDefaultValue(): String? {
+        if (psiParameter.isKotlin()) {
+            val psiCallableItem = item.containingCallable() as PsiCallableItem
+            val ktFunction =
+                ((psiCallableItem.psi() as? UMethod)?.sourcePsi as? KtFunction)
+                    ?: return INVALID_VALUE
+
+            analyze(ktFunction) {
+                val function =
+                    if (ktFunction.hasActualModifier()) {
+                        ktFunction.symbol.getExpectsForActual().singleOrNull()
+                    } else {
+                        ktFunction.symbol
+                    }
+                if (function !is KaFunctionSymbol) return INVALID_VALUE
+                val symbol = getKtParameterSymbol(function) ?: return INVALID_VALUE
+                if (symbol is KaValueParameterSymbol && symbol.hasDefaultValue) {
+                    val defaultValue =
+                        (symbol.psi as? KtParameter)?.defaultValue ?: return INVALID_VALUE
+                    if (defaultValue is KtConstantExpression) {
+                        return defaultValue.text
+                    }
+
+                    val defaultExpression =
+                        UastFacade.convertElement(defaultValue, null, UExpression::class.java)
+                            as? UExpression
+                            ?: return INVALID_VALUE
+                    val constant = defaultExpression.evaluate()
+                    return if (constant != null && constant !is Pair<*, *>) {
+                        CodePrinter.constantToSource(constant)
+                    } else {
+                        // Expression: Compute from UAST rather than just using the source text
+                        // such that we can ensure references are fully qualified etc.
+                        codebase.printer.toSourceString(defaultExpression)
+                    }
+                }
+            }
+
+            return INVALID_VALUE
+        } else {
+            // Java: Look for @ParameterName annotation
+            val annotation = modifiers.findAnnotation(AnnotationItem::isDefaultValue)
+            if (annotation != null) {
+                return annotation.attributes.firstOrNull()?.value?.value()?.toString()
+            }
+        }
+
+        return null
+    }
+
+    private fun PsiParameterItem.getKtParameterSymbol(
+        functionSymbol: KaFunctionSymbol
+    ): KaParameterSymbol? {
+        if (isReceiver()) {
+            return functionSymbol.receiverParameter
+        }
+
+        // Perform matching based on parameter names, because indices won't work in the
+        // presence of @JvmOverloads where UAST generates multiple permutations of the
+        // method from the same KtParameters array.
+        val parameters = functionSymbol.valueParameters
+
+        val index = if (functionSymbol.isExtension) parameterIndex - 1 else parameterIndex
+        val isSuspend = (functionSymbol as? KaNamedFunctionSymbol)?.isSuspend == true
+        if (isSuspend && index >= parameters.size) {
+            // suspend functions have continuation as a last parameter, which is not
+            // defined in the symbol
+            return null
+        }
+
+        // Quick lookup first which usually works
+        if (index >= 0) {
+            val parameter = parameters[index]
+            if (parameter.name.asString() == name()) {
+                return parameter
+            }
+        }
+
+        for (parameter in parameters) {
+            if (parameter.name.asString() == name()) {
+                return parameter
+            }
+        }
+
+        // Fallback to handle scenario where the real parameter names are hidden by
+        // UAST (see UastKotlinPsiParameter which replaces parameter names to p$index)
+        if (index >= 0) {
+            val parameter = parameters[index]
+            if (!isReceiver()) {
+                return parameter
+            }
+        }
+
+        return null
+    }
+
+    companion object {
+
+        /**
+         * Private marker return value from [#computeDefaultValue] signifying that the parameter has
+         * a default value but we were unable to compute a suitable static string representation for
+         * it
+         */
+        const val INVALID_VALUE = "__invalid_value__"
+    }
+}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
index 2a38904ed..d21f12d45 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
@@ -135,6 +135,7 @@ class PsiEnvironmentManager(
         modelOptions: ModelOptions,
         allowReadingComments: Boolean,
         jdkHome: File?,
+        projectDescription: File?,
     ): SourceParser {
         return PsiSourceParser(
             psiEnvironmentManager = this,
@@ -145,6 +146,7 @@ class PsiEnvironmentManager(
             useK2Uast = modelOptions[PsiModelOptions.useK2Uast],
             allowReadingComments = allowReadingComments,
             jdkHome = jdkHome,
+            projectDescription = projectDescription,
         )
     }
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
index 3ba594f0f..023a89224 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
@@ -16,12 +16,20 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
+import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.isNonNullAnnotation
+import com.android.tools.metalava.model.item.DefaultFieldItem
+import com.android.tools.metalava.model.item.FieldValue
+import com.android.tools.metalava.reporter.Issues
 import com.intellij.psi.PsiCallExpression
 import com.intellij.psi.PsiClassType
 import com.intellij.psi.PsiEnumConstant
@@ -30,89 +38,137 @@ import com.intellij.psi.PsiModifierListOwner
 import com.intellij.psi.PsiPrimitiveType
 import com.intellij.psi.PsiReference
 import com.intellij.psi.impl.JavaConstantExpressionEvaluator
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtObjectDeclaration
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
+import org.jetbrains.kotlin.psi.psiUtil.isPublic
+import org.jetbrains.uast.UField
 
-class PsiFieldItem(
-    codebase: PsiBasedCodebase,
+internal class PsiFieldItem(
+    override val codebase: PsiBasedCodebase,
     private val psiField: PsiField,
-    containingClass: PsiClassItem,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
     name: String,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    private val fieldType: TypeItem,
+    containingClass: ClassItem,
+    type: TypeItem,
     private val isEnumConstant: Boolean,
-    private val fieldValue: PsiFieldValue?,
+    override val fieldValue: FieldValue?,
 ) :
-    PsiMemberItem(
+    DefaultFieldItem(
         codebase = codebase,
+        fileLocation = PsiFileLocation(psiField),
+        itemLanguage = psiField.itemLanguage,
         modifiers = modifiers,
-        documentation = documentation,
-        element = psiField,
-        containingClass = containingClass,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
         name = name,
+        containingClass = containingClass,
+        type = type,
+        isEnumConstant = isEnumConstant,
+        fieldValue = fieldValue,
     ),
-    FieldItem {
-
-    override var property: PsiPropertyItem? = null
-
-    override fun type(): TypeItem = fieldType
-
-    override fun initialValue(requireConstant: Boolean): Any? {
-        return fieldValue?.initialValue(requireConstant)
-    }
-
-    override fun isEnumConstant(): Boolean = isEnumConstant
+    FieldItem,
+    PsiItem {
 
     override fun psi(): PsiField = psiField
 
-    override fun duplicate(targetContainingClass: ClassItem): PsiFieldItem {
-        val duplicated =
-            create(
+    override var property: PropertyItem? = null
+
+    override fun duplicate(targetContainingClass: ClassItem) =
+        create(
                 codebase,
-                targetContainingClass as PsiClassItem,
+                targetContainingClass,
                 psiField,
                 codebase.globalTypeItemFactory.from(targetContainingClass),
             )
-        duplicated.inheritedFrom = containingClass
-
-        // Preserve flags that may have been inherited (propagated) from surrounding packages
-        if (targetContainingClass.hidden) {
-            duplicated.hidden = true
-        }
-        if (targetContainingClass.removed) {
-            duplicated.removed = true
-        }
-        if (targetContainingClass.docOnly) {
-            duplicated.docOnly = true
-        }
+            .also { duplicated -> duplicated.inheritedFrom = containingClass() }
 
-        return duplicated
-    }
-
-    override var inheritedFrom: ClassItem? = null
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
+    override fun ensureCompanionFieldJvmField() {
+        if (modifiers.isPublic() && modifiers.isFinal()) {
+            // UAST will inline const fields into the surrounding class, so we have to
+            // dip into Kotlin PSI to figure out if this field was really declared in
+            // a companion object
+            val psi = psi()
+            if (psi is UField) {
+                val sourcePsi = psi.sourcePsi
+                if (sourcePsi is KtProperty) {
+                    val companionClassName = sourcePsi.containingClassOrObject?.name
+                    if (companionClassName == "Companion") {
+                        // JvmField cannot be applied to const property
+                        // (https://github.com/JetBrains/kotlin/blob/dc7b1fbff946d1476cc9652710df85f65664baee/compiler/frontend.java/src/org/jetbrains/kotlin/resolve/jvm/checkers/JvmFieldApplicabilityChecker.kt#L46)
+                        if (!modifiers.isConst()) {
+                            if (modifiers.findAnnotation("kotlin.jvm.JvmField") == null) {
+                                codebase.reporter.report(
+                                    Issues.MISSING_JVMSTATIC,
+                                    this,
+                                    "Companion object constants like ${name()} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
+                                )
+                            } else if (modifiers.findAnnotation("kotlin.jvm.JvmStatic") != null) {
+                                codebase.reporter.report(
+                                    Issues.MISSING_JVMSTATIC,
+                                    this,
+                                    "Companion object constants like ${name()} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
+                                )
+                            }
+                        }
+                    }
+                } else if (sourcePsi is KtObjectDeclaration && sourcePsi.isCompanion()) {
+                    // We are checking if we have public properties that we can expect to be
+                    // constant
+                    // (that is, declared via `val`) but that aren't declared 'const' in a companion
+                    // object that are not annotated with @JvmField or annotated with @JvmStatic
+                    // https://developer.android.com/kotlin/interop#companion_constants
+                    val ktProperties =
+                        sourcePsi.declarations.filter { declaration ->
+                            declaration is KtProperty &&
+                                declaration.isPublic &&
+                                !declaration.isVar &&
+                                !declaration.hasModifier(KtTokens.CONST_KEYWORD) &&
+                                declaration.annotationEntries.none { annotationEntry ->
+                                    annotationEntry.shortName?.asString() == "JvmField"
+                                }
+                        }
+                    for (ktProperty in ktProperties) {
+                        if (
+                            ktProperty.annotationEntries.none { annotationEntry ->
+                                annotationEntry.shortName?.asString() == "JvmStatic"
+                            }
+                        ) {
+                            codebase.reporter.report(
+                                Issues.MISSING_JVMSTATIC,
+                                ktProperty,
+                                "Companion object constants like ${ktProperty.name} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
+                            )
+                        } else {
+                            codebase.reporter.report(
+                                Issues.MISSING_JVMSTATIC,
+                                ktProperty,
+                                "Companion object constants like ${ktProperty.name} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
+                            )
+                        }
+                    }
+                }
+            }
         }
-        return other is FieldItem &&
-            name == other.name() &&
-            containingClass == other.containingClass()
-    }
-
-    override fun hashCode(): Int {
-        return name.hashCode()
     }
 
     companion object {
         internal fun create(
             codebase: PsiBasedCodebase,
-            containingClass: PsiClassItem,
+            containingClass: ClassItem,
             psiField: PsiField,
             enclosingClassTypeItemFactory: PsiTypeItemFactory,
         ): PsiFieldItem {
             val name = psiField.name
-            val commentText = javadoc(psiField, codebase.allowReadingComments)
-            val modifiers = modifiers(codebase, psiField, commentText)
+            val modifiers = PsiModifierItem.create(codebase, psiField)
+
+            if (containingClass.classKind == ClassKind.INTERFACE) {
+                // All interface fields are implicitly public and static.
+                modifiers.setVisibilityLevel(VisibilityLevel.PUBLIC)
+                modifiers.setStatic(true)
+            }
 
             val isEnumConstant = psiField is PsiEnumConstant
 
@@ -139,11 +195,11 @@ class PsiFieldItem(
             return PsiFieldItem(
                 codebase = codebase,
                 psiField = psiField,
-                containingClass = containingClass,
-                name = name,
-                documentation = commentText,
+                documentationFactory = PsiItemDocumentation.factory(psiField, codebase),
                 modifiers = modifiers,
-                fieldType = fieldType,
+                name = name,
+                containingClass = containingClass,
+                type = fieldType,
                 isEnumConstant = isEnumConstant,
                 fieldValue = fieldValue
             )
@@ -180,9 +236,9 @@ private fun PsiField.isFieldInitializerNonNull(): Boolean {
  * Wrapper around a [PsiField] that will provide access to the initial value of the field, if
  * available, or `null` otherwise.
  */
-class PsiFieldValue(private val psiField: PsiField) {
+class PsiFieldValue(private val psiField: PsiField) : FieldValue {
 
-    fun initialValue(requireConstant: Boolean): Any? {
+    override fun initialValue(requireConstant: Boolean): Any? {
         val constant = psiField.computeConstantValue()
         // Offset [ClsFieldImpl#computeConstantValue] for [TYPE] field in boxed primitive types.
         // Those fields hold [Class] object, but the constant value should not be of [PsiType].
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt
index 3bd7f0028..0ff3ba43a 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt
@@ -16,273 +16,29 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.DefaultItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.source.utils.LazyDelegate
-import com.android.tools.metalava.reporter.FileLocation
-import com.intellij.psi.PsiCompiledElement
-import com.intellij.psi.PsiDocCommentOwner
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemLanguage
 import com.intellij.psi.PsiElement
-import com.intellij.psi.PsiModifierListOwner
 import org.jetbrains.kotlin.idea.KotlinLanguage
-import org.jetbrains.kotlin.kdoc.psi.api.KDoc
-import org.jetbrains.kotlin.psi.KtDeclaration
 import org.jetbrains.uast.UElement
-import org.jetbrains.uast.sourcePsiElement
 
-abstract class PsiItem
-internal constructor(
-    override val codebase: PsiBasedCodebase,
-    element: PsiElement,
-    fileLocation: FileLocation = PsiFileLocation(element),
-    modifiers: DefaultModifierList,
-    override var documentation: String,
-) :
-    DefaultItem(
-        fileLocation = fileLocation,
-        modifiers = modifiers,
-    ) {
+internal interface PsiItem : Item {
 
-    @Suppress(
-        "LeakingThis"
-    ) // Documentation can change, but we don't want to pick up subsequent @docOnly mutations
-    override var docOnly = documentation.contains("@doconly")
-    @Suppress("LeakingThis") override var removed = documentation.contains("@removed")
+    override val codebase: PsiBasedCodebase
 
     /** The source PSI provided by UAST */
-    internal val sourcePsi: PsiElement? = (element as? UElement)?.sourcePsi
-
-    override var originallyHidden: Boolean by LazyDelegate {
-        documentation.contains('@') &&
-            (documentation.contains("@hide") ||
-                documentation.contains("@pending") ||
-                // KDoc:
-                documentation.contains("@suppress")) || hasHideAnnotation()
-    }
-
-    override var hidden: Boolean by LazyDelegate { originallyHidden && !hasShowAnnotation() }
+    val sourcePsi
+        get() = (psi() as? UElement)?.sourcePsi
 
     /** Returns the PSI element for this item */
-    abstract fun psi(): PsiElement
-
-    override fun isFromClassPath(): Boolean {
-        return codebase.fromClasspath || containingClass()?.isFromClassPath() ?: false
-    }
-
-    override fun findTagDocumentation(tag: String, value: String?): String? {
-        if (psi() is PsiCompiledElement) {
-            return null
-        }
-        if (documentation.isBlank()) {
-            return null
-        }
-
-        // We can't just use element.docComment here because we may have modified
-        // the comment and then the comment snapshot in PSI isn't up to date with our
-        // latest changes
-        val docComment = codebase.getComment(documentation)
-        val tagComment =
-            if (value == null) {
-                docComment.findTagByName(tag)
-            } else {
-                docComment.findTagsByName(tag).firstOrNull { it.valueElement?.text == value }
-            }
-
-        if (tagComment == null) {
-            return null
-        }
-
-        val text = tagComment.text
-        // Trim trailing next line (javadoc *)
-        var index = text.length - 1
-        while (index > 0) {
-            val c = text[index]
-            if (!(c == '*' || c.isWhitespace())) {
-                break
-            }
-            index--
-        }
-        index++
-        if (index < text.length) {
-            return text.substring(0, index)
-        } else {
-            return text
-        }
-    }
-
-    override fun appendDocumentation(comment: String, tagSection: String?, append: Boolean) {
-        if (comment.isBlank()) {
-            return
-        }
-
-        // TODO: Figure out if an annotation should go on the return value, or on the method.
-        // For example; threading: on the method, range: on the return value.
-        // TODO: Find a good way to add or append to a given tag (@param <something>, @return, etc)
-
-        if (this is ParameterItem) {
-            // For parameters, the documentation goes into the surrounding method's documentation!
-            // Find the right parameter location!
-            val parameterName = name()
-            val target = containingMethod()
-            target.appendDocumentation(comment, parameterName)
-            return
-        }
-
-        // Micro-optimization: we're very often going to be merging @apiSince and to a lesser
-        // extend @deprecatedSince into existing comments, since we're flagging every single
-        // public API. Normally merging into documentation has to be done carefully, since
-        // there could be existing versions of the tag we have to append to, and some parts
-        // of the comment needs to be present in certain places. For example, you can't
-        // just append to the description of a method by inserting something right before "*/"
-        // since you could be appending to a javadoc tag like @return.
-        //
-        // However, for @apiSince and @deprecatedSince specifically, in addition to being frequent,
-        // they will (a) never appear in existing docs, and (b) they're separate tags, which means
-        // it's safe to append them at the end. So we'll special case these two tags here, to
-        // help speed up the builds since these tags are inserted 30,000+ times for each framework
-        // API target (there are many), and each time would have involved constructing a full
-        // javadoc
-        // AST with lexical tokens using IntelliJ's javadoc parsing APIs. Instead, we'll just
-        // do some simple string heuristics.
-        if (
-            tagSection == "@apiSince" ||
-                tagSection == "@deprecatedSince" ||
-                tagSection == "@sdkExtSince"
-        ) {
-            documentation = addUniqueTag(documentation, tagSection, comment)
-            return
-        }
-
-        documentation = mergeDocumentation(documentation, psi(), comment.trim(), tagSection, append)
-    }
-
-    private fun addUniqueTag(
-        documentation: String,
-        tagSection: String,
-        commentLine: String
-    ): String {
-        assert(commentLine.indexOf('\n') == -1) // Not meant for multi-line comments
-
-        if (documentation.isBlank()) {
-            return "/** $tagSection $commentLine */"
-        }
-
-        // Already single line?
-        if (documentation.indexOf('\n') == -1) {
-            val end = documentation.lastIndexOf("*/")
-            return "/**\n *" +
-                documentation.substring(3, end) +
-                "\n * $tagSection $commentLine\n */"
-        }
-
-        var end = documentation.lastIndexOf("*/")
-        while (end > 0 && documentation[end - 1].isWhitespace() && documentation[end - 1] != '\n') {
-            end--
-        }
-        // The comment ends with:
-        // * some comment here */
-        val insertNewLine: Boolean = documentation[end - 1] != '\n'
-
-        val indent: String
-        var linePrefix = ""
-        val secondLine = documentation.indexOf('\n')
-        if (secondLine == -1) {
-            // Single line comment
-            indent = "\n * "
-        } else {
-            val indentStart = secondLine + 1
-            var indentEnd = indentStart
-            while (indentEnd < documentation.length) {
-                if (!documentation[indentEnd].isWhitespace()) {
-                    break
-                }
-                indentEnd++
-            }
-            indent = documentation.substring(indentStart, indentEnd)
-            // TODO: If it starts with "* " follow that
-            if (documentation.startsWith("* ", indentEnd)) {
-                linePrefix = "* "
-            }
-        }
-        return documentation.substring(0, end) +
-            (if (insertNewLine) "\n" else "") +
-            indent +
-            linePrefix +
-            tagSection +
-            " " +
-            commentLine +
-            "\n" +
-            indent +
-            " */"
-    }
-
-    override fun fullyQualifiedDocumentation(): String {
-        return fullyQualifiedDocumentation(documentation)
-    }
-
-    override fun fullyQualifiedDocumentation(documentation: String): String {
-        return codebase.docQualifier.toFullyQualifiedDocumentation(this, documentation)
-    }
-
-    override fun isJava(): Boolean {
-        return !isKotlin()
-    }
-
-    override fun isKotlin(): Boolean {
-        return psi().isKotlin()
-    }
-
-    companion object {
-
-        // Gets the javadoc of the current element, unless reading comments is
-        // disabled via allowReadingComments
-        internal fun javadoc(element: PsiElement, allowReadingComments: Boolean): String {
-            if (!allowReadingComments) {
-                return ""
-            }
-            if (element is PsiCompiledElement) {
-                return ""
-            }
-
-            if (element is KtDeclaration) {
-                return element.docComment?.text.orEmpty()
-            }
-
-            if (element is UElement) {
-                val comments = element.comments
-                if (comments.isNotEmpty()) {
-                    val sb = StringBuilder()
-                    comments.asSequence().joinTo(buffer = sb, separator = "\n") { it.text }
-                    return sb.toString()
-                } else {
-                    // Temporary workaround: UAST seems to not return document nodes
-                    // https://youtrack.jetbrains.com/issue/KT-22135
-                    val first = element.sourcePsiElement?.firstChild
-                    if (first is KDoc) {
-                        return first.text
-                    }
-                }
-            }
-
-            if (element is PsiDocCommentOwner && element.docComment !is PsiCompiledElement) {
-                return element.docComment?.text ?: ""
-            }
-
-            return ""
-        }
-
-        internal fun modifiers(
-            codebase: PsiBasedCodebase,
-            element: PsiModifierListOwner,
-            documentation: String? = null,
-        ): DefaultModifierList {
-            return PsiModifierItem.create(codebase, element, documentation)
-        }
-    }
+    fun psi(): PsiElement
 }
 
-/** Check whether a [PsiElement] is Kotlin or not. */
+/** Get the [ItemLanguage] for this [PsiElement]. */
+val PsiElement.itemLanguage
+    get() = if (isKotlin()) ItemLanguage.KOTLIN else ItemLanguage.JAVA
+
+/** Check whether this [PsiElement] is Kotlin or not. */
 fun PsiElement.isKotlin(): Boolean {
     return language === KotlinLanguage.INSTANCE
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
new file mode 100644
index 000000000..b0f6d0bfe
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
@@ -0,0 +1,734 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.AbstractItemDocumentation
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.reporter.Issues
+import com.intellij.psi.JavaPsiFacade
+import com.intellij.psi.PsiClass
+import com.intellij.psi.PsiCompiledElement
+import com.intellij.psi.PsiDocCommentOwner
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiJavaCodeReferenceElement
+import com.intellij.psi.PsiMember
+import com.intellij.psi.PsiReference
+import com.intellij.psi.PsiTypeParameter
+import com.intellij.psi.PsiWhiteSpace
+import com.intellij.psi.impl.source.SourceTreeToPsiMap
+import com.intellij.psi.impl.source.javadoc.PsiDocMethodOrFieldRef
+import com.intellij.psi.impl.source.tree.CompositePsiElement
+import com.intellij.psi.impl.source.tree.JavaDocElementType
+import com.intellij.psi.javadoc.PsiDocTag
+import com.intellij.psi.javadoc.PsiDocToken
+import com.intellij.psi.javadoc.PsiInlineDocTag
+import org.jetbrains.kotlin.kdoc.psi.api.KDoc
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.uast.UElement
+import org.jetbrains.uast.sourcePsiElement
+
+/** A Psi specialization of [ItemDocumentation]. */
+internal class PsiItemDocumentation(
+    private val item: PsiItem,
+    private val psi: PsiElement,
+    private val extraDocs: String?,
+) : AbstractItemDocumentation() {
+
+    /** Lazily initialized backing property for [text]. */
+    private lateinit var _text: String
+
+    override var text: String
+        get() = if (::_text.isInitialized) _text else initializeText()
+        set(value) {
+            _text = value
+        }
+
+    /** Lazy initializer for [_text]. */
+    private fun initializeText(): String {
+        _text = javadoc(psi).let { if (extraDocs != null) it + "\n$extraDocs" else it }
+        return _text
+    }
+
+    override fun duplicate(item: Item) = PsiItemDocumentation(item as PsiItem, psi, extraDocs)
+
+    override fun findTagDocumentation(tag: String, value: String?): String? {
+        if (psi is PsiCompiledElement) {
+            return null
+        }
+        if (text.isBlank()) {
+            return null
+        }
+
+        // We can't just use element.docComment here because we may have modified the comment and
+        // then the comment snapshot in PSI isn't up-to-date with our latest changes
+        val docComment = item.codebase.psiAssembler.getComment(text)
+        val tagComment =
+            if (value == null) {
+                docComment.findTagByName(tag)
+            } else {
+                docComment.findTagsByName(tag).firstOrNull { it.valueElement?.text == value }
+            }
+
+        if (tagComment == null) {
+            return null
+        }
+
+        val text = tagComment.text
+        // Trim trailing next line (javadoc *)
+        var index = text.length - 1
+        while (index > 0) {
+            val c = text[index]
+            if (!(c == '*' || c.isWhitespace())) {
+                break
+            }
+            index--
+        }
+        index++
+        return if (index < text.length) {
+            text.substring(0, index)
+        } else {
+            text
+        }
+    }
+
+    override fun mergeDocumentation(comment: String, tagSection: String?) {
+        text = mergeDocumentation(text, psi, comment, tagSection, append = true)
+    }
+
+    override fun findMainDocumentation(): String {
+        if (text == "") return text
+        val comment = item.codebase.psiAssembler.getComment(text)
+        val end = findFirstTag(comment)?.textRange?.startOffset ?: text.length
+        return comment.text.substring(0, end)
+    }
+
+    override fun fullyQualifiedDocumentation(documentation: String): String {
+        if (documentation.isBlank() || !containsLinkTags(documentation)) {
+            return documentation
+        }
+
+        val assembler = item.codebase.psiAssembler
+        val comment =
+            try {
+                assembler.getComment(documentation, psi)
+            } catch (throwable: Throwable) {
+                // TODO: Get rid of line comments as documentation
+                // Invalid comment
+                if (documentation.startsWith("//") && documentation.contains("/**")) {
+                    return fullyQualifiedDocumentation(
+                        documentation.substring(documentation.indexOf("/**"))
+                    )
+                }
+                assembler.getComment(documentation, psi)
+            }
+        return buildString(documentation.length) { expand(comment, this) }
+    }
+
+    private fun reportUnresolvedDocReference(unresolved: String) {
+        if (!REPORT_UNRESOLVED_SYMBOLS) {
+            return
+        }
+
+        if (unresolved.startsWith("{@") && !unresolved.startsWith("{@link")) {
+            return
+        }
+
+        // References are sometimes split across lines and therefore have newlines, leading
+        // asterisks etc. in the middle: clean this up before emitting reference into error message
+        val cleaned = unresolved.replace("\n", "").replace("*", "").replace("  ", " ")
+
+        item.codebase.reporter.report(
+            Issues.UNRESOLVED_LINK,
+            item,
+            "Unresolved documentation reference: $cleaned"
+        )
+    }
+
+    private fun expand(element: PsiElement, sb: StringBuilder) {
+        when {
+            element is PsiWhiteSpace -> {
+                sb.append(element.text)
+            }
+            element is PsiDocToken -> {
+                assert(element.firstChild == null)
+                val text = element.text
+                // Auto-fix some docs in the framework which starts with R.styleable in @attr
+                if (text.startsWith("R.styleable#") && item.documentation.contains("@attr")) {
+                    sb.append("android.")
+                }
+
+                sb.append(text)
+            }
+            element is PsiDocMethodOrFieldRef -> {
+                val text = element.text
+                var resolved = element.reference?.resolve()
+
+                // Workaround: relative references doesn't work from a class item to its members
+                if (resolved == null && item is ClassItem) {
+                    // For some reason, resolving relative methods and field references at the root
+                    // level isn't working right.
+                    if (PREPEND_LOCAL_CLASS && text.startsWith("#")) {
+                        var end = text.indexOf('(')
+                        if (end == -1) {
+                            // definitely a field
+                            end = text.length
+                            val fieldName = text.substring(1, end)
+                            val field = item.findField(fieldName)
+                            if (field != null) {
+                                resolved = (field as? PsiFieldItem)?.psi()
+                            }
+                        }
+                        if (resolved == null) {
+                            val methodName = text.substring(1, end)
+                            resolved =
+                                (item as PsiClassItem)
+                                    .psi()
+                                    .findMethodsByName(methodName, true)
+                                    .firstOrNull()
+                        }
+                    }
+                }
+
+                if (resolved is PsiMember) {
+                    val containingClass = resolved.containingClass
+                    if (containingClass != null && !samePackage(containingClass)) {
+                        val referenceText = element.reference?.element?.text ?: text
+                        if (!PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
+                            sb.append(text)
+                            return
+                        }
+
+                        var className = containingClass.classQualifiedName
+
+                        if (
+                            element.firstChildNode.elementType ===
+                                JavaDocElementType.DOC_REFERENCE_HOLDER
+                        ) {
+                            val firstChildPsi =
+                                SourceTreeToPsiMap.treeElementToPsi(
+                                    element.firstChildNode.firstChildNode
+                                )
+                            if (firstChildPsi is PsiJavaCodeReferenceElement) {
+                                val referenceElement = firstChildPsi as PsiJavaCodeReferenceElement?
+                                val referencedElement = referenceElement!!.resolve()
+                                if (referencedElement is PsiClass) {
+                                    className = referencedElement.classQualifiedName
+                                }
+                            }
+                        }
+
+                        sb.append(className)
+                        sb.append('#')
+                        sb.append(resolved.name)
+                        val index = text.indexOf('(')
+                        if (index != -1) {
+                            sb.append(text.substring(index))
+                        }
+                    } else {
+                        sb.append(text)
+                    }
+                } else {
+                    if (resolved == null) {
+                        val referenceText = element.reference?.element?.text ?: text
+                        if (text.startsWith("#") && item is ClassItem) {
+                            // Unfortunately resolving references is broken from class javadocs
+                            // to members using just a relative reference, #.
+                        } else {
+                            reportUnresolvedDocReference(referenceText)
+                        }
+                    }
+                    sb.append(text)
+                }
+            }
+            element is PsiJavaCodeReferenceElement -> {
+                val resolved = element.resolve()
+                if (resolved is PsiClass) {
+                    if (samePackage(resolved) || resolved is PsiTypeParameter) {
+                        sb.append(element.text)
+                    } else {
+                        sb.append(resolved.classQualifiedName)
+                    }
+                } else if (resolved is PsiMember) {
+                    val text = element.text
+                    sb.append(resolved.containingClass?.classQualifiedName)
+                    sb.append('#')
+                    sb.append(resolved.name)
+                    val index = text.indexOf('(')
+                    if (index != -1) {
+                        sb.append(text.substring(index))
+                    }
+                } else {
+                    val text = element.text
+                    if (resolved == null) {
+                        reportUnresolvedDocReference(text)
+                    }
+                    sb.append(text)
+                }
+            }
+            element is PsiInlineDocTag -> {
+                val handled = handleTag(element, sb)
+                if (!handled) {
+                    sb.append(element.text)
+                }
+            }
+            element.firstChild != null -> {
+                var curr = element.firstChild
+                while (curr != null) {
+                    expand(curr, sb)
+                    curr = curr.nextSibling
+                }
+            }
+            else -> {
+                val text = element.text
+                sb.append(text)
+            }
+        }
+    }
+
+    private fun handleTag(element: PsiInlineDocTag, sb: StringBuilder): Boolean {
+        val name = element.name
+        if (name == "code" || name == "literal") {
+            // @code: don't attempt to rewrite this
+            sb.append(element.text)
+            return true
+        }
+
+        val reference = extractReference(element)
+        val referenceText = reference?.element?.text ?: element.text
+        val customLinkText = extractCustomLinkText(element)
+        val displayText = customLinkText?.text ?: referenceText
+        if (!PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
+            val suffix = element.text
+            if (suffix.contains("(") && suffix.contains(")")) {
+                expandArgumentList(element, suffix, sb)
+            } else {
+                sb.append(suffix)
+            }
+            return true
+        }
+
+        // TODO: If referenceText is already absolute, e.g.
+        // android.Manifest.permission#BIND_CARRIER_SERVICES,
+        // try to short circuit this?
+
+        val valueElement = element.valueElement
+        if (valueElement is CompositePsiElement) {
+            if (
+                valueElement.firstChildNode.elementType === JavaDocElementType.DOC_REFERENCE_HOLDER
+            ) {
+                val firstChildPsi =
+                    SourceTreeToPsiMap.treeElementToPsi(valueElement.firstChildNode.firstChildNode)
+                if (firstChildPsi is PsiJavaCodeReferenceElement) {
+                    val referenceElement = firstChildPsi as PsiJavaCodeReferenceElement?
+                    val referencedElement = referenceElement!!.resolve()
+                    if (referencedElement is PsiClass) {
+                        var className = computeFullClassName(referencedElement)
+                        if (className.indexOf('.') != -1 && !referenceText.startsWith(className)) {
+                            val simpleName = referencedElement.name
+                            if (simpleName != null && referenceText.startsWith(simpleName)) {
+                                className = simpleName
+                            }
+                        }
+                        if (referenceText.startsWith(className)) {
+                            sb.append("{@")
+                            sb.append(element.name)
+                            sb.append(' ')
+                            sb.append(referencedElement.classQualifiedName)
+                            val suffix = referenceText.substring(className.length)
+                            if (suffix.contains("(") && suffix.contains(")")) {
+                                expandArgumentList(element, suffix, sb)
+                            } else {
+                                sb.append(suffix)
+                            }
+                            sb.append(' ')
+                            sb.append(displayText)
+                            sb.append("}")
+                            return true
+                        }
+                    }
+                }
+            }
+        }
+
+        var resolved = reference?.resolve()
+        if (resolved == null && item is ClassItem) {
+            // For some reason, resolving relative methods and field references at the root
+            // level isn't working right.
+            if (PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
+                var end = referenceText.indexOf('(')
+                if (end == -1) {
+                    // definitely a field
+                    end = referenceText.length
+                    val fieldName = referenceText.substring(1, end)
+                    val field = item.findField(fieldName)
+                    if (field != null) {
+                        resolved = (field as? PsiFieldItem)?.psi()
+                    }
+                }
+                if (resolved == null) {
+                    val methodName = referenceText.substring(1, end)
+                    resolved =
+                        (item as PsiClassItem)
+                            .psi()
+                            .findMethodsByName(methodName, true)
+                            .firstOrNull()
+                }
+            }
+        }
+
+        if (resolved != null) {
+            when (resolved) {
+                is PsiClass -> {
+                    val text = element.text
+                    if (samePackage(resolved)) {
+                        sb.append(text)
+                        return true
+                    }
+                    val qualifiedName =
+                        resolved.qualifiedName
+                            ?: run {
+                                sb.append(text)
+                                return true
+                            }
+                    if (referenceText == qualifiedName) {
+                        // Already absolute
+                        sb.append(text)
+                        return true
+                    }
+                    val append =
+                        when {
+                            valueElement != null -> {
+                                val start = valueElement.startOffsetInParent
+                                val end = start + valueElement.textLength
+                                text.substring(0, start) + qualifiedName + text.substring(end)
+                            }
+                            name == "see" -> {
+                                val suffix =
+                                    text.substring(
+                                        text.indexOf(referenceText) + referenceText.length
+                                    )
+                                "@see $qualifiedName$suffix"
+                            }
+                            text.startsWith("{") -> "{@$name $qualifiedName $displayText}"
+                            else -> "@$name $qualifiedName $displayText"
+                        }
+                    sb.append(append)
+                    return true
+                }
+                is PsiMember -> {
+                    val text = element.text
+                    val containing =
+                        resolved.containingClass
+                            ?: run {
+                                sb.append(text)
+                                return true
+                            }
+                    if (samePackage(containing)) {
+                        sb.append(text)
+                        return true
+                    }
+                    val qualifiedName =
+                        containing.qualifiedName
+                            ?: run {
+                                sb.append(text)
+                                return true
+                            }
+                    if (referenceText.startsWith(qualifiedName)) {
+                        // Already absolute
+                        sb.append(text)
+                        return true
+                    }
+
+                    // It may also be the case that the reference is already fully qualified
+                    // but to some different class. For example, the link may be to
+                    // android.os.Bundle#getInt, but the resolved method actually points to
+                    // an inherited method into android.os.Bundle from android.os.BaseBundle.
+                    // In that case we don't want to rewrite the link.
+                    for (c in referenceText) {
+                        if (c == '.') {
+                            // Already qualified
+                            sb.append(text)
+                            return true
+                        } else if (!Character.isJavaIdentifierPart(c)) {
+                            break
+                        }
+                    }
+
+                    if (valueElement != null) {
+                        val start = valueElement.startOffsetInParent
+
+                        var nameEnd = -1
+                        var close = start
+                        var balance = 0
+                        while (close < text.length) {
+                            val c = text[close]
+                            if (c == '(') {
+                                if (nameEnd == -1) {
+                                    nameEnd = close
+                                }
+                                balance++
+                            } else if (c == ')') {
+                                balance--
+                                if (balance == 0) {
+                                    close++
+                                    break
+                                }
+                            } else if (c == '}') {
+                                if (nameEnd == -1) {
+                                    nameEnd = close
+                                }
+                                break
+                            } else if (balance == 0 && c == '#') {
+                                if (nameEnd == -1) {
+                                    nameEnd = close
+                                }
+                            } else if (balance == 0 && !Character.isJavaIdentifierPart(c)) {
+                                break
+                            }
+                            close++
+                        }
+                        val memberPart = text.substring(nameEnd, close)
+                        val append =
+                            "${text.substring(0, start)}$qualifiedName$memberPart $displayText}"
+                        sb.append(append)
+                        return true
+                    }
+                }
+            }
+        } else {
+            reportUnresolvedDocReference(referenceText)
+        }
+
+        return false
+    }
+
+    private fun expandArgumentList(element: PsiInlineDocTag, suffix: String, sb: StringBuilder) {
+        val elementFactory = JavaPsiFacade.getElementFactory(element.project)
+        // Try to rewrite the types to fully qualified names as well
+        val begin = suffix.indexOf('(')
+        sb.append(suffix.substring(0, begin + 1))
+        var index = begin + 1
+        var balance = 0
+        var argBegin = index
+        while (index < suffix.length) {
+            val c = suffix[index++]
+            if (c == '<' || c == '(') {
+                balance++
+            } else if (c == '>') {
+                balance--
+            } else if (c == ')' && balance == 0 || c == ',') {
+                // Strip off javadoc header
+                while (argBegin < index) {
+                    val p = suffix[argBegin]
+                    if (p != '*' && !p.isWhitespace()) {
+                        break
+                    }
+                    argBegin++
+                }
+                if (index > argBegin + 1) {
+                    val arg = suffix.substring(argBegin, index - 1).trim()
+                    val space = arg.indexOf(' ')
+                    // Strip off parameter name (shouldn't be there but happens
+                    // in some Android sources sine tools didn't use to complain
+                    val typeString =
+                        if (space == -1) {
+                            arg
+                        } else {
+                            if (space < arg.length - 1 && !arg[space + 1].isJavaIdentifierStart()) {
+                                // Example: "String []"
+                                arg
+                            } else {
+                                // Example "String name"
+                                arg.substring(0, space)
+                            }
+                        }
+                    var insert = arg
+                    if (typeString[0].isUpperCase()) {
+                        try {
+                            val type = elementFactory.createTypeFromText(typeString, element)
+                            insert = type.canonicalText
+                        } catch (ignore: com.intellij.util.IncorrectOperationException) {
+                            // Not a valid type - just leave what was in the parameter text
+                        }
+                    }
+                    sb.append(insert)
+                    sb.append(c)
+                    if (c == ')') {
+                        break
+                    }
+                } else if (c == ')') {
+                    sb.append(')')
+                    break
+                }
+                argBegin = index
+            } else if (c == ')') {
+                balance--
+            }
+        }
+        while (index < suffix.length) {
+            sb.append(suffix[index++])
+        }
+    }
+
+    private fun samePackage(cls: PsiClass): Boolean {
+        if (INCLUDE_SAME_PACKAGE) {
+            // doclava seems to have REAL problems with this
+            return false
+        }
+        val pkg = packageName() ?: return false
+        return cls.qualifiedName == "$pkg.${cls.name}"
+    }
+
+    private fun packageName(): String? {
+        var curr: Item? = item
+        while (curr != null) {
+            if (curr is PackageItem) {
+                return curr.qualifiedName()
+            }
+            curr = curr.parent()
+        }
+
+        return null
+    }
+
+    // Copied from UnnecessaryJavaDocLinkInspection and tweaked a bit
+    private fun extractReference(tag: PsiDocTag): PsiReference? {
+        val valueElement = tag.valueElement
+        if (valueElement != null) {
+            return valueElement.reference
+        }
+        // hack around the fact that a reference to a class is apparently
+        // not a PsiDocTagValue
+        val dataElements = tag.dataElements
+        if (dataElements.isEmpty()) {
+            return null
+        }
+        val salientElement: PsiElement =
+            dataElements.firstOrNull { it !is PsiWhiteSpace && it !is PsiDocToken } ?: return null
+        val child = salientElement.firstChild
+        return if (child !is PsiReference) null else child
+    }
+
+    private fun extractCustomLinkText(tag: PsiDocTag): PsiDocToken? {
+        val dataElements = tag.dataElements
+        if (dataElements.isEmpty()) {
+            return null
+        }
+        val salientElement: PsiElement =
+            dataElements.lastOrNull { it !is PsiWhiteSpace && it !is PsiDocMethodOrFieldRef }
+                ?: return null
+        return if (salientElement !is PsiDocToken) null else salientElement
+    }
+
+    companion object {
+        /**
+         * Get an [ItemDocumentationFactory] for the [psi].
+         *
+         * If [PsiBasedCodebase.allowReadingComments] is `true` then this will return a factory that
+         * creates a [PsiItemDocumentation] instance. If [extraDocs] is not-null then this will
+         * return a factory that will create an [ItemDocumentation] wrapper around [extraDocs],
+         * otherwise it will return [ItemDocumentation.NONE_FACTORY].
+         *
+         * @param psi the underlying element from which the documentation will be retrieved.
+         *   Although this is usually accessible through the [PsiItem.psi] property, that is not
+         *   true within the [ItemDocumentationFactory] as that is called during initialization of
+         *   the [PsiItem] before [PsiItem.psi] has been initialized.
+         */
+        internal fun factory(
+            psi: PsiElement,
+            codebase: PsiBasedCodebase,
+            extraDocs: String? = null,
+        ) =
+            if (codebase.allowReadingComments) {
+                // When reading comments provide full access to them.
+                { item ->
+                    val psiItem = item as PsiItem
+                    PsiItemDocumentation(psiItem, psi, extraDocs)
+                }
+            } else {
+                // If extraDocs are provided then they most likely contain documentation for the
+                // package from a `package-info.java` or `package.html` file. Make sure that they
+                // are included in the `ItemDocumentation`, otherwise package hiding will not work.
+                extraDocs?.toItemDocumentationFactory()
+                // Otherwise, there is no documentation to use.
+                ?: ItemDocumentation.NONE_FACTORY
+            }
+
+        // Gets the javadoc of the current element
+        private fun javadoc(element: PsiElement): String {
+            if (element is PsiCompiledElement) {
+                return ""
+            }
+
+            if (element is KtDeclaration) {
+                return element.docComment?.text.orEmpty()
+            }
+
+            if (element is UElement) {
+                val comments = element.comments
+                if (comments.isNotEmpty()) {
+                    val sb = StringBuilder()
+                    comments.joinTo(buffer = sb, separator = "\n") { it.text }
+                    return sb.toString()
+                } else {
+                    // Temporary workaround: UAST seems to not return document nodes
+                    // https://youtrack.jetbrains.com/issue/KT-22135
+                    val first = element.sourcePsiElement?.firstChild
+                    if (first is KDoc) {
+                        return first.text
+                    }
+                }
+            }
+
+            if (element is PsiDocCommentOwner && element.docComment !is PsiCompiledElement) {
+                return element.docComment?.text ?: ""
+            }
+
+            return ""
+        }
+    }
+}
+
+/**
+ * Computes the "full" class name; this is not the qualified class name (e.g. with package) but for
+ * a nested class it includes all the outer classes
+ */
+private fun computeFullClassName(cls: PsiClass): String {
+    if (cls.containingClass == null) {
+        val name = cls.name
+        return name!!
+    } else {
+        val list = mutableListOf<String>()
+        var curr: PsiClass? = cls
+        while (curr != null) {
+            val name = curr.name
+            curr =
+                if (name != null) {
+                    list.add(name)
+                    curr.containingClass
+                } else {
+                    break
+                }
+        }
+        return list.asReversed().joinToString(separator = ".") { it }
+    }
+}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
index 54f2f5afa..6cbe2e7a6 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
@@ -16,127 +16,74 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.computeSuperMethods
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.item.DefaultMethodItem
+import com.android.tools.metalava.model.item.ParameterItemsFactory
+import com.android.tools.metalava.model.psi.PsiCallableItem.Companion.parameterList
+import com.android.tools.metalava.model.psi.PsiCallableItem.Companion.throwsTypes
 import com.android.tools.metalava.model.type.MethodFingerprint
-import com.android.tools.metalava.model.updateCopiedMethodState
 import com.android.tools.metalava.reporter.FileLocation
 import com.intellij.psi.PsiAnnotationMethod
 import com.intellij.psi.PsiMethod
-import com.intellij.psi.PsiParameter
-import org.jetbrains.kotlin.name.JvmStandardClassIds
-import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtNamedFunction
 import org.jetbrains.kotlin.psi.KtParameter
 import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
 import org.jetbrains.uast.UAnnotation
 import org.jetbrains.uast.UAnnotationMethod
-import org.jetbrains.uast.UElement
 import org.jetbrains.uast.UMethod
-import org.jetbrains.uast.UThrowExpression
-import org.jetbrains.uast.UTryExpression
-import org.jetbrains.uast.getParentOfType
 import org.jetbrains.uast.kotlin.KotlinUMethodWithFakeLightDelegateBase
 import org.jetbrains.uast.toUElement
-import org.jetbrains.uast.visitor.AbstractUastVisitor
 
-open class PsiMethodItem(
-    codebase: PsiBasedCodebase,
-    val psiMethod: PsiMethod,
+internal class PsiMethodItem(
+    override val codebase: PsiBasedCodebase,
+    override val psiMethod: PsiMethod,
     fileLocation: FileLocation = PsiFileLocation(psiMethod),
     // Takes ClassItem as this may be duplicated from a PsiBasedCodebase on the classpath into a
     // TextClassItem.
     containingClass: ClassItem,
     name: String,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    private val returnType: TypeItem,
-    private val parameters: List<PsiParameterItem>,
-    override val typeParameterList: TypeParameterList,
-    private val throwsTypes: List<ExceptionTypeItem>
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    returnType: TypeItem,
+    parameterItemsFactory: ParameterItemsFactory,
+    typeParameterList: TypeParameterList,
+    throwsTypes: List<ExceptionTypeItem>,
 ) :
-    PsiMemberItem(
+    DefaultMethodItem(
         codebase = codebase,
-        modifiers = modifiers,
-        documentation = documentation,
-        element = psiMethod,
         fileLocation = fileLocation,
-        containingClass = containingClass,
+        itemLanguage = psiMethod.itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
         name = name,
+        containingClass = containingClass,
+        typeParameterList = typeParameterList,
+        returnType = returnType,
+        parameterItemsFactory = parameterItemsFactory,
+        throwsTypes = throwsTypes,
+        callableBodyFactory = { PsiCallableBody(it as PsiCallableItem) },
     ),
-    MethodItem {
-
-    init {
-        for (parameter in parameters) {
-            @Suppress("LeakingThis")
-            parameter.containingMethod = this
-        }
-    }
-
-    override var inheritedFrom: ClassItem? = null
+    PsiCallableItem {
 
     override var property: PsiPropertyItem? = null
 
-    @Deprecated("This property should not be accessed directly.")
-    override var _requiresOverride: Boolean? = null
-
-    override fun equals(other: Any?): Boolean {
-        // TODO: Allow mix and matching with other MethodItems?
-        if (this === other) return true
-        if (javaClass != other?.javaClass) return false
-
-        other as PsiMethodItem
-
-        if (psiMethod != other.psiMethod) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return psiMethod.hashCode()
-    }
-
-    override fun findMainDocumentation(): String {
-        if (documentation == "") return documentation
-        val comment = codebase.getComment(documentation)
-        val end = findFirstTag(comment)?.textRange?.startOffset ?: documentation.length
-        return comment.text.substring(0, end)
-    }
-
-    override fun isConstructor(): Boolean = false
-
-    override fun isImplicitConstructor(): Boolean = false
-
-    override fun returnType(): TypeItem = returnType
-
-    override fun parameters(): List<PsiParameterItem> = parameters
-
-    override fun psi() = psiMethod
-
-    private var superMethods: List<MethodItem>? = null
-
-    override fun superMethods(): List<MethodItem> {
-        if (superMethods == null) {
-            superMethods = computeSuperMethods()
-        }
-
-        return superMethods!!
-    }
-
-    override fun throwsTypes() = throwsTypes
-
     override fun isExtensionMethod(): Boolean {
         if (isKotlin()) {
             val ktParameters =
                 ((psiMethod as? UMethod)?.sourcePsi as? KtNamedFunction)?.valueParameters
                     ?: return false
-            return ktParameters.size < parameters.size
+            return ktParameters.size < parameters().size
         }
 
         return false
@@ -150,67 +97,6 @@ open class PsiMethodItem(
                     (psiMethod.sourcePsi as KtParameter).hasValOrVar())
     }
 
-    override fun findThrownExceptions(): Set<ClassItem> {
-        val method = psiMethod as? UMethod ?: return emptySet()
-        if (!isKotlin()) {
-            return emptySet()
-        }
-
-        val exceptions = mutableSetOf<ClassItem>()
-
-        method.accept(
-            object : AbstractUastVisitor() {
-                override fun visitThrowExpression(node: UThrowExpression): Boolean {
-                    val type = node.thrownExpression.getExpressionType()
-                    if (type != null) {
-                        val typeItemFactory =
-                            codebase.globalTypeItemFactory.from(this@PsiMethodItem)
-                        val exceptionClass = typeItemFactory.getType(type).asClass()
-                        if (exceptionClass != null && !isCaught(exceptionClass, node)) {
-                            exceptions.add(exceptionClass)
-                        }
-                    }
-                    return super.visitThrowExpression(node)
-                }
-
-                private fun isCaught(exceptionClass: ClassItem, node: UThrowExpression): Boolean {
-                    var current: UElement = node
-                    while (true) {
-                        val tryExpression =
-                            current.getParentOfType<UTryExpression>(
-                                UTryExpression::class.java,
-                                true,
-                                UMethod::class.java
-                            )
-                                ?: return false
-
-                        for (catchClause in tryExpression.catchClauses) {
-                            for (type in catchClause.types) {
-                                val qualifiedName = type.canonicalText
-                                if (exceptionClass.extends(qualifiedName)) {
-                                    return true
-                                }
-                            }
-                        }
-
-                        current = tryExpression
-                    }
-                }
-            }
-        )
-
-        return exceptions
-    }
-
-    internal fun areAllParametersOptional(): Boolean {
-        for (param in parameters) {
-            if (!param.hasDefaultValue()) {
-                return false
-            }
-        }
-        return true
-    }
-
     override fun defaultValue(): String {
         return when (psiMethod) {
             is UAnnotationMethod -> {
@@ -225,32 +111,40 @@ open class PsiMethodItem(
     }
 
     override fun duplicate(targetContainingClass: ClassItem): PsiMethodItem {
-        val duplicated =
-            create(
+        // If duplicating within the same codebase type then map the type variables, otherwise do
+        // not. That is because this can end up substituting a `TypeItem` implementation of one
+        // type in place of a `PsiTypeItem` which can cause casting issues, e.g. in
+        // `PsiParameterItem` which expects its type as `PsiTypeItem`. Falling back to not mapping
+        // will not cause any significant issues as that is what was done before.
+        // TODO(b/324196754): Fix this. It is not clear if this causes problems outside tests, it
+        //  does not seem to break Android build.
+        val typeVariableMap =
+            if (codebase.javaClass === targetContainingClass.codebase.javaClass)
+                targetContainingClass.mapTypeVariables(containingClass())
+            else emptyMap()
+
+        return PsiMethodItem(
                 codebase,
-                targetContainingClass,
                 psiMethod,
-                // Use the scope from this class to resolve type parameter references as the target
-                // class may have a completely different set.
-                codebase.globalTypeItemFactory.from(containingClass)
+                fileLocation,
+                targetContainingClass,
+                name(),
+                modifiers,
+                documentation::duplicate,
+                returnType.convertType(typeVariableMap),
+                { methodItem ->
+                    parameters().map {
+                        (it as PsiParameterItem).duplicate(methodItem, typeVariableMap)
+                    }
+                },
+                typeParameterList,
+                throwsTypes(),
             )
+            .also { duplicated ->
+                duplicated.inheritedFrom = containingClass()
 
-        duplicated.inheritedFrom = containingClass
-
-        // Preserve flags that may have been inherited (propagated) from surrounding packages
-        if (targetContainingClass.hidden) {
-            duplicated.hidden = true
-        }
-        if (targetContainingClass.removed) {
-            duplicated.removed = true
-        }
-        if (targetContainingClass.docOnly) {
-            duplicated.docOnly = true
-        }
-
-        duplicated.updateCopiedMethodState()
-
-        return duplicated
+                duplicated.updateCopiedMethodState()
+            }
     }
 
     /* Call corresponding PSI utility method -- if I can find it!
@@ -264,16 +158,6 @@ open class PsiMethodItem(
     }
     */
 
-    override fun shouldExpandOverloads(): Boolean {
-        val ktFunction = (psiMethod as? UMethod)?.sourcePsi as? KtFunction ?: return false
-        return modifiers.isActual() &&
-            psiMethod.hasAnnotation(JvmStandardClassIds.JVM_OVERLOADS_FQ_NAME.asString()) &&
-            // It is /technically/ invalid to have actual functions with default values, but
-            // some places suppress the compiler error, so we should handle it here too.
-            ktFunction.valueParameters.none { it.hasDefaultValue() } &&
-            parameters.any { it.hasDefaultValue() }
-    }
-
     companion object {
         /**
          * Create a [PsiMethodItem].
@@ -312,8 +196,25 @@ open class PsiMethodItem(
                 } else {
                     psiMethod.name
                 }
-            val commentText = javadoc(psiMethod, codebase.allowReadingComments)
-            val modifiers = modifiers(codebase, psiMethod, commentText)
+            val modifiers = PsiModifierItem.create(codebase, psiMethod)
+
+            if (containingClass.classKind == ClassKind.INTERFACE) {
+                // All interface methods are implicitly public (except in Java 1.9, where they can
+                // be private.
+                if (!modifiers.isPrivate()) {
+                    modifiers.setVisibilityLevel(VisibilityLevel.PUBLIC)
+                }
+            }
+
+            if (modifiers.isFinal() && containingClass.modifiers.isFinal()) {
+                // The containing class is final, so it is implied that every method is final as
+                // well.
+                // No need to apply 'final' to each method. (We do it here rather than just in the
+                // signature emit code since we want to make sure that the signature comparison
+                // methods with super methods also consider this method non-final.)
+                modifiers.setFinal(false)
+            }
+
             // Create the TypeParameterList for this before wrapping any of the other types used by
             // it as they may reference a type parameter in the list.
             val (typeParameterList, methodTypeItemFactory) =
@@ -323,7 +224,6 @@ open class PsiMethodItem(
                     "method $name",
                     psiMethod
                 )
-            val parameters = parameterList(codebase, psiMethod, methodTypeItemFactory)
             val fingerprint = MethodFingerprint(psiMethod.name, psiMethod.parameters.size)
             val isAnnotationElement = containingClass.isAnnotationType() && !modifiers.isStatic()
             val returnType =
@@ -340,111 +240,22 @@ open class PsiMethodItem(
                     psiMethod = psiMethod,
                     containingClass = containingClass,
                     name = name,
-                    documentation = commentText,
+                    documentationFactory = PsiItemDocumentation.factory(psiMethod, codebase),
                     modifiers = modifiers,
                     returnType = returnType,
-                    parameters = parameters,
+                    parameterItemsFactory = { containingCallable ->
+                        parameterList(
+                            codebase,
+                            psiMethod,
+                            containingCallable as PsiCallableItem,
+                            methodTypeItemFactory,
+                        )
+                    },
                     typeParameterList = typeParameterList,
                     throwsTypes = throwsTypes(psiMethod, methodTypeItemFactory),
                 )
-            if (modifiers.isFinal() && containingClass.modifiers.isFinal()) {
-                // The containing class is final, so it is implied that every method is final as
-                // well.
-                // No need to apply 'final' to each method. (We do it here rather than just in the
-                // signature emit code since we want to make sure that the signature comparison
-                // methods with super methods also consider this method non-final.)
-                modifiers.setFinal(false)
-            }
-
-            return method
-        }
-
-        /**
-         * Create a [PsiMethodItem] from a [PsiMethodItem] in a hidden super class.
-         *
-         * @see ClassItem.inheritMethodFromNonApiAncestor
-         */
-        internal fun create(containingClass: PsiClassItem, original: PsiMethodItem): PsiMethodItem {
-            val typeParameterBindings = containingClass.mapTypeVariables(original.containingClass())
-            val returnType = original.returnType.convertType(typeParameterBindings) as PsiTypeItem
-
-            // This results in a PsiMethodItem that is inconsistent, compared with other
-            // PsiMethodItem. PsiMethodItems created directly from the source are such that:
-            //
-            //    psiMethod.containingClass === containingClass().psiClass
-            //
-            // However, the PsiMethodItem created here contains a psiMethod from a different class,
-            // usually the super class, so:
-            //
-            //    psiMethod.containingClass !== containingClass().psiClass
-            //
-            // If the method was created from the super class then:
-            //
-            //    psiMethod.containingClass === containingClass().superClass().psiClass
-            //
-            // The consequence of this is that the PsiMethodItem does not behave as might be
-            // expected. e.g. superMethods() will find super methods of the method in the super
-            // class, not the PsiMethodItem's containing class.
-            val method =
-                PsiMethodItem(
-                    codebase = original.codebase,
-                    psiMethod = original.psiMethod,
-                    containingClass = containingClass,
-                    name = original.name(),
-                    documentation = original.documentation,
-                    modifiers = original.modifiers.duplicate(),
-                    returnType = returnType,
-                    parameters =
-                        PsiParameterItem.create(original.parameters(), typeParameterBindings),
-                    // This is probably incorrect as the type parameter bindings probably need
-                    // applying here but this is the same behavior as before.
-                    // TODO: Investigate whether the above comment is correct and fix if necessary.
-                    typeParameterList = original.typeParameterList,
-                    throwsTypes = original.throwsTypes,
-                )
 
             return method
         }
-
-        internal fun parameterList(
-            codebase: PsiBasedCodebase,
-            psiMethod: PsiMethod,
-            enclosingTypeItemFactory: PsiTypeItemFactory,
-        ): List<PsiParameterItem> {
-            val psiParameters = psiMethod.psiParameters
-            val fingerprint = MethodFingerprint(psiMethod.name, psiParameters.size)
-            return psiParameters.mapIndexed { index, parameter ->
-                PsiParameterItem.create(
-                    codebase,
-                    fingerprint,
-                    parameter,
-                    index,
-                    enclosingTypeItemFactory
-                )
-            }
-        }
-
-        internal fun throwsTypes(
-            psiMethod: PsiMethod,
-            enclosingTypeItemFactory: PsiTypeItemFactory,
-        ): List<ExceptionTypeItem> {
-            val throwsClassTypes = psiMethod.throwsList.referencedTypes
-            if (throwsClassTypes.isEmpty()) {
-                return emptyList()
-            }
-
-            return throwsClassTypes
-                // Convert the PsiType to an ExceptionTypeItem and wrap it in a ThrowableType.
-                .map { psiType -> enclosingTypeItemFactory.getExceptionType(PsiTypeInfo(psiType)) }
-                // We're sorting the names here even though outputs typically do their own sorting,
-                // since for example the MethodItem.sameSignature check wants to do an
-                // element-by-element comparison to see if the signature matches, and that should
-                // match overrides even if they specify their elements in different orders.
-                .sortedWith(ExceptionTypeItem.fullNameComparator)
-        }
     }
 }
-
-/** Get the [PsiParameter]s for a [PsiMethod]. */
-val PsiMethod.psiParameters: List<PsiParameter>
-    get() = if (this is UMethod) uastParameters else parameterList.parameters.toList()
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
index aebf603b3..8520b4e31 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
@@ -18,44 +18,45 @@ package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.DefaultModifierList.Companion.ABSTRACT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.ACTUAL
-import com.android.tools.metalava.model.DefaultModifierList.Companion.COMPANION
-import com.android.tools.metalava.model.DefaultModifierList.Companion.CONST
-import com.android.tools.metalava.model.DefaultModifierList.Companion.DATA
-import com.android.tools.metalava.model.DefaultModifierList.Companion.DEFAULT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.EXPECT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.FINAL
-import com.android.tools.metalava.model.DefaultModifierList.Companion.FUN
-import com.android.tools.metalava.model.DefaultModifierList.Companion.INFIX
-import com.android.tools.metalava.model.DefaultModifierList.Companion.INLINE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.INTERNAL
-import com.android.tools.metalava.model.DefaultModifierList.Companion.NATIVE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.OPERATOR
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PACKAGE_PRIVATE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PRIVATE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PROTECTED
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PUBLIC
-import com.android.tools.metalava.model.DefaultModifierList.Companion.SEALED
-import com.android.tools.metalava.model.DefaultModifierList.Companion.STATIC
-import com.android.tools.metalava.model.DefaultModifierList.Companion.STRICT_FP
-import com.android.tools.metalava.model.DefaultModifierList.Companion.SUSPEND
-import com.android.tools.metalava.model.DefaultModifierList.Companion.SYNCHRONIZED
-import com.android.tools.metalava.model.DefaultModifierList.Companion.TRANSIENT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.VALUE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.VARARG
-import com.android.tools.metalava.model.DefaultModifierList.Companion.VISIBILITY_MASK
-import com.android.tools.metalava.model.DefaultModifierList.Companion.VOLATILE
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.JAVA_LANG_ANNOTATION_TARGET
 import com.android.tools.metalava.model.JAVA_LANG_TYPE_USE_TARGET
+import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
+import com.android.tools.metalava.model.ModifierFlags.Companion.ACTUAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.COMPANION
+import com.android.tools.metalava.model.ModifierFlags.Companion.CONST
+import com.android.tools.metalava.model.ModifierFlags.Companion.DATA
+import com.android.tools.metalava.model.ModifierFlags.Companion.DEFAULT
+import com.android.tools.metalava.model.ModifierFlags.Companion.EXPECT
+import com.android.tools.metalava.model.ModifierFlags.Companion.FINAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.FUN
+import com.android.tools.metalava.model.ModifierFlags.Companion.INFIX
+import com.android.tools.metalava.model.ModifierFlags.Companion.INLINE
+import com.android.tools.metalava.model.ModifierFlags.Companion.INTERNAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.NATIVE
+import com.android.tools.metalava.model.ModifierFlags.Companion.OPERATOR
+import com.android.tools.metalava.model.ModifierFlags.Companion.PACKAGE_PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PROTECTED
+import com.android.tools.metalava.model.ModifierFlags.Companion.PUBLIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.SEALED
+import com.android.tools.metalava.model.ModifierFlags.Companion.STATIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.STRICT_FP
+import com.android.tools.metalava.model.ModifierFlags.Companion.SUSPEND
+import com.android.tools.metalava.model.ModifierFlags.Companion.SYNCHRONIZED
+import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
+import com.android.tools.metalava.model.ModifierFlags.Companion.VALUE
+import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
+import com.android.tools.metalava.model.ModifierFlags.Companion.VISIBILITY_MASK
+import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
+import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createMutableModifiers
 import com.android.tools.metalava.model.hasAnnotation
 import com.android.tools.metalava.model.isNullnessAnnotation
-import com.android.tools.metalava.model.psi.KotlinTypeInfo.Companion.isInheritedGenericType
 import com.intellij.psi.PsiAnnotation
 import com.intellij.psi.PsiAnnotationMemberValue
 import com.intellij.psi.PsiArrayInitializerMemberValue
-import com.intellij.psi.PsiDocCommentOwner
 import com.intellij.psi.PsiField
 import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiModifier
@@ -68,9 +69,8 @@ import com.intellij.psi.impl.light.LightModifierList
 import org.jetbrains.annotations.NotNull
 import org.jetbrains.annotations.Nullable
 import org.jetbrains.kotlin.analysis.api.analyze
-import org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolWithVisibility
+import org.jetbrains.kotlin.analysis.api.symbols.KaSymbolVisibility
 import org.jetbrains.kotlin.asJava.elements.KtLightElement
-import org.jetbrains.kotlin.descriptors.Visibilities
 import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.KtAnnotated
 import org.jetbrains.kotlin.psi.KtDeclaration
@@ -96,32 +96,22 @@ internal object PsiModifierItem {
     fun create(
         codebase: PsiBasedCodebase,
         element: PsiModifierListOwner,
-        documentation: String? = null,
-    ): DefaultModifierList {
+    ): MutableModifierList {
         val modifiers =
             if (element is UAnnotated) {
-                create(codebase, element, element)
+                createFromUAnnotated(codebase, element, element)
             } else {
-                create(codebase, element)
+                createFromPsiElement(codebase, element)
             }
 
         // Sometimes Psi/Kotlin interoperation goes a little awry and adds nullability annotations
         // that it should not, so this removes them.
-        if (shouldRemoveNullnessAnnotations(element, modifiers)) {
-            modifiers.removeAnnotations { it.isNullnessAnnotation() }
+        if (shouldRemoveNullnessAnnotations(modifiers)) {
+            modifiers.mutateAnnotations { removeIf { it.isNullnessAnnotation() } }
         }
 
-        val docDeprecated =
-            if (codebase.allowReadingComments) {
-                documentation?.contains("@deprecated") == true ||
-                    // Check for @Deprecated annotation
-                    ((element as? PsiDocCommentOwner)?.isDeprecated == true)
-            } else {
-                false
-            }
         if (
-            docDeprecated ||
-                hasDeprecatedAnnotation(modifiers) ||
+            hasDeprecatedAnnotation(modifiers) ||
                 // Check for @Deprecated on sourcePsi
                 isDeprecatedFromSourcePsi(element)
         ) {
@@ -133,8 +123,7 @@ internal object PsiModifierItem {
 
     /** Determine whether nullness annotations need removing from [modifiers]. */
     private fun shouldRemoveNullnessAnnotations(
-        element: PsiModifierListOwner,
-        modifiers: DefaultModifierList,
+        modifiers: BaseModifierList,
     ): Boolean {
         // Kotlin varargs are not nullable but can sometimes and up with an @Nullable annotation
         // added to the [PsiParameter] so remove it from the modifiers. Only Kotlin varargs have a
@@ -143,32 +132,18 @@ internal object PsiModifierItem {
             return true
         }
 
-        // Although https://youtrack.jetbrains.com/issue/KTIJ-19087 has been fixed there still
-        // seems to be an issue with reified type parameters causing nullability annotations
-        // being added to the parameter even when the use site does not require
-        // them. So, this removes them.
-        val kotlinTypeInfo = KotlinTypeInfo.fromContext(element)
-        if (
-            kotlinTypeInfo.analysisSession != null &&
-                kotlinTypeInfo.ktType != null &&
-                kotlinTypeInfo.analysisSession.isInheritedGenericType(kotlinTypeInfo.ktType)
-        ) {
-            return true
-        }
-
         return false
     }
 
-    private fun hasDeprecatedAnnotation(modifiers: DefaultModifierList) =
+    private fun hasDeprecatedAnnotation(modifiers: BaseModifierList) =
         modifiers.hasAnnotation {
-            it.qualifiedName?.let { qualifiedName ->
+            it.qualifiedName.let { qualifiedName ->
                 qualifiedName == "Deprecated" ||
                     qualifiedName.endsWith(".Deprecated") ||
                     // DeprecatedForSdk that do not apply to this API surface have been filtered
                     // out so if any are left then treat it as a standard Deprecated annotation.
                     qualifiedName == ANDROID_DEPRECATED_FOR_SDK
             }
-                ?: false
         }
 
     private fun isDeprecatedFromSourcePsi(element: PsiModifierListOwner): Boolean {
@@ -266,9 +241,9 @@ internal object PsiModifierItem {
                 // modifier, but overrides an internal declaration. Adapted from
                 // org.jetbrains.kotlin.asJava.classes.UltraLightMembersCreator.isInternal
                 analyze(sourcePsi) {
-                    val symbol = (sourcePsi as? KtDeclaration)?.getSymbol()
-                    val visibility = (symbol as? KtSymbolWithVisibility)?.visibility
-                    if (visibility == Visibilities.Internal) {
+                    val symbol = (sourcePsi as? KtDeclaration)?.symbol
+                    val visibility = symbol?.visibility
+                    if (visibility == KaSymbolVisibility.INTERNAL) {
                         visibilityFlags = INTERNAL
                     }
                 }
@@ -407,26 +382,26 @@ internal object PsiModifierItem {
         }
     }
 
-    private fun create(
+    private fun createFromPsiElement(
         codebase: PsiBasedCodebase,
         element: PsiModifierListOwner
-    ): DefaultModifierList {
+    ): MutableModifierList {
         var flags =
             element.modifierList?.let { modifierList -> computeFlag(element, modifierList) }
                 ?: PACKAGE_PRIVATE
 
         val psiAnnotations = element.annotations
         return if (psiAnnotations.isEmpty()) {
-            DefaultModifierList(codebase, flags)
+            createMutableModifiers(flags)
         } else {
-            val annotations: MutableList<AnnotationItem> =
+            val annotations =
                 // psi sometimes returns duplicate annotations, using distinct() to counter
                 // that.
                 psiAnnotations
                     .distinct()
                     // Remove any type-use annotations that psi incorrectly applied to the item.
                     .filterIncorrectTypeUseAnnotations(element)
-                    .map {
+                    .mapNotNull {
                         val qualifiedName = it.qualifiedName
                         // Consider also supporting
                         // com.android.internal.annotations.VisibleForTesting?
@@ -442,20 +417,20 @@ internal object PsiModifierItem {
                             flags = getVisibilityFlag(ref, flags)
                         }
 
-                        PsiAnnotationItem.create(codebase, it, qualifiedName)
+                        PsiAnnotationItem.create(codebase, it)
                     }
                     .filter { !it.isDeprecatedForSdk() }
-                    .toMutableList()
-            DefaultModifierList(codebase, flags, annotations)
+            createMutableModifiers(flags, annotations)
         }
     }
 
-    private fun create(
+    private fun createFromUAnnotated(
         codebase: PsiBasedCodebase,
         element: PsiModifierListOwner,
         annotated: UAnnotated
-    ): DefaultModifierList {
-        val modifierList = element.modifierList ?: return DefaultModifierList(codebase)
+    ): MutableModifierList {
+        val modifierList =
+            element.modifierList ?: return createMutableModifiers(VisibilityLevel.PACKAGE_PRIVATE)
         val uAnnotations = annotated.uAnnotations
         val psiAnnotations =
             modifierList.annotations.takeIf { it.isNotEmpty() }
@@ -466,16 +441,16 @@ internal object PsiModifierItem {
 
         return if (uAnnotations.isEmpty()) {
             if (psiAnnotations.isNotEmpty()) {
-                val annotations: MutableList<AnnotationItem> =
-                    psiAnnotations.map { PsiAnnotationItem.create(codebase, it) }.toMutableList()
-                DefaultModifierList(codebase, flags, annotations)
+                val annotations =
+                    psiAnnotations.mapNotNull { PsiAnnotationItem.create(codebase, it) }
+                createMutableModifiers(flags, annotations)
             } else {
-                DefaultModifierList(codebase, flags)
+                createMutableModifiers(flags)
             }
         } else {
             val isPrimitiveVariable = element is UVariable && element.type is PsiPrimitiveType
 
-            val annotations: MutableList<AnnotationItem> =
+            var annotations =
                 uAnnotations
                     // Uast sometimes puts nullability annotations on primitives!?
                     .filter {
@@ -483,7 +458,7 @@ internal object PsiModifierItem {
                             it.qualifiedName == null ||
                             !it.isKotlinNullabilityAnnotation
                     }
-                    .map {
+                    .mapNotNull {
                         val qualifiedName = it.qualifiedName
                         if (qualifiedName == ANDROIDX_VISIBLE_FOR_TESTING) {
                             val otherwise = it.findAttributeValue(ATTR_OTHERWISE)
@@ -497,10 +472,9 @@ internal object PsiModifierItem {
                             flags = getVisibilityFlag(ref, flags)
                         }
 
-                        UAnnotationItem.create(codebase, it, qualifiedName)
+                        UAnnotationItem.create(codebase, it)
                     }
                     .filter { !it.isDeprecatedForSdk() }
-                    .toMutableList()
 
             if (!isPrimitiveVariable) {
                 if (psiAnnotations.isNotEmpty() && annotations.none { it.isNullnessAnnotation() }) {
@@ -509,12 +483,18 @@ internal object PsiModifierItem {
                             psiAnnotation.qualifiedName?.let { isNullnessAnnotation(it) } == true
                         }
                     ktNullAnnotation?.let {
-                        annotations.add(PsiAnnotationItem.create(codebase, it))
+                        PsiAnnotationItem.create(codebase, it)?.let { annotationItem ->
+                            annotations =
+                                annotations.toMutableList().run {
+                                    add(annotationItem)
+                                    toList()
+                                }
+                        }
                     }
                 }
             }
 
-            DefaultModifierList(codebase, flags, annotations)
+            createMutableModifiers(flags, annotations)
         }
     }
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt
index ae5b8ca8b..1647b279f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt
@@ -16,138 +16,73 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.PackageDoc
+import com.android.tools.metalava.model.item.ResourceFile
+import com.android.tools.metalava.reporter.FileLocation
 import com.intellij.psi.PsiPackage
 
-class PsiPackageItem
+internal class PsiPackageItem
 internal constructor(
-    codebase: PsiBasedCodebase,
+    override val codebase: PsiBasedCodebase,
     private val psiPackage: PsiPackage,
-    private val qualifiedName: String,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    override val overviewDocumentation: String?,
-    /** True if this package is from the classpath (dependencies). Exposed in [isFromClassPath]. */
-    private val fromClassPath: Boolean
+    fileLocation: FileLocation,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    qualifiedName: String,
+    containingPackage: PackageItem?,
+    overviewDocumentation: ResourceFile?,
 ) :
-    PsiItem(
+    DefaultPackageItem(
         codebase = codebase,
+        fileLocation = fileLocation,
+        itemLanguage = psiPackage.itemLanguage,
         modifiers = modifiers,
-        documentation = documentation,
-        element = psiPackage
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
+        qualifiedName = qualifiedName,
+        containingPackage = containingPackage,
+        overviewDocumentation = overviewDocumentation,
     ),
-    PackageItem {
-
-    // Note - top level classes only
-    private val classes: MutableList<ClassItem> = mutableListOf()
-
-    override fun topLevelClasses(): Sequence<ClassItem> =
-        classes.toList().asSequence().filter { it.isTopLevelClass() }
-
-    lateinit var containingPackageField: PsiPackageItem
-
-    override fun containingClass(): ClassItem? = null
+    PackageItem,
+    PsiItem {
 
     override fun psi() = psiPackage
 
-    override fun containingPackage(): PackageItem? {
-        return if (qualifiedName.isEmpty()) null
-        else {
-            if (!::containingPackageField.isInitialized) {
-                var parentPackage = qualifiedName
-                while (true) {
-                    val index = parentPackage.lastIndexOf('.')
-                    if (index == -1) {
-                        containingPackageField = codebase.findPackage("")!!
-                        return containingPackageField
-                    }
-                    parentPackage = parentPackage.substring(0, index)
-                    val pkg = codebase.findPackage(parentPackage)
-                    if (pkg != null) {
-                        containingPackageField = pkg
-                        return pkg
-                    }
-                }
-
-                @Suppress("UNREACHABLE_CODE") null
-            } else {
-                containingPackageField
-            }
-        }
-    }
-
-    fun addClass(cls: PsiClassItem) {
-        if (!cls.isTopLevelClass()) {
-            // TODO: Stash in a list somewhere to make allClasses() faster?
-            return
-        }
-
-        /*
-        // Temp debugging:
-        val q = cls.qualifiedName()
-        for (c in classes) {
-            if (q == c.qualifiedName()) {
-                assert(false, { "Unexpectedly found class $q already listed in $this" })
-                return
-            }
-        }
-        */
-
-        classes.add(cls)
-        cls.containingPackage = this
-    }
-
-    fun addClasses(classList: List<PsiClassItem>) {
-        for (cls in classList) {
-            addClass(cls)
-        }
-    }
-
-    override fun qualifiedName(): String = qualifiedName
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is PackageItem && qualifiedName == other.qualifiedName()
-    }
-
-    override fun hashCode(): Int = qualifiedName.hashCode()
-
-    override fun isFromClassPath(): Boolean = fromClassPath
+    // N.A. a package cannot be contained in a class
+    override fun containingClass(): ClassItem? = null
 
     companion object {
         fun create(
             codebase: PsiBasedCodebase,
             psiPackage: PsiPackage,
-            extraDocs: String?,
-            overviewHtml: String?,
-            fromClassPath: Boolean,
+            packageDoc: PackageDoc,
+            containingPackage: PackageItem?,
         ): PsiPackageItem {
-            val commentText =
-                javadoc(psiPackage, codebase.allowReadingComments) +
-                    if (extraDocs != null) "\n$extraDocs" else ""
-            val modifiers = modifiers(codebase, psiPackage, commentText)
+            val modifiers = PsiModifierItem.create(codebase, psiPackage)
             if (modifiers.isPackagePrivate()) {
                 // packages are always public (if not hidden explicitly with private)
                 modifiers.setVisibilityLevel(VisibilityLevel.PUBLIC)
             }
             val qualifiedName = psiPackage.qualifiedName
 
-            val pkg =
-                PsiPackageItem(
-                    codebase = codebase,
-                    psiPackage = psiPackage,
-                    qualifiedName = qualifiedName,
-                    documentation = commentText,
-                    overviewDocumentation = overviewHtml,
-                    modifiers = modifiers,
-                    fromClassPath = fromClassPath
-                )
-            return pkg
+            return PsiPackageItem(
+                codebase = codebase,
+                psiPackage = psiPackage,
+                fileLocation = packageDoc.fileLocation,
+                modifiers = modifiers,
+                documentationFactory = packageDoc.commentFactory ?: "".toItemDocumentationFactory(),
+                qualifiedName = qualifiedName,
+                containingPackage = containingPackage,
+                overviewDocumentation = packageDoc.overview,
+            )
         }
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
index 3644a55ed..3c1a3707f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
@@ -17,255 +17,61 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterBindings
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.psi.CodePrinter.Companion.constantToSource
+import com.android.tools.metalava.model.item.DefaultParameterItem
+import com.android.tools.metalava.model.item.DefaultValueFactory
+import com.android.tools.metalava.model.item.PublicNameProvider
 import com.android.tools.metalava.model.type.MethodFingerprint
-import com.intellij.psi.LambdaUtil
-import com.intellij.psi.PsiArrayType
 import com.intellij.psi.PsiEllipsisType
 import com.intellij.psi.PsiParameter
 import com.intellij.psi.impl.compiled.ClsParameterImpl
 import org.jetbrains.kotlin.analysis.api.analyze
-import org.jetbrains.kotlin.analysis.api.symbols.KtFunctionLikeSymbol
-import org.jetbrains.kotlin.analysis.api.symbols.KtFunctionSymbol
-import org.jetbrains.kotlin.analysis.api.symbols.KtParameterSymbol
-import org.jetbrains.kotlin.analysis.api.symbols.KtValueParameterSymbol
-import org.jetbrains.kotlin.analysis.api.types.KtTypeNullability
-import org.jetbrains.kotlin.psi.KtConstantExpression
-import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtParameter
-import org.jetbrains.kotlin.psi.psiUtil.hasActualModifier
-import org.jetbrains.uast.UExpression
-import org.jetbrains.uast.UMethod
 import org.jetbrains.uast.UParameter
-import org.jetbrains.uast.UastFacade
 
-class PsiParameterItem
+internal class PsiParameterItem
 internal constructor(
-    codebase: PsiBasedCodebase,
-    private val psiParameter: PsiParameter,
-    private val name: String,
-    override val parameterIndex: Int,
-    modifiers: DefaultModifierList,
-    private val type: PsiTypeItem,
+    override val codebase: PsiBasedCodebase,
+    internal val psiParameter: PsiParameter,
+    modifiers: BaseModifierList,
+    name: String,
+    publicNameProvider: PublicNameProvider,
+    containingCallable: PsiCallableItem,
+    parameterIndex: Int,
+    type: TypeItem,
+    defaultValueFactory: DefaultValueFactory,
 ) :
-    PsiItem(
+    DefaultParameterItem(
         codebase = codebase,
-        element = psiParameter,
+        fileLocation = PsiFileLocation.fromPsiElement(psiParameter),
+        itemLanguage = psiParameter.itemLanguage,
         modifiers = modifiers,
-        documentation = "",
+        name = name,
+        publicNameProvider = publicNameProvider,
+        containingCallable = containingCallable,
+        parameterIndex = parameterIndex,
+        type = type,
+        defaultValueFactory = defaultValueFactory,
     ),
-    ParameterItem {
-    lateinit var containingMethod: PsiMethodItem
+    PsiItem {
 
     override var property: PsiPropertyItem? = null
 
-    override fun name(): String = name
-
     override fun psi() = psiParameter
 
-    override fun publicName(): String? {
-        if (psiParameter.isKotlin()) {
-            // Omit names of some special parameters in Kotlin. None of these parameters may be
-            // set through Kotlin keyword arguments, so there's no need to track their names for
-            // compatibility. This also helps avoid signature file churn if PSI or the compiler
-            // change what name they're using for these parameters.
-
-            // Receiver parameter of extension function
-            if (isReceiver()) {
-                return null
-            }
-            // Property setter parameter
-            if (containingMethod.isKotlinProperty()) {
-                return null
-            }
-            // Continuation parameter of suspend function
-            if (
-                containingMethod.modifiers.isSuspend() &&
-                    "kotlin.coroutines.Continuation" == type.asClass()?.qualifiedName() &&
-                    containingMethod.parameters().size - 1 == parameterIndex
-            ) {
-                return null
-            }
-            return name
-        } else {
-            // Java: Look for @ParameterName annotation
-            val annotation = modifiers.findAnnotation(AnnotationItem::isParameterName)
-            if (annotation != null) {
-                return annotation.attributes.firstOrNull()?.value?.value()?.toString()
-            }
-
-            // Parameter names from classpath jars are not present as annotations
-            if (
-                isFromClassPath() &&
-                    (psiParameter is ClsParameterImpl) &&
-                    !psiParameter.isAutoGeneratedName
-            ) {
-                return name()
-            }
-        }
-
-        return null
-    }
-
-    override fun hasDefaultValue(): Boolean = isDefaultValueKnown()
-
-    override fun isDefaultValueKnown(): Boolean {
-        return if (psiParameter.isKotlin()) {
-            defaultValue() != INVALID_VALUE
-        } else {
-            // Java: Look for @ParameterName annotation
-            modifiers.hasAnnotation(AnnotationItem::isDefaultValue)
-        }
-    }
-
     // Note receiver parameter used to be named $receiver in previous UAST versions, now it is
     // $this$functionName
-    private fun isReceiver(): Boolean = parameterIndex == 0 && name.startsWith("\$this\$")
-
-    private fun getKtParameterSymbol(functionSymbol: KtFunctionLikeSymbol): KtParameterSymbol? {
-        if (isReceiver()) {
-            return functionSymbol.receiverParameter
-        }
-
-        // Perform matching based on parameter names, because indices won't work in the
-        // presence of @JvmOverloads where UAST generates multiple permutations of the
-        // method from the same KtParameters array.
-        val parameters = functionSymbol.valueParameters
+    internal fun isReceiver(): Boolean = parameterIndex == 0 && name().startsWith("\$this\$")
 
-        val index = if (functionSymbol.isExtension) parameterIndex - 1 else parameterIndex
-        val isSuspend = functionSymbol is KtFunctionSymbol && functionSymbol.isSuspend
-        if (isSuspend && index >= parameters.size) {
-            // suspend functions have continuation as a last parameter, which is not
-            // defined in the symbol
-            return null
-        }
-
-        // Quick lookup first which usually works
-        if (index >= 0) {
-            val parameter = parameters[index]
-            if (parameter.name.asString() == name) {
-                return parameter
-            }
-        }
-
-        for (parameter in parameters) {
-            if (parameter.name.asString() == name) {
-                return parameter
-            }
-        }
-
-        // Fallback to handle scenario where the real parameter names are hidden by
-        // UAST (see UastKotlinPsiParameter which replaces parameter names to p$index)
-        if (index >= 0) {
-            val parameter = parameters[index]
-            if (!isReceiver()) {
-                return parameter
-            }
-        }
-
-        return null
-    }
-
-    private var defaultValue: String? = null
-
-    override fun defaultValue(): String? {
-        if (defaultValue == null) {
-            defaultValue = computeDefaultValue()
-        }
-        return defaultValue
-    }
-
-    private fun computeDefaultValue(): String? {
-        if (psiParameter.isKotlin()) {
-            val ktFunction =
-                ((containingMethod.psiMethod as? UMethod)?.sourcePsi as? KtFunction)
-                    ?: return INVALID_VALUE
-
-            analyze(ktFunction) {
-                val function =
-                    if (ktFunction.hasActualModifier()) {
-                        ktFunction.getSymbol().getExpectsForActual().singleOrNull()
-                    } else {
-                        ktFunction.getSymbol()
-                    }
-                if (function !is KtFunctionLikeSymbol) return INVALID_VALUE
-                val symbol = getKtParameterSymbol(function) ?: return INVALID_VALUE
-                if (symbol is KtValueParameterSymbol && symbol.hasDefaultValue) {
-                    val defaultValue =
-                        (symbol.psi as? KtParameter)?.defaultValue ?: return INVALID_VALUE
-                    if (defaultValue is KtConstantExpression) {
-                        return defaultValue.text
-                    }
-
-                    val defaultExpression =
-                        UastFacade.convertElement(defaultValue, null, UExpression::class.java)
-                            as? UExpression
-                            ?: return INVALID_VALUE
-                    val constant = defaultExpression.evaluate()
-                    return if (constant != null && constant !is Pair<*, *>) {
-                        constantToSource(constant)
-                    } else {
-                        // Expression: Compute from UAST rather than just using the source text
-                        // such that we can ensure references are fully qualified etc.
-                        codebase.printer.toSourceString(defaultExpression)
-                    }
-                }
-            }
-
-            return INVALID_VALUE
-        } else {
-            // Java: Look for @ParameterName annotation
-            val annotation = modifiers.findAnnotation(AnnotationItem::isDefaultValue)
-            if (annotation != null) {
-                return annotation.attributes.firstOrNull()?.value?.value()?.toString()
-            }
-        }
-
-        return null
-    }
-
-    override fun type(): TypeItem = type
-
-    override fun containingMethod(): MethodItem = containingMethod
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is ParameterItem &&
-            parameterIndex == other.parameterIndex &&
-            containingMethod == other.containingMethod()
-    }
-
-    override fun hashCode(): Int {
-        return parameterIndex
-    }
-
-    override fun isVarArgs(): Boolean {
-        return psiParameter.isVarArgs || modifiers.isVarArg()
-    }
-
-    /**
-     * Returns whether this parameter is SAM convertible or a Kotlin lambda. If this parameter is
-     * the last parameter, it also means that it could be called in Kotlin using the trailing lambda
-     * syntax.
-     *
-     * Specifically this will attempt to handle the follow cases:
-     * - Java SAM interface = true
-     * - Kotlin SAM interface = false // Kotlin (non-fun) interfaces are not SAM convertible
-     * - Kotlin fun interface = true
-     * - Kotlin lambda = true
-     * - Any other type = false
-     */
-    fun isSamCompatibleOrKotlinLambda(): Boolean {
+    override fun isSamCompatibleOrKotlinLambda(): Boolean {
         // Method is defined in Java source
         if (isJava()) {
             // Check the parameter type to see if it is defined in Kotlin or not.
@@ -277,13 +83,13 @@ internal constructor(
             // with trailing lambda syntax), but in reality the amount of Java methods with a Kotlin
             // interface with a single abstract method from an external dependency should be
             // minimal, so just checking source will make this easier to maintain in the future.
-            val cls = type.asClass()
+            val cls = type().asClass()
             if (cls != null && cls.isKotlin()) {
                 return cls.isInterface() && cls.modifiers.isFunctional()
             }
             // Note: this will return `true` if the interface is defined in Kotlin, hence why we
             // need the prior check as well
-            return LambdaUtil.isFunctionalType(type.psiType)
+            return type().let { it is ClassTypeItem && it.isFunctionalType() }
             // Method is defined in Kotlin source
         } else {
             // For Kotlin declarations we can re-use the existing utilities for calculating whether
@@ -291,8 +97,8 @@ internal constructor(
             // and avoid any divergence from the actual compiler behaviour, if there are changes.
             val parameter = (psi() as? UParameter)?.sourcePsi as? KtParameter ?: return false
             analyze(parameter) {
-                val ktType = parameter.getParameterSymbol().returnType
-                val isSamType = ktType.isFunctionalInterfaceType
+                val ktType = parameter.symbol.returnType
+                val isSamType = ktType.isFunctionalInterface
                 val isFunctionalType =
                     ktType.isFunctionType ||
                         ktType.isSuspendFunctionType ||
@@ -303,9 +109,26 @@ internal constructor(
         }
     }
 
+    override fun duplicate(
+        containingCallable: CallableItem,
+        typeVariableMap: TypeParameterBindings
+    ) =
+        PsiParameterItem(
+            codebase = codebase,
+            psiParameter = psiParameter,
+            modifiers = modifiers,
+            name = name(),
+            publicNameProvider = publicNameProvider,
+            containingCallable = containingCallable as PsiCallableItem,
+            parameterIndex = parameterIndex,
+            type = type().convertType(typeVariableMap) as PsiTypeItem,
+            defaultValueFactory = defaultValue::duplicate,
+        )
+
     companion object {
         internal fun create(
             codebase: PsiBasedCodebase,
+            containingCallable: PsiCallableItem,
             fingerprint: MethodFingerprint,
             psiParameter: PsiParameter,
             parameterIndex: Int,
@@ -313,36 +136,10 @@ internal constructor(
         ): PsiParameterItem {
             val name = psiParameter.name
             val modifiers = createParameterModifiers(codebase, psiParameter)
-            val psiType = psiParameter.type
-            // UAST workaround: nullity of element type in last `vararg` parameter's array type
-            val workaroundPsiType =
-                if (
-                    psiParameter is UParameter &&
-                        psiParameter.sourcePsi is KtParameter &&
-                        psiParameter.isVarArgs && // last `vararg`
-                        psiType is PsiArrayType
-                ) {
-                    val ktParameter = psiParameter.sourcePsi as KtParameter
-                    val annotationProvider =
-                        when (codebase.uastResolveService?.nullability(ktParameter)) {
-                            KtTypeNullability.NON_NULLABLE ->
-                                codebase.getNonNullAnnotationProvider()
-                            KtTypeNullability.NULLABLE -> codebase.getNullableAnnotationProvider()
-                            else -> null
-                        }
-                    val annotatedType =
-                        if (annotationProvider != null) {
-                            psiType.componentType.annotate(annotationProvider)
-                        } else {
-                            psiType.componentType
-                        }
-                    PsiEllipsisType(annotatedType, annotatedType.annotationProvider)
-                } else {
-                    psiType
-                }
+            val psiType = codebase.psiAssembler.getPsiTypeForPsiParameter(psiParameter)
             val type =
                 enclosingMethodTypeItemFactory.getMethodParameterType(
-                    underlyingParameterType = PsiTypeInfo(workaroundPsiType, psiParameter),
+                    underlyingParameterType = PsiTypeInfo(psiType, psiParameter),
                     itemAnnotations = modifiers.annotations(),
                     fingerprint = fingerprint,
                     parameterIndex = parameterIndex,
@@ -352,44 +149,23 @@ internal constructor(
                 PsiParameterItem(
                     codebase = codebase,
                     psiParameter = psiParameter,
+                    modifiers = modifiers,
                     name = name,
+                    publicNameProvider = { (it as PsiParameterItem).getPublicName() },
+                    containingCallable = containingCallable,
                     parameterIndex = parameterIndex,
-                    modifiers = modifiers,
                     // Need to down cast as [isSamCompatibleOrKotlinLambda] needs access to the
                     // underlying PsiType.
-                    type = type as PsiTypeItem
-                )
-            return parameter
-        }
-
-        fun create(
-            original: PsiParameterItem,
-            typeParameterBindings: TypeParameterBindings
-        ): PsiParameterItem {
-            val type = original.type.convertType(typeParameterBindings) as PsiTypeItem
-            val parameter =
-                PsiParameterItem(
-                    codebase = original.codebase,
-                    psiParameter = original.psiParameter,
-                    name = original.name,
-                    parameterIndex = original.parameterIndex,
-                    modifiers = original.modifiers.duplicate(),
-                    type = type
+                    type = type as PsiTypeItem,
+                    defaultValueFactory = { PsiDefaultValue(it as PsiParameterItem) }
                 )
             return parameter
         }
 
-        fun create(
-            original: List<ParameterItem>,
-            typeParameterBindings: TypeParameterBindings
-        ): List<PsiParameterItem> {
-            return original.map { create(it as PsiParameterItem, typeParameterBindings) }
-        }
-
         private fun createParameterModifiers(
             codebase: PsiBasedCodebase,
             psiParameter: PsiParameter
-        ): DefaultModifierList {
+        ): MutableModifierList {
             val modifiers = PsiModifierItem.create(codebase, psiParameter)
             // Method parameters don't have a visibility level; they are visible to anyone that can
             // call their method. However, Kotlin constructors sometimes appear to specify the
@@ -402,12 +178,50 @@ internal constructor(
             modifiers.setVisibilityLevel(VisibilityLevel.PACKAGE_PRIVATE)
             return modifiers
         }
+    }
+}
 
-        /**
-         * Private marker return value from [#computeDefaultValue] signifying that the parameter has
-         * a default value but we were unable to compute a suitable static string representation for
-         * it
-         */
-        private const val INVALID_VALUE = "__invalid_value__"
+/** Get the public name of this parameter. */
+internal fun PsiParameterItem.getPublicName(): String? {
+    if (psiParameter.isKotlin()) {
+        // Omit names of some special parameters in Kotlin. None of these parameters may be set
+        // through Kotlin keyword arguments, so there's no need to track their names for
+        // compatibility. This also helps avoid signature file churn if PSI or the compiler change
+        // what name they're using for these parameters.
+
+        // Receiver parameter of extension function
+        if (isReceiver()) {
+            return null
+        }
+        // Property setter parameter
+        if (possibleContainingMethod()?.isKotlinProperty() == true) {
+            return null
+        }
+        // Continuation parameter of suspend function
+        if (
+            containingCallable().modifiers.isSuspend() &&
+                "kotlin.coroutines.Continuation" == type().asClass()?.qualifiedName() &&
+                containingCallable().parameters().size - 1 == parameterIndex
+        ) {
+            return null
+        }
+        return name()
+    } else {
+        // Java: Look for @ParameterName annotation
+        val annotation = modifiers.findAnnotation(AnnotationItem::isParameterName)
+        if (annotation != null) {
+            return annotation.attributes.firstOrNull()?.value?.value()?.toString()
+        }
+
+        // Parameter names from classpath jars are not present as annotations
+        if (
+            origin == ClassOrigin.CLASS_PATH &&
+                (psiParameter is ClsParameterImpl) &&
+                !psiParameter.isAutoGeneratedName
+        ) {
+            return name()
+        }
     }
+
+    return null
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
index c2a63e237..fcb24124e 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
@@ -16,57 +16,54 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.item.DefaultPropertyItem
 import com.intellij.psi.PsiMethod
 import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
 import org.jetbrains.uast.UAnnotation
 import org.jetbrains.uast.toUElement
 
-class PsiPropertyItem
+internal class PsiPropertyItem
 private constructor(
-    codebase: PsiBasedCodebase,
+    override val codebase: PsiBasedCodebase,
     private val psiMethod: PsiMethod,
-    containingClass: PsiClassItem,
+    modifiers: BaseModifierList,
+    // This needs to be passed in because the documentation may come from the property, or it may
+    // come from the getter method.
+    documentationFactory: ItemDocumentationFactory,
     name: String,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    private val fieldType: PsiTypeItem,
-    override val getter: PsiMethodItem,
-    override val setter: PsiMethodItem?,
-    override val constructorParameter: PsiParameterItem?,
-    override val backingField: PsiFieldItem?
+    containingClass: ClassItem,
+    type: TypeItem,
+    override val getter: MethodItem,
+    override val setter: MethodItem?,
+    override val constructorParameter: ParameterItem?,
+    override val backingField: FieldItem?
 ) :
-    PsiMemberItem(
+    DefaultPropertyItem(
         codebase = codebase,
+        fileLocation = PsiFileLocation(psiMethod),
+        itemLanguage = psiMethod.itemLanguage,
         modifiers = modifiers,
-        documentation = documentation,
-        element = psiMethod,
-        containingClass = containingClass,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
         name = name,
+        containingClass = containingClass,
+        type = type,
     ),
-    PropertyItem {
-
-    override fun type(): TypeItem = fieldType
+    PropertyItem,
+    PsiItem {
 
     override fun psi() = psiMethod
 
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is FieldItem &&
-            name == other.name() &&
-            containingClass == other.containingClass()
-    }
-
-    override fun hashCode(): Int {
-        return name.hashCode()
-    }
-
     companion object {
         /**
          * Creates a new property item, given a [name], [type] and relationships to other items.
@@ -89,22 +86,22 @@ private constructor(
          */
         internal fun create(
             codebase: PsiBasedCodebase,
-            containingClass: PsiClassItem,
+            containingClass: ClassItem,
             name: String,
-            type: PsiTypeItem,
+            type: TypeItem,
             getter: PsiMethodItem,
             setter: PsiMethodItem? = null,
             constructorParameter: PsiParameterItem? = null,
             backingField: PsiFieldItem? = null
         ): PsiPropertyItem {
             val psiMethod = getter.psiMethod
-            val documentation =
+            // Get the appropriate element from which to retrieve the documentation.
+            val psiElement =
                 when (val sourcePsi = getter.sourcePsi) {
-                    is KtPropertyAccessor ->
-                        javadoc(sourcePsi.property, codebase.allowReadingComments)
-                    else -> javadoc(sourcePsi ?: psiMethod, codebase.allowReadingComments)
+                    is KtPropertyAccessor -> sourcePsi.property
+                    else -> sourcePsi ?: psiMethod
                 }
-            val modifiers = modifiers(codebase, psiMethod, documentation)
+            val modifiers = PsiModifierItem.create(codebase, psiMethod)
             // Alas, annotations whose target is property won't be bound to anywhere in LC/UAST,
             // if the property doesn't need a backing field. Same for unspecified use-site target.
             // To preserve such annotations, our last resort is to examine source PSI directly.
@@ -121,7 +118,8 @@ private constructor(
                         } else null
                     }
                 annotations?.forEach { uAnnotation ->
-                    val annotationItem = UAnnotationItem.create(codebase, uAnnotation)
+                    val annotationItem =
+                        UAnnotationItem.create(codebase, uAnnotation) ?: return@forEach
                     if (annotationItem !in modifiers.annotations()) {
                         modifiers.addAnnotation(annotationItem)
                     }
@@ -131,11 +129,11 @@ private constructor(
                 PsiPropertyItem(
                     codebase = codebase,
                     psiMethod = psiMethod,
-                    containingClass = containingClass,
-                    name = name,
-                    documentation = documentation,
                     modifiers = modifiers,
-                    fieldType = type,
+                    documentationFactory = PsiItemDocumentation.factory(psiElement, codebase),
+                    name = name,
+                    containingClass = containingClass,
+                    type = type,
                     getter = getter,
                     setter = setter,
                     constructorParameter = constructorParameter,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
index 5dd21acb8..2e5ea6766 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
@@ -113,7 +113,7 @@ internal class PsiSourceFile(
                         }
                     } else if (resolved is PsiMethod) {
                         codebase.findClass(resolved.containingClass ?: continue) ?: continue
-                        val methodItem = codebase.findMethod(resolved)
+                        val methodItem = codebase.findCallableByPsiMethod(resolved)
                         if (predicate.test(methodItem)) {
                             imports.add(Import(methodItem))
                         }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
index 701996e30..211dd337c 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
@@ -18,19 +18,15 @@ package com.android.tools.metalava.model.psi
 
 import com.android.SdkConstants
 import com.android.tools.lint.UastEnvironment
-import com.android.tools.lint.annotations.Extractor
 import com.android.tools.lint.computeMetadata
 import com.android.tools.lint.detector.api.Project
 import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
-import com.android.tools.metalava.model.source.SourceCodebase
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
-import com.android.tools.metalava.model.source.utils.OVERVIEW_HTML
-import com.android.tools.metalava.model.source.utils.PACKAGE_HTML
-import com.android.tools.metalava.model.source.utils.findPackage
 import com.android.tools.metalava.reporter.Reporter
 import com.intellij.pom.java.LanguageLevel
 import java.io.File
@@ -69,6 +65,7 @@ internal class PsiSourceParser(
     private val useK2Uast: Boolean = false,
     private val allowReadingComments: Boolean,
     private val jdkHome: File? = null,
+    private val projectDescription: File? = null,
 ) : SourceParser {
 
     override fun getClassResolver(classPath: List<File>): ClassResolver {
@@ -92,7 +89,7 @@ internal class PsiSourceParser(
         commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
-    ): PsiBasedCodebase {
+    ): Codebase {
         return parseAbsoluteSources(
             sourceSet.absoluteCopy().extractRoots(reporter),
             commonSourceSet.absoluteCopy().extractRoots(reporter),
@@ -113,16 +110,22 @@ internal class PsiSourceParser(
 
         val rootDir = sourceSet.sourcePath.firstOrNull() ?: File("").canonicalFile
 
-        if (commonSourceSet.sources.isNotEmpty()) {
-            configureUastEnvironmentForKMP(
-                config,
-                sourceSet.sources,
-                commonSourceSet.sources,
-                classpath,
-                rootDir
-            )
-        } else {
-            configureUastEnvironment(config, sourceSet.sourcePath, classpath, rootDir)
+        when {
+            projectDescription != null -> {
+                configureUastEnvironmentFromProjectDescription(config, projectDescription)
+            }
+            commonSourceSet.sources.isNotEmpty() -> {
+                configureUastEnvironmentForKMP(
+                    config,
+                    sourceSet.sources,
+                    commonSourceSet.sources,
+                    classpath,
+                    rootDir
+                )
+            }
+            else -> {
+                configureUastEnvironment(config, sourceSet.sourcePath, classpath, rootDir)
+            }
         }
         // K1 UAST: loading of JDK (via compiler config, i.e., only for FE1.0), when using JDK9+
         jdkHome?.let {
@@ -133,40 +136,44 @@ internal class PsiSourceParser(
         }
 
         val environment = psiEnvironmentManager.createEnvironment(config)
-
         val kotlinFiles = sourceSet.sources.filter { it.path.endsWith(SdkConstants.DOT_KT) }
         environment.analyzeFiles(kotlinFiles)
 
-        val units = Extractor.createUnitsForFiles(environment.ideaProject, sourceSet.sources)
-        val packageDocs = gatherPackageJavadoc(sourceSet)
+        val assembler =
+            PsiCodebaseAssembler(environment) {
+                PsiBasedCodebase(
+                    location = rootDir,
+                    description = description,
+                    annotationManager = annotationManager,
+                    reporter = reporter,
+                    allowReadingComments = allowReadingComments,
+                    assembler = it,
+                )
+            }
 
-        val codebase =
-            PsiBasedCodebase(
-                location = rootDir,
-                description = description,
-                annotationManager = annotationManager,
-                reporter = reporter,
-                allowReadingComments = allowReadingComments,
-            )
-        codebase.initializeFromSources(environment, units, packageDocs)
-        return codebase
+        assembler.initializeFromSources(sourceSet)
+        return assembler.codebase
     }
 
     private fun isJdkModular(homePath: File): Boolean {
         return File(homePath, "jmods").isDirectory
     }
 
-    override fun loadFromJar(apiJar: File): SourceCodebase {
+    override fun loadFromJar(apiJar: File): Codebase {
         val environment = loadUastFromJars(listOf(apiJar))
-        val codebase =
-            PsiBasedCodebase(
-                location = apiJar,
-                description = "Codebase loaded from $apiJar",
-                annotationManager = annotationManager,
-                reporter = reporter,
-                allowReadingComments = allowReadingComments
-            )
-        codebase.initializeFromJar(environment, apiJar)
+        val assembler =
+            PsiCodebaseAssembler(environment) { assembler ->
+                PsiBasedCodebase(
+                    location = apiJar,
+                    description = "Codebase loaded from $apiJar",
+                    annotationManager = annotationManager,
+                    reporter = reporter,
+                    allowReadingComments = allowReadingComments,
+                    assembler = assembler,
+                )
+            }
+        val codebase = assembler.codebase
+        assembler.initializeFromJar(apiJar)
         return codebase
     }
 
@@ -233,7 +240,11 @@ internal class PsiSourceParser(
             for (dep in classpath) {
                 // TODO: what other kinds of dependencies?
                 if (dep.extension !in SUPPORTED_CLASSPATH_EXT) continue
-                appendLine("    <classpath ${dep.extension}=\"${dep.absolutePath}\" />")
+                if (dep.extension == "klib") {
+                    appendLine("    <klib file=\"${dep.absolutePath}\" />")
+                } else {
+                    appendLine("    <classpath ${dep.extension}=\"${dep.absolutePath}\" />")
+                }
             }
         }
 
@@ -294,6 +305,13 @@ internal class PsiSourceParser(
         }
         projectXml.writeText(description)
 
+        configureUastEnvironmentFromProjectDescription(config, projectXml)
+    }
+
+    private fun configureUastEnvironmentFromProjectDescription(
+        config: UastEnvironment.Configuration,
+        projectDescription: File,
+    ) {
         val lintClient = MetalavaCliClient()
         // This will parse the description of Lint's project model and populate the module structure
         // inside the given Lint client. We will use it to set up the project structure that
@@ -303,7 +321,7 @@ internal class PsiSourceParser(
         // There are a couple of limitations that force use fall into this long steps:
         //  * Lint Project creation is not exposed at all. Only project.xml parsing is available.
         //  * UastEnvironment Module simply reuses existing Lint Project model.
-        computeMetadata(lintClient, projectXml)
+        computeMetadata(lintClient, projectDescription)
         config.addModules(
             lintClient.knownProjects.map { lintProject ->
                 lintProject.kotlinLanguageLevel = kotlinLanguageLevel
@@ -326,50 +344,3 @@ internal class PsiSourceParser(
         private val SUPPORTED_CLASSPATH_EXT = listOf(AAR, JAR, KLIB)
     }
 }
-
-private fun gatherPackageJavadoc(sourceSet: SourceSet): PackageDocs {
-    val packageComments = HashMap<String, String>(100)
-    val overviewHtml = HashMap<String, String>(10)
-    val hiddenPackages = HashSet<String>(100)
-    val sortedSourceRoots = sourceSet.sourcePath.sortedBy { -it.name.length }
-    for (file in sourceSet.sources) {
-        var javadoc = false
-        val map =
-            when (file.name) {
-                PACKAGE_HTML -> {
-                    javadoc = true
-                    packageComments
-                }
-                OVERVIEW_HTML -> {
-                    overviewHtml
-                }
-                else -> continue
-            }
-        var contents = file.readText(Charsets.UTF_8)
-        if (javadoc) {
-            contents = packageHtmlToJavadoc(contents)
-        }
-
-        // Figure out the package: if there is a java file in the same directory, get the package
-        // name from the java file. Otherwise, guess from the directory path + source roots.
-        // NOTE: This causes metalava to read files other than the ones explicitly passed to it.
-        var pkg =
-            file.parentFile
-                ?.listFiles()
-                ?.filter { it.name.endsWith(SdkConstants.DOT_JAVA) }
-                ?.asSequence()
-                ?.mapNotNull { findPackage(it) }
-                ?.firstOrNull()
-        if (pkg == null) {
-            // Strip the longest prefix source root.
-            val prefix = sortedSourceRoots.firstOrNull { file.startsWith(it) }?.path ?: ""
-            pkg = file.parentFile.path.substring(prefix.length).trim('/').replace("/", ".")
-        }
-        map[pkg] = contents
-        if (contents.contains("@hide")) {
-            hiddenPackages.add(pkg)
-        }
-    }
-
-    return PackageDocs(packageComments, overviewHtml, hiddenPackages)
-}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt
index 5f5c2a0ad..8030332eb 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItem.kt
@@ -29,6 +29,7 @@ import com.android.tools.metalava.model.TypeModifiers
 import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.WildcardTypeItem
+import com.intellij.psi.LambdaUtil
 import com.intellij.psi.PsiArrayType
 import com.intellij.psi.PsiClassType
 import com.intellij.psi.PsiPrimitiveType
@@ -58,23 +59,31 @@ internal class PsiPrimitiveTypeItem(
     override val kind: PrimitiveTypeItem.Primitive,
     modifiers: TypeModifiers,
 ) : PrimitiveTypeItem, PsiTypeItem(psiType, modifiers) {
-    override fun duplicate(): PsiPrimitiveTypeItem =
-        PsiPrimitiveTypeItem(psiType = psiType, kind = kind, modifiers = modifiers.duplicate())
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers)"),
+    )
+    override fun duplicate(modifiers: TypeModifiers): PsiPrimitiveTypeItem =
+        PsiPrimitiveTypeItem(psiType = psiType, kind = kind, modifiers = modifiers)
 }
 
 /** A [PsiTypeItem] backed by a [PsiArrayType]. */
 internal class PsiArrayTypeItem(
     psiType: PsiType,
-    override val componentType: PsiTypeItem,
+    override val componentType: TypeItem,
     override val isVarargs: Boolean,
     modifiers: TypeModifiers,
 ) : ArrayTypeItem, PsiTypeItem(psiType, modifiers) {
-    override fun duplicate(componentType: TypeItem): ArrayTypeItem =
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, componentType)"),
+    )
+    override fun duplicate(modifiers: TypeModifiers, componentType: TypeItem): ArrayTypeItem =
         PsiArrayTypeItem(
             psiType = psiType,
-            componentType = componentType as PsiTypeItem,
+            componentType = componentType,
             isVarargs = isVarargs,
-            modifiers = modifiers.duplicate()
+            modifiers = modifiers,
         )
 }
 
@@ -84,18 +93,27 @@ internal open class PsiClassTypeItem(
     psiType: PsiType,
     final override val qualifiedName: String,
     final override val arguments: List<TypeArgumentTypeItem>,
-    final override val outerClassType: PsiClassTypeItem?,
-    final override val className: String,
+    final override val outerClassType: ClassTypeItem?,
     modifiers: TypeModifiers,
 ) : ClassTypeItem, PsiTypeItem(psiType, modifiers) {
+    override val className: String = ClassTypeItem.computeClassName(qualifiedName)
 
     private val asClassCache by
         lazy(LazyThreadSafetyMode.NONE) { codebase.resolveClass(qualifiedName) }
 
     override fun asClass() = asClassCache
 
+    override fun isFunctionalType(): Boolean {
+        return LambdaUtil.isFunctionalType(psiType)
+    }
+
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)"),
+    )
     override fun duplicate(
-        outerClass: ClassTypeItem?,
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
         arguments: List<TypeArgumentTypeItem>
     ): ClassTypeItem =
         PsiClassTypeItem(
@@ -103,9 +121,8 @@ internal open class PsiClassTypeItem(
             psiType = psiType,
             qualifiedName = qualifiedName,
             arguments = arguments,
-            outerClassType = outerClass as? PsiClassTypeItem,
-            className = className,
-            modifiers = modifiers.duplicate()
+            outerClassType = outerClassType,
+            modifiers = modifiers,
         )
 }
 
@@ -114,8 +131,7 @@ internal class PsiLambdaTypeItem(
     psiType: PsiType,
     qualifiedName: String,
     arguments: List<TypeArgumentTypeItem>,
-    outerClassType: PsiClassTypeItem?,
-    className: String,
+    outerClassType: ClassTypeItem?,
     modifiers: TypeModifiers,
     override val isSuspend: Boolean,
     override val receiverType: TypeItem?,
@@ -128,13 +144,17 @@ internal class PsiLambdaTypeItem(
         qualifiedName = qualifiedName,
         arguments = arguments,
         outerClassType = outerClassType,
-        className = className,
         modifiers = modifiers,
     ),
     LambdaTypeItem {
 
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)"),
+    )
     override fun duplicate(
-        outerClass: ClassTypeItem?,
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
         arguments: List<TypeArgumentTypeItem>
     ): LambdaTypeItem {
         return PsiLambdaTypeItem(
@@ -142,9 +162,8 @@ internal class PsiLambdaTypeItem(
             psiType = psiType,
             qualifiedName = qualifiedName,
             arguments = arguments,
-            outerClassType = outerClass as? PsiClassTypeItem,
-            className = className,
-            modifiers = modifiers.duplicate(),
+            outerClassType = outerClassType,
+            modifiers = modifiers,
             isSuspend = isSuspend,
             receiverType = receiverType,
             parameterTypes = parameterTypes,
@@ -162,10 +181,14 @@ internal class PsiVariableTypeItem(
 
     override val name: String = asTypeParameter.name()
 
-    override fun duplicate(): PsiVariableTypeItem =
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers)"),
+    )
+    override fun duplicate(modifiers: TypeModifiers): PsiVariableTypeItem =
         PsiVariableTypeItem(
             psiType = psiType,
-            modifiers = modifiers.duplicate(),
+            modifiers = modifiers,
             asTypeParameter = asTypeParameter,
         )
 }
@@ -177,7 +200,12 @@ internal class PsiWildcardTypeItem(
     override val superBound: ReferenceTypeItem?,
     modifiers: TypeModifiers,
 ) : WildcardTypeItem, PsiTypeItem(psiType, modifiers) {
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, extendsBound, superBound)")
+    )
     override fun duplicate(
+        modifiers: TypeModifiers,
         extendsBound: ReferenceTypeItem?,
         superBound: ReferenceTypeItem?
     ): WildcardTypeItem =
@@ -185,6 +213,6 @@ internal class PsiWildcardTypeItem(
             psiType = psiType,
             extendsBound = extendsBound,
             superBound = superBound,
-            modifiers = modifiers.duplicate()
+            modifiers = modifiers,
         )
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
index c2f109e14..703188d77 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
@@ -16,9 +16,9 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.ReferenceTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
@@ -32,6 +32,7 @@ import com.android.tools.metalava.model.WildcardTypeItem
 import com.android.tools.metalava.model.type.ContextNullability
 import com.android.tools.metalava.model.type.DefaultTypeItemFactory
 import com.android.tools.metalava.model.type.DefaultTypeModifiers
+import com.intellij.psi.PsiAnnotation
 import com.intellij.psi.PsiArrayType
 import com.intellij.psi.PsiClassType
 import com.intellij.psi.PsiElement
@@ -42,9 +43,10 @@ import com.intellij.psi.PsiType
 import com.intellij.psi.PsiTypeParameter
 import com.intellij.psi.PsiTypes
 import com.intellij.psi.PsiWildcardType
-import org.jetbrains.kotlin.analysis.api.types.KtFunctionalType
-import org.jetbrains.kotlin.analysis.api.types.KtNonErrorClassType
-import org.jetbrains.kotlin.analysis.api.types.KtTypeMappingMode
+import org.jetbrains.kotlin.analysis.api.KaExperimentalApi
+import org.jetbrains.kotlin.analysis.api.types.KaClassType
+import org.jetbrains.kotlin.analysis.api.types.KaFunctionType
+import org.jetbrains.kotlin.analysis.api.types.KaTypeMappingMode
 import org.jetbrains.kotlin.utils.addToStdlib.ifNotEmpty
 import org.jetbrains.uast.kotlin.isKotlin
 
@@ -58,26 +60,28 @@ data class PsiTypeInfo(val psiType: PsiType, val context: PsiElement? = null)
  * [PsiTypeInfo].
  */
 internal class PsiTypeItemFactory(
-    val codebase: PsiBasedCodebase,
+    private val assembler: PsiCodebaseAssembler,
     typeParameterScope: TypeParameterScope
 ) : DefaultTypeItemFactory<PsiTypeInfo, PsiTypeItemFactory>(typeParameterScope) {
 
+    private val codebase = assembler.codebase
+
     /** Construct a [PsiTypeItemFactory] suitable for creating types within [classItem]. */
     fun from(classItem: ClassItem): PsiTypeItemFactory {
         val scope = TypeParameterScope.from(classItem)
-        return if (scope.isEmpty()) this else PsiTypeItemFactory(codebase, scope)
+        return if (scope.isEmpty()) this else PsiTypeItemFactory(assembler, scope)
     }
 
-    /** Construct a [PsiTypeItemFactory] suitable for creating types within [methodItem]. */
-    fun from(methodItem: MethodItem): PsiTypeItemFactory {
-        val scope = TypeParameterScope.from(methodItem)
-        return if (scope.isEmpty()) this else PsiTypeItemFactory(codebase, scope)
+    /** Construct a [PsiTypeItemFactory] suitable for creating types within [callableItem]. */
+    fun from(callableItem: CallableItem): PsiTypeItemFactory {
+        val scope = TypeParameterScope.from(callableItem)
+        return if (scope.isEmpty()) this else PsiTypeItemFactory(assembler, scope)
     }
 
     override fun self() = this
 
     override fun createNestedFactory(scope: TypeParameterScope) =
-        PsiTypeItemFactory(codebase, scope)
+        PsiTypeItemFactory(assembler, scope)
 
     override fun getType(
         underlyingType: PsiTypeInfo,
@@ -117,7 +121,7 @@ internal class PsiTypeItemFactory(
     fun getClassTypeForClass(psiClassItem: PsiClassItem): PsiClassTypeItem {
         // Create a PsiType for the class. Specifies `PsiSubstitutor.EMPTY` so that if the class
         // has any type parameters then the PsiType will include references to those parameters.
-        val psiTypeWithTypeParametersIfAny = codebase.getClassType(psiClassItem.psiClass)
+        val psiTypeWithTypeParametersIfAny = assembler.getClassType(psiClassItem.psiClass)
         // Create a PsiTypeItemFactory that will correctly resolve any references to the class's
         // type parameters.
         val classTypeItemFactory = from(psiClassItem)
@@ -134,7 +138,7 @@ internal class PsiTypeItemFactory(
         psiTypeParameterItem: PsiTypeParameterItem
     ): VariableTypeItem {
         val psiTypeParameter = psiTypeParameterItem.psi()
-        val psiType = codebase.getClassType(psiTypeParameter)
+        val psiType = assembler.getClassType(psiTypeParameter)
         return createVariableTypeItem(
             psiType,
             null,
@@ -151,13 +155,33 @@ internal class PsiTypeItemFactory(
         kotlinType: KotlinTypeInfo?,
         contextNullability: ContextNullability,
     ): TypeModifiers {
-        val typeAnnotations = type.annotations.map { PsiAnnotationItem.create(codebase, it) }
+        val typeAnnotations =
+            type.annotations.mapNotNull { anno ->
+                // SLC adds JetBrain nullness annotation on types.
+                if (anno.isJetBrainNullnessAnnotation) null
+                else PsiAnnotationItem.create(codebase, anno)
+            }
         // Compute the nullability, factoring in any context nullability, kotlin types and
         // type annotations.
         val nullability = contextNullability.compute(kotlinType?.nullability(), typeAnnotations)
-        return DefaultTypeModifiers.create(typeAnnotations.toMutableList(), nullability)
+        return DefaultTypeModifiers.create(typeAnnotations, nullability)
     }
 
+    private val PsiAnnotation.isJetBrainNotNull: Boolean
+        get() {
+            return qualifiedName == org.jetbrains.annotations.NotNull::class.qualifiedName
+        }
+
+    private val PsiAnnotation.isJetBrainNullable: Boolean
+        get() {
+            return qualifiedName == org.jetbrains.annotations.Nullable::class.qualifiedName
+        }
+
+    private val PsiAnnotation.isJetBrainNullnessAnnotation: Boolean
+        get() {
+            return isJetBrainNotNull || isJetBrainNullable
+        }
+
     /** Create a [PsiTypeItem]. */
     private fun createTypeItem(
         psiType: PsiType,
@@ -183,7 +207,7 @@ internal class PsiTypeItemFactory(
                         // If the type resolves to a PsiTypeParameter then the TypeParameterItem
                         // must exist.
                         is PsiTypeParameter -> {
-                            val name = psiClass.qualifiedName ?: psiType.name
+                            val name = psiClass.simpleName
                             typeParameterScope.getTypeParameter(name)
                         }
                         // If the type could not be resolved then the TypeParameterItem might
@@ -212,7 +236,7 @@ internal class PsiTypeItemFactory(
                         contextNullability = correctedContextNullability,
                     )
                 } else {
-                    if (kotlinType?.ktType is KtFunctionalType) {
+                    if (kotlinType?.kaType is KaFunctionType) {
                         createLambdaTypeItem(
                             psiType = psiType,
                             kotlinType = kotlinType,
@@ -320,8 +344,6 @@ internal class PsiTypeItemFactory(
                     kotlinType,
                     creatingClassTypeForClass = true,
                 ),
-            // This should be able to use `psiType.name`, but that sometimes returns null.
-            className = ClassTypeItem.computeClassName(qualifiedName),
             modifiers = createTypeModifiers(psiType, kotlinType, contextNullability),
         )
     }
@@ -338,8 +360,8 @@ internal class PsiTypeItemFactory(
                 // are no arguments but due to a bug in Psi somewhere. Check to see if the
                 // kotlin type info has a different set of type arguments and if it has then use
                 // that to fix the type, otherwise just assume it should be empty.
-                kotlinType?.ktType?.let { ktType ->
-                    (ktType as? KtNonErrorClassType)?.ownTypeArguments?.ifNotEmpty {
+                kotlinType?.kaType?.let { ktType ->
+                    (ktType as? KaClassType)?.typeArguments?.ifNotEmpty {
                         fixUpPsiTypeMissingTypeArguments(psiType, kotlinType)
                     }
                 }
@@ -427,13 +449,14 @@ internal class PsiTypeItemFactory(
      *
      * The wildcard is correct.
      */
+    @OptIn(KaExperimentalApi::class)
     private fun fixUpPsiTypeMissingTypeArguments(
         psiType: PsiClassType,
         kotlinType: KotlinTypeInfo
     ): List<PsiType> {
-        if (kotlinType.analysisSession == null || kotlinType.ktType == null) return emptyList()
+        if (kotlinType.analysisSession == null || kotlinType.kaType == null) return emptyList()
 
-        val ktType = kotlinType.ktType as KtNonErrorClassType
+        val kaType = kotlinType.kaType as KaClassType
 
         // Restrict this fix to the known issue.
         val className = psiType.className
@@ -452,8 +475,8 @@ internal class PsiTypeItemFactory(
             kotlinType.analysisSession.run {
                 // Use the default mode so that the resulting psiType is
                 // `java.util.Collection<? extends Z>`.
-                val mode = KtTypeMappingMode.DEFAULT
-                ktType.asPsiType(kotlinType.context, false, mode = mode)
+                val mode = KaTypeMappingMode.DEFAULT
+                kaType.asPsiType(kotlinType.context, false, mode = mode)
             } as? PsiClassType
         return psiTypeFromKotlin?.parameters?.toList() ?: emptyList()
     }
@@ -467,13 +490,13 @@ internal class PsiTypeItemFactory(
         // TODO(b/300081840): this drops annotations on the outer class
         return PsiNameHelper.getOuterClassReference(psiType.canonicalText).let { outerClassName ->
             // [PsiNameHelper.getOuterClassReference] returns an empty string if there is no
-            // outer class reference. If the type is not an inner type, it returns the package
+            // outer class reference. If the type is not a nested type, it returns the package
             // name (e.g. for "java.lang.String" it returns "java.lang").
-            if (outerClassName == "" || codebase.findPsiPackage(outerClassName) != null) {
+            if (outerClassName == "" || assembler.findPsiPackage(outerClassName) != null) {
                 null
             } else {
                 val psiOuterClassType =
-                    codebase.createPsiType(
+                    assembler.createPsiType(
                         outerClassName,
                         // The context psi element allows variable types to be resolved (with no
                         // context, they would be interpreted as class types). The [psiContext]
@@ -511,7 +534,7 @@ internal class PsiTypeItemFactory(
     /** If the type item is not nullable and is a boxed type then map it to the unboxed type. */
     private fun unboxTypeWherePossible(typeItem: TypeItem): TypeItem {
         if (
-            typeItem is ClassTypeItem && typeItem.modifiers.nullability() == TypeNullability.NONNULL
+            typeItem is ClassTypeItem && typeItem.modifiers.nullability == TypeNullability.NONNULL
         ) {
             boxedToPsiPrimitiveType[typeItem.qualifiedName]?.let { psiPrimitiveType ->
                 return createPrimitiveTypeItem(psiPrimitiveType, null)
@@ -537,7 +560,7 @@ internal class PsiTypeItemFactory(
      *
      * Extends a [PsiClassTypeItem] and then deconstructs the type arguments of Kotlin `Function<N>`
      * to extract the receiver, input and output types. This makes heavy use of the
-     * [KotlinTypeInfo.ktType] property of [kotlinType] which must be a [KtFunctionalType]. That has
+     * [KotlinTypeInfo.kaType] property of [kotlinType] which must be a [KtFunctionalType]. That has
      * the information necessary to determine which of the Kotlin `Function<N>` class's type
      * arguments are the receiver (if any) and which are input parameters. The last type argument is
      * always the return type.
@@ -549,9 +572,9 @@ internal class PsiTypeItemFactory(
     ): PsiLambdaTypeItem {
         val qualifiedName = psiType.computeQualifiedName()
 
-        val ktType = kotlinType.ktType as KtFunctionalType
+        val kaType = kotlinType.kaType as KaFunctionType
 
-        val isSuspend = ktType.isSuspend
+        val isSuspend = kaType.isSuspend
 
         val actualKotlinType =
             kotlinType.copy(
@@ -560,9 +583,9 @@ internal class PsiTypeItemFactory(
                     // underlying `kotlin.jvm.functions.Function*`.
                     buildList {
                         // The optional lambda receiver is the first type argument.
-                        ktType.receiverType?.let { add(kotlinType.copy(ktType = it)) }
+                        kaType.receiverType?.let { add(kotlinType.copy(kaType = it)) }
                         // The lambda's explicit parameters appear next.
-                        ktType.parameterTypes.mapTo(this) { kotlinType.copy(ktType = it) }
+                        kaType.parameterTypes.mapTo(this) { kotlinType.copy(kaType = it) }
                         // A `suspend` lambda is transformed by Kotlin in the same way that a
                         // `suspend` function is, i.e. an additional continuation parameter is added
                         // at the end of the explicit parameters that encapsulates the return type
@@ -570,12 +593,12 @@ internal class PsiTypeItemFactory(
                         if (isSuspend) {
                             // Create a KotlinTypeInfo for the continuation parameter that
                             // encapsulates the actual return type.
-                            add(kotlinType.forSyntheticContinuationParameter(ktType.returnType))
+                            add(kotlinType.forSyntheticContinuationParameter(kaType.returnType))
                             // Add the `Any?` for the return type.
                             add(kotlinType.nullableAny())
                         } else {
                             // As it is not a `suspend` lambda add the return type last.
-                            add(kotlinType.copy(ktType = ktType.returnType))
+                            add(kotlinType.copy(kaType = kaType.returnType))
                         }
                     }
             )
@@ -586,7 +609,7 @@ internal class PsiTypeItemFactory(
         // If the function has a receiver then it is the first type argument.
         var firstParameterTypeIndex = 0
         val receiverType =
-            if (ktType.hasReceiver) {
+            if (kaType.hasReceiver) {
                 // The first parameter type is now the second type argument.
                 firstParameterTypeIndex = 1
                 unwrapInputType(typeArguments[0])
@@ -611,8 +634,6 @@ internal class PsiTypeItemFactory(
             qualifiedName = qualifiedName,
             arguments = typeArguments,
             outerClassType = computeOuterClass(psiType, actualKotlinType),
-            // This should be able to use `psiType.name`, but that sometimes returns null.
-            className = ClassTypeItem.computeClassName(qualifiedName),
             modifiers = createTypeModifiers(psiType, actualKotlinType, contextNullability),
             isSuspend = isSuspend,
             receiverType = receiverType,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
index 081871468..ff27d8254 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
@@ -16,10 +16,10 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.BoundsTypeItem
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.intellij.psi.PsiTypeParameter
 import org.jetbrains.kotlin.asJava.elements.KotlinLightTypeParameterBuilder
 import org.jetbrains.kotlin.asJava.elements.KtLightDeclaration
@@ -27,56 +27,31 @@ import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.KtTypeParameter
 
 internal class PsiTypeParameterItem(
-    codebase: PsiBasedCodebase,
+    override val codebase: PsiBasedCodebase,
     private val psiClass: PsiTypeParameter,
-    private val name: String,
-    modifiers: DefaultModifierList
+    name: String,
+    modifiers: BaseModifierList
 ) :
-    PsiItem(
+    DefaultTypeParameterItem(
         codebase = codebase,
-        element = psiClass,
+        itemLanguage = psiClass.itemLanguage,
         modifiers = modifiers,
-        documentation = "",
+        name = name,
+        isReified = isReified(psiClass)
     ),
-    TypeParameterItem {
-
-    override fun name() = name
-
-    /** Must only be used by [type] to cache its result. */
-    private lateinit var variableTypeItem: VariableTypeItem
-
-    override fun type(): VariableTypeItem {
-        if (!::variableTypeItem.isInitialized) {
-            variableTypeItem = codebase.globalTypeItemFactory.getVariableTypeForTypeParameter(this)
-        }
-        return variableTypeItem
-    }
+    TypeParameterItem,
+    PsiItem {
 
     override fun psi() = psiClass
 
-    override fun typeBounds(): List<BoundsTypeItem> = bounds
-
-    override fun isReified(): Boolean {
-        return isReified(psiClass as? PsiTypeParameter)
-    }
-
-    internal lateinit var bounds: List<BoundsTypeItem>
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is TypeParameterItem) return false
-
-        return name == other.name()
-    }
-
-    override fun hashCode(): Int {
-        return name.hashCode()
+    override fun createVariableTypeItem(): VariableTypeItem {
+        return codebase.globalTypeItemFactory.getVariableTypeForTypeParameter(this)
     }
 
     companion object {
         fun create(codebase: PsiBasedCodebase, psiClass: PsiTypeParameter): PsiTypeParameterItem {
             val simpleName = psiClass.name!!
-            val modifiers = modifiers(codebase, psiClass)
+            val modifiers = PsiModifierItem.create(codebase, psiClass)
 
             return PsiTypeParameterItem(
                 codebase = codebase,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt
index 4c62821a4..4f68c65a1 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterList.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.DefaultTypeParameterList
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.TypeParameterListAndFactory
 import com.intellij.psi.PsiTypeParameterListOwner
 
 internal object PsiTypeParameterList {
@@ -27,31 +28,28 @@ internal object PsiTypeParameterList {
         enclosingTypeItemFactory: PsiTypeItemFactory,
         scopeDescription: String,
         psiOwner: PsiTypeParameterListOwner
-    ): Pair<TypeParameterList, PsiTypeItemFactory> {
+    ): TypeParameterListAndFactory<PsiTypeItemFactory> {
         val psiTypeParameterList =
             psiOwner.typeParameterList
-                ?: return Pair(TypeParameterList.NONE, enclosingTypeItemFactory)
+                ?: return TypeParameterListAndFactory(
+                    TypeParameterList.NONE,
+                    enclosingTypeItemFactory
+                )
 
-        val (typeParameters, typeItemFactory) =
-            DefaultTypeParameterList.createTypeParameterItemsAndFactory(
-                enclosingTypeItemFactory,
-                scopeDescription,
-                psiTypeParameterList.typeParameters.toList(),
-                { PsiTypeParameterItem.create(codebase, it) },
-                // Create bounds and store it in the [PsiTypeParameterItem.bounds] property.
-                { typeItemFactory, item, psiTypeParameter ->
-                    val refs = psiTypeParameter.extendsList.referencedTypes
-                    val bounds =
-                        if (refs.isEmpty()) {
-                            emptyList()
-                        } else {
-                            refs.mapNotNull { typeItemFactory.getBoundsType(PsiTypeInfo(it)) }
-                        }
-                    item.bounds = bounds
-                    bounds
-                },
-            )
-
-        return Pair(DefaultTypeParameterList(typeParameters), typeItemFactory)
+        return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+            enclosingTypeItemFactory,
+            scopeDescription,
+            psiTypeParameterList.typeParameters.toList(),
+            { PsiTypeParameterItem.create(codebase, it) },
+            // Create bounds and store it in the [PsiTypeParameterItem.bounds] property.
+            { typeItemFactory, psiTypeParameter ->
+                val refs = psiTypeParameter.extendsList.referencedTypes
+                if (refs.isEmpty()) {
+                    emptyList()
+                } else {
+                    refs.mapNotNull { typeItemFactory.getBoundsType(PsiTypeInfo(it)) }
+                }
+            },
+        )
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
index c2306a7d9..2375a677d 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
@@ -22,7 +22,7 @@ import com.android.tools.metalava.model.AnnotationAttribute
 import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationTarget
-import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
 import com.android.tools.metalava.model.DefaultAnnotationAttribute
 import com.android.tools.metalava.model.DefaultAnnotationItem
@@ -47,16 +47,19 @@ import org.jetbrains.uast.UQualifiedReferenceExpression
 import org.jetbrains.uast.UReferenceExpression
 import org.jetbrains.uast.util.isArrayInitializer
 
-class UAnnotationItem
+internal class UAnnotationItem
 private constructor(
     override val codebase: PsiBasedCodebase,
     val uAnnotation: UAnnotation,
-    originalName: String?
+    originalName: String,
+    qualifiedName: String,
 ) :
     DefaultAnnotationItem(
-        codebase,
-        originalName,
-        { getAnnotationAttributes(codebase, uAnnotation) }
+        codebase = codebase,
+        fileLocation = PsiFileLocation.fromPsiElement(uAnnotation.sourcePsi),
+        originalName = originalName,
+        qualifiedName = qualifiedName,
+        attributesGetter = { getAnnotationAttributes(codebase, uAnnotation) },
     ) {
 
     override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
@@ -65,9 +68,7 @@ private constructor(
         return sb.toString()
     }
 
-    override fun resolve(): ClassItem? {
-        return codebase.findOrCreateClass(originalName ?: return null)
-    }
+    override fun snapshot(targetCodebase: Codebase) = this
 
     override fun isNonNull(): Boolean {
         if (uAnnotation.javaPsi is KtLightNullabilityAnnotation<*> && originalName == "") {
@@ -78,7 +79,7 @@ private constructor(
     }
 
     override val targets: Set<AnnotationTarget> by lazy {
-        codebase.annotationManager.computeTargets(this, codebase::findOrCreateClass)
+        codebase.annotationManager.computeTargets(this, codebase::resolveClass)
     }
 
     companion object {
@@ -98,9 +99,16 @@ private constructor(
         fun create(
             codebase: PsiBasedCodebase,
             uAnnotation: UAnnotation,
-            qualifiedName: String? = uAnnotation.qualifiedName
-        ): AnnotationItem {
-            return UAnnotationItem(codebase, uAnnotation, qualifiedName)
+        ): AnnotationItem? {
+            val originalName = uAnnotation.qualifiedName ?: return null
+            val qualifiedName =
+                codebase.annotationManager.normalizeInputName(originalName) ?: return null
+            return UAnnotationItem(
+                codebase = codebase,
+                uAnnotation = uAnnotation,
+                originalName = originalName,
+                qualifiedName = qualifiedName,
+            )
         }
 
         private fun getAttributes(
@@ -222,7 +230,7 @@ private constructor(
                         sb,
                         value,
                         // Normalize the input name of the annotation.
-                        codebase.annotationManager.normalizeInputName(value.qualifiedName),
+                        codebase.annotationManager.normalizeInputName(value.qualifiedName!!),
                         target,
                         showDefaultAttrs
                     )
@@ -298,7 +306,7 @@ private fun createValue(codebase: PsiBasedCodebase, value: UExpression): Annotat
     }
 }
 
-class UAnnotationSingleAttributeValue(
+internal class UAnnotationSingleAttributeValue(
     private val codebase: PsiBasedCodebase,
     private val psiValue: UExpression
 ) : DefaultAnnotationSingleAttributeValue({ getText(psiValue) }, { getValue(psiValue) }) {
@@ -340,7 +348,7 @@ class UAnnotationSingleAttributeValue(
             when (val resolved = psiValue.resolve()) {
                 is PsiField -> return codebase.findField(resolved)
                 is PsiClass -> return codebase.findOrCreateClass(resolved)
-                is PsiMethod -> return codebase.findMethod(resolved)
+                is PsiMethod -> return codebase.findCallableByPsiMethod(resolved)
             }
         }
         return null
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
index 710a910c7..a732d649d 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
@@ -75,11 +75,11 @@ class PsiFieldItemTest : BaseModelTest() {
         ) {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val fooField = fooClass.fields().single()
-            assertEquals(TypeNullability.NONNULL, fooField.type().modifiers.nullability())
+            assertEquals(TypeNullability.NONNULL, fooField.type().modifiers.nullability)
 
             val barClass = codebase.assertClass("test.pkg.Bar")
             val duplicated = fooField.duplicate(barClass)
-            assertEquals(TypeNullability.NONNULL, duplicated.type().modifiers.nullability())
+            assertEquals(TypeNullability.NONNULL, duplicated.type().modifiers.nullability)
         }
     }
 }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiItemTest.kt
index b99466824..16c406f38 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiItemTest.kt
@@ -54,15 +54,16 @@ class PsiItemTest : BaseModelTest() {
             val barJavadoc = "@param bar The bar to foo with\n     *     the thing."
             val bazJavadoc = "@param baz The baz to foo\n     *     I think."
 
-            assertEquals(barJavadoc, method.findTagDocumentation("param"))
-            assertEquals("@return The result", method.findTagDocumentation("return"))
+            val documentation = method.documentation
+            assertEquals(barJavadoc, documentation.findTagDocumentation("param"))
+            assertEquals("@return The result", documentation.findTagDocumentation("return"))
 
-            assertEquals(barJavadoc, method.findTagDocumentation("param", "bar"))
-            assertEquals(bazJavadoc, method.findTagDocumentation("param", "baz"))
+            assertEquals(barJavadoc, documentation.findTagDocumentation("param", "bar"))
+            assertEquals(bazJavadoc, documentation.findTagDocumentation("param", "baz"))
 
             assertEquals(
                 "/**\n     * This method does foo.\n     *\n     * ",
-                method.findMainDocumentation()
+                documentation.findMainDocumentation()
             )
         }
     }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiMethodItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiMethodItemTest.kt
index 7722a7da5..fcfff65f2 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiMethodItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiMethodItemTest.kt
@@ -66,7 +66,7 @@ class PsiMethodItemTest : BaseModelTest() {
             """
             )
         runCodebaseTest(sourceFile) {
-            val ctorItem = codebase.assertClass("Foo").assertMethod("Foo", "")
+            val ctorItem = codebase.assertClass("Foo").assertConstructor("")
             val ctorReturnType = ctorItem.returnType()
 
             val methodItem = codebase.assertClass("Foo").assertMethod("bar", "")
@@ -316,11 +316,11 @@ class PsiMethodItemTest : BaseModelTest() {
         ) {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val toString = fooClass.assertMethod("toString", "")
-            assertEquals(TypeNullability.NONNULL, toString.returnType().modifiers.nullability())
+            assertEquals(TypeNullability.NONNULL, toString.returnType().modifiers.nullability)
 
             val barClass = codebase.assertClass("test.pkg.Bar")
-            val duplicated = barClass.inheritMethodFromNonApiAncestor(toString)
-            assertEquals(TypeNullability.NONNULL, duplicated.returnType().modifiers.nullability())
+            val duplicated = toString.duplicate(barClass)
+            assertEquals(TypeNullability.NONNULL, duplicated.returnType().modifiers.nullability)
         }
     }
 }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt
index 21350a7c0..5d3d4eaee 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt
@@ -103,7 +103,7 @@ class PsiModifierItemTest : BaseModelTest() {
                 """
             )
         ) {
-            assertTrue(codebase.assertClass("Internal").isInternal)
+            assertTrue(codebase.assertResolvedClass("Internal").isInternal)
             assertTrue(codebase.assertClass("Public").isPublic)
             assertTrue(codebase.assertClass("DefaultPublic").isPublic)
             assertTrue(codebase.assertClass("Outer.Private").isPrivate)
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
index 8f94158e0..bd5745805 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
@@ -89,7 +89,7 @@ class PsiParameterItemTest : BaseModelTest() {
 
                 val parameter = parameters[1]
                 assertTrue(parameter.hasDefaultValue())
-                assertEquals("\"\"", parameter.defaultValue())
+                assertEquals("\"\"", parameter.defaultValueAsString())
 
                 // continuation
                 assertFalse(parameters[2].hasDefaultValue())
@@ -102,7 +102,7 @@ class PsiParameterItemTest : BaseModelTest() {
             with(constructorItem) {
                 val parameter = parameters().single()
                 assertTrue(parameter.hasDefaultValue())
-                assertEquals("\"\"", parameter.defaultValue())
+                assertEquals("\"\"", parameter.defaultValueAsString())
             }
 
             val methodItem = classItem.methods().single()
@@ -111,10 +111,10 @@ class PsiParameterItemTest : BaseModelTest() {
                 assertEquals(3, parameters.size)
 
                 assertTrue(parameters[0].hasDefaultValue())
-                assertEquals("\"\"", parameters[0].defaultValue())
+                assertEquals("\"\"", parameters[0].defaultValueAsString())
 
                 assertTrue(parameters[1].hasDefaultValue())
-                assertEquals("param + \"\"", parameters[1].defaultValue())
+                assertEquals("param + \"\"", parameters[1].defaultValueAsString())
 
                 assertFalse(parameters[2].hasDefaultValue())
             }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiPropertyItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiPropertyItemTest.kt
index 572173fc5..1010d194e 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiPropertyItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiPropertyItemTest.kt
@@ -322,8 +322,8 @@ class PsiPropertyItemTest : BaseModelTest() {
             assertContains(parameter.documentation, "parameter doc")
             assertContains(body.documentation, "body doc")
             assertContains(accessors.documentation, "accessors property doc")
-            assertContains(accessors.getter?.documentation.orEmpty(), "getter doc")
-            assertContains(accessors.setter?.documentation.orEmpty(), "setter doc")
+            assertContains(accessors.getter?.documentation?.text.orEmpty(), "getter doc")
+            assertContains(accessors.setter?.documentation?.text.orEmpty(), "setter doc")
         }
     }
 }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
index 586f31a61..9a5cfa196 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
@@ -26,6 +26,7 @@ import com.android.tools.metalava.reporter.BasicReporter
 import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.testing.TemporaryFolderOwner
 import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
 import java.io.File
 import java.io.PrintWriter
 import java.io.StringWriter
@@ -155,4 +156,25 @@ class PsiSourceParserTest : TemporaryFolderOwner, Assertions {
             )
         }
     }
+
+    @Test
+    fun `Regression test for 359909520`() {
+        // Regression test for 359909520: Handle kotlin packages that have `` in them.
+        testCodebase(
+            kotlin(
+                "com/google/receiver/Test.kt",
+                """
+                        package com.google.`receiver`
+                        class Test
+                    """
+            ),
+        ) {
+            val src = listOf(projectDir.resolve("src"))
+            val sourceSet = SourceSet.createFromSourcePath(reporter, src)
+            val roots = sourceSet.extractRoots(reporter).sourcePath
+            assertEquals(1, roots.size)
+            assertEquals(src[0].path, roots[0].path)
+            assertEquals("", output)
+        }
+    }
 }
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiTypeItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiTypeItemTest.kt
index fab445476..23fd6267b 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiTypeItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiTypeItemTest.kt
@@ -51,7 +51,7 @@ class PsiTypeItemTest : BaseModelTest() {
         ) {
             val platformFromKotlin =
                 codebase.assertClass("test.pkg.Foo").methods().single().returnType()
-            assertEquals(platformFromKotlin.modifiers.nullability(), TypeNullability.PLATFORM)
+            assertEquals(platformFromKotlin.modifiers.nullability, TypeNullability.PLATFORM)
         }
     }
 }
diff --git a/metalava-model-snapshot-testing/README.md b/metalava-model-snapshot-testing/README.md
new file mode 100644
index 000000000..4fdfc1568
--- /dev/null
+++ b/metalava-model-snapshot-testing/README.md
@@ -0,0 +1,9 @@
+# metalava-model-snapshot-testing
+
+The purpose of this module is to test the snapshot mechanism by running the testsuite against a number of different
+providers to create a `Codebase` and then take a snapshot of the `Codebase` and perform the actual test against the
+snapshot. This will ensure that the snapshot provides the same capabilities as the original providers.
+
+It does that by registering a `com.android.tools.metalava.model.testing.transformer.CodebaseTransformer` service which
+is loaded by the `com.android.tools.metalava.model.testsuite.ModelSuiteRunner` and used to transform the `Codebase`
+before performing the test.
diff --git a/metalava-model-snapshot-testing/build.gradle.kts b/metalava-model-snapshot-testing/build.gradle.kts
new file mode 100644
index 000000000..90980bf42
--- /dev/null
+++ b/metalava-model-snapshot-testing/build.gradle.kts
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+plugins {
+    `java-library`
+    `java-test-fixtures`
+    id("org.jetbrains.kotlin.jvm")
+    id("metalava-build-plugin")
+
+    // This project does not actually provide an implementation of the metalava-model, but it does
+    // run the test suite over other models, on a snapshot of the codebase they create.
+    id("metalava-model-provider-plugin")
+}
+
+dependencies {
+    testImplementation(project(":metalava-model"))
+    testImplementation(testFixtures(project(":metalava-model")))
+
+    // Include the text model's test runner so that the test suite will run its signature based
+    // tests on a snapshot of the codebase it produces.
+    testImplementation(testFixtures(project(":metalava-model-text")))
+
+    // Pick up the SourceModelSuiteRunner service to run the `metalava-model-testsuite` against a
+    // SourceModelProvider.
+    testImplementation(testFixtures(project(":metalava-model-source")))
+
+    // Include the turbine model's SourceModelProvider so that the test suite will run its Java
+    // based tests on a snapshot of the codebase it produces.
+    testImplementation(project(":metalava-model-turbine"))
+
+    // Include the psi model's SourceModelProvider so that the test suite will run its Java based
+    // tests on a snapshot of the codebase it produces.
+    testImplementation(project(":metalava-model-psi"))
+}
diff --git a/metalava-model-snapshot-testing/lint-baseline.xml b/metalava-model-snapshot-testing/lint-baseline.xml
new file mode 100644
index 000000000..2ed8a3bbf
--- /dev/null
+++ b/metalava-model-snapshot-testing/lint-baseline.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<issues format="6" by="lint 8.2.0-alpha14" type="baseline" client="gradle" dependencies="false" name="AGP (8.2.0-alpha14)" variant="all" version="8.2.0-alpha14">
+
+</issues>
diff --git a/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt b/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt
new file mode 100644
index 000000000..0d716d81a
--- /dev/null
+++ b/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.snapshot
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
+
+/** A [CodebaseTransformer] that will return a snapshot of the supplied [Codebase]. */
+// @AutoService(CodebaseTransformer.class)
+class SnapshotCodebaseTransformer : CodebaseTransformer {
+    override fun transform(codebase: Codebase): Codebase {
+        val fragment =
+            CodebaseFragment(codebase, ::NonEmittableDelegatingVisitor)
+                .snapshotIncludingRevertedItems()
+        return fragment.codebase
+    }
+}
diff --git a/metalava-model-snapshot-testing/src/test/resources/META-INF/services/com.android.tools.metalava.model.testing.transformer.CodebaseTransformer b/metalava-model-snapshot-testing/src/test/resources/META-INF/services/com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
new file mode 100644
index 000000000..7da7f6bd2
--- /dev/null
+++ b/metalava-model-snapshot-testing/src/test/resources/META-INF/services/com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
@@ -0,0 +1 @@
+com.android.tools.metalava.model.snapshot.SnapshotCodebaseTransformer
\ No newline at end of file
diff --git a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
new file mode 100644
index 000000000..37dd64074
--- /dev/null
+++ b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
@@ -0,0 +1,137 @@
+com.android.tools.metalava.model.testsuite.BootstrapSourceModelProviderTest
+  210 Test Method exception list[psi,java,k1]
+  210 Test Method exception list[psi,java,k2]
+  240 test documentations[psi,java,k1]
+  240 test documentations[psi,java,k2]
+  240 test documentations[turbine]
+  260 - test doconly members[psi,java,k1]
+  260 - test doconly members[psi,java,k2]
+  260 - test doconly members[turbine]
+
+com.android.tools.metalava.model.testsuite.CommonApiVariantSelectorsTest
+  Test accessible[psi,java,k1]
+  Test accessible[psi,java,k2]
+  Test accessible[turbine]
+  Test docOnly[psi,java,k1]
+  Test docOnly[psi,java,k2]
+  Test docOnly[turbine]
+  Test not docOnly[psi,java,k1]
+  Test not docOnly[psi,java,k2]
+  Test not docOnly[turbine]
+  Test not hidden[psi,java,k1]
+  Test not hidden[psi,java,k2]
+  Test not hidden[turbine]
+  Test not removed[psi,java,k1]
+  Test not removed[psi,java,k2]
+  Test not removed[turbine]
+  Test originallyHidden hidden[psi,java,k1]
+  Test originallyHidden hidden[psi,java,k2]
+  Test originallyHidden hidden[turbine]
+  Test removed[psi,java,k1]
+  Test removed[psi,java,k2]
+  Test removed[turbine]
+  Test toString[psi,java,k1]
+  Test toString[psi,java,k2]
+  Test toString[turbine]
+
+com.android.tools.metalava.model.testsuite.CommonModifierListWriterTest
+  modifiers public explicitly final method in final class[psi,java,k1]
+  modifiers public explicitly final method in final class[psi,java,k2]
+
+com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTest
+  annotation toSource() with char values[text]
+  annotation toSource() with class values[text]
+  annotation toSource() with compound expression values[text]
+  annotation toSource() with compound expression values[turbine]
+  annotation toSource() with constant literal values[turbine]
+  annotation toSource() with number values[text]
+  annotation with constant literal values[text]
+  annotation with enum values[psi,java,k1]
+  annotation with enum values[psi,java,k2]
+  annotation with infinity values[text]
+  annotation with negative number values[text]
+  annotation with type cast values[text]
+
+com.android.tools.metalava.model.testsuite.classitem.CommonDuplicateClassItemTest
+  Test duplicate classes[turbine]
+
+com.android.tools.metalava.model.testsuite.codebase.CommonCodebaseTest
+  Test getTopLevelClassesFromSource[psi,java,k1]
+  Test getTopLevelClassesFromSource[psi,java,k2]
+  Test getTopLevelClassesFromSource[turbine]
+
+com.android.tools.metalava.model.testsuite.fielditem.CommonFieldItemTest
+  Test implicit nullability of constant field initialized from @NonNull method[turbine]
+
+com.android.tools.metalava.model.testsuite.fielditem.SourceFieldItemTest
+  test default value of an enum constant field[turbine]
+  test non final field with default value as constant expression[turbine]
+
+com.android.tools.metalava.model.testsuite.methoditem.CommonParameterItemTest
+  Test no default value[psi,java,k1]
+  Test no default value[psi,java,k2]
+  Test no default value[psi,kotlin,k1]
+  Test no default value[psi,kotlin,k2]
+  Test no default value[turbine]
+  Test publicName reports correct name when called on binary class - Object#equals[turbine]
+  Test publicName reports correct name when called on binary class - ViewGroup#onLayout[turbine]
+
+com.android.tools.metalava.model.testsuite.packageitem.CommonPackageItemTest
+  Test @hide in package html[psi,java,k1]
+  Test @hide in package html[psi,java,k2]
+  Test @hide in package html[turbine]
+  Test @hide in package info processed first[psi,java,k1]
+  Test @hide in package info processed first[psi,java,k2]
+  Test @hide in package info processed first[turbine]
+  Test @hide in package info processed last[psi,java,k1]
+  Test @hide in package info processed last[psi,java,k2]
+  Test @hide in package info processed last[turbine]
+
+com.android.tools.metalava.model.testsuite.typeitem.CommonIsAssignableFromTest
+  Test assignability without unboxing[psi,java,k1,boxedInt to primitiveInt]
+  Test assignability without unboxing[psi,java,k1,number to boxedInt]
+  Test assignability without unboxing[psi,java,k1,number to primitiveInt]
+  Test assignability without unboxing[psi,java,k1,obj to string]
+  Test assignability without unboxing[psi,java,k2,boxedInt to primitiveInt]
+  Test assignability without unboxing[psi,java,k2,number to boxedInt]
+  Test assignability without unboxing[psi,java,k2,number to primitiveInt]
+  Test assignability without unboxing[psi,java,k2,obj to string]
+  Test assignability without unboxing[psi,kotlin,k1,boxedInt to primitiveInt]
+  Test assignability without unboxing[psi,kotlin,k1,number to boxedInt]
+  Test assignability without unboxing[psi,kotlin,k1,number to primitiveInt]
+  Test assignability without unboxing[psi,kotlin,k1,obj to string]
+  Test assignability without unboxing[psi,kotlin,k2,boxedInt to primitiveInt]
+  Test assignability without unboxing[psi,kotlin,k2,number to boxedInt]
+  Test assignability without unboxing[psi,kotlin,k2,number to primitiveInt]
+  Test assignability without unboxing[psi,kotlin,k2,obj to string]
+  Test assignability without unboxing[text,boxedInt to primitiveInt]
+  Test assignability without unboxing[text,number to boxedInt]
+  Test assignability without unboxing[text,number to primitiveInt]
+  Test assignability without unboxing[text,obj to string]
+  Test assignability without unboxing[turbine,boxedInt to primitiveInt]
+  Test assignability without unboxing[turbine,number to boxedInt]
+  Test assignability without unboxing[turbine,number to primitiveInt]
+  Test assignability without unboxing[turbine,obj to string]
+
+com.android.tools.metalava.model.testsuite.typeitem.CommonTypeModifiersTest
+  Test inner parameterized types with annotations[psi,java,k1]
+  Test inner parameterized types with annotations[psi,java,k2]
+  Test interface types[turbine]
+  Test leading annotation on array type[turbine]
+  Test nullability of Kotlin properties and accessors[psi,kotlin,k1]
+  Test nullability of Kotlin properties and accessors[psi,kotlin,k2]
+  Test nullability of outer classes[psi,java,k1]
+  Test nullability of outer classes[psi,java,k2]
+  Test nullability of varargs[psi,kotlin,k1]
+  Test nullability of varargs[psi,kotlin,k2]
+  Test super class and interface types of interface[turbine]
+
+com.android.tools.metalava.model.testsuite.typeitem.CommonTypeParameterItemTest
+  Test type parameter with annotations[psi,kotlin,k1]
+  Test type parameter with annotations[text]
+
+com.android.tools.metalava.model.testsuite.typeitem.CommonTypeStringTest
+  Type string[psi,java,k1,null annotated parameterized inner type - annotated]
+  Type string[psi,java,k1,null annotated parameterized inner type - kotlin nulls]
+  Type string[psi,java,k2,null annotated parameterized inner type - annotated]
+  Type string[psi,java,k2,null annotated parameterized inner type - kotlin nulls]
diff --git a/metalava-model-source/build.gradle.kts b/metalava-model-source/build.gradle.kts
index de31d0643..4f62bd6d0 100644
--- a/metalava-model-source/build.gradle.kts
+++ b/metalava-model-source/build.gradle.kts
@@ -29,6 +29,7 @@ dependencies {
     implementation(project(":metalava-reporter"))
 
     testFixturesImplementation(project(":metalava-model"))
+    testFixturesImplementation(testFixtures(project(":metalava-model")))
     testFixturesImplementation(project(":metalava-model-testsuite"))
     testFixturesImplementation(project(":metalava-reporter"))
     testFixturesImplementation(libs.androidLintTests)
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
index 5a75195d9..32eab5417 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.source
 
 import com.android.tools.metalava.model.AnnotationManager
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ModelOptions
 import com.android.tools.metalava.reporter.Reporter
 import java.io.Closeable
@@ -31,15 +32,16 @@ import java.io.File
 interface EnvironmentManager : Closeable {
 
     /**
-     * Create a [SourceParser] that can be used to create [SourceCodebase] related objects.
+     * Create a [SourceParser] that can be used to create [Codebase] related objects.
      *
      * @param reporter the [Reporter] to use for any issues found while processing the sources.
      * @param annotationManager the [AnnotationManager] that determines how annotations will affect
-     *   any generated [SourceCodebase]s.
+     *   any generated [Codebase]s.
      * @param javaLanguageLevel the java language level as a string, e.g. 1.8, 17, etc.
      * @param kotlinLanguageLevel the kotlin language level as a string, e.g. 1.8, etc.
      * @param modelOptions a set of model specific options provided by the caller.
      * @param jdkHome the optional path to the jdk home directory.
+     * @param projectDescription Lint project model that can describe project structures in detail.
      */
     fun createSourceParser(
         reporter: Reporter,
@@ -49,6 +51,7 @@ interface EnvironmentManager : Closeable {
         modelOptions: ModelOptions = ModelOptions.empty,
         allowReadingComments: Boolean = true,
         jdkHome: File? = null,
+        projectDescription: File? = null,
     ): SourceParser
 }
 
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceItemDocumentation.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceItemDocumentation.kt
new file mode 100644
index 000000000..8fe6b3a41
--- /dev/null
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceItemDocumentation.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.source
+
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.source.utils.packageHtmlToJavadoc
+import org.intellij.lang.annotations.Language
+
+/** Provides support for creating [ItemDocumentation] from source files. */
+object SourceItemDocumentation {
+    /**
+     * Create an [ItemDocumentationFactory] from a `package.html` file by extracting the contents of
+     * the body tag.
+     */
+    @Language("JAVA")
+    fun fromHTML(@Language("HTML") packageHtml: String?): ItemDocumentationFactory {
+        val text = packageHtmlToJavadoc(packageHtml)
+        return text.toItemDocumentationFactory()
+    }
+}
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceModelProvider.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceModelProvider.kt
index 515c4a09a..3c6fd26ba 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceModelProvider.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceModelProvider.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model.source
 
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ModelOptions
 import com.android.tools.metalava.model.provider.FilterableCodebaseCreator
 import java.util.ServiceLoader
@@ -25,7 +26,7 @@ interface SourceModelProvider : FilterableCodebaseCreator {
 
     /**
      * Create an [EnvironmentManager] that will manage any resources needed while creating
-     * [SourceCodebase]s from source files.
+     * [Codebase]s from source files.
      *
      * @param disableStderrDumping if false then the manager will output useful information to
      *   stderr, otherwise it will suppress the errors.
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
index 1c23d4619..2ee201a83 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
@@ -31,7 +31,7 @@ interface SourceParser {
     fun getClassResolver(classPath: List<File>): ClassResolver
 
     /**
-     * Parse a set of sources into a [SourceCodebase].
+     * Parse a set of sources into a [Codebase].
      *
      * @param sourceSet the list of source files and root directories.
      * @param commonSourceSet the list of source files and root directories in the common module.
@@ -51,12 +51,12 @@ interface SourceParser {
         commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
-    ): SourceCodebase
+    ): Codebase
 
     /**
-     * Load a [SourceCodebase] from a single jar.
+     * Load a [Codebase] from a single jar.
      *
-     * @param apiJar the jar file from which the [SourceCodebase] will be loaded.
+     * @param apiJar the jar file from which the [Codebase] will be loaded.
      */
-    fun loadFromJar(apiJar: File): SourceCodebase
+    fun loadFromJar(apiJar: File): Codebase
 }
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/CommonSourceUtils.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/CommonSourceUtils.kt
deleted file mode 100644
index 66e040fc3..000000000
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/CommonSourceUtils.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.source.utils
-
-import com.android.tools.metalava.model.Item
-import kotlin.properties.ReadWriteProperty
-import kotlin.reflect.KProperty
-
-// a property with a lazily calculated default value
-class LazyDelegate<T>(val defaultValueProvider: () -> T) : ReadWriteProperty<Item, T> {
-    private var currentValue: T? = null
-
-    override operator fun setValue(thisRef: Item, property: KProperty<*>, value: T) {
-        currentValue = value
-    }
-
-    override operator fun getValue(thisRef: Item, property: KProperty<*>): T {
-        if (currentValue == null) {
-            currentValue = defaultValueProvider()
-        }
-
-        return currentValue!!
-    }
-}
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/GatherPackageJavadoc.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/GatherPackageJavadoc.kt
new file mode 100644
index 000000000..c2892b66d
--- /dev/null
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/GatherPackageJavadoc.kt
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.source.utils
+
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.item.MutablePackageDoc
+import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.model.item.ResourceFile
+import com.android.tools.metalava.model.source.SourceSet
+import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.Reporter
+import java.io.File
+
+/** The kinds of package documentation file. */
+private enum class PackageDocumentationKind {
+    PACKAGE {
+        override fun update(packageDoc: MutablePackageDoc, file: File) {
+            val contents = file.readText(Charsets.UTF_8)
+            packageDoc.commentFactory = packageHtmlToJavadoc(contents).toItemDocumentationFactory()
+            packageDoc.fileLocation = FileLocation.forFile(file)
+        }
+    },
+    OVERVIEW {
+        override fun update(packageDoc: MutablePackageDoc, file: File) {
+            packageDoc.overview = ResourceFile(file)
+        }
+    };
+
+    /** Update kind appropriate property in [packageDoc] with [contents]. */
+    abstract fun update(packageDoc: MutablePackageDoc, file: File)
+}
+
+/**
+ * Gather javadoc related to packages from the [sourceSet] and a list of model specific
+ * [packageInfoFiles].
+ *
+ * This will look for `package.html` and `overview.html` files within the source set and then map
+ * that back to a package. It will first check to see if there is a java class in the same directory
+ * and if so then extract the package name from that otherwise it will construct one from the
+ * directory, which may be wrong.
+ *
+ * If a `package.html` and `package-info.java` are provided for the same package then it will be
+ * reported as an error and the comment from the latter will win.
+ *
+ * @param P the model specific `package-info.java` file type.
+ * @param packageNameFilter a lambda that given a package name will return `true` if it is a valid
+ *   package and `false` otherwise. This is used to filter out any packages incorrectly inferred
+ *   from `package.html` files.
+ * @param packageInfoFiles a collection of model specific `package-info.java` files.
+ * @param packageInfoDocExtractor get a [MutablePackageDoc] from a model specific
+ *   `package-info.java` file.
+ */
+fun <P> gatherPackageJavadoc(
+    reporter: Reporter,
+    sourceSet: SourceSet,
+    packageNameFilter: (String) -> Boolean,
+    packageInfoFiles: Collection<P>,
+    packageInfoDocExtractor: (P) -> MutablePackageDoc?,
+): PackageDocs {
+    val packages = mutableMapOf<String, MutablePackageDoc>()
+    val sortedSourceRoots = sourceSet.sourcePath.sortedBy { -it.name.length }
+    for (file in sourceSet.sources) {
+        val documentationFile =
+            when (file.name) {
+                PACKAGE_HTML -> {
+                    PackageDocumentationKind.PACKAGE
+                }
+                OVERVIEW_HTML -> {
+                    PackageDocumentationKind.OVERVIEW
+                }
+                else -> continue
+            }
+
+        // Figure out the package: if there is a java file in the same directory, get the package
+        // name from the java file. Otherwise, guess from the directory path + source roots.
+        // NOTE: This causes metalava to read files other than the ones explicitly passed to it.
+        var pkg =
+            file.parentFile
+                ?.listFiles()
+                ?.filter { it.name.endsWith(DOT_JAVA) }
+                ?.asSequence()
+                ?.mapNotNull { findPackage(it) }
+                ?.firstOrNull()
+        if (pkg == null) {
+            // Strip the longest prefix source root.
+            val prefix = sortedSourceRoots.firstOrNull { file.startsWith(it) }?.path ?: ""
+            pkg = file.parentFile.path.substring(prefix.length).trim('/').replace("/", ".")
+        }
+
+        // If the package name is invalid then skip it.
+        if (!packageNameFilter(pkg)) continue
+
+        val packageDoc = packages.computeIfAbsent(pkg, ::MutablePackageDoc)
+
+        documentationFile.update(packageDoc, file)
+    }
+
+    // Merge package-info.java documentation.
+    for (packageInfoFile in packageInfoFiles) {
+        val (packageName, fileLocation, modifiers, comment, _) =
+            packageInfoDocExtractor(packageInfoFile) ?: continue
+
+        val packageDoc = packages.computeIfAbsent(packageName, ::MutablePackageDoc)
+        if (packageDoc.commentFactory != null) {
+            reporter.report(
+                Issues.BOTH_PACKAGE_INFO_AND_HTML,
+                null,
+                "It is illegal to provide both a package-info.java file and " +
+                    "a package.html file for the same package",
+                fileLocation,
+            )
+        }
+
+        // Always set this as package-info.java is preferred over package.html.
+        packageDoc.fileLocation = fileLocation
+        packageDoc.modifiers = modifiers
+        packageDoc.commentFactory = comment
+    }
+
+    return PackageDocs(packages)
+}
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/JavadocUtils.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/JavadocUtils.kt
new file mode 100644
index 000000000..b7cf97931
--- /dev/null
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/JavadocUtils.kt
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.source.utils
+
+import org.intellij.lang.annotations.Language
+
+/** Converts from package.html content to a package-info.java javadoc string. */
+@Language("JAVA")
+fun packageHtmlToJavadoc(@Language("HTML") packageHtml: String?): String {
+    packageHtml ?: return ""
+    if (packageHtml.isBlank()) {
+        return ""
+    }
+
+    val body = getBodyContents(packageHtml).trim()
+    if (body.isBlank()) {
+        return ""
+    }
+    // Combine into comment lines prefixed by asterisk, ,and make sure we don't
+    // have end-comment markers in the HTML that will escape out of the javadoc comment
+    val comment = body.lines().joinToString(separator = "\n") { " * $it" }.replace("*/", "&#42;/")
+    @Suppress("DanglingJavadoc") return "/**\n$comment\n */\n"
+}
+
+/**
+ * Returns the body content from the given HTML document. Attempts to tokenize the HTML properly
+ * such that it doesn't get confused by comments or text that looks like tags.
+ */
+@Suppress("LocalVariableName")
+private fun getBodyContents(html: String): String {
+    val length = html.length
+    val STATE_TEXT = 1
+    val STATE_SLASH = 2
+    val STATE_ATTRIBUTE_NAME = 3
+    val STATE_IN_TAG = 4
+    val STATE_BEFORE_ATTRIBUTE = 5
+    val STATE_ATTRIBUTE_BEFORE_EQUALS = 6
+    val STATE_ATTRIBUTE_AFTER_EQUALS = 7
+    val STATE_ATTRIBUTE_VALUE_NONE = 8
+    val STATE_ATTRIBUTE_VALUE_SINGLE = 9
+    val STATE_ATTRIBUTE_VALUE_DOUBLE = 10
+    val STATE_CLOSE_TAG = 11
+    val STATE_ENDING_TAG = 12
+
+    var bodyStart = -1
+    var htmlStart = -1
+
+    var state = STATE_TEXT
+    var offset = 0
+    var tagStart = -1
+    var tagEndStart = -1
+    var prev = -1
+    loop@ while (offset < length) {
+        if (offset == prev) {
+            // Purely here to prevent potential bugs in the state machine from looping
+            // infinitely
+            offset++
+            if (offset == length) {
+                break
+            }
+        }
+        prev = offset
+
+        val c = html[offset]
+        when (state) {
+            STATE_TEXT -> {
+                if (c == '<') {
+                    state = STATE_SLASH
+                    offset++
+                    continue@loop
+                }
+
+                // Other text is just ignored
+                offset++
+            }
+            STATE_SLASH -> {
+                if (c == '!') {
+                    if (html.startsWith("!--", offset)) {
+                        // Comment
+                        val end = html.indexOf("-->", offset + 3)
+                        if (end == -1) {
+                            offset = length
+                        } else {
+                            offset = end + 3
+                            state = STATE_TEXT
+                        }
+                        continue@loop
+                    } else if (html.startsWith("![CDATA[", offset)) {
+                        val end = html.indexOf("]]>", offset + 8)
+                        if (end == -1) {
+                            offset = length
+                        } else {
+                            state = STATE_TEXT
+                            offset = end + 3
+                        }
+                        continue@loop
+                    } else {
+                        val end = html.indexOf('>', offset + 2)
+                        if (end == -1) {
+                            offset = length
+                            state = STATE_TEXT
+                        } else {
+                            offset = end + 1
+                            state = STATE_TEXT
+                        }
+                        continue@loop
+                    }
+                } else if (c == '/') {
+                    state = STATE_CLOSE_TAG
+                    offset++
+                    tagEndStart = offset
+                    continue@loop
+                } else if (c == '?') {
+                    // XML Prologue
+                    val end = html.indexOf('>', offset + 2)
+                    if (end == -1) {
+                        offset = length
+                        state = STATE_TEXT
+                    } else {
+                        offset = end + 1
+                        state = STATE_TEXT
+                    }
+                    continue@loop
+                }
+                state = STATE_IN_TAG
+                tagStart = offset
+            }
+            STATE_CLOSE_TAG -> {
+                if (c == '>') {
+                    state = STATE_TEXT
+                    if (html.startsWith("body", tagEndStart, true)) {
+                        val bodyEnd = tagEndStart - 2 // </
+                        if (bodyStart != -1) {
+                            return html.substring(bodyStart, bodyEnd)
+                        }
+                    }
+                    if (html.startsWith("html", tagEndStart, true)) {
+                        val htmlEnd = tagEndStart - 2
+                        if (htmlEnd != -1) {
+                            return html.substring(htmlStart, htmlEnd)
+                        }
+                    }
+                }
+                offset++
+            }
+            STATE_IN_TAG -> {
+                val whitespace = Character.isWhitespace(c)
+                if (whitespace || c == '>') {
+                    if (html.startsWith("body", tagStart, true)) {
+                        bodyStart = html.indexOf('>', offset) + 1
+                    }
+                    if (html.startsWith("html", tagStart, true)) {
+                        htmlStart = html.indexOf('>', offset) + 1
+                    }
+                }
+
+                when {
+                    whitespace -> state = STATE_BEFORE_ATTRIBUTE
+                    c == '>' -> {
+                        state = STATE_TEXT
+                    }
+                    c == '/' -> state = STATE_ENDING_TAG
+                }
+                offset++
+            }
+            STATE_ENDING_TAG -> {
+                if (c == '>') {
+                    if (html.startsWith("body", tagEndStart, true)) {
+                        val bodyEnd = tagEndStart - 1
+                        if (bodyStart != -1) {
+                            return html.substring(bodyStart, bodyEnd)
+                        }
+                    }
+                    if (html.startsWith("html", tagEndStart, true)) {
+                        val htmlEnd = tagEndStart - 1
+                        if (htmlEnd != -1) {
+                            return html.substring(htmlStart, htmlEnd)
+                        }
+                    }
+                    offset++
+                    state = STATE_TEXT
+                }
+            }
+            STATE_BEFORE_ATTRIBUTE -> {
+                if (c == '>') {
+                    state = STATE_TEXT
+                } else if (c == '/') {
+                    // we expect an '>' next to close the tag
+                } else if (!Character.isWhitespace(c)) {
+                    state = STATE_ATTRIBUTE_NAME
+                }
+                offset++
+            }
+            STATE_ATTRIBUTE_NAME -> {
+                when {
+                    c == '>' -> state = STATE_TEXT
+                    c == '=' -> state = STATE_ATTRIBUTE_AFTER_EQUALS
+                    Character.isWhitespace(c) -> state = STATE_ATTRIBUTE_BEFORE_EQUALS
+                    c == ':' -> {}
+                }
+                offset++
+            }
+            STATE_ATTRIBUTE_BEFORE_EQUALS -> {
+                if (c == '=') {
+                    state = STATE_ATTRIBUTE_AFTER_EQUALS
+                } else if (c == '>') {
+                    state = STATE_TEXT
+                } else if (!Character.isWhitespace(c)) {
+                    // Attribute value not specified (used for some boolean attributes)
+                    state = STATE_ATTRIBUTE_NAME
+                }
+                offset++
+            }
+            STATE_ATTRIBUTE_AFTER_EQUALS -> {
+                if (c == '\'') {
+                    // a='b'
+                    state = STATE_ATTRIBUTE_VALUE_SINGLE
+                } else if (c == '"') {
+                    // a="b"
+                    state = STATE_ATTRIBUTE_VALUE_DOUBLE
+                } else if (!Character.isWhitespace(c)) {
+                    // a=b
+                    state = STATE_ATTRIBUTE_VALUE_NONE
+                }
+                offset++
+            }
+            STATE_ATTRIBUTE_VALUE_SINGLE -> {
+                if (c == '\'') {
+                    state = STATE_BEFORE_ATTRIBUTE
+                }
+                offset++
+            }
+            STATE_ATTRIBUTE_VALUE_DOUBLE -> {
+                if (c == '"') {
+                    state = STATE_BEFORE_ATTRIBUTE
+                }
+                offset++
+            }
+            STATE_ATTRIBUTE_VALUE_NONE -> {
+                if (c == '>') {
+                    state = STATE_TEXT
+                } else if (Character.isWhitespace(c)) {
+                    state = STATE_BEFORE_ATTRIBUTE
+                }
+                offset++
+            }
+            else -> assert(false) { state }
+        }
+    }
+
+    return html
+}
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/SourceSetUtils.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/SourceSetUtils.kt
index 84182ca52..306067223 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/SourceSetUtils.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/utils/SourceSetUtils.kt
@@ -32,5 +32,6 @@ fun findPackage(file: File): String? {
 
 /** Finds the package of the given Java/Kotlin source code, if possible */
 private fun findPackage(source: String): String? {
-    return ClassName(source).packageName
+    // Replace is there to handle kotlin packages that have `` in them like com.`receiver`.example
+    return ClassName(source).packageName?.replace("`", "")
 }
diff --git a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
index ec598e8fa..3d0b4d7a6 100644
--- a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
+++ b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
@@ -20,7 +20,9 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunner.SourceDir
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner.TestConfiguration
 import com.android.tools.metalava.reporter.BasicReporter
 import com.android.tools.metalava.testing.getAndroidJar
@@ -28,17 +30,9 @@ import com.android.tools.metalava.testing.getKotlinStdlibPaths
 import java.io.File
 import java.io.PrintWriter
 
-/**
- * A [ModelSuiteRunner] that is implemented using a [SourceModelProvider].
- *
- * This expects to be loaded on a class path that contains a single [SourceModelProvider] service
- * (retrievable via [SourceModelProvider.getImplementation]).
- */
-// @AutoService(ModelSuiteRunner.class)
-class SourceModelSuiteRunner : ModelSuiteRunner {
-
-    /** Get the [SourceModelProvider] implementation that is available. */
-    private val sourceModelProvider = SourceModelProvider.getImplementation({ true }, "of any type")
+/** A [ModelSuiteRunner] that is implemented using a [SourceModelProvider]. */
+class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvider) :
+    ModelSuiteRunner {
 
     override val providerName = sourceModelProvider.providerName
 
@@ -70,7 +64,11 @@ class SourceModelSuiteRunner : ModelSuiteRunner {
                     inputs,
                     classPath,
                 )
-            test(codebase)
+
+            // If available, transform the codebase for testing, otherwise use the one provided.
+            val transformedCodebase = CodebaseTransformer.transformIfAvailable(codebase)
+
+            test(transformedCodebase)
         }
     }
 
@@ -87,16 +85,53 @@ class SourceModelSuiteRunner : ModelSuiteRunner {
                 modelOptions = inputs.modelOptions,
             )
         return sourceParser.parseSources(
-            sourceSet(inputs.mainSourceDir),
+            sourceSet(inputs.mainSourceDir, inputs.additionalMainSourceDir),
             sourceSet(inputs.commonSourceDir),
             description = "Test Codebase",
             classPath = classPath,
         )
     }
 
-    private fun sourceSet(sourceDir: ModelSuiteRunner.SourceDir?) =
-        if (sourceDir == null) SourceSet.empty()
-        else SourceSet(sourceDir.createFiles(), listOf(sourceDir.dir))
+    /**
+     * Create a [SourceSet] from some [SourceDir] instances.
+     *
+     * @param sourceDir if supplied the files created from this will be added to the
+     *   [SourceSet.sources] list and its directory will be added to the [SourceSet.sourcePath]
+     *   list.
+     * @param sourcePathDir if supplied the root directories in which its files are created will be
+     *   added to the [SourceSet.sourcePath] but the files themselves will not be added to the
+     *   [SourceSet.sources] list.
+     */
+    private fun sourceSet(sourceDir: SourceDir?, sourcePathDir: SourceDir? = null) =
+        if (sourceDir == null && sourcePathDir == null) SourceSet.empty()
+        else {
+            val sources = mutableListOf<File>()
+
+            // Create a set that will dedup the directories but maintain the order in which they
+            // were added.
+            val sourcePath = mutableSetOf<File>()
+            if (sourceDir != null) {
+                // Create the files and add them to the sources and the containing directory to the
+                // source path.
+                sources.addAll(sourceDir.createFiles())
+                sourcePath.add(sourceDir.dir)
+            }
+            if (sourcePathDir != null) {
+                // Create the files but do not add them to the sources, instead just add the
+                // directory in which the files were created to the source path.
+                val dir = sourcePathDir.dir
+                for (testFile in sourcePathDir.contents) {
+                    testFile.createFile(dir)
+                    // Get the root directory in which the test file was created and add that to the
+                    // source path.
+                    val rootDir = testFile.targetRootFolder?.let { dir.resolve(it) } ?: dir
+                    sourcePath.add(rootDir)
+                }
+                sourcePath.add(sourcePathDir.dir.resolve("src"))
+            }
+
+            SourceSet(sources, sourcePath.toList())
+        }
 
     override fun toString(): String = sourceModelProvider.providerName
 }
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceCodebase.kt b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunnerProvider.kt
similarity index 50%
rename from metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceCodebase.kt
rename to metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunnerProvider.kt
index 8d9bfe59a..12bdefd2b 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceCodebase.kt
+++ b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunnerProvider.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2023 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,20 +16,14 @@
 
 package com.android.tools.metalava.model.source
 
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
 
 /**
- * Extends [Codebase] to add any additional members needed for [Codebase] implementations created
- * from source files.
+ * A [ModelSuiteRunnerProvider] that will return one [ModelSuiteRunner] for each available
+ * [SourceModelProvider].
  */
-interface SourceCodebase : Codebase {
-    /**
-     * Returns a list of the top-level classes declared in the codebase's source (rather than on its
-     * classpath).
-     */
-    fun getTopLevelClassesFromSource(): List<ClassItem>
-
-    // False since this codebase would be reading from source
-    override fun trustedApi(): Boolean = false
+class SourceModelSuiteRunnerProvider : ModelSuiteRunnerProvider {
+    override val runners: List<ModelSuiteRunner> =
+        SourceModelProvider.implementations.map { SourceModelSuiteRunner(it) }
 }
diff --git a/metalava-model-text/src/test/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunner b/metalava-model-source/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
similarity index 89%
rename from metalava-model-text/src/test/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunner
rename to metalava-model-source/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
index f6397e1c5..74a6daf2e 100644
--- a/metalava-model-text/src/test/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+++ b/metalava-model-source/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
@@ -14,4 +14,4 @@
 # limitations under the License.
 #
 
-com.android.tools.metalava.model.text.TextModelSuiteRunner
\ No newline at end of file
+com.android.tools.metalava.model.source.SourceModelSuiteRunnerProvider
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
index 0728e0974..163413319 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
@@ -21,10 +21,10 @@ import com.android.tools.lint.checks.infrastructure.TestFiles
 import com.android.tools.metalava.model.Assertions
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.provider.InputFormat
-import com.android.tools.metalava.model.source.SourceCodebase
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfigAware
 import com.android.tools.metalava.testing.TemporaryFolderOwner
+import java.io.File
 import org.junit.Rule
 import org.junit.rules.TemporaryFolder
 import org.junit.runner.RunWith
@@ -92,8 +92,11 @@ abstract class BaseModelTest() :
         /** The [InputFormat] of the [testFiles]. */
         val inputFormat: InputFormat,
 
-        /** The [TestFile]s to process. */
+        /** The [TestFile]s to explicitly pass to code being tested. */
         val testFiles: List<TestFile>,
+
+        /** The optional [TestFile]s to pass on source path. */
+        val additionalTestFiles: List<TestFile>?,
     )
 
     /** Create an [InputSet] from a list of [TestFile]s. */
@@ -106,7 +109,7 @@ abstract class BaseModelTest() :
      * ([InputFormat.JAVA] or [InputFormat.KOTLIN]) and signature ([InputFormat.SIGNATURE]). If it
      * contains both [InputFormat.JAVA] and [InputFormat.KOTLIN] then the latter will be used.
      */
-    fun inputSet(vararg testFiles: TestFile): InputSet {
+    fun inputSet(vararg testFiles: TestFile, sourcePathFiles: List<TestFile>? = null): InputSet {
         if (testFiles.isEmpty()) {
             throw IllegalStateException("Must provide at least one source file")
         }
@@ -124,19 +127,28 @@ abstract class BaseModelTest() :
                 // are incompatible.
                 .reduce { if1, if2 -> if1.combineWith(if2) }
 
-        return InputSet(inputFormat, testFiles.toList())
+        return InputSet(inputFormat, testFiles.toList(), sourcePathFiles)
     }
 
     /**
      * Context within which the main body of tests that check the state of the [Codebase] will run.
      */
-    interface CodebaseContext<C : Codebase> {
+    interface CodebaseContext {
         /** The newly created [Codebase]. */
-        val codebase: C
+        val codebase: Codebase
+
+        /** Replace any test run specific directories in [string] with a placeholder string. */
+        fun removeTestSpecificDirectories(string: String): String
     }
 
-    private class DefaultCodebaseContext<C : Codebase>(override val codebase: C) :
-        CodebaseContext<C>
+    inner class DefaultCodebaseContext(
+        override val codebase: Codebase,
+        private val mainSourceDir: File,
+    ) : CodebaseContext {
+        override fun removeTestSpecificDirectories(string: String): String {
+            return cleanupString(string, mainSourceDir)
+        }
+    }
 
     /**
      * Create a [Codebase] from one of the supplied [inputSets] and then run a test on that
@@ -148,7 +160,7 @@ abstract class BaseModelTest() :
     private fun createCodebaseFromInputSetAndRun(
         inputSets: Array<out InputSet>,
         commonSourcesByInputFormat: Map<InputFormat, InputSet> = emptyMap(),
-        test: (Codebase) -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         // Run the input set that matches the current inputFormat, if there is one.
         inputSets
@@ -156,6 +168,8 @@ abstract class BaseModelTest() :
             ?.let { inputSet ->
                 val mainSourceDir = sourceDir(inputSet)
 
+                val additionalSourceDir = inputSet.additionalTestFiles?.let { sourceDir(it) }
+
                 val commonSourceDir =
                     commonSourcesByInputFormat[inputFormat]?.let { commonInputSet ->
                         sourceDir(commonInputSet)
@@ -166,16 +180,23 @@ abstract class BaseModelTest() :
                         inputFormat = inputSet.inputFormat,
                         modelOptions = codebaseCreatorConfig.modelOptions,
                         mainSourceDir = mainSourceDir,
+                        additionalMainSourceDir = additionalSourceDir,
                         commonSourceDir = commonSourceDir,
                     )
-                runner.createCodebaseAndRun(inputs) { codebase -> test(codebase) }
+                runner.createCodebaseAndRun(inputs) { codebase ->
+                    val context = DefaultCodebaseContext(codebase, mainSourceDir.dir)
+                    context.test()
+                }
             }
     }
 
     private fun sourceDir(inputSet: InputSet): ModelSuiteRunner.SourceDir {
+        return sourceDir(inputSet.testFiles)
+    }
+
+    private fun sourceDir(testFiles: List<TestFile>): ModelSuiteRunner.SourceDir {
         val tempDir = temporaryFolder.newFolder()
-        val mainSourceDir = ModelSuiteRunner.SourceDir(dir = tempDir, contents = inputSet.testFiles)
-        return mainSourceDir
+        return ModelSuiteRunner.SourceDir(dir = tempDir, contents = testFiles)
     }
 
     private fun testFilesToInputSets(testFiles: Array<out TestFile>): Array<InputSet> {
@@ -192,7 +213,7 @@ abstract class BaseModelTest() :
     fun runCodebaseTest(
         vararg sources: TestFile,
         commonSources: Array<TestFile> = emptyArray(),
-        test: CodebaseContext<Codebase>.() -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         runCodebaseTest(
             sources = testFilesToInputSets(sources),
@@ -210,7 +231,7 @@ abstract class BaseModelTest() :
     fun runCodebaseTest(
         vararg sources: InputSet,
         commonSources: Array<InputSet> = emptyArray(),
-        test: CodebaseContext<Codebase>.() -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         runCodebaseTest(
             sources = sources,
@@ -228,20 +249,18 @@ abstract class BaseModelTest() :
     private fun runCodebaseTest(
         vararg sources: InputSet,
         commonSourcesByInputFormat: Map<InputFormat, InputSet> = emptyMap(),
-        test: CodebaseContext<Codebase>.() -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
-            sources,
+            inputSets = sources,
             commonSourcesByInputFormat = commonSourcesByInputFormat,
-        ) { codebase ->
-            val context = DefaultCodebaseContext(codebase)
-            context.test()
-        }
+            test = test,
+        )
     }
 
     /**
-     * Create a [SourceCodebase] from one of the supplied [sources] and then run the [test] on that
-     * [SourceCodebase].
+     * Create a [Codebase] from one of the supplied [sources] and then run the [test] on that
+     * [Codebase].
      *
      * The [sources] array should have at most one [TestFile] whose extension matches an
      * [InputFormat.extension].
@@ -249,7 +268,7 @@ abstract class BaseModelTest() :
     fun runSourceCodebaseTest(
         vararg sources: TestFile,
         commonSources: Array<TestFile> = emptyArray(),
-        test: CodebaseContext<SourceCodebase>.() -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         runSourceCodebaseTest(
             sources = testFilesToInputSets(sources),
@@ -260,15 +279,15 @@ abstract class BaseModelTest() :
     }
 
     /**
-     * Create a [SourceCodebase] from one of the supplied [sources] [InputSet]s and then run the
-     * [test] on that [SourceCodebase].
+     * Create a [Codebase] from one of the supplied [sources] [InputSet]s and then run the [test] on
+     * that [Codebase].
      *
      * The [sources] array should have at most one [InputSet] of each [InputFormat].
      */
     fun runSourceCodebaseTest(
         vararg sources: InputSet,
         commonSources: Array<InputSet> = emptyArray(),
-        test: CodebaseContext<SourceCodebase>.() -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         runSourceCodebaseTest(
             sources = sources,
@@ -278,24 +297,21 @@ abstract class BaseModelTest() :
     }
 
     /**
-     * Create a [SourceCodebase] from one of the supplied [sources] [InputSet]s and then run the
-     * [test] on that [SourceCodebase].
+     * Create a [Codebase] from one of the supplied [sources] [InputSet]s and then run the [test] on
+     * that [Codebase].
      *
      * The [sources] array should have at most one [InputSet] of each [InputFormat].
      */
     private fun runSourceCodebaseTest(
         vararg sources: InputSet,
         commonSourcesByInputFormat: Map<InputFormat, InputSet>,
-        test: CodebaseContext<SourceCodebase>.() -> Unit,
+        test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
             commonSourcesByInputFormat = commonSourcesByInputFormat,
-        ) { codebase ->
-            codebase as SourceCodebase
-            val context = DefaultCodebaseContext(codebase)
-            context.test()
-        }
+            test = test,
+        )
     }
 
     /**
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
index 40716815f..22b4731ad 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
@@ -54,7 +54,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    class Test {
+                    public class Test {
                     }
                 """
             ),
@@ -71,14 +71,14 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    class Test {
+                    public class Test {
                     }
                 """
             ),
         ) {
             val packageItem = codebase.assertPackage("test.pkg")
             assertEquals("test.pkg", packageItem.qualifiedName())
-            assertEquals(1, packageItem.topLevelClasses().count(), message = "")
+            assertEquals(1, packageItem.topLevelClasses().size, message = "")
         }
     }
 
@@ -89,7 +89,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    class Test {
+                    public class Test {
                         int field;
                     }
                 """
@@ -109,7 +109,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    class Test {
+                    public class Test {
                         void method();
                     }
                 """
@@ -128,7 +128,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    class Test {
+                    public class Test {
                         public Test() {}
                     }
                 """
@@ -147,7 +147,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    class Test {
+                    public class Test {
                       class InnerTestClass {}
                     }
                 """
@@ -159,7 +159,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             assertEquals("Test.InnerTestClass", innerClassItem.fullName())
             assertEquals("InnerTestClass", innerClassItem.simpleName())
             assertEquals(classItem, innerClassItem.containingClass())
-            assertEquals(1, classItem.innerClasses().count(), message = "")
+            assertEquals(1, classItem.nestedClasses().count(), message = "")
         }
     }
 
@@ -173,12 +173,12 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
 
                         import test.parent.SuperInterface;
 
-                        abstract class SuperClass implements SuperInterface {}
+                        public abstract class SuperClass implements SuperInterface {}
 
-                        interface SuperChildInterface {}
-                        interface ChildInterface extends SuperChildInterface,SuperInterface {}
+                        public interface SuperChildInterface {}
+                        public interface ChildInterface extends SuperChildInterface,SuperInterface {}
 
-                        class Test extends SuperClass implements ChildInterface {}
+                        public class Test extends SuperClass implements ChildInterface {}
                     """
                 ),
                 java(
@@ -214,9 +214,9 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                   package test.pkg;
 
-                  interface TestInterface {}
-                  enum TestEnum {}
-                  @interface TestAnnotation {}
+                  public interface TestInterface {}
+                  public enum TestEnum {}
+                  public @interface TestAnnotation {}
                 """
             ),
         ) {
@@ -237,7 +237,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     """
                         package test.pkg;
 
-                        class Test {
+                        public class Test {
                             class Inner {}
                         }
                     """
@@ -252,8 +252,8 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             val rootPackageItem = codebase.assertPackage("")
             val classItem = codebase.assertClass("test.pkg.Test")
             val innerClassItem = codebase.assertClass("test.pkg.Test.Inner")
-            assertEquals(1, packageItem.topLevelClasses().count())
-            assertEquals(0, parentPackageItem.topLevelClasses().count())
+            assertEquals(1, packageItem.topLevelClasses().size)
+            assertEquals(0, parentPackageItem.topLevelClasses().size)
             assertEquals(parentPackageItem, packageItem.containingPackage())
             assertEquals(rootPackageItem, parentPackageItem.containingPackage())
             assertEquals(null, rootPackageItem.containingPackage())
@@ -282,11 +282,11 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             val fieldItem1 = classItem1.assertField("var1")
             val fieldItem2 = classItem1.assertField("var2")
             val fieldItem3 = classItem1.assertField("var3")
-            val packageMod = packageItem.mutableModifiers()
-            val classMod1 = classItem1.mutableModifiers()
-            val fieldMod1 = fieldItem1.mutableModifiers()
-            val fieldMod2 = fieldItem2.mutableModifiers()
-            val fieldMod3 = fieldItem3.mutableModifiers()
+            val packageMod = packageItem.modifiers
+            val classMod1 = classItem1.modifiers
+            val fieldMod1 = fieldItem1.modifiers
+            val fieldMod2 = fieldItem2.modifiers
+            val fieldMod3 = fieldItem3.modifiers
             assertEquals(true, packageMod.isPublic())
             assertEquals(true, classMod1.isPublic())
             assertEquals(false, classMod1.isSynchronized())
@@ -295,11 +295,6 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             assertEquals(false, fieldMod2.isPrivate())
             assertEquals(true, fieldMod2.asAccessibleAs(fieldMod1))
             assertEquals(true, fieldMod3.isPackagePrivate())
-            assertEquals(packageItem, packageMod.owner())
-            assertEquals(classItem1, classMod1.owner())
-            assertEquals(fieldItem1, fieldMod1.owner())
-            assertEquals(fieldItem2, fieldMod2.owner())
-            assertEquals(fieldItem3, fieldMod3.owner())
         }
     }
 
@@ -319,7 +314,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
 
                     import java.util.Date;
 
-                    class Test extends Date {}
+                    public class Test extends Date {}
                 """
             ),
         ) {
@@ -336,7 +331,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             // Check that the class and package have been loaded but will not be emitted.
             val utilPkgItem = codebase.assertPackage("java.util")
             assertEquals(false, utilPkgItem.emit)
-            val utilClassItem = codebase.assertClass("java.util.Date")
+            val utilClassItem = codebase.assertClass("java.util.Date", expectedEmit = false)
             assertEquals(false, utilClassItem.emit)
 
             // Check that the Test super class is expected.
@@ -348,7 +343,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             // Check that the class and package have been loaded but will not be emitted.
             val langPkgItem = codebase.assertPackage("java.lang")
             assertEquals(false, langPkgItem.emit)
-            val objectClassItem = codebase.assertClass("java.lang.Object")
+            val objectClassItem = codebase.assertClass("java.lang.Object", expectedEmit = false)
             assertEquals(false, objectClassItem.emit)
 
             // Check that the Date super class is expected.
@@ -366,7 +361,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     package test.pkg;
 
                     interface Interface {}
-                    class Test extends UnresolvedSuper implements Interface, UnresolvedInterface {}
+                    public class Test extends UnresolvedSuper implements Interface, UnresolvedInterface {}
                 """
             ),
         ) {
@@ -394,7 +389,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                         import anno.FieldValue;
                         import test.SimpleClass;
 
-                        class Test {
+                        public class Test {
                             @test.Nullable
                             @FieldInfo(children = {"child1","child2"}, val = 5, cls = SimpleClass.class)
                             @FieldValue(testInt1+testInt2)
@@ -506,18 +501,18 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                 """
                     package test.pkg;
 
-                    interface Interface1 {
+                    public interface Interface1 {
                         public void method1();
                         public <T> void method2(T value);
                     }
 
-                    interface Interface2 extends Interface1 {
+                    public interface Interface2 extends Interface1 {
                         public void method1();
                     }
 
-                    interface Interface3 extends Interface1,Interface2 {}
+                    public interface Interface3 extends Interface1,Interface2 {}
 
-                    abstract class Test1 implements Interface2 {
+                    public abstract class Test1 implements Interface2 {
                         @Override
                         public void method1(){}
 
@@ -525,12 +520,12 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                         public <Integer> void method2(Integer value){}
                     }
 
-                    class Test2 implements Interface3 {
+                    public class Test2 implements Interface3 {
                         @Override
                         public void method1(){}
                     }
 
-                    class Test3 implements Interface2,Interface1 {
+                    public class Test3 implements Interface2,Interface1 {
                         @Override
                         public void method1(){}
                     }
@@ -645,7 +640,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     package test.pkg;
 
                     public class Test {}
-                    class Test1<S> {
+                    public class Test1<S> {
                         class Test2<T extends Test> {}
                     }
 
@@ -732,7 +727,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     import java.util.Map;
                     import java.io.Serializable;
 
-                    class Test<@Nullable T,U extends Map<? super U, String>,V extends  Comparable & Serializable> {
+                    public class Test<@Nullable T,U extends Map<? super U, String>,V extends  Comparable & Serializable> {
                         public <Q, R extends Outer<? super U>.Inner<? extends Comparable >,S extends  Comparable & Serializable> void foo1(Q a, R b, S c) {}
                         public <A extends Object, B extends Object> void foo2() {}
                     }
@@ -740,7 +735,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     class Outer<O> {
                         class Inner<P> {}
                     }
-                    @interface Nullable {}
+                    public @interface Nullable {}
                 """
             ),
         ) {
@@ -810,7 +805,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             val throwableClasses = methodItem.throwsTypes().map { it.erasedClass }
 
             // This must be available after resolving throwable types.
-            val ioExceptionClass = codebase.assertClass("java.io.IOException")
+            val ioExceptionClass = codebase.assertClass("java.io.IOException", expectedEmit = false)
 
             assertEquals(listOf(testExceptionClass, ioExceptionClass), throwableClasses)
         }
@@ -900,11 +895,11 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             val paramItem = methodItem.parameters().single()
 
             assertEquals("parameter", paramItem.name())
-            assertEquals(methodItem, paramItem.containingMethod())
+            assertEquals(methodItem, paramItem.containingCallable())
             assertEquals("TestParam", paramItem.publicName())
             assertEquals(true, paramItem.hasDefaultValue())
             assertEquals(true, paramItem.isDefaultValueKnown())
-            assertEquals("5", paramItem.defaultValue())
+            assertEquals("5", paramItem.defaultValueAsString())
         }
     }
 
@@ -936,7 +931,7 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
 
                          class Inner {}
                     }
-                    class Test1 {}
+                    public class Test1 {}
                 """
             ),
         ) {
@@ -970,11 +965,11 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     .trimIndent()
             assertEquals(null, innerClassItem.getSourceFile())
             assertEquals(headerComment, sourceFile.getHeaderComments())
-            assertEquals(methodComment, methodItem.documentation)
-            assertEquals("/** Class documentation */", classItem.documentation)
-            assertEquals("/** Field Doc */", fieldItem.documentation)
-            assertEquals("", fieldItem1.documentation)
-            assertEquals("", pkgItem.documentation)
+            assertEquals(methodComment, methodItem.documentation.text)
+            assertEquals("/** Class documentation */", classItem.documentation.text)
+            assertEquals("/** Field Doc */", fieldItem.documentation.text)
+            assertEquals("", fieldItem1.documentation.text)
+            assertEquals("", pkgItem.documentation.text)
             assertEquals(classItem.sourceFile(), classItem1.sourceFile())
         }
     }
@@ -999,9 +994,9 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                         public int valueOf(Test a, String b) {return 7;}
                     }
 
-                    enum Test1 {}
+                    public enum Test1 {}
 
-                    class Test2 {
+                    public class Test2 {
                         static final Test field = Test.ENUM2;
                     }
                 """
@@ -1043,14 +1038,16 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
             ),
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
+            val classSelectors = classItem.variantSelectors
             val innerClassItem = codebase.assertClass("test.pkg.Test.Inner")
-            val fieldItem = classItem.assertField("Field")
-            val innerFieldItem = innerClassItem.assertField("InnerField")
-
-            assertEquals(false, classItem.docOnly)
-            assertEquals(true, innerClassItem.docOnly)
-            assertEquals(false, innerFieldItem.docOnly)
-            assertEquals(true, fieldItem.docOnly)
+            val innerClassSelectors = innerClassItem.variantSelectors
+            val fieldSelectors = classItem.assertField("Field").variantSelectors
+            val innerFieldSelectors = innerClassItem.assertField("InnerField").variantSelectors
+
+            assertEquals(false, classSelectors.docOnly, message = "classSelectors.docOnly")
+            assertEquals(true, innerClassSelectors.docOnly, message = "innerClassSelectors.docOnly")
+            assertEquals(true, innerFieldSelectors.docOnly, message = "innerFieldSelectors.docOnly")
+            assertEquals(true, fieldSelectors.docOnly, message = "fieldSelectors.docOnly")
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
new file mode 100644
index 000000000..49f070058
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
@@ -0,0 +1,423 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite
+
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.ApiVariantSelectors.TestableSelectorsState
+import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.MemberItem
+import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import org.junit.Test
+
+/** Common tests for [ApiVariantSelectors]. */
+class CommonApiVariantSelectorsTest : BaseModelTest() {
+
+    /**
+     * Test this [ApiVariantSelectors] against an [ApiVariantSelectors] with the same state as
+     * [expectedState]
+     */
+    fun ApiVariantSelectors.assertEquals(expectedState: TestableSelectorsState, message: String) {
+        assertEquals(expectedState.createSelectorsforTesting(), this, message = message)
+
+        // The preceding check will verify that val properties like originallyHidden are either set
+        // or not set as expected. The following checks test to make that they have the expected
+        // value.
+        expectedState.originallyHidden?.let { expectedOriginallyHidden ->
+            assertEquals(
+                expectedOriginallyHidden,
+                originallyHidden,
+                message = "$message (originallyHidden)"
+            )
+        }
+
+        expectedState.docOnly?.let { expected ->
+            assertEquals(expected, docOnly, message = "$message (docOnly)")
+        }
+    }
+
+    @Test
+    fun `Test toString`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val selectors = fooClass.variantSelectors
+
+            assertEquals(
+                """
+                    class test.pkg.Foo {
+                        originallyHidden=<not-set>,
+                        inheritableHidden=<not-set>,
+                        hidden=<not-set>,
+                        accessible=<not-set>,
+                        docOnly=<not-set>,
+                        removed=<not-set>,
+                        inheritIntoWasCalled=<not-set>,
+                        showability=<not-set>,
+                    }
+                """
+                    .trimIndent(),
+                selectors.toString(),
+                message = "before initializing"
+            )
+
+            // Initialize the properties.
+            selectors.hidden
+            selectors.accessible
+            selectors.docOnly
+            selectors.removed
+            selectors.showability
+
+            assertEquals(
+                """
+                    class test.pkg.Foo {
+                        originallyHidden=false,
+                        inheritableHidden=false,
+                        hidden=false,
+                        accessible=true,
+                        docOnly=false,
+                        removed=false,
+                        inheritIntoWasCalled=true,
+                        showability=Showability(show=NO_EFFECT, recursive=NO_EFFECT, forStubsOnly=NO_EFFECT, revertItem=null),
+                    }
+                """
+                    .trimIndent(),
+                selectors.toString(),
+                message = "after initializing"
+            )
+        }
+    }
+
+    @Test
+    fun `Test originallyHidden not hidden`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val selectors = fooClass.variantSelectors
+
+            assertEquals(false, selectors.originallyHidden, message = "originallyHidden")
+        }
+    }
+
+    @Test
+    fun `Test originallyHidden hidden`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    /** @hide */
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val selectors = fooClass.variantSelectors
+
+            var testableSelectorsState = TestableSelectorsState(item = fooClass)
+
+            // Check the state before initializing any property.
+            selectors.assertEquals(testableSelectorsState, message = "initial")
+
+            assertEquals(true, selectors.originallyHidden, message = "originallyHidden")
+
+            // Check the state after initializing `originallyHidden`.
+            testableSelectorsState =
+                testableSelectorsState.copy(
+                    originallyHidden = true,
+                )
+            selectors.assertEquals(
+                testableSelectorsState,
+                message = "after `originallyHidden` initialized"
+            )
+        }
+    }
+
+    @Test
+    fun `Test not hidden`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val selectors = fooClass.variantSelectors
+
+            var testableSelectorsState = TestableSelectorsState(item = fooClass)
+
+            // Check the state before initializing any property.
+            selectors.assertEquals(testableSelectorsState, message = "initial")
+
+            // Get the `showability` property.
+            assertEquals(Showability.NO_EFFECT, selectors.showability, message = "showability")
+
+            // Check the state after initializing `showability`.
+            testableSelectorsState =
+                testableSelectorsState.copy(showability = Showability.NO_EFFECT)
+            selectors.assertEquals(
+                testableSelectorsState,
+                message = "after `showability` initialized"
+            )
+
+            // Get the `hidden` property.
+            assertEquals(false, selectors.hidden, message = "hidden")
+
+            // Check the state after initializing `hidden`.
+            testableSelectorsState =
+                testableSelectorsState.copy(
+                    originallyHidden = false,
+                    inheritIntoWasCalled = true,
+                    inheritableHidden = false,
+                    hidden = false,
+                )
+            selectors.assertEquals(testableSelectorsState, message = "after `hidden` initialized")
+
+            // Get the `docOnly` property.
+            assertEquals(false, selectors.docOnly, message = "docOnly")
+
+            // Check the state after initializing `docOnly`.
+            testableSelectorsState = testableSelectorsState.copy(docOnly = false)
+            selectors.assertEquals(testableSelectorsState, message = "after `docOnly` initialized")
+
+            // Get the `removed` property.
+            assertEquals(false, selectors.removed, message = "removed")
+
+            // Check the state after initializing `removed`.
+            testableSelectorsState = testableSelectorsState.copy(removed = false)
+            selectors.assertEquals(testableSelectorsState, message = "after `removed` initialized")
+        }
+    }
+
+    @Test
+    fun `Test not docOnly`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val selectors = fooClass.variantSelectors
+
+            var testableSelectorsState = TestableSelectorsState(item = fooClass)
+
+            // Check the state before initializing any property.
+            selectors.assertEquals(testableSelectorsState, message = "initial")
+
+            // Get the `docOnly` property.
+            assertEquals(false, selectors.docOnly, message = "docOnly")
+
+            // Check the state after initializing `docOnly`.
+            testableSelectorsState = testableSelectorsState.copy(docOnly = false)
+            selectors.assertEquals(testableSelectorsState, message = "after `docOnly` initialized")
+        }
+    }
+
+    @Test
+    fun `Test docOnly`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        /** @doconly */
+                        package test.pkg;
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        public class Foo {
+                        }
+                    """
+                ),
+            ),
+        ) {
+            val pkgItem = codebase.assertPackage("test.pkg")
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val pkgSelectors = pkgItem.variantSelectors
+            val fooSelectors = fooClass.variantSelectors
+
+            var pkgSelectorsState = TestableSelectorsState(item = pkgItem)
+            var fooSelectorsState = TestableSelectorsState(item = fooClass)
+
+            // Check the states before initializing any property.
+            pkgSelectors.assertEquals(pkgSelectorsState, message = "initial pkg")
+            fooSelectors.assertEquals(fooSelectorsState, message = "initial foo")
+
+            // Get the `docOnly` property, do foo first to show it can inherit properly.
+            assertEquals(true, fooSelectors.docOnly, message = "foo docOnly")
+
+            // Check the states after initializing `docOnly`.
+            pkgSelectorsState = pkgSelectorsState.copy(docOnly = true)
+            pkgSelectors.assertEquals(pkgSelectorsState, message = "after pkg")
+
+            fooSelectorsState = fooSelectorsState.copy(docOnly = true)
+            fooSelectors.assertEquals(fooSelectorsState, message = "after foo")
+        }
+    }
+
+    @Test
+    fun `Test not removed`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val selectors = fooClass.variantSelectors
+
+            var testableSelectorsState = TestableSelectorsState(item = fooClass)
+
+            // Check the state before initializing any property.
+            selectors.assertEquals(testableSelectorsState, message = "initial")
+
+            // Get the `removed` property.
+            assertEquals(false, selectors.removed, message = "removed")
+
+            // Check the state after initializing `removed`.
+            testableSelectorsState = testableSelectorsState.copy(removed = false)
+            selectors.assertEquals(testableSelectorsState, message = "after `removed` initialized")
+        }
+    }
+
+    @Test
+    fun `Test removed`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        /** @removed */
+                        package test.pkg;
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        public class Foo {
+                        }
+                    """
+                ),
+            ),
+        ) {
+            val pkgItem = codebase.assertPackage("test.pkg")
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val pkgSelectors = pkgItem.variantSelectors
+            val fooSelectors = fooClass.variantSelectors
+
+            var pkgSelectorsState = TestableSelectorsState(item = pkgItem)
+            var fooSelectorsState = TestableSelectorsState(item = fooClass)
+
+            // Check the states before initializing any property.
+            pkgSelectors.assertEquals(pkgSelectorsState, message = "initial pkg")
+            fooSelectors.assertEquals(fooSelectorsState, message = "initial foo")
+
+            // Get the `removed` property, do foo first to show it can inherit properly.
+            assertEquals(true, fooSelectors.removed, message = "foo removed")
+
+            // Check the states after initializing `removed`.
+            pkgSelectorsState = pkgSelectorsState.copy(removed = true)
+            pkgSelectors.assertEquals(pkgSelectorsState, message = "after pkg")
+
+            fooSelectorsState = fooSelectorsState.copy(removed = true)
+            fooSelectors.assertEquals(fooSelectorsState, message = "after foo")
+        }
+    }
+
+    @Test
+    fun `Test accessible`() {
+        runCodebaseTest(
+            inputSet(
+                java("""
+                        package test.pkg;
+                    """),
+                java(
+                    """
+                        package test.pkg;
+                        public class Outer {
+                            class PackagePrivateInaccessible {
+                                public class PublicInsideInaccessible {}
+                            }
+                            protected class Protected {
+                                public static final int FIELD = 0;
+                            }
+                            private void methodPrivateInaccessible() {}
+                        }
+                    """
+                ),
+            ),
+        ) {
+            // Get the `accessible` property for the pkg, is always `true`.
+            val pkgItem = codebase.assertPackage("test.pkg")
+            assertEquals(true, pkgItem.variantSelectors.accessible, message = "pkg accessible")
+
+            var count = 0
+            pkgItem.accept(
+                object : BaseItemVisitor() {
+                    override fun visitItem(item: Item) {
+                        val name =
+                            when (item) {
+                                is ClassItem -> item.simpleName()
+                                is MemberItem -> item.name()
+                                else -> return
+                            }
+
+                        val expectedAccessible = !name.endsWith("Inaccessible")
+                        assertEquals(
+                            expectedAccessible,
+                            item.variantSelectors.accessible,
+                            message = "$item accessible"
+                        )
+                        count += 1
+                    }
+                }
+            )
+
+            // Make sure it actually did something.
+            assertEquals(10, count, message = "item count")
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt
index 9f6685800..83c541244 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
+import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
 import kotlin.test.assertNotNull
 import kotlin.test.assertNotSame
@@ -83,14 +84,21 @@ class CommonModelTest : BaseModelTest() {
             ),
         ) {
             // Iterate over the codebase and try and find every item that is visited.
+            val items = mutableListOf<Item>()
             codebase.accept(
                 object : BaseItemVisitor() {
                     override fun visitItem(item: Item) {
                         val foundItem = item.findCorrespondingItemIn(codebase)
                         assertSame(item, foundItem)
+                        foundItem?.let { items += it }
                     }
                 }
             )
+
+            // Make sure that at least 11 items were found, that is every item listed in the input
+            // but does not include implicit items that may be found from elsewhere, e.g. classpath.
+            // TODO: The actual number varies from model to model which needs rectifying.
+            assertThat(items.size).isAtLeast(11)
         }
     }
 
@@ -323,11 +331,19 @@ class CommonModelTest : BaseModelTest() {
                 ),
             ),
         ) {
-            // Iterate over the codebase and try and find every item that is visited.
+            // Iterate over the codebase classes and resolve the super class of every class visited.
+            val items = mutableListOf<Item>()
             for (classItem in codebase.getPackages().allClasses()) {
+                items += classItem
                 // Resolve the super class which might trigger a change in the packages/classes.
-                classItem.superClass()
+                classItem.superClass()?.let { items += it }
             }
+
+            // Make sure that at least 2 items were found, that is every item listed in the input
+            // but does not include undefined classes which are treated differently in text model to
+            // other models.
+            // TODO: The actual number varies from model to model which needs rectifying.
+            assertThat(items.size).isAtLeast(2)
         }
     }
 
@@ -367,14 +383,23 @@ class CommonModelTest : BaseModelTest() {
                 ),
             ),
         ) {
-            // Iterate over the codebase and try and find every item that is visited.
+            // Iterate over the codebase classes and resolve the super interfaces of every class
+            // visited.
+            val items = mutableListOf<Item>()
             for (classItem in codebase.getPackages().allClasses()) {
+                items += classItem
                 for (interfaceType in classItem.interfaceTypes()) {
                     // Resolve the interface type which might trigger a change in the
                     // packages/classes.
-                    interfaceType.asClass()
+                    interfaceType.asClass()?.let { items += it }
                 }
             }
+
+            // Make sure that at least 2 items were found, that is every item listed in the input
+            // but does not include undefined classes which are treated differently in text model to
+            // other models.
+            // TODO: The actual number varies from model to model which needs rectifying.
+            assertThat(items.size).isAtLeast(2)
         }
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt
new file mode 100644
index 000000000..9cfcd5366
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.DefaultAnnotationItem
+import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
+import com.android.tools.metalava.model.ModifierList
+import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.model.createMutableModifiers
+import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import kotlin.test.assertFalse
+import kotlin.test.assertTrue
+import org.junit.Test
+
+/** Tests [ModifierList] and [MutableModifierList] functionality. */
+class CommonModifierListTest : BaseModelTest() {
+
+    /** Just creates a basic [Codebase] for the test to use. */
+    private fun runWithCodebase(body: CodebaseContext.() -> Unit) {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Foo {
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+                    public class Foo {
+                        private Foo() {}
+                    }
+                """
+            ),
+            test = body,
+        )
+    }
+
+    @Test
+    fun `test equals() of empty modifiers`() {
+        runWithCodebase {
+            val annotation =
+                DefaultAnnotationItem.create(codebase, JAVA_LANG_DEPRECATED, emptyList())!!
+
+            // Create an empty set of modifiers
+            val modifiers = createMutableModifiers(VisibilityLevel.PUBLIC)
+
+            // Create another empty set of modifiers.
+            val anotherModifiers = createMutableModifiers(VisibilityLevel.PUBLIC)
+
+            // They compare equal both directly and in their string representation.
+            assertEquals(modifiers, anotherModifiers, message = "modifiers before")
+            assertEquals(
+                modifiers.toString(),
+                anotherModifiers.toString(),
+                message = "modifiers string representation before"
+            )
+
+            // Now add and remove an annotation, after which it should still be empty.
+            anotherModifiers.apply {
+                // Add and remove the annotations in separate mutations as otherwise it is just
+                // testing the standard List behavior.
+                mutateAnnotations { add(annotation) }
+                mutateAnnotations { remove(annotation) }
+            }
+
+            // They should still compare equal both directly and in their string representation but
+            // they do not.
+            // TODO(b/356548977): Fix this.
+            assertEquals(modifiers, anotherModifiers, message = "modifiers")
+            assertEquals(
+                modifiers.toString(),
+                anotherModifiers.toString(),
+                message = "modifiers string representation"
+            )
+        }
+    }
+
+    @Test
+    fun `test toString()`() {
+        runWithCodebase {
+            val annotation =
+                DefaultAnnotationItem.create(codebase, FileLocation.UNKNOWN, JAVA_LANG_DEPRECATED) {
+                    emptyList()
+                }!!
+            val modifiers =
+                createImmutableModifiers(
+                    visibility = VisibilityLevel.PUBLIC,
+                    annotations = listOf(annotation),
+                )
+            assertEquals(
+                "ModifierList(flags = 0b100, annotations = [@java.lang.Deprecated])",
+                modifiers.toString()
+            )
+        }
+    }
+
+    @Test
+    fun `test equivalentTo()`() {
+        assertTrue {
+            createImmutableModifiers(VisibilityLevel.PUBLIC)
+                .equivalentTo(null, createImmutableModifiers(VisibilityLevel.PUBLIC))
+        }
+        assertFalse {
+            createImmutableModifiers(VisibilityLevel.PRIVATE)
+                .equivalentTo(null, createImmutableModifiers(VisibilityLevel.PUBLIC))
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
index 96648e3a4..87d037a84 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
@@ -71,6 +71,13 @@ interface ModelSuiteRunner : FilterableCodebaseCreator {
         /** The main sources that will be loaded into the [Codebase] to be tested. */
         val mainSourceDir: SourceDir,
 
+        /**
+         * Additional sources that will be created but will not be passed directly to the code being
+         * tested. Instead, the [SourceDir.dir] will be added to the source path which the code
+         * being tested may search implicitly.
+         */
+        val additionalMainSourceDir: SourceDir?,
+
         /** The optional common sources. */
         val commonSourceDir: SourceDir?,
     )
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunnerProvider.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunnerProvider.kt
new file mode 100644
index 000000000..9d173ed21
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunnerProvider.kt
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite
+
+/** Provider of [ModelSuiteRunner]s. */
+interface ModelSuiteRunnerProvider {
+    /** The list of [ModelSuiteRunner]s that this provides. */
+    val runners: List<ModelSuiteRunner>
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelTestSuiteRunner.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelTestSuiteRunner.kt
index 495aa2bd1..47abd90f3 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelTestSuiteRunner.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelTestSuiteRunner.kt
@@ -47,25 +47,28 @@ class ModelTestSuiteRunner(clazz: Class<*>) :
 
     companion object {
         private fun getModelSuiteRunners(): List<CodebaseCreatorConfig<ModelSuiteRunner>> {
-            val loader = ServiceLoader.load(ModelSuiteRunner::class.java)
-            val modelSuiteRunners = loader.toList()
+            val loader = ServiceLoader.load(ModelSuiteRunnerProvider::class.java)
+            val modelSuiteRunners = loader.flatMap { it.runners }.toList()
             if (modelSuiteRunners.isEmpty()) {
                 fail("No runners found")
             }
-            val runner = modelSuiteRunners.single()
 
-            return runner.testConfigurations.map {
-                CodebaseCreatorConfig(
-                    creator = runner,
-                    inputFormat = it.inputFormat,
-                    modelOptions = it.modelOptions,
-                    // There is only a single runner for a single provider so ignore the
-                    // provider name.
-                    includeProviderNameInTestName = false,
-                    // Only include the input format in the test name if the runner supports
-                    // more than one.
-                    includeInputFormatInTestName = runner.supportedInputFormats.size > 1,
-                )
+            // If there is only a single runner for a single provider then ignore the provider name,
+            // otherwise include it.
+            val includeProviderNameInTestName = modelSuiteRunners.size > 1
+
+            return modelSuiteRunners.flatMap { runner ->
+                runner.testConfigurations.map {
+                    CodebaseCreatorConfig(
+                        creator = runner,
+                        inputFormat = it.inputFormat,
+                        modelOptions = it.modelOptions,
+                        includeProviderNameInTestName = includeProviderNameInTestName,
+                        // Only include the input format in the test name if the runner supports
+                        // more than one.
+                        includeInputFormatInTestName = runner.supportedInputFormats.size > 1,
+                    )
+                }
             }
         }
     }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/NullabilityTesting.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/NullabilityTesting.kt
index d984f415a..2d27b2c30 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/NullabilityTesting.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/NullabilityTesting.kt
@@ -18,20 +18,19 @@ package com.android.tools.metalava.model.testsuite
 
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.testing.KnownSourceFiles
 import com.google.common.truth.Truth.*
 
 class NullabilityCodebaseContext(
-    codebaseContext: BaseModelTest.CodebaseContext<Codebase>,
+    codebaseContext: BaseModelTest.CodebaseContext,
     /**
      * True if nullness information came from annotations, false if it came from kotlin null
      * suffixes.
      */
     val nullabilityFromAnnotations: Boolean,
-) : BaseModelTest.CodebaseContext<Codebase> by codebaseContext
+) : BaseModelTest.CodebaseContext by codebaseContext
 
 /**
  * Runs a test where it matters whether nullability is provided by annotations (which it is in
@@ -82,10 +81,8 @@ internal fun TypeItem.assertHasNonNullNullability(
     expectAnnotation: Boolean? = null,
     message: String? = null,
 ) {
-    assertWithMessage(message ?: "")
-        .that(modifiers.nullability())
-        .isEqualTo(TypeNullability.NONNULL)
-    val nullabilityAnnotations = modifiers.annotations().filter { it.isNullnessAnnotation() }
+    assertWithMessage(message ?: "").that(modifiers.nullability).isEqualTo(TypeNullability.NONNULL)
+    val nullabilityAnnotations = modifiers.annotations.filter { it.isNullnessAnnotation() }
     when (expectAnnotation) {
         true -> assertThat(nullabilityAnnotations.single().isNonNull()).isTrue()
         false -> assertThat(nullabilityAnnotations).isEmpty()
@@ -101,8 +98,8 @@ internal fun TypeItem.assertHasNonNullNullability(
  *     * `null` disables the annotation check.
  */
 internal fun TypeItem.assertHasNullableNullability(expectAnnotation: Boolean? = null) {
-    assertThat(modifiers.nullability()).isEqualTo(TypeNullability.NULLABLE)
-    val nullabilityAnnotations = modifiers.annotations().filter { it.isNullnessAnnotation() }
+    assertThat(modifiers.nullability).isEqualTo(TypeNullability.NULLABLE)
+    val nullabilityAnnotations = modifiers.annotations.filter { it.isNullnessAnnotation() }
     when (expectAnnotation) {
         true -> assertThat(nullabilityAnnotations.single().isNullable()).isTrue()
         false -> assertThat(nullabilityAnnotations).isEmpty()
@@ -112,10 +109,10 @@ internal fun TypeItem.assertHasNullableNullability(expectAnnotation: Boolean? =
 
 /** Make sure that this [TypeItem] has [TypeNullability.PLATFORM]. */
 internal fun TypeItem.assertHasPlatformNullability() {
-    assertThat(modifiers.nullability()).isEqualTo(TypeNullability.PLATFORM)
+    assertThat(modifiers.nullability).isEqualTo(TypeNullability.PLATFORM)
 }
 
 /** Make sure that this [TypeItem] has [TypeNullability.UNDEFINED]. */
 internal fun TypeItem.assertHasUndefinedNullability() {
-    assertThat(modifiers.nullability()).isEqualTo(TypeNullability.UNDEFINED)
+    assertThat(modifiers.nullability).isEqualTo(TypeNullability.UNDEFINED)
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
index 5bd35dfd3..abf13b939 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
@@ -17,17 +17,173 @@
 package com.android.tools.metalava.model.testsuite.annotationitem
 
 import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.getAttributeValue
 import com.android.tools.metalava.model.getAttributeValues
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
 import kotlin.test.assertEquals
 import org.junit.Test
 
+/** Annotation that is added on a line before the item being annotated. */
+val lineBefore =
+    java(
+        """
+            package test.pkg;
+
+            public @interface LineBefore {
+                String value();
+            }
+        """
+    )
+
+/** Annotation that is added on the same line as the item being annotated. */
+val sameLine =
+    java(
+        """
+            package test.pkg;
+
+            public @interface SameLine {
+                String value();
+            }
+        """
+    )
+
 /** Common tests for implementations of [ClassItem]. */
 class CommonAnnotationItemTest : BaseModelTest() {
 
+    /** Check the location information of the various parts of [item]. */
+    private fun checkLocationInformation(item: Item, expectedLocations: String) {
+        val details = mutableListOf<Pair<Int, String>>()
+        val foo = item
+
+        fun addDetails(fileLocation: FileLocation, description: String) {
+            val line = fileLocation.line
+            if (line == 0) return
+            details.add(line to description)
+        }
+
+        foo.accept(
+            object : BaseItemVisitor() {
+                override fun visitItem(item: Item) {
+                    item.modifiers.annotations().forEach {
+                        addDetails(it.fileLocation, it.toSource())
+                    }
+                    addDetails(item.fileLocation, item.describe())
+                }
+            }
+        )
+        val sorted = details.sortedWith(compareBy({ it.first }, { it.second }))
+        val actualLocations = sorted.map { (line, details) -> "$line:$details" }.joinToString("\n")
+        assertEquals(expectedLocations.trimIndent(), actualLocations)
+    }
+
+    @RequiresCapabilities(Capability.JAVA)
+    @Test
+    fun `annotation location (java)`() {
+        runCodebaseTest(
+            inputSet(
+                lineBefore,
+                sameLine,
+                java(
+                    """
+                        package test.pkg;
+
+                        @LineBefore("Foo")
+                        @SameLine("Foo") public class Foo {
+                            @LineBefore("constructor")
+                            @SameLine("constructor") public Foo() {}
+                            @LineBefore("field")
+                            @SameLine("field") public int field;
+                            @LineBefore("method")
+                            @SameLine("method") public void method(
+                                @LineBefore("parameter")
+                                @SameLine("parameter") int p) {}
+                        }
+                    """
+                ),
+            ),
+        ) {
+            checkLocationInformation(
+                codebase.assertClass("test.pkg.Foo"),
+                """
+                    3:@test.pkg.LineBefore("Foo")
+                    4:@test.pkg.SameLine("Foo")
+                    4:class test.pkg.Foo
+                    5:@test.pkg.LineBefore("constructor")
+                    6:@test.pkg.SameLine("constructor")
+                    6:constructor test.pkg.Foo()
+                    7:@test.pkg.LineBefore("field")
+                    8:@test.pkg.SameLine("field")
+                    8:field test.pkg.Foo.field
+                    9:@test.pkg.LineBefore("method")
+                    10:@test.pkg.SameLine("method")
+                    10:method test.pkg.Foo.method(int)
+                    11:@test.pkg.LineBefore("parameter")
+                    12:@test.pkg.SameLine("parameter")
+                    12:parameter p in test.pkg.Foo.method(int p)
+                """
+            )
+        }
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `annotation location (kotlin)`() {
+        runCodebaseTest(
+            inputSet(
+                lineBefore,
+                sameLine,
+                kotlin(
+                    """
+                        package test.pkg
+
+                        @LineBefore("Foo")
+                        @SameLine("Foo") class Foo {
+                            @LineBefore("constructor")
+                            @SameLine("constructor") constructor() {}
+                            @LineBefore("field")
+                            @SameLine("field") val field: Int
+                            @LineBefore("method")
+                            @SameLine("method") fun method(
+                                @LineBefore("parameter")
+                                @SameLine("parameter") p: Int) {}
+                        }
+                    """
+                ),
+            ),
+        ) {
+            checkLocationInformation(
+                codebase.assertClass("test.pkg.Foo"),
+                """
+                    3:@test.pkg.LineBefore("Foo")
+                    4:@test.pkg.SameLine("Foo")
+                    4:class test.pkg.Foo
+                    5:@test.pkg.LineBefore("constructor")
+                    5:constructor test.pkg.Foo()
+                    6:@test.pkg.SameLine("constructor")
+                    7:@test.pkg.LineBefore("field")
+                    8:@test.pkg.SameLine("field")
+                    8:field test.pkg.Foo.field
+                    8:method test.pkg.Foo.getField()
+                    8:property Foo.field
+                    9:@test.pkg.LineBefore("method")
+                    10:@test.pkg.SameLine("method")
+                    10:method test.pkg.Foo.method(int)
+                    11:@test.pkg.LineBefore("parameter")
+                    12:@test.pkg.SameLine("parameter")
+                    12:parameter p in test.pkg.Foo.method(int p)
+                """
+            )
+        }
+    }
+
     @Test
     fun `annotation with annotation values`() {
         runCodebaseTest(
@@ -1365,6 +1521,58 @@ class CommonAnnotationItemTest : BaseModelTest() {
         }
     }
 
+    @Test
+    fun `annotation resolve`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      @test.pkg.Test.Anno
+                      public class Test {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Test.Anno {
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    import java.lang.annotation.Retention;
+                    import java.lang.annotation.RetentionPolicy;
+
+                    @Test.Anno
+                    public class Test {
+                        private Test() {}
+
+                        @Retention(RetentionPolicy.CLASS)
+                        public @interface Anno {
+                        }
+                    }
+                """
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val anno = testClass.modifiers.annotations().single()
+
+            // Check that the annotation can be resolved to a class.
+            val annoClass = anno.resolve()!!
+            assertEquals("test.pkg.Test.Anno", annoClass.qualifiedName(), message = "anno class")
+
+            // Check that the annotation can be resolved to a class.
+            val retentionAnno = annoClass.modifiers.annotations().single()
+            val retentionClass = retentionAnno.resolve()!!
+            assertEquals(
+                "java.lang.annotation.Retention",
+                retentionClass.qualifiedName(),
+                message = "retention class"
+            )
+        }
+    }
+
     inline fun <reified T : Any> AnnotationItem.assertAttributeValue(
         attributeName: String,
         expected: T
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt
new file mode 100644
index 000000000..efd9f749d
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/callableitem/CallableParameterDescriptorUsingDotsTest.kt
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.callableitem
+
+import com.android.tools.metalava.model.Assertions
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.getCallableParameterDescriptorUsingDots
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import org.intellij.lang.annotations.Language
+import org.junit.Assert.assertEquals
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+class CallableParameterDescriptorUsingDotsTest : BaseModelTest() {
+
+    @Parameterized.Parameter(0) lateinit var params: TestParams
+
+    data class TestParams(
+        @Language("JAVA") val inputSource: String,
+        val constructor: Boolean = false,
+        val callableGetter: (Codebase) -> CallableItem = {
+            val classItem = it.assertClass("test.pkg.Foo")
+            val callables = if (constructor) classItem.constructors() else classItem.methods()
+            callables.single()
+        },
+        val expectedResult: String?,
+    ) {
+        override fun toString(): String {
+            return expectedResult.toString()
+        }
+    }
+
+    companion object : Assertions {
+        private val params =
+            listOf(
+                TestParams(
+                    inputSource =
+                        """
+                            package test.pkg;
+                            public class Foo {
+                                public void method() {}
+                            }
+                        """,
+                    expectedResult = "()",
+                ),
+                TestParams(
+                    inputSource =
+                        """
+                            package test.pkg;
+                            public class Foo {
+                                public int method(int p, String s) {return p;}
+                            }
+                        """,
+                    expectedResult = "(ILjava.lang.String;)",
+                ),
+                TestParams(
+                    inputSource =
+                        """
+                            package test.pkg;
+                            public class Foo {
+                                public Foo(long p, byte b) {}
+                            }
+                        """,
+                    constructor = true,
+                    expectedResult = "(JB)",
+                ),
+                TestParams(
+                    inputSource =
+                        """
+                            package test.pkg;
+                            import java.util.Map;
+                            public class Foo {
+                                public class Bar {
+                                    public Bar(Map.Entry<String, Integer> e) {}
+                                }
+                            }
+                        """,
+                    constructor = true,
+                    callableGetter = { it.assertClass("test.pkg.Foo.Bar").constructors().single() },
+                    // This is `null` because the PSI helper cannot resolve Bar to a class.
+                    expectedResult = null,
+                ),
+                TestParams(
+                    inputSource =
+                        """
+                            package test.pkg;
+                            import java.util.Map;
+                            public class Foo {
+                                public static class Bar {
+                                    public Bar(Map.Entry<String, Integer> e) {}
+                                }
+                            }
+                        """,
+                    constructor = true,
+                    callableGetter = { it.assertClass("test.pkg.Foo.Bar").constructors().single() },
+                    expectedResult = "(Ljava.util.Map.Entry;)",
+                ),
+            )
+
+        @JvmStatic @Parameterized.Parameters fun params() = params
+    }
+
+    @Test
+    fun `Test getCallableParameterDescriptorUsingDots`() {
+        runCodebaseTest(java(params.inputSource)) {
+            val callable = params.callableGetter(codebase)
+            assertEquals(params.expectedResult, callable.getCallableParameterDescriptorUsingDots())
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
index dc2b3d5bd..a98c39675 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.testsuite.classitem
 
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterItem
@@ -29,6 +30,7 @@ import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
 import kotlin.test.assertEquals
+import kotlin.test.assertNotNull
 import kotlin.test.assertNull
 import kotlin.test.assertSame
 import kotlin.test.assertTrue
@@ -64,7 +66,7 @@ class CommonClassItemTest : BaseModelTest() {
             assertEquals("Test", testClass.fullName())
             assertEquals("test/pkg/Test", testClass.internalName())
             assertEquals("test.pkg.Test", testClass.qualifiedName())
-            assertEquals("test.pkg.Test", testClass.qualifiedNameWithDollarInnerClasses())
+            assertEquals("test.pkg.Test", testClass.qualifiedNameWithDollarNestedClasses())
             assertEquals(1, testClass.constructors().size)
             assertEquals(emptyList(), testClass.methods())
             assertEquals(emptyList(), testClass.fields())
@@ -417,7 +419,7 @@ class CommonClassItemTest : BaseModelTest() {
             val fooSuperClass = fooClass.superClass()
 
             // Now get the object class.
-            val objectClass = codebase.assertClass("java.lang.Object")
+            val objectClass = codebase.assertClass("java.lang.Object", expectedEmit = false)
 
             assertSame(objectClass, fooSuperClass)
 
@@ -522,7 +524,7 @@ class CommonClassItemTest : BaseModelTest() {
             val fooSuperClass = fooClass.superClass()
 
             // Now get the object class.
-            val objectClass = codebase.assertClass("java.lang.Object")
+            val objectClass = codebase.assertClass("java.lang.Object", expectedEmit = false)
 
             assertSame(objectClass, fooSuperClass)
 
@@ -1061,7 +1063,12 @@ class CommonClassItemTest : BaseModelTest() {
 
             val child = codebase.assertClass("test.pkg.Child")
 
-            val erasedParentType = parent.type().duplicate(null, emptyList())
+            val parentType = parent.type()
+            val erasedParentType =
+                parentType.substitute(
+                    outerClassType = null,
+                    arguments = emptyList(),
+                )
             assertEquals(
                 mapOf(a to tType, b to erasedParentType),
                 parent.mapTypeVariables(grandparent)
@@ -1266,7 +1273,7 @@ class CommonClassItemTest : BaseModelTest() {
     }
 
     @Test
-    fun `Test inheritMethodFromNonApiAncestor without type substitutions`() {
+    fun `Test duplicate without type substitutions`() {
         runSourceCodebaseTest(
             inputSet(
                 java(
@@ -1288,8 +1295,7 @@ class CommonClassItemTest : BaseModelTest() {
                 kotlin(
                     """
                         package test.pkg
-                        /** @hide */
-                        open class HiddenClass {
+                        internal open class HiddenClass {
                             fun foo() {}
                         }
                     """
@@ -1302,11 +1308,11 @@ class CommonClassItemTest : BaseModelTest() {
                 ),
             ),
         ) {
-            val hiddenClass = codebase.assertClass("test.pkg.HiddenClass")
+            val hiddenClass = codebase.assertResolvedClass("test.pkg.HiddenClass")
             val hiddenClassMethod = hiddenClass.methods().single()
             val publicClass = codebase.assertClass("test.pkg.PublicClass")
 
-            val inheritedMethod = publicClass.inheritMethodFromNonApiAncestor(hiddenClassMethod)
+            val inheritedMethod = hiddenClassMethod.duplicate(publicClass)
             assertSame(hiddenClass, inheritedMethod.inheritedFrom)
             assertTrue(inheritedMethod.inheritedFromAncestor)
 
@@ -1315,7 +1321,7 @@ class CommonClassItemTest : BaseModelTest() {
     }
 
     @Test
-    fun `Test inheritMethodFromNonApiAncestor with type substitutions`() {
+    fun `Test duplicate with type substitutions`() {
         runSourceCodebaseTest(
             inputSet(
                 typeUseOnlyNonNullSource,
@@ -1371,7 +1377,7 @@ class CommonClassItemTest : BaseModelTest() {
                 ),
             ),
         ) {
-            val hiddenClass = codebase.assertClass("test.pkg.HiddenClass")
+            val hiddenClass = codebase.assertResolvedClass("test.pkg.HiddenClass")
             val publicClass = codebase.assertClass("test.pkg.PublicClass")
 
             val expectedTypes =
@@ -1388,7 +1394,7 @@ class CommonClassItemTest : BaseModelTest() {
 
             for (method in hiddenClass.methods().sortedBy { it.name() }) {
                 val name = method.name()
-                val inheritedMethod = publicClass.inheritMethodFromNonApiAncestor(method)
+                val inheritedMethod = method.duplicate(publicClass)
                 assertSame(hiddenClass, inheritedMethod.inheritedFrom)
                 assertTrue(inheritedMethod.inheritedFromAncestor)
 
@@ -1401,10 +1407,10 @@ class CommonClassItemTest : BaseModelTest() {
     }
 
     @Test
-    fun `Test inheritMethodFromNonApiAncestor with type substitutions and not type use nullability annotations`() {
-        // Test for behavior of ClassItem.inheritMethodFromNonApiAncestor(...) in Java when the type
-        // parameter is used in the return type and is either unannotated, or annotated with a
-        // non-type use nullability annotation.
+    fun `Test duplicate with type substitutions and not type use nullability annotations`() {
+        // Test for behavior of MethodItem.duplicate(ClassItem) in Java when the type parameter is
+        // used in the return type and is either unannotated, or annotated with a non-type use
+        // nullability annotation.
         runSourceCodebaseTest(
             inputSet(
                 typeUseOnlyNonNullSource,
@@ -1429,7 +1435,7 @@ class CommonClassItemTest : BaseModelTest() {
                 ),
             ),
         ) {
-            val hiddenClass = codebase.assertClass("test.pkg.HiddenClass")
+            val hiddenClass = codebase.assertResolvedClass("test.pkg.HiddenClass")
             val publicClass = codebase.assertClass("test.pkg.PublicClass")
 
             val expectedTypesAndNullability =
@@ -1441,7 +1447,7 @@ class CommonClassItemTest : BaseModelTest() {
 
             for (method in hiddenClass.methods().sortedBy { it.name() }) {
                 val name = method.name()
-                val inheritedMethod = publicClass.inheritMethodFromNonApiAncestor(method)
+                val inheritedMethod = method.duplicate(publicClass)
                 assertSame(hiddenClass, inheritedMethod.inheritedFrom)
                 assertTrue(inheritedMethod.inheritedFromAncestor)
 
@@ -1452,7 +1458,7 @@ class CommonClassItemTest : BaseModelTest() {
                     .isEqualTo(expectedType)
 
                 assertWithMessage("testing type nullability of $name")
-                    .that(returnType.modifiers.nullability())
+                    .that(returnType.modifiers.nullability)
                     .isEqualTo(expectedNullability)
             }
         }
@@ -1617,10 +1623,124 @@ class CommonClassItemTest : BaseModelTest() {
             val modifiers = classType.modifiers
 
             // Class types are always non-null without needing an annotation
-            assertThat(modifiers.nullability()).isEqualTo(TypeNullability.NONNULL)
+            assertThat(modifiers.nullability).isEqualTo(TypeNullability.NONNULL)
 
             // Class types do not have any annotations.
-            assertThat(modifiers.annotations()).isEmpty()
+            assertThat(modifiers.annotations).isEmpty()
+        }
+    }
+
+    private fun CodebaseContext.checkClassOrigin(
+        name: String,
+        expectedOrigin: ClassOrigin,
+    ) {
+        // Make sure to resolve any class requested just in case it is on the class path.
+        val testClass =
+            codebase.assertResolvedClass(
+                name,
+                expectedEmit = expectedOrigin == ClassOrigin.COMMAND_LINE,
+            )
+        assertEquals(expectedOrigin, testClass.origin, message = "$name origin")
+    }
+
+    @Test
+    fun `Test origin`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Test {
+                        private Test() {}
+                    }
+                """
+            ),
+        ) {
+            checkClassOrigin(
+                "test.pkg.Test",
+                expectedOrigin = ClassOrigin.COMMAND_LINE,
+            )
+            checkClassOrigin(
+                "java.lang.String",
+                expectedOrigin = ClassOrigin.CLASS_PATH,
+            )
+
+            // Some models may not return an unknown class but those that do should treat it as
+            // coming from the class path.
+            codebase.resolveClass("Unknown")?.let { testClass ->
+                assertEquals(ClassOrigin.CLASS_PATH, testClass.origin, message = "Unknown")
+            }
+        }
+    }
+
+    @Test
+    fun `Test origin source path`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Test {
+                            private Test() {}
+                        }
+                    """
+                ),
+                sourcePathFiles =
+                    listOf(
+                        java(
+                            """
+                                package test.pkg;
+
+                                public class SourcePathClass {}
+                            """
+                        )
+                    ),
+            )
+        ) {
+            checkClassOrigin(
+                "test.pkg.SourcePathClass",
+                expectedOrigin = ClassOrigin.SOURCE_PATH,
+            )
+        }
+    }
+
+    @Test
+    fun `Test class on source path`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Test {
+                            private Test() {}
+                        }
+                    """
+                ),
+                sourcePathFiles =
+                    listOf(
+                        java(
+                            """
+                                package test.pkg;
+
+                                public class SourcePathClass {}
+                            """
+                        )
+                    ),
+            )
+        ) {
+            // Make sure that a class defined on the source class path can be resolved.
+            assertNotNull(codebase.resolveClass("test.pkg.SourcePathClass"))
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt
new file mode 100644
index 000000000..ceafaf609
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDuplicateClassItemTest.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.classitem
+
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import org.junit.Test
+
+/** Common tests for implementations of [ClassItem]. */
+class CommonDuplicateClassItemTest : BaseModelTest() {
+
+    private fun runDuplicateTest(test: CodebaseContext.() -> Unit) {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {}
+                    """
+                ),
+                java(
+                    "src2/test/pkg/Foo.java",
+                    """
+                        package test.pkg;
+
+                        public class Foo {}
+                    """
+                )
+            ),
+            test = test,
+        )
+    }
+
+    private fun CodebaseContext.checkCodebase(codebase: Codebase) {
+        val fooClass = codebase.assertClass("test.pkg.Foo")
+        assertEquals(
+            "TESTROOT/src/test/pkg/Foo.java",
+            removeTestSpecificDirectories(fooClass.fileLocation.path.toString())
+        )
+
+        val fooLocations =
+            codebase
+                .getPackages()
+                .allClasses()
+                .filter { it.qualifiedName() == "test.pkg.Foo" }
+                .joinToString("\n") {
+                    removeTestSpecificDirectories(it.fileLocation.path.toString())
+                }
+        assertEquals(
+            """
+                TESTROOT/src/test/pkg/Foo.java
+            """
+                .trimIndent(),
+            fooLocations
+        )
+    }
+
+    @Test
+    fun `Test duplicate classes`() {
+        runDuplicateTest { checkCodebase(codebase) }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonFrozenClassItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonFrozenClassItemTest.kt
new file mode 100644
index 000000000..7bf3c7277
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonFrozenClassItemTest.kt
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.classitem
+
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import kotlin.test.assertEquals
+import kotlin.test.assertFalse
+import kotlin.test.assertTrue
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+/** Common tests for [ClassItem.freeze] and related functionality. */
+class CommonFrozenClassItemTest : BaseModelTest() {
+    @Test
+    fun `Test freeze class and super types`() {
+        runCodebaseTest(
+            inputSet(
+                signature(
+                    """
+                       // Signature format: 2.0
+                       package test.pkg {
+                         public class PublicClass extends test.pkg.SuperClass implements test.pkg.SuperInterface {
+                           ctor public PublicClass();
+                         }
+                         public class SuperClass {
+                           ctor public SuperClass();
+                           method public void foo();
+                         }
+                         public interface SuperInterface {
+                           method public void bar();
+                         }
+                       } 
+                    """
+                ),
+            ),
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+                        public class SuperClass {
+                            public void foo() {}
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        public interface SuperInterface {
+                            void bar();
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        public class PublicClass extends SuperClass implements SuperInterface {}
+                    """
+                ),
+            ),
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        open class SuperClass {
+                            fun foo() {}
+                        }
+                    """
+                ),
+                kotlin(
+                    """
+                        package test.pkg
+                        interface SuperInterface {
+                            fun bar()
+                        }
+                    """
+                ),
+                kotlin(
+                    """
+                        package test.pkg
+                        class PublicClass: SuperClass(), SuperInterface
+                    """
+                ),
+            ),
+        ) {
+            val superClass = codebase.assertClass("test.pkg.SuperClass")
+            val superInterface = codebase.assertClass("test.pkg.SuperInterface")
+            val publicClass = codebase.assertClass("test.pkg.PublicClass")
+
+            // Make sure that the classes are not frozen when initially loaded.
+            assertFalse(superClass.frozen, message = "SuperClass.frozen")
+            assertFalse(superInterface.frozen, message = "SuperInterface.frozen")
+            assertFalse(publicClass.frozen, message = "PublicClass.frozen")
+
+            // Freeze the class.
+            publicClass.freeze()
+
+            // Make sure that the classes are frozen after calling freeze(). SuperClass should be
+            // frozen because its subclass was frozen. Similarly, SuperInterface should be frozen
+            // as its subclass was frozen.
+            assertTrue(superClass.frozen, message = "SuperClass.frozen")
+            assertTrue(superInterface.frozen, message = "SuperInterface.frozen")
+            assertTrue(publicClass.frozen, message = "PublicClass.frozen")
+        }
+    }
+
+    @Test
+    fun `Test addMethod on frozen class`() {
+        runCodebaseTest(
+            inputSet(
+                signature(
+                    """
+                       // Signature format: 2.0
+                       package test.pkg {
+                         public class PublicClass extends test.pkg.SuperClass {
+                           ctor public PublicClass();
+                         }
+                         public class SuperClass {
+                           ctor public SuperClass();
+                           method public void foo();
+                         }
+                       } 
+                    """
+                ),
+            ),
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+                        public class SuperClass {
+                            public void foo() {}
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        public class PublicClass extends SuperClass {}
+                    """
+                ),
+            ),
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        open class SuperClass {
+                            fun foo() {}
+                        }
+                    """
+                ),
+                kotlin(
+                    """
+                        package test.pkg
+                        class PublicClass: SuperClass()
+                    """
+                ),
+            ),
+        ) {
+            val superClass = codebase.assertClass("test.pkg.SuperClass")
+            val superClassMethod = superClass.methods().single()
+            val publicClass = codebase.assertClass("test.pkg.PublicClass")
+
+            // Freeze the class.
+            publicClass.freeze()
+
+            // Duplicate and add a method, this should throw an exception.
+            val duplicateMethod = superClassMethod.duplicate(publicClass)
+            val error =
+                assertThrows(IllegalStateException::class.java) {
+                    publicClass.addMethod(duplicateMethod)
+                }
+            assertEquals("Cannot modify frozen class test.pkg.PublicClass", error.message)
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt
new file mode 100644
index 000000000..2e9183e53
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.codebase
+
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import org.junit.Test
+
+/** Common tests for implementations of [MethodItem]. */
+class CommonCodebaseTest : BaseModelTest() {
+
+    @Test
+    fun `Test getTopLevelClassesFromSource`() {
+        runSourceCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    public class Outer {
+                        private Outer() {}
+                        public class Middle {
+                            private Middle() {}
+                            public class Inner {
+                                private Inner(O o) {}
+                            }
+                        }
+                    }
+                """
+            ),
+        ) {
+            val classes = codebase.getTopLevelClassesFromSource()
+
+            assertEquals(listOf(codebase.assertClass("test.pkg.Outer")), classes)
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/SourceConstructorItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/SourceConstructorItemTest.kt
new file mode 100644
index 000000000..32eb40641
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/SourceConstructorItemTest.kt
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.constructoritem
+
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertFalse
+import kotlin.test.assertTrue
+import org.junit.Test
+
+/** Common tests for implementations of [ConstructorItem] for source based models. */
+class SourceConstructorItemTest : BaseModelTest() {
+
+    @Test
+    fun `test implicit default constructor`() {
+        runSourceCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    public class Foo {}
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val constructorItem = fooClass.assertConstructor("")
+
+            assertTrue(
+                fooClass.hasImplicitDefaultConstructor(),
+                message = "hasImplicitDefaultConstructor"
+            )
+            assertTrue(constructorItem.isImplicitConstructor(), message = "isImplicitConstructor")
+        }
+    }
+
+    @Test
+    fun `test explicit no-args public constructor`() {
+        runSourceCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    public class Foo {
+                        public Foo() {}
+                    }
+                """
+            ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val constructorItem = fooClass.assertConstructor("")
+
+            assertFalse(
+                fooClass.hasImplicitDefaultConstructor(),
+                message = "!hasImplicitDefaultConstructor"
+            )
+            assertFalse(constructorItem.isImplicitConstructor(), message = "!isImplicitConstructor")
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt
index a3a462620..1ae44b717 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonCopyFieldItemTest.kt
@@ -57,7 +57,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
 
                         import java.io.IOException;
 
-                        public interface Source  {
+                        public interface Source {
                             int field;
                         }
                     """
@@ -101,7 +101,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
 
                         import java.io.IOException;
 
-                        interface Source  {
+                        public interface Source {
                             static int field;
                         }
                     """
@@ -131,7 +131,7 @@ class CommonCopyFieldItemTest : CommonCopyMemberItemTest<FieldItem>() {
 
                         import java.io.IOException;
 
-                        interface Source  {
+                        public interface Source {
                             int field;
                         }
                     """
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
index 3405c5ed1..ee5ebf76e 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
@@ -295,7 +295,9 @@ class CommonFieldItemTest : BaseModelTest() {
                     "field4" to "T",
                     "field5" to "java.util.Map.Entry<T!,java.lang.String!>",
                 )
-            for (field in codebase.assertClass("test.pkg.Foo").fields()) {
+            val fields = codebase.assertClass("test.pkg.Foo").fields()
+            assertEquals(expectedTypes.size, fields.size, message = "field count")
+            for (field in fields) {
                 val name = field.name()
                 val expectedType = expectedTypes[name]!!
                 // Compare the kotlin style format of the field to ensure that only the outermost
@@ -354,7 +356,9 @@ class CommonFieldItemTest : BaseModelTest() {
                     "field4" to "T?",
                     "field5" to "java.util.Map.Entry<T!,java.lang.String!>?",
                 )
-            for (field in codebase.assertClass("test.pkg.Foo").fields()) {
+            val fields = codebase.assertClass("test.pkg.Foo").fields()
+            assertEquals(expectedTypes.size, fields.size, message = "field count")
+            for (field in fields) {
                 val name = field.name()
                 val expectedType = expectedTypes[name]!!
                 // Compare the kotlin style format of the field to ensure that only the outermost
@@ -491,7 +495,9 @@ class CommonFieldItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
 
             val minNormalBits = java.lang.Float.MIN_NORMAL.toBits()
-            for (field in testClass.fields()) {
+            val fields = testClass.fields()
+            assertEquals(3, fields.size, message = "field count")
+            for (field in fields) {
                 val value = field.initialValue(true) as Float
                 val valueBits = value.toBits()
                 assertEquals(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
index aa2c60e29..cf6ea6347 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
@@ -254,14 +254,21 @@ class SourceFieldItemTest : BaseModelTest() {
 
             assertEquals(
                 fieldItem.modifiers.getVisibilityLevel(),
-                duplicateField.modifiers.getVisibilityLevel()
+                duplicateField.modifiers.getVisibilityLevel(),
+                message = "duplicated visibilityLevel"
             )
-            assertEquals(true, fieldItem.modifiers.equivalentTo(duplicateField.modifiers))
-            assertEquals(true, duplicateField.hidden)
-            assertEquals(false, duplicateField.docOnly)
-            assertEquals(fieldItem.type(), duplicateField.type())
-            assertEquals(fieldItem.initialValue(), duplicateField.initialValue())
-            assertEquals(classItem, duplicateField.inheritedFrom)
+            assertEquals(
+                true,
+                fieldItem.modifiers.equivalentTo(fieldItem, duplicateField.modifiers),
+                message = "duplicated modifiers"
+            )
+            assertEquals(fieldItem.type(), duplicateField.type(), message = "duplicated types")
+            assertEquals(
+                fieldItem.initialValue(),
+                duplicateField.initialValue(),
+                message = "duplicated initial value"
+            )
+            assertEquals(classItem, duplicateField.inheritedFrom, message = "inheritedFrom")
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/memberitem/CommonCopyMemberItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/memberitem/CommonCopyMemberItemTest.kt
index f095c5a2c..c0ce94203 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/memberitem/CommonCopyMemberItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/memberitem/CommonCopyMemberItemTest.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.model.testsuite.memberitem
 
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 
@@ -36,12 +35,12 @@ abstract class CommonCopyMemberItemTest<M : MemberItem> : BaseModelTest() {
     protected abstract fun copyMember(sourceMemberItem: M, targetClassItem: ClassItem): M
 
     protected inner class CopyContext(
-        override val codebase: Codebase,
+        codebaseContext: CodebaseContext,
         val sourceClassItem: ClassItem,
         val targetClassItem: ClassItem,
         val sourceMemberItem: M,
         val copiedMemberItem: M,
-    ) : CodebaseContext<Codebase>
+    ) : CodebaseContext by codebaseContext
 
     protected fun runCopyTest(
         vararg inputs: InputSet,
@@ -61,7 +60,7 @@ abstract class CommonCopyMemberItemTest<M : MemberItem> : BaseModelTest() {
 
             val context =
                 CopyContext(
-                    codebase,
+                    this,
                     sourceClassItem,
                     targetClassItem,
                     sourceMemberItem,
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt
index 8c3c94bef..f00b52e0d 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonCopyMethodItemTest.kt
@@ -46,14 +46,6 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
             ): MethodItem {
                 return sourceMethodItem.duplicate(targetClassItem)
             }
-        },
-        INHERIT(supportedInputFormats = setOf(InputFormat.JAVA)) {
-            override fun copy(
-                sourceMethodItem: MethodItem,
-                targetClassItem: ClassItem
-            ): MethodItem {
-                return targetClassItem.inheritMethodFromNonApiAncestor(sourceMethodItem)
-            }
         };
 
         abstract fun copy(sourceMethodItem: MethodItem, targetClassItem: ClassItem): MethodItem
@@ -106,7 +98,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
 
                         import java.io.IOException;
 
-                        public interface Source  {
+                        public interface Source {
                             void method();
                         }
                     """
@@ -150,7 +142,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
 
                         import java.io.IOException;
 
-                        interface Source  {
+                        public interface Source {
                             default void method() {}
                         }
                     """
@@ -195,7 +187,7 @@ class CommonCopyMethodItemTest : CommonCopyMemberItemTest<MethodItem>() {
 
                         import java.io.IOException;
 
-                        interface Source  {
+                        public interface Source {
                             static void method() {}
                         }
                     """
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
index df631c8fb..1d6934fdb 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
@@ -146,51 +146,6 @@ class CommonMethodItemTest : BaseModelTest() {
         }
     }
 
-    @Test
-    fun `MethodItem superMethods() on constructor`() {
-        runCodebaseTest(
-            inputSet(
-                signature(
-                    """
-                        // Signature format: 2.0
-                        package test.pkg {
-                          public class Base {
-                            ctor public Base();
-                          }
-                          public class Test extends test.pkg.Base {
-                            ctor public Test();
-                          }
-                        }
-                    """
-                ),
-            ),
-            inputSet(
-                java(
-                    """
-                        package test.pkg;
-
-                        public class Base {
-                            public Base() {}
-                        }
-                    """
-                ),
-                java(
-                    """
-                        package test.pkg;
-
-                        public class Test extends Base {
-                            public Test() {}
-                        }
-                    """
-                ),
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val testConstructor = testClass.constructors().single()
-            assertEquals(emptyList(), testConstructor.superMethods())
-        }
-    }
-
     @Test
     fun `MethodItem superMethods() on simple method`() {
         runCodebaseTest(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
index 53c31dede..e9bf32d69 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model.testsuite.methoditem
 
+import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles
@@ -24,6 +25,7 @@ import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertWithMessage
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNull
+import org.junit.Assert.assertThrows
 import org.junit.Test
 
 /** Common tests for implementations of [ParameterItem]. */
@@ -242,6 +244,7 @@ class CommonParameterItemTest : BaseModelTest() {
             // actual parameter name. Probably, because it was compiled with an older version of
             // javac, and/or without the appropriate options to record the parameter name.
             val expectedNames = listOf("p", "p1", "p2", "p3", "p4")
+            assertEquals("parameter count", parameterItems.size, expectedNames.size)
             for (i in parameterItems.indices) {
                 val parameterItem = parameterItems[i]
                 val expectedName = expectedNames[i]
@@ -298,7 +301,9 @@ class CommonParameterItemTest : BaseModelTest() {
                     "method4" to "T",
                     "method5" to "java.util.Map.Entry<T!,java.lang.String!>",
                 )
-            for (method in codebase.assertClass("test.pkg.Foo").methods()) {
+            val methods = codebase.assertClass("test.pkg.Foo").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
                 val name = method.name()
                 val expectedType = expectedTypes[name]!!
                 // Compare the kotlin style format of the parameter to ensure that only the
@@ -358,7 +363,9 @@ class CommonParameterItemTest : BaseModelTest() {
                     "method4" to "T?",
                     "method5" to "java.util.Map.Entry<T!,java.lang.String!>?",
                 )
-            for (method in codebase.assertClass("test.pkg.Foo").methods()) {
+            val methods = codebase.assertClass("test.pkg.Foo").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
                 val name = method.name()
                 val expectedType = expectedTypes[name]!!
                 // Compare the kotlin style format of the parameter to ensure that only the
@@ -413,7 +420,9 @@ class CommonParameterItemTest : BaseModelTest() {
                     "nonNull" to "java.lang.String!...",
                     "platform" to "java.lang.String!...!",
                 )
-            for (method in codebase.assertClass("test.pkg.Foo").methods()) {
+            val methods = codebase.assertClass("test.pkg.Foo").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
                 val name = method.name()
                 val expectedType = expectedTypes[name]!!
                 // Compare the kotlin style format of the parameter to ensure that only the
@@ -457,7 +466,9 @@ class CommonParameterItemTest : BaseModelTest() {
                     "nullable" to "java.lang.String?...",
                     "nonNull" to "java.lang.String...",
                 )
-            for (method in codebase.assertClass("test.pkg.Foo").methods()) {
+            val methods = codebase.assertClass("test.pkg.Foo").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
                 val name = method.name()
                 val parameterItem = method.parameters().single()
 
@@ -492,7 +503,9 @@ class CommonParameterItemTest : BaseModelTest() {
                     "nullable" to "java.lang.Object?[]",
                     "nonNull" to "java.lang.Object[]",
                 )
-            for (method in codebase.assertClass("test.pkg.TestKt").methods()) {
+            val methods = codebase.assertClass("test.pkg.TestKt").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
                 val name = method.name()
                 val parameterItem = method.parameters().first()
 
@@ -527,7 +540,9 @@ class CommonParameterItemTest : BaseModelTest() {
                     "nullable" to "T?...",
                     "nonNull" to "T...",
                 )
-            for (method in codebase.assertClass("test.pkg.TestKt").methods()) {
+            val methods = codebase.assertClass("test.pkg.TestKt").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
                 val name = method.name()
                 val parameterItem = method.parameters().single()
 
@@ -544,4 +559,203 @@ class CommonParameterItemTest : BaseModelTest() {
             }
         }
     }
+
+    @Test
+    fun `Test parameter isVarArgs`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Foo {
+                        method public void varArgsMethod(String... p);
+                        method public void nonVarArgsMethod(String[] p);
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Foo {
+                        public void varArgsMethod(String... p) {}
+                        public void nonVarArgsMethod(String[] p) {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    class Foo {
+                        fun varArgsMethod(vararg p: String) {}
+                        fun nonVarArgsMethod(p: Array<String>) {}
+                    }
+                """
+            ),
+        ) {
+            val expectedTypes =
+                mapOf(
+                    "varArgsMethod" to true,
+                    "nonVarArgsMethod" to false,
+                )
+            val methods = codebase.assertClass("test.pkg.Foo").methods()
+            assertEquals("method count", expectedTypes.size, methods.size)
+            for (method in methods) {
+                val name = method.name()
+                val parameterItem = method.parameters().single()
+
+                // Make sure that it is modelled as a varargs parameter if expected
+                val expectedVarArgs = expectedTypes[name]
+                assertWithMessage("$name isVarArgs")
+                    .that(parameterItem.isVarArgs())
+                    .isEqualTo(expectedVarArgs)
+            }
+        }
+    }
+
+    @Test
+    fun `Test no default value`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 5.0
+                    // - language=kotlin
+                    // - concise-default-values=no
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public final class Foo {
+                        ctor public Foo();
+                        method public method(s: String?): void;
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Foo {
+                        public void method(String s) {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    class Foo {
+                        fun method(s: String?) {}
+                    }
+                """
+            ),
+        ) {
+            val parameter =
+                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single()
+            assertEquals("hasDefaultValue", false, parameter.hasDefaultValue())
+            assertEquals("isDefaultValueKnown", false, parameter.isDefaultValueKnown())
+            // TODO: Improve consistency of the following.
+            when (parameter.itemLanguage) {
+                ItemLanguage.KOTLIN -> {
+                    assertEquals(
+                        "defaultValue",
+                        "__invalid_value__",
+                        parameter.defaultValueAsString()
+                    )
+                }
+                ItemLanguage.JAVA -> {
+                    assertEquals("defaultValue", null, parameter.defaultValueAsString())
+                }
+                ItemLanguage.UNKNOWN -> {
+                    val exception =
+                        assertThrows(IllegalStateException::class.java) {
+                            parameter.defaultValueAsString()
+                        }
+                    assertEquals(
+                        "defaultValue",
+                        "cannot call on NONE DefaultValue",
+                        exception.message
+                    )
+                }
+            }
+        }
+    }
+
+    @Test
+    fun `Test null default value`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 5.0
+                    // - language=kotlin
+                    // - concise-default-values=no
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public final class Foo {
+                        ctor public Foo();
+                        method public method(s: String? = null): void;
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Foo {
+                        public void method(@other.DefaultValue("null") String s) {}
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+
+                    class Foo {
+                        fun method(s: String? = null) {}
+                    }
+                """
+            ),
+        ) {
+            val parameter =
+                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single()
+            assertEquals("hasDefaultValue", true, parameter.hasDefaultValue())
+            assertEquals("isDefaultValueKnown", true, parameter.isDefaultValueKnown())
+            assertEquals("defaultValue", "null", parameter.defaultValueAsString())
+        }
+    }
+
+    @Test
+    fun `Test unknown default value`() {
+        runCodebaseTest(
+            // Neither Kotlin nor Java has a way to specify an unknown default property. Kotlin and
+            // Java both treat no default and unknown default as the same. Only signature file can
+            // specify that it has a default but does not know what its value is. It does that by
+            // using the `optional` pseudo modifier.
+            signature(
+                """
+                    // Signature format: 5.0
+                    // - language=kotlin
+                    // - concise-default-values=yes
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public final class Foo {
+                        ctor public Foo();
+                        method public method(optional s: String?): void;
+                      }
+                    }
+                """
+            ),
+        ) {
+            val parameter =
+                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single()
+            assertEquals("hasDefaultValue", true, parameter.hasDefaultValue())
+
+            assertEquals("isDefaultValueKnown", false, parameter.isDefaultValueKnown())
+            val exception =
+                assertThrows(IllegalStateException::class.java) { parameter.defaultValueAsString() }
+            assertEquals("defaultValue", "cannot call on UNKNOWN DefaultValue", exception.message)
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonSuperMethodsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonSuperMethodsTest.kt
index 5180cced5..e1f8534d5 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonSuperMethodsTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonSuperMethodsTest.kt
@@ -738,7 +738,8 @@ class CommonSuperMethodsTest : BaseModelTest() {
             val method = codebase.assertClass("test.pkg.Foo").methods().first()
             val parentInterfaceMethod =
                 codebase.assertClass("test.pkg.ParentInterface").methods().first()
-            val hiddenClassMethod = codebase.assertClass("test.pkg.HiddenClass").methods().first()
+            val hiddenClassMethod =
+                codebase.assertResolvedClass("test.pkg.HiddenClass").methods().first()
 
             assertEquals(listOf(hiddenClassMethod, parentInterfaceMethod), method.superMethods())
         }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/SourceMethodItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/SourceMethodItemTest.kt
index 13a1f9759..6ef3740c6 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/SourceMethodItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/SourceMethodItemTest.kt
@@ -32,7 +32,7 @@ class SourceMethodItemTest : BaseModelTest() {
         duplicatedMethod.parameters().forEach {
             // Make sure that the duplicated parameters consider themselves to be part of
             // the duplicated method.
-            assertSame(duplicatedMethod, it.containingMethod())
+            assertSame(duplicatedMethod, it.containingCallable())
         }
     }
 
@@ -69,12 +69,13 @@ class SourceMethodItemTest : BaseModelTest() {
                 methodItem.modifiers.getVisibilityLevel(),
                 duplicateMethod.modifiers.getVisibilityLevel()
             )
-            assertEquals(true, methodItem.modifiers.equivalentTo(duplicateMethod.modifiers))
-            assertEquals(true, duplicateMethod.hidden)
-            assertEquals(false, duplicateMethod.docOnly)
+            assertEquals(
+                true,
+                methodItem.modifiers.equivalentTo(methodItem, duplicateMethod.modifiers)
+            )
             assertEquals("void", duplicateMethod.returnType().toTypeString())
             assertEquals(
-                listOf("A", "B"),
+                listOf("M", "String"),
                 duplicateMethod.parameters().map { it.type().toTypeString() }
             )
             assertEquals(methodItem.typeParameterList, duplicateMethod.typeParameterList)
@@ -86,9 +87,10 @@ class SourceMethodItemTest : BaseModelTest() {
                 methodItem1.modifiers.getVisibilityLevel(),
                 duplicateMethod1.modifiers.getVisibilityLevel()
             )
-            assertEquals(true, methodItem1.modifiers.equivalentTo(duplicateMethod1.modifiers))
-            assertEquals(true, duplicateMethod1.hidden)
-            assertEquals(false, duplicateMethod1.docOnly)
+            assertEquals(
+                true,
+                methodItem1.modifiers.equivalentTo(methodItem1, duplicateMethod1.modifiers)
+            )
             assertEquals("void", duplicateMethod.returnType().toTypeString())
             assertEquals(
                 listOf("C", "D"),
@@ -100,70 +102,4 @@ class SourceMethodItemTest : BaseModelTest() {
             checkMethodParameterState(duplicateMethod1)
         }
     }
-
-    @Test
-    fun `test inherited methods`() {
-        runSourceCodebaseTest(
-            java(
-                """
-                    package test.pkg;
-
-                    import java.io.IOException;
-
-                    /** @doconly Some docs here */
-                    public class Test<A,B>  {
-                        public final void foo(A a, B b) throws IOException {}
-
-                        public final <C,D extends Number> void foo1(C a,D d) {}
-                    }
-
-                    /** @hide */
-                    public class Target<M,String> extends Test<M,String> {}
-                """
-            ),
-        ) {
-            val classItem = codebase.assertClass("test.pkg.Test")
-            val targetClassItem = codebase.assertClass("test.pkg.Target")
-            val methodItem = classItem.methods().first()
-            val methodItem1 = classItem.methods().last()
-
-            val inheritedMethod = targetClassItem.inheritMethodFromNonApiAncestor(methodItem)
-            val inheritedMethod1 = targetClassItem.inheritMethodFromNonApiAncestor(methodItem1)
-
-            assertEquals(
-                methodItem.modifiers.getVisibilityLevel(),
-                inheritedMethod.modifiers.getVisibilityLevel()
-            )
-            assertEquals(true, methodItem.modifiers.equivalentTo(inheritedMethod.modifiers))
-            assertEquals(false, inheritedMethod.hidden)
-            assertEquals(false, inheritedMethod.docOnly)
-            assertEquals("void", inheritedMethod.returnType().toTypeString())
-            assertEquals(
-                listOf("M", "String"),
-                inheritedMethod.parameters().map { it.type().toTypeString() }
-            )
-            assertEquals(methodItem.typeParameterList, inheritedMethod.typeParameterList)
-            assertEquals(methodItem.throwsTypes(), inheritedMethod.throwsTypes())
-            assertEquals(classItem, inheritedMethod.inheritedFrom)
-            checkMethodParameterState(inheritedMethod)
-
-            assertEquals(
-                methodItem1.modifiers.getVisibilityLevel(),
-                inheritedMethod1.modifiers.getVisibilityLevel()
-            )
-            assertEquals(true, methodItem1.modifiers.equivalentTo(inheritedMethod1.modifiers))
-            assertEquals(false, inheritedMethod1.hidden)
-            assertEquals(false, inheritedMethod1.docOnly)
-            assertEquals(methodItem1.returnType(), inheritedMethod1.returnType())
-            assertEquals("void", inheritedMethod.returnType().toTypeString())
-            assertEquals(
-                listOf("C", "D"),
-                inheritedMethod1.parameters().map { it.type().toTypeString() }
-            )
-            assertEquals(methodItem1.typeParameterList, inheritedMethod1.typeParameterList)
-            assertEquals(methodItem1.throwsTypes(), inheritedMethod1.throwsTypes())
-            assertEquals(classItem, inheritedMethod1.inheritedFrom)
-            checkMethodParameterState(inheritedMethod1)
-        }
-    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
index 4c90ea51d..e66376283 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
@@ -16,11 +16,13 @@
 
 package com.android.tools.metalava.model.testsuite.packageitem
 
+import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles.nonNullSource
 import com.android.tools.metalava.testing.html
 import com.android.tools.metalava.testing.java
 import kotlin.test.assertEquals
+import kotlin.test.assertNull
 import org.junit.Test
 
 class CommonPackageItemTest : BaseModelTest() {
@@ -140,4 +142,290 @@ class CommonPackageItemTest : BaseModelTest() {
             )
         }
     }
+
+    private fun dumpPackageContainment(start: Item): String {
+        return buildString {
+            val packageContainment = generateSequence(start) { it.containingPackage() }
+            for (item in packageContainment) {
+                if (isNotEmpty()) append("-> ")
+                append(item.describe())
+                append("\n")
+            }
+        }
+    }
+
+    @Test
+    fun `Test package containment`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package java.lang.invoke.mine {
+                        public class Foo {
+                        }
+                    }
+                """
+            ),
+            java(
+                """
+                    package java.lang.invoke.mine;
+
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            val classItem = codebase.assertClass("java.lang.invoke.mine.Foo")
+
+            assertEquals(
+                """
+                    class java.lang.invoke.mine.Foo
+                    -> package java.lang.invoke.mine
+                    -> package java.lang.invoke
+                    -> package java.lang
+                    -> package java
+                    -> package <root>
+                """
+                    .trimIndent(),
+                dumpPackageContainment(classItem).trim()
+            )
+        }
+    }
+
+    @Test
+    fun `Test package location (signature)`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public class Foo {
+                        }
+                    }
+                """
+            ),
+        ) {
+            val packageItem = codebase.assertPackage("test.pkg")
+            val packageLocation = packageItem.fileLocation.path.toString()
+
+            assertEquals("TESTROOT/api.txt", removeTestSpecificDirectories(packageLocation))
+        }
+    }
+
+    @Test
+    fun `Test package location (package-info)`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {
+                        }
+                    """
+                ),
+                java(
+                    """
+                        /** Some text. */
+                        package test.pkg;
+                    """
+                ),
+            ),
+        ) {
+            val packageItem = codebase.assertPackage("test.pkg")
+            val packageLocation = packageItem.fileLocation.path.toString()
+
+            assertEquals(
+                "TESTROOT/src/test/pkg/package-info.java",
+                removeTestSpecificDirectories(packageLocation)
+            )
+        }
+    }
+
+    @Test
+    fun `Test package documentation (package-info)`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {
+                        }
+                    """
+                ),
+                java(
+                    """
+                        /** Some text. */
+                        package test.pkg;
+                    """
+                ),
+            ),
+        ) {
+            val packageItem = codebase.assertPackage("test.pkg")
+
+            assertEquals(
+                "/** Some text. */",
+                packageItem.documentation.text.trim(),
+            )
+        }
+    }
+
+    @Test
+    fun `Test package location (package-html)`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {
+                        }
+                    """
+                ),
+                html(
+                    "src/test/pkg/package.html",
+                    """
+                        <HTML>
+                        <BODY>
+                        Some text.
+                        </BODY>
+                        </HTML>
+                    """
+                ),
+            ),
+        ) {
+            val packageItem = codebase.assertPackage("test.pkg")
+            val packageLocation = packageItem.fileLocation.path.toString()
+
+            assertEquals(
+                "TESTROOT/src/test/pkg/package.html",
+                removeTestSpecificDirectories(packageLocation)
+            )
+        }
+    }
+
+    @Test
+    fun `Test package documentation (package-html)`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {
+                        }
+                    """
+                ),
+                html(
+                    "src/test/pkg/package.html",
+                    """
+                        <HTML>
+                        <BODY>
+                        Some text.
+                        </BODY>
+                        </HTML>
+                    """
+                ),
+            ),
+        ) {
+            val packageItem = codebase.assertPackage("test.pkg")
+
+            assertEquals(
+                """
+                    /**
+                     * Some text.
+                     */
+                """
+                    .trimIndent(),
+                packageItem.documentation.text.trim(),
+            )
+        }
+    }
+
+    @Test
+    fun `Test invalid package (package-html)`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {
+                        }
+                    """
+                ),
+                html(
+                    "src/other/pkg/package.html",
+                    """
+                        <HTML>
+                        <BODY>
+                        Some text.
+                        </BODY>
+                        </HTML>
+                    """
+                ),
+            ),
+        ) {
+            val packageItem = codebase.findPackage("other.pkg")
+            assertNull(packageItem)
+        }
+    }
+
+    @Test
+    fun `Test package documentation (overview-html)`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Foo {
+                        }
+                    """
+                ),
+                html(
+                    "src/test/pkg/overview.html",
+                    """
+                        <HTML>
+                        <BODY>
+                        Overview.
+                        </BODY>
+                        </HTML>
+                    """
+                ),
+            ),
+        ) {
+            val packageItem = codebase.assertPackage("test.pkg")
+
+            assertEquals(
+                """
+                    <HTML>
+                    <BODY>
+                    Overview.
+                    </BODY>
+                    </HTML>
+                """
+                    .trimIndent(),
+                packageItem.overviewDocumentation?.content?.trim(),
+            )
+        }
+    }
+
+    @Test
+    fun `Test mismatching between package and directory`() {
+        runCodebaseTest(
+            java(
+                "src/test/other/Foo.java",
+                """
+                    package test.pkg;
+
+                    public class Foo {
+                    }
+                """
+            ),
+        ) {
+            codebase.assertClass("test.pkg.Foo")
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/SourceFileTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
similarity index 91%
rename from metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/SourceFileTest.kt
rename to metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
index 0b957e5c9..b8913ff80 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/SourceFileTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
@@ -78,9 +78,9 @@ class CommonSourceFileTest : BaseModelTest() {
                     """
                         package test.pkg1;
 
-                        class Test1 {}
+                        public class Test1 {}
 
-                        class Test2 {}
+                        public class Test2 {}
                     """
                 ),
                 java(
@@ -88,7 +88,7 @@ class CommonSourceFileTest : BaseModelTest() {
                         package test;
 
                         /** @hide */
-                        class Test {
+                        public class Test {
                             class Inner {}
                         }
                     """
@@ -114,13 +114,12 @@ class CommonSourceFileTest : BaseModelTest() {
             // Method and Field imports don't seem to resolve and are not included.
             assertEquals(
                 setOf(classImport, innerClassImport, packageImport),
-                sourceFile.getImports(AlwaysTrue())
+                sourceFile.getImports(AlwaysTrue()),
+                message = "unfiltered imports"
             )
 
-            assertEquals(
-                setOf(innerClassImport, packageImport),
-                sourceFile.getImports(FilterHidden())
-            )
+            val imports = sourceFile.getImports(FilterHidden())
+            assertEquals(setOf(packageImport), imports, message = "filtered hidden")
         }
     }
 
@@ -133,7 +132,7 @@ class CommonSourceFileTest : BaseModelTest() {
 
                     public class Test {}
 
-                    class Outer {
+                    public class Outer {
                         class Inner {}
                     }
                 """
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
index 26f8cee19..fd0a87e92 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
@@ -17,18 +17,24 @@
 package com.android.tools.metalava.model.testsuite.typeitem
 
 import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.BaseTypeTransformer
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.ReferenceTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeModifiers
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
+import kotlin.test.assertEquals
 import org.junit.Test
 
 class CommonTypeItemTest : BaseModelTest() {
@@ -1473,6 +1479,349 @@ class CommonTypeItemTest : BaseModelTest() {
         }
     }
 
+    @Test
+    fun `Test convertType's creation of duplicate objects`() {
+        runCodebaseTest(
+            inputSet(
+                signature(
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public interface Input<T,Unused> {
+                            // Field from which the type to be substituted for a type variable will
+                            // be retrieved.
+                            field public @NonNull Long javaLongType;
+
+                            // One for each TypeItem subinterface supported in signature files.
+                            method public @NonNull T @Nullable [] arrayTypeItem();
+                            method public @Nullable java.util.List<@NonNull T> classTypeItem();
+                            method public int primitiveTypeItem();
+                            method public @Nullable T variableTypeItem();
+                            method public @Nullable java.util.List<? extends @NonNull T> wildcardTypeItem_extendsBound();
+                            method public @Nullable java.util.List<? super @NonNull T> wildcardTypeItem_superBound();
+                          }
+                        }
+                    """
+                ),
+            ),
+            inputSet(
+                KnownSourceFiles.nonNullSource,
+                KnownSourceFiles.nullableSource,
+                java(
+                    """
+                        package test.pkg;
+                        import android.annotation.NonNull;
+                        import android.annotation.Nullable;
+                        import java.util.List;
+                        public interface Input<T,Unused> {
+                            // Field from which the type to be substituted for a type variable will
+                            // be retrieved.
+                            @NonNull Long javaLongType;
+
+                            // One for each TypeItem subinterface supported in signature files.
+                            @NonNull T @Nullable [] arrayTypeItem();
+                            @Nullable List<@NonNull T> classTypeItem();
+                            int primitiveTypeItem();
+                            @Nullable T variableTypeItem();
+                            @Nullable List<? extends @NonNull T> wildcardTypeItem_extendsBound();
+                            @Nullable List<? super @NonNull T> wildcardTypeItem_superBound();
+                        }
+                    """
+                ),
+            ),
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        import java.util.List
+                        interface Input<T,Unused> {
+                            // Field from which the type to be substituted for a type variable will
+                            // be retrieved.
+                            companion object {
+                                @JvmField val javaLongType: java.lang.Long
+                            }
+
+                            // One for each TypeItem subinterface supported in signature files.
+                            fun arrayTypeItem(): Array<T>?
+                            fun classTypeItem(): List<T>?
+                            fun lambdaTypeItem(): ((T) -> Int)?
+                            fun primitiveTypeItem(): Int
+                            fun variableTypeItem(): T?
+                            fun wildcardTypeItem_extendsBound(): List<out T>?
+                            fun wildcardTypeItem_superBound(): List<in T>?
+                        }
+                    """
+                ),
+            ),
+        ) {
+            val inputClass = codebase.assertClass("test.pkg.Input")
+
+            // Get the type variables from the class.
+            val (usedTypeVariable, unusedTypeVariable) = inputClass.typeParameterList
+
+            // Get the type to substitute
+            val javaLongType = inputClass.assertField("javaLongType").type() as ReferenceTypeItem
+
+            // Iterate over the methods
+            val types = buildString {
+                for (method in inputClass.methods()) {
+                    val name = method.name()
+                    val typeToTest = method.returnType()
+
+                    fun TypeItem.typeInfo() =
+                        toTypeString(
+                            annotations = true,
+                            kotlinStyleNulls = true,
+                        )
+
+                    append(name).append("\n")
+                    append("    original: ${typeToTest.typeInfo()}\n")
+
+                    // Map the Unused type variable to java.lang.Long. This should have no effect of
+                    // on the test type.
+                    typeToTest.convertType(mapOf(unusedTypeVariable to javaLongType)).also { result
+                        ->
+                        append("${"    no change"}: ${result.typeInfo()}\n")
+                        val unusedMessage =
+                            "conversion of ${unusedTypeVariable.name()} to $javaLongType in $name"
+                        assertWithMessage(unusedMessage).that(result).isSameInstanceAs(typeToTest)
+                    }
+
+                    // Map the T type variable to java.lang.Long. This should change every type
+                    // except the primitive type.
+                    typeToTest.convertType(mapOf(usedTypeVariable to javaLongType)).also { result ->
+                        append("${"    T -> java.lang.Long"}: ${result.typeInfo()}\n")
+                        val usedMessage =
+                            "conversion of ${usedTypeVariable.name()} to $javaLongType in $name"
+                        if (name == "primitiveTypeItem") {
+                            assertWithMessage(usedMessage).that(result).isSameInstanceAs(typeToTest)
+                        } else {
+                            assertWithMessage(usedMessage)
+                                .that(result)
+                                .isNotSameInstanceAs(typeToTest)
+                        }
+                    }
+
+                    append("\n")
+                }
+            }
+
+            val optionalLambda =
+                """
+                    lambdaTypeItem
+                        original: kotlin.jvm.functions.Function1<T,java.lang.Integer>?
+                        no change: kotlin.jvm.functions.Function1<T,java.lang.Integer>?
+                        T -> java.lang.Long: kotlin.jvm.functions.Function1<java.lang.Long,java.lang.Integer>?
+                """
+
+            assertEquals(
+                """
+                    arrayTypeItem
+                        original: T[]?
+                        no change: T[]?
+                        T -> java.lang.Long: java.lang.Long[]?
+
+                    classTypeItem
+                        original: java.util.List<T>?
+                        no change: java.util.List<T>?
+                        T -> java.lang.Long: java.util.List<java.lang.Long>?
+                    ${if (inputFormat == InputFormat.KOTLIN) optionalLambda else ""}
+                    primitiveTypeItem
+                        original: int
+                        no change: int
+                        T -> java.lang.Long: int
+
+                    variableTypeItem
+                        original: T?
+                        no change: T?
+                        T -> java.lang.Long: java.lang.Long?
+
+                    wildcardTypeItem_extendsBound
+                        original: java.util.List<? extends T>?
+                        no change: java.util.List<? extends T>?
+                        T -> java.lang.Long: java.util.List<? extends java.lang.Long>?
+
+                    wildcardTypeItem_superBound
+                        original: java.util.List<? super T>?
+                        no change: java.util.List<? super T>?
+                        T -> java.lang.Long: java.util.List<? super java.lang.Long>?
+                """
+                    .trimIndent(),
+                types.trim()
+            )
+        }
+    }
+
+    @Test
+    fun `Test transform's creation of duplicate objects`() {
+        val typeUseAnnotation =
+            java(
+                """
+            package test.annotation;
+            import java.lang.annotation.ElementType;
+            import java.lang.annotation.Target;
+
+            @Target(ElementType.TYPE_USE)
+            public @interface TypeUse {}
+        """
+            )
+        runCodebaseTest(
+            inputSet(
+                signature(
+                    """
+                        // Signature format: 5.0
+                        // - kotlin-style-nulls=yes
+                        // - kotlin-name-type-order=yes
+                        // - include-type-use-annotations=yes
+                        package test.pkg {
+                          public interface Input<T> {
+                            // One for each TypeItem subinterface supported in signature files.
+                            method public arrayTypeItem(): T @test.annotation.TypeUse []?;
+                            method public classTypeItem(): @test.annotation.TypeUse java.util.List<@test.annotation.TypeUse T>?;
+                            method public primitiveTypeItem(): @test.annotation.TypeUse int;
+                            method public variableTypeItem(): @test.annotation.TypeUse T?;
+                            method public wildcardTypeItem_extendsBound(): java.util.List<? extends @test.annotation.TypeUse T>?;
+                            method public wildcardTypeItem_superBound(): java.util.List<? super @test.annotation.TypeUse T>?;
+                          }
+                        }
+                        package test.annotation {
+                          public @interface TypeUse {
+                          }
+                        }
+                    """
+                ),
+            ),
+            inputSet(
+                KnownSourceFiles.nonNullSource,
+                KnownSourceFiles.nullableSource,
+                typeUseAnnotation,
+                java(
+                    """
+                        package test.pkg;
+                        import android.annotation.NonNull;
+                        import android.annotation.Nullable;
+                        import java.util.List;
+                        import test.annotation.TypeUse;
+                        public interface Input<T,Unused> {
+                            @NonNull T @TypeUse @Nullable [] arrayTypeItem();
+                            @TypeUse @Nullable List<@TypeUse @NonNull T> classTypeItem();
+                            @TypeUse int primitiveTypeItem();
+                            @TypeUse @Nullable T variableTypeItem();
+                            @Nullable List<? extends @TypeUse @NonNull T> wildcardTypeItem_extendsBound();
+                            @Nullable List<? super @TypeUse @NonNull T> wildcardTypeItem_superBound();
+                        }
+                    """
+                ),
+            ),
+            inputSet(
+                typeUseAnnotation,
+                kotlin(
+                    """
+                        package test.pkg
+                        import java.util.List
+                        import test.annotation.TypeUse
+                        interface Input<T,Unused> {
+                            fun arrayTypeItem(): @TypeUse Array<T>?
+                            fun classTypeItem(): @TypeUse List<@TypeUse T>?
+                            fun lambdaTypeItem(): ((@TypeUse T) -> @TypeUse Int)?
+                            fun primitiveTypeItem(): @TypeUse Int
+                            fun variableTypeItem(): @TypeUse T?
+                            fun wildcardTypeItem_extendsBound(): List<out @TypeUse T>?
+                            fun wildcardTypeItem_superBound(): List<in @TypeUse T>?
+                        }
+                    """
+                ),
+            ),
+        ) {
+            val inputClass = codebase.assertClass("test.pkg.Input")
+
+            // Iterate over the methods
+            val types = buildString {
+                for (method in inputClass.methods()) {
+                    val name = method.name()
+                    val typeToTest = method.returnType()
+
+                    fun TypeItem.typeInfo() =
+                        toTypeString(
+                            annotations = true,
+                            kotlinStyleNulls = true,
+                        )
+
+                    append(name).append("\n")
+                    append("    original: ${typeToTest.typeInfo()}\n")
+
+                    // Check that a no-op transformation returns the TypeItem on which it is called.
+                    typeToTest.transform(BaseTypeTransformer()).also { result ->
+                        append("${"    no change"}: ${result.typeInfo()}\n")
+                        val unusedMessage = "no-op transformation in $name"
+                        assertWithMessage(unusedMessage).that(result).isSameInstanceAs(typeToTest)
+                    }
+
+                    // A TypeTransformer that will discard all type annotations.
+                    val annotationsRemover =
+                        object : BaseTypeTransformer() {
+                            override fun transform(modifiers: TypeModifiers): TypeModifiers {
+                                return modifiers.substitute(annotations = emptyList())
+                            }
+                        }
+
+                    // Check that an actual transformation returns different objects.
+                    typeToTest.transform(annotationsRemover).also { result ->
+                        append("    discarded annotations: ${result.typeInfo()}\n")
+                        val usedMessage = "discarded annotations in $name"
+                        assertWithMessage(usedMessage).that(result).isNotSameInstanceAs(typeToTest)
+                    }
+
+                    append("\n")
+                }
+            }
+
+            val optionalLambda =
+                """
+                    lambdaTypeItem
+                        original: kotlin.jvm.functions.Function1<@test.annotation.TypeUse T,java.lang.@test.annotation.TypeUse Integer>?
+                        no change: kotlin.jvm.functions.Function1<@test.annotation.TypeUse T,java.lang.@test.annotation.TypeUse Integer>?
+                        discarded annotations: kotlin.jvm.functions.Function1<T,java.lang.Integer>?
+                """
+
+            assertEquals(
+                """
+                    arrayTypeItem
+                        original: T @test.annotation.TypeUse []?
+                        no change: T @test.annotation.TypeUse []?
+                        discarded annotations: T[]?
+
+                    classTypeItem
+                        original: java.util.@test.annotation.TypeUse List<@test.annotation.TypeUse T>?
+                        no change: java.util.@test.annotation.TypeUse List<@test.annotation.TypeUse T>?
+                        discarded annotations: java.util.List<T>?
+                    ${if (inputFormat == InputFormat.KOTLIN) optionalLambda else ""}
+                    primitiveTypeItem
+                        original: @test.annotation.TypeUse int
+                        no change: @test.annotation.TypeUse int
+                        discarded annotations: int
+
+                    variableTypeItem
+                        original: @test.annotation.TypeUse T?
+                        no change: @test.annotation.TypeUse T?
+                        discarded annotations: T?
+
+                    wildcardTypeItem_extendsBound
+                        original: java.util.List<? extends @test.annotation.TypeUse T>?
+                        no change: java.util.List<? extends @test.annotation.TypeUse T>?
+                        discarded annotations: java.util.List<? extends T>?
+
+                    wildcardTypeItem_superBound
+                        original: java.util.List<? super @test.annotation.TypeUse T>?
+                        no change: java.util.List<? super @test.annotation.TypeUse T>?
+                        discarded annotations: java.util.List<? super T>?
+                """
+                    .trimIndent(),
+                types.trim()
+            )
+        }
+    }
+
     @Test
     fun `Test hasTypeArguments`() {
         runCodebaseTest(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
index cf94e110a..b27b59976 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
@@ -614,7 +614,7 @@ class CommonTypeModifiersTest : BaseModelTest() {
 
             val bar = interfaces[0]
             assertThat(bar.qualifiedName).isEqualTo("test.pkg.Bar")
-            val annotations = bar.modifiers.annotations()
+            val annotations = bar.modifiers.annotations
             assertThat(annotations).hasSize(1)
             assertThat(annotations.single().qualifiedName).isEqualTo("test.pkg.A")
 
@@ -775,8 +775,8 @@ class CommonTypeModifiersTest : BaseModelTest() {
         ) {
             // Check the modifiers contain one annotation, `@test.pkg.A(a=1, b=2, c=3)`
             val testModifiers = { modifiers: TypeModifiers ->
-                assertThat(modifiers.annotations()).hasSize(1)
-                val annotation = modifiers.annotations().single()
+                assertThat(modifiers.annotations).hasSize(1)
+                val annotation = modifiers.annotations.single()
                 assertThat(annotation.qualifiedName).isEqualTo("test.pkg.A")
                 val attributes = annotation.attributes
                 assertThat(attributes.toString()).isEqualTo("[a=1, b=2, c=3]")
@@ -818,41 +818,6 @@ class CommonTypeModifiersTest : BaseModelTest() {
         }
     }
 
-    @Test
-    fun `Test adding and removing annotations`() {
-        // Not supported for text codebases due to caching
-        runCodebaseTest(
-            java(
-                """
-                    package test.pkg;
-                    import java.lang.annotation.ElementType;
-                    import java.lang.annotation.Target;
-                    public class Foo {
-                        public @A @B String foo() {}
-                    }
-                    @Target(ElementType.TYPE_USE)
-                    public @interface A {}
-                    @Target(ElementType.TYPE_USE)
-                    public @interface B {}
-                """
-                    .trimIndent()
-            ),
-        ) {
-            val stringType = codebase.assertClass("test.pkg.Foo").methods().single().returnType()
-            assertThat(stringType.annotationNames()).containsExactly("test.pkg.A", "test.pkg.B")
-
-            // Remove annotation
-            val annotationA = stringType.modifiers.annotations().first()
-            assertThat(annotationA.qualifiedName).isEqualTo("test.pkg.A")
-            stringType.modifiers.removeAnnotation(annotationA)
-            assertThat(stringType.annotationNames()).containsExactly("test.pkg.B")
-
-            // Add annotation
-            stringType.modifiers.addAnnotation(annotationA)
-            assertThat(stringType.annotationNames()).containsExactly("test.pkg.B", "test.pkg.A")
-        }
-    }
-
     @Test
     fun `Test nullability of primitives`() {
         runNullabilityTest(
@@ -971,7 +936,7 @@ class CommonTypeModifiersTest : BaseModelTest() {
             // Platform nullability isn't possible from Kotlin
             if (inputFormat != InputFormat.KOTLIN) {
                 val platformString = fooClass.assertMethod("platformString", "").returnType()
-                assertThat(platformString.modifiers.nullability()).isEqualTo(PLATFORM)
+                assertThat(platformString.modifiers.nullability).isEqualTo(PLATFORM)
             }
 
             val nullableString = fooClass.assertMethod("nullableString", "").returnType()
@@ -1590,19 +1555,19 @@ class CommonTypeModifiersTest : BaseModelTest() {
             stringType.assertHasNullableNullability(annotations)
 
             // Set to platform
-            stringType.modifiers.setNullability(PLATFORM)
-            stringType.assertHasPlatformNullability()
+            val platformStringType = stringType.substitute(PLATFORM)
+            platformStringType.assertHasPlatformNullability()
             // The annotation was not removed
             if (annotations) {
-                assertThat(stringType.annotationNames().single()).endsWith("Nullable")
+                assertThat(platformStringType.annotationNames().single()).endsWith("Nullable")
             }
 
             // Set to non-null
-            stringType.modifiers.setNullability(NONNULL)
-            assertThat(stringType.modifiers.nullability()).isEqualTo(NONNULL)
+            val nonNullStringType = stringType.substitute(NONNULL)
+            assertThat(nonNullStringType.modifiers.nullability).isEqualTo(NONNULL)
             // The nullable annotation was not removed, a nonnull annotation was not added
             if (annotations) {
-                assertThat(stringType.annotationNames().single()).endsWith("Nullable")
+                assertThat(nonNullStringType.annotationNames().single()).endsWith("Nullable")
             }
         }
 
@@ -2293,12 +2258,12 @@ class CommonTypeModifiersTest : BaseModelTest() {
         ) {
             val foo = codebase.assertClass("test.pkg.Foo").constructors().single().returnType()
             foo.assertHasNonNullNullability()
-            val f = (foo as ClassTypeItem).arguments.single()
+            val f = foo.arguments.single()
             f.assertHasUndefinedNullability()
 
             val bar = codebase.assertClass("test.pkg.Foo.Bar").constructors().single().returnType()
             bar.assertHasNonNullNullability()
-            val b = (bar as ClassTypeItem).arguments.single()
+            val b = bar.arguments.single()
             b.assertHasUndefinedNullability()
             val outerFoo = bar.outerClassType!!
             outerFoo.assertHasNonNullNullability()
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
index 5c4680b64..b5ce840e3 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
@@ -22,6 +22,7 @@ import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.isNullnessAnnotation
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.typeUseAnnotationFilter
 import com.android.tools.metalava.testing.KnownSourceFiles.intRangeTypeUseSource
 import com.android.tools.metalava.testing.KnownSourceFiles.libcoreNonNullSource
 import com.android.tools.metalava.testing.KnownSourceFiles.libcoreNullableSource
@@ -162,12 +163,16 @@ class CommonTypeStringTest : BaseModelTest() {
         runCodebaseTest(javaTestFiles(), signatureTestFile()) {
             val method = codebase.assertClass("test.pkg.Foo").methods().single()
             val param = method.parameters().single()
-            val type = param.type()
+            val type =
+                param.type().let { unfilteredType ->
+                    val filter =
+                        parameters.typeStringConfiguration.filter ?: return@let unfilteredType
+                    unfilteredType.transform(typeUseAnnotationFilter(filter))
+                }
             val typeString =
                 type.toTypeString(
                     annotations = parameters.typeStringConfiguration.annotations,
                     kotlinStyleNulls = parameters.typeStringConfiguration.kotlinStyleNulls,
-                    filter = parameters.typeStringConfiguration.filter,
                     spaceBetweenParameters =
                         parameters.typeStringConfiguration.spaceBetweenParameters,
                 )
diff --git a/metalava-model-text/build.gradle.kts b/metalava-model-text/build.gradle.kts
index a933038c7..cafbbbf53 100644
--- a/metalava-model-text/build.gradle.kts
+++ b/metalava-model-text/build.gradle.kts
@@ -27,6 +27,10 @@ plugins {
 
 dependencies {
     testFixturesImplementation(libs.junit4)
+    testFixturesImplementation(testFixtures(project(":metalava-model")))
+    testFixturesImplementation(project(":metalava-model-testsuite"))
+    testFixturesImplementation(project(":metalava-testing"))
+    testFixturesImplementation(project(":metalava-reporter"))
 
     testImplementation(project(":metalava-testing"))
     testImplementation(testFixtures(project(":metalava-model")))
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
index 2050dfeb2..34282d5ea 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
@@ -21,25 +21,43 @@ import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationItem.Companion.unshortenAnnotation
 import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultModifierList
 import com.android.tools.metalava.model.DefaultTypeParameterList
 import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.FixedFieldValue
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemDocumentation
 import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
+import com.android.tools.metalava.model.JAVA_LANG_OBJECT
 import com.android.tools.metalava.model.MetalavaApi
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
+import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.TypeParameterListAndFactory
 import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.model.createMutableModifiers
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
+import com.android.tools.metalava.model.item.DefaultValue
+import com.android.tools.metalava.model.item.MutablePackageDoc
+import com.android.tools.metalava.model.item.PackageDocs
 import com.android.tools.metalava.model.javaUnescapeString
 import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.type.MethodFingerprint
@@ -81,10 +99,12 @@ data class SignatureFile(
 @MetalavaApi
 class ApiFile
 private constructor(
-    private val codebase: TextCodebase,
+    private val assembler: TextCodebaseAssembler,
     private val formatForLegacyFiles: FileFormat?,
 ) {
 
+    private val codebase = assembler.codebase
+
     /**
      * Provides support for parsing and caching [TypeItem]s.
      *
@@ -100,7 +120,10 @@ private constructor(
      * Defer creation as it depends on [typeParser].
      */
     private val globalTypeItemFactory by
-        lazy(LazyThreadSafetyMode.NONE) { TextTypeItemFactory(codebase, typeParser) }
+        lazy(LazyThreadSafetyMode.NONE) { TextTypeItemFactory(assembler, typeParser) }
+
+    /** Creates [Item] instances for [codebase]. */
+    private val itemFactory = assembler.itemFactory
 
     /**
      * Whether types should be interpreted to be in Kotlin format (e.g. ? suffix means nullable, !
@@ -152,11 +175,11 @@ private constructor(
             )
 
         /**
-         * Read API signature files into a [TextCodebase].
+         * Read API signature files into a [DefaultCodebase].
          *
-         * Note: when reading from them multiple files, [TextCodebase.location] would refer to the
-         * first file specified. each [com.android.tools.metalava.model.text.TextItem.fileLocation]
-         * would correctly point out the source file of each item.
+         * Note: when reading from them multiple files, [DefaultCodebase.location] would refer to
+         * the first file specified. each [Item.fileLocation] would correctly point out the source
+         * file of each item.
          *
          * @param signatureFiles input signature files
          */
@@ -170,19 +193,20 @@ private constructor(
             apiStatsConsumer: (Stats) -> Unit = {},
         ): Codebase {
             require(signatureFiles.isNotEmpty()) { "files must not be empty" }
-            val api =
-                TextCodebase(
-                    location = signatureFiles[0].file,
-                    annotationManager = annotationManager,
-                    classResolver = classResolver,
-                )
             val actualDescription =
                 description
                     ?: buildString {
                         append("Codebase loaded from ")
                         signatureFiles.joinTo(this)
                     }
-            val parser = ApiFile(api, formatForLegacyFiles)
+            val assembler =
+                TextCodebaseAssembler.createAssembler(
+                    location = signatureFiles[0].file,
+                    description = actualDescription,
+                    annotationManager = annotationManager,
+                    classResolver = classResolver,
+                )
+            val parser = ApiFile(assembler, formatForLegacyFiles)
             var first = true
             for (signatureFile in signatureFiles) {
                 val file = signatureFile.file
@@ -204,12 +228,10 @@ private constructor(
                 )
                 first = false
             }
-            api.description = actualDescription
-            parser.postProcess()
 
             apiStatsConsumer(parser.stats)
 
-            return api
+            return assembler.codebase
         }
 
         /** <p>DO NOT MODIFY - used by com/android/gts/api/ApprovedApis.java */
@@ -250,22 +272,22 @@ private constructor(
             formatForLegacyFiles: FileFormat? = null,
         ): Codebase {
             val path = Path.of(filename)
-            val api =
-                TextCodebase(
+            val assembler =
+                TextCodebaseAssembler.createAssembler(
                     location = path.toFile(),
+                    description = "Codebase loaded from $filename",
                     annotationManager = noOpAnnotationManager,
                     classResolver = classResolver,
                 )
-            api.description = "Codebase loaded from $filename"
-            val parser = ApiFile(api, formatForLegacyFiles)
+            val parser = ApiFile(assembler, formatForLegacyFiles)
             parser.parseApiSingleFile(
                 appending = false,
                 path = path,
                 apiText = apiText,
                 forCurrentApiSurface = true,
             )
-            parser.postProcess()
-            return api
+
+            return assembler.codebase
         }
 
         /**
@@ -349,13 +371,6 @@ private constructor(
         }
     }
 
-    /**
-     * Perform any final steps to initialize the [TextCodebase] after parsing the signature files.
-     */
-    private fun postProcess() {
-        codebase.resolveSuperTypes()
-    }
-
     private fun parseApiSingleFile(
         appending: Boolean,
         path: Path,
@@ -405,35 +420,26 @@ private constructor(
 
         // Metalava: including annotations in file now
         val annotations = getAnnotations(tokenizer, token)
-        val modifiers = createModifiers(DefaultModifierList.PUBLIC, annotations)
+        val modifiers = createModifiers(VisibilityLevel.PUBLIC, annotations)
         token = tokenizer.current
         tokenizer.assertIdent(token)
         val name: String = token
 
-        // If the same package showed up multiple times, make sure they have the same modifiers.
-        // (Packages can't have public/private/etc., but they can have annotations, which are part
-        // of ModifierList.)
-        val existing = codebase.findPackage(name)
+        // Wrap the modifiers and file location in a PackageDocs so that findOrCreatePackage(...)
+        // will create a package with them and will check to make sure that an existing package, if
+        // any, has matching modifiers.
+        val packageDoc =
+            MutablePackageDoc(
+                name,
+                fileLocation = tokenizer.fileLocation(),
+                modifiers = modifiers,
+            )
+        val packageDocs = PackageDocs(mapOf(name to packageDoc))
         val pkg =
-            if (existing != null) {
-                if (modifiers != existing.modifiers) {
-                    throw ApiParseException(
-                        String.format(
-                            "Contradicting declaration of package %s. Previously seen with modifiers \"%s\", but now with \"%s\"",
-                            name,
-                            existing.modifiers,
-                            modifiers
-                        ),
-                        tokenizer
-                    )
-                }
-                existing
-            } else {
-                val newPackageItem =
-                    TextPackageItem(codebase, name, modifiers, tokenizer.fileLocation())
-                newPackageItem.markForCurrentApiSurface()
-                codebase.addPackage(newPackageItem)
-                newPackageItem
+            try {
+                codebase.findOrCreatePackage(name, packageDocs)
+            } catch (e: IllegalStateException) {
+                throw ApiParseException(e.message!!, tokenizer)
             }
 
         token = tokenizer.requireToken()
@@ -450,7 +456,7 @@ private constructor(
         }
     }
 
-    private fun parseClass(pkg: TextPackageItem, tokenizer: Tokenizer, startingToken: String) {
+    private fun parseClass(pkg: DefaultPackageItem, tokenizer: Tokenizer, startingToken: String) {
         var token = startingToken
         var classKind = ClassKind.CLASS
         var superClassType: ClassTypeItem? = null
@@ -498,7 +504,6 @@ private constructor(
 
         // Extract lots of information from the declared class type.
         val (
-            className,
             fullName,
             qualifiedClassName,
             outerClass,
@@ -566,7 +571,7 @@ private constructor(
                 qualifiedName = qualifiedClassName,
                 fullName = fullName,
                 classKind = classKind,
-                modifiers = modifiers,
+                modifiers = modifiers.toImmutable(),
                 superClassType = superClassType,
             )
 
@@ -576,47 +581,40 @@ private constructor(
             return
         }
 
-        // Create the TextClassItem and set its package but do not add it to the package or
+        // Default the superClassType() to java.lang.Object for any class that is not an interface,
+        // annotation, or enum and which is not itself java.lang.Object.
+        if (
+            classKind == ClassKind.CLASS &&
+                superClassType == null &&
+                qualifiedClassName != JAVA_LANG_OBJECT
+        ) {
+            superClassType = globalTypeItemFactory.superObjectType
+        }
+
+        // Create the DefaultClassItem and set its package but do not add it to the package or
         // register it.
         val cl =
-            TextClassItem(
-                codebase = codebase,
+            itemFactory.createClassItem(
                 fileLocation = classPosition,
                 modifiers = modifiers,
                 classKind = classKind,
+                containingClass = outerClass,
+                containingPackage = pkg,
                 qualifiedName = qualifiedClassName,
-                simpleName = className,
-                fullName = fullName,
                 typeParameterList = typeParameterList,
+                // All signature files have to be explicitly specified.
+                origin = ClassOrigin.COMMAND_LINE,
+                superClassType = superClassType,
+                interfaceTypes = interfaceTypes.toList(),
             )
         cl.markForCurrentApiSurface()
 
-        // Default the superClassType() to java.lang.Object for any class that is not an interface,
-        // annotation, or enum and which is not itself java.lang.Object.
-        if (classKind == ClassKind.CLASS && superClassType == null && !cl.isJavaLangObject()) {
-            superClassType = globalTypeItemFactory.superObjectType
-        }
-        cl.setSuperClassType(superClassType)
-
-        cl.setInterfaceTypes(interfaceTypes.toList())
-
         // Store the [TypeItemFactory] for this [ClassItem] so it can be retrieved later in
         // [typeItemFactoryForClass].
         if (!typeItemFactory.typeParameterScope.isEmpty()) {
             classToTypeItemFactory[cl] = typeItemFactory
         }
 
-        cl.setContainingPackage(pkg)
-        cl.containingClass = outerClass
-        if (outerClass == null) {
-            // Add the class to the package, it will only be added to the TextCodebase once the
-            // package body has been parsed.
-            pkg.addClass(cl)
-        } else {
-            outerClass.addInnerClass(cl)
-        }
-        codebase.registerClass(cl)
-
         // Parse the class body adding each member created to the class item being populated.
         parseClassBody(tokenizer, cl, typeItemFactory)
     }
@@ -652,8 +650,10 @@ private constructor(
         // Add new annotations to the existing class
         val newClassAnnotations = newClassCharacteristics.modifiers.annotations().toSet()
         val existingClassAnnotations = existingCharacteristics.modifiers.annotations().toSet()
-        for (annotation in newClassAnnotations.subtract(existingClassAnnotations)) {
-            existingClass.addAnnotation(annotation)
+
+        val extraAnnotations = newClassAnnotations.subtract(existingClassAnnotations)
+        if (extraAnnotations.isNotEmpty()) {
+            existingClass.mutateModifiers { mutateAnnotations { addAll(extraAnnotations) } }
         }
 
         // Use the latest super class.
@@ -683,7 +683,7 @@ private constructor(
     /** Parse the class body, adding members to [cl]. */
     private fun parseClassBody(
         tokenizer: Tokenizer,
-        cl: TextClassItem,
+        cl: DefaultClassItem,
         classTypeItemFactory: TextTypeItemFactory,
     ) {
         var token = tokenizer.requireToken()
@@ -744,14 +744,12 @@ private constructor(
 
     /** Encapsulates multiple return values from [parseDeclaredClassType]. */
     private data class DeclaredClassTypeComponents(
-        /** The simple name of the class, i.e. not including any outer class prefix. */
-        val simpleName: String,
         /** The full name of the class, including outer class prefix. */
         val fullName: String,
         /** The fully qualified name, including package and full name. */
         val qualifiedName: String,
         /** The optional, resolved outer [ClassItem]. */
-        val outerClass: ClassItem?,
+        val outerClass: DefaultClassItem?,
         /** The set of type parameters. */
         val typeParameterList: TypeParameterList,
         /**
@@ -771,7 +769,7 @@ private constructor(
      * If the qualified name matches an existing class then return its information.
      */
     private fun parseDeclaredClassType(
-        pkg: TextPackageItem,
+        pkg: DefaultPackageItem,
         declaredClassType: String,
         classFileLocation: FileLocation,
     ): DeclaredClassTypeComponents {
@@ -786,25 +784,24 @@ private constructor(
                     declaredClassType.substring(paramIndex)
                 )
             }
-        val pkgName = pkg.name()
+        val pkgName = pkg.qualifiedName()
         val qualifiedName = qualifiedName(pkgName, fullName)
 
         // Split the full name into an optional outer class and a simple name.
         val nestedClassIndex = fullName.lastIndexOf('.')
-        val (outerClass, simpleName) =
+        val outerClass =
             if (nestedClassIndex == -1) {
-                Pair(null, fullName)
+                null
             } else {
                 val outerClassFullName = fullName.substring(0, nestedClassIndex)
                 val qualifiedOuterClassName = qualifiedName(pkgName, outerClassFullName)
 
                 // Search for the outer class in the codebase. This is safe as the outer class
                 // always precedes its nested classes.
-                val outerClass =
-                    codebase.getOrCreateClass(qualifiedOuterClassName, isOuterClass = true)
-
-                val innerClassName = fullName.substring(nestedClassIndex + 1)
-                Pair(outerClass, innerClassName)
+                assembler.getOrCreateClass(
+                    qualifiedOuterClassName,
+                    isOuterClassOfClassInThisCodebase = true
+                ) as DefaultClassItem
             }
 
         // Get the [TextTypeItemFactory] for the outer class, if any, from a previously stored one,
@@ -815,7 +812,7 @@ private constructor(
         // Create type parameter list and factory from the string and optional outer class factory.
         val (typeParameterList, typeItemFactory) =
             if (typeParameterListString == "")
-                Pair(TypeParameterList.NONE, outerClassTypeItemFactory)
+                TypeParameterListAndFactory(TypeParameterList.NONE, outerClassTypeItemFactory)
             else
                 createTypeParameterList(
                     outerClassTypeItemFactory,
@@ -850,7 +847,6 @@ private constructor(
                 ?: Pair(typeParameterList, typeItemFactory)
 
         return DeclaredClassTypeComponents(
-            simpleName = simpleName,
             fullName = fullName,
             qualifiedName = qualifiedName,
             outerClass = outerClass,
@@ -922,32 +918,46 @@ private constructor(
 
     /**
      * Collects all the sequential annotations from the [tokenizer] beginning with [startingToken],
-     * returning them as a (possibly empty) mutable list.
+     * returning them as a (possibly empty) list.
      *
      * When the method returns, the [tokenizer] will point to the token after the annotation list.
      */
-    private fun getAnnotations(
-        tokenizer: Tokenizer,
-        startingToken: String
-    ): MutableList<AnnotationItem> {
-        val annotations: MutableList<AnnotationItem> = mutableListOf()
+    private fun getAnnotations(tokenizer: Tokenizer, startingToken: String) = buildList {
         var token = startingToken
         while (true) {
             val annotationSource = getAnnotationSource(tokenizer, token) ?: break
             token = tokenizer.current
-            annotations.add(DefaultAnnotationItem.create(codebase, annotationSource))
+            DefaultAnnotationItem.create(codebase, annotationSource)?.let { annotationItem ->
+                add(annotationItem)
+            }
         }
-        return annotations
+    }
+
+    /**
+     * Create [ParameterItem]s for the [containingCallable] from the [parameters] using the
+     * [typeItemFactory] to create types.
+     *
+     * This is called from within the constructor of the [containingCallable] so must only access
+     * its `name` and its reference. In particularly it must not access its
+     * [CallableItem.parameters] property as this is called during its initialization.
+     */
+    private fun createParameterItems(
+        containingCallable: CallableItem,
+        parameters: List<ParameterInfo>,
+        typeItemFactory: TextTypeItemFactory
+    ): List<ParameterItem> {
+        val methodFingerprint = MethodFingerprint(containingCallable.name(), parameters.size)
+        return parameters.map { it.create(containingCallable, typeItemFactory, methodFingerprint) }
     }
 
     private fun parseConstructor(
         tokenizer: Tokenizer,
-        containingClass: TextClassItem,
+        containingClass: DefaultClassItem,
         classTypeItemFactory: TextTypeItemFactory,
         startingToken: String
     ) {
         var token = startingToken
-        val method: TextConstructorItem
+        val method: ConstructorItem
 
         // Metalava: including annotations in file now
         val annotations = getAnnotations(tokenizer, token)
@@ -962,15 +972,15 @@ private constructor(
                     token = tokenizer.requireToken()
                 }
             } else {
-                Pair(TypeParameterList.NONE, classTypeItemFactory)
+                TypeParameterListAndFactory(TypeParameterList.NONE, classTypeItemFactory)
             }
 
         tokenizer.assertIdent(token)
         val name: String =
             token.substring(
                 token.lastIndexOf('.') + 1
-            ) // For inner classes, strip outer classes from name
-        val parameters = parseParameterList(tokenizer, typeItemFactory, name)
+            ) // For nested classes, strip outer classes from name
+        val parameters = parseParameterList(tokenizer)
         token = tokenizer.requireToken()
         var throwsList = emptyList<ExceptionTypeItem>()
         if ("throws" == token) {
@@ -982,49 +992,38 @@ private constructor(
         }
 
         method =
-            TextConstructorItem(
-                codebase,
-                name,
-                containingClass,
-                modifiers,
-                containingClass.type(),
-                parameters,
-                tokenizer.fileLocation()
+            itemFactory.createConstructorItem(
+                fileLocation = tokenizer.fileLocation(),
+                modifiers = modifiers,
+                documentationFactory = ItemDocumentation.NONE_FACTORY,
+                name = name,
+                containingClass = containingClass,
+                typeParameterList = typeParameterList,
+                returnType = containingClass.type(),
+                parameterItemsFactory = { methodItem ->
+                    createParameterItems(methodItem, parameters, typeItemFactory)
+                },
+                throwsTypes = throwsList,
+                // Signature files do not track implicit constructors, all constructors are treated
+                // the same as whether it was created by the compiler or in the source has no effect
+                // on the API surface.
+                implicitConstructor = false,
             )
         method.markForCurrentApiSurface()
-        method.typeParameterList = typeParameterList
-        method.setThrowsTypes(throwsList)
 
         if (!containingClass.constructors().contains(method)) {
             containingClass.addConstructor(method)
         }
     }
 
-    /**
-     * Check whether the method is a synthetic enum method.
-     *
-     * i.e. `getEntries()` from Kotlin and `values()` and `valueOf(String)` from both Java and
-     * Kotlin.
-     */
-    private fun isEnumSyntheticMethod(
-        containingClass: ClassItem,
-        name: String,
-        parameters: List<ParameterItem>
-    ): Boolean {
-        if (!containingClass.isEnum()) return false
-        val parameterCount = parameters.size
-        return (parameterCount == 0 && (name == "values" || name == "getEntries")) ||
-            (parameterCount == 1 && name == "valueOf" && parameters[0].type().isString())
-    }
-
     private fun parseMethod(
         tokenizer: Tokenizer,
-        cl: TextClassItem,
+        cl: DefaultClassItem,
         classTypeItemFactory: TextTypeItemFactory,
         startingToken: String
     ) {
         var token = startingToken
-        val method: TextMethodItem
+        val method: MethodItem
 
         // Metalava: including annotations in file now
         val annotations = getAnnotations(tokenizer, token)
@@ -1039,18 +1038,18 @@ private constructor(
                     token = tokenizer.requireToken()
                 }
             } else {
-                Pair(TypeParameterList.NONE, classTypeItemFactory)
+                TypeParameterListAndFactory(TypeParameterList.NONE, classTypeItemFactory)
             }
 
         tokenizer.assertIdent(token)
 
         val returnTypeString: String
-        val parameters: List<TextParameterItem>
+        val parameters: List<ParameterInfo>
         val name: String
         if (format.kotlinNameTypeOrder) {
             // Kotlin style: parse the name, the parameter list, then the return type.
             name = token
-            parameters = parseParameterList(tokenizer, typeItemFactory, name)
+            parameters = parseParameterList(tokenizer)
             token = tokenizer.requireToken()
             if (token != ":") {
                 throw ApiParseException(
@@ -1068,7 +1067,7 @@ private constructor(
             token = tokenizer.current
             tokenizer.assertIdent(token)
             name = token
-            parameters = parseParameterList(tokenizer, typeItemFactory, name)
+            parameters = parseParameterList(tokenizer)
             token = tokenizer.requireToken()
         }
 
@@ -1102,32 +1101,37 @@ private constructor(
             throw ApiParseException("expected ; found $token", tokenizer)
         }
 
-        // Ignore enum synthetic methods.
-        if (isEnumSyntheticMethod(cl, name, parameters)) return
-
         method =
-            TextMethodItem(
-                codebase,
-                name,
-                cl,
-                modifiers,
-                returnType,
-                parameters,
-                tokenizer.fileLocation()
+            itemFactory.createMethodItem(
+                fileLocation = tokenizer.fileLocation(),
+                modifiers = modifiers,
+                documentationFactory = ItemDocumentation.NONE_FACTORY,
+                name = name,
+                containingClass = cl,
+                typeParameterList = typeParameterList,
+                returnType = returnType,
+                parameterItemsFactory = { containingCallable ->
+                    createParameterItems(containingCallable, parameters, typeItemFactory)
+                },
+                throwsTypes = throwsList,
+                annotationDefault = defaultAnnotationMethodValue,
             )
+
+        // Ignore enum synthetic methods. They are no longer included in signature files as they add
+        // no information. However, they did use to be included and so this filters them out to
+        // ensure that the resulting Codebase is consistent with the original source Codebase.
+        if (method.isEnumSyntheticMethod()) return
+
         method.markForCurrentApiSurface()
-        method.typeParameterList = typeParameterList
-        method.setThrowsTypes(throwsList)
-        method.setAnnotationDefault(defaultAnnotationMethodValue)
 
-        if (!cl.methods().contains(method)) {
-            cl.addMethod(method)
-        }
+        // If the method already exists in the class item because it was defined in a previous
+        // signature file then replace it with this one, otherwise just add this method.
+        cl.replaceOrAddMethod(method)
     }
 
     private fun parseField(
         tokenizer: Tokenizer,
-        cl: TextClassItem,
+        cl: DefaultClassItem,
         classTypeItemFactory: TextTypeItemFactory,
         startingToken: String,
         isEnumConstant: Boolean,
@@ -1176,28 +1180,34 @@ private constructor(
         synchronizeNullability(type, modifiers)
 
         // Parse the value string.
-        val value = valueString?.let { parseValue(type, valueString, tokenizer) }
+        val fieldValue =
+            valueString?.let { FixedFieldValue(parseValue(type, valueString, tokenizer)) }
 
         if (";" != token) {
             throw ApiParseException("expected ; found $token", tokenizer)
         }
         val field =
-            TextFieldItem(codebase, name, cl, modifiers, type, value, tokenizer.fileLocation())
+            itemFactory.createFieldItem(
+                fileLocation = tokenizer.fileLocation(),
+                modifiers = modifiers,
+                documentationFactory = ItemDocumentation.NONE_FACTORY,
+                name = name,
+                containingClass = cl,
+                type = type,
+                isEnumConstant = isEnumConstant,
+                fieldValue = fieldValue,
+            )
         field.markForCurrentApiSurface()
-        if (isEnumConstant) {
-            cl.addEnumConstant(field)
-        } else {
-            cl.addField(field)
-        }
+        cl.addField(field)
     }
 
     private fun parseModifiers(
         tokenizer: Tokenizer,
         startingToken: String?,
-        annotations: MutableList<AnnotationItem>
-    ): DefaultModifierList {
+        annotations: List<AnnotationItem>
+    ): MutableModifierList {
         var token = startingToken
-        val modifiers = createModifiers(DefaultModifierList.PACKAGE_PRIVATE, annotations)
+        val modifiers = createModifiers(VisibilityLevel.PACKAGE_PRIVATE, annotations)
 
         processModifiers@ while (true) {
             token =
@@ -1300,12 +1310,12 @@ private constructor(
         return modifiers
     }
 
-    /** Creates a [DefaultModifierList], setting the deprecation based on the [annotations]. */
+    /** Creates a [MutableModifierList], setting the deprecation based on the [annotations]. */
     private fun createModifiers(
-        visibility: Int,
-        annotations: MutableList<AnnotationItem>
-    ): DefaultModifierList {
-        val modifiers = DefaultModifierList(codebase, visibility, annotations)
+        visibility: VisibilityLevel,
+        annotations: List<AnnotationItem>
+    ): MutableModifierList {
+        val modifiers = createMutableModifiers(visibility, annotations)
         // @Deprecated is also treated as a "modifier"
         if (annotations.any { it.qualifiedName == JAVA_LANG_DEPRECATED }) {
             modifiers.setDeprecated(true)
@@ -1376,7 +1386,7 @@ private constructor(
 
     private fun parseProperty(
         tokenizer: Tokenizer,
-        cl: TextClassItem,
+        cl: DefaultClassItem,
         classTypeItemFactory: TextTypeItemFactory,
         startingToken: String
     ) {
@@ -1413,7 +1423,13 @@ private constructor(
             throw ApiParseException("expected ; found $token", tokenizer)
         }
         val property =
-            TextPropertyItem(codebase, name, cl, modifiers, type, tokenizer.fileLocation())
+            itemFactory.createPropertyItem(
+                fileLocation = tokenizer.fileLocation(),
+                modifiers = modifiers,
+                name = name,
+                containingClass = cl,
+                type = type,
+            )
         property.markForCurrentApiSurface()
         cl.addProperty(property)
     }
@@ -1421,7 +1437,7 @@ private constructor(
     private fun parseTypeParameterList(
         tokenizer: Tokenizer,
         enclosingTypeItemFactory: TextTypeItemFactory,
-    ): Pair<TypeParameterList, TextTypeItemFactory> {
+    ): TypeParameterListAndFactory<TextTypeItemFactory> {
         var token: String
         val start = tokenizer.offset() - 1
         var balance = 1
@@ -1435,7 +1451,7 @@ private constructor(
         }
         val typeParameterListString = tokenizer.getStringFromOffset(start)
         return if (typeParameterListString.isEmpty()) {
-            Pair(TypeParameterList.NONE, enclosingTypeItemFactory)
+            TypeParameterListAndFactory(TypeParameterList.NONE, enclosingTypeItemFactory)
         } else {
             // Use the file location as a part of the description of the scope as at this point
             // there is no other information available.
@@ -1461,7 +1477,7 @@ private constructor(
         enclosingTypeItemFactory: TextTypeItemFactory,
         scopeDescription: String,
         typeParameterListString: String
-    ): Pair<TypeParameterList, TextTypeItemFactory> {
+    ): TypeParameterListAndFactory<TextTypeItemFactory> {
         // Split the type parameter list string into a list of strings, one for each type
         // parameter.
         val typeParameterStrings = TextTypeParser.typeParameterStrings(typeParameterListString)
@@ -1469,23 +1485,56 @@ private constructor(
         // Create the List<TypeParameterItem> and the corresponding TypeItemFactory that can be
         // used to resolve TypeParameterItems from the list. This performs the construction in two
         // stages to handle cycles between the parameters.
-        val (typeParameters, typeItemFactory) =
-            DefaultTypeParameterList.createTypeParameterItemsAndFactory(
-                enclosingTypeItemFactory,
-                scopeDescription,
-                typeParameterStrings,
-                // Create a `TextTypeParameterItem` from the type parameter string.
-                { TextTypeParameterItem.create(codebase, it) },
-                // Create, set and return the [BoundsTypeItem] list.
-                { typeItemFactory, item, typeParameterString ->
-                    val boundsStringList = extractTypeParameterBoundsStringList(typeParameterString)
-                    boundsStringList
-                        .map { typeItemFactory.getBoundsType(it) }
-                        .also { item.bounds = it }
-                },
-            )
+        return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+            enclosingTypeItemFactory,
+            scopeDescription,
+            typeParameterStrings,
+            // Create a `TextTypeParameterItem` from the type parameter string.
+            { createTypeParameterItem(it) },
+            // Create, set and return the [BoundsTypeItem] list.
+            { typeItemFactory, typeParameterString ->
+                val boundsStringList = extractTypeParameterBoundsStringList(typeParameterString)
+                boundsStringList.map { typeItemFactory.getBoundsType(it) }
+            },
+        )
+    }
+
+    /**
+     * Create a partially initialized [DefaultTypeParameterItem].
+     *
+     * This extracts the [TypeParameterItem.isReified] and [TypeParameterItem.name] from the
+     * [typeParameterString] and creates a [DefaultTypeParameterItem] with those properties
+     * initialized but the [DefaultTypeParameterItem.bounds] is not.
+     */
+    private fun createTypeParameterItem(typeParameterString: String): DefaultTypeParameterItem {
+        val length = typeParameterString.length
+        var nameEnd = length
+
+        val isReified = typeParameterString.startsWith("reified ")
+        val nameStart =
+            if (isReified) {
+                8 // "reified ".length
+            } else {
+                0
+            }
 
-        return Pair(DefaultTypeParameterList(typeParameters), typeItemFactory)
+        for (i in nameStart until length) {
+            val c = typeParameterString[i]
+            if (!Character.isJavaIdentifierPart(c)) {
+                nameEnd = i
+                break
+            }
+        }
+        val name = typeParameterString.substring(nameStart, nameEnd)
+
+        // TODO: Type use annotations support will need to handle annotations on the parameter.
+        val modifiers = createImmutableModifiers(VisibilityLevel.PUBLIC)
+
+        return itemFactory.createTypeParameterItem(
+            modifiers = modifiers,
+            name = name,
+            isReified = isReified,
+        )
     }
 
     /**
@@ -1497,9 +1546,7 @@ private constructor(
      */
     private fun parseParameterList(
         tokenizer: Tokenizer,
-        typeItemFactory: TextTypeItemFactory,
-        methodName: String,
-    ): List<TextParameterItem> {
+    ): List<ParameterInfo> {
         val parameters = mutableListOf<ParameterInfo>()
         var token: String = tokenizer.requireToken()
         if ("(" != token) {
@@ -1509,9 +1556,8 @@ private constructor(
         var index = 0
         while (true) {
             if (")" == token) {
-                // All parameters are parsed, create the actual TextParameterItems
-                val methodFingerprint = MethodFingerprint(methodName, parameters.size)
-                return parameters.map { it.create(codebase, typeItemFactory, methodFingerprint) }
+                // All parameters are parsed, return them.
+                return parameters
             }
 
             // Each item can be
@@ -1520,8 +1566,8 @@ private constructor(
 
             // Used to represent the presence of a default value, instead of showing the entire
             // default value
-            var hasDefaultValue = token == "optional"
-            if (hasDefaultValue) {
+            val hasOptionalKeyword = token == "optional"
+            if (hasOptionalKeyword) {
                 token = tokenizer.requireToken()
             }
 
@@ -1562,11 +1608,17 @@ private constructor(
                 }
             }
 
-            var defaultValue = UNKNOWN_DEFAULT_VALUE
+            var defaultValueString: String? = null
             if ("=" == token) {
-                defaultValue = tokenizer.requireToken(true)
-                val sb = StringBuilder(defaultValue)
-                if (defaultValue == "{") {
+                if (hasOptionalKeyword) {
+                    throw ApiParseException(
+                        "cannot have both optional keyword and default value",
+                        tokenizer
+                    )
+                }
+                defaultValueString = tokenizer.requireToken(true)
+                val sb = StringBuilder(defaultValueString)
+                if (defaultValueString == "{") {
                     var balance = 1
                     while (balance > 0) {
                         token = tokenizer.requireToken(parenIsSep = false, eatWhitespace = false)
@@ -1582,7 +1634,7 @@ private constructor(
                     }
                     token = tokenizer.requireToken()
                 } else {
-                    var balance = if (defaultValue == "(") 1 else 0
+                    var balance = if (defaultValueString == "(") 1 else 0
                     while (true) {
                         token = tokenizer.requireToken(parenIsSep = true, eatWhitespace = false)
                         if ((token.endsWith(",") || token.endsWith(")")) && balance <= 0) {
@@ -1600,10 +1652,7 @@ private constructor(
                         }
                     }
                 }
-                defaultValue = sb.toString()
-            }
-            if (defaultValue != UNKNOWN_DEFAULT_VALUE) {
-                hasDefaultValue = true
+                defaultValueString = sb.toString()
             }
             when (token) {
                 "," -> {
@@ -1616,11 +1665,25 @@ private constructor(
                     throw ApiParseException("expected , or ), found $token", tokenizer)
                 }
             }
+
+            // Select the DefaultValue for the parameter.
+            val defaultValue =
+                when {
+                    hasOptionalKeyword ->
+                        // It has an optional keyword, so it has a default value but the actual
+                        // value is not known.
+                        DefaultValue.UNKNOWN
+                    defaultValueString == null ->
+                        // It has neither an optional keyword nor an actual default value.
+                        DefaultValue.NONE
+                    else ->
+                        // It has an actual default value.
+                        DefaultValue.fixedDefaultValue(defaultValueString)
+                }
             parameters.add(
                 ParameterInfo(
                     name,
                     publicName,
-                    hasDefaultValue,
                     defaultValue,
                     typeString,
                     modifiers,
@@ -1634,26 +1697,25 @@ private constructor(
 
     /**
      * Container for parsed information on a parameter. This is an intermediate step before a
-     * [TextParameterItem] is created, which is needed because
+     * [ParameterItem] is created, which is needed because
      * [TextTypeItemFactory.getMethodParameterType] requires a [MethodFingerprint] with the total
      * number of method parameters.
      */
     private inner class ParameterInfo(
         val name: String,
         val publicName: String?,
-        val hasDefaultValue: Boolean,
-        val defaultValue: String?,
+        val defaultValue: DefaultValue,
         val typeString: String,
-        val modifiers: DefaultModifierList,
+        val modifiers: MutableModifierList,
         val location: FileLocation,
         val index: Int
     ) {
-        /** Turn this [ParameterInfo] into a [TextParameterItem] by parsing the [typeString]. */
+        /** Turn this [ParameterInfo] into a [ParameterItem] by parsing the [typeString]. */
         fun create(
-            codebase: TextCodebase,
+            containingCallable: CallableItem,
             typeItemFactory: TextTypeItemFactory,
             methodFingerprint: MethodFingerprint
-        ): TextParameterItem {
+        ): ParameterItem {
             val type =
                 typeItemFactory.getMethodParameterType(
                     typeString,
@@ -1665,22 +1727,18 @@ private constructor(
             synchronizeNullability(type, modifiers)
 
             val parameter =
-                TextParameterItem(
-                    codebase,
-                    name,
-                    publicName,
-                    hasDefaultValue,
-                    defaultValue,
-                    index,
-                    type,
-                    modifiers,
-                    location
+                itemFactory.createParameterItem(
+                    fileLocation = location,
+                    modifiers = modifiers,
+                    name = name,
+                    publicNameProvider = { publicName },
+                    containingCallable = containingCallable,
+                    parameterIndex = index,
+                    type = type,
+                    defaultValueFactory = { defaultValue },
                 )
 
             parameter.markForCurrentApiSurface()
-            if (type is ArrayTypeItem && type.isVarargs) {
-                modifiers.setVarArg(true)
-            }
 
             return parameter
         }
@@ -1773,7 +1831,7 @@ private constructor(
      * @param typeItem the type of the API item.
      * @param modifiers the API item's modifiers.
      */
-    private fun synchronizeNullability(typeItem: TypeItem, modifiers: DefaultModifierList) {
+    private fun synchronizeNullability(typeItem: TypeItem, modifiers: MutableModifierList) {
         if (typeParser.kotlinStyleNulls) {
             // Add an annotation to the context item for the type's nullability if applicable.
             val annotationToAdd =
@@ -1781,7 +1839,7 @@ private constructor(
                 if (typeItem is ArrayTypeItem && typeItem.isVarargs) {
                     ANDROIDX_NONNULL
                 } else {
-                    val nullability = typeItem.modifiers.nullability()
+                    val nullability = typeItem.modifiers.nullability
                     if (typeItem !is PrimitiveTypeItem && nullability == TypeNullability.NONNULL) {
                         ANDROIDX_NONNULL
                     } else if (nullability == TypeNullability.NULLABLE) {
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt
index 31f07e5d8..c15ceb20c 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model.text
 
+import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.ModifierList
@@ -53,12 +54,13 @@ internal data class ClassCharacteristics(
 // TODO(b/323168612): Add interface type strings.
 ) {
     /**
-     * Checks if the [cls] from different signature file can be merged with this [TextClassItem].
-     * For instance, `current.txt` and `system-current.txt` may contain equal class definitions with
-     * different class methods. This method is used to determine if the two [TextClassItem]s can be
-     * safely merged in such scenarios.
+     * Checks if the [other] from different signature file can be merged with this
+     * [ClassCharacteristics]. For instance, `current.txt` and `system-current.txt` may contain
+     * equal class definitions with different class methods. This method is used to determine if the
+     * two [ClassItem]s can be safely merged in such scenarios.
      *
-     * @param cls [TextClassItem] to be checked if it is compatible with [this] and can be merged
+     * @param other [ClassCharacteristics] to be checked if it is compatible with [this] and can be
+     *   merged
      * @return a Boolean value representing if [cls] is compatible with [this]
      */
     fun isCompatible(other: ClassCharacteristics): Boolean {
@@ -66,14 +68,14 @@ internal data class ClassCharacteristics(
         // TextClassItem
         return fullName == other.fullName &&
             classKind == other.classKind &&
-            modifiers.equivalentTo(other.modifiers)
+            modifiers.equivalentTo(null, other.modifiers)
     }
 
     companion object {
-        fun of(classItem: TextClassItem): ClassCharacteristics =
+        fun of(classItem: ClassItem): ClassCharacteristics =
             ClassCharacteristics(
                 fileLocation = classItem.fileLocation,
-                qualifiedName = classItem.qualifiedName,
+                qualifiedName = classItem.qualifiedName(),
                 fullName = classItem.fullName(),
                 classKind = classItem.classKind,
                 modifiers = classItem.modifiers,
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
index 582b3e0db..18bccfe0c 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.model.text
 
-import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.reporter.FileLocation
 import java.io.LineNumberReader
 import java.io.Reader
@@ -304,12 +304,12 @@ data class FileFormat(
         }
     }
 
-    enum class OverloadedMethodOrder(val comparator: Comparator<MethodItem>) {
+    enum class OverloadedMethodOrder(val comparator: Comparator<CallableItem>) {
         /** Sort overloaded methods according to source order. */
-        SOURCE(MethodItem.sourceOrderForOverloadedMethodsComparator),
+        SOURCE(CallableItem.sourceOrderForOverloadedMethodsComparator),
 
         /** Sort overloaded methods by their signature. */
-        SIGNATURE(MethodItem.comparator)
+        SIGNATURE(CallableItem.comparator)
     }
 
     /**
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubClassBuilder.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubClassBuilder.kt
index be38eca9c..c819c2915 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubClassBuilder.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubClassBuilder.kt
@@ -16,56 +16,71 @@
 
 package com.android.tools.metalava.model.text
 
+import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.bestGuessAtFullName
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.reporter.FileLocation
 
 /**
- * A builder for stub classes, i.e. [TextClassItem]s fabricated because [ApiFile] has no definition
- * of the class but a [TextClassItem] is still needed.
+ * A builder for stub classes, i.e. [DefaultClassItem]s fabricated because [ApiFile] has no
+ * definition of the class but a [DefaultClassItem] is still needed.
  */
 internal class StubClassBuilder(
-    val codebase: TextCodebase,
-    val qualifiedName: String,
+    internal val assembler: TextCodebaseAssembler,
+    internal val qualifiedName: String,
+    private val containingClass: ClassItem?,
+    val containingPackage: PackageItem,
 ) {
-    /**
-     * The full name can be ambiguous in theory, but where the naming conventions for packages and
-     * classes are followed it is not. So, assuming that the conventions are followed then produce
-     * the best guess for the full name. This is not really that important as the full name only
-     * really affects the partial ordering of some classes, like in a `throws` list.
-     */
-    val fullName: String = bestGuessAtFullName(qualifiedName)
-
     /** The default [ClassKind] can be modified. */
     var classKind = ClassKind.CLASS
 
     /** The modifiers are set to `public` because otherwise there is no point in creating it. */
-    val modifiers = DefaultModifierList(codebase, DefaultModifierList.PUBLIC)
+    val modifiers = createImmutableModifiers(VisibilityLevel.PUBLIC)
 
     var superClassType: ClassTypeItem? = null
 
-    private fun build(): TextClassItem =
-        TextClassItem(
-                codebase = codebase,
-                qualifiedName = qualifiedName,
-                fullName = fullName,
-                classKind = classKind,
-                modifiers = modifiers,
-            )
-            .also { item -> item.setSuperClassType(superClassType) }
+    private fun build(): DefaultClassItem =
+        assembler.itemFactory.createClassItem(
+            fileLocation = FileLocation.UNKNOWN,
+            modifiers = modifiers,
+            classKind = classKind,
+            containingClass = containingClass,
+            containingPackage = containingPackage,
+            qualifiedName = qualifiedName,
+            typeParameterList = TypeParameterList.NONE,
+            // Always treat stubs as if they are from the class path. While that is not strictly
+            // true stubs classes should be treated as if they did come from there, i.e. they can be
+            // referenced but not emitted.
+            origin = ClassOrigin.CLASS_PATH,
+            superClassType = superClassType,
+            interfaceTypes = emptyList(),
+        )
 
     companion object {
         /**
-         * Create a [TextClassItem] in the specified [codebase] and with the specific
+         * Create a [DefaultClassItem] in the specified [codebase] and with the specific
          * [qualifiedName], after applying the specified mutator.
          */
         fun build(
-            codebase: TextCodebase,
+            assembler: TextCodebaseAssembler,
             qualifiedName: String,
-            mutator: StubClassBuilder.() -> Unit
-        ): TextClassItem {
-            val builder = StubClassBuilder(codebase, qualifiedName)
+            containingClass: ClassItem?,
+            containingPackage: PackageItem,
+            mutator: StubClassBuilder.() -> Unit,
+        ): DefaultClassItem {
+            val builder =
+                StubClassBuilder(
+                    assembler = assembler,
+                    qualifiedName = qualifiedName,
+                    containingClass = containingClass,
+                    containingPackage = containingPackage,
+                )
             builder.mutator()
             return builder.build()
         }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubKind.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubKind.kt
index 9b52e481c..3d9f91eae 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubKind.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/StubKind.kt
@@ -29,7 +29,7 @@ internal enum class StubKind(
     THROWABLE({
         // Throwables must extend `java.lang.Throwable`, unless they are `java.lang.Throwable`.
         if (qualifiedName != JAVA_LANG_THROWABLE) {
-            superClassType = codebase.resolveClass(JAVA_LANG_THROWABLE).type()
+            superClassType = assembler.codebase.resolveClass(JAVA_LANG_THROWABLE)!!.type()
         }
     }),
 }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextClassItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextClassItem.kt
deleted file mode 100644
index 90bcc7aab..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextClassItem.kt
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationRetention
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.ClassKind
-import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PropertyItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.type.DefaultResolvedClassTypeItem
-import com.android.tools.metalava.reporter.FileLocation
-import java.util.function.Predicate
-
-internal open class TextClassItem(
-    override val codebase: TextCodebase,
-    fileLocation: FileLocation = FileLocation.UNKNOWN,
-    modifiers: DefaultModifierList,
-    override val classKind: ClassKind = ClassKind.CLASS,
-    val qualifiedName: String = "",
-    var simpleName: String = qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1),
-    val fullName: String = simpleName,
-    override val typeParameterList: TypeParameterList = TypeParameterList.NONE
-) : TextItem(codebase = codebase, fileLocation = fileLocation, modifiers = modifiers), ClassItem {
-
-    override var artifact: String? = null
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (javaClass != other?.javaClass) return false
-
-        other as TextClassItem
-
-        return qualifiedName == other.qualifiedName()
-    }
-
-    override fun hashCode(): Int {
-        return qualifiedName.hashCode()
-    }
-
-    override fun interfaceTypes(): List<ClassTypeItem> = interfaceTypes
-
-    override fun allInterfaces(): Sequence<ClassItem> {
-        return sequenceOf(
-                // Add this if and only if it is an interface.
-                if (classKind == ClassKind.INTERFACE) sequenceOf(this) else emptySequence(),
-                interfaceTypes.asSequence().map { it.asClass() }.filterNotNull(),
-            )
-            .flatten()
-    }
-
-    private var innerClasses: MutableList<ClassItem> = mutableListOf()
-
-    override var stubConstructor: ConstructorItem? = null
-
-    override var hasPrivateConstructor: Boolean = false
-
-    override fun innerClasses(): List<ClassItem> = innerClasses
-
-    override fun hasImplicitDefaultConstructor(): Boolean {
-        return false
-    }
-
-    var containingClass: ClassItem? = null
-
-    override fun containingClass(): ClassItem? = containingClass
-
-    private var containingPackage: PackageItem? = null
-
-    fun setContainingPackage(containingPackage: TextPackageItem) {
-        this.containingPackage = containingPackage
-    }
-
-    override fun containingPackage(): PackageItem =
-        containingClass?.containingPackage() ?: containingPackage ?: error(this)
-
-    override fun hasTypeVariables(): Boolean = typeParameterList.isNotEmpty()
-
-    private var superClassType: ClassTypeItem? = null
-
-    override fun superClass(): ClassItem? = superClassType?.asClass()
-
-    override fun superClassType(): ClassTypeItem? = superClassType
-
-    internal fun setSuperClassType(superClassType: ClassTypeItem?) {
-        this.superClassType = superClassType
-    }
-
-    override fun setInterfaceTypes(interfaceTypes: List<ClassTypeItem>) {
-        this.interfaceTypes = interfaceTypes
-    }
-
-    /** Must only be used by [type] to cache its result. */
-    private lateinit var cachedType: ClassTypeItem
-
-    override fun type(): ClassTypeItem {
-        if (!::cachedType.isInitialized) {
-            cachedType = DefaultResolvedClassTypeItem.createForClass(this)
-        }
-        return cachedType
-    }
-
-    private var interfaceTypes = emptyList<ClassTypeItem>()
-    private val constructors = mutableListOf<ConstructorItem>()
-    private val methods = mutableListOf<MethodItem>()
-    private val fields = mutableListOf<FieldItem>()
-    private val properties = mutableListOf<PropertyItem>()
-
-    override fun constructors(): List<ConstructorItem> = constructors
-
-    override fun methods(): List<MethodItem> = methods
-
-    override fun fields(): List<FieldItem> = fields
-
-    override fun properties(): List<PropertyItem> = properties
-
-    fun addConstructor(constructor: TextConstructorItem) {
-        constructors += constructor
-    }
-
-    fun addMethod(method: TextMethodItem) {
-        methods += method
-    }
-
-    fun addField(field: TextFieldItem) {
-        fields += field
-    }
-
-    fun addProperty(property: TextPropertyItem) {
-        properties += property
-    }
-
-    fun addEnumConstant(field: TextFieldItem) {
-        field.setEnumConstant(true)
-        fields += field
-    }
-
-    override fun addInnerClass(cls: ClassItem) {
-        innerClasses.add(cls)
-    }
-
-    fun addAnnotation(annotation: AnnotationItem) {
-        modifiers.addAnnotation(annotation)
-    }
-
-    override fun filteredSuperClassType(predicate: Predicate<Item>): TypeItem? {
-        // No filtering in signature files: we assume signature APIs
-        // have already been filtered and all items should match.
-        // This lets us load signature files and rewrite them using updated
-        // output formats etc.
-        return superClassType
-    }
-
-    private var retention: AnnotationRetention? = null
-
-    override fun getRetention(): AnnotationRetention {
-        retention?.let {
-            return it
-        }
-
-        if (!isAnnotationType()) {
-            error("getRetention() should only be called on annotation classes")
-        }
-
-        retention = ClassItem.findRetention(this)
-        return retention!!
-    }
-
-    override fun simpleName(): String = simpleName
-
-    override fun fullName(): String = fullName
-
-    override fun qualifiedName(): String = qualifiedName
-
-    override fun createDefaultConstructor(): ConstructorItem {
-        return TextConstructorItem.createDefaultConstructor(codebase, this, fileLocation)
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebase.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebase.kt
deleted file mode 100644
index e30ddc5a9..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebase.kt
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationManager
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.ClassResolver
-import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultCodebase
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PackageList
-import com.android.tools.metalava.reporter.FileLocation
-import java.io.File
-import java.util.ArrayList
-import java.util.HashMap
-
-// Copy of ApiInfo in doclava1 (converted to Kotlin + some cleanup to make it work with metalava's
-// data structures.
-// (Converted to Kotlin such that I can inherit behavior via interfaces, in particular Codebase.)
-internal class TextCodebase(
-    location: File,
-    annotationManager: AnnotationManager,
-    private val classResolver: ClassResolver?,
-) : DefaultCodebase(location, "Codebase", true, annotationManager) {
-    private val packagesByName = HashMap<String, TextPackageItem>(300)
-    private val allClassesByName = HashMap<String, TextClassItem>(30000)
-
-    private val externalClassesByName = HashMap<String, ClassItem>()
-
-    override fun trustedApi(): Boolean = true
-
-    override fun getPackages(): PackageList {
-        val list = ArrayList<PackageItem>(packagesByName.values)
-        list.sortWith(PackageItem.comparator)
-        return PackageList(this, list)
-    }
-
-    override fun size(): Int {
-        return packagesByName.size
-    }
-
-    /** Find a class in this codebase, i.e. not classes loaded from the [classResolver]. */
-    fun findClassInCodebase(className: String) = allClassesByName[className]
-
-    override fun findClass(className: String) =
-        allClassesByName[className] ?: externalClassesByName[className]
-
-    override fun resolveClass(className: String) = getOrCreateClass(className)
-
-    override fun supportsDocumentation(): Boolean = false
-
-    fun addPackage(pInfo: TextPackageItem) {
-        // track the set of organized packages in the API
-        packagesByName[pInfo.name()] = pInfo
-
-        // accumulate a direct map of all the classes in the API
-        for (cl in pInfo.allClasses()) {
-            allClassesByName[cl.qualifiedName()] = cl as TextClassItem
-        }
-    }
-
-    fun registerClass(classItem: TextClassItem) {
-        val qualifiedName = classItem.qualifiedName
-        val existing = allClassesByName.put(qualifiedName, classItem)
-        if (existing != null) {
-            error(
-                "Attempted to register $qualifiedName twice; once from ${existing.fileLocation.path} and this one from ${classItem.fileLocation.path}"
-            )
-        }
-
-        addClass(classItem)
-
-        // A real class exists so a stub will not be created.
-        requiredStubKindForClass.remove(qualifiedName)
-    }
-
-    /**
-     * The [StubKind] required for each class which could not be found, defaults to [StubKind.CLASS]
-     * if not specified.
-     *
-     * Specific types, require a specific type of class, e.g. a type used in an `extends` clause of
-     * a concrete class requires a concrete class, whereas a type used in an `implements` clause of
-     * a concrete class, or an `extends` list of an interface requires an interface.
-     *
-     * Similarly, an annotation must be an annotation type and extends
-     * `java.lang.annotation.Annotation` and a `throws` type that is not a type parameter must be a
-     * concrete class that extends `java.lang.Throwable.`
-     *
-     * This contains information about the type use so that if a stub class is needed a class of the
-     * appropriate structure can be fabricated to avoid spurious issues being reported.
-     */
-    private val requiredStubKindForClass = mutableMapOf<String, StubKind>()
-
-    /**
-     * Register that the class type requires a specific stub kind.
-     *
-     * If a concrete class already exists then this does nothing. Otherwise, this registers the
-     * [StubKind] for the [ClassTypeItem.qualifiedName], making sure that it does not conflict with
-     * any previous requirements.
-     */
-    fun requireStubKindFor(classTypeItem: ClassTypeItem, stubKind: StubKind) {
-        val qualifiedName = classTypeItem.qualifiedName
-
-        // If a real class already exists then a stub will not need to be created.
-        if (allClassesByName[qualifiedName] != null) return
-
-        val existing = requiredStubKindForClass.put(qualifiedName, stubKind)
-        if (existing != null && existing != stubKind) {
-            error(
-                "Mismatching required stub kinds for $qualifiedName, found $existing and $stubKind"
-            )
-        }
-    }
-
-    /**
-     * Gets an existing, or creates a new [ClassItem].
-     *
-     * Tries to find [name] in [allClassesByName]. If not found, then if a [classResolver] is
-     * provided it will invoke that and return the [ClassItem] it returns if any. Otherwise, it will
-     * create an empty stub class of the [StubKind] specified in [requiredStubKindForClass] or
-     * [StubKind.CLASS] if no specific [StubKind] was required.
-     *
-     * Initializes outer classes and packages for the created class as needed.
-     *
-     * @param name the name of the class.
-     * @param isOuterClass if `true` then this is searching for an outer class of a class in this
-     *   codebase, in which case this must only search classes in this codebase, otherwise it can
-     *   search for external classes too.
-     */
-    fun getOrCreateClass(
-        name: String,
-        isOuterClass: Boolean = false,
-    ): ClassItem {
-        // Check this codebase first, if found then return it.
-        allClassesByName[name]?.let { found ->
-            return found
-        }
-
-        // Only check for external classes if this is not searching for an outer class and there is
-        // a class resolver that will populate the external classes.
-        if (!isOuterClass && classResolver != null) {
-            // Check to see whether the class has already been retrieved from the resolver. If it
-            // has then return it.
-            externalClassesByName[name]?.let { found ->
-                return found
-            }
-
-            // Else try and resolve the class.
-            val classItem = classResolver.resolveClass(name)
-            if (classItem != null) {
-                // Save the class item, so it can be retrieved the next time this is loaded. This is
-                // needed because otherwise TextTypeItem.asClass would not work properly.
-                externalClassesByName[name] = classItem
-                return classItem
-            }
-        }
-
-        // Build a stub class of the required kind.
-        val requiredStubKind = requiredStubKindForClass.remove(name) ?: StubKind.CLASS
-        val stubClass =
-            StubClassBuilder.build(this, name) {
-                // Apply stub kind specific mutations to the stub class being built.
-                requiredStubKind.mutator(this)
-            }
-
-        registerClass(stubClass)
-        stubClass.emit = false
-
-        val fullName = stubClass.fullName()
-        if (fullName.contains('.')) {
-            // We created a new inner class stub. We need to fully initialize it with outer classes,
-            // themselves possibly stubs
-            val outerName = name.substring(0, name.lastIndexOf('.'))
-            // Pass classResolver = null, so it only looks in this codebase for the outer class.
-            val outerClass = getOrCreateClass(outerName, isOuterClass = true)
-
-            // It makes no sense for a Foo to come from one codebase and Foo.Bar to come from
-            // another.
-            if (outerClass.codebase != stubClass.codebase) {
-                throw IllegalStateException(
-                    "Outer class $outerClass is from ${outerClass.codebase} but" +
-                        " inner class $stubClass is from ${stubClass.codebase}"
-                )
-            }
-
-            stubClass.containingClass = outerClass
-            outerClass.addInnerClass(stubClass)
-        } else {
-            // Add to package
-            val endIndex = name.lastIndexOf('.')
-            val pkgPath = if (endIndex != -1) name.substring(0, endIndex) else ""
-            val pkg =
-                findPackage(pkgPath)
-                    ?: run {
-                        val newPkg =
-                            TextPackageItem(
-                                this,
-                                pkgPath,
-                                DefaultModifierList(this, DefaultModifierList.PUBLIC),
-                                FileLocation.UNKNOWN
-                            )
-                        addPackage(newPkg)
-                        newPkg.emit = false
-                        newPkg
-                    }
-            stubClass.setContainingPackage(pkg)
-            pkg.addClass(stubClass)
-        }
-        return stubClass
-    }
-
-    override fun findPackage(pkgName: String): TextPackageItem? {
-        return packagesByName[pkgName]
-    }
-
-    override fun createAnnotation(
-        source: String,
-        context: Item?,
-    ): AnnotationItem {
-        return DefaultAnnotationItem.create(this, source)
-    }
-
-    override fun toString(): String {
-        return description
-    }
-
-    override fun unsupported(desc: String?): Nothing {
-        error(desc ?: "Not supported for a signature-file based codebase")
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
new file mode 100644
index 000000000..d8215cf92
--- /dev/null
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.AnnotationManager
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.bestGuessAtFullName
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.item.DefaultCodebaseAssembler
+import com.android.tools.metalava.model.item.DefaultCodebaseFactory
+import com.android.tools.metalava.model.item.DefaultItemFactory
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.reporter.BasicReporter
+import java.io.File
+import java.io.PrintWriter
+
+internal class TextCodebaseAssembler(
+    codebaseFactory: DefaultCodebaseFactory,
+    private val classResolver: ClassResolver?,
+) : DefaultCodebaseAssembler() {
+
+    internal val codebase = codebaseFactory(this)
+
+    /** Creates [Item] instances for this. */
+    override val itemFactory =
+        DefaultItemFactory(
+            codebase = codebase,
+            // Signature files do not contain information about whether an item was originally
+            // created from Java or Kotlin.
+            defaultItemLanguage = ItemLanguage.UNKNOWN,
+            // Signature files have already been separated by API surface variants, so they can use
+            // the same immutable ApiVariantSelectors.
+            defaultVariantSelectorsFactory = ApiVariantSelectors.IMMUTABLE_FACTORY,
+        )
+
+    fun initialize() {
+        // Make sure that it has a root package.
+        codebase.packageTracker.createInitialPackages(PackageDocs.EMPTY)
+    }
+
+    override fun createClassFromUnderlyingModel(qualifiedName: String) =
+        getOrCreateClass(qualifiedName)
+
+    /**
+     * The [StubKind] required for each class which could not be found, defaults to [StubKind.CLASS]
+     * if not specified.
+     *
+     * Specific types, require a specific type of class, e.g. a type used in an `extends` clause of
+     * a concrete class requires a concrete class, whereas a type used in an `implements` clause of
+     * a concrete class, or an `extends` list of an interface requires an interface.
+     *
+     * Similarly, an annotation must be an annotation type and extends
+     * `java.lang.annotation.Annotation` and a `throws` type that is not a type parameter must be a
+     * concrete class that extends `java.lang.Throwable.`
+     *
+     * This contains information about the type use so that if a stub class is needed a class of the
+     * appropriate structure can be fabricated to avoid spurious issues being reported.
+     */
+    private val requiredStubKindForClass = mutableMapOf<String, StubKind>()
+
+    override fun newClassRegistered(classItem: DefaultClassItem) {
+        // A real class exists so a stub will not be created so the hint as to the kind of class
+        // that the stubs should be is no longer needed.
+        requiredStubKindForClass.remove(classItem.qualifiedName())
+    }
+
+    /**
+     * Register that the class type requires a specific stub kind.
+     *
+     * If a concrete class already exists then this does nothing. Otherwise, this registers the
+     * [StubKind] for the [ClassTypeItem.qualifiedName], making sure that it does not conflict with
+     * any previous requirements.
+     */
+    fun requireStubKindFor(classTypeItem: ClassTypeItem, stubKind: StubKind) {
+        val qualifiedName = classTypeItem.qualifiedName
+
+        // If a real class already exists then a stub will not need to be created.
+        if (codebase.findClass(qualifiedName) != null) return
+
+        val existing = requiredStubKindForClass.put(qualifiedName, stubKind)
+        if (existing != null && existing != stubKind) {
+            error(
+                "Mismatching required stub kinds for $qualifiedName, found $existing and $stubKind"
+            )
+        }
+    }
+
+    /**
+     * Gets an existing, or creates a new [ClassItem].
+     *
+     * Tries to find [qualifiedName] in [codebase]. If not found, then if a [classResolver] is
+     * provided it will invoke that and return the [ClassItem] it returns if any. Otherwise, it will
+     * create an empty stub class of the [StubKind] specified in [requiredStubKindForClass] or
+     * [StubKind.CLASS] if no specific [StubKind] was required.
+     *
+     * Initializes outer classes and packages for the created class as needed.
+     *
+     * @param qualifiedName the fully qualified name of the class.
+     * @param isOuterClassOfClassInThisCodebase if `true` then this is searching for an outer class
+     *   of a class in this codebase, in which case this must only search classes in this codebase,
+     *   otherwise it can search for external classes too.
+     */
+    internal fun getOrCreateClass(
+        qualifiedName: String,
+        isOuterClassOfClassInThisCodebase: Boolean = false,
+    ): ClassItem {
+        // Check this codebase first, if found then return it.
+        codebase.findClass(qualifiedName)?.let {
+            return it
+        }
+
+        // Only check for external classes if this is not searching for an outer class of a class in
+        // this codebase and there is a class resolver that will populate the external classes.
+        if (!isOuterClassOfClassInThisCodebase && classResolver != null) {
+            // Try and resolve the class, returning it if it was found.
+            classResolver.resolveClass(qualifiedName)?.let {
+                return it
+            }
+        }
+
+        val fullName = bestGuessAtFullName(qualifiedName)
+
+        val outerClass =
+            if (fullName.contains('.')) {
+                // We created a new nested class stub. We need to fully initialize it with outer
+                // classes, themselves possibly stubs
+                val outerName = qualifiedName.substring(0, qualifiedName.lastIndexOf('.'))
+                val outerClass = getOrCreateClass(outerName, isOuterClassOfClassInThisCodebase)
+
+                // As outerClass and stubClass are from the same codebase the outerClass must be a
+                // DefaultClassItem so cast it to one so that the code below can use
+                // DefaultClassItem methods.
+                outerClass as DefaultClassItem
+            } else {
+                null
+            }
+
+        // Find/create package
+        val pkg =
+            if (outerClass == null) {
+                val endIndex = qualifiedName.lastIndexOf('.')
+                val pkgPath = if (endIndex != -1) qualifiedName.substring(0, endIndex) else ""
+                codebase.findOrCreatePackage(pkgPath)
+            } else {
+                outerClass.containingPackage() as DefaultPackageItem
+            }
+
+        // Build a stub class of the required kind.
+        val requiredStubKind = requiredStubKindForClass.remove(qualifiedName) ?: StubKind.CLASS
+
+        return StubClassBuilder.build(
+            assembler = this,
+            qualifiedName = qualifiedName,
+            containingClass = outerClass,
+            containingPackage = pkg,
+        ) {
+            // Apply stub kind specific mutations to the stub class being built.
+            requiredStubKind.mutator(this)
+        }
+    }
+
+    companion object {
+        /** Create a [TextCodebaseAssembler]. */
+        fun createAssembler(
+            location: File,
+            description: String,
+            annotationManager: AnnotationManager,
+            classResolver: ClassResolver?,
+        ): TextCodebaseAssembler {
+            val assembler =
+                TextCodebaseAssembler(
+                    codebaseFactory = { assembler ->
+                        val reporter = BasicReporter(PrintWriter(System.err))
+                        DefaultCodebase(
+                            location = location,
+                            description = description,
+                            preFiltered = true,
+                            annotationManager = annotationManager,
+                            trustedApi = true,
+                            supportsDocumentation = false,
+                            reporter = reporter,
+                            assembler = assembler,
+                        )
+                    },
+                    classResolver = classResolver,
+                )
+            assembler.initialize()
+
+            return assembler
+        }
+    }
+}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
index 098f27fc5..af131ebf6 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
@@ -20,113 +20,95 @@ import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.reporter.FileLocation
 import java.io.File
 
-/**
- * Supports building a [TextCodebase] that is a subset of another [TextCodebase].
- *
- * The purposely uses generic model classes in the API and down casts any items provided to the
- * appropriate text model item. That is to avoid external dependencies on the text model item
- * implementation classes.
- */
-class TextCodebaseBuilder private constructor(private val codebase: TextCodebase) {
+/** Supports building a [DefaultCodebase] that is a subset of another [DefaultCodebase]. */
+class TextCodebaseBuilder private constructor(private val assembler: TextCodebaseAssembler) {
 
     companion object {
         fun build(
             location: File,
+            description: String,
             annotationManager: AnnotationManager,
             block: TextCodebaseBuilder.() -> Unit
         ): Codebase {
-            val codebase =
-                TextCodebase(
+            val assembler =
+                TextCodebaseAssembler.createAssembler(
                     location = location,
+                    description = description,
                     annotationManager = annotationManager,
                     classResolver = null,
                 )
-            val builder = TextCodebaseBuilder(codebase)
+            val builder = TextCodebaseBuilder(assembler)
             builder.block()
 
-            return codebase
+            return assembler.codebase
         }
     }
 
-    var description by codebase::description
+    val codebase = assembler.codebase
 
-    private fun getOrAddPackage(pkgName: String): TextPackageItem {
-        val pkg = codebase.findPackage(pkgName)
-        if (pkg != null) {
-            return pkg
-        }
-        val newPkg =
-            TextPackageItem(
-                codebase,
-                pkgName,
-                DefaultModifierList(codebase, DefaultModifierList.PUBLIC),
-                FileLocation.UNKNOWN
-            )
-        codebase.addPackage(newPkg)
-        return newPkg
-    }
+    val description by codebase::description
+
+    private val itemFactory = assembler.itemFactory
+
+    private fun getOrAddPackage(pkgName: String) = codebase.findOrCreatePackage(pkgName)
 
     fun addPackage(pkg: PackageItem) {
-        codebase.addPackage(pkg as TextPackageItem)
+        codebase.addPackage(pkg as DefaultPackageItem)
     }
 
     fun addClass(cls: ClassItem) {
         val pkg = getOrAddPackage(cls.containingPackage().qualifiedName())
-        pkg.addClass(cls as TextClassItem)
+        pkg.addTopClass(cls)
     }
 
     fun addConstructor(ctor: ConstructorItem) {
         val cls = getOrAddClass(ctor.containingClass())
-        cls.addConstructor(ctor as TextConstructorItem)
+        cls.addConstructor(ctor)
     }
 
     fun addMethod(method: MethodItem) {
         val cls = getOrAddClass(method.containingClass())
-        cls.addMethod(method as TextMethodItem)
+        cls.addMethod(method)
     }
 
     fun addField(field: FieldItem) {
         val cls = getOrAddClass(field.containingClass())
-        cls.addField(field as TextFieldItem)
+        cls.addField(field)
     }
 
     fun addProperty(property: PropertyItem) {
         val cls = getOrAddClass(property.containingClass())
-        cls.addProperty(property as TextPropertyItem)
+        cls.addProperty(property)
     }
 
-    private fun getOrAddClass(fullClass: ClassItem): TextClassItem {
+    private fun getOrAddClass(fullClass: ClassItem): DefaultClassItem {
         val cls = codebase.findClassInCodebase(fullClass.qualifiedName())
         if (cls != null) {
             return cls
         }
-        val textClass = fullClass as TextClassItem
-        val newClass =
-            TextClassItem(
-                codebase = codebase,
-                fileLocation = FileLocation.UNKNOWN,
-                modifiers = textClass.modifiers,
-                classKind = textClass.classKind,
-                qualifiedName = textClass.qualifiedName,
-                simpleName = textClass.simpleName,
-                fullName = textClass.fullName,
-                typeParameterList = textClass.typeParameterList,
-            )
-
-        newClass.setSuperClassType(textClass.superClassType())
-
         val pkg = getOrAddPackage(fullClass.containingPackage().qualifiedName())
-        pkg.addClass(newClass)
-        newClass.setContainingPackage(pkg)
-        codebase.registerClass(newClass)
-        return newClass
+
+        return itemFactory.createClassItem(
+            fileLocation = FileLocation.UNKNOWN,
+            modifiers = fullClass.modifiers,
+            classKind = fullClass.classKind,
+            containingClass = null,
+            containingPackage = pkg,
+            qualifiedName = fullClass.qualifiedName(),
+            typeParameterList = fullClass.typeParameterList,
+            origin = fullClass.origin,
+            superClassType = fullClass.superClassType(),
+            interfaceTypes = fullClass.interfaceTypes(),
+        )
     }
 }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextConstructorItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextConstructorItem.kt
deleted file mode 100644
index e694bebd1..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextConstructorItem.kt
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TextConstructorItem(
-    codebase: TextCodebase,
-    name: String,
-    containingClass: TextClassItem,
-    modifiers: DefaultModifierList,
-    returnType: ClassTypeItem,
-    parameters: List<TextParameterItem>,
-    fileLocation: FileLocation
-) :
-    TextMethodItem(
-        codebase,
-        name,
-        containingClass,
-        modifiers,
-        returnType,
-        parameters,
-        fileLocation
-    ),
-    ConstructorItem {
-
-    override var superConstructor: ConstructorItem? = null
-
-    override fun isConstructor(): Boolean = true
-
-    companion object {
-        fun createDefaultConstructor(
-            codebase: TextCodebase,
-            containingClass: TextClassItem,
-            fileLocation: FileLocation,
-        ): TextConstructorItem {
-            val name = containingClass.simpleName
-            // The default constructor is package private because while in Java a class without
-            // a constructor has a default public constructor in a signature file a class
-            // without a constructor has no public constructors.
-            val modifiers = DefaultModifierList(codebase, DefaultModifierList.PACKAGE_PRIVATE, null)
-
-            val item =
-                TextConstructorItem(
-                    codebase = codebase,
-                    name = name,
-                    containingClass = containingClass,
-                    modifiers = modifiers,
-                    returnType = containingClass.type(),
-                    parameters = emptyList(),
-                    fileLocation = fileLocation,
-                )
-            return item
-        }
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextFieldItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextFieldItem.kt
deleted file mode 100644
index 225274e77..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextFieldItem.kt
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TextFieldItem(
-    codebase: TextCodebase,
-    name: String,
-    containingClass: TextClassItem,
-    modifiers: DefaultModifierList,
-    private val type: TypeItem,
-    private val constantValue: Any?,
-    fileLocation: FileLocation
-) : TextMemberItem(codebase, name, containingClass, fileLocation, modifiers), FieldItem {
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is FieldItem) return false
-
-        if (name() != other.name()) {
-            return false
-        }
-
-        return containingClass() == other.containingClass()
-    }
-
-    override fun hashCode(): Int = name().hashCode()
-
-    override fun type(): TypeItem = type
-
-    override fun initialValue(requireConstant: Boolean): Any? = constantValue
-
-    override fun duplicate(targetContainingClass: ClassItem): TextFieldItem {
-        val duplicated =
-            TextFieldItem(
-                codebase,
-                name(),
-                targetContainingClass as TextClassItem,
-                modifiers.duplicate(),
-                type,
-                constantValue,
-                fileLocation
-            )
-        duplicated.inheritedFrom = containingClass()
-
-        // Preserve flags that may have been inherited (propagated) from surrounding packages
-        if (targetContainingClass.hidden) {
-            duplicated.hidden = true
-        }
-        if (targetContainingClass.removed) {
-            duplicated.removed = true
-        }
-        if (targetContainingClass.docOnly) {
-            duplicated.docOnly = true
-        }
-
-        return duplicated
-    }
-
-    override var inheritedFrom: ClassItem? = null
-
-    private var isEnumConstant = false
-
-    override fun isEnumConstant(): Boolean = isEnumConstant
-
-    fun setEnumConstant(isEnumConstant: Boolean) {
-        this.isEnumConstant = isEnumConstant
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextItem.kt
deleted file mode 100644
index b7656f8ce..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextItem.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.DefaultItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.reporter.FileLocation
-
-internal abstract class TextItem(
-    override val codebase: TextCodebase,
-    fileLocation: FileLocation,
-    override var docOnly: Boolean = false,
-    override var documentation: String = "",
-    modifiers: DefaultModifierList,
-) :
-    DefaultItem(
-        fileLocation = fileLocation,
-        modifiers = modifiers,
-    ) {
-
-    override var originallyHidden = false
-    override var hidden = false
-    override var removed = false
-
-    override fun findTagDocumentation(tag: String, value: String?): String? = null
-
-    override fun appendDocumentation(comment: String, tagSection: String?, append: Boolean) =
-        codebase.unsupported()
-
-    override fun isJava(): Boolean =
-        codebase.unsupported() // source language not recorded in signature files
-
-    override fun isKotlin(): Boolean =
-        codebase.unsupported() // source language not recorded in signature files
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextMemberItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextMemberItem.kt
deleted file mode 100644
index 1b9b0c354..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextMemberItem.kt
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.MemberItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal abstract class TextMemberItem(
-    codebase: TextCodebase,
-    private val name: String,
-    private val containingClass: ClassItem,
-    fileLocation: FileLocation,
-    modifiers: DefaultModifierList
-) : TextItem(codebase, fileLocation = fileLocation, modifiers = modifiers), MemberItem {
-
-    override fun name(): String = name
-
-    override fun containingClass(): ClassItem = containingClass
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextMethodItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextMethodItem.kt
deleted file mode 100644
index a3cc6adb6..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextMethodItem.kt
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.computeSuperMethods
-import com.android.tools.metalava.model.updateCopiedMethodState
-import com.android.tools.metalava.reporter.FileLocation
-import java.util.function.Predicate
-
-internal open class TextMethodItem(
-    codebase: TextCodebase,
-    name: String,
-    containingClass: ClassItem,
-    modifiers: DefaultModifierList,
-    private val returnType: TypeItem,
-    private val parameters: List<TextParameterItem>,
-    fileLocation: FileLocation,
-) :
-    TextMemberItem(codebase, name, containingClass, fileLocation, modifiers = modifiers),
-    MethodItem {
-    init {
-        parameters.forEach { it.containingMethod = this }
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is MethodItem) return false
-
-        if (name() != other.name()) {
-            return false
-        }
-
-        if (containingClass() != other.containingClass()) {
-            return false
-        }
-
-        val parameters1 = parameters()
-        val parameters2 = other.parameters()
-
-        if (parameters1.size != parameters2.size) {
-            return false
-        }
-
-        for (i in parameters1.indices) {
-            val parameter1 = parameters1[i]
-            val parameter2 = parameters2[i]
-            if (parameter1.type() != parameter2.type()) {
-                return false
-            }
-        }
-
-        val typeParameters1 = typeParameterList
-        val typeParameters2 = other.typeParameterList
-
-        if (typeParameters1.size != typeParameters2.size) {
-            return false
-        }
-
-        for (i in typeParameters1.indices) {
-            val typeParameter1 = typeParameters1[i]
-            val typeParameter2 = typeParameters2[i]
-            if (typeParameter1.typeBounds() != typeParameter2.typeBounds()) {
-                return false
-            }
-        }
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return name().hashCode()
-    }
-
-    override fun isConstructor(): Boolean = false
-
-    override fun returnType(): TypeItem = returnType
-
-    override fun superMethods(): List<MethodItem> {
-        return computeSuperMethods()
-    }
-
-    override fun findMainDocumentation(): String = documentation
-
-    override fun findPredicateSuperMethod(predicate: Predicate<Item>): MethodItem? = null
-
-    override var typeParameterList: TypeParameterList = TypeParameterList.NONE
-        internal set
-
-    override fun duplicate(targetContainingClass: ClassItem): MethodItem {
-        val typeVariableMap = targetContainingClass.mapTypeVariables(containingClass())
-        val duplicated =
-            TextMethodItem(
-                codebase,
-                name(),
-                targetContainingClass,
-                modifiers.duplicate(),
-                returnType.convertType(typeVariableMap),
-                parameters.map { it.duplicate(typeVariableMap) },
-                fileLocation
-            )
-        duplicated.inheritedFrom = containingClass()
-
-        // Preserve flags that may have been inherited (propagated) from surrounding packages
-        if (targetContainingClass.hidden) {
-            duplicated.hidden = true
-        }
-        if (targetContainingClass.removed) {
-            duplicated.removed = true
-        }
-        if (targetContainingClass.docOnly) {
-            duplicated.docOnly = true
-        }
-
-        duplicated.annotationDefault = annotationDefault
-        duplicated.throwsTypes = this.throwsTypes
-        duplicated.typeParameterList = typeParameterList
-
-        duplicated.updateCopiedMethodState()
-
-        return duplicated
-    }
-
-    private var throwsTypes: List<ExceptionTypeItem> = emptyList()
-
-    override fun throwsTypes(): List<ExceptionTypeItem> = this.throwsTypes
-
-    fun setThrowsTypes(throwsClasses: List<ExceptionTypeItem>) {
-        this.throwsTypes = throwsClasses
-    }
-
-    override fun parameters(): List<ParameterItem> = parameters
-
-    override fun isExtensionMethod(): Boolean = codebase.unsupported()
-
-    override var inheritedFrom: ClassItem? = null
-
-    @Deprecated("This property should not be accessed directly.")
-    override var _requiresOverride: Boolean? = null
-
-    private var annotationDefault = ""
-
-    fun setAnnotationDefault(default: String) {
-        annotationDefault = default
-    }
-
-    override fun defaultValue(): String {
-        return annotationDefault
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextPackageItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextPackageItem.kt
deleted file mode 100644
index 6a1f15680..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextPackageItem.kt
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TextPackageItem(
-    codebase: TextCodebase,
-    private val name: String,
-    modifiers: DefaultModifierList,
-    fileLocation: FileLocation
-) : TextItem(codebase, fileLocation, modifiers = modifiers), PackageItem {
-
-    private val classes = ArrayList<ClassItem>(100)
-
-    private val classesNames = HashSet<String>(100)
-
-    fun name() = name
-
-    fun addClass(classInfo: ClassItem) {
-        val classFullName = classInfo.fullName()
-        if (classFullName in classesNames) {
-            return
-        }
-        classes.add(classInfo)
-        classesNames.add(classFullName)
-    }
-
-    override fun topLevelClasses(): Sequence<ClassItem> = classes.asSequence()
-
-    override fun qualifiedName(): String = name
-
-    override fun containingClass(): ClassItem? = null
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is PackageItem) return false
-
-        return name == other.qualifiedName()
-    }
-
-    override fun hashCode(): Int {
-        return name.hashCode()
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextParameterItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextParameterItem.kt
deleted file mode 100644
index c9e1dedf2..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextParameterItem.kt
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterBindings
-import com.android.tools.metalava.reporter.FileLocation
-
-const val UNKNOWN_DEFAULT_VALUE = "__unknown_default_value__"
-
-internal class TextParameterItem(
-    codebase: TextCodebase,
-    private var name: String,
-    private var publicName: String?,
-    private val hasDefaultValue: Boolean,
-    private var defaultValueBody: String? = UNKNOWN_DEFAULT_VALUE,
-    override val parameterIndex: Int,
-    private var type: TypeItem,
-    modifiers: DefaultModifierList,
-    fileLocation: FileLocation
-) :
-    // TODO: We need to pass in parameter modifiers here (synchronized etc)
-    TextItem(codebase, fileLocation, modifiers = modifiers),
-    ParameterItem {
-
-    internal lateinit var containingMethod: TextMethodItem
-
-    override fun isVarArgs(): Boolean {
-        return modifiers.isVarArg()
-    }
-
-    override fun type(): TypeItem = type
-
-    override fun name(): String = name
-
-    override fun publicName(): String? = publicName
-
-    override fun hasDefaultValue(): Boolean = hasDefaultValue
-
-    override fun isDefaultValueKnown(): Boolean = defaultValueBody != UNKNOWN_DEFAULT_VALUE
-
-    override fun defaultValue(): String? = defaultValueBody
-
-    override fun containingMethod(): MethodItem = containingMethod
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is ParameterItem) return false
-
-        return parameterIndex == other.parameterIndex
-    }
-
-    override fun hashCode(): Int = parameterIndex
-
-    internal fun duplicate(typeVariableMap: TypeParameterBindings): TextParameterItem {
-        return TextParameterItem(
-            codebase,
-            name,
-            publicName,
-            hasDefaultValue,
-            defaultValueBody,
-            parameterIndex,
-            type.convertType(typeVariableMap),
-            modifiers.duplicate(),
-            fileLocation
-        )
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextPropertyItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextPropertyItem.kt
deleted file mode 100644
index 2d8fc7ed7..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextPropertyItem.kt
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.PropertyItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TextPropertyItem(
-    codebase: TextCodebase,
-    name: String,
-    containingClass: TextClassItem,
-    modifiers: DefaultModifierList,
-    private val type: TypeItem,
-    fileLocation: FileLocation
-) : TextMemberItem(codebase, name, containingClass, fileLocation, modifiers), PropertyItem {
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is FieldItem) return false
-
-        if (name() != other.name()) {
-            return false
-        }
-
-        return containingClass() == other.containingClass()
-    }
-
-    override fun hashCode(): Int = name().hashCode()
-
-    override fun type(): TypeItem = type
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeItemFactory.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeItemFactory.kt
index 1e929b065..4f2fac1b4 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeItemFactory.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeItemFactory.kt
@@ -27,7 +27,7 @@ import com.android.tools.metalava.model.type.ContextNullability
 import com.android.tools.metalava.model.type.DefaultTypeItemFactory
 
 internal class TextTypeItemFactory(
-    private val codebase: TextCodebase,
+    private val assembler: TextCodebaseAssembler,
     private val typeParser: TextTypeParser,
     typeParameterScope: TypeParameterScope = TypeParameterScope.empty,
 ) : DefaultTypeItemFactory<String, TextTypeItemFactory>(typeParameterScope) {
@@ -47,7 +47,7 @@ internal class TextTypeItemFactory(
     override fun self() = this
 
     override fun createNestedFactory(scope: TypeParameterScope) =
-        TextTypeItemFactory(codebase, typeParser, scope)
+        TextTypeItemFactory(assembler, typeParser, scope)
 
     override fun getType(
         underlyingType: String,
@@ -67,30 +67,32 @@ internal class TextTypeItemFactory(
         if (
             typeItem is ArrayTypeItem &&
                 forcedComponentNullability != null &&
-                forcedComponentNullability != typeItem.componentType.modifiers.nullability()
+                forcedComponentNullability != typeItem.componentType.modifiers.nullability
         ) {
             typeItem =
-                typeItem.duplicate(typeItem.componentType.duplicate(forcedComponentNullability))
+                typeItem.substitute(
+                    componentType = typeItem.componentType.substitute(forcedComponentNullability),
+                )
         }
 
         // Check if the type's nullability needs to be updated based on the context.
-        val typeNullability = typeItem.modifiers.nullability()
+        val typeNullability = typeItem.modifiers.nullability
         val actualTypeNullability =
-            contextNullability.compute(typeNullability, typeItem.modifiers.annotations())
+            contextNullability.compute(typeNullability, typeItem.modifiers.annotations)
         return if (actualTypeNullability != typeNullability) {
-            typeItem.duplicate(actualTypeNullability)
+            typeItem.substitute(actualTypeNullability)
         } else typeItem
     }
 
     override fun getExceptionType(underlyingType: String) =
         super.getExceptionType(underlyingType).also { exceptionTypeItem ->
             if (exceptionTypeItem is ClassTypeItem) {
-                codebase.requireStubKindFor(exceptionTypeItem, StubKind.THROWABLE)
+                assembler.requireStubKindFor(exceptionTypeItem, StubKind.THROWABLE)
             }
         }
 
     override fun getInterfaceType(underlyingType: String) =
         super.getInterfaceType(underlyingType).also { classTypeItem ->
-            codebase.requireStubKindFor(classTypeItem, StubKind.INTERFACE)
+            assembler.requireStubKindFor(classTypeItem, StubKind.INTERFACE)
         }
 }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParameterItem.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParameterItem.kt
deleted file mode 100644
index a019b5f6e..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParameterItem.kt
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.BoundsTypeItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.TypeNullability
-import com.android.tools.metalava.model.TypeParameterItem
-import com.android.tools.metalava.model.VariableTypeItem
-import com.android.tools.metalava.model.type.DefaultTypeModifiers
-import com.android.tools.metalava.model.type.DefaultVariableTypeItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TextTypeParameterItem(
-    codebase: TextCodebase,
-    private val name: String,
-    private val isReified: Boolean,
-) :
-    TextItem(
-        codebase = codebase,
-        fileLocation = FileLocation.UNKNOWN,
-        modifiers = DefaultModifierList(codebase, DefaultModifierList.PUBLIC),
-    ),
-    TypeParameterItem {
-
-    lateinit var bounds: List<BoundsTypeItem>
-
-    override fun name(): String {
-        return name
-    }
-
-    override fun type(): VariableTypeItem {
-        return DefaultVariableTypeItem(
-            DefaultTypeModifiers.create(emptyList(), TypeNullability.UNDEFINED),
-            this
-        )
-    }
-
-    override fun typeBounds(): List<BoundsTypeItem> = bounds
-
-    override fun isReified(): Boolean = isReified
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is TypeParameterItem) return false
-
-        return name == other.name()
-    }
-
-    override fun hashCode(): Int {
-        return name.hashCode()
-    }
-
-    companion object {
-
-        /**
-         * Create a partially initialized [TextTypeParameterItem].
-         *
-         * This extracts the [isReified] and [name] from the [typeParameterString] and creates a
-         * [TextTypeParameterItem] with those properties initialized but the [bounds] is not.
-         *
-         * This must ONLY be used by [ApiFile.createTypeParameterList] as that will complete the
-         * initialization of the [bounds] property.
-         */
-        fun create(
-            codebase: TextCodebase,
-            typeParameterString: String,
-        ): TextTypeParameterItem {
-            val length = typeParameterString.length
-            var nameEnd = length
-
-            val isReified = typeParameterString.startsWith("reified ")
-            val nameStart =
-                if (isReified) {
-                    8 // "reified ".length
-                } else {
-                    0
-                }
-
-            for (i in nameStart until length) {
-                val c = typeParameterString[i]
-                if (!Character.isJavaIdentifierPart(c)) {
-                    nameEnd = i
-                    break
-                }
-            }
-            val name = typeParameterString.substring(nameStart, nameEnd)
-
-            return TextTypeParameterItem(
-                codebase = codebase,
-                name = name,
-                isReified = isReified,
-            )
-        }
-    }
-}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
index 686cb24c4..81d1e9d2d 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
@@ -386,7 +386,7 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
 
         val qualifiedName =
             if (outerClassType != null) {
-                // This is an inner type, add the prefix of the outer name
+                // This is a nested type, add the prefix of the outer name
                 "${outerClassType.qualifiedName}.$name"
             } else if (!name.contains('.')) {
                 // Reverse the effect of [TypeItem.stripJavaLangPrefix].
@@ -399,7 +399,7 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
         val arguments =
             argumentStrings.map { cachedParseType(it, typeParameterScope) as TypeArgumentTypeItem }
         // If this is an outer class type (there's a remainder), call it non-null and don't apply
-        // the leading annotations (they belong to the inner class type).
+        // the leading annotations (they belong to the nested class type).
         val classModifiers =
             if (remainder != null) {
                 modifiers(classAnnotations, TypeNullability.NONNULL)
@@ -415,7 +415,7 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                     "Could not parse type `$type`. Found unexpected string after type parameters: $remainder"
                 )
             }
-            // This is an inner class type, recur with the new outer class
+            // This is a nested class type, recur with the new outer class
             return createClassType(
                 remainder.substring(1),
                 classType,
@@ -435,7 +435,6 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
         return DefaultTypeModifiers.create(
             annotations,
             nullability,
-            "Type modifiers created by the text model are immutable because they are cached",
         )
     }
 
@@ -449,7 +448,9 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
         while (trimmed.startsWith('@')) {
             val end = findAnnotationEnd(trimmed, 1)
             val annotationSource = trimmed.substring(0, end).trim()
-            annotations.add(DefaultAnnotationItem.create(codebase, annotationSource))
+            DefaultAnnotationItem.create(codebase, annotationSource)?.let { annotationItem ->
+                annotations.add(annotationItem)
+            }
             trimmed = trimmed.substring(end).trim()
         }
         return Pair(trimmed, annotations)
@@ -490,7 +491,9 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
                 break
             }
             val annotationSource = trimmed.substring(start)
-            annotations.add(DefaultAnnotationItem.create(codebase, annotationSource))
+            DefaultAnnotationItem.create(codebase, annotationSource)?.let { annotationItem ->
+                annotations.add(annotationItem)
+            }
             // Cut this annotation off, so now the next one can end at the last index.
             trimmed = trimmed.substring(0, start).trim()
         }
@@ -500,7 +503,7 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
     /**
      * Given [type] which represents a class, splits the string into the qualified name of the
      * class, the remainder of the type string, and a list of type-use annotations. The remainder of
-     * the type string might be the type parameter list, inner class names, or a combination
+     * the type string might be the type parameter list, nested class names, or a combination
      *
      * For `java.util.@A @B List<java.lang.@C String>`, returns the triple ("java.util.List",
      * "<java.lang.@C String", listOf("@A", "@B")).
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
index 8481a59e1..98ff9e70e 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
@@ -23,6 +23,7 @@ import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.testing.getAndroidJar
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
 import kotlin.test.assertNotNull
@@ -103,7 +104,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
             val throwableSuperClass = throwable.superClass()
 
             // Now get the object class.
-            val objectClass = codebase.assertClass("java.lang.Object")
+            val objectClass = codebase.assertClass("java.lang.Object", expectedEmit = false)
 
             assertSame(objectClass, throwableSuperClass)
 
@@ -138,7 +139,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
             val errorSuperClass = error.superClassType()?.asClass()
 
             // Now get the throwable class.
-            val throwable = codebase.assertClass("java.lang.Throwable")
+            val throwable = codebase.assertClass("java.lang.Throwable", expectedEmit = false)
 
             assertSame(throwable, errorSuperClass)
 
@@ -197,7 +198,8 @@ class ApiFileTest : BaseTextCodebaseTest() {
             // is checked below.
             exceptionType.erasedClass
 
-            val unknownExceptionClass = codebase.assertClass("other.UnknownException")
+            val unknownExceptionClass =
+                codebase.assertClass("other.UnknownException", expectedEmit = false)
             // Make sure the stub UnknownException is initialized correctly.
             assertSame(throwable, unknownExceptionClass.superClass())
 
@@ -297,8 +299,10 @@ class ApiFileTest : BaseTextCodebaseTest() {
 
     /** Dump the package structure of [codebase] to a string for easy comparison. */
     private fun dumpPackageStructure(codebase: Codebase) = buildString {
-        codebase.getPackages().packages.map { packageItem ->
-            append("${packageItem.qualifiedName()}\n")
+        for (packageItem in codebase.getPackages().packages) {
+            // Ignore packages that will not be emitted.
+            if (!packageItem.emit) continue
+            append("${packageItem.qualifiedName().let {if (it == "") "<root>" else it}}\n")
             for (classItem in packageItem.allClasses()) {
                 append("    ${classItem.qualifiedName()}\n")
             }
@@ -445,7 +449,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
             // Resolve the class. Even though it does not exist, the text model will fabricate an
             // instance.
             val unknownInterfaceClass =
-                codebase.assertResolvedClass("test.pkg.Foo").interfaceTypes().single().asClass()
+                codebase.assertClass("test.pkg.Foo").interfaceTypes().single().asClass()
             assertNotNull(unknownInterfaceClass)
 
             // Make sure that the fabricated instance is of the correct structure.
@@ -524,7 +528,9 @@ class ApiFileTest : BaseTextCodebaseTest() {
             files.map { file ->
                 SignatureFile(file, forCurrentApiSurface = file.name == "current.txt")
             }
-        val codebase = ApiFile.parseApi(signatureFiles)
+
+        val classResolver = ClassLoaderBasedClassResolver(getAndroidJar())
+        val codebase = ApiFile.parseApi(signatureFiles, classResolver = classResolver)
 
         val current = buildList {
             codebase.accept(
@@ -540,9 +546,12 @@ class ApiFileTest : BaseTextCodebaseTest() {
 
         assertEquals(
             """
+                package test.pkg
                 class test.pkg.Foo
                 constructor test.pkg.Foo.Foo(int)
                 parameter currentCtorParameter
+                method test.pkg.Foo.extensibleMethod(int)
+                parameter parameter
                 method test.pkg.Foo.currentMethod(int)
                 parameter currentMethodParameter
                 field Foo.currentField
@@ -557,9 +566,8 @@ class ApiFileTest : BaseTextCodebaseTest() {
     class TestClassItem private constructor(delegate: ClassItem) : ClassItem by delegate {
         companion object {
             fun create(name: String): TestClassItem {
-                val codebase =
-                    ApiFile.parseApi("other.txt", "// Signature format: 2.0") as TextCodebase
-                val delegate = codebase.getOrCreateClass(name)
+                val codebase = ApiFile.parseApi("other.txt", "// Signature format: 2.0")
+                val delegate = codebase.resolveClass(name)!!
                 return TestClassItem(delegate)
             }
         }
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt
index b67f4ea47..a339b306e 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/BaseTextCodebaseTest.kt
@@ -21,13 +21,13 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 
 /**
- * Base class for text test classes that parse signature files to create a [TextCodebase] that can
- * then be introspected.
+ * Base class for text test classes that parse signature files to create a [Codebase] that can then
+ * be introspected.
  */
 abstract class BaseTextCodebaseTest : BaseModelTest() {
 
     /** Run a single signature test with a set of signature files. */
-    fun runSignatureTest(vararg sources: TestFile, test: CodebaseContext<Codebase>.() -> Unit) {
+    fun runSignatureTest(vararg sources: TestFile, test: CodebaseContext.() -> Unit) {
         runCodebaseTest(inputSet(*sources), test = test)
     }
 }
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/MultipleFileTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/MultipleFileTest.kt
index 48ef87e67..7676811ac 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/MultipleFileTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/MultipleFileTest.kt
@@ -17,12 +17,13 @@
 package com.android.tools.metalava.model.text
 
 import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.model.Codebase
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertSame
 import org.junit.Assert.assertThrows
 import org.junit.Test
 
-/** Contains tests for when loading multiple files into a single [TextCodebase]. */
+/** Contains tests for when loading multiple files into a single [Codebase]. */
 class MultipleFileTest : BaseTextCodebaseTest() {
 
     @Test
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextMethodItemTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextMethodItemTest.kt
index 1181cb23b..3cd2622cb 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextMethodItemTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextMethodItemTest.kt
@@ -38,7 +38,7 @@ class TextMethodItemTest : BaseTextCodebaseTest() {
             )
         ) {
             val cls = codebase.assertClass("test.pkg.Foo")
-            val ctorItem = cls.assertMethod("Foo", "")
+            val ctorItem = cls.assertConstructor("")
             val methodItem = cls.assertMethod("bar", "")
 
             assertNotNull(ctorItem.returnType())
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextModifierListTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextModifierListTest.kt
deleted file mode 100644
index 73c814570..000000000
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextModifierListTest.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.model.DefaultModifierList
-import kotlin.test.assertFalse
-import kotlin.test.assertTrue
-import org.junit.Test
-
-/** Tests that the text model parses modifiers correctly. */
-class TextModifierListTest {
-
-    @Test
-    fun `test equivalentTo()`() {
-        val codebase =
-            ApiFile.parseApi(
-                "test",
-                """
-            // Signature format: 2.0
-            package androidx.navigation {
-              public final class NavDestination {
-                ctor public NavDestination();
-              }
-            }
-            """
-                    .trimIndent(),
-            )
-
-        assertTrue {
-            DefaultModifierList(codebase, flags = DefaultModifierList.PUBLIC)
-                .equivalentTo(DefaultModifierList(codebase, flags = DefaultModifierList.PUBLIC))
-        }
-        assertFalse {
-            DefaultModifierList(codebase, flags = DefaultModifierList.PRIVATE)
-                .equivalentTo(DefaultModifierList(codebase, flags = DefaultModifierList.PUBLIC))
-        }
-    }
-}
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
index 541ca9258..d96798b81 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava.model.text
 
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterScope
@@ -32,7 +33,7 @@ import org.junit.Test
 class TextTypeParserCacheTest : BaseTextCodebaseTest() {
 
     private data class Context(
-        val codebase: TextCodebase,
+        val codebase: Codebase,
         val parser: TextTypeParser,
         val emptyScope: TypeParameterScope,
         val nonEmptyScope: TypeParameterScope,
@@ -50,16 +51,15 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
                 """
             ),
         ) {
-            val textCodebase = codebase as TextCodebase
             val parser =
                 TextTypeParser(
-                    textCodebase,
+                    codebase,
                     kotlinStyleNulls = false,
                 )
             val nonEmptyScope = TypeParameterScope.from(codebase.assertClass("test.pkg.Generic"))
             val context =
                 Context(
-                    textCodebase,
+                    codebase,
                     parser,
                     TypeParameterScope.empty,
                     nonEmptyScope,
@@ -104,7 +104,7 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
                 assertThat(stats)
                     .isEqualTo(
                         ApiFile.Stats(
-                            totalClasses = 328,
+                            totalClasses = 306,
                             typeCacheRequests = 7245,
                             typeCacheSkip = 0,
                             typeCacheHit = 6532,
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
similarity index 59%
rename from metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
rename to metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
index dc2e67f41..07451bf02 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2023 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,12 +17,18 @@
 package com.android.tools.metalava.model.text
 
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
 import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.testing.getAndroidJar
@@ -49,7 +55,11 @@ class TextModelSuiteRunner : ModelSuiteRunner {
         val signatureFiles = SignatureFile.fromFiles(inputs.mainSourceDir.createFiles())
         val resolver = ClassLoaderBasedClassResolver(getAndroidJar())
         val codebase = ApiFile.parseApi(signatureFiles, classResolver = resolver)
-        test(codebase)
+
+        // If available, transform the codebase for testing, otherwise use the one provided.
+        val transformedCodebase = CodebaseTransformer.transformIfAvailable(codebase)
+
+        test(transformedCodebase)
     }
 
     override fun toString() = providerName
@@ -60,24 +70,29 @@ class TextModelSuiteRunner : ModelSuiteRunner {
  *
  * When [resolveClass] is called this will first look in [codebase] to see if the [ClassItem] has
  * already been loaded, returning it if found. Otherwise, it will look in the [classLoader] to see
- * if the class exists on the classpath. If it does then it will create a [TextClassItem] to
+ * if the class exists on the classpath. If it does then it will create a [DefaultClassItem] to
  * represent it and add it to the [codebase]. Otherwise, it will return `null`.
  *
- * The created [TextClassItem] is not a complete representation of the class that was found in the
- * [classLoader]. It is just a placeholder to indicate that it was found, although that may change
- * in the future.
+ * The created [DefaultClassItem] is not a complete representation of the class that was found in
+ * the [classLoader]. It is just a placeholder to indicate that it was found, although that may
+ * change in the future.
  */
-internal class ClassLoaderBasedClassResolver(jar: File) : ClassResolver {
-
-    private val codebase by lazy {
-        TextCodebase(
-            location = jar,
-            annotationManager = noOpAnnotationManager,
-            classResolver = null,
-        )
-    }
+class ClassLoaderBasedClassResolver(jar: File) : ClassResolver {
+
+    private val assembler by
+        lazy(LazyThreadSafetyMode.NONE) {
+            TextCodebaseAssembler.createAssembler(
+                location = jar,
+                description = "Codebase for resolving classes in $jar for tests",
+                annotationManager = noOpAnnotationManager,
+                classResolver = null,
+            )
+        }
+
+    private val codebase by lazy(LazyThreadSafetyMode.NONE) { assembler.codebase }
 
-    private val classLoader by lazy { URLClassLoader(arrayOf(jar.toURI().toURL()), null) }
+    private val classLoader by
+        lazy(LazyThreadSafetyMode.NONE) { URLClassLoader(arrayOf(jar.toURI().toURL()), null) }
 
     private fun findClassInClassLoader(qualifiedName: String): Class<*>? {
         var binaryName = qualifiedName
@@ -85,7 +100,7 @@ internal class ClassLoaderBasedClassResolver(jar: File) : ClassResolver {
             try {
                 return classLoader.loadClass(binaryName)
             } catch (e: ClassNotFoundException) {
-                // If the class could not be found then maybe it was an inner class so replace the
+                // If the class could not be found then maybe it was a nested class so replace the
                 // last '.' in the name with a $ and try again. If there is no '.' then return.
                 val lastDot = binaryName.lastIndexOf('.')
                 if (lastDot == -1) {
@@ -105,25 +120,21 @@ internal class ClassLoaderBasedClassResolver(jar: File) : ClassResolver {
                 val cls = findClassInClassLoader(erasedName) ?: return null
                 val packageName = cls.`package`.name
 
-                val packageItem =
-                    codebase.findPackage(packageName)
-                        ?: TextPackageItem(
-                                codebase = codebase,
-                                name = packageName,
-                                modifiers = DefaultModifierList(codebase),
-                                fileLocation = FileLocation.UNKNOWN,
-                            )
-                            .also { newPackageItem -> codebase.addPackage(newPackageItem) }
-
-                TextClassItem(
-                        codebase = codebase,
-                        modifiers = DefaultModifierList(codebase),
-                        qualifiedName = cls.canonicalName,
-                    )
-                    .also { newClassItem ->
-                        codebase.registerClass(newClassItem)
-                        packageItem.addClass(newClassItem)
-                    }
+                val itemFactory = assembler.itemFactory
+
+                val packageItem = codebase.findOrCreatePackage(packageName)
+                itemFactory.createClassItem(
+                    fileLocation = FileLocation.UNKNOWN,
+                    modifiers = createImmutableModifiers(VisibilityLevel.PACKAGE_PRIVATE),
+                    classKind = ClassKind.CLASS,
+                    containingClass = null,
+                    containingPackage = packageItem,
+                    qualifiedName = cls.canonicalName,
+                    typeParameterList = TypeParameterList.NONE,
+                    origin = ClassOrigin.CLASS_PATH,
+                    superClassType = null,
+                    interfaceTypes = emptyList(),
+                )
             }
     }
 }
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunnerProvider.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunnerProvider.kt
new file mode 100644
index 000000000..832b40236
--- /dev/null
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunnerProvider.kt
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
+
+/** A [ModelSuiteRunnerProvider] that will return one [TextModelSuiteRunner]. */
+class TextModelSuiteRunnerProvider : ModelSuiteRunnerProvider {
+    override val runners = listOf(TextModelSuiteRunner())
+}
diff --git a/metalava-model-source/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunner b/metalava-model-text/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
similarity index 90%
rename from metalava-model-source/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunner
rename to metalava-model-text/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
index d1dc13b10..e00446c78 100644
--- a/metalava-model-source/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+++ b/metalava-model-text/src/testFixtures/resources/META-INF/services/com.android.tools.metalava.model.testsuite.ModelSuiteRunnerProvider
@@ -14,4 +14,4 @@
 # limitations under the License.
 #
 
-com.android.tools.metalava.model.source.SourceModelSuiteRunner
+com.android.tools.metalava.model.text.TextModelSuiteRunnerProvider
\ No newline at end of file
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineBasedCodebase.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineBasedCodebase.kt
deleted file mode 100644
index 728dc598d..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineBasedCodebase.kt
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationManager
-import com.android.tools.metalava.model.CLASS_ESTIMATE
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultCodebase
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PackageList
-import com.android.tools.metalava.model.source.SourceCodebase
-import com.google.turbine.tree.Tree.CompUnit
-import java.io.File
-
-const val PACKAGE_ESTIMATE = 500
-
-internal open class TurbineBasedCodebase(
-    location: File,
-    description: String = "Unknown",
-    annotationManager: AnnotationManager,
-    val allowReadingComments: Boolean
-) : DefaultCodebase(location, description, false, annotationManager), SourceCodebase {
-
-    /**
-     * Map from class name to class item. Classes are added via [registerClass] while initialising
-     * the codebase
-     */
-    private lateinit var classMap: MutableMap<String, TurbineClassItem>
-
-    /** Map from package name to the corresponding package item */
-    private lateinit var packageMap: MutableMap<String, PackageItem>
-    private val hiddenPackages = mutableSetOf<String>()
-
-    /**
-     * A list of the top-level classes declared in the codebase's source (rather than on its
-     * classpath).
-     */
-    private lateinit var topLevelClassesFromSource: MutableList<ClassItem>
-
-    private lateinit var initializer: TurbineCodebaseInitialiser
-
-    override fun createAnnotation(
-        source: String,
-        context: Item?,
-    ): AnnotationItem {
-        return DefaultAnnotationItem.create(this, source)
-    }
-
-    override fun findClass(className: String): TurbineClassItem? {
-        return classMap[className]
-    }
-
-    override fun resolveClass(className: String) = findOrCreateClass(className)
-
-    fun findOrCreateClass(className: String): TurbineClassItem? {
-        return initializer.findOrCreateClass(className)
-    }
-
-    override fun findPackage(pkgName: String): PackageItem? {
-        return packageMap[pkgName]
-    }
-
-    override fun getPackages(): PackageList {
-        return PackageList(
-            this,
-            packageMap.values.toMutableList().sortedWith(PackageItem.comparator)
-        )
-    }
-
-    override fun size(): Int {
-        return packageMap.size
-    }
-
-    override fun supportsDocumentation(): Boolean = true
-
-    override fun getTopLevelClassesFromSource(): List<ClassItem> {
-        return topLevelClassesFromSource
-    }
-
-    fun registerClass(classItem: TurbineClassItem, isTopClass: Boolean) {
-        val qualifiedName = classItem.qualifiedName()
-        val existing = classMap.put(qualifiedName, classItem)
-        if (existing != null) {
-            error(
-                "Attempted to register $qualifiedName twice; once from ${existing.fileLocation.path} and this one from ${classItem.fileLocation.path}"
-            )
-        }
-
-        if (isTopClass) {
-            topLevelClassesFromSource.add(classItem)
-        }
-
-        addClass(classItem)
-    }
-
-    /**
-     * Determines if a given package name is marked as hidden.
-     *
-     * @param packageName the name of the package to check.
-     * @return true if the package is hidden, false otherwise.
-     */
-    fun isPackageHidden(packageName: String): Boolean {
-        return hiddenPackages.contains(packageName)
-    }
-
-    fun addPackage(packageItem: TurbinePackageItem) {
-        packageMap.put(packageItem.qualifiedName(), packageItem)
-    }
-
-    fun initialize(units: List<CompUnit>, classpath: List<File>, hiddenPackages: Set<String>) {
-        this.hiddenPackages.addAll(hiddenPackages)
-        topLevelClassesFromSource = ArrayList(CLASS_ESTIMATE)
-        classMap = HashMap(CLASS_ESTIMATE)
-        packageMap = HashMap(PACKAGE_ESTIMATE)
-        initializer = TurbineCodebaseInitialiser(units, this, classpath)
-        initializer.initialize()
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassItem.kt
deleted file mode 100644
index 70a56c44d..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassItem.kt
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.AnnotationRetention
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.ClassKind
-import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.PropertyItem
-import com.android.tools.metalava.model.SourceFile
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.VariableTypeItem
-import com.android.tools.metalava.model.type.DefaultResolvedClassTypeItem
-import com.android.tools.metalava.model.type.DefaultTypeModifiers
-import com.android.tools.metalava.model.type.DefaultVariableTypeItem
-import com.android.tools.metalava.model.updateCopiedMethodState
-import com.android.tools.metalava.reporter.FileLocation
-import com.google.turbine.binder.sym.ClassSymbol
-import com.google.turbine.binder.sym.MethodSymbol
-
-internal open class TurbineClassItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    private val name: String,
-    private val fullName: String,
-    private val qualifiedName: String,
-    private val classSymbol: ClassSymbol,
-    modifiers: DefaultModifierList,
-    override val classKind: ClassKind,
-    override val typeParameterList: TypeParameterList,
-    documentation: String,
-    private val source: SourceFile?
-) : TurbineItem(codebase, fileLocation, modifiers, documentation), ClassItem {
-
-    override var artifact: String? = null
-
-    override var hasPrivateConstructor: Boolean = false
-
-    override var stubConstructor: ConstructorItem? = null
-
-    internal lateinit var innerClasses: List<TurbineClassItem>
-
-    private var superClassType: ClassTypeItem? = null
-
-    private var allInterfaces: List<ClassItem>? = null
-
-    internal lateinit var containingPackage: TurbinePackageItem
-
-    internal lateinit var fields: List<TurbineFieldItem>
-
-    internal lateinit var methods: MutableList<TurbineMethodItem>
-
-    internal lateinit var constructors: List<TurbineConstructorItem>
-
-    internal var containingClass: TurbineClassItem? = null
-
-    private lateinit var interfaceTypesList: List<ClassTypeItem>
-
-    internal var hasImplicitDefaultConstructor = false
-
-    private var retention: AnnotationRetention? = null
-
-    override fun allInterfaces(): Sequence<ClassItem> {
-        if (allInterfaces == null) {
-            val interfaces = mutableSetOf<ClassItem>()
-
-            // Add self as interface if applicable
-            if (isInterface()) {
-                interfaces.add(this)
-            }
-
-            // Add all the interfaces of super class
-            superClass()?.let { supClass ->
-                supClass.allInterfaces().forEach { interfaces.add(it) }
-            }
-
-            // Add all the interfaces of direct interfaces
-            interfaceTypesList.forEach { interfaceType ->
-                val itf = interfaceType.asClass()
-                itf?.allInterfaces()?.forEach { interfaces.add(it) }
-            }
-
-            allInterfaces = interfaces.toList()
-        }
-
-        return allInterfaces!!.asSequence()
-    }
-
-    override fun constructors(): List<ConstructorItem> = constructors
-
-    override fun containingClass(): TurbineClassItem? = containingClass
-
-    override fun containingPackage(): PackageItem =
-        containingClass?.containingPackage() ?: containingPackage
-
-    override fun fields(): List<FieldItem> = fields
-
-    override fun getRetention(): AnnotationRetention {
-        retention?.let {
-            return it
-        }
-
-        if (!isAnnotationType()) {
-            error("getRetention() should only be called on annotation classes")
-        }
-
-        retention = ClassItem.findRetention(this)
-        return retention!!
-    }
-
-    override fun hasImplicitDefaultConstructor(): Boolean = hasImplicitDefaultConstructor
-
-    override fun createDefaultConstructor(): ConstructorItem {
-        val sym = MethodSymbol(0, classSymbol, name)
-        return TurbineConstructorItem.createDefaultConstructor(codebase, this, sym)
-    }
-
-    override fun hasTypeVariables(): Boolean = typeParameterList.isNotEmpty()
-
-    override fun innerClasses(): List<ClassItem> = innerClasses
-
-    override fun interfaceTypes(): List<ClassTypeItem> = interfaceTypesList
-
-    override fun methods(): List<MethodItem> = methods
-
-    /**
-     * [PropertyItem]s are kotlin specific and it is unlikely that Turbine will ever support Kotlin
-     * so just return an empty list.
-     */
-    override fun properties(): List<PropertyItem> = emptyList()
-
-    override fun simpleName(): String = name
-
-    override fun qualifiedName(): String = qualifiedName
-
-    override fun fullName(): String = fullName
-
-    override fun setInterfaceTypes(interfaceTypes: List<ClassTypeItem>) {
-        interfaceTypesList = interfaceTypes
-    }
-
-    internal fun setSuperClassType(superClassType: ClassTypeItem?) {
-        this.superClassType = superClassType
-    }
-
-    override fun superClass(): ClassItem? = superClassType?.asClass()
-
-    override fun superClassType(): ClassTypeItem? = superClassType
-
-    /** Must only be used by [type] to cache its result. */
-    private lateinit var cachedType: ClassTypeItem
-
-    override fun type(): ClassTypeItem {
-        if (!::cachedType.isInitialized) {
-            cachedType = DefaultResolvedClassTypeItem.createForClass(this)
-        }
-        return cachedType
-    }
-
-    private fun createVariableType(typeParam: TurbineTypeParameterItem): VariableTypeItem {
-        val mods = DefaultTypeModifiers.create(typeParam.modifiers.annotations())
-        return DefaultVariableTypeItem(mods, typeParam)
-    }
-
-    override fun hashCode(): Int = qualifiedName.hashCode()
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is ClassItem && qualifiedName() == other.qualifiedName()
-    }
-
-    override fun getSourceFile(): SourceFile? = source
-
-    override fun inheritMethodFromNonApiAncestor(template: MethodItem): MethodItem {
-        val method = template as TurbineMethodItem
-        val replacementMap = mapTypeVariables(method.containingClass())
-        val retType = method.returnType().convertType(replacementMap)
-        val mods = method.modifiers.duplicate()
-
-        val duplicateMethod =
-            TurbineMethodItem(
-                codebase,
-                FileLocation.UNKNOWN,
-                method.getSymbol(),
-                this,
-                retType,
-                mods,
-                method.typeParameterList,
-                method.documentation,
-                method.defaultValue(),
-            )
-
-        val params =
-            method.parameters().map {
-                TurbineParameterItem.duplicate(codebase, duplicateMethod, it, replacementMap)
-            }
-        duplicateMethod.parameters = params
-        duplicateMethod.inheritedFrom = method.containingClass()
-        duplicateMethod.throwableTypes = method.throwableTypes
-
-        duplicateMethod.updateCopiedMethodState()
-
-        return duplicateMethod
-    }
-
-    override fun addMethod(method: MethodItem) {
-        methods.add(method as TurbineMethodItem)
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
index 7bce15a1c..542f06b61 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
@@ -20,21 +20,60 @@ import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationAttribute
 import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ApiVariantSelectors
 import com.android.tools.metalava.model.BoundsTypeItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
-import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
 import com.android.tools.metalava.model.DefaultAnnotationAttribute
 import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
 import com.android.tools.metalava.model.DefaultTypeParameterList
 import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.FixedFieldValue
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.JAVA_PACKAGE_INFO
+import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
+import com.android.tools.metalava.model.ModifierFlags.Companion.DEFAULT
+import com.android.tools.metalava.model.ModifierFlags.Companion.FINAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.NATIVE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.PROTECTED
+import com.android.tools.metalava.model.ModifierFlags.Companion.PUBLIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.SEALED
+import com.android.tools.metalava.model.ModifierFlags.Companion.STATIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.STRICT_FP
+import com.android.tools.metalava.model.ModifierFlags.Companion.SYNCHRONIZED
+import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
+import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
+import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
+import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.TypeParameterListAndFactory
 import com.android.tools.metalava.model.TypeParameterScope
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.addDefaultRetentionPolicyAnnotation
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.model.createMutableModifiers
+import com.android.tools.metalava.model.findAnnotation
+import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.item.DefaultCodebaseAssembler
+import com.android.tools.metalava.model.item.DefaultCodebaseFactory
+import com.android.tools.metalava.model.item.DefaultItemFactory
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
+import com.android.tools.metalava.model.item.FieldValue
+import com.android.tools.metalava.model.item.MutablePackageDoc
+import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.model.source.SourceSet
+import com.android.tools.metalava.model.source.utils.gatherPackageJavadoc
 import com.android.tools.metalava.model.type.MethodFingerprint
 import com.android.tools.metalava.reporter.FileLocation
 import com.google.common.collect.ImmutableList
@@ -51,13 +90,13 @@ import com.google.turbine.binder.bound.TypeBoundClass.FieldInfo
 import com.google.turbine.binder.bound.TypeBoundClass.MethodInfo
 import com.google.turbine.binder.bound.TypeBoundClass.ParamInfo
 import com.google.turbine.binder.bound.TypeBoundClass.TyVarInfo
-import com.google.turbine.binder.bytecode.BytecodeBoundClass
 import com.google.turbine.binder.env.CompoundEnv
 import com.google.turbine.binder.env.SimpleEnv
 import com.google.turbine.binder.lookup.LookupKey
 import com.google.turbine.binder.lookup.TopLevelIndex
 import com.google.turbine.binder.sym.ClassSymbol
 import com.google.turbine.binder.sym.TyVarSymbol
+import com.google.turbine.diag.SourceFile
 import com.google.turbine.diag.TurbineLog
 import com.google.turbine.model.Const
 import com.google.turbine.model.Const.ArrayInitValue
@@ -66,6 +105,7 @@ import com.google.turbine.model.Const.Value
 import com.google.turbine.model.TurbineConstantTypeKind as PrimKind
 import com.google.turbine.model.TurbineFlag
 import com.google.turbine.model.TurbineTyKind
+import com.google.turbine.parse.Parser
 import com.google.turbine.processing.ModelFactory
 import com.google.turbine.processing.TurbineElements
 import com.google.turbine.processing.TurbineTypes
@@ -78,6 +118,7 @@ import com.google.turbine.tree.Tree.Ident
 import com.google.turbine.tree.Tree.Literal
 import com.google.turbine.tree.Tree.MethDecl
 import com.google.turbine.tree.Tree.TyDecl
+import com.google.turbine.tree.Tree.VarDecl
 import com.google.turbine.type.AnnoInfo
 import com.google.turbine.type.Type
 import java.io.File
@@ -91,27 +132,40 @@ import javax.lang.model.element.TypeElement
  * This is used for populating all the classes,packages and other items from the data present in the
  * parsed Tree
  */
-internal open class TurbineCodebaseInitialiser(
-    val units: List<CompUnit>,
-    val codebase: TurbineBasedCodebase,
-    val classpath: List<File>,
-) {
+internal class TurbineCodebaseInitialiser(
+    codebaseFactory: DefaultCodebaseFactory,
+    private val classpath: List<File>,
+    private val allowReadingComments: Boolean,
+) : DefaultCodebaseAssembler() {
+
+    internal val codebase = codebaseFactory(this)
+
     /** The output from Turbine Binder */
     private lateinit var bindingResult: BindingResult
 
-    /** Map between ClassSymbols and TurbineClass for classes present in source */
-    private lateinit var sourceClassMap: ImmutableMap<ClassSymbol, SourceTypeBoundClass>
-
-    /** Map between ClassSymbols and TurbineClass for classes present in classPath */
-    private lateinit var envClassMap: CompoundEnv<ClassSymbol, BytecodeBoundClass>
+    /**
+     * Map between ClassSymbols and TurbineClass for classes present on the source path or the class
+     * path
+     */
+    private lateinit var envClassMap: CompoundEnv<ClassSymbol, TypeBoundClass>
 
     private lateinit var index: TopLevelIndex
 
     /** Map between Class declaration and the corresponding source CompUnit */
-    private val classSourceMap: MutableMap<TyDecl, CompUnit> = mutableMapOf<TyDecl, CompUnit>()
-
-    private val globalTypeItemFactory =
-        TurbineTypeItemFactory(codebase, this, TypeParameterScope.empty)
+    private val classSourceMap: MutableMap<TyDecl, CompUnit> = mutableMapOf()
+
+    private val globalTypeItemFactory = TurbineTypeItemFactory(this, TypeParameterScope.empty)
+
+    /** Creates [Item] instances for [codebase]. */
+    override val itemFactory =
+        DefaultItemFactory(
+            codebase = codebase,
+            // Turbine can only process java files.
+            defaultItemLanguage = ItemLanguage.JAVA,
+            // Source files need to track which parts belong to which API surface variants, so they
+            // need to create an ApiVariantSelectors instance that can be used to track that.
+            defaultVariantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
+        )
 
     /**
      * Data Type: TurbineElements (An implementation of javax.lang.model.util.Elements)
@@ -121,12 +175,38 @@ internal open class TurbineCodebaseInitialiser(
     private lateinit var turbineElements: TurbineElements
 
     /**
-     * Binds the units with the help of Turbine's binder.
+     * Populates [codebase] from the [sourceSet].
      *
      * Then creates the packages, classes and their members, as well as sets up various class
      * hierarchies using the binder's output
      */
-    fun initialize() {
+    fun initialize(sourceSet: SourceSet) {
+        // Get the units from the source files provided on the command line.
+        val commandLineSources = sourceSet.sources
+        val sourceFiles = getSourceFiles(commandLineSources.asSequence())
+        val units = sourceFiles.map { Parser.parse(it) }
+
+        // Get the sequence of all files that can be found on the source path which are not
+        // explicitly listed on the command line.
+        val scannedFiles = scanSourcePath(sourceSet.sourcePath, commandLineSources.toSet())
+        val sourcePathFiles = getSourceFiles(scannedFiles)
+
+        // Get the set of qualified class names provided on the command line. If a `.java` file
+        // contains multiple java classes then it just used the main class name.
+        val commandLineClasses = units.mapNotNull { unit -> unit.mainClassQualifiedName }.toSet()
+
+        // Get the units for the extra source files found on the source path.
+        val extraUnits =
+            sourcePathFiles
+                .map { Parser.parse(it) }
+                // Ignore any files that contain duplicates of a class that was specified on the
+                // command line. This is needed when merging annotations from other java files as
+                // there may be duplicate definitions of the class on the source path.
+                .filter { unit -> unit.mainClassQualifiedName !in commandLineClasses }
+
+        // Combine all the units together.
+        val allUnits = ImmutableList.builder<CompUnit>().addAll(units).addAll(extraUnits).build()
+
         // Bind the units
         try {
             val procInfo =
@@ -144,189 +224,407 @@ internal open class TurbineCodebaseInitialiser(
             bindingResult =
                 Binder.bind(
                     log,
-                    ImmutableList.copyOf(units),
+                    allUnits,
                     ClassPathBinder.bindClasspath(classpath.map { it.toPath() }),
                     procInfo,
                     ClassPathBinder.bindClasspath(listOf()),
                     Optional.empty()
                 )!!
-            sourceClassMap = bindingResult.units()
-            envClassMap = bindingResult.classPathEnv()
             index = bindingResult.tli()
         } catch (e: Throwable) {
             throw e
         }
-        // maps class symbols to their source-based definitions
-        val sourceEnv = SimpleEnv<ClassSymbol, SourceTypeBoundClass>(sourceClassMap)
-        // maps class symbols to their classpath-based definitions
-        val classpathEnv: CompoundEnv<ClassSymbol, TypeBoundClass> = CompoundEnv.of(envClassMap)
-        // provides a unified view of both source and classpath classes
-        val combinedEnv = classpathEnv.append(sourceEnv)
+        // Get the SourceTypeBoundClass for all units that have been bound together.
+        val allSourceClassMap = bindingResult.units()
+
+        // Maps class symbols to their source-based definitions
+        val sourceEnv = SimpleEnv(allSourceClassMap)
+
+        // Maps class symbols to their classpath-based definitions
+        val classPathEnv = bindingResult.classPathEnv()
+
+        // Provides a unified view of both source and classpath classes. Although, the `sourceEnv`
+        // is appended to the `CompoundEnv` that contains the `classPathEnv`, it is actually
+        // queried first. So, this will search for a class on the source path first and then on the
+        // class path.
+        envClassMap = CompoundEnv.of<ClassSymbol, TypeBoundClass>(classPathEnv).append(sourceEnv)
 
         // used to create language model elements for code analysis
-        val factory = ModelFactory(combinedEnv, ClassLoader.getSystemClassLoader(), index)
+        val factory = ModelFactory(envClassMap, ClassLoader.getSystemClassLoader(), index)
         // provides type-related operations within the Turbine compiler context
         val turbineTypes = TurbineTypes(factory)
         // provides access to code elements (packages, types, members) for analysis.
         turbineElements = TurbineElements(factory, turbineTypes)
 
-        createAllPackages()
-        createAllClasses()
-    }
+        // Split all the units into package-info.java units and normal class units.
+        val (packageInfoUnits, classUnits) = allUnits.partition { it.isPackageInfo() }
+
+        // Split the map from ClassSymbol to SourceTypeBoundClass into separate package-info and
+        // normal classes.
+        val (packageInfoClasses, allSourceClasses) =
+            separatePackageInfoClassesFromRealClasses(allSourceClassMap)
+
+        val packageInfoList =
+            combinePackageInfoClassesAndUnits(packageInfoClasses, packageInfoUnits)
+
+        // Scan the files looking for package.html and overview.html files and combine that with
+        // information from package-info.java units to create a comprehensive set of package
+        // documentation just in case they are needed during package creation.
+        val packageDocs =
+            gatherPackageJavadoc(
+                codebase.reporter,
+                sourceSet,
+                packageNameFilter = { true },
+                packageInfoList
+            ) { (unit, packageName, sourceTypeBoundClass) ->
+                val source = unit.source().source()
+                val file = File(unit.source().path())
+                val fileLocation = FileLocation.forFile(file)
+                val comment = getHeaderComments(source).toItemDocumentationFactory()
 
-    private fun createAllPackages() {
-        // Root package
-        findOrCreatePackage("", null, "")
+                // Create a `TurbineSourceFile` for this unit. It is not used here but is used when
+                // creating annotations below.
+                createTurbineSourceFile(unit)
+                val annotations = createAnnotations(sourceTypeBoundClass.annotations())
 
-        for (unit in units) {
-            var doc = ""
-            var sourceFile: TurbineSourceFile? = null
-            // No class declarations. Will be a case of package-info file
-            if (unit.decls().isEmpty()) {
-                val source = unit.source().source()
-                sourceFile = TurbineSourceFile(codebase, unit)
-                doc = getHeaderComments(source)
+                val modifiers = createImmutableModifiers(VisibilityLevel.PUBLIC, annotations)
+                MutablePackageDoc(packageName, fileLocation, modifiers, comment)
             }
-            findOrCreatePackage(getPackageName(unit), sourceFile, doc)
-            unit.decls().forEach { decl -> classSourceMap.put(decl, unit) }
+
+        // Create a mapping between all the top level classes and their containing `CompUnit` so
+        // that the latter can be looked up in createClass to create a TurbineSourceFile.
+        for (unit in classUnits) {
+            unit.decls().forEach { decl -> classSourceMap[decl] = unit }
         }
+
+        // Get the map from ClassSymbol to SourceTypeBoundClass for only those classes provided on
+        // the command line as only those classes can contribute directly to the API.
+        val commandLineSourceClasses =
+            allSourceClasses.filter { (_, typeBoundClass) ->
+                val unit = classSourceMap[typeBoundClass.decl()]
+                unit !in extraUnits
+            }
+
+        createAllPackages(packageDocs)
+        createAllClasses(commandLineSourceClasses)
     }
 
     /**
-     * Searches for the package with supplied name in the codebase's package map and if not found
-     * creates the corresponding TurbinePackageItem and adds it to the package map.
+     * Get the qualified class name of the main class in a unit.
+     *
+     * If a `.java` file contains multiple java classes then the main class is the first one which
+     * is assumed to be the public class.
      */
-    private fun findOrCreatePackage(
-        name: String,
-        sourceFile: TurbineSourceFile?,
-        document: String
-    ): TurbinePackageItem {
-        val pkgItem = codebase.findPackage(name)
-        if (pkgItem != null) {
-            val turbinePkgItem = pkgItem as TurbinePackageItem
-            // Update originallyHidden status based on the documentation.
-            if (document.isNotEmpty()) {
-                turbinePkgItem.updateOriginallyHiddenStatus(document)
+    private val CompUnit.mainClassQualifiedName: String?
+        get() {
+            val pkgName = getPackageName(this)
+            return decls().firstOrNull()?.let { decl -> "$pkgName.${decl.name()}" }
+        }
+
+    private fun scanSourcePath(sourcePath: List<File>, existingSources: Set<File>): Sequence<File> {
+        val visited = mutableSetOf<String>()
+        return sourcePath
+            .asSequence()
+            .flatMap { sourceRoot ->
+                sourceRoot
+                    .walkTopDown()
+                    // The following prevents repeatedly re-entering the same directory if there is
+                    // a cycle in the files, e.g. a symlink from a subdirectory back up to an
+                    // ancestor directory.
+                    .onEnter { dir ->
+                        // Use the canonical path as each file in a cycle can be represented by an
+                        // infinite number of paths and using them would make the visited check
+                        // useless.
+                        val canonical = dir.canonicalPath
+                        return@onEnter if (canonical in visited) false
+                        else {
+                            visited += canonical
+                            true
+                        }
+                    }
+            }
+            .filter { it !in existingSources }
+    }
+
+    /**
+     * Find the TypeBoundClass for the `ClassSymbol` in the source path and if it could not find it
+     * then look in the class path. It is guaranteed to be found in one of those places as otherwise
+     * there would be no `ClassSymbol`.
+     */
+    private fun typeBoundClassForSymbol(classSymbol: ClassSymbol) = envClassMap.get(classSymbol)!!
+
+    /**
+     * Separate `package-info.java` synthetic classes from real classes.
+     *
+     * Turbine treats a `package-info.java` file as if it created a class called `package-info`.
+     * This method separates the [sourceClassMap] into two, one for the synthetic `package-info`
+     * classes and one for real classes.
+     *
+     * @param sourceClassMap the map from [ClassSymbol] to [SourceTypeBoundClass] for all classes,
+     *   real or synthetic.
+     */
+    private fun separatePackageInfoClassesFromRealClasses(
+        sourceClassMap: Map<ClassSymbol, SourceTypeBoundClass>,
+    ): Pair<Map<ClassSymbol, SourceTypeBoundClass>, Map<ClassSymbol, SourceTypeBoundClass>> {
+        val packageInfoClasses = mutableMapOf<ClassSymbol, SourceTypeBoundClass>()
+        val sourceClasses = mutableMapOf<ClassSymbol, SourceTypeBoundClass>()
+        for ((symbol, typeBoundClass) in sourceClassMap) {
+            if (symbol.simpleName() == "package-info") {
+                packageInfoClasses[symbol] = typeBoundClass
+            } else {
+                sourceClasses[symbol] = typeBoundClass
             }
-            // The hidden status will be updated automatically based on originallyHidden
-            return turbinePkgItem
-        } else {
-            val modifiers = TurbineModifierItem.create(codebase, 0, null, false)
-            val fileLocation = TurbineFileLocation.forTree(sourceFile)
-            val turbinePkgItem =
-                TurbinePackageItem.create(codebase, fileLocation, name, modifiers, document)
-            codebase.addPackage(turbinePkgItem)
-            return turbinePkgItem
         }
+        return Pair(packageInfoClasses, sourceClasses)
     }
 
-    private fun createAllClasses() {
-        for ((classSymbol, sourceBoundClass) in sourceClassMap) {
+    /**
+     * Encapsulates information needed to create a [DefaultPackageItem] in [gatherPackageJavadoc].
+     */
+    data class PackageInfoClass(
+        val unit: CompUnit,
+        val packageName: String,
+        val sourceTypeBoundClass: SourceTypeBoundClass,
+    )
+
+    /** Combine `package-info.java` synthetic classes and units */
+    private fun combinePackageInfoClassesAndUnits(
+        sourceClassMap: Map<ClassSymbol, SourceTypeBoundClass>,
+        packageInfoUnits: List<CompUnit>
+    ): List<PackageInfoClass> {
+        // Create a mapping between the package name and the unit.
+        val packageInfoMap = packageInfoUnits.associateBy { getPackageName(it) }
+
+        return sourceClassMap.entries.map { (symbol, typeBoundClass) ->
+            val packageName = symbol.packageName().replace('/', '.')
+            PackageInfoClass(
+                unit = packageInfoMap[packageName]!!,
+                packageName = packageName,
+                sourceTypeBoundClass = typeBoundClass,
+            )
+        }
+    }
+
+    /** Map from file path to the [TurbineSourceFile]. */
+    private val turbineSourceFiles = mutableMapOf<String, TurbineSourceFile>()
+
+    /**
+     * Create a [TurbineSourceFile] for the specified [compUnit].
+     *
+     * This may be called multiple times for the same [compUnit] in which case it will return the
+     * same [TurbineSourceFile]. It will throw an exception if two [CompUnit]s have the same path.
+     */
+    private fun createTurbineSourceFile(compUnit: CompUnit): TurbineSourceFile {
+        val path = compUnit.source().path()
+        val existing = turbineSourceFiles[path]
+        if (existing != null && existing.compUnit != compUnit) {
+            error("duplicate source file found for $path")
+        }
+        return TurbineSourceFile(codebase, compUnit).also { turbineSourceFiles[path] = it }
+    }
 
-            // Turbine considers package-info as class and creates one for empty packages which is
-            // not consistent with Psi
-            if (classSymbol.simpleName() == "package-info") {
+    /**
+     * Get the [TurbineSourceFile] for a [SourceFile], failing if it could not be found.
+     *
+     * A [TurbineSourceFile] must be created by [createTurbineSourceFile] before calling this.
+     */
+    private fun turbineSourceFile(sourceFile: SourceFile): TurbineSourceFile =
+        turbineSourceFiles[sourceFile.path()]
+            ?: error("unrecognized source file: ${sourceFile.path()}")
+
+    /** Check if this is for a `package-info.java` file or not. */
+    private fun CompUnit.isPackageInfo() =
+        source().path().let { it == JAVA_PACKAGE_INFO || it.endsWith("/" + JAVA_PACKAGE_INFO) }
+
+    private fun createAllPackages(packageDocs: PackageDocs) {
+        // Create packages for all the documentation packages and make sure there is a root package.
+        codebase.packageTracker.createInitialPackages(packageDocs)
+    }
+
+    private fun createAllClasses(sourceClassMap: Map<ClassSymbol, SourceTypeBoundClass>) {
+        // Iterate over all the classes in the sources.
+        for ((classSymbol, sourceBoundClass) in sourceClassMap) {
+            // Ignore nested classes, they will be created when the outer class is created.
+            if (sourceBoundClass.owner() != null) {
                 continue
             }
 
-            // Ignore inner classes, they will be created when the outer class is created.
-            if (sourceBoundClass.owner() != null) {
+            // Ignore inaccessible classes.
+            if (!sourceBoundClass.isAccessible) {
                 continue
             }
 
-            createTopLevelClassAndContents(classSymbol)
+            val classItem =
+                createTopLevelClassAndContents(
+                    classSymbol = classSymbol,
+                    sourceBoundClass,
+                    origin = ClassOrigin.COMMAND_LINE,
+                )
+            codebase.addTopLevelClassFromSource(classItem)
         }
-
-        codebase.resolveSuperTypes()
     }
 
     val ClassSymbol.isTopClass
         get() = !binaryName().contains('$')
 
     /**
-     * Create top level classes, their inner classes and all the other members.
+     * Create top level classes, their nested classes and all the other members.
      *
-     * All the classes are registered by name and so can be found by [findOrCreateClass].
+     * All the classes are registered by name and so can be found by
+     * [createClassFromUnderlyingModel].
      */
-    private fun createTopLevelClassAndContents(classSymbol: ClassSymbol) {
+    private fun createTopLevelClassAndContents(
+        classSymbol: ClassSymbol,
+        typeBoundClass: TypeBoundClass = typeBoundClassForSymbol(classSymbol),
+        origin: ClassOrigin,
+    ): ClassItem {
         if (!classSymbol.isTopClass) error("$classSymbol is not a top level class")
-        createClass(classSymbol, null, globalTypeItemFactory)
-    }
-
-    /** Tries to create a class if not already present in codebase's classmap */
-    internal fun findOrCreateClass(name: String): TurbineClassItem? {
-        var classItem = codebase.findClass(name)
-
-        if (classItem == null) {
-            // This will get the symbol for the top class even if the class name is for an inner
-            // class.
-            val topClassSym = getClassSymbol(name)
-
-            // Create the top level class, if needed, along with any inner classes and register them
-            // all by name.
-            topClassSym?.let {
-                // It is possible that the top level class has already been created but just did not
-                // contain the requested inner class so check to make sure it exists before creating
-                // it.
-                val topClassName = getQualifiedName(topClassSym.binaryName())
-                codebase.findClass(topClassName)
-                    ?: let {
-                        // Create tand register he top level class and its inner classes.
-                        createTopLevelClassAndContents(topClassSym)
-
-                        // Now try and find the actual class that was requested by name. If it
-                        // exists it
-                        // should have been created in the previous call.
-                        classItem = codebase.findClass(name)
-                    }
+        return createClass(
+            classSymbol = classSymbol,
+            typeBoundClass = typeBoundClass,
+            containingClassItem = null,
+            enclosingClassTypeItemFactory = globalTypeItemFactory,
+            origin = origin,
+        )
+    }
+
+    /** Tries to create a class from a Turbine class with [qualifiedName]. */
+    override fun createClassFromUnderlyingModel(qualifiedName: String): ClassItem? {
+        // This will get the symbol for the top class even if the class name is for a nested
+        // class.
+        val topClassSym = getClassSymbol(qualifiedName)
+
+        // Create the top level class, if needed, along with any nested classes and register
+        // them all by name.
+        topClassSym?.let {
+            // It is possible that the top level class has already been created but just did not
+            // contain the requested nested class so check to make sure it exists before
+            // creating it.
+            val topClassName = getQualifiedName(topClassSym.binaryName())
+            codebase.findClass(topClassName)
+                ?: let {
+                    // Get the origin of the class.
+                    val typeBoundClass = typeBoundClassForSymbol(topClassSym)
+                    val origin =
+                        when (typeBoundClass) {
+                            is SourceTypeBoundClass -> ClassOrigin.SOURCE_PATH
+                            else -> ClassOrigin.CLASS_PATH
+                        }
+
+                    // Create and register the top level class and its nested classes.
+                    createTopLevelClassAndContents(
+                        classSymbol = topClassSym,
+                        typeBoundClass = typeBoundClass,
+                        origin = origin,
+                    )
+
+                    // Now try and find the actual class that was requested by name. If it exists it
+                    // should have been created in the previous call.
+                    return codebase.findClass(qualifiedName)
+                }
+        }
+
+        // Could not be found.
+        return null
+    }
+
+    private fun createModifiers(flag: Int, annoInfos: List<AnnoInfo>): MutableModifierList {
+        val annotations = createAnnotations(annoInfos)
+        val modifierItem =
+            when (flag) {
+                0 -> { // No Modifier. Default modifier is PACKAGE_PRIVATE in such case
+                    createMutableModifiers(
+                        visibility = VisibilityLevel.PACKAGE_PRIVATE,
+                        annotations = annotations,
+                    )
+                }
+                else -> {
+                    createMutableModifiers(computeFlag(flag), annotations)
+                }
             }
+        modifierItem.setDeprecated(isDeprecated(annotations))
+        return modifierItem
+    }
+
+    /**
+     * Given flag value corresponding to Turbine modifiers compute the equivalent flag in Metalava.
+     */
+    private fun computeFlag(flag: Int): Int {
+        // If no visibility flag is provided, result remains 0, implying a 'package-private' default
+        // state.
+        var result = 0
+
+        if (flag and TurbineFlag.ACC_STATIC != 0) {
+            result = result or STATIC
+        }
+        if (flag and TurbineFlag.ACC_ABSTRACT != 0) {
+            result = result or ABSTRACT
+        }
+        if (flag and TurbineFlag.ACC_FINAL != 0) {
+            result = result or FINAL
+        }
+        if (flag and TurbineFlag.ACC_NATIVE != 0) {
+            result = result or NATIVE
+        }
+        if (flag and TurbineFlag.ACC_SYNCHRONIZED != 0) {
+            result = result or SYNCHRONIZED
+        }
+        if (flag and TurbineFlag.ACC_STRICT != 0) {
+            result = result or STRICT_FP
+        }
+        if (flag and TurbineFlag.ACC_TRANSIENT != 0) {
+            result = result or TRANSIENT
+        }
+        if (flag and TurbineFlag.ACC_VOLATILE != 0) {
+            result = result or VOLATILE
+        }
+        if (flag and TurbineFlag.ACC_DEFAULT != 0) {
+            result = result or DEFAULT
+        }
+        if (flag and TurbineFlag.ACC_SEALED != 0) {
+            result = result or SEALED
+        }
+        if (flag and TurbineFlag.ACC_VARARGS != 0) {
+            result = result or VARARG
         }
 
-        return classItem
+        // Visibility Modifiers
+        if (flag and TurbineFlag.ACC_PUBLIC != 0) {
+            result = result or PUBLIC
+        }
+        if (flag and TurbineFlag.ACC_PRIVATE != 0) {
+            result = result or PRIVATE
+        }
+        if (flag and TurbineFlag.ACC_PROTECTED != 0) {
+            result = result or PROTECTED
+        }
+
+        return result
+    }
+
+    private fun isDeprecated(annotations: List<AnnotationItem>?): Boolean {
+        return annotations?.any { it.qualifiedName == "java.lang.Deprecated" } ?: false
     }
 
     private fun createClass(
-        sym: ClassSymbol,
-        containingClassItem: TurbineClassItem?,
+        classSymbol: ClassSymbol,
+        typeBoundClass: TypeBoundClass = typeBoundClassForSymbol(classSymbol),
+        containingClassItem: DefaultClassItem?,
         enclosingClassTypeItemFactory: TurbineTypeItemFactory,
-    ): TurbineClassItem {
-
-        var cls: TypeBoundClass? = sourceClassMap[sym]
-        cls = if (cls != null) cls else envClassMap.get(sym)!!
-        val decl = (cls as? SourceTypeBoundClass)?.decl()
+        origin: ClassOrigin,
+    ): ClassItem {
+        val decl = (typeBoundClass as? SourceTypeBoundClass)?.decl()
 
-        val isTopClass = cls.owner() == null
-        val isFromClassPath = !(cls is SourceTypeBoundClass)
+        val isTopClass = typeBoundClass.owner() == null
 
         // Get the package item
-        val pkgName = sym.packageName().replace('/', '.')
-        val pkgItem = findOrCreatePackage(pkgName, null, "")
+        val pkgName = classSymbol.packageName().replace('/', '.')
+        val pkgItem = codebase.findOrCreatePackage(pkgName)
 
-        // Create class
-        val qualifiedName = getQualifiedName(sym.binaryName())
-        val simpleName = qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1)
-        val fullName = sym.simpleName().replace('$', '.')
-        val annotations = createAnnotations(cls.annotations())
-        val documentation = javadoc(decl)
-        val modifierItem =
-            TurbineModifierItem.create(
-                codebase,
-                cls.access(),
-                annotations,
-                isDeprecated(documentation)
-            )
-        val (typeParameters, classTypeItemFactory) =
-            createTypeParameters(
-                cls.typeParameterTypes(),
-                enclosingClassTypeItemFactory,
-                "class $qualifiedName",
-            )
         // Create the sourcefile
         val sourceFile =
-            if (isTopClass && !isFromClassPath) {
-                classSourceMap[(cls as SourceTypeBoundClass).decl()]?.let {
-                    TurbineSourceFile(codebase, it)
-                }
+            if (isTopClass && typeBoundClass is SourceTypeBoundClass) {
+                classSourceMap[typeBoundClass.decl()]?.let { createTurbineSourceFile(it) }
             } else null
         val fileLocation =
             when {
@@ -335,64 +633,69 @@ internal open class TurbineCodebaseInitialiser(
                     TurbineFileLocation.forTree(containingClassItem, decl)
                 else -> FileLocation.UNKNOWN
             }
-        val classItem =
-            TurbineClassItem(
-                codebase,
-                fileLocation,
-                simpleName,
-                fullName,
-                qualifiedName,
-                sym,
-                modifierItem,
-                getClassKind(cls.kind()),
-                typeParameters,
-                getCommentedDoc(documentation),
-                sourceFile,
+
+        // Create class
+        val qualifiedName = getQualifiedName(classSymbol.binaryName())
+        val documentation = javadoc(decl)
+        val modifierItem =
+            createModifiers(
+                typeBoundClass.access(),
+                typeBoundClass.annotations(),
+            )
+        val (typeParameters, classTypeItemFactory) =
+            createTypeParameters(
+                typeBoundClass.typeParameterTypes(),
+                enclosingClassTypeItemFactory,
+                "class $qualifiedName",
             )
-        classItem.containingClass = containingClassItem
+        val classKind = getClassKind(typeBoundClass.kind())
+
         modifierItem.setSynchronized(false) // A class can not be synchronized in java
 
-        // Setup the SuperClass
-        if (!classItem.isInterface()) {
-            val superClassType = cls.superClassType()
-            val superClassTypeItem =
-                if (superClassType == null) null
-                else classTypeItemFactory.getSuperClassType(superClassType)
-            classItem.setSuperClassType(superClassTypeItem)
+        if (classKind == ClassKind.ANNOTATION_TYPE) {
+            if (!modifierItem.hasAnnotation(AnnotationItem::isRetention)) {
+                modifierItem.addDefaultRetentionPolicyAnnotation(codebase, isKotlin = false)
+            }
         }
 
+        // Setup the SuperClass
+        val superClassType =
+            if (classKind != ClassKind.INTERFACE) {
+                typeBoundClass.superClassType()?.let { classTypeItemFactory.getSuperClassType(it) }
+            } else null
+
         // Set interface types
-        classItem.setInterfaceTypes(
-            cls.interfaceTypes().map { classTypeItemFactory.getInterfaceType(it) }
-        )
+        val interfaceTypes =
+            typeBoundClass.interfaceTypes().map { classTypeItemFactory.getInterfaceType(it) }
+
+        val classItem =
+            itemFactory.createClassItem(
+                fileLocation = fileLocation,
+                modifiers = modifierItem,
+                documentationFactory = getCommentedDoc(documentation),
+                source = sourceFile,
+                classKind = classKind,
+                containingClass = containingClassItem,
+                containingPackage = pkgItem,
+                qualifiedName = qualifiedName,
+                typeParameterList = typeParameters,
+                origin = origin,
+                superClassType = superClassType,
+                interfaceTypes = interfaceTypes,
+            )
 
         // Create fields
-        createFields(classItem, cls.fields(), classTypeItemFactory)
+        createFields(classItem, typeBoundClass.fields(), classTypeItemFactory)
 
         // Create methods
-        createMethods(classItem, cls.methods(), classTypeItemFactory)
+        createMethods(classItem, typeBoundClass.methods(), classTypeItemFactory)
 
         // Create constructors
-        createConstructors(classItem, cls.methods(), classTypeItemFactory)
-
-        // Add to the codebase
-        codebase.registerClass(classItem, isTopClass)
-
-        // Add the class to corresponding PackageItem
-        if (isTopClass) {
-            classItem.containingPackage = pkgItem
-            pkgItem.addTopClass(classItem)
-        }
-
-        // Do not emit to signature file if it is from classpath
-        if (isFromClassPath) {
-            pkgItem.emit = false
-            classItem.emit = false
-        }
+        createConstructors(classItem, typeBoundClass.methods(), classTypeItemFactory)
 
         // Create InnerClasses.
-        val children = cls.children()
-        createInnerClasses(classItem, children.values.asList(), classTypeItemFactory)
+        val children = typeBoundClass.children()
+        createNestedClasses(classItem, children.values.asList(), classTypeItemFactory)
 
         return classItem
     }
@@ -408,17 +711,25 @@ internal open class TurbineCodebaseInitialiser(
 
     /** Creates a list of AnnotationItems from given list of Turbine Annotations */
     internal fun createAnnotations(annotations: List<AnnoInfo>): List<AnnotationItem> {
-        return annotations.map { createAnnotation(it) }
+        return annotations.mapNotNull { createAnnotation(it) }
     }
 
-    private fun createAnnotation(annotation: AnnoInfo): AnnotationItem {
-        val simpleName = annotation.tree()?.let { extractNameFromIdent(it.name()) }
+    private fun createAnnotation(annotation: AnnoInfo): AnnotationItem? {
+        val tree = annotation.tree()
+        val simpleName = tree?.let { extractNameFromIdent(it.name()) }
         val clsSym = annotation.sym()
         val qualifiedName =
             if (clsSym == null) simpleName!! else getQualifiedName(clsSym.binaryName())
 
-        return DefaultAnnotationItem(codebase, qualifiedName) {
-            getAnnotationAttributes(annotation.values(), annotation.tree()?.args())
+        val fileLocation =
+            annotation
+                .source()
+                ?.let { sourceFile -> turbineSourceFile(sourceFile) }
+                ?.let { sourceFile -> TurbineFileLocation.forTree(sourceFile, tree) }
+                ?: FileLocation.UNKNOWN
+
+        return DefaultAnnotationItem.create(codebase, fileLocation, qualifiedName) {
+            getAnnotationAttributes(annotation.values(), tree?.args())
         }
     }
 
@@ -444,8 +755,14 @@ internal open class TurbineCodebaseInitialiser(
                     }
                     else -> {
                         val name = ANNOTATION_ATTR_VALUE
+                        val value =
+                            attrs[name]
+                                ?: (exp as? Literal)?.value()
+                                    ?: error(
+                                    "Cannot find value for default 'value' attribute from $exp"
+                                )
                         attributes.add(
-                            DefaultAnnotationAttribute(name, createAttrValue(attrs[name]!!, exp))
+                            DefaultAnnotationAttribute(name, createAttrValue(value, exp))
                         )
                     }
                 }
@@ -525,11 +842,10 @@ internal open class TurbineCodebaseInitialiser(
                     if (expr != null) const.elements().zip((expr as ArrayInit).exprs())
                     else const.elements().map { Pair(it, null) }
                 buildString {
-                        append("{")
-                        pairs.joinTo(this, ", ") { getSource(it.first, it.second) }
-                        append("}")
-                    }
-                    .toString()
+                    append("{")
+                    pairs.joinTo(this, ", ") { getSource(it.first, it.second) }
+                    append("}")
+                }
             }
             Kind.ENUM_CONSTANT -> getValue(const).toString()
             Kind.CLASS_LITERAL -> {
@@ -566,38 +882,42 @@ internal open class TurbineCodebaseInitialiser(
         tyParams: ImmutableMap<TyVarSymbol, TyVarInfo>,
         enclosingClassTypeItemFactory: TurbineTypeItemFactory,
         description: String,
-    ): Pair<TypeParameterList, TurbineTypeItemFactory> {
-
-        if (tyParams.isEmpty()) return Pair(TypeParameterList.NONE, enclosingClassTypeItemFactory)
+    ): TypeParameterListAndFactory<TurbineTypeItemFactory> {
 
-        // Create a list of [TypeParameterItem]s from turbine specific classes.
-        val (typeParameters, typeItemFactory) =
-            DefaultTypeParameterList.createTypeParameterItemsAndFactory(
-                enclosingClassTypeItemFactory,
-                description,
-                tyParams.toList(),
-                { (sym, tyParam) -> createTypeParameter(sym, tyParam) },
-                { typeItemFactory, item, (_, tParam) ->
-                    createTypeParameterBounds(tParam, typeItemFactory).also { item.bounds = it }
-                },
+        if (tyParams.isEmpty())
+            return TypeParameterListAndFactory(
+                TypeParameterList.NONE,
+                enclosingClassTypeItemFactory
             )
 
-        return Pair(DefaultTypeParameterList(typeParameters), typeItemFactory)
+        // Create a list of [TypeParameterItem]s from turbine specific classes.
+        return DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+            enclosingClassTypeItemFactory,
+            description,
+            tyParams.toList(),
+            { (sym, tyParam) -> createTypeParameter(sym, tyParam) },
+            { typeItemFactory, (_, tParam) -> createTypeParameterBounds(tParam, typeItemFactory) },
+        )
     }
 
     /**
-     * Create the [TurbineTypeParameterItem] without any bounds and register it so that any uses of
+     * Create the [DefaultTypeParameterItem] without any bounds and register it so that any uses of
      * it within the type bounds, e.g. `<E extends Enum<E>>`, or from other type parameters within
      * the same [TypeParameterList] can be resolved.
      */
-    private fun createTypeParameter(sym: TyVarSymbol, param: TyVarInfo): TurbineTypeParameterItem {
-        val modifiers =
-            TurbineModifierItem.create(codebase, 0, createAnnotations(param.annotations()), false)
-        val typeParamItem = TurbineTypeParameterItem(codebase, modifiers, name = sym.name())
+    private fun createTypeParameter(sym: TyVarSymbol, param: TyVarInfo): DefaultTypeParameterItem {
+        val modifiers = createModifiers(0, param.annotations())
+        val typeParamItem =
+            itemFactory.createTypeParameterItem(
+                modifiers,
+                name = sym.name(),
+                // Java does not supports reified generics
+                isReified = false,
+            )
         return typeParamItem
     }
 
-    /** Create the bounds of a [TurbineTypeParameterItem]. */
+    /** Create the bounds of a [DefaultTypeParameterItem]. */
     private fun createTypeParameterBounds(
         param: TyVarInfo,
         typeItemFactory: TurbineTypeItemFactory,
@@ -611,143 +931,143 @@ internal open class TurbineCodebaseInitialiser(
         return typeBounds.toList()
     }
 
-    /** This method sets up the inner class hierarchy. */
-    private fun createInnerClasses(
-        classItem: TurbineClassItem,
-        innerClasses: ImmutableList<ClassSymbol>,
+    /** This method sets up the nested class hierarchy. */
+    private fun createNestedClasses(
+        classItem: DefaultClassItem,
+        nestedClasses: ImmutableList<ClassSymbol>,
         enclosingClassTypeItemFactory: TurbineTypeItemFactory,
     ) {
-        classItem.innerClasses =
-            innerClasses.map { cls -> createClass(cls, classItem, enclosingClassTypeItemFactory) }
+        for (nestedClassSymbol in nestedClasses) {
+            createClass(
+                classSymbol = nestedClassSymbol,
+                containingClassItem = classItem,
+                enclosingClassTypeItemFactory = enclosingClassTypeItemFactory,
+                origin = classItem.origin,
+            )
+        }
     }
 
     /** This methods creates and sets the fields of a class */
     private fun createFields(
-        classItem: TurbineClassItem,
+        classItem: DefaultClassItem,
         fields: ImmutableList<FieldInfo>,
         typeItemFactory: TurbineTypeItemFactory,
     ) {
-        classItem.fields =
-            fields.map { field ->
-                val annotations = createAnnotations(field.annotations())
-                val flags = field.access()
-                val decl = field.decl()
-                val fieldModifierItem =
-                    TurbineModifierItem.create(
-                        codebase,
-                        flags,
-                        annotations,
-                        isDeprecated(javadoc(decl))
-                    )
-                val isEnumConstant = (flags and TurbineFlag.ACC_ENUM) != 0
-                val fieldValue = createInitialValue(field)
-                val type =
-                    typeItemFactory.getFieldType(
-                        underlyingType = field.type(),
-                        itemAnnotations = annotations,
-                        isEnumConstant = isEnumConstant,
-                        isFinal = fieldModifierItem.isFinal(),
-                        isInitialValueNonNull = {
-                            // The initial value is non-null if the value is a literal which is not
-                            // null.
-                            fieldValue.initialValue(false) != null
-                        }
-                    )
+        for (field in fields) {
+            val flags = field.access()
+            val decl = field.decl()
+            val fieldModifierItem =
+                createModifiers(
+                    flags,
+                    field.annotations(),
+                )
+            val isEnumConstant = (flags and TurbineFlag.ACC_ENUM) != 0
+            val fieldValue = createInitialValue(field)
+            val type =
+                typeItemFactory.getFieldType(
+                    underlyingType = field.type(),
+                    itemAnnotations = fieldModifierItem.annotations(),
+                    isEnumConstant = isEnumConstant,
+                    isFinal = fieldModifierItem.isFinal(),
+                    isInitialValueNonNull = {
+                        // The initial value is non-null if the value is a literal which is not
+                        // null.
+                        fieldValue.initialValue(false) != null
+                    }
+                )
 
-                val documentation = javadoc(decl)
-                val fieldItem =
-                    TurbineFieldItem(
-                        codebase,
-                        TurbineFileLocation.forTree(classItem, decl),
-                        field.name(),
-                        classItem,
-                        type,
-                        fieldModifierItem,
-                        getCommentedDoc(documentation),
-                        isEnumConstant,
-                        fieldValue,
-                    )
-                fieldItem
-            }
+            val documentation = javadoc(decl)
+            val fieldItem =
+                itemFactory.createFieldItem(
+                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
+                    modifiers = fieldModifierItem,
+                    documentationFactory = getCommentedDoc(documentation),
+                    name = field.name(),
+                    containingClass = classItem,
+                    type = type,
+                    isEnumConstant = isEnumConstant,
+                    fieldValue = fieldValue,
+                )
+
+            classItem.addField(fieldItem)
+        }
     }
 
     private fun createMethods(
-        classItem: TurbineClassItem,
+        classItem: DefaultClassItem,
         methods: List<MethodInfo>,
         enclosingClassTypeItemFactory: TurbineTypeItemFactory,
     ) {
-        val methodItems =
-            methods
-                .filter { it.sym().name() != "<init>" }
-                .map { method ->
-                    val annotations = createAnnotations(method.annotations())
-                    val decl: MethDecl? = method.decl()
-                    val methodModifierItem =
-                        TurbineModifierItem.create(
-                            codebase,
-                            method.access(),
-                            annotations,
-                            isDeprecated(javadoc(decl))
-                        )
-                    val (typeParams, methodTypeItemFactory) =
-                        createTypeParameters(
-                            method.tyParams(),
-                            enclosingClassTypeItemFactory,
-                            method.name(),
-                        )
-                    val documentation = javadoc(decl)
-                    val defaultValueExpr = getAnnotationDefaultExpression(method)
-                    val defaultValue =
-                        if (method.defaultValue() != null)
-                            extractAnnotationDefaultValue(method.defaultValue()!!, defaultValueExpr)
-                        else ""
-
-                    val parameters = method.parameters()
-                    val fingerprint = MethodFingerprint(method.name(), parameters.size)
-                    val isAnnotationElement =
-                        classItem.isAnnotationType() && !methodModifierItem.isStatic()
-                    val returnType =
-                        methodTypeItemFactory.getMethodReturnType(
-                            underlyingReturnType = method.returnType(),
-                            itemAnnotations = methodModifierItem.annotations(),
-                            fingerprint = fingerprint,
-                            isAnnotationElement = isAnnotationElement,
-                        )
+        for (method in methods) {
+            // Ignore constructors.
+            if (method.sym().name() == "<init>") continue
+
+            val decl: MethDecl? = method.decl()
+            val methodModifierItem =
+                createModifiers(
+                    method.access(),
+                    method.annotations(),
+                )
+            val name = method.name()
+            val (typeParams, methodTypeItemFactory) =
+                createTypeParameters(
+                    method.tyParams(),
+                    enclosingClassTypeItemFactory,
+                    name,
+                )
+            val documentation = javadoc(decl)
+            val defaultValueExpr = getAnnotationDefaultExpression(method)
+            val defaultValue =
+                if (method.defaultValue() != null)
+                    extractAnnotationDefaultValue(method.defaultValue()!!, defaultValueExpr)
+                else ""
+
+            val parameters = method.parameters()
+            val fingerprint = MethodFingerprint(name, parameters.size)
+            val isAnnotationElement = classItem.isAnnotationType() && !methodModifierItem.isStatic()
+            val returnType =
+                methodTypeItemFactory.getMethodReturnType(
+                    underlyingReturnType = method.returnType(),
+                    itemAnnotations = methodModifierItem.annotations(),
+                    fingerprint = fingerprint,
+                    isAnnotationElement = isAnnotationElement,
+                )
 
-                    val methodItem =
-                        TurbineMethodItem(
-                            codebase,
-                            TurbineFileLocation.forTree(classItem, decl),
-                            method.sym(),
-                            classItem,
-                            returnType,
-                            methodModifierItem,
-                            typeParams,
-                            getCommentedDoc(documentation),
-                            defaultValue,
+            val methodItem =
+                itemFactory.createMethodItem(
+                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
+                    modifiers = methodModifierItem,
+                    documentationFactory = getCommentedDoc(documentation),
+                    name = name,
+                    containingClass = classItem,
+                    typeParameterList = typeParams,
+                    returnType = returnType,
+                    parameterItemsFactory = { containingCallable ->
+                        createParameters(
+                            containingCallable,
+                            decl?.params(),
+                            parameters,
+                            methodTypeItemFactory,
                         )
-                    createParameters(
-                        methodItem,
-                        decl?.params(),
-                        parameters,
-                        methodTypeItemFactory,
-                    )
-                    methodItem.throwableTypes =
-                        getThrowsList(method.exceptions(), methodTypeItemFactory)
-                    methodItem
-                }
-        // Ignore default enum methods
-        classItem.methods =
-            methodItems.filter { !isDefaultEnumMethod(classItem, it) }.toMutableList()
+                    },
+                    throwsTypes = getThrowsList(method.exceptions(), methodTypeItemFactory),
+                    annotationDefault = defaultValue,
+                )
+
+            // Ignore enum synthetic methods.
+            if (methodItem.isEnumSyntheticMethod()) continue
+
+            classItem.addMethod(methodItem)
+        }
     }
 
     private fun createParameters(
-        methodItem: TurbineMethodItem,
-        parameterDecls: List<Tree.VarDecl>?,
+        containingCallable: CallableItem,
+        parameterDecls: List<VarDecl>?,
         parameters: List<ParamInfo>,
         typeItemFactory: TurbineTypeItemFactory,
-    ) {
-        val fingerprint = MethodFingerprint(methodItem.name(), parameters.size)
+    ): List<ParameterItem> {
+        val fingerprint = MethodFingerprint(containingCallable.name(), parameters.size)
         // Some parameters in [parameters] are implicit parameters that do not have a corresponding
         // entry in the [parameterDecls] list. The number of implicit parameters is the total
         // number of [parameters] minus the number of declared parameters [parameterDecls]. The
@@ -755,95 +1075,97 @@ internal open class TurbineCodebaseInitialiser(
         // in [parameterDecls] to the corresponding parameter in [parameters] is simply the number
         // of the implicit parameters.
         val declaredParameterOffset = parameters.size - (parameterDecls?.size ?: 0)
-        methodItem.parameters =
-            parameters.mapIndexed { idx, parameter ->
-                val annotations = createAnnotations(parameter.annotations())
-                val parameterModifierItem =
-                    TurbineModifierItem.create(codebase, parameter.access(), annotations, false)
-                val type =
-                    typeItemFactory.getMethodParameterType(
-                        underlyingParameterType = parameter.type(),
-                        itemAnnotations = annotations,
-                        fingerprint = fingerprint,
-                        parameterIndex = idx,
-                        isVarArg = parameterModifierItem.isVarArg(),
-                    )
-                // Get the [Tree.VarDecl] corresponding to the [ParamInfo], if available.
-                val decl =
-                    if (parameterDecls != null && idx >= declaredParameterOffset)
-                        parameterDecls.get(idx - declaredParameterOffset)
-                    else null
-
-                val parameterItem =
-                    TurbineParameterItem(
-                        codebase,
-                        TurbineFileLocation.forTree(methodItem.containingClass(), decl),
-                        parameter.name(),
-                        methodItem,
-                        idx,
-                        type,
-                        parameterModifierItem,
-                    )
-                parameterItem
-            }
+        return parameters.mapIndexed { idx, parameter ->
+            val parameterModifierItem =
+                createModifiers(parameter.access(), parameter.annotations()).toImmutable()
+            val type =
+                typeItemFactory.getMethodParameterType(
+                    underlyingParameterType = parameter.type(),
+                    itemAnnotations = parameterModifierItem.annotations(),
+                    fingerprint = fingerprint,
+                    parameterIndex = idx,
+                    isVarArg = parameterModifierItem.isVarArg(),
+                )
+            // Get the [Tree.VarDecl] corresponding to the [ParamInfo], if available.
+            val decl =
+                if (parameterDecls != null && idx >= declaredParameterOffset)
+                    parameterDecls.get(idx - declaredParameterOffset)
+                else null
+
+            val fileLocation =
+                TurbineFileLocation.forTree(containingCallable.containingClass(), decl)
+            val parameterItem =
+                itemFactory.createParameterItem(
+                    fileLocation = fileLocation,
+                    modifiers = parameterModifierItem,
+                    name = parameter.name(),
+                    publicNameProvider = { item ->
+                        // Java: Look for @ParameterName annotation
+                        val modifiers = item.modifiers
+                        val annotation = modifiers.findAnnotation(AnnotationItem::isParameterName)
+                        annotation?.attributes?.firstOrNull()?.value?.value()?.toString()
+                    },
+                    containingCallable = containingCallable,
+                    parameterIndex = idx,
+                    type = type,
+                    defaultValueFactory = { TurbineDefaultValue(parameterModifierItem) },
+                )
+            parameterItem
+        }
     }
 
     private fun createConstructors(
-        classItem: TurbineClassItem,
+        classItem: DefaultClassItem,
         methods: List<MethodInfo>,
         enclosingClassTypeItemFactory: TurbineTypeItemFactory,
     ) {
-        var hasImplicitDefaultConstructor = false
-        classItem.constructors =
-            methods
-                .filter { it.sym().name() == "<init>" }
-                .map { constructor ->
-                    val annotations = createAnnotations(constructor.annotations())
-                    val decl: MethDecl? = constructor.decl()
-                    val constructorModifierItem =
-                        TurbineModifierItem.create(
-                            codebase,
-                            constructor.access(),
-                            annotations,
-                            isDeprecated(javadoc(decl))
-                        )
-                    val (typeParams, constructorTypeItemFactory) =
-                        createTypeParameters(
-                            constructor.tyParams(),
-                            enclosingClassTypeItemFactory,
-                            constructor.name(),
-                        )
-                    hasImplicitDefaultConstructor =
-                        (constructor.access() and TurbineFlag.ACC_SYNTH_CTOR) != 0
-                    val name = classItem.simpleName()
-                    val documentation = javadoc(decl)
-                    val constructorItem =
-                        TurbineConstructorItem(
-                            codebase,
-                            TurbineFileLocation.forTree(classItem, decl),
-                            name,
-                            constructor.sym(),
-                            classItem,
-                            // Turbine's Binder gives return type of constructors as void but the
-                            // model expects it to the type of object being created. So, use the
-                            // containing [ClassItem]'s type as the constructor return type.
-                            classItem.type(),
-                            constructorModifierItem,
-                            typeParams,
-                            getCommentedDoc(documentation),
-                            "",
+        for (constructor in methods) {
+            // Skip real methods.
+            if (constructor.sym().name() != "<init>") continue
+
+            val decl: MethDecl? = constructor.decl()
+            val constructorModifierItem =
+                createModifiers(
+                    constructor.access(),
+                    constructor.annotations(),
+                )
+            val (typeParams, constructorTypeItemFactory) =
+                createTypeParameters(
+                    constructor.tyParams(),
+                    enclosingClassTypeItemFactory,
+                    constructor.name(),
+                )
+            val isImplicitDefaultConstructor =
+                (constructor.access() and TurbineFlag.ACC_SYNTH_CTOR) != 0
+            val name = classItem.simpleName()
+            val documentation = javadoc(decl)
+            val constructorItem =
+                itemFactory.createConstructorItem(
+                    fileLocation = TurbineFileLocation.forTree(classItem, decl),
+                    modifiers = constructorModifierItem,
+                    documentationFactory = getCommentedDoc(documentation),
+                    // Turbine's Binder gives return type of constructors as void but the
+                    // model expects it to the type of object being created. So, use the
+                    // containing [ClassItem]'s type as the constructor return type.
+                    name = name,
+                    containingClass = classItem,
+                    typeParameterList = typeParams,
+                    returnType = classItem.type(),
+                    parameterItemsFactory = { constructorItem ->
+                        createParameters(
+                            constructorItem,
+                            decl?.params(),
+                            constructor.parameters(),
+                            constructorTypeItemFactory,
                         )
-                    createParameters(
-                        constructorItem,
-                        decl?.params(),
-                        constructor.parameters(),
-                        constructorTypeItemFactory,
-                    )
-                    constructorItem.throwableTypes =
-                        getThrowsList(constructor.exceptions(), constructorTypeItemFactory)
-                    constructorItem
-                }
-        classItem.hasImplicitDefaultConstructor = hasImplicitDefaultConstructor
+                    },
+                    throwsTypes =
+                        getThrowsList(constructor.exceptions(), constructorTypeItemFactory),
+                    implicitConstructor = isImplicitDefaultConstructor,
+                )
+
+            classItem.addConstructor(constructorItem)
+        }
     }
 
     internal fun getQualifiedName(binaryName: String): String {
@@ -853,7 +1175,7 @@ internal open class TurbineCodebaseInitialiser(
     /**
      * Get the ClassSymbol corresponding to a qualified name. Since the Turbine's lookup method
      * returns only top-level classes, this method will return the ClassSymbol of outermost class
-     * for inner classes.
+     * for nested classes.
      */
     private fun getClassSymbol(name: String): ClassSymbol? {
         val result = index.scope().lookup(createLookupKey(name))
@@ -866,25 +1188,21 @@ internal open class TurbineCodebaseInitialiser(
         return LookupKey(ImmutableList.copyOf(idents))
     }
 
-    private fun javadoc(item: Tree.TyDecl?): String {
-        if (!codebase.allowReadingComments) return ""
+    private fun javadoc(item: TyDecl?): String {
+        if (!allowReadingComments) return ""
         return item?.javadoc() ?: ""
     }
 
-    private fun javadoc(item: Tree.VarDecl?): String {
-        if (!codebase.allowReadingComments) return ""
+    private fun javadoc(item: VarDecl?): String {
+        if (!allowReadingComments) return ""
         return item?.javadoc() ?: ""
     }
 
-    private fun javadoc(item: Tree.MethDecl?): String {
-        if (!codebase.allowReadingComments) return ""
+    private fun javadoc(item: MethDecl?): String {
+        if (!allowReadingComments) return ""
         return item?.javadoc() ?: ""
     }
 
-    private fun isDeprecated(javadoc: String?): Boolean {
-        return javadoc?.contains("@deprecated") ?: false
-    }
-
     private fun getThrowsList(
         throwsTypes: List<Type>,
         enclosingTypeItemFactory: TurbineTypeItemFactory
@@ -892,7 +1210,7 @@ internal open class TurbineCodebaseInitialiser(
         return throwsTypes.map { type -> enclosingTypeItemFactory.getExceptionType(type) }
     }
 
-    private fun getCommentedDoc(doc: String): String {
+    private fun getCommentedDoc(doc: String): ItemDocumentationFactory {
         return buildString {
                 if (doc != "") {
                     append("/**")
@@ -900,10 +1218,10 @@ internal open class TurbineCodebaseInitialiser(
                     append("*/")
                 }
             }
-            .toString()
+            .toItemDocumentationFactory()
     }
 
-    private fun createInitialValue(field: FieldInfo): TurbineFieldValue {
+    private fun createInitialValue(field: FieldInfo): FieldValue {
         val optExpr = field.decl()?.init()
         val expr = if (optExpr != null && optExpr.isPresent()) optExpr.get() else null
         val constantValue = field.value()?.getValue()
@@ -927,34 +1245,9 @@ internal open class TurbineCodebaseInitialiser(
                     }
             }
 
-        return TurbineFieldValue(constantValue, initialValueWithoutRequiredConstant)
+        return FixedFieldValue(constantValue, initialValueWithoutRequiredConstant)
     }
 
-    /** Determines whether the given method is a default enum method ("values" or "valueOf"). */
-    private fun isDefaultEnumMethod(classItem: ClassItem, methodItem: MethodItem): Boolean =
-        classItem.isEnum() &&
-            (methodItem.name() == "values" && isValuesMethod(classItem, methodItem) ||
-                methodItem.name() == "valueOf" && isValueOfMethod(classItem, methodItem))
-
-    /** Checks if the given method matches the signature of the "values" enum method. */
-    private fun isValuesMethod(classItem: ClassItem, methodItem: MethodItem): Boolean =
-        methodItem.returnType().let { returnType ->
-            returnType is ArrayTypeItem &&
-                matchType(returnType.componentType, classItem) &&
-                methodItem.parameters().isEmpty()
-        }
-
-    /** Checks if the given method matches the signature of the "valueOf" enum method. */
-    private fun isValueOfMethod(classItem: ClassItem, methodItem: MethodItem): Boolean =
-        matchType(methodItem.returnType(), classItem) &&
-            methodItem.parameters().singleOrNull()?.type()?.let {
-                it is ClassTypeItem && it.qualifiedName == "java.lang.String"
-            }
-                ?: false
-
-    private fun matchType(typeItem: TypeItem, classItem: ClassItem): Boolean =
-        typeItem is ClassTypeItem && typeItem.qualifiedName == classItem.qualifiedName()
-
     /**
      * Extracts the expression corresponding to the default value of a given annotation method. If
      * the method does not have a default value, returns null.
@@ -1014,3 +1307,20 @@ internal open class TurbineCodebaseInitialiser(
 
     internal fun getTypeElement(name: String): TypeElement? = turbineElements.getTypeElement(name)
 }
+
+/** Create a [SourceFile] for every `.java` file in [sources]. */
+private fun getSourceFiles(sources: Sequence<File>): List<SourceFile> {
+    return sources
+        .filter { it.isFile && it.extension == "java" } // Ensure only Java files are included
+        .map { SourceFile(it.path, it.readText()) }
+        .toList()
+}
+
+private const val ACC_PUBLIC_OR_PROTECTED = TurbineFlag.ACC_PUBLIC or TurbineFlag.ACC_PROTECTED
+
+/** Check whether the [TypeBoundClass] is accessible. */
+private val TypeBoundClass.isAccessible: Boolean
+    get() {
+        val flags = access()
+        return flags and ACC_PUBLIC_OR_PROTECTED != 0
+    }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineConstructorItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineConstructorItem.kt
deleted file mode 100644
index 320595c06..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineConstructorItem.kt
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.DefaultTypeParameterList
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.reporter.FileLocation
-import com.google.turbine.binder.sym.MethodSymbol
-
-internal class TurbineConstructorItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    private val name: String,
-    methodSymbol: MethodSymbol,
-    containingClass: TurbineClassItem,
-    returnType: ClassTypeItem,
-    modifiers: DefaultModifierList,
-    typeParameters: TypeParameterList,
-    documentation: String,
-    private val defaultValue: String,
-) :
-    TurbineMethodItem(
-        codebase,
-        fileLocation,
-        methodSymbol,
-        containingClass,
-        returnType,
-        modifiers,
-        typeParameters,
-        documentation,
-        defaultValue,
-    ),
-    ConstructorItem {
-
-    override fun name(): String = name
-
-    override var superConstructor: ConstructorItem? = null
-
-    override fun isConstructor(): Boolean = true
-
-    companion object {
-        fun createDefaultConstructor(
-            codebase: TurbineBasedCodebase,
-            containingClass: TurbineClassItem,
-            symbol: MethodSymbol
-        ): TurbineConstructorItem {
-            val name = containingClass.simpleName()
-            val modifiers = DefaultModifierList(codebase, DefaultModifierList.PACKAGE_PRIVATE, null)
-            modifiers.setVisibilityLevel(containingClass.modifiers.getVisibilityLevel())
-            val typeParameterList = DefaultTypeParameterList(emptyList())
-
-            val ctorItem =
-                TurbineConstructorItem(
-                    codebase,
-                    // Use the location of the containing class for the implicit default
-                    // constructor.
-                    containingClass.fileLocation,
-                    name,
-                    symbol,
-                    containingClass,
-                    containingClass.type(),
-                    modifiers,
-                    typeParameterList,
-                    "",
-                    "",
-                )
-            ctorItem.parameters = emptyList()
-            ctorItem.throwableTypes = emptyList()
-            return ctorItem
-        }
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineDefaultValue.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineDefaultValue.kt
new file mode 100644
index 000000000..2aa0adb77
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineDefaultValue.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ModifierList
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.findAnnotation
+import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.item.DefaultValue
+
+/** Encapsulates information about default values retrieved from the annotations. */
+class TurbineDefaultValue(private val modifiers: ModifierList) : DefaultValue {
+
+    override fun hasDefaultValue(): Boolean = isDefaultValueKnown()
+
+    override fun isDefaultValueKnown(): Boolean {
+        return modifiers.hasAnnotation(AnnotationItem::isDefaultValue)
+    }
+
+    override fun value(): String? {
+        val annotation = modifiers.findAnnotation(AnnotationItem::isDefaultValue)
+        return annotation?.attributes?.firstOrNull()?.value?.value()?.toString()
+    }
+
+    override fun duplicate(parameter: ParameterItem) = TurbineDefaultValue(parameter.modifiers)
+}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
index 041d9ee70..f8853b7b6 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
@@ -34,8 +34,9 @@ internal class TurbineEnvironmentManager() : EnvironmentManager {
         modelOptions: ModelOptions,
         allowReadingComments: Boolean,
         jdkHome: File?,
+        projectDescription: File?,
     ): SourceParser {
-        return TurbineSourceParser(annotationManager, allowReadingComments)
+        return TurbineSourceParser(reporter, annotationManager, allowReadingComments)
     }
 
     // TODO (b/299217550 implement it)
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineFieldItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineFieldItem.kt
deleted file mode 100644
index 25ac70084..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineFieldItem.kt
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TurbineFieldItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    private val name: String,
-    containingClass: ClassItem,
-    private val type: TypeItem,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    private val isEnumConstant: Boolean,
-    private val fieldValue: TurbineFieldValue?,
-) :
-    TurbineMemberItem(codebase, fileLocation, modifiers, documentation, containingClass),
-    FieldItem {
-
-    override var inheritedFrom: ClassItem? = null
-
-    override fun name(): String = name
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is FieldItem &&
-            name() == other.name() &&
-            containingClass() == other.containingClass()
-    }
-
-    override fun hashCode(): Int = name().hashCode()
-
-    override fun type(): TypeItem = type
-
-    override fun duplicate(targetContainingClass: ClassItem): FieldItem {
-        val duplicated =
-            TurbineFieldItem(
-                codebase,
-                fileLocation,
-                name(),
-                targetContainingClass,
-                type.duplicate(),
-                modifiers.duplicate(),
-                documentation,
-                isEnumConstant,
-                fieldValue,
-            )
-        duplicated.inheritedFrom = containingClass()
-
-        // Preserve flags that may have been inherited (propagated) from surrounding packages
-        if (targetContainingClass.hidden) {
-            duplicated.hidden = true
-        }
-        if (targetContainingClass.removed) {
-            duplicated.removed = true
-        }
-        if (targetContainingClass.docOnly) {
-            duplicated.docOnly = true
-        }
-
-        return duplicated
-    }
-
-    override fun initialValue(requireConstant: Boolean) = fieldValue?.initialValue(requireConstant)
-
-    override fun isEnumConstant(): Boolean = isEnumConstant
-}
-
-/** Provides access to the initial values of a field. */
-class TurbineFieldValue(
-    private var initialValueWithRequiredConstant: Any?,
-    private var initialValueWithoutRequiredConstant: Any?,
-) {
-
-    fun initialValue(requireConstant: Boolean) =
-        if (requireConstant) initialValueWithRequiredConstant
-        else initialValueWithoutRequiredConstant
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineItem.kt
deleted file mode 100644
index 81234c30f..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineItem.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.DefaultItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.source.utils.LazyDelegate
-import com.android.tools.metalava.reporter.FileLocation
-
-internal abstract class TurbineItem(
-    override val codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    modifiers: DefaultModifierList,
-    final override var documentation: String,
-    initialHiddenStatus: Boolean = false,
-) :
-    DefaultItem(
-        fileLocation = fileLocation,
-        modifiers = modifiers,
-    ) {
-
-    override var docOnly: Boolean = documentation.contains("@doconly")
-
-    override var hidden: Boolean by LazyDelegate { originallyHidden && !hasShowAnnotation() }
-
-    override var originallyHidden: Boolean by LazyDelegate {
-        documentation.contains("@hide") ||
-            documentation.contains("@pending") ||
-            hasHideAnnotation() ||
-            initialHiddenStatus
-    }
-
-    override var removed: Boolean = false
-
-    override fun appendDocumentation(comment: String, tagSection: String?, append: Boolean) {
-        TODO("b/295800205")
-    }
-
-    override fun findTagDocumentation(tag: String, value: String?): String? {
-        TODO("b/295800205")
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineMemberItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineMemberItem.kt
deleted file mode 100644
index 38c9ab434..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineMemberItem.kt
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.MemberItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal abstract class TurbineMemberItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    private val containingClass: ClassItem,
-) : TurbineItem(codebase, fileLocation, modifiers, documentation), MemberItem {
-
-    final override fun containingClass(): ClassItem = containingClass
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineMethodItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineMethodItem.kt
deleted file mode 100644
index 7f77489c7..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineMethodItem.kt
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.computeSuperMethods
-import com.android.tools.metalava.model.updateCopiedMethodState
-import com.android.tools.metalava.reporter.FileLocation
-import com.google.turbine.binder.sym.MethodSymbol
-
-internal open class TurbineMethodItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    private val methodSymbol: MethodSymbol,
-    containingClass: ClassItem,
-    private val returnType: TypeItem,
-    modifiers: DefaultModifierList,
-    override val typeParameterList: TypeParameterList,
-    documentation: String,
-    private val defaultValue: String,
-) :
-    TurbineMemberItem(codebase, fileLocation, modifiers, documentation, containingClass),
-    MethodItem {
-
-    private lateinit var superMethodList: List<MethodItem>
-    internal lateinit var throwableTypes: List<ExceptionTypeItem>
-    internal lateinit var parameters: List<ParameterItem>
-
-    override var inheritedFrom: ClassItem? = null
-
-    override fun name(): String = methodSymbol.name()
-
-    override fun parameters(): List<ParameterItem> = parameters
-
-    override fun returnType(): TypeItem = returnType
-
-    override fun throwsTypes(): List<ExceptionTypeItem> = throwableTypes
-
-    override fun isExtensionMethod(): Boolean = false // java does not support extension methods
-
-    override fun isConstructor(): Boolean = false
-
-    /**
-     * Super methods for a given method M with containing class C are calculated as follows:
-     * 1) Superclass Search: Traverse the class hierarchy, starting from C's direct superclass, and
-     *    add the first method that matches M's signature to the list.
-     * 2) Interface Supermethod Search: For each direct interface implemented by C, check if it
-     *    contains a method matching M's signature. If found, return that method. If not,
-     *    recursively apply this method to the direct interfaces of the current interface.
-     *
-     * Note: This method's implementation is based on MethodItem.matches method which only checks
-     * that name and parameter list types match. Parameter names, Return types and Throws list types
-     * are not matched
-     */
-    override fun superMethods(): List<MethodItem> {
-        if (!::superMethodList.isInitialized) {
-            superMethodList = computeSuperMethods()
-        }
-        return superMethodList
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (javaClass != other?.javaClass) return false
-
-        other as TurbineMethodItem
-
-        if (methodSymbol != other.methodSymbol) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return methodSymbol.hashCode()
-    }
-
-    @Deprecated("This property should not be accessed directly.")
-    override var _requiresOverride: Boolean? = null
-
-    override fun duplicate(targetContainingClass: ClassItem): TurbineMethodItem {
-        val retType = returnType.duplicate()
-        val mods = modifiers.duplicate()
-        val duplicated =
-            TurbineMethodItem(
-                codebase,
-                fileLocation,
-                methodSymbol,
-                targetContainingClass,
-                retType,
-                mods,
-                typeParameterList,
-                documentation,
-                defaultValue,
-            )
-        // Duplicate the parameters
-        val params =
-            parameters.map { TurbineParameterItem.duplicate(codebase, duplicated, it, emptyMap()) }
-        duplicated.parameters = params
-        duplicated.inheritedFrom = containingClass()
-        duplicated.throwableTypes = throwableTypes
-
-        // Preserve flags that may have been inherited (propagated) from surrounding packages
-        if (targetContainingClass.hidden) {
-            duplicated.hidden = true
-        }
-        if (targetContainingClass.removed) {
-            duplicated.removed = true
-        }
-        if (targetContainingClass.docOnly) {
-            duplicated.docOnly = true
-        }
-
-        duplicated.updateCopiedMethodState()
-
-        return duplicated
-    }
-
-    override fun findMainDocumentation(): String = TODO("b/295800205")
-
-    internal fun setThrowsTypes(throwsList: List<ExceptionTypeItem>) {
-        throwableTypes = throwsList
-    }
-
-    internal fun getSymbol(): MethodSymbol = methodSymbol
-
-    override fun defaultValue(): String = defaultValue
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineModifierItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineModifierItem.kt
deleted file mode 100644
index adaab9b5f..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineModifierItem.kt
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.DefaultModifierList.Companion.ABSTRACT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.DEFAULT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.FINAL
-import com.android.tools.metalava.model.DefaultModifierList.Companion.NATIVE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PRIVATE
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PROTECTED
-import com.android.tools.metalava.model.DefaultModifierList.Companion.PUBLIC
-import com.android.tools.metalava.model.DefaultModifierList.Companion.SEALED
-import com.android.tools.metalava.model.DefaultModifierList.Companion.STATIC
-import com.android.tools.metalava.model.DefaultModifierList.Companion.STRICT_FP
-import com.android.tools.metalava.model.DefaultModifierList.Companion.SYNCHRONIZED
-import com.android.tools.metalava.model.DefaultModifierList.Companion.TRANSIENT
-import com.android.tools.metalava.model.DefaultModifierList.Companion.VARARG
-import com.android.tools.metalava.model.DefaultModifierList.Companion.VOLATILE
-import com.google.turbine.model.TurbineFlag
-
-internal object TurbineModifierItem {
-    fun create(
-        codebase: Codebase,
-        flag: Int,
-        annotations: List<AnnotationItem>?,
-        isDeprecatedViaDoc: Boolean,
-    ): DefaultModifierList {
-        val modifierItem =
-            when (flag) {
-                0 -> { // No Modifier. Default modifier is PACKAGE_PRIVATE in such case
-                    DefaultModifierList(codebase, annotations = annotations?.toMutableList())
-                }
-                else -> {
-                    DefaultModifierList(codebase, computeFlag(flag), annotations?.toMutableList())
-                }
-            }
-        modifierItem.setDeprecated(isDeprecated(annotations) || isDeprecatedViaDoc)
-        return modifierItem
-    }
-
-    /**
-     * Given flag value corresponding to Turbine modifiers compute the equivalent flag in Metalava.
-     */
-    private fun computeFlag(flag: Int): Int {
-        // If no visibility flag is provided, result remains 0, implying a 'package-private' default
-        // state.
-        var result = 0
-
-        if (flag and TurbineFlag.ACC_STATIC != 0) {
-            result = result or STATIC
-        }
-        if (flag and TurbineFlag.ACC_ABSTRACT != 0) {
-            result = result or ABSTRACT
-        }
-        if (flag and TurbineFlag.ACC_FINAL != 0) {
-            result = result or FINAL
-        }
-        if (flag and TurbineFlag.ACC_NATIVE != 0) {
-            result = result or NATIVE
-        }
-        if (flag and TurbineFlag.ACC_SYNCHRONIZED != 0) {
-            result = result or SYNCHRONIZED
-        }
-        if (flag and TurbineFlag.ACC_STRICT != 0) {
-            result = result or STRICT_FP
-        }
-        if (flag and TurbineFlag.ACC_TRANSIENT != 0) {
-            result = result or TRANSIENT
-        }
-        if (flag and TurbineFlag.ACC_VOLATILE != 0) {
-            result = result or VOLATILE
-        }
-        if (flag and TurbineFlag.ACC_DEFAULT != 0) {
-            result = result or DEFAULT
-        }
-        if (flag and TurbineFlag.ACC_SEALED != 0) {
-            result = result or SEALED
-        }
-        if (flag and TurbineFlag.ACC_VARARGS != 0) {
-            result = result or VARARG
-        }
-
-        // Visibility Modifiers
-        if (flag and TurbineFlag.ACC_PUBLIC != 0) {
-            result = result or PUBLIC
-        }
-        if (flag and TurbineFlag.ACC_PRIVATE != 0) {
-            result = result or PRIVATE
-        }
-        if (flag and TurbineFlag.ACC_PROTECTED != 0) {
-            result = result or PROTECTED
-        }
-
-        return result
-    }
-
-    private fun isDeprecated(annotations: List<AnnotationItem>?): Boolean {
-        return annotations?.any { it.qualifiedName == "java.lang.Deprecated" } ?: false
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbinePackageItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbinePackageItem.kt
deleted file mode 100644
index e728e4773..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbinePackageItem.kt
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TurbinePackageItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    private val qualifiedName: String,
-    modifiers: DefaultModifierList,
-    documentation: String,
-    isInitiallyHidden: Boolean,
-) : TurbineItem(codebase, fileLocation, modifiers, documentation, isInitiallyHidden), PackageItem {
-
-    private var topClasses = mutableListOf<TurbineClassItem>()
-
-    private var containingPackage: PackageItem? = null
-
-    companion object {
-        fun create(
-            codebase: TurbineBasedCodebase,
-            fileLocation: FileLocation,
-            qualifiedName: String,
-            modifiers: DefaultModifierList,
-            documentation: String,
-        ): TurbinePackageItem {
-            val isHidden = codebase.isPackageHidden(qualifiedName)
-            if (modifiers.isPackagePrivate()) {
-                modifiers.setVisibilityLevel(VisibilityLevel.PUBLIC)
-            }
-            return TurbinePackageItem(
-                codebase,
-                fileLocation,
-                qualifiedName,
-                modifiers,
-                documentation,
-                isHidden,
-            )
-        }
-    }
-    // N.A. a package cannot be contained in a class
-    override fun containingClass(): ClassItem? = null
-
-    fun updateOriginallyHiddenStatus(documentation: String) {
-        this.originallyHidden =
-            this.originallyHidden ||
-                documentation.contains("@hide") ||
-                documentation.contains("@pending") ||
-                hasHideAnnotation()
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is PackageItem && qualifiedName == other.qualifiedName()
-    }
-
-    override fun hashCode(): Int = qualifiedName.hashCode()
-
-    override fun qualifiedName(): String = qualifiedName
-
-    override fun topLevelClasses(): Sequence<ClassItem> = topClasses.asSequence()
-
-    internal fun addTopClass(classItem: TurbineClassItem) {
-        topClasses.add(classItem)
-    }
-
-    override fun containingPackage(): PackageItem? {
-        // if this package is root package, then return null
-        return if (qualifiedName.isEmpty()) null
-        else {
-            if (containingPackage == null) {
-                // If package is of the form A.B then the containing package is A
-                // If package is top level, then containing package is the root package
-                val name = qualifiedName()
-                val lastDot = name.lastIndexOf('.')
-                containingPackage =
-                    if (lastDot != -1) codebase.findPackage(name.substring(0, lastDot))
-                    else codebase.findPackage("")
-            }
-            return containingPackage
-        }
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineParameterItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineParameterItem.kt
deleted file mode 100644
index 27d03b6dc..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineParameterItem.kt
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ParameterItem
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterBindings
-import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TurbineParameterItem(
-    codebase: TurbineBasedCodebase,
-    fileLocation: FileLocation,
-    private val name: String,
-    private val containingMethod: MethodItem,
-    override val parameterIndex: Int,
-    private val type: TypeItem,
-    modifiers: DefaultModifierList,
-) : TurbineItem(codebase, fileLocation, modifiers, ""), ParameterItem {
-
-    override fun name(): String = name
-
-    override fun publicName(): String? {
-        // Java: Look for @ParameterName annotation
-        val annotation = modifiers.findAnnotation(AnnotationItem::isParameterName)
-        return annotation?.attributes?.firstOrNull()?.value?.value()?.toString()
-    }
-
-    override fun containingMethod(): MethodItem = containingMethod
-
-    override fun hasDefaultValue(): Boolean = isDefaultValueKnown()
-
-    override fun isDefaultValueKnown(): Boolean {
-        return modifiers.hasAnnotation(AnnotationItem::isDefaultValue)
-    }
-
-    override fun defaultValue(): String? {
-        val annotation = modifiers.findAnnotation(AnnotationItem::isDefaultValue)
-        return annotation?.attributes?.firstOrNull()?.value?.value()?.toString()
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) {
-            return true
-        }
-        return other is ParameterItem &&
-            parameterIndex == other.parameterIndex &&
-            containingMethod == other.containingMethod()
-    }
-
-    override fun hashCode(): Int = parameterIndex
-
-    override fun type(): TypeItem = type
-
-    override fun isVarArgs(): Boolean = modifiers.isVarArg()
-
-    companion object {
-        internal fun duplicate(
-            codebase: TurbineBasedCodebase,
-            containingMethod: MethodItem,
-            parameter: ParameterItem,
-            typeParameterBindings: TypeParameterBindings,
-        ): TurbineParameterItem {
-            val type = parameter.type().convertType(typeParameterBindings)
-            val mods = (parameter.modifiers as DefaultModifierList).duplicate()
-            return TurbineParameterItem(
-                codebase,
-                FileLocation.UNKNOWN,
-                parameter.name(),
-                containingMethod,
-                parameter.parameterIndex,
-                type,
-                mods
-            )
-        }
-    }
-}
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
index 2a5359af7..6c06597c2 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
@@ -20,13 +20,14 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Import
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.item.DefaultCodebase
 import com.google.turbine.diag.LineMap
 import com.google.turbine.tree.Tree.CompUnit
 import java.util.TreeSet
 import java.util.function.Predicate
 
 internal class TurbineSourceFile(
-    val codebase: TurbineBasedCodebase,
+    val codebase: DefaultCodebase,
     val compUnit: CompUnit,
 ) : SourceFile {
 
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
index 5da236c28..979d73356 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
@@ -18,21 +18,19 @@ package com.android.tools.metalava.model.turbine
 
 import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassResolver
-import com.android.tools.metalava.model.source.SourceCodebase
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
-import com.android.tools.metalava.model.source.utils.findPackage
-import com.google.turbine.diag.SourceFile
-import com.google.turbine.parse.Parser
+import com.android.tools.metalava.reporter.Reporter
 import java.io.File
 
 internal class TurbineSourceParser(
+    private val reporter: Reporter,
     private val annotationManager: AnnotationManager,
     private val allowReadingComments: Boolean
 ) : SourceParser {
 
-    private val hiddenPackages = mutableSetOf<String>()
-
     override fun getClassResolver(classPath: List<File>): ClassResolver {
         TODO("implement it")
     }
@@ -45,69 +43,35 @@ internal class TurbineSourceParser(
         commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
-    ): TurbineBasedCodebase {
+    ): Codebase {
         val rootDir = sourceSet.sourcePath.firstOrNull() ?: File("").canonicalFile
-        val codebase =
-            TurbineBasedCodebase(rootDir, description, annotationManager, allowReadingComments)
-
-        identifyHiddenPackages(sourceSet.sources)
 
-        val sourceFiles = getSourceFiles(sourceSet.sources)
-        val units = sourceFiles.map { Parser.parse(it) }
-        codebase.initialize(units, classPath, hiddenPackages)
+        val assembler =
+            TurbineCodebaseInitialiser(
+                codebaseFactory = { assembler ->
+                    DefaultCodebase(
+                        location = rootDir,
+                        description = description,
+                        preFiltered = false,
+                        annotationManager = annotationManager,
+                        trustedApi = false,
+                        supportsDocumentation = true,
+                        reporter = reporter,
+                        assembler = assembler,
+                    )
+                },
+                classpath = classPath,
+                allowReadingComments = allowReadingComments,
+            )
 
-        return codebase
-    }
+        // Initialize the codebase.
+        assembler.initialize(sourceSet)
 
-    private fun getSourceFiles(sources: List<File>): List<SourceFile> {
-        return sources
-            .filter { it.isFile && it.extension == "java" } // Ensure only Java files are included
-            .map { SourceFile(it.path, it.readText()) }
+        // Return the newly created and initialized codebase.
+        return assembler.codebase
     }
 
-    override fun loadFromJar(apiJar: File): SourceCodebase {
+    override fun loadFromJar(apiJar: File): Codebase {
         TODO("b/299044569 handle this")
     }
-
-    /**
-     * Identifies directories and packages that should be hidden based on the contents of
-     * package.html files.
-     */
-    private fun identifyHiddenPackages(files: List<File>) {
-        files
-            .filter { it.isFile && it.name == "package.html" }
-            .forEach { file ->
-                val content = file.readText()
-                if (content.contains("@hide")) {
-                    val packageName = findPackageName(file)
-                    if (packageName != null) {
-                        hiddenPackages.add(packageName)
-                    }
-                }
-            }
-    }
-
-    /**
-     * Attempts to find the package name by looking for any Java class files in the same directory,
-     * if unsuccessful, it will guess based on the directory structure.
-     */
-    private fun findPackageName(file: File): String? {
-        // First try to find a package name using the utility method which might analyze the java
-        // file
-        file.parentFile
-            .listFiles()
-            ?.filter { it.isFile && it.extension == "java" }
-            ?.forEach { javaFile ->
-                findPackage(javaFile)?.let {
-                    return it
-                }
-            }
-
-        // If no class file with package declaration was found, deduce from the directory structure
-        return file.parentFile.absolutePath
-            .split(File.separatorChar)
-            .dropWhile { it != "java" }
-            .drop(1)
-            .joinToString(".")
-    }
 }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt
index 1fe1e1870..f599915ad 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeItemFactory.kt
@@ -22,8 +22,8 @@ import com.android.tools.metalava.model.ReferenceTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeModifiers
-import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterScope
+import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.type.ContextNullability
 import com.android.tools.metalava.model.type.DefaultArrayTypeItem
 import com.android.tools.metalava.model.type.DefaultClassTypeItem
@@ -41,15 +41,16 @@ import javax.lang.model.type.TypeKind
 
 /** Creates [TypeItem]s from [Type]s. */
 internal class TurbineTypeItemFactory(
-    private val codebase: TurbineBasedCodebase,
     private val initializer: TurbineCodebaseInitialiser,
     typeParameterScope: TypeParameterScope,
 ) : DefaultTypeItemFactory<Type, TurbineTypeItemFactory>(typeParameterScope) {
 
+    private val codebase: DefaultCodebase = initializer.codebase
+
     override fun self() = this
 
     override fun createNestedFactory(scope: TypeParameterScope) =
-        TurbineTypeItemFactory(codebase, initializer, scope)
+        TurbineTypeItemFactory(initializer, scope)
 
     override fun getType(
         underlyingType: Type,
@@ -65,7 +66,7 @@ internal class TurbineTypeItemFactory(
         // Compute the nullability, factoring in any context nullability and type annotations.
         // Turbine does not support kotlin so the kotlin nullability is always null.
         val nullability = contextNullability.compute(null, typeAnnotations)
-        return DefaultTypeModifiers.create(typeAnnotations.toMutableList(), nullability)
+        return DefaultTypeModifiers.create(typeAnnotations, nullability)
     }
 
     internal fun createType(
@@ -105,7 +106,7 @@ internal class TurbineTypeItemFactory(
             Type.TyKind.CLASS_TY -> {
                 type as Type.ClassTy
                 var outerClass: ClassTypeItem? = null
-                // A ClassTy is represented by list of SimpleClassTY each representing an inner
+                // A ClassTy is represented by list of SimpleClassTY each representing a nested
                 // class. e.g. , Outer.Inner.Inner1 will be represented by three simple classes
                 // Outer, Outer.Inner and Outer.Inner.Inner1
                 val iterator = type.classes().iterator()
@@ -114,7 +115,7 @@ internal class TurbineTypeItemFactory(
 
                     // Select the ContextNullability. If there is another SimpleClassTy after this
                     // then this is an outer class which can never be null, so force it to be
-                    // non-null. Otherwise, this is the inner class so use the supplied
+                    // non-null. Otherwise, this is the nested class so use the supplied
                     // ContextNullability.
                     val actualContextNullability =
                         if (iterator.hasNext()) {
@@ -126,7 +127,7 @@ internal class TurbineTypeItemFactory(
                         }
 
                     outerClass =
-                        createInnerClassType(simpleClass, outerClass, actualContextNullability)
+                        createNestedClassType(simpleClass, outerClass, actualContextNullability)
                 }
                 outerClass!!
             }
@@ -170,7 +171,7 @@ internal class TurbineTypeItemFactory(
             Type.TyKind.NONE_TY ->
                 DefaultPrimitiveTypeItem(
                     // Primitives are always non-null.
-                    DefaultTypeModifiers.create(emptyList(), TypeNullability.NONNULL),
+                    DefaultTypeModifiers.emptyNonNullModifiers,
                     PrimitiveTypeItem.Primitive.VOID
                 )
             Type.TyKind.ERROR_TY -> {
@@ -178,7 +179,7 @@ internal class TurbineTypeItemFactory(
                 type as Type.ErrorTy
                 DefaultClassTypeItem(
                     codebase,
-                    DefaultTypeModifiers.create(emptyList(), TypeNullability.UNDEFINED),
+                    DefaultTypeModifiers.emptyUndefinedModifiers,
                     type.name(),
                     emptyList(),
                     null,
@@ -265,7 +266,7 @@ internal class TurbineTypeItemFactory(
         element as TypeElement
 
         // Since this type was never part of source , it won't have any annotation or arguments
-        val modifiers = DefaultTypeModifiers.create(emptyList(), TypeNullability.NONNULL)
+        val modifiers = DefaultTypeModifiers.emptyNonNullModifiers
         val classTypeItem =
             DefaultClassTypeItem(
                 codebase,
@@ -277,7 +278,7 @@ internal class TurbineTypeItemFactory(
         return classTypeItem
     }
 
-    private fun createInnerClassType(
+    private fun createNestedClassType(
         type: Type.ClassTy.SimpleClassTy,
         outerClass: ClassTypeItem?,
         contextNullability: ContextNullability,
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeParameterItem.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeParameterItem.kt
deleted file mode 100644
index c16a25513..000000000
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineTypeParameterItem.kt
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.turbine
-
-import com.android.tools.metalava.model.BoundsTypeItem
-import com.android.tools.metalava.model.DefaultModifierList
-import com.android.tools.metalava.model.TypeNullability
-import com.android.tools.metalava.model.TypeParameterItem
-import com.android.tools.metalava.model.VariableTypeItem
-import com.android.tools.metalava.model.type.DefaultTypeModifiers
-import com.android.tools.metalava.model.type.DefaultVariableTypeItem
-import com.android.tools.metalava.reporter.FileLocation
-
-internal class TurbineTypeParameterItem(
-    codebase: TurbineBasedCodebase,
-    modifiers: DefaultModifierList,
-    private val name: String,
-) :
-    TurbineItem(
-        codebase,
-        FileLocation.UNKNOWN,
-        modifiers,
-        "",
-    ),
-    TypeParameterItem {
-
-    lateinit var bounds: List<BoundsTypeItem>
-
-    override fun name() = name
-
-    // Java does not supports reified generics
-    override fun isReified(): Boolean = false
-
-    override fun typeBounds(): List<BoundsTypeItem> = bounds
-
-    override fun type(): VariableTypeItem {
-        return DefaultVariableTypeItem(
-            DefaultTypeModifiers.create(emptyList(), TypeNullability.UNDEFINED),
-            this
-        )
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is TypeParameterItem) return false
-
-        return name == other.name()
-    }
-
-    override fun hashCode(): Int {
-        return name.hashCode()
-    }
-}
diff --git a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
index 375142f28..01d163436 100644
--- a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
@@ -2,6 +2,9 @@ com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTe
   annotation toSource() with compound expression values
   annotation toSource() with constant literal values
 
+com.android.tools.metalava.model.testsuite.classitem.CommonDuplicateClassItemTest
+  Test duplicate classes
+
 com.android.tools.metalava.model.testsuite.fielditem.CommonFieldItemTest
   Test implicit nullability of constant field initialized from @NonNull method
 
@@ -13,9 +16,6 @@ com.android.tools.metalava.model.testsuite.methoditem.CommonParameterItemTest
   Test publicName reports correct name when called on binary class - Object#equals
   Test publicName reports correct name when called on binary class - ViewGroup#onLayout
 
-com.android.tools.metalava.model.testsuite.packageitem.CommonPackageItemTest
-  Test nullability annotation in package info
-
 com.android.tools.metalava.model.testsuite.typeitem.CommonIsAssignableFromTest
   Test assignability without unboxing[boxedInt to primitiveInt]
   Test assignability without unboxing[number to boxedInt]
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
index 93f0b26dc..8cc651b9d 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
@@ -30,3 +30,5 @@ const val ANDROIDX_NONNULL = "androidx.annotation.NonNull"
 const val ANDROIDX_NULLABLE = "androidx.annotation.Nullable"
 
 const val ANDROID_DEPRECATED_FOR_SDK = "android.annotation.DeprecatedForSdk"
+
+const val ANDROIDX_REQUIRES_PERMISSION = "androidx.annotation.RequiresPermission"
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
index 15a00078b..b66e1f679 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
@@ -185,6 +185,13 @@ data class Showability(
      */
     fun showForStubsOnly() = forStubsOnly.show(revertItem)
 
+    /**
+     * Check whether the annotations on this item affect nested `Item`s.
+     *
+     * Returns `true` if they do, `false` if they do not affect nested `Item`s.
+     */
+    fun showRecursive() = recursive.show(revertItem) || forStubsOnly.show(revertItem)
+
     /**
      * Check whether the annotations on this item only affect the current `Item`.
      *
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
index 16e7259fc..354a02cd3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.reporter.FileLocation
 import kotlin.reflect.KClass
 
 fun isNullnessAnnotation(qualifiedName: String): Boolean =
@@ -40,11 +41,19 @@ fun isJvmSyntheticAnnotation(qualifiedName: String): Boolean {
     return qualifiedName == "kotlin.jvm.JvmSynthetic"
 }
 
-interface AnnotationItem {
+sealed interface AnnotationItem {
     val codebase: Codebase
 
+    /**
+     * The location of this annotation with the source file.
+     *
+     * Will be [FileLocation.UNKNOWN] if the location cannot be determined, e.g. because it is from
+     * a `.class` file.
+     */
+    val fileLocation: FileLocation
+
     /** Fully qualified name of the annotation */
-    val qualifiedName: String?
+    val qualifiedName: String
 
     /**
      * Determines the effect that this will have on whether an item annotated with this annotation
@@ -83,12 +92,12 @@ interface AnnotationItem {
 
     /** True if this annotation represents @JvmSynthetic */
     fun isJvmSynthetic(): Boolean {
-        return isJvmSyntheticAnnotation(qualifiedName ?: return false)
+        return isJvmSyntheticAnnotation(qualifiedName)
     }
 
     /** True if this annotation represents @IntDef, @LongDef or @StringDef */
     fun isTypeDefAnnotation(): Boolean {
-        val name = qualifiedName ?: return false
+        val name = qualifiedName
         if (!(name.endsWith("Def"))) {
             return false
         }
@@ -105,7 +114,7 @@ interface AnnotationItem {
      * annotation). The parameter name should be the default attribute or "value".
      */
     fun isParameterName(): Boolean {
-        return qualifiedName?.endsWith(".ParameterName") ?: return false
+        return qualifiedName.endsWith(".ParameterName")
     }
 
     /**
@@ -113,7 +122,7 @@ interface AnnotationItem {
      * annotation). The default value should be the default attribute or "value".
      */
     fun isDefaultValue(): Boolean {
-        return qualifiedName?.endsWith(".DefaultValue") ?: return false
+        return qualifiedName.endsWith(".DefaultValue")
     }
 
     /** Returns the given named attribute if specified */
@@ -188,13 +197,16 @@ interface AnnotationItem {
             return AnnotationRetention.getDefault()
         }
 
+    /** Take a snapshot of this [AnnotationItem] suitable for use in [Codebase]. */
+    fun snapshot(targetCodebase: Codebase): AnnotationItem
+
     companion object {
         /**
          * The simple name of an annotation, which is the annotation name (not qualified name)
          * prefixed by @
          */
         fun simpleName(item: AnnotationItem): String {
-            return item.qualifiedName?.let { "@${it.substringAfterLast('.')}" }.orEmpty()
+            return item.qualifiedName.let { "@${it.substringAfterLast('.')}" }
         }
 
         /**
@@ -323,7 +335,7 @@ internal fun <T : Any> AnnotationItem.nonInlineGetAttributeValues(
             else -> listOfNotNull(attributeValue.value())
         }
 
-    return values.map { caster(convertValue(codebase, kClass, it)) }
+    return values.mapNotNull { convertValue(codebase, kClass, it) }.map { caster(it) }
 }
 
 /**
@@ -333,7 +345,7 @@ internal fun <T : Any> AnnotationItem.nonInlineGetAttributeValues(
  * simply returns the value it is given. It is the caller's responsibility to actually cast the
  * returned value to the correct type.
  */
-private fun convertValue(codebase: Codebase, kClass: KClass<*>, value: Any): Any {
+private fun convertValue(codebase: Codebase, kClass: KClass<*>, value: Any): Any? {
     // The value stored for number types is not always the same as the type of the annotation
     // attributes. This is for a number of reasons, e.g.
     // * In a .class file annotation values are stored in the constant pool and some number types do
@@ -368,35 +380,20 @@ private fun convertValue(codebase: Codebase, kClass: KClass<*>, value: Any): Any
 /** Default implementation of an annotation item */
 open class DefaultAnnotationItem
 /** The primary constructor is private to force sub-classes to use the secondary constructor. */
-private constructor(
+protected constructor(
     override val codebase: Codebase,
+    override val fileLocation: FileLocation,
 
     /** Fully qualified name of the annotation (prior to name mapping) */
-    protected val originalName: String?,
+    protected val originalName: String,
 
     /** Fully qualified name of the annotation (after name mapping) */
-    final override val qualifiedName: String?,
+    final override val qualifiedName: String,
 
     /** Possibly empty list of attributes. */
     attributesGetter: () -> List<AnnotationAttribute>,
 ) : AnnotationItem {
 
-    /**
-     * This constructor is needed to initialize [qualifiedName] using the [codebase] parameter
-     * instead of the [DefaultAnnotationItem.codebase] property which is overridden by subclasses
-     * and will not be initialized at the time it is used.
-     */
-    constructor(
-        codebase: Codebase,
-        originalName: String?,
-        attributesGetter: () -> List<AnnotationAttribute>,
-    ) : this(
-        codebase,
-        originalName,
-        qualifiedName = codebase.annotationManager.normalizeInputName(originalName),
-        attributesGetter,
-    )
-
     override val targets: Set<AnnotationTarget> by lazy {
         codebase.annotationManager.computeTargets(this, codebase::findClass)
     }
@@ -425,16 +422,12 @@ private constructor(
         get() = info.showability
 
     override fun resolve(): ClassItem? {
-        return codebase.findClass(originalName ?: return null)
+        return codebase.resolveClass(originalName)
     }
 
     /** If this annotation has a typedef annotation associated with it, return it */
     override fun findTypedefAnnotation(): AnnotationItem? {
-        val className = originalName ?: return null
-        return codebase
-            .findClass(className)
-            ?.modifiers
-            ?.findAnnotation(AnnotationItem::isTypeDefAnnotation)
+        return resolve()?.modifiers?.findAnnotation(AnnotationItem::isTypeDefAnnotation)
     }
 
     override fun isShowAnnotation(): Boolean = info.showability.show()
@@ -447,13 +440,24 @@ private constructor(
 
     override fun isShowabilityAnnotation(): Boolean = info.showability != Showability.NO_EFFECT
 
+    override fun snapshot(targetCodebase: Codebase): AnnotationItem {
+        return DefaultAnnotationItem(
+            targetCodebase,
+            fileLocation,
+            originalName,
+            qualifiedName,
+        ) {
+            attributes.map { DefaultAnnotationAttribute(it.name, it.value.snapshot()) }
+        }
+    }
+
     override fun equals(other: Any?): Boolean {
         if (other !is AnnotationItem) return false
         return qualifiedName == other.qualifiedName && attributes == other.attributes
     }
 
     override fun hashCode(): Int {
-        var result = qualifiedName?.hashCode() ?: 0
+        var result = qualifiedName.hashCode()
         result = 31 * result + attributes.hashCode()
         return result
     }
@@ -496,7 +500,7 @@ private constructor(
             }
         }
 
-        fun create(codebase: Codebase, source: String): AnnotationItem {
+        fun create(codebase: Codebase, source: String): AnnotationItem? {
             val index = source.indexOf("(")
             val originalName =
                 if (index == -1) source.substring(1) // Strip @
@@ -511,7 +515,7 @@ private constructor(
                     )
                 }
 
-            return DefaultAnnotationItem(codebase, originalName, ::attributes)
+            return create(codebase, FileLocation.UNKNOWN, originalName, ::attributes)
         }
 
         fun create(
@@ -519,10 +523,31 @@ private constructor(
             originalName: String,
             attributes: List<AnnotationAttribute> = emptyList(),
             context: Item? = null
-        ): AnnotationItem {
+        ): AnnotationItem? {
             val source = formatAnnotationItem(originalName, attributes)
             return codebase.createAnnotation(source, context)
         }
+
+        /**
+         * Create a [DefaultAnnotationItem] by mapping the [originalName] to a [qualifiedName] by
+         * using the [codebase]'s [AnnotationManager.normalizeInputName].
+         */
+        fun create(
+            codebase: Codebase,
+            fileLocation: FileLocation,
+            originalName: String,
+            attributesGetter: () -> List<AnnotationAttribute>,
+        ): AnnotationItem? {
+            val qualifiedName =
+                codebase.annotationManager.normalizeInputName(originalName) ?: return null
+            return DefaultAnnotationItem(
+                codebase = codebase,
+                fileLocation = fileLocation,
+                originalName = originalName,
+                qualifiedName = qualifiedName,
+                attributesGetter = attributesGetter,
+            )
+        }
     }
 }
 
@@ -530,7 +555,7 @@ private constructor(
 const val ANNOTATION_ATTR_VALUE = "value"
 
 /** An attribute of an annotation, such as "value" */
-interface AnnotationAttribute {
+sealed interface AnnotationAttribute {
     /** The name of the annotation */
     val name: String
     /** The annotation value */
@@ -551,7 +576,7 @@ const val ANNOTATION_VALUE_FALSE = "false"
 const val ANNOTATION_VALUE_TRUE = "true"
 
 /** An annotation value */
-interface AnnotationAttributeValue {
+sealed interface AnnotationAttributeValue {
     /** Generates source code for this annotation value */
     fun toSource(): String
 
@@ -563,6 +588,11 @@ interface AnnotationAttributeValue {
      */
     fun resolve(): Item?
 
+    /**
+     * Take a snapshot of this [AnnotationAttributeValue] suitable for use in a snapshot [Codebase].
+     */
+    fun snapshot(): AnnotationAttributeValue
+
     companion object {
         fun addValues(
             value: AnnotationAttributeValue,
@@ -580,14 +610,14 @@ interface AnnotationAttributeValue {
 }
 
 /** An annotation value (for a single item, not an array) */
-interface AnnotationSingleAttributeValue : AnnotationAttributeValue {
+sealed interface AnnotationSingleAttributeValue : AnnotationAttributeValue {
     val value: Any?
 
     override fun value() = value
 }
 
 /** An annotation value for an array of items */
-interface AnnotationArrayAttributeValue : AnnotationAttributeValue {
+sealed interface AnnotationArrayAttributeValue : AnnotationAttributeValue {
     /** The annotation values */
     val values: List<AnnotationAttributeValue>
 
@@ -757,6 +787,18 @@ open class DefaultAnnotationSingleAttributeValue(
 
     override fun resolve(): Item? = null
 
+    override fun snapshot(): AnnotationSingleAttributeValue {
+        // Take a snapshot of the value and sources by immediately forcing them to be initialized
+        // from their respective getters. That way there will be no connection to the original
+        // attribute value.
+        val newValue = value
+        val newSource = toSource()
+        return DefaultAnnotationSingleAttributeValue(
+            sourceGetter = { newSource },
+            valueGetter = { newValue },
+        )
+    }
+
     override fun equals(other: Any?): Boolean {
         if (other !is AnnotationSingleAttributeValue) return false
         return value == other.value
@@ -774,6 +816,18 @@ class DefaultAnnotationArrayAttributeValue(
 
     override val values by lazy(LazyThreadSafetyMode.NONE, valuesGetter)
 
+    override fun snapshot(): AnnotationArrayAttributeValue {
+        // Take a snapshot of the values and sources by immediately forcing them to be initialized
+        // from their respective getters. That way there will be no connection to the original
+        // attribute value.
+        val newValues = values.map { it.snapshot() }
+        val newSource = toSource()
+        return DefaultAnnotationArrayAttributeValue(
+            sourceGetter = { newSource },
+            valuesGetter = { newValues },
+        )
+    }
+
     override fun equals(other: Any?): Boolean {
         if (other !is AnnotationArrayAttributeValue) return false
         return values == other.values
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
index 96a7c71cf..c712fd4b1 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
@@ -88,12 +88,6 @@ interface AnnotationManager {
     val typedefMode: TypedefMode
 }
 
-/**
- * The default empty [AnnotationInfo] used when a more applicable one cannot be created, e.g. when
- * the [AnnotationItem.qualifiedName] is `null`.
- */
-private val noInfoAvailable = AnnotationInfo(qualifiedName = "")
-
 /** Base class for [AnnotationManager] instances. */
 abstract class BaseAnnotationManager : AnnotationManager {
 
@@ -104,7 +98,6 @@ abstract class BaseAnnotationManager : AnnotationManager {
     private val annotationKeyToInfo = mutableMapOf<String, AnnotationInfo>()
 
     override fun getAnnotationInfo(annotation: AnnotationItem): AnnotationInfo {
-        annotation.qualifiedName ?: return noInfoAvailable
         val key = getKeyForAnnotationItem(annotation)
         val existing = annotationKeyToInfo[key]
         if (existing != null) {
@@ -156,11 +149,11 @@ internal class NoOpAnnotationManager : BaseAnnotationManager() {
     override fun getKeyForAnnotationItem(annotationItem: AnnotationItem): String {
         // Just use the qualified name as the key as [computeAnnotationInfo] does not use anything
         // else.
-        return annotationItem.qualifiedName!!
+        return annotationItem.qualifiedName
     }
 
     override fun computeAnnotationInfo(annotationItem: AnnotationItem): AnnotationInfo {
-        return AnnotationInfo(annotationItem.qualifiedName!!)
+        return AnnotationInfo(annotationItem.qualifiedName)
     }
 
     override fun normalizeInputName(qualifiedName: String?): String? {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ApiVariantSelectors.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ApiVariantSelectors.kt
new file mode 100644
index 000000000..0a0e09e7b
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ApiVariantSelectors.kt
@@ -0,0 +1,626 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import com.android.tools.metalava.reporter.Issues
+
+/** A factory that will create an [ApiVariantSelectors] for a specific [Item]. */
+typealias ApiVariantSelectorsFactory = (Item) -> ApiVariantSelectors
+
+/** Contains properties that select which, if any, variant of an API an [Item] belongs in. */
+sealed class ApiVariantSelectors {
+    /**
+     * Indicates whether the item was explicitly hidden in the source, e.g. via an `@hide` javadoc
+     * tag in its [Item.documentation], or a hide annotation directly on the [Item].
+     */
+    abstract val originallyHidden: Boolean
+
+    /**
+     * Indicates whether children of an [Item] should be hidden, i.e. should not be included in ANY
+     * API surface variant.
+     *
+     * Initially set to [originallyHidden] but updated due to inheritance.
+     */
+    internal abstract val inheritableHidden: Boolean
+
+    /**
+     * Indicates whether the [Item] is accessible, and its enclosing classes are accessible.
+     *
+     * An [Item] is accessible if it is either `public` or `protected`. In Kotlin it is also
+     * accessible if it is `internal` as long as it is annotated with `@PublishedApi`. However, that
+     * annotation is not treated specially in Metalava, instead it relies on the user to specify
+     * `@PublishedApi` as a show annotation and this just assumes that any show annotation is enough
+     * to make it accessible.
+     */
+    abstract val accessible: Boolean
+
+    /**
+     * Indicates whether the [Item] should be hidden, i.e. should not be included in ANY API surface
+     * variant.
+     *
+     * Initially set to [inheritableHidden] but updated due to show annotations.
+     */
+    abstract val hidden: Boolean
+
+    /**
+     * Indicates whether the [Item] should be included in the doc only API surface variant.
+     *
+     * Initially set to `true` if the [Item.documentation] contains `@doconly` but updated due to
+     * inheritance.
+     */
+    abstract val docOnly: Boolean
+
+    /**
+     * Indicates whether the [Item] should be in the removed API surface variant.
+     *
+     * Initially set to `true` if the [Item.documentation] contains `@removed` but updated due to
+     * inheritance.
+     */
+    abstract val removed: Boolean
+
+    /** Determines whether this item will be shown as part of the API or not. */
+    abstract val showability: Showability
+
+    /** Create a duplicate of this for the specified [Item]. */
+    abstract fun duplicate(item: Item): ApiVariantSelectors
+
+    /**
+     * Update the mutable properties of this by inheriting state from the parent selectors, if
+     * available.
+     */
+    abstract fun inheritInto()
+
+    companion object {
+        /**
+         * An [ApiVariantSelectors] factory that will always return an immutable
+         * [ApiVariantSelectors]. It will return `false` for all the properties and throw an error
+         * on any attempt to set a property.
+         */
+        val IMMUTABLE_FACTORY: ApiVariantSelectorsFactory = { Immutable }
+
+        /**
+         * An [ApiVariantSelectors] factory that will return a new, mutable, [ApiVariantSelectors]
+         * for each [SelectableItem].
+         *
+         * This cannot be used on an [Item] that is not a [SelectableItem], use [IMMUTABLE_FACTORY]
+         * instead.
+         */
+        val MUTABLE_FACTORY: ApiVariantSelectorsFactory = {
+            if (it is SelectableItem) Mutable(it)
+            else error("Cannot create Mutable for non-SelectableItem, use Immutable instead")
+        }
+    }
+
+    /**
+     * An immutable [ApiVariantSelectors] that will return `false` for all the properties and fail
+     * on any attempt to set the `var` properties.
+     */
+    @Suppress("ConvertObjectToDataObject") // Requires language level 1.9
+    private object Immutable : ApiVariantSelectors() {
+
+        override val originallyHidden: Boolean
+            get() = false
+
+        override val inheritableHidden: Boolean
+            get() = false
+
+        /**
+         * Defaults to `true` as this is used by `Item`s loaded from an API signature file which
+         * typically only contains accessible `Item`s. It is possible that it could contain
+         * inaccessible `Item`s but at the moment that is not supported.
+         */
+        override val accessible: Boolean
+            get() = true
+
+        override val hidden: Boolean
+            get() = false
+
+        override val docOnly: Boolean
+            get() = false
+
+        override var removed: Boolean
+            get() = false
+            set(value) {
+                error("Cannot set `removed` to $value")
+            }
+
+        override val showability: Showability
+            get() = Showability.NO_EFFECT
+
+        override fun duplicate(item: Item): ApiVariantSelectors = this
+
+        override fun inheritInto() = error("Cannot inheritInto() $this")
+
+        override fun toString() = "Immutable"
+    }
+
+    /**
+     * A mutable [ApiVariantSelectors].
+     *
+     * [originallyHidden] will be `true` if it's [item]'s documentation contains one of `@hide`,
+     * `@pending` or `@suppress` or its [SelectableItem] has a hide annotation associated with it.
+     *
+     * Unless [hidden] is written before reading then it will default to `true` if
+     * [originallyHidden] is `true` and it does not have any show annotations.
+     *
+     * [docOnly] will be initialized to `true` if it's [item]'s documentation contains `@doconly`.
+     *
+     * [removed] will be initialized to `true` if it's [item]'s documentation contains `@removed`.
+     *
+     * This uses bits in [propertyHasBeenSetBits] and [propertyValueBits] to handle lazy
+     * initialization and store the value. The main purpose of using bit masks is not primarily
+     * performance or to reduce storage (although keeping that down is a factor) but rather to
+     * support lazy initialization with optional setters without duplicating lots of complicated
+     * code.
+     */
+    private class Mutable(private val item: SelectableItem) : ApiVariantSelectors() {
+
+        /**
+         * Contains a bit for each lazy boolean property indicating whether it has been set, either
+         * implicitly during initialization or explicitly via its setter.
+         *
+         * If a bit is set in here then the corresponding bit in [propertyValueBits] contains the
+         * value.
+         */
+        private var propertyHasBeenSetBits = 0
+
+        /**
+         * Contains a bit for each lazy boolean property indicating its value.
+         *
+         * A bit in here represents the value of the property if and only if the corresponding bit
+         * has been set in [propertyHasBeenSetBits]. Otherwise, the value of the bit is undefined.
+         */
+        private var propertyValueBits = 0
+
+        /**
+         * Get the value of a property from [propertyValueBits], initializing it if it has not yet
+         * been set.
+         *
+         * @param propertyBitMask the bit mask in [propertyHasBeenSetBits] and [propertyValueBits]
+         *   which indicates whether the associated property's value has been set and if so what its
+         *   value is.
+         * @param initialValueProvider a lambda which returns the initial value of the property if
+         *   it has not yet been set.
+         */
+        private inline fun lazyGet(propertyBitMask: Int, initialValueProvider: () -> Boolean) =
+            // Check to see if the property has been set first before accessing the value.
+            if ((propertyHasBeenSetBits and propertyBitMask) == 0) {
+                // The property has not been set so get the initial value and store it.
+                val result = initialValueProvider()
+                // Record that the property has been set.
+                propertyHasBeenSetBits = propertyHasBeenSetBits or propertyBitMask
+                // Record the value.
+                if (result) propertyValueBits = propertyValueBits or propertyBitMask
+                // Return the result.
+                result
+            } else {
+                // The property has been set so get its value.
+                (propertyValueBits and propertyBitMask) != 0
+            }
+
+        /**
+         * Like [lazyGet] except that if the flag is not set it will invoke [inheritInto] if it has
+         * not already been called. It will then check to see if the property has been set and if it
+         * has then the value will be returned. Otherwise, it will invoke the [initialValueProvider]
+         * just as [lazyGet] does.
+         */
+        private inline fun lazyGetAfterInherit(
+            propertyBitMask: Int,
+            initialValueProvider: () -> Boolean
+        ): Boolean {
+            if ((propertyHasBeenSetBits and propertyBitMask) == 0) {
+                // The property has not been set so first call `inheritInto()` to give it a chance
+                // to initialize the property. It will return immediately if it had nothing to do.
+                inheritInto()
+
+                // At this point inheritInfo may have been called and may have set the property,
+                // but it also may not so check again and if it has not then set it to its initial
+                // value.
+                return lazyGet(propertyBitMask, initialValueProvider)
+            } else {
+                // The property has been set so return its value.
+                return (propertyValueBits and propertyBitMask) != 0
+            }
+        }
+
+        /**
+         * Set the value of a property in [propertyValueBits], skipping initializing it that has not
+         * already been done.
+         *
+         * @param propertyBitMask the bit mask in [propertyHasBeenSetBits] and [propertyValueBits]
+         *   which indicates whether the associated property's value has been set and if so what its
+         *   value is.
+         * @param value the new value of the property.
+         */
+        private fun lazySet(propertyBitMask: Int, value: Boolean) {
+            // Record that the property has been set.
+            propertyHasBeenSetBits = propertyHasBeenSetBits or propertyBitMask
+            if (value) {
+                // The value is true so set the bit.
+                propertyValueBits = propertyValueBits or propertyBitMask
+            } else {
+                // The value is false so clear the bit.
+                propertyValueBits = propertyValueBits and propertyBitMask.inv()
+            }
+        }
+
+        override val originallyHidden: Boolean
+            get() =
+                lazyGet(ORIGINALLY_HIDDEN_BIT_MASK) {
+                    // The item is originally hidden if the javadoc contains @hide or similar, or
+                    // it is tagged with a hide annotation. That is true even if the hide annotation
+                    // is superseded by a show annotation.
+                    item.documentation.isHidden || item.hasHideAnnotation()
+                }
+
+        override var inheritableHidden: Boolean
+            get() =
+                lazyGetAfterInherit(INHERITABLE_HIDDEN_BIT_MASK) {
+                    // By default, i.e. if the property has not been set, the contents of this item
+                    // will be hidden if this item was originally hidden and this item did not have
+                    // a show annotation that applies recursively to its contents. Otherwise, the
+                    // item's contents will be visible.
+                    originallyHidden && !showability.showRecursive()
+                }
+            set(value) {
+                lazySet(INHERITABLE_HIDDEN_BIT_MASK, value)
+            }
+
+        override val accessible: Boolean
+            get() =
+                lazyGet(ACCESSIBLE_BIT_MASK) {
+                    when (item) {
+                        // Packages are always accessible.
+                        is PackageItem -> true
+                        else ->
+                            // This is accessible if it is public, protected or internal (with show
+                            // annotation) and none of its containing classes, if any, are
+                            // inaccessible.
+                            (item.isPublic ||
+                                item.isProtected ||
+                                (item.isInternal && showability.show())) &&
+                                item.containingClass()?.variantSelectors?.accessible != false
+                    }
+                }
+
+        override var hidden: Boolean
+            get() =
+                lazyGetAfterInherit(HIDDEN_BIT_MASK) {
+                    // By default, i.e. if the property has not been set, this item will be hidden
+                    // if it inherits hidden from its parent (or was originally hidden) and this
+                    // item does not have a show annotation of any sort. Otherwise, this item is
+                    // visible.
+                    inheritableHidden && !showability.show()
+                }
+            set(value) {
+                lazySet(HIDDEN_BIT_MASK, value)
+            }
+
+        override val docOnly: Boolean
+            get() =
+                lazyGet(DOCONLY_BIT_MASK) {
+                    (item.parent()?.variantSelectors?.docOnly == true) ||
+                        item.documentation.isDocOnly
+                }
+
+        override var removed: Boolean
+            get() =
+                lazyGet(REMOVED_BIT_MASK) {
+                    (item.parent()?.variantSelectors?.removed == true) ||
+                        item.documentation.isRemoved
+                }
+            // This is only used for testing.
+            set(value) {
+                lazySet(REMOVED_BIT_MASK, value)
+            }
+
+        /** Cache of [showability]. */
+        internal var _showability: Showability? = null
+
+        override val showability: Showability
+            get() =
+                _showability
+                    ?: let {
+                        _showability = item.codebase.annotationManager.getShowabilityForItem(item)
+                        _showability!!
+                    }
+
+        override fun duplicate(item: Item): ApiVariantSelectors = Mutable(item as SelectableItem)
+
+        /**
+         * Records whether [inheritInto] was called as it must only be called once.
+         *
+         * This uses [lazyGet] and [lazySet] to be consistent with other properties and makes it
+         * easy to include the information in the [toString] result.
+         */
+        internal var inheritIntoWasCalled
+            get() = lazyGet(INHERIT_INTO_BIT_MASK) { false }
+            set(value) {
+                lazySet(INHERIT_INTO_BIT_MASK, value)
+            }
+
+        override fun inheritInto() {
+            // This must only be called once.
+            if (inheritIntoWasCalled) return
+            inheritIntoWasCalled = true
+
+            // PackageItem behaves quite differently to the other Item types so do it first.
+            if (item is PackageItem) {
+                showability.let { showability ->
+                    when {
+                        showability.show() -> inheritableHidden = false
+                        showability.hide() -> inheritableHidden = true
+                    }
+                }
+                val containingPackageSelectors =
+                    item.containingPackage()?.variantSelectors ?: return
+                if (containingPackageSelectors.inheritableHidden) {
+                    inheritableHidden = true
+                }
+                return
+            }
+
+            // Inheritance is only done on a few Item types, ignore the rest.
+            if (item !is ClassItem && item !is CallableItem && item !is FieldItem) return
+
+            if (item is ClassItem) {
+                // Workaround: we're pulling in .aidl files from .jar files. These are
+                // marked @hide, but since we only see the .class files we don't know that.
+                if (
+                    item.simpleName().startsWith("I") &&
+                        item.origin == ClassOrigin.CLASS_PATH &&
+                        item.interfaceTypes().any { it.qualifiedName == "android.os.IInterface" }
+                ) {
+                    hidden = true
+                    return
+                }
+            }
+
+            if (showability.show()) {
+                // If the showability is recursive then set inheritableHidden to false, that will
+                // unhide any contents of this item too, unless they hide themselves.
+                if (showability.showRecursive()) {
+                    inheritableHidden = false
+                }
+                // Whether the showability is recursive or not a show annotation of any sort will
+                // always unhide this item.
+                hidden = false
+
+                if (item is ClassItem) {
+                    // Make containing package non-hidden if it contains a show-annotation class.
+                    val containingPackageSelectors = item.containingPackage().variantSelectors
+                    // Only unhide the package, do not affect anything that might inherit from that
+                    // package.
+                    (containingPackageSelectors as Mutable).hidden = false
+                }
+
+                if (item.containingClass() != null) {
+                    ensureParentVisible()
+                }
+            } else if (showability.hide()) {
+                inheritableHidden = true
+            } else {
+                val containingClassSelectors = item.containingClass()?.variantSelectors
+                if (containingClassSelectors != null) {
+                    if (item is FieldItem) {
+                        if (
+                            containingClassSelectors.originallyHidden &&
+                                containingClassSelectors.showability.showNonRecursive()
+                        ) {
+                            // This is a member in a class that was hidden but then unhidden; but it
+                            // was
+                            // unhidden by a non-recursive (single) show annotation, so don't
+                            // inherit
+                            // the show annotation into this item.
+                            inheritableHidden = true
+                        }
+                    } else if (containingClassSelectors.inheritableHidden) {
+                        inheritableHidden = true
+                    }
+                } else if (item is ClassItem) {
+                    // This will only be executed for top level classes, i.e. containing class is
+                    // null. They inherit their properties from the containing package.
+                    val containingPackageSelectors = item.containingPackage().variantSelectors
+                    if (containingPackageSelectors.inheritableHidden) {
+                        inheritableHidden = true
+                    }
+                }
+            }
+        }
+
+        /**
+         * Ensure that the parents of a visible [Item], i.e. one whose [Item.hidden] property is
+         * `false` are themselves visible.
+         *
+         * Note: This will only be called when [item] is a class, constructor, method or field. In
+         * particular, it does not apply to [PackageItem]s as they are completely separate from one
+         * another, i.e. you do not need to have package `abc.qrs` be visible in order to have
+         * `abc.qrs.xyz` be visible.
+         */
+        private fun ensureParentVisible() {
+            val parent = item.parent() ?: return
+
+            // If the parent is not hidden then everything is fine.
+            if (!parent.hidden) {
+                return
+            }
+
+            // Otherwise, find a show annotation to blame it on and report the issue.
+            item.modifiers.findAnnotation(AnnotationItem::isShowAnnotation)?.let {
+                violatingAnnotation ->
+                item.codebase.reporter.report(
+                    Issues.SHOWING_MEMBER_IN_HIDDEN_CLASS,
+                    item,
+                    "Attempting to unhide ${item.describe()}, but surrounding ${parent.describe()} is " +
+                        "hidden and should also be annotated with $violatingAnnotation"
+                )
+            }
+        }
+
+        override fun toString(): String {
+            return buildString {
+                append(item.describe())
+                append(" {\n")
+                for ((bitPosition, propertyName) in propertyNamePerBit.withIndex()) {
+                    val bitMask = 1 shl bitPosition
+                    append("    ")
+                    append(propertyName)
+                    append("=")
+                    if ((propertyHasBeenSetBits and bitMask) == 0) {
+                        append("<not-set>")
+                    } else if ((propertyValueBits and bitMask) == 0) {
+                        append("false")
+                    } else {
+                        append("true")
+                    }
+                    append(",\n")
+                }
+                append("    showability=")
+                if (_showability == null) {
+                    append("<not-set>")
+                } else {
+                    append(_showability)
+                }
+                append(",\n")
+                append("}")
+            }
+        }
+
+        override fun equals(other: Any?): Boolean {
+            if (this === other) return true
+            if (other !is Mutable) return false
+
+            if (item != other.item) return false
+            if (propertyHasBeenSetBits != other.propertyHasBeenSetBits) return false
+            if (propertyValueBits != other.propertyValueBits) return false
+            if (_showability != other._showability) return false
+
+            return true
+        }
+
+        override fun hashCode(): Int {
+            var result = item.hashCode()
+            result = 31 * result + propertyHasBeenSetBits
+            result = 31 * result + propertyValueBits
+            result = 31 * result + _showability.hashCode()
+            return result
+        }
+
+        companion object {
+            // `originallyHidden` related constants
+            private const val ORIGINALLY_HIDDEN_BIT_POSITION: Int = 0
+            private const val ORIGINALLY_HIDDEN_BIT_MASK: Int = 1 shl ORIGINALLY_HIDDEN_BIT_POSITION
+
+            // `inheritableHidden` related constants
+            private const val INHERITABLE_HIDDEN_BIT_POSITION: Int =
+                ORIGINALLY_HIDDEN_BIT_POSITION + 1
+            private const val INHERITABLE_HIDDEN_BIT_MASK: Int =
+                1 shl INHERITABLE_HIDDEN_BIT_POSITION
+
+            // `hidden` related constants
+            private const val HIDDEN_BIT_POSITION: Int = INHERITABLE_HIDDEN_BIT_POSITION + 1
+            private const val HIDDEN_BIT_MASK: Int = 1 shl HIDDEN_BIT_POSITION
+
+            // `accessible` related constants
+            private const val ACCESSIBLE_BIT_POSITION: Int = HIDDEN_BIT_POSITION + 1
+            private const val ACCESSIBLE_BIT_MASK: Int = 1 shl ACCESSIBLE_BIT_POSITION
+
+            // `docOnly` related constants
+            private const val DOCONLY_BIT_POSITION: Int = ACCESSIBLE_BIT_POSITION + 1
+            private const val DOCONLY_BIT_MASK: Int = 1 shl DOCONLY_BIT_POSITION
+
+            // `removed` related constants
+            private const val REMOVED_BIT_POSITION: Int = DOCONLY_BIT_POSITION + 1
+            private const val REMOVED_BIT_MASK: Int = 1 shl REMOVED_BIT_POSITION
+
+            /**
+             * Bit mask in [propertyHasBeenSetBits] that indicates whether [inheritInto] has been
+             * called.
+             */
+            private const val INHERIT_INTO_BIT_POSITION = REMOVED_BIT_POSITION + 1
+            private const val INHERIT_INTO_BIT_MASK = 1 shl INHERIT_INTO_BIT_POSITION
+
+            /** The count of the number of bits used. */
+            private const val COUNT_BITS_USED = INHERIT_INTO_BIT_POSITION + 1
+
+            /** Map from bit to the associated property name, used in toString() */
+            private val propertyNamePerBit =
+                Array(COUNT_BITS_USED) { "" }
+                    .also { array ->
+                        array[ORIGINALLY_HIDDEN_BIT_POSITION] = "originallyHidden"
+                        array[INHERITABLE_HIDDEN_BIT_POSITION] = "inheritableHidden"
+                        array[HIDDEN_BIT_POSITION] = "hidden"
+                        array[ACCESSIBLE_BIT_POSITION] = "accessible"
+                        array[DOCONLY_BIT_POSITION] = "docOnly"
+                        array[REMOVED_BIT_POSITION] = "removed"
+                        array[INHERIT_INTO_BIT_POSITION] = "inheritIntoWasCalled"
+                    }
+        }
+    }
+
+    /**
+     * Encapsulates the expected state of a [Mutable] instance.
+     *
+     * A data class was chosen for this because the nature of the [Mutable] class is such that
+     * generally, once a property has been set it is not changed (not strictly true for packages).
+     * Tests will typically, test the state, make a change (e.g. get the value of a property), check
+     * the new state and so on. The [copy] method generated for data classes makes it easy to
+     * incrementally modify the state without having to repeat all the previous changes.
+     *
+     * For `var` properties in [Mutable] each corresponding optional parameter will have no effect
+     * if `null` but otherwise will be used to set the corresponding `var` property in the returned
+     * object.
+     *
+     * The `val` properties like [originallyHidden] cannot be set to a specific value. So, all that
+     * this can do is force it to be initialized. That means that the [ApiVariantSelectors] returned
+     * from [createSelectorsforTesting] will only verify whether it is set or not-set as expected.
+     * It cannot test if the value is expected. That will need to be done by the caller.
+     */
+    data class TestableSelectorsState(
+        val item: SelectableItem,
+        val originallyHidden: Boolean? = null,
+        val inheritIntoWasCalled: Boolean = false,
+        val inheritableHidden: Boolean? = null,
+        val hidden: Boolean? = null,
+        val docOnly: Boolean? = null,
+        val removed: Boolean? = null,
+        val showability: Showability? = null,
+    ) {
+
+        /**
+         * Create a [Mutable] instance whose state matches this that can be used as the expected
+         * state in a test.
+         */
+        fun createSelectorsforTesting(): ApiVariantSelectors =
+            Mutable(item).also { selectors ->
+                // If originally hidden is set then force it to be initialized.
+                originallyHidden?.let {
+                    // It is expected to be set so force it to be initialized.
+                    selectors.originallyHidden
+                }
+                if (inheritIntoWasCalled) selectors.inheritIntoWasCalled = true
+                inheritableHidden?.let { selectors.inheritableHidden = it }
+                hidden?.let { selectors.hidden = it }
+                docOnly?.let {
+                    // It is expected to be set so force it to be initialized.
+                    selectors.docOnly
+                }
+                removed?.let { selectors.removed = it }
+                showability?.let { selectors._showability = it }
+            }
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
index 56f346bc5..8146ed25f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
@@ -18,17 +18,11 @@ package com.android.tools.metalava.model
 
 open class BaseItemVisitor(
     /**
-     * Whether constructors should be visited as part of a [#visitMethod] call instead of just a
-     * [#visitConstructor] call. Helps simplify visitors that don't care to distinguish between the
-     * two cases. Defaults to true.
-     */
-    val visitConstructorsAsMethods: Boolean = true,
-    /**
-     * Whether inner classes should be visited "inside" a class; when this property is true, inner
+     * Whether nested classes should be visited "inside" a class; when this property is true, nested
      * classes are visited before the [#afterVisitClass] method is called; when false, it's done
      * afterwards. Defaults to false.
      */
-    val nestInnerClasses: Boolean = false,
+    val preserveClassNesting: Boolean = false,
 ) : ItemVisitor {
     override fun visit(cls: ClassItem) {
         if (skip(cls)) {
@@ -68,20 +62,14 @@ open class BaseItemVisitor(
             }
         }
 
-        if (nestInnerClasses) {
-            for (innerCls in cls.innerClasses()) {
-                innerCls.accept(this)
+        if (preserveClassNesting) {
+            for (nestedCls in cls.nestedClasses()) {
+                nestedCls.accept(this)
             }
-        } // otherwise done below
+        } // otherwise done in visit(PackageItem)
 
         afterVisitClass(cls)
         afterVisitItem(cls)
-
-        if (!nestInnerClasses) {
-            for (innerCls in cls.innerClasses()) {
-                innerCls.accept(this)
-            }
-        }
     }
 
     override fun visit(field: FieldItem) {
@@ -91,36 +79,62 @@ open class BaseItemVisitor(
 
         visitItem(field)
         visitField(field)
-
-        afterVisitField(field)
         afterVisitItem(field)
     }
 
+    override fun visit(constructor: ConstructorItem) {
+        visitMethodOrConstructor(constructor) { visitConstructor(it) }
+    }
+
     override fun visit(method: MethodItem) {
-        if (skip(method)) {
+        visitMethodOrConstructor(method) { visitMethod(it) }
+    }
+
+    private inline fun <T : CallableItem> visitMethodOrConstructor(
+        callable: T,
+        dispatch: (T) -> Unit
+    ) {
+        if (skip(callable)) {
             return
         }
 
-        visitItem(method)
-        if (method.isConstructor()) {
-            visitConstructor(method as ConstructorItem)
-        } else {
-            visitMethod(method)
-        }
+        visitItem(callable)
+        visitCallable(callable)
+
+        // Call the specific visitX method for the CallableItem subclass.
+        dispatch(callable)
 
-        for (parameter in method.parameters()) {
+        for (parameter in callable.parameters()) {
             parameter.accept(this)
         }
 
-        if (method.isConstructor()) {
-            afterVisitConstructor(method as ConstructorItem)
-        } else {
-            afterVisitMethod(method)
-        }
-        afterVisitItem(method)
+        afterVisitItem(callable)
+    }
+
+    /**
+     * Get the package's classes to visit directly.
+     *
+     * If nested classes are to appear as nested within their containing classes then this will just
+     * return the package's top level classes. It will then be the responsibility of
+     * `visit(ClassItem)` to visit the nested classes. Otherwise, this will return a flattened
+     * sequence of each class followed by its nested classes.
+     */
+    protected fun packageClassesAsSequence(pkg: PackageItem) =
+        if (preserveClassNesting) pkg.topLevelClasses().asSequence() else pkg.allClasses()
+
+    override fun visit(codebase: Codebase) {
+        visitCodebase(codebase)
+        codebase.getPackages().packages.forEach { it.accept(this) }
+        afterVisitCodebase(codebase)
     }
 
     override fun visit(pkg: PackageItem) {
+        // Ignore any packages whose `emit` property is `false`. That is basically any package that
+        // does not contain at least one class that could be emitted as part of the API.
+        if (!pkg.emit) {
+            return
+        }
+
         if (skip(pkg)) {
             return
         }
@@ -128,7 +142,7 @@ open class BaseItemVisitor(
         visitItem(pkg)
         visitPackage(pkg)
 
-        for (cls in pkg.topLevelClasses()) {
+        for (cls in packageClassesAsSequence(pkg)) {
             cls.accept(this)
         }
 
@@ -136,12 +150,6 @@ open class BaseItemVisitor(
         afterVisitItem(pkg)
     }
 
-    override fun visit(packageList: PackageList) {
-        visitCodebase(packageList.codebase)
-        packageList.packages.forEach { it.accept(this) }
-        afterVisitCodebase(packageList.codebase)
-    }
-
     override fun visit(parameter: ParameterItem) {
         if (skip(parameter)) {
             return
@@ -149,8 +157,6 @@ open class BaseItemVisitor(
 
         visitItem(parameter)
         visitParameter(parameter)
-
-        afterVisitParameter(parameter)
         afterVisitItem(parameter)
     }
 
@@ -161,8 +167,6 @@ open class BaseItemVisitor(
 
         visitItem(property)
         visitProperty(property)
-
-        afterVisitProperty(property)
         afterVisitItem(property)
     }
 
@@ -180,16 +184,14 @@ open class BaseItemVisitor(
 
     open fun visitClass(cls: ClassItem) {}
 
-    open fun visitConstructor(constructor: ConstructorItem) {
-        if (visitConstructorsAsMethods) {
-            visitMethod(constructor)
-        }
-    }
+    open fun visitCallable(callable: CallableItem) {}
 
-    open fun visitField(field: FieldItem) {}
+    open fun visitConstructor(constructor: ConstructorItem) {}
 
     open fun visitMethod(method: MethodItem) {}
 
+    open fun visitField(field: FieldItem) {}
+
     open fun visitParameter(parameter: ParameterItem) {}
 
     open fun visitProperty(property: PropertyItem) {}
@@ -201,18 +203,4 @@ open class BaseItemVisitor(
     open fun afterVisitPackage(pkg: PackageItem) {}
 
     open fun afterVisitClass(cls: ClassItem) {}
-
-    open fun afterVisitConstructor(constructor: ConstructorItem) {
-        if (visitConstructorsAsMethods) {
-            afterVisitMethod(constructor)
-        }
-    }
-
-    open fun afterVisitField(field: FieldItem) {}
-
-    open fun afterVisitMethod(method: MethodItem) {}
-
-    open fun afterVisitParameter(parameter: ParameterItem) {}
-
-    open fun afterVisitProperty(property: PropertyItem) {}
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/CallableBody.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableBody.kt
new file mode 100644
index 000000000..b4c6fc5b8
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableBody.kt
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.reporter.FileLocation
+
+/**
+ * A lamda that given a [CallableItem] will create a [CallableBody] for it.
+ *
+ * This is called from within the constructor of the [CallableItem] and should not access any
+ * properties of [CallableItem] as they may not have been initialized. This should just store a
+ * reference for later use.
+ */
+typealias CallableBodyFactory = (CallableItem) -> CallableBody
+
+/** Represents the body of a [CallableItem]. */
+interface CallableBody {
+
+    /**
+     * Return a duplicate of this instance to use by [callableItem] which will be in the same type
+     * of [Codebase] as this.
+     */
+    fun duplicate(callableItem: CallableItem): CallableBody
+
+    /**
+     * Take a snapshot of this suitable for use by [callableItem] which will be in a
+     * [DefaultCodebase].
+     *
+     * At the moment this simply delegates to [duplicate] as there is no easy way to take a snapshot
+     * of the state.
+     */
+    fun snapshot(callableItem: CallableItem) = duplicate(callableItem)
+
+    /**
+     * Finds uncaught exceptions actually thrown inside this body (as opposed to ones declared in
+     * the signature)
+     */
+    fun findThrownExceptions(): Set<ClassItem>
+
+    /**
+     * Finds the locations within this where a `synchronized` statement may be visible because it
+     * locks either the instance on which the method is called or its class. e.g. `synchronized
+     * (this) {...}` or `synchronized (Class.class)`.
+     */
+    fun findVisiblySynchronizedLocations(): List<FileLocation>
+
+    /**
+     * Called on a method whose return value is annotated with [typeDefAnnotation] of class
+     * [typeDefClass].
+     *
+     * This scans the body of the method, finds `return` statements and checks to make sure that if
+     * they use a constant that it is one of the constants in the type def, reporting any which are
+     * not.
+     */
+    fun verifyReturnedConstants(typeDefAnnotation: AnnotationItem, typeDefClass: ClassItem)
+
+    companion object {
+        /** Indicates that the model does not provide [CallableBody] instances. */
+        val UNAVAILABLE =
+            object : CallableBody {
+                override fun duplicate(callableItem: CallableItem) = this
+
+                override fun findThrownExceptions() = error("method body is unavailable")
+
+                /** Return an empty list as the method body is unavailable. */
+                override fun findVisiblySynchronizedLocations() = emptyList<FileLocation>()
+
+                /** Do nothing. */
+                override fun verifyReturnedConstants(
+                    typeDefAnnotation: AnnotationItem,
+                    typeDefClass: ClassItem
+                ) {}
+            }
+
+        /**
+         * A special [CallableBodyFactory] that returns [UNAVAILABLE].
+         *
+         * Used where there is no available body, e.g. text/turbine model, implicit default
+         * constructor, etc..
+         */
+        val UNAVAILABLE_FACTORY: CallableBodyFactory = { UNAVAILABLE }
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
new file mode 100644
index 000000000..ac6345f8c
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import java.util.Objects
+import java.util.function.Predicate
+
+/** Common to [MethodItem] and [ConstructorItem]. */
+@MetalavaApi
+interface CallableItem : MemberItem, TypeParameterListOwner {
+
+    /** Whether this callable is a constructor or a method. */
+    @MetalavaApi fun isConstructor(): Boolean
+
+    /**
+     * The return type of this callable.
+     *
+     * Returns the [ClassItem.type] of the [containingClass] for constructors.
+     */
+    @MetalavaApi fun returnType(): TypeItem
+
+    /** The list of parameters */
+    @MetalavaApi fun parameters(): List<ParameterItem>
+
+    override fun type() = returnType()
+
+    /** Types of exceptions that this callable can throw */
+    fun throwsTypes(): List<ExceptionTypeItem>
+
+    /** The body of this, may not be available. */
+    val body: CallableBody
+
+    /** Returns true if this callable throws the given exception */
+    fun throws(qualifiedName: String): Boolean {
+        for (type in throwsTypes()) {
+            val throwableClass = type.erasedClass ?: continue
+            if (throwableClass.extends(qualifiedName)) {
+                return true
+            }
+        }
+
+        return false
+    }
+
+    fun filteredThrowsTypes(predicate: Predicate<Item>): Collection<ExceptionTypeItem> {
+        if (throwsTypes().isEmpty()) {
+            return emptyList()
+        }
+        return filteredThrowsTypes(predicate, LinkedHashSet())
+    }
+
+    private fun filteredThrowsTypes(
+        predicate: Predicate<Item>,
+        throwsTypes: LinkedHashSet<ExceptionTypeItem>
+    ): LinkedHashSet<ExceptionTypeItem> {
+        for (exceptionType in throwsTypes()) {
+            if (exceptionType is VariableTypeItem) {
+                throwsTypes.add(exceptionType)
+            } else {
+                val classItem = exceptionType.erasedClass ?: continue
+                if (predicate.test(classItem)) {
+                    throwsTypes.add(exceptionType)
+                } else {
+                    // Excluded, but it may have super class throwables that are included; if so,
+                    // include those.
+                    classItem
+                        .allSuperClasses()
+                        .firstOrNull { superClass -> predicate.test(superClass) }
+                        ?.let { superClass -> throwsTypes.add(superClass.type()) }
+                }
+            }
+        }
+        return throwsTypes
+    }
+
+    /** Override to specialize return type. */
+    override fun findCorrespondingItemIn(
+        codebase: Codebase,
+        superMethods: Boolean,
+        duplicate: Boolean,
+    ): CallableItem?
+
+    override fun baselineElementId() = buildString {
+        append(containingClass().qualifiedName())
+        append("#")
+        append(name())
+        append("(")
+        parameters().joinTo(this) { it.type().toSimpleType() }
+        append(")")
+    }
+
+    override fun toStringForItem(): String {
+        return "${if (isConstructor()) "constructor" else "method"} ${
+            containingClass().qualifiedName()}.${name()}(${parameters().joinToString { it.type().toSimpleType() }})"
+    }
+
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is CallableItem) return false
+
+        // The name check will ensure that methods and constructors do not compare equally to each
+        // other even if the rest of this method would return true. That is because constructor
+        // names MUST be the class' `simpleName`, whereas method names MUST NOT be the class'
+        // `simpleName`.
+        if (name() != other.name()) {
+            return false
+        }
+
+        if (containingClass() != other.containingClass()) {
+            return false
+        }
+
+        val parameters1 = parameters()
+        val parameters2 = other.parameters()
+
+        if (parameters1.size != parameters2.size) {
+            return false
+        }
+
+        for (i in parameters1.indices) {
+            val parameter1 = parameters1[i]
+            val parameter2 = parameters2[i]
+            if (parameter1.type() != parameter2.type()) {
+                return false
+            }
+        }
+
+        val typeParameters1 = typeParameterList
+        val typeParameters2 = other.typeParameterList
+
+        if (typeParameters1.size != typeParameters2.size) {
+            return false
+        }
+
+        for (i in typeParameters1.indices) {
+            val typeParameter1 = typeParameters1[i]
+            val typeParameter2 = typeParameters2[i]
+            if (typeParameter1.typeBounds() != typeParameter2.typeBounds()) {
+                return false
+            }
+        }
+        return true
+    }
+
+    override fun hashCodeForItem(): Int {
+        // Just use the callable name, containing class and number of parameters.
+        return Objects.hash(name(), containingClass(), parameters().size)
+    }
+
+    /**
+     * Returns true if this callable is a signature match for the given callable (e.g. can be
+     * overriding if it is a method). This checks that the name and parameter lists match, but
+     * ignores differences in parameter names, return value types and throws list types.
+     */
+    fun matches(other: CallableItem): Boolean {
+        if (this === other) return true
+
+        // The name check will ensure that methods and constructors do not compare equally to each
+        // other even if the rest of this method would return true. That is because constructor
+        // names MUST be the class' `simpleName`, whereas method names MUST NOT be the class'
+        // `simpleName`.
+        if (name() != other.name()) {
+            return false
+        }
+
+        val parameters1 = parameters()
+        val parameters2 = other.parameters()
+
+        if (parameters1.size != parameters2.size) {
+            return false
+        }
+
+        for (i in parameters1.indices) {
+            val parameter1Type = parameters1[i].type()
+            val parameter2Type = parameters2[i].type()
+            if (parameter1Type == parameter2Type) continue
+            if (parameter1Type.toErasedTypeString() == parameter2Type.toErasedTypeString()) continue
+
+            val convertedType =
+                parameter1Type.convertType(other.containingClass(), containingClass())
+            if (convertedType != parameter2Type) return false
+        }
+        return true
+    }
+
+    /**
+     * Returns whether this callable has any types in its signature that does not match the given
+     * filter.
+     */
+    fun hasHiddenType(filterReference: Predicate<Item>): Boolean {
+        for (parameter in parameters()) {
+            if (parameter.type().hasHiddenType(filterReference)) return true
+        }
+
+        if (returnType().hasHiddenType(filterReference)) return true
+
+        for (typeParameter in typeParameterList) {
+            if (typeParameter.typeBounds().any { it.hasHiddenType(filterReference) }) return true
+        }
+
+        return false
+    }
+
+    /** Checks if there is a reference to a hidden class anywhere in the type. */
+    private fun TypeItem.hasHiddenType(filterReference: Predicate<Item>): Boolean {
+        return when (this) {
+            is PrimitiveTypeItem -> false
+            is ArrayTypeItem -> componentType.hasHiddenType(filterReference)
+            is ClassTypeItem ->
+                asClass()?.let { !filterReference.test(it) } == true ||
+                    outerClassType?.hasHiddenType(filterReference) == true ||
+                    arguments.any { it.hasHiddenType(filterReference) }
+            is VariableTypeItem -> !filterReference.test(asTypeParameter)
+            is WildcardTypeItem ->
+                extendsBound?.hasHiddenType(filterReference) == true ||
+                    superBound?.hasHiddenType(filterReference) == true
+            else -> throw IllegalStateException("Unrecognized type: $this")
+        }
+    }
+
+    companion object {
+        private fun compareCallables(
+            o1: CallableItem,
+            o2: CallableItem,
+            overloadsInSourceOrder: Boolean
+        ): Int {
+            val name1 = o1.name()
+            val name2 = o2.name()
+            if (name1 == name2) {
+                if (overloadsInSourceOrder) {
+                    val rankDelta = o1.sortingRank - o2.sortingRank
+                    if (rankDelta != 0) {
+                        return rankDelta
+                    }
+                }
+
+                // Compare by the rest of the signature to ensure stable output (we don't need to
+                // sort
+                // by return value or modifiers or modifiers or throws-lists since methods can't be
+                // overloaded
+                // by just those attributes
+                val p1 = o1.parameters()
+                val p2 = o2.parameters()
+                val p1n = p1.size
+                val p2n = p2.size
+                for (i in 0 until minOf(p1n, p2n)) {
+                    val compareTypes =
+                        p1[i]
+                            .type()
+                            .toTypeString()
+                            .compareTo(p2[i].type().toTypeString(), ignoreCase = true)
+                    if (compareTypes != 0) {
+                        return compareTypes
+                    }
+                    // (Don't compare names; they're not part of the signatures)
+                }
+                return p1n.compareTo(p2n)
+            }
+
+            return name1.compareTo(name2)
+        }
+
+        val comparator: Comparator<CallableItem> = Comparator { o1, o2 ->
+            compareCallables(o1, o2, false)
+        }
+        val sourceOrderComparator: Comparator<CallableItem> = Comparator { o1, o2 ->
+            val delta = o1.sortingRank - o2.sortingRank
+            if (delta == 0) {
+                // Within a source file all the items will have unique sorting ranks, but since
+                // we copy methods in from hidden super classes it's possible for ranks to clash,
+                // and in that case we'll revert to a signature based comparison
+                comparator.compare(o1, o2)
+            } else {
+                delta
+            }
+        }
+        val sourceOrderForOverloadedMethodsComparator: Comparator<CallableItem> =
+            Comparator { o1, o2 ->
+                compareCallables(o1, o2, true)
+            }
+    }
+}
+
+/**
+ * Get the JVM-like descriptor of this [CallableItem] for just parameters (not return type) and
+ * using dots ('.') instead of slash (`/`) and dollar sign (`$`) characters.
+ *
+ * Due to legacy reasons it will return `null` for the constructor of an inner class.
+ */
+fun CallableItem.getCallableParameterDescriptorUsingDots(): String? {
+    return if (
+        isConstructor() &&
+            containingClass().isNestedClass() &&
+            !containingClass().modifiers.isStatic()
+    )
+        null
+    else
+        buildString {
+            append("(")
+            for (parameter in parameters()) {
+                append(parameter.type().internalName().replace('/', '.').replace('$', '.'))
+            }
+            append(")")
+        }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassContentItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassContentItem.kt
new file mode 100644
index 000000000..f144295f7
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassContentItem.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/**
+ * An [Item] that can be the content of a [ClassItem].
+ *
+ * i.e.
+ * * Nested [ClassItem]s.
+ * * Class members:
+ *     * Constructors
+ *     * Methods
+ *     * Fields
+ *     * Properties
+ * * Parameters
+ *
+ * Basically, every [Item] except [PackageItem].
+ */
+interface ClassContentItem : Item {
+
+    /**
+     * The origin of this item.
+     *
+     * If this [Item] was copied from a class in the class path into a source class then this will
+     * return [ClassOrigin.CLASS_PATH].
+     */
+    val origin: ClassOrigin
+        get() =
+            if (codebase.isFromClassPath()) ClassOrigin.CLASS_PATH
+            else
+                containingClass()?.origin
+                    ?:
+                    // This should never happen as this will only be called for a top level class
+                    // and
+                    // ClassItem implementation should override this method.
+                    error("unknown origin")
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
index 32e95d430..64b2c446f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
@@ -16,8 +16,6 @@
 
 package com.android.tools.metalava.model
 
-import java.util.ArrayList
-import java.util.LinkedHashSet
 import java.util.function.Predicate
 
 /**
@@ -27,41 +25,44 @@ import java.util.function.Predicate
  * com.android.tools.metalava.model.TypeItem} instead
  */
 @MetalavaApi
-interface ClassItem : Item, TypeParameterListOwner {
-    /** The simple name of a class. In class foo.bar.Outer.Inner, the simple name is "Inner" */
-    fun simpleName(): String
-
-    /** The full name of a class. In class foo.bar.Outer.Inner, the full name is "Outer.Inner" */
-    fun fullName(): String
-
+interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     /**
      * The qualified name of a class. In class foo.bar.Outer.Inner, the qualified name is the whole
      * thing.
      */
     @MetalavaApi fun qualifiedName(): String
 
-    /** Is this an innerclass? */
-    @MetalavaApi fun isInnerClass(): Boolean = containingClass() != null
+    /** The simple name of a class. In class foo.bar.Outer.Inner, the simple name is "Inner" */
+    fun simpleName(): String
+
+    /** The full name of a class. In class foo.bar.Outer.Inner, the full name is "Outer.Inner" */
+    fun fullName(): String
+
+    /** Is this a nested class? */
+    @MetalavaApi fun isNestedClass() = containingClass() != null
 
     /** Is this a top level class? */
     fun isTopLevelClass(): Boolean = containingClass() == null
 
-    /** This [ClassItem] and all of its inner classes, recursively */
+    /** The origin of this class. */
+    override val origin: ClassOrigin
+
+    /** This [ClassItem] and all of its nested classes, recursively */
     fun allClasses(): Sequence<ClassItem> {
-        return sequenceOf(this).plus(innerClasses().asSequence().flatMap { it.allClasses() })
+        return sequenceOf(this).plus(nestedClasses().asSequence().flatMap { it.allClasses() })
     }
 
-    override fun parent(): Item? = containingClass() ?: containingPackage()
+    override fun parent(): SelectableItem? = containingClass() ?: containingPackage()
 
     override val effectivelyDeprecated: Boolean
         get() = originallyDeprecated || containingClass()?.effectivelyDeprecated == true
 
     /**
-     * The qualified name where inner classes use $ as a separator. In class foo.bar.Outer.Inner,
+     * The qualified name where nested classes use $ as a separator. In class foo.bar.Outer.Inner,
      * this method will return foo.bar.Outer$Inner. (This is the name format used in ProGuard keep
      * files for example.)
      */
-    fun qualifiedNameWithDollarInnerClasses(): String {
+    fun qualifiedNameWithDollarNestedClasses(): String {
         var curr: ClassItem? = this
         while (curr?.containingClass() != null) {
             curr = curr.containingClass()
@@ -95,7 +96,7 @@ interface ClassItem : Item, TypeParameterListOwner {
      *
      * Interfaces always return `null` for this.
      */
-    @MetalavaApi fun superClass(): ClassItem?
+    @MetalavaApi fun superClass() = superClassType()?.asClass()
 
     /** All super classes, if any */
     fun allSuperClasses(): Sequence<ClassItem> {
@@ -159,8 +160,11 @@ interface ClassItem : Item, TypeParameterListOwner {
      */
     fun allInterfaces(): Sequence<ClassItem>
 
-    /** Any inner classes of this class */
-    fun innerClasses(): List<ClassItem>
+    /**
+     * Any classes nested in this class, that includes inner classes which are just non-static
+     * nested classes.
+     */
+    fun nestedClasses(): List<ClassItem>
 
     /** The constructors in this class */
     @MetalavaApi fun constructors(): List<ConstructorItem>
@@ -196,7 +200,13 @@ interface ClassItem : Item, TypeParameterListOwner {
     /** Whether this class is a regular class (not an interface, not an enum, etc) */
     fun isClass() = classKind == ClassKind.CLASS
 
-    /** The containing class, for inner classes */
+    /**
+     * Whether this class is a File Facade class, i.e. a `*Kt` class that contains declarations
+     * which do not belong to a Kotlin class, e.g. top-level functions, properties, etc.
+     */
+    fun isFileFacade() = false
+
+    /** The containing class, for nested classes */
     @MetalavaApi override fun containingClass(): ClassItem?
 
     /** The containing package */
@@ -205,6 +215,22 @@ interface ClassItem : Item, TypeParameterListOwner {
     /** Gets the type for this class */
     override fun type(): ClassTypeItem
 
+    override fun setType(type: TypeItem) =
+        error("Cannot call setType(TypeItem) on PackageItem: $this")
+
+    /** True if [freeze] has been called on this, false otherwise. */
+    val frozen: Boolean
+
+    /**
+     * Freeze this [ClassItem] so it cannot be mutated.
+     *
+     * A frozen [ClassItem] cannot have new members (including nested classes) added or its
+     * modifiers mutated.
+     *
+     * Freezing a [ClassItem] will also freeze its super types.
+     */
+    fun freeze()
+
     override fun findCorrespondingItemIn(
         codebase: Codebase,
         superMethods: Boolean,
@@ -223,24 +249,27 @@ interface ClassItem : Item, TypeParameterListOwner {
     // This replaces the interface types implemented by this class
     fun setInterfaceTypes(interfaceTypes: List<ClassTypeItem>)
 
-    var hasPrivateConstructor: Boolean
-
     /** The primary constructor for this class in Kotlin, if present. */
     val primaryConstructor: ConstructorItem?
         get() = constructors().singleOrNull { it.isPrimary }
 
-    /**
-     * Maven artifact of this class, if any. (Not used for the Android SDK, but used in for example
-     * support libraries.
-     */
-    var artifact: String?
-
     override fun baselineElementId() = qualifiedName()
 
     override fun accept(visitor: ItemVisitor) {
         visitor.visit(this)
     }
 
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is ClassItem) return false
+
+        return qualifiedName() == other.qualifiedName()
+    }
+
+    override fun hashCodeForItem(): Int {
+        return qualifiedName().hashCode()
+    }
+
     override fun toStringForItem() = "class ${qualifiedName()}"
 
     companion object {
@@ -292,10 +321,6 @@ interface ClassItem : Item, TypeParameterListOwner {
         includeSuperClasses: Boolean = false,
         includeInterfaces: Boolean = false
     ): MethodItem? {
-        if (template.isConstructor()) {
-            return findConstructor(template as ConstructorItem)
-        }
-
         methods()
             .asSequence()
             .filter { it.matches(template) }
@@ -375,12 +400,11 @@ interface ClassItem : Item, TypeParameterListOwner {
     /**
      * Find the [MethodItem] in this.
      *
-     * If [methodName] is the same as [simpleName] then this will look for [ConstructorItem]s,
-     * otherwise it will look for [MethodItem]s whose [MethodItem.name] is equal to [methodName].
+     * It will look for [MethodItem]s whose [MethodItem.name] is equal to [methodName].
      *
-     * Out of those matching items it will select the first [MethodItem] (or [ConstructorItem]
-     * subclass) whose parameters match the supplied parameters string. Parameters are matched
-     * against a candidate [MethodItem] as follows:
+     * Out of those matching items it will select the first [MethodItem] whose parameters match the
+     * supplied parameters string. Parameters are matched against a candidate [MethodItem] as
+     * follows:
      * * The [parameters] string is split on `,` and trimmed and then each item in the list is
      *   matched with the corresponding [ParameterItem] in `candidate.parameters()` as follows:
      * * Everything after `<` is removed.
@@ -393,29 +417,41 @@ interface ClassItem : Item, TypeParameterListOwner {
      * @param methodName the name of the method or [simpleName] if looking for constructors.
      * @param parameters the comma separated erased types of the parameters.
      */
-    fun findMethod(methodName: String, parameters: String): MethodItem? {
-        if (methodName == simpleName()) {
-            // Constructor
-            constructors()
-                .filter { parametersMatch(it, parameters) }
-                .forEach {
-                    return it
-                }
-        } else {
-            methods()
-                .filter { it.name() == methodName && parametersMatch(it, parameters) }
-                .forEach {
-                    return it
-                }
-        }
+    fun findMethod(methodName: String, parameters: String) =
+        methods().firstOrNull { it.name() == methodName && parametersMatch(it, parameters) }
 
-        return null
-    }
+    /**
+     * Find the [ConstructorItem] in this.
+     *
+     * Out of those matching items it will select the first [ConstructorItem] whose parameters match
+     * the supplied parameters string. Parameters are matched against a candidate [ConstructorItem]
+     * as follows:
+     * * The [parameters] string is split on `,` and trimmed and then each item in the list is
+     *   matched with the corresponding [ParameterItem] in `candidate.parameters()` as follows:
+     * * Everything after `<` is removed.
+     * * The result is compared to the result of calling [TypeItem.toErasedTypeString]`(candidate)`
+     *   on the [ParameterItem.type].
+     *
+     * If every parameter matches then the matched [ConstructorItem] is returned. If no `candidate`
+     * matches then it returns 'null`.
+     *
+     * @param parameters the comma separated erased types of the parameters.
+     */
+    fun findConstructor(parameters: String) =
+        constructors().firstOrNull { parametersMatch(it, parameters) }
+
+    /**
+     * Find the [CallableItem] in this.
+     *
+     * If [name] is [simpleName] then call [findConstructor] else call [findMethod].
+     */
+    fun findCallable(name: String, parameters: String) =
+        if (name == simpleName()) findConstructor(parameters) else findMethod(name, parameters)
 
-    private fun parametersMatch(method: MethodItem, description: String): Boolean {
+    private fun parametersMatch(callable: CallableItem, description: String): Boolean {
         val parameterStrings =
             description.splitToSequence(",").map(String::trim).filter(String::isNotEmpty).toList()
-        val parameters = method.parameters()
+        val parameters = callable.parameters()
         if (parameters.size != parameterStrings.size) {
             return false
         }
@@ -435,7 +471,7 @@ interface ClassItem : Item, TypeParameterListOwner {
     }
 
     /** Returns the corresponding source file, if any */
-    fun getSourceFile(): SourceFile? = null
+    fun getSourceFile(): SourceFile?
 
     /** If this class is an annotation type, returns the retention of this class */
     fun getRetention(): AnnotationRetention
@@ -453,7 +489,7 @@ interface ClassItem : Item, TypeParameterListOwner {
         }
     }
 
-    fun filteredSuperClassType(predicate: Predicate<Item>): TypeItem? {
+    fun filteredSuperClassType(predicate: Predicate<Item>): ClassTypeItem? {
         var superClassType: ClassTypeItem? = superClassType() ?: return null
         var prev: ClassItem? = null
         while (superClassType != null) {
@@ -468,7 +504,7 @@ interface ClassItem : Item, TypeParameterListOwner {
                     return superClassType
                 }
 
-                return superClassType.convertType(this, prev)
+                return superClassType.convertType(this, prev) as ClassTypeItem
             }
 
             prev = superClass
@@ -572,7 +608,7 @@ interface ClassItem : Item, TypeParameterListOwner {
         return list
     }
 
-    fun filteredInterfaceTypes(predicate: Predicate<Item>): Collection<TypeItem> {
+    fun filteredInterfaceTypes(predicate: Predicate<Item>): Collection<ClassTypeItem> {
         val interfaceTypes =
             filteredInterfaceTypes(
                 predicate,
@@ -581,9 +617,6 @@ interface ClassItem : Item, TypeParameterListOwner {
                 includeParents = false,
                 target = this
             )
-        if (interfaceTypes.isEmpty()) {
-            return interfaceTypes
-        }
 
         return interfaceTypes
     }
@@ -606,11 +639,11 @@ interface ClassItem : Item, TypeParameterListOwner {
 
     private fun filteredInterfaceTypes(
         predicate: Predicate<Item>,
-        types: LinkedHashSet<TypeItem>,
+        types: LinkedHashSet<ClassTypeItem>,
         includeSelf: Boolean,
         includeParents: Boolean,
         target: ClassItem
-    ): LinkedHashSet<TypeItem> {
+    ): LinkedHashSet<ClassTypeItem> {
         val superClassType = superClassType()
         if (superClassType != null) {
             val superClass = superClassType.asClass()
@@ -659,34 +692,6 @@ interface ClassItem : Item, TypeParameterListOwner {
         return types
     }
 
-    fun allInnerClasses(includeSelf: Boolean = false): Sequence<ClassItem> {
-        if (!includeSelf && innerClasses().isEmpty()) {
-            return emptySequence()
-        }
-
-        val list = ArrayList<ClassItem>()
-        if (includeSelf) {
-            list.add(this)
-        }
-        addInnerClasses(list, this)
-        return list.asSequence()
-    }
-
-    private fun addInnerClasses(list: MutableList<ClassItem>, cls: ClassItem) {
-        for (innerClass in cls.innerClasses()) {
-            list.add(innerClass)
-            addInnerClasses(list, innerClass)
-        }
-    }
-
-    /**
-     * The default constructor to invoke on this class from subclasses; initially null but may be
-     * updated during use. (Note that in some cases [stubConstructor] may not be in [constructors],
-     * e.g. when we need to create a constructor to match a public parent class with a non-default
-     * constructor and the one in the code is not a match, e.g. is marked @hide etc.)
-     */
-    var stubConstructor: ConstructorItem?
-
     /**
      * Creates a map of type parameters of the target class to the type variables substituted for
      * those parameters by this class.
@@ -754,7 +759,7 @@ interface ClassItem : Item, TypeParameterListOwner {
         val classTypeArguments =
             classTypeItem.arguments.map {
                 if (it is ClassTypeItem && it.arguments.isNotEmpty()) {
-                    it.duplicate(it.outerClassType, arguments = emptyList())
+                    it.substitute(arguments = emptyList())
                 } else {
                     it
                 }
@@ -767,23 +772,22 @@ interface ClassItem : Item, TypeParameterListOwner {
         return declaringClass.typeParameterList.zip(classTypeArguments).toMap()
     }
 
-    /** Creates a constructor in this class */
-    fun createDefaultConstructor(): ConstructorItem = codebase.unsupported()
-
     /**
-     * Creates a method corresponding to the given method signature in this class.
+     * Creates a default constructor in this class.
      *
-     * This is used to inherit a [MethodItem] from a super class that will not be part of the API
-     * into a class that will be part of the API.
+     * Default constructors that are added by Java have the same visibility as their class which is
+     * the default behavior of this method if no [visibility] is provided. However, this is also
+     * used to create default constructors in order for stub classes to compile and as they do not
+     * appear in the API they need to be marked as package private so this method allows the
+     * [visibility] to be explicitly specified by the caller.
      *
-     * The [MethodItem.inheritedFrom] property in the returned [MethodItem] is set to
-     * [MethodItem.containingClass] of the [template].
+     * @param visibility the visibility of the constructor, defaults to the same as this class.
      */
-    fun inheritMethodFromNonApiAncestor(template: MethodItem): MethodItem = codebase.unsupported()
-
-    fun addMethod(method: MethodItem): Unit = codebase.unsupported()
+    fun createDefaultConstructor(
+        visibility: VisibilityLevel = modifiers.getVisibilityLevel()
+    ): ConstructorItem
 
-    fun addInnerClass(cls: ClassItem): Unit = codebase.unsupported()
+    fun addMethod(method: MethodItem)
 
     /**
      * Return true if a [ClassItem] could be subclassed, i.e. is not final or sealed and has at
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassOrigin.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassOrigin.kt
new file mode 100644
index 000000000..2b9380b86
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassOrigin.kt
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/** Identifies the origin of a specific class definition. */
+enum class ClassOrigin {
+    /**
+     * The class was defined in a file that was specified on the command line.
+     *
+     * That can include signature files, jar files as well as source files.
+     */
+    COMMAND_LINE,
+
+    /** The class was found while searching for a class on the source path. */
+    SOURCE_PATH,
+
+    /** The class was found while searching for a class on the class path. */
+    CLASS_PATH,
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
index 3d655e3c2..444b14b9d 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
@@ -16,6 +16,8 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.reporter.Reporter
 import java.io.File
 
 /**
@@ -32,6 +34,9 @@ interface Codebase {
      */
     val location: File
 
+    /** [Reporter] to which any issues found within the [Codebase] can be reported. */
+    val reporter: Reporter
+
     /** The manager of annotations within this codebase. */
     val annotationManager: AnnotationManager
 
@@ -41,6 +46,26 @@ interface Codebase {
     /** The rough size of the codebase (package count) */
     fun size(): Int
 
+    /**
+     * Returns a list of the top-level classes declared in the codebase's source (rather than on its
+     * classpath).
+     */
+    fun getTopLevelClassesFromSource(): List<ClassItem>
+
+    /**
+     * Return `true` if this whole [Codebase] was created from the class path, i.e. not from
+     * sources.
+     */
+    fun isFromClassPath(): Boolean = false
+
+    /**
+     * Freeze all the classes loaded from sources, along with their super classes.
+     *
+     * This does not prevent adding new classes and does automatically freeze classes added after
+     * this is called.
+     */
+    fun freezeClasses()
+
     /** Returns a class identified by fully qualified name, if in the codebase */
     fun findClass(className: String): ClassItem?
 
@@ -67,17 +92,26 @@ interface Codebase {
     fun trustedApi(): Boolean
 
     fun accept(visitor: ItemVisitor) {
-        getPackages().accept(visitor)
+        visitor.visit(this)
     }
 
-    /** Creates an annotation item for the given (fully qualified) Java source */
+    /**
+     * Creates an annotation item for the given (fully qualified) Java source.
+     *
+     * Returns `null` if the source contains an annotation that is not recognized by Metalava.
+     */
     fun createAnnotation(
         source: String,
         context: Item? = null,
-    ): AnnotationItem
+    ): AnnotationItem?
 
     /** Reports that the given operation is unsupported for this codebase type */
-    fun unsupported(desc: String? = null): Nothing
+    fun unsupported(desc: String? = null): Nothing {
+        error(
+            desc
+                ?: "This operation is not available on this type of codebase (${javaClass.simpleName})"
+        )
+    }
 
     /** Discards this model */
     fun dispose()
@@ -96,73 +130,10 @@ data class SetMinSdkVersion(val value: Int) : MinSdkVersion()
 
 object UnsetMinSdkVersion : MinSdkVersion()
 
-const val CLASS_ESTIMATE = 15000
-
-abstract class DefaultCodebase(
-    final override var location: File,
-    final override var description: String,
-    final override val preFiltered: Boolean,
-    final override val annotationManager: AnnotationManager,
-) : Codebase {
-
-    override fun unsupported(desc: String?): Nothing {
-        error(
-            desc
-                ?: "This operation is not available on this type of codebase (${this.javaClass.simpleName})"
-        )
-    }
-
-    override fun dispose() {
-        description += " [disposed]"
-    }
-
-    /** A list of all the classes. Primarily used by [iterateAllClasses]. */
-    private val allClasses: MutableList<ClassItem> = ArrayList(CLASS_ESTIMATE)
-
+interface MutableCodebase : Codebase {
     /**
-     * Add a [ClassItem].
-     *
-     * It is the responsibility of the caller to ensure that each [classItem] is not added more than
-     * once.
+     * Register the class by name, return `true` if the class was registered and `false` if it was
+     * not, i.e. because it is a duplicate.
      */
-    protected fun addClass(classItem: ClassItem) {
-        allClasses.add(classItem)
-    }
-
-    /**
-     * Iterate over all the [ClassItem]s in the [Codebase].
-     *
-     * If additional classes are added to the [Codebase] by [body], e.g. by resolving a
-     * `ClassTypeItem` to a class on the classpath that was not previously loaded, then they will be
-     * included in the iteration.
-     */
-    fun iterateAllClasses(body: (ClassItem) -> Unit) {
-        // Iterate by index not using an iterator to avoid `ConcurrentModificationException`s.
-        // Limit the first round of iteration to just the classes that were present at the start.
-        var start = 0
-        var end = allClasses.size
-        do {
-            // Iterate over the classes in the selected range, invoking [body] pn each.
-            for (i in start until end) {
-                val classItem = allClasses[i]
-                body(classItem)
-            }
-
-            // Move the range to include all the classes, if any, added during the previous round.
-            start = end
-            end = allClasses.size
-
-            // Repeat until no new classes were added.
-        } while (start < end)
-    }
-
-    /** Iterate over all the classes resolving their super class and interface types. */
-    fun resolveSuperTypes() {
-        iterateAllClasses { classItem ->
-            classItem.superClass()
-            for (interfaceType in classItem.interfaceTypes()) {
-                interfaceType.asClass()
-            }
-        }
-    }
+    fun registerClass(classItem: DefaultClassItem): Boolean
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt
new file mode 100644
index 000000000..41fa17099
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import com.android.tools.metalava.model.snapshot.CodebaseSnapshotTaker
+import com.android.tools.metalava.model.snapshot.NonEmittableDelegatingVisitor
+
+/**
+ * Encapsulates [codebase] to visit and a [factory] that if given a [DelegatedVisitor] will return
+ * an [ItemVisitor] that can be used to visit some fragment of the [codebase].
+ */
+class CodebaseFragment(
+    val codebase: Codebase,
+    private val factory: (DelegatedVisitor) -> ItemVisitor,
+) {
+    /**
+     * Create an [ItemVisitor] that will visit this fragment and delegate its contents to
+     * [delegate].
+     */
+    fun createVisitor(delegate: DelegatedVisitor) = factory(delegate)
+
+    /** Take a snapshot of this [CodebaseFragment] and return a new [CodebaseFragment]. */
+    fun snapshotIncludingRevertedItems(): CodebaseFragment {
+        val snapshot = CodebaseSnapshotTaker.takeSnapshot(codebase, factory)
+        return CodebaseFragment(snapshot, ::NonEmittableDelegatingVisitor)
+    }
+
+    /** Visit this fragment, delegating to [delegate]. */
+    fun accept(delegate: DelegatedVisitor) {
+        val visitor = createVisitor(delegate)
+        codebase.accept(visitor)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt
index 7916ace50..fdd2f6cf3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt
@@ -16,7 +16,23 @@
 
 package com.android.tools.metalava.model
 
-interface ConstructorItem : MethodItem {
+interface ConstructorItem : CallableItem {
+
+    /** Override to specialize return type. */
+    override fun returnType(): ClassTypeItem
+
+    /** Override to specialize return type. */
+    override fun type() = returnType()
+
+    override fun accept(visitor: ItemVisitor) {
+        visitor.visit(this)
+    }
+
+    @Deprecated(
+        message =
+            "There is no point in calling this method on ConstructorItem as it always returns true",
+        ReplaceWith("")
+    )
     override fun isConstructor(): Boolean = true
 
     /** Returns the internal name of the class, as seen in bytecode */
@@ -28,13 +44,13 @@ interface ConstructorItem : MethodItem {
         duplicate: Boolean,
     ) = containingClass().findCorrespondingItemIn(codebase)?.findConstructor(this)
 
-    /**
-     * The constructor that the stub version of this constructor must delegate to in its `super`
-     * call. Is `null` if the super class has a default constructor.
-     */
-    var superConstructor: ConstructorItem?
-
     /** True if this is the primary constructor in Kotlin. */
     val isPrimary: Boolean
         get() = false
+
+    /**
+     * True if this is a [ConstructorItem] that was created implicitly by the compiler and so does
+     * not have any corresponding source code.
+     */
+    fun isImplicitConstructor(): Boolean = false
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
index dff80c6c5..b4ac05b38 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
@@ -16,15 +16,44 @@
 
 package com.android.tools.metalava.model
 
-class DefaultModifierList(
-    override val codebase: Codebase,
-    private var flags: Int = PACKAGE_PRIVATE,
-    private var annotations: MutableList<AnnotationItem>? = null
-) : MutableModifierList {
-    /** Set in [DefaultItem] initialization. */
-    internal lateinit var owner: Item
-
-    private operator fun set(mask: Int, set: Boolean) {
+import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
+import com.android.tools.metalava.model.ModifierFlags.Companion.ACTUAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.COMPANION
+import com.android.tools.metalava.model.ModifierFlags.Companion.CONST
+import com.android.tools.metalava.model.ModifierFlags.Companion.DATA
+import com.android.tools.metalava.model.ModifierFlags.Companion.DEFAULT
+import com.android.tools.metalava.model.ModifierFlags.Companion.DEPRECATED
+import com.android.tools.metalava.model.ModifierFlags.Companion.EQUIVALENCE_MASK
+import com.android.tools.metalava.model.ModifierFlags.Companion.EXPECT
+import com.android.tools.metalava.model.ModifierFlags.Companion.FINAL
+import com.android.tools.metalava.model.ModifierFlags.Companion.FUN
+import com.android.tools.metalava.model.ModifierFlags.Companion.INFIX
+import com.android.tools.metalava.model.ModifierFlags.Companion.INLINE
+import com.android.tools.metalava.model.ModifierFlags.Companion.NATIVE
+import com.android.tools.metalava.model.ModifierFlags.Companion.OPERATOR
+import com.android.tools.metalava.model.ModifierFlags.Companion.PACKAGE_PRIVATE
+import com.android.tools.metalava.model.ModifierFlags.Companion.SEALED
+import com.android.tools.metalava.model.ModifierFlags.Companion.STATIC
+import com.android.tools.metalava.model.ModifierFlags.Companion.STRICT_FP
+import com.android.tools.metalava.model.ModifierFlags.Companion.SUSPEND
+import com.android.tools.metalava.model.ModifierFlags.Companion.SYNCHRONIZED
+import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
+import com.android.tools.metalava.model.ModifierFlags.Companion.VALUE
+import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
+import com.android.tools.metalava.model.ModifierFlags.Companion.VISIBILITY_LEVEL_ENUMS
+import com.android.tools.metalava.model.ModifierFlags.Companion.VISIBILITY_MASK
+import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
+import java.lang.annotation.Retention
+import java.lang.annotation.RetentionPolicy
+
+/** Default [BaseModifierList]. */
+internal abstract class DefaultBaseModifierList
+constructor(
+    protected var flags: Int,
+    protected var annotations: List<AnnotationItem> = emptyList(),
+) : BaseModifierList {
+
+    protected operator fun set(mask: Int, set: Boolean) {
         flags =
             if (set) {
                 flags or mask
@@ -38,11 +67,7 @@ class DefaultModifierList(
     }
 
     override fun annotations(): List<AnnotationItem> {
-        return annotations ?: emptyList()
-    }
-
-    override fun owner(): Item {
-        return owner
+        return annotations
     }
 
     override fun getVisibilityLevel(): VisibilityLevel {
@@ -163,6 +188,168 @@ class DefaultModifierList(
         return isSet(ACTUAL)
     }
 
+    override fun isPackagePrivate(): Boolean {
+        return flags and VISIBILITY_MASK == PACKAGE_PRIVATE
+    }
+
+    override fun equivalentTo(owner: Item?, other: BaseModifierList): Boolean {
+        other as DefaultBaseModifierList
+
+        val flags2 = other.flags
+        val mask = EQUIVALENCE_MASK
+
+        val masked1 = flags and mask
+        val masked2 = flags2 and mask
+        val same = masked1 xor masked2
+        if (same == 0) {
+            return true
+        } else {
+            if (
+                same == FINAL &&
+                    // Only differ in final: not significant if implied by containing class
+                    isFinal() &&
+                    (owner as? MethodItem)?.containingClass()?.modifiers?.isFinal() == true
+            ) {
+                return true
+            } else if (
+                same == DEPRECATED &&
+                    // Only differ in deprecated: not significant if implied by containing class
+                    isDeprecated() &&
+                    (owner as? MethodItem)?.containingClass()?.effectivelyDeprecated == true
+            ) {
+                return true
+            }
+        }
+
+        return false
+    }
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is DefaultBaseModifierList) return false
+
+        if (flags != other.flags) return false
+        if (annotations != other.annotations) return false
+
+        return true
+    }
+
+    override fun hashCode(): Int {
+        var result = flags
+        result = 31 * result + annotations.hashCode()
+        return result
+    }
+
+    override fun toString(): String {
+        val binaryFlags = Integer.toBinaryString(flags)
+        return "ModifierList(flags = 0b$binaryFlags, annotations = $annotations)"
+    }
+}
+
+interface ModifierFlags {
+    companion object {
+
+        /**
+         * 'PACKAGE_PRIVATE' is set to 0 to act as the default visibility when no other visibility
+         * flags are explicitly set.
+         */
+        const val PACKAGE_PRIVATE = 0
+        const val PRIVATE = 1
+        const val INTERNAL = 2
+        const val PROTECTED = 3
+        const val PUBLIC = 4
+        const val VISIBILITY_MASK = 0b111
+
+        /**
+         * An internal copy of VisibilityLevel.values() to avoid paying the cost of duplicating the
+         * array on every call.
+         */
+        internal val VISIBILITY_LEVEL_ENUMS = VisibilityLevel.values()
+
+        // Check that the constants above are consistent with the VisibilityLevel enum, i.e. the
+        // mask is large enough
+        // to include all allowable values and that each visibility level value is the same as the
+        // corresponding enum
+        // constant's ordinal.
+        init {
+            check(PACKAGE_PRIVATE == VisibilityLevel.PACKAGE_PRIVATE.ordinal)
+            check(PRIVATE == VisibilityLevel.PRIVATE.ordinal)
+            check(INTERNAL == VisibilityLevel.INTERNAL.ordinal)
+            check(PROTECTED == VisibilityLevel.PROTECTED.ordinal)
+            check(PUBLIC == VisibilityLevel.PUBLIC.ordinal)
+            // Calculate the mask required to hold as many different values as there are
+            // VisibilityLevel values.
+            // Given N visibility levels, the required mask is constructed by determining the MSB in
+            // the number N - 1
+            // and then setting all bits to the right.
+            // e.g. when N is 5 then N - 1 is 4, the MSB is bit 2, and so the mask is what you get
+            // when you set bits 2,
+            // 1 and 0, i.e. 0b111.
+            val expectedMask =
+                (1 shl (32 - Integer.numberOfLeadingZeros(VISIBILITY_LEVEL_ENUMS.size - 1))) - 1
+            check(VISIBILITY_MASK == expectedMask)
+        }
+
+        const val STATIC = 1 shl 3
+        const val ABSTRACT = 1 shl 4
+        const val FINAL = 1 shl 5
+        const val NATIVE = 1 shl 6
+        const val SYNCHRONIZED = 1 shl 7
+        const val STRICT_FP = 1 shl 8
+        const val TRANSIENT = 1 shl 9
+        const val VOLATILE = 1 shl 10
+        const val DEFAULT = 1 shl 11
+        const val DEPRECATED = 1 shl 12
+        const val VARARG = 1 shl 13
+        const val SEALED = 1 shl 14
+        const val FUN = 1 shl 15
+        const val INFIX = 1 shl 16
+        const val OPERATOR = 1 shl 17
+        const val INLINE = 1 shl 18
+        const val SUSPEND = 1 shl 19
+        const val COMPANION = 1 shl 20
+        const val CONST = 1 shl 21
+        const val DATA = 1 shl 22
+        const val VALUE = 1 shl 23
+        const val EXPECT = 1 shl 24
+        const val ACTUAL = 1 shl 25
+
+        /**
+         * Modifiers considered significant to include signature files (and similarly to consider
+         * whether an override of a method is different from its super implementation)
+         */
+        internal const val EQUIVALENCE_MASK =
+            VISIBILITY_MASK or
+                STATIC or
+                ABSTRACT or
+                FINAL or
+                TRANSIENT or
+                VOLATILE or
+                DEPRECATED or
+                VARARG or
+                SEALED or
+                FUN or
+                INFIX or
+                OPERATOR or
+                SUSPEND or
+                COMPANION
+    }
+}
+
+/** Default [MutableModifierList]. */
+internal class DefaultMutableModifierList(
+    flags: Int,
+    annotations: List<AnnotationItem> = emptyList(),
+) : DefaultBaseModifierList(flags, annotations), MutableModifierList {
+
+    override fun toMutable(): MutableModifierList {
+        return this
+    }
+
+    override fun toImmutable(): ModifierList {
+        return DefaultModifierList.create(flags, annotations)
+    }
+
     override fun setVisibilityLevel(level: VisibilityLevel) {
         flags = (flags and VISIBILITY_MASK.inv()) or level.visibilityFlagValue
     }
@@ -255,182 +442,106 @@ class DefaultModifierList(
         set(ACTUAL, actual)
     }
 
-    override fun addAnnotation(annotation: AnnotationItem) {
-        if (annotations == null) {
-            annotations = mutableListOf()
-        }
-        annotations?.add(annotation)
-    }
-
-    override fun removeAnnotation(annotation: AnnotationItem) {
-        annotations?.remove(annotation)
+    override fun mutateAnnotations(mutator: MutableList<AnnotationItem>.() -> Unit) {
+        val mutable = annotations.toMutableList()
+        mutable.mutator()
+        annotations = mutable.toList()
     }
+}
 
-    override fun removeAnnotations(predicate: (AnnotationItem) -> Boolean) {
-        annotations?.removeAll(predicate)
-    }
+/** Default [ModifierList]. */
+internal class DefaultModifierList
+private constructor(
+    flags: Int,
+    annotations: List<AnnotationItem>,
+) : DefaultBaseModifierList(flags, annotations), ModifierList {
 
-    override fun clearAnnotations(annotation: AnnotationItem) {
-        annotations?.clear()
+    override fun toMutable(): MutableModifierList {
+        return DefaultMutableModifierList(flags, annotations)
     }
 
-    override fun isEmpty(): Boolean {
-        return flags and DEPRECATED.inv() == 0 // deprecated isn't a real modifier
+    override fun toImmutable(): ModifierList {
+        return this
     }
 
-    override fun isPackagePrivate(): Boolean {
-        return flags and VISIBILITY_MASK == PACKAGE_PRIVATE
-    }
+    override fun snapshot(targetCodebase: Codebase): ModifierList {
+        if (annotations.isEmpty()) return this
 
-    /**
-     * Copy this, so it can be used on (and possibly modified by) another [Item] from the same
-     * codebase.
-     */
-    fun duplicate(): DefaultModifierList {
-        val annotations = this.annotations
-        val newAnnotations =
-            if (annotations == null || annotations.isEmpty()) {
-                null
-            } else {
-                annotations.toMutableList()
-            }
-        return DefaultModifierList(codebase, flags, newAnnotations)
+        val newAnnotations = annotations.map { it.snapshot(targetCodebase) }
+        return create(flags, newAnnotations)
     }
 
-    // Rename? It's not a full equality, it's whether an override's modifier set is significant
-    override fun equivalentTo(other: ModifierList): Boolean {
-        if (other is DefaultModifierList) {
-            val flags2 = other.flags
-            val mask = EQUIVALENCE_MASK
-
-            val masked1 = flags and mask
-            val masked2 = flags2 and mask
-            val same = masked1 xor masked2
-            if (same == 0) {
-                return true
-            } else {
-                if (
-                    same == FINAL &&
-                        // Only differ in final: not significant if implied by containing class
-                        isFinal() &&
-                        (owner as? MethodItem)?.containingClass()?.modifiers?.isFinal() == true
-                ) {
-                    return true
-                } else if (
-                    same == DEPRECATED &&
-                        // Only differ in deprecated: not significant if implied by containing class
-                        isDeprecated() &&
-                        (owner as? MethodItem)?.containingClass()?.effectivelyDeprecated == true
-                ) {
-                    return true
-                }
+    companion object {
+        private var cache = mutableMapOf<Int, DefaultModifierList>()
+
+        /** Not thread-safe. */
+        fun create(
+            flags: Int,
+            annotations: List<AnnotationItem> = emptyList(),
+        ): ModifierList {
+            if (annotations.isEmpty()) {
+                return cache.computeIfAbsent(flags) { DefaultModifierList(it, emptyList()) }
             }
+            return DefaultModifierList(flags, annotations)
         }
-        return false
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (javaClass != other?.javaClass) return false
-
-        other as DefaultModifierList
-
-        if (flags != other.flags) return false
-        if (annotations != other.annotations) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        var result = flags
-        result = 31 * result + (annotations?.hashCode() ?: 0)
-        return result
     }
+}
 
-    companion object {
-        /**
-         * 'PACKAGE_PRIVATE' is set to 0 to act as the default visibility when no other visibility
-         * flags are explicitly set.
-         */
-        const val PACKAGE_PRIVATE = 0
-        const val PRIVATE = 1
-        const val INTERNAL = 2
-        const val PROTECTED = 3
-        const val PUBLIC = 4
-        const val VISIBILITY_MASK = 0b111
-
-        /**
-         * An internal copy of VisibilityLevel.values() to avoid paying the cost of duplicating the
-         * array on every call.
-         */
-        private val VISIBILITY_LEVEL_ENUMS = VisibilityLevel.values()
+/**
+ * Add a [Retention] annotation with the default [RetentionPolicy] suitable for [codebase].
+ *
+ * The caller must ensure that the annotation does not already have a [Retention] annotation before
+ * calling this.
+ */
+fun MutableModifierList.addDefaultRetentionPolicyAnnotation(
+    codebase: Codebase,
+    isKotlin: Boolean,
+) {
+    // By policy, include explicit retention policy annotation if missing
+    val defaultRetentionPolicy = AnnotationRetention.getDefault(isKotlin)
+    addAnnotation(
+        codebase.createAnnotation(
+            buildString {
+                append('@')
+                append(Retention::class.qualifiedName)
+                append('(')
+                append(RetentionPolicy::class.qualifiedName)
+                append('.')
+                append(defaultRetentionPolicy.name)
+                append(')')
+            },
+        )
+    )
+}
 
-        // Check that the constants above are consistent with the VisibilityLevel enum, i.e. the
-        // mask is large enough
-        // to include all allowable values and that each visibility level value is the same as the
-        // corresponding enum
-        // constant's ordinal.
-        init {
-            check(PACKAGE_PRIVATE == VisibilityLevel.PACKAGE_PRIVATE.ordinal)
-            check(PRIVATE == VisibilityLevel.PRIVATE.ordinal)
-            check(INTERNAL == VisibilityLevel.INTERNAL.ordinal)
-            check(PROTECTED == VisibilityLevel.PROTECTED.ordinal)
-            check(PUBLIC == VisibilityLevel.PUBLIC.ordinal)
-            // Calculate the mask required to hold as many different values as there are
-            // VisibilityLevel values.
-            // Given N visibility levels, the required mask is constructed by determining the MSB in
-            // the number N - 1
-            // and then setting all bits to the right.
-            // e.g. when N is 5 then N - 1 is 4, the MSB is bit 2, and so the mask is what you get
-            // when you set bits 2,
-            // 1 and 0, i.e. 0b111.
-            val expectedMask =
-                (1 shl (32 - Integer.numberOfLeadingZeros(VISIBILITY_LEVEL_ENUMS.size - 1))) - 1
-            check(VISIBILITY_MASK == expectedMask)
-        }
+/**
+ * Create an immutable [ModifierList] with the [visibility] level and an optional list of
+ * [AnnotationItem]s.
+ */
+fun createImmutableModifiers(
+    visibility: VisibilityLevel,
+    annotations: List<AnnotationItem> = emptyList(),
+): ModifierList {
+    return DefaultModifierList.create(visibility.visibilityFlagValue, annotations)
+}
 
-        const val STATIC = 1 shl 3
-        const val ABSTRACT = 1 shl 4
-        const val FINAL = 1 shl 5
-        const val NATIVE = 1 shl 6
-        const val SYNCHRONIZED = 1 shl 7
-        const val STRICT_FP = 1 shl 8
-        const val TRANSIENT = 1 shl 9
-        const val VOLATILE = 1 shl 10
-        const val DEFAULT = 1 shl 11
-        const val DEPRECATED = 1 shl 12
-        const val VARARG = 1 shl 13
-        const val SEALED = 1 shl 14
-        const val FUN = 1 shl 15
-        const val INFIX = 1 shl 16
-        const val OPERATOR = 1 shl 17
-        const val INLINE = 1 shl 18
-        const val SUSPEND = 1 shl 19
-        const val COMPANION = 1 shl 20
-        const val CONST = 1 shl 21
-        const val DATA = 1 shl 22
-        const val VALUE = 1 shl 23
-        const val EXPECT = 1 shl 24
-        const val ACTUAL = 1 shl 25
+/**
+ * Create a [MutableModifierList] with the [visibility] level and an optional list of
+ * [AnnotationItem]s.
+ */
+fun createMutableModifiers(
+    visibility: VisibilityLevel,
+    annotations: List<AnnotationItem> = emptyList(),
+): MutableModifierList {
+    return DefaultMutableModifierList(visibility.visibilityFlagValue, annotations)
+}
 
-        /**
-         * Modifiers considered significant to include signature files (and similarly to consider
-         * whether an override of a method is different from its super implementation)
-         */
-        private const val EQUIVALENCE_MASK =
-            VISIBILITY_MASK or
-                STATIC or
-                ABSTRACT or
-                FINAL or
-                TRANSIENT or
-                VOLATILE or
-                DEPRECATED or
-                VARARG or
-                SEALED or
-                FUN or
-                INFIX or
-                OPERATOR or
-                SUSPEND or
-                COMPANION
-    }
+/**
+ * Create a [MutableModifierList] from a set of [flags] and an optional list of [AnnotationItem]s.
+ */
+fun createMutableModifiers(
+    flags: Int,
+    annotations: List<AnnotationItem> = emptyList(),
+): MutableModifierList {
+    return DefaultMutableModifierList(flags, annotations)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt
new file mode 100644
index 000000000..2a8b3f4fa
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/DelegatedVisitor.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/**
+ * A special visitor interface suitable for use with code that traverses a [Codebase] and which
+ * wants to delegate the visiting of the [Item]s to another class.
+ */
+interface DelegatedVisitor {
+    /**
+     * If `true` then a nested class is visited while visiting the containing class, otherwise
+     * nested classes are visited after visiting the containing class. A class is being visited
+     * between calls to [visitClass] and [afterVisitClass].
+     *
+     * Defaults to `false` simply because most implementations do not need to preserve class
+     * nesting.
+     */
+    val requiresClassNesting: Boolean
+        get() = false
+
+    fun visitCodebase(codebase: Codebase) {}
+
+    fun afterVisitCodebase(codebase: Codebase) {}
+
+    fun visitPackage(pkg: PackageItem) {}
+
+    fun afterVisitPackage(pkg: PackageItem) {}
+
+    fun visitClass(cls: ClassItem) {}
+
+    fun afterVisitClass(cls: ClassItem) {}
+
+    fun visitConstructor(constructor: ConstructorItem) {}
+
+    fun visitField(field: FieldItem) {}
+
+    fun visitMethod(method: MethodItem) {}
+
+    fun visitProperty(property: PropertyItem) {}
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
index 49251f89d..42cc900f1 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
@@ -16,10 +16,11 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.item.FieldValue
 import java.io.PrintWriter
 
 @MetalavaApi
-interface FieldItem : MemberItem {
+interface FieldItem : MemberItem, InheritableItem {
     /** The property this field backs; inverse of [PropertyItem.backingField] */
     val property: PropertyItem?
         get() = null
@@ -33,6 +34,9 @@ interface FieldItem : MemberItem {
         duplicate: Boolean,
     ) = containingClass().findCorrespondingItemIn(codebase)?.findField(name())
 
+    /** The optional value of this [FieldItem]. */
+    val fieldValue: FieldValue?
+
     /**
      * The initial/constant value, if any. If [requireConstant] the initial value will only be
      * returned if it's constant.
@@ -58,6 +62,17 @@ interface FieldItem : MemberItem {
         visitor.visit(this)
     }
 
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is FieldItem) return false
+
+        return name() == other.name() && containingClass() == other.containingClass()
+    }
+
+    override fun hashCodeForItem(): Int {
+        return name().hashCode()
+    }
+
     override fun toStringForItem() = "field ${containingClass().fullName()}.${name()}"
 
     /**
@@ -94,10 +109,28 @@ interface FieldItem : MemberItem {
         return false
     }
 
+    /**
+     * Warn if companion constants are not marked with @JvmField.
+     *
+     * Checks the field to see if it is a companion object constant and if it is then make sure that
+     * it is annotated with `@JvmField`, reporting an issue otherwise.
+     *
+     * TODO: This should probably be in a PSI specific API Lint check (when they are supported) but
+     *   it is here for now to avoid dependencies on PSI specific code in API Lint.
+     */
+    fun ensureCompanionFieldJvmField() {}
+
     companion object {
         val comparator: java.util.Comparator<FieldItem> = Comparator { a, b ->
             a.name().compareTo(b.name())
         }
+
+        /**
+         * Comparator that will order [FieldItem]s such that those for which
+         * [FieldItem.isEnumConstant] returns `true` will come before those for which it is `false`.
+         */
+        val comparatorEnumConstantFirst: java.util.Comparator<FieldItem> =
+            Comparator.comparing(FieldItem::isEnumConstant).reversed().thenComparing(comparator)
     }
 
     /**
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FixedDefaultValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FixedDefaultValue.kt
new file mode 100644
index 000000000..504d6e8b1
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/FixedDefaultValue.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import com.android.tools.metalava.model.item.DefaultValue
+
+/** Encapsulates information about a fixed default value. */
+internal class FixedDefaultValue(private val value: String?) : DefaultValue {
+
+    /** This is always true as the text model will use [DefaultValue.NONE] for no value. */
+    override fun hasDefaultValue() = true
+
+    /** This is always true as the text model will use [DefaultValue.UNKNOWN] for no value. */
+    override fun isDefaultValueKnown() = true
+
+    override fun value() = value
+
+    /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
+    override fun duplicate(parameter: ParameterItem) = this
+
+    /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
+    override fun snapshot(parameter: ParameterItem) = this
+
+    override fun toString() = "DefaultValue($value)"
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FixedFieldValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FixedFieldValue.kt
new file mode 100644
index 000000000..4f4908c4c
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/FixedFieldValue.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import com.android.tools.metalava.model.item.FieldValue
+
+/** Provides access to the initial values of a field. */
+class FixedFieldValue(
+    private var initialValueWithRequiredConstant: Any?,
+    private var initialValueWithoutRequiredConstant: Any? = initialValueWithRequiredConstant,
+) : FieldValue {
+
+    override fun initialValue(requireConstant: Boolean) =
+        if (requireConstant) initialValueWithRequiredConstant
+        else initialValueWithoutRequiredConstant
+
+    override fun snapshot() = this
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/InheritableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/InheritableItem.kt
new file mode 100644
index 000000000..7c09b24f8
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/InheritableItem.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/** A [MemberItem] that can be inherited from one class to another. */
+interface InheritableItem : MemberItem {
+
+    /** True if this member was inherited from an ancestor class or interface. */
+    val inheritedFromAncestor
+        get() = inheritedFrom != null
+
+    /**
+     * If this member is inherited from a super class (typically via [duplicate]) this field points
+     * to the original class it was inherited from
+     */
+    val inheritedFrom: ClassItem?
+
+    /**
+     * Duplicates this member item.
+     *
+     * This is only used when comparing two [Codebase]s, in which case it is called to inherit a
+     * member from a super class/interface when it exists in the other [Codebase]. The resulting
+     * [InheritableItem] is expected to behave as if it was part of the [targetContainingClass] but
+     * is otherwise identical to `this`, e.g. if [targetContainingClass] is [hidden] then so should
+     * the returned [InheritableItem].
+     *
+     * The [inheritedFrom] property in the returned [InheritableItem] is set to [containingClass] of
+     * this [InheritableItem].
+     *
+     * @param targetContainingClass the [ClassItem] that will be used as
+     *   [InheritableItem.containingClass]. Note, this may be from a different [Codebase]
+     *   implementation than the [InheritableItem] so implementations must be careful to avoid an
+     *   unconditional downcast.
+     */
+    fun duplicate(targetContainingClass: ClassItem): InheritableItem
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
index 626d4e2da..c4f082d07 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
@@ -41,19 +41,33 @@ interface Item : Reportable {
     /**
      * Whether this element was originally hidden with @hide/@Hide. The [hidden] property tracks
      * whether it is *actually* hidden, since elements can be unhidden via show annotations, etc.
+     *
+     * @see variantSelectors
      */
-    var originallyHidden: Boolean
+    val originallyHidden: Boolean
 
     /**
      * Whether this element has been hidden with @hide/@Hide (or after propagation, in some
      * containing class/pkg)
+     *
+     * @see variantSelectors
+     */
+    val hidden: Boolean
+
+    /**
+     * Tracks the properties that determine whether this [Item] will be selected for each API
+     * variant.
+     *
+     * @see originallyHidden
+     * @see hidden
+     * @see removed
      */
-    var hidden: Boolean
+    val variantSelectors: ApiVariantSelectors
 
     /** Whether this element will be printed in the signature file */
     var emit: Boolean
 
-    fun parent(): Item?
+    fun parent(): SelectableItem?
 
     /**
      * Recursive check to see if this item or any of its parents (containing class, containing
@@ -75,8 +89,10 @@ interface Item : Reportable {
     /**
      * Whether this element has been removed with @removed/@Remove (or after propagation, in some
      * containing class)
+     *
+     * @see variantSelectors
      */
-    var removed: Boolean
+    val removed: Boolean
 
     /** True if this item has been marked deprecated. */
     val originallyDeprecated: Boolean
@@ -87,31 +103,28 @@ interface Item : Reportable {
      */
     val effectivelyDeprecated: Boolean
 
-    /** True if this element is only intended for documentation */
-    var docOnly: Boolean
-
     /** True if this item is either hidden or removed */
     fun isHiddenOrRemoved(): Boolean = hidden || removed
 
     /** Visits this element using the given [visitor] */
     fun accept(visitor: ItemVisitor)
 
-    /** Get a mutable version of modifiers for this item */
-    fun mutableModifiers(): MutableModifierList
-
     /**
-     * The javadoc/KDoc comment for this code element, if any. This is the original content of the
-     * documentation, including lexical tokens to begin, continue and end the comment (such as /+*).
-     * See [fullyQualifiedDocumentation] to look up the documentation with fully qualified
-     * references to classes.
+     * Mutate the [modifiers] list.
+     *
+     * Provides a [MutableModifierList] of the [modifiers] that can be modified by [mutator]. Once
+     * the mutator exits the [modifiers] will be updated. The [MutableModifierList] must not be
+     * accessed from outside [mutator].
      */
-    var documentation: String
+    fun mutateModifiers(mutator: MutableModifierList.() -> Unit)
 
     /**
-     * Looks up docs for the first instance of a specific javadoc tag having the (optionally)
-     * provided value (e.g. parameter name).
+     * The javadoc/KDoc comment for this code element, if any. This is the original content of the
+     * documentation, including lexical tokens to begin, continue and end the comment (such as /+*).
+     * See [ItemDocumentation.fullyQualifiedDocumentation] to look up the documentation with fully
+     * qualified references to classes.
      */
-    fun findTagDocumentation(tag: String, value: String? = null): String?
+    val documentation: ItemDocumentation
 
     /**
      * A rank used for sorting. This allows signature files etc to sort similar items by a natural
@@ -126,11 +139,13 @@ interface Item : Reportable {
      * Add the given text to the documentation.
      *
      * If the [tagSection] is null, add the comment to the initial text block of the description.
-     * Otherwise if it is "@return", add the comment to the return value. Otherwise the [tagSection]
-     * is taken to be the parameter name, and the comment added as parameter documentation for the
-     * given parameter.
+     *
+     * If it is "@return", add the comment to the return value.
+     *
+     * Otherwise, the [tagSection] is taken to be the parameter name, and the comment added as
+     * parameter documentation for the given parameter.
      */
-    fun appendDocumentation(comment: String, tagSection: String? = null, append: Boolean = true)
+    fun appendDocumentation(comment: String, tagSection: String? = null)
 
     val isPublic: Boolean
     val isProtected: Boolean
@@ -138,28 +153,53 @@ interface Item : Reportable {
     val isPackagePrivate: Boolean
     val isPrivate: Boolean
 
-    // make sure these are implemented so we can place in maps:
+    /** Calls [equalsToItem]. */
     override fun equals(other: Any?): Boolean
 
+    /** Calls [hashCodeForItem]. */
     override fun hashCode(): Int
 
     /** Calls [toStringForItem]. */
     override fun toString(): String
 
+    /**
+     * Whether this [Item] is equal to [other].
+     *
+     * This is implemented instead of [equals] because interfaces are not allowed to implement
+     * [equals]. Implementations of this will implement [equals] by calling this.
+     */
+    fun equalsToItem(other: Any?): Boolean
+
+    /**
+     * Hashcode for this [Item].
+     *
+     * This is implemented instead of [hashCode] because interfaces are not allowed to implement
+     * [hashCode]. Implementations of this will implement [hashCode] by calling this.
+     */
+    fun hashCodeForItem(): Int
+
     /** Provides a string representation of the item, suitable for use while debugging. */
     fun toStringForItem(): String
 
     /**
-     * Whether this item was loaded from the classpath (e.g. jar dependencies) rather than be
-     * declared as source
+     * The language in which this was written, or [ItemLanguage.UNKNOWN] if not known, e.g. when
+     * created from a signature file.
      */
-    fun isFromClassPath(): Boolean = false
+    val itemLanguage: ItemLanguage
 
-    /** Is this element declared in Java (rather than Kotlin) ? */
-    fun isJava(): Boolean = true
+    /**
+     * Is this element declared in Java (rather than Kotlin) ?
+     *
+     * See [itemLanguage].
+     */
+    fun isJava() = itemLanguage.isJava()
 
-    /** Is this element declared in Kotlin (rather than Java) ? */
-    fun isKotlin() = !isJava()
+    /**
+     * Is this element declared in Kotlin (rather than Java) ?
+     *
+     * See [itemLanguage].
+     */
+    fun isKotlin() = itemLanguage.isKotlin()
 
     /** Determines whether this item will be shown as part of the API or not. */
     val showability: Showability
@@ -171,19 +211,23 @@ interface Item : Reportable {
      */
     fun hasShowAnnotation(): Boolean = showability.show()
 
+    /** Returns true if this modifier list contains any hide annotations */
+    fun hasHideAnnotation(): Boolean = codebase.annotationManager.hasHideAnnotations(modifiers)
+
     /**
-     * Returns true if this has any show single annotations.
+     * Returns true if this [Item]'s modifier list contains any suppress compatibility
+     * meta-annotations.
      *
-     * See [Showability.recursive]
+     * Metalava will suppress compatibility checks for APIs which are within the scope of a
+     * "suppress compatibility" meta-annotation, but they may still be written to API files or stub
+     * JARs.
+     *
+     * "Suppress compatibility" meta-annotations allow Metalava to handle concepts like Jetpack
+     * experimental APIs, where developers can use the [RequiresOptIn] meta-annotation to mark
+     * feature sets with unstable APIs.
      */
-    fun hasShowSingleAnnotation(): Boolean = showability.showNonRecursive()
-
-    /** Returns true if this modifier list contains any hide annotations */
-    fun hasHideAnnotation(): Boolean =
-        modifiers.codebase.annotationManager.hasHideAnnotations(modifiers)
-
     fun hasSuppressCompatibilityMetaAnnotation(): Boolean =
-        modifiers.hasSuppressCompatibilityMetaAnnotations()
+        codebase.annotationManager.hasSuppressCompatibilityMetaAnnotations(modifiers)
 
     fun sourceFile(): SourceFile? {
         var curr: Item? = this
@@ -200,17 +244,6 @@ interface Item : Reportable {
     override val fileLocation: FileLocation
         get() = FileLocation.UNKNOWN
 
-    /**
-     * Returns the [documentation], but with fully qualified links (except for the same package, and
-     * when turning a relative reference into a fully qualified reference, use the javadoc syntax
-     * for continuing to display the relative text, e.g. instead of {@link java.util.List}, use
-     * {@link java.util.List List}.
-     */
-    fun fullyQualifiedDocumentation(): String = documentation
-
-    /** Expands the given documentation comment in the current name context */
-    fun fullyQualifiedDocumentation(documentation: String): String = documentation
-
     /**
      * Produces a user visible description of this item, including a label such as "class" or
      * "field"
@@ -236,6 +269,13 @@ interface Item : Reportable {
      */
     fun type(): TypeItem?
 
+    /**
+     * Set the type of this.
+     *
+     * The [type] parameter must be of the same concrete type as returned by the [Item.type] method.
+     */
+    fun setType(type: TypeItem)
+
     /**
      * Find the [Item] in [codebase] that corresponds to this item, or `null` if there is no such
      * item.
@@ -261,7 +301,7 @@ interface Item : Reportable {
      * @param superMethods if true and this is a [MethodItem] then this method will search for super
      *   methods. If this is a [ParameterItem] then the value of this parameter will be passed to
      *   the [findCorrespondingItemIn] call which is used to find the [MethodItem] corresponding to
-     *   the [ParameterItem.containingMethod].
+     *   the [ParameterItem.containingCallable].
      * @param duplicate if true, and this is a [MemberItem] (or [ParameterItem]) then the returned
      *   [Item], if any, will be in the [ClassItem] that corresponds to the [Item.containingClass].
      *   This should be `true` if the returned [Item] is going to be compared to the original [Item]
@@ -299,7 +339,7 @@ interface Item : Reportable {
                 is PackageItem -> describe(item, capitalize = capitalize)
                 is ClassItem -> describe(item, capitalize = capitalize)
                 is FieldItem -> describe(item, capitalize = capitalize)
-                is MethodItem ->
+                is CallableItem ->
                     describe(
                         item,
                         includeParameterNames = false,
@@ -318,7 +358,7 @@ interface Item : Reportable {
         }
 
         fun describe(
-            item: MethodItem,
+            item: CallableItem,
             includeParameterNames: Boolean = false,
             includeParameterTypes: Boolean = false,
             includeReturnValue: Boolean = false,
@@ -335,7 +375,7 @@ interface Item : Reportable {
                 builder.append(item.returnType().toSimpleType())
                 builder.append(' ')
             }
-            appendMethodSignature(builder, item, includeParameterNames, includeParameterTypes)
+            appendCallableSignature(builder, item, includeParameterNames, includeParameterTypes)
             return builder.toString()
         }
 
@@ -350,14 +390,14 @@ interface Item : Reportable {
             builder.append(' ')
             builder.append(item.name())
             builder.append(" in ")
-            val method = item.containingMethod()
-            appendMethodSignature(builder, method, includeParameterNames, includeParameterTypes)
+            val callable = item.containingCallable()
+            appendCallableSignature(builder, callable, includeParameterNames, includeParameterTypes)
             return builder.toString()
         }
 
-        private fun appendMethodSignature(
+        private fun appendCallableSignature(
             builder: StringBuilder,
-            item: MethodItem,
+            item: CallableItem,
             includeParameterNames: Boolean,
             includeParameterTypes: Boolean
         ) {
@@ -405,21 +445,73 @@ interface Item : Reportable {
         }
 
         private fun describe(item: PackageItem, capitalize: Boolean = false): String {
-            return "${if (capitalize) "Package" else "package"} ${item.qualifiedName()}"
+            val suffix = item.qualifiedName().let { if (it.isEmpty()) "<root>" else it }
+            return "${if (capitalize) "Package" else "package"} $suffix"
         }
     }
 }
 
-abstract class DefaultItem(
+/** Base [Item] implementation that is common to all models. */
+abstract class AbstractItem(
     final override val fileLocation: FileLocation,
-    final override val modifiers: DefaultModifierList,
+    final override val itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
 ) : Item {
 
+    /**
+     * Create a [ItemDocumentation] appropriate for this [Item].
+     *
+     * The leaking of `this` is safe as the implementations do not access anything that has not been
+     * initialized.
+     */
+    final override val documentation = @Suppress("LeakingThis") documentationFactory(this)
+
+    /**
+     * The immutable [modifiers].
+     *
+     * The supplied `modifiers` parameter could be either [MutableModifierList] or [ModifierList]
+     * but this requires a [ModifierList] so get one using [BaseModifierList.toImmutable].
+     *
+     * The [ModifierList] that this references is immutable but the [mutateModifiers] method can be
+     * used to change the [ModifierList] to which this refers.
+     */
+    final override var modifiers: ModifierList = modifiers.toImmutable()
+        private set
+
     init {
-        @Suppress("LeakingThis")
-        modifiers.owner = this
+        if (documentation.contains("@deprecated") && !modifiers.isDeprecated()) {
+            mutateModifiers { setDeprecated(true) }
+        }
     }
 
+    /**
+     * Create a [ApiVariantSelectors] appropriate for this [Item].
+     *
+     * The leaking of `this` is safe as the implementations do not access anything that has not been
+     * initialized.
+     */
+    override val variantSelectors = @Suppress("LeakingThis") variantSelectorsFactory(this)
+
+    /**
+     * Manually delegate to [ApiVariantSelectors.originallyHidden] as property delegates are
+     * expensive.
+     */
+    final override val originallyHidden
+        get() = variantSelectors.originallyHidden
+
+    /** Manually delegate to [ApiVariantSelectors.hidden] as property delegates are expensive. */
+    final override val hidden
+        get() = variantSelectors.hidden
+
+    /** Manually delegate to [ApiVariantSelectors.removed] as property delegates are expensive. */
+    final override val removed: Boolean
+        get() = variantSelectors.removed
+
+    final override val showability: Showability
+        get() = variantSelectors.showability
+
     final override val sortingRank: Int = nextRank.getAndIncrement()
 
     final override val originallyDeprecated
@@ -427,38 +519,40 @@ abstract class DefaultItem(
         // the value of this and [Item.effectivelyDeprecated] which delegates to this.
         get() = modifiers.isDeprecated()
 
-    final override fun mutableModifiers(): MutableModifierList = modifiers
+    override fun mutateModifiers(mutator: MutableModifierList.() -> Unit) {
+        val mutable = modifiers.toMutable()
+        mutable.mutator()
+        modifiers = mutable.toImmutable()
+    }
 
-    override val isPublic: Boolean
+    final override val isPublic: Boolean
         get() = modifiers.isPublic()
 
-    override val isProtected: Boolean
+    final override val isProtected: Boolean
         get() = modifiers.isProtected()
 
-    override val isInternal: Boolean
+    final override val isInternal: Boolean
         get() = modifiers.getVisibilityLevel() == VisibilityLevel.INTERNAL
 
-    override val isPackagePrivate: Boolean
+    final override val isPackagePrivate: Boolean
         get() = modifiers.isPackagePrivate()
 
-    override val isPrivate: Boolean
+    final override val isPrivate: Boolean
         get() = modifiers.isPrivate()
 
-    final override var emit = true
+    final override var emit =
+        // Do not emit expect declarations in APIs.
+        !modifiers.isExpect()
 
     companion object {
         private var nextRank = AtomicInteger()
     }
 
-    override val showability: Showability by lazy {
-        codebase.annotationManager.getShowabilityForItem(this)
-    }
-
-    override fun suppressedIssues(): Set<String> {
+    final override fun suppressedIssues(): Set<String> {
         return buildSet {
             for (annotation in modifiers.annotations()) {
                 val annotationName = annotation.qualifiedName
-                if (annotationName != null && annotationName in SUPPRESS_ANNOTATIONS) {
+                if (annotationName in SUPPRESS_ANNOTATIONS) {
                     for (attribute in annotation.attributes) {
                         // Assumption that all annotations in SUPPRESS_ANNOTATIONS only have
                         // one attribute such as value/names that is varargs of String
@@ -478,5 +572,30 @@ abstract class DefaultItem(
         }
     }
 
+    final override fun appendDocumentation(comment: String, tagSection: String?) {
+        if (comment.isBlank()) {
+            return
+        }
+
+        // TODO: Figure out if an annotation should go on the return value, or on the method.
+        // For example; threading: on the method, range: on the return value.
+        // TODO: Find a good way to add or append to a given tag (@param <something>, @return, etc)
+
+        if (this is ParameterItem) {
+            // For parameters, the documentation goes into the surrounding method's documentation!
+            // Find the right parameter location!
+            val parameterName = name()
+            val target = containingCallable()
+            target.appendDocumentation(comment, parameterName)
+            return
+        }
+
+        documentation.appendDocumentation(comment, tagSection)
+    }
+
+    final override fun equals(other: Any?) = equalsToItem(other)
+
+    final override fun hashCode() = hashCodeForItem()
+
     final override fun toString() = toStringForItem()
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt
new file mode 100644
index 000000000..a3c70ef7b
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import java.util.regex.Pattern
+
+/** A factory that will create an [ItemDocumentation] for a specific [Item]. */
+typealias ItemDocumentationFactory = (Item) -> ItemDocumentation
+
+/**
+ * The documentation associated with an [Item].
+ *
+ * This implements [CharSequence] to simplify migration.
+ */
+interface ItemDocumentation : CharSequence {
+    val text: String
+
+    override val length
+        get() = text.length
+
+    override fun get(index: Int) = text.get(index)
+
+    override fun subSequence(startIndex: Int, endIndex: Int) =
+        text.subSequence(startIndex, endIndex)
+
+    /**
+     * True if the documentation contains one of the following tags that indicates that it should
+     * not be part of an API, unless overridden by a show annotation:
+     * * `@hide`
+     * * `@pending`
+     * * `@suppress`
+     */
+    val isHidden: Boolean
+
+    /**
+     * True if the documentation contains `@doconly` which indicates that it should only be included
+     * in stubs that are generated for documentation purposes.
+     */
+    val isDocOnly: Boolean
+
+    /**
+     * True if the documentation contains `@removed` which indicates that the [Item] must not be
+     * included in stubs or the main signature file but will be included in the `removed` signature
+     * file as it is still considered part of the API available at runtime and so cannot be removed
+     * altogether.
+     */
+    val isRemoved: Boolean
+
+    /**
+     * Return a duplicate of this instance.
+     *
+     * [ItemDocumentation] instances can be mutable, and if they are then they must not be shared.
+     */
+    fun duplicate(item: Item): ItemDocumentation
+
+    /**
+     * Like [duplicate] except that it returns an instance of [ItemDocumentation] suitable for use
+     * in the snapshot.
+     */
+    fun snapshot(item: Item): ItemDocumentation = text.toItemDocumentation()
+
+    /** Work around javadoc cutting off the summary line after the first ". ". */
+    fun workAroundJavaDocSummaryTruncationIssue() {}
+
+    /**
+     * Add the given text to the documentation.
+     *
+     * If the [tagSection] is null, add the comment to the initial text block of the description.
+     * Otherwise, if it is "@return", add the comment to the return value. Otherwise, the
+     * [tagSection] is taken to be the parameter name, and the comment added as parameter
+     * documentation for the given parameter.
+     */
+    fun appendDocumentation(comment: String, tagSection: String?)
+
+    /**
+     * Looks up docs for the first instance of a specific javadoc tag having the (optionally)
+     * provided value (e.g. parameter name).
+     */
+    fun findTagDocumentation(tag: String, value: String? = null): String?
+
+    /** Returns the main documentation for the method (the documentation before any tags). */
+    fun findMainDocumentation(): String
+
+    /**
+     * Returns the [text], but with fully qualified links (except for the same package, and when
+     * turning a relative reference into a fully qualified reference, use the javadoc syntax for
+     * continuing to display the relative text, e.g. instead of {@link java.util.List}, use {@link
+     * java.util.List List}.
+     */
+    fun fullyQualifiedDocumentation(): String = fullyQualifiedDocumentation(text)
+
+    /** Expands the given documentation comment in the current name context */
+    fun fullyQualifiedDocumentation(documentation: String): String = documentation
+
+    /** Remove the `@deprecated` section, if any. */
+    fun removeDeprecatedSection()
+
+    companion object {
+        /**
+         * A special [ItemDocumentation] that contains no documentation.
+         *
+         * Used where there is no documentation possible, e.g. text model, type parameters,
+         * parameters.
+         */
+        val NONE: ItemDocumentation = EmptyItemDocumentation()
+
+        /**
+         * A special [ItemDocumentationFactory] that returns [NONE] which contains no documentation.
+         *
+         * Used where there is no documentation possible, e.g. text model, type parameters,
+         * parameters.
+         */
+        val NONE_FACTORY: ItemDocumentationFactory = { NONE }
+
+        /** Wrap a [String] in an [ItemDocumentationFactory]. */
+        fun String.toItemDocumentationFactory(): ItemDocumentationFactory = {
+            toItemDocumentation()
+        }
+
+        /** Wrap a [String] in an [ItemDocumentation] instance. */
+        fun String.toItemDocumentation(): ItemDocumentation = DefaultItemDocumentation(this)
+    }
+
+    /** An empty [ItemDocumentation] that can never contain any text. */
+    private class EmptyItemDocumentation : ItemDocumentation {
+        override val text
+            get() = ""
+
+        override val isHidden
+            get() = false
+
+        override val isDocOnly
+            get() = false
+
+        override val isRemoved
+            get() = false
+
+        // This is ok to share as it is immutable.
+        override fun duplicate(item: Item) = this
+
+        // This is ok to use in a snapshot as it is immutable and model independent.
+        override fun snapshot(item: Item) = this
+
+        override fun findTagDocumentation(tag: String, value: String?): String? = null
+
+        override fun appendDocumentation(comment: String, tagSection: String?) {
+            error("cannot modify documentation on an item that does not support documentation")
+        }
+
+        override fun findMainDocumentation() = ""
+
+        override fun removeDeprecatedSection() {}
+    }
+}
+
+/**
+ * Abstract [ItemDocumentation] into which functionality that is common to all models will be added.
+ */
+abstract class AbstractItemDocumentation : ItemDocumentation {
+
+    /**
+     * The mutable text contents of the documentation. This is abstract to allow the implementations
+     * of this to optimize how it is accessed, e.g. initialize it lazily.
+     */
+    abstract override var text: String
+
+    override val isHidden
+        get() =
+            text.contains('@') &&
+                (text.contains("@hide") ||
+                    text.contains("@pending") ||
+                    // KDoc:
+                    text.contains("@suppress"))
+
+    override val isDocOnly
+        get() = text.contains("@doconly")
+
+    override val isRemoved
+        get() = text.contains("@removed")
+
+    override fun workAroundJavaDocSummaryTruncationIssue() {
+        // Work around javadoc cutting off the summary line after the first ". ".
+        val firstDot = text.indexOf(".")
+        if (firstDot > 0 && text.regionMatches(firstDot - 1, "e.g. ", 0, 5, false)) {
+            text = text.substring(0, firstDot) + ".g.&nbsp;" + text.substring(firstDot + 4)
+        }
+    }
+
+    override fun findTagDocumentation(tag: String, value: String?): String? {
+        TODO("Not yet implemented")
+    }
+
+    override fun appendDocumentation(comment: String, tagSection: String?) {
+        if (comment.isBlank()) {
+            return
+        }
+
+        // Micro-optimization: we're very often going to be merging @apiSince and to a lesser
+        // extent @deprecatedSince into existing comments, since we're flagging every single
+        // public API. Normally merging into documentation has to be done carefully, since
+        // there could be existing versions of the tag we have to append to, and some parts
+        // of the comment needs to be present in certain places. For example, you can't
+        // just append to the description of a method by inserting something right before "*/"
+        // since you could be appending to a javadoc tag like @return.
+        //
+        // However, for @apiSince and @deprecatedSince specifically, in addition to being frequent,
+        // they will (a) never appear in existing docs, and (b) they're separate tags, which means
+        // it's safe to append them at the end. So we'll special case these two tags here, to
+        // help speed up the builds since these tags are inserted 30,000+ times for each framework
+        // API target (there are many), and each time would have involved constructing a full
+        // javadoc
+        // AST with lexical tokens using IntelliJ's javadoc parsing APIs. Instead, we'll just
+        // do some simple string heuristics.
+        if (
+            tagSection == "@apiSince" ||
+                tagSection == "@deprecatedSince" ||
+                tagSection == "@sdkExtSince"
+        ) {
+            text = addUniqueTag(text, tagSection, comment)
+            return
+        }
+
+        mergeDocumentation(comment.trim(), tagSection)
+    }
+
+    /**
+     * Merge the comment into the appropriate [tagSection].
+     *
+     * See [Item.appendDocumentation] for more details.
+     */
+    protected abstract fun mergeDocumentation(comment: String, tagSection: String?)
+
+    private fun addUniqueTag(text: String, tagSection: String, commentLine: String): String {
+        assert(commentLine.indexOf('\n') == -1) // Not meant for multi-line comments
+
+        if (text.isBlank()) {
+            return "/** $tagSection $commentLine */"
+        }
+
+        // Already single line?
+        if (text.indexOf('\n') == -1) {
+            val end = text.lastIndexOf("*/")
+            return "/**\n *" + text.substring(3, end) + "\n * $tagSection $commentLine\n */"
+        }
+
+        var end = text.lastIndexOf("*/")
+        while (end > 0 && text[end - 1].isWhitespace() && text[end - 1] != '\n') {
+            end--
+        }
+        // The comment ends with:
+        // * some comment here */
+        val insertNewLine: Boolean = text[end - 1] != '\n'
+
+        val indent: String
+        var linePrefix = ""
+        val secondLine = text.indexOf('\n')
+        if (secondLine == -1) {
+            // Single line comment
+            indent = "\n * "
+        } else {
+            val indentStart = secondLine + 1
+            var indentEnd = indentStart
+            while (indentEnd < text.length) {
+                if (!text[indentEnd].isWhitespace()) {
+                    break
+                }
+                indentEnd++
+            }
+            indent = text.substring(indentStart, indentEnd)
+            // TODO: If it starts with "* " follow that
+            if (text.startsWith("* ", indentEnd)) {
+                linePrefix = "* "
+            }
+        }
+        return text.substring(0, end) +
+            (if (insertNewLine) "\n" else "") +
+            indent +
+            linePrefix +
+            tagSection +
+            " " +
+            commentLine +
+            "\n" +
+            indent +
+            " */"
+    }
+
+    override fun removeDeprecatedSection() {
+        text = removeDeprecatedSection(text)
+    }
+}
+
+/** A default [ItemDocumentation] containing JavaDoc/KDoc. */
+internal class DefaultItemDocumentation(override var text: String) : AbstractItemDocumentation() {
+
+    override fun duplicate(item: Item) = DefaultItemDocumentation(text)
+
+    override fun mergeDocumentation(comment: String, tagSection: String?) {
+        TODO("Not yet implemented")
+    }
+
+    override fun findMainDocumentation(): String {
+        TODO("Not yet implemented")
+    }
+}
+
+/** Regular expression to match the start of a doc comment. */
+private const val DOC_COMMENT_START_RE = """\Q/**\E"""
+
+/**
+ * Regular expression to match the end of a block comment. If the block comment is at the start of a
+ * line, preceded by some white space then it includes all that white space.
+ */
+private const val BLOCK_COMMENT_END_RE = """(?m:^\s*)?\Q*/\E"""
+
+/**
+ * Regular expression to match the start of a line Javadoc tag, i.e. a Javadoc tag at the beginning
+ * of a line. Optionally, includes the preceding white space and a `*` forming a left hand border.
+ */
+private const val START_OF_LINE_TAG_RE = """(?m:^\s*)\Q*\E\s*@"""
+
+/**
+ * A [Pattern[] for matching an `@deprecated` tag and its associated text. If the tag is at the
+ * start of the line then it includes everything from the start of the line. It includes everything
+ * up to the end of the comment (apart from the line for the end of the comment) or the start of the
+ * next line tag.
+ */
+private val deprecatedTagPattern =
+    """((?m:^\s*\*\s*)?@deprecated\b(?m:\s*.*?))($START_OF_LINE_TAG_RE|$BLOCK_COMMENT_END_RE)"""
+        .toPattern(Pattern.DOTALL)
+
+/** A [Pattern] that matches a blank, i.e. white space only, doc comment. */
+private val blankDocCommentPattern = """$DOC_COMMENT_START_RE\s*$BLOCK_COMMENT_END_RE""".toPattern()
+
+/** Remove the `@deprecated` section, if any, from [docs]. */
+fun removeDeprecatedSection(docs: String): String {
+    // Find the `@deprecated` tag.
+    val deprecatedTagMatcher = deprecatedTagPattern.matcher(docs)
+    if (!deprecatedTagMatcher.find()) {
+        // Nothing to do as the documentation does not include @deprecated.
+        return docs
+    }
+
+    // Remove the @deprecated tag and associated text.
+    val withoutDeprecated =
+        // The part before the `@deprecated` tag.
+        docs.substring(0, deprecatedTagMatcher.start(1)) +
+            // The part after the `@deprecated` tag.
+            docs.substring(deprecatedTagMatcher.end(1))
+
+    // Check to see if the resulting document comment is empty and if it is then discard it all
+    // together.
+    val emptyDocCommentMatcher = blankDocCommentPattern.matcher(withoutDeprecated)
+    return if (emptyDocCommentMatcher.matches()) {
+        ""
+    } else {
+        withoutDeprecated
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemLanguage.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemLanguage.kt
new file mode 100644
index 000000000..65eef152c
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemLanguage.kt
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/** The language of an item. */
+enum class ItemLanguage {
+    KOTLIN,
+    JAVA,
+    UNKNOWN {
+        override fun isJava(): Boolean {
+            error("unknown language type")
+        }
+
+        override fun isKotlin(): Boolean {
+            error("unknown language type")
+        }
+    },
+    ;
+
+    open fun isJava() = this == JAVA
+
+    open fun isKotlin() = this == KOTLIN
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt
index 5049d74da..b045454a0 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemVisitor.kt
@@ -17,17 +17,19 @@
 package com.android.tools.metalava.model
 
 interface ItemVisitor {
-    fun visit(cls: ClassItem)
+    fun visit(codebase: Codebase) {}
 
-    fun visit(field: FieldItem)
+    fun visit(cls: ClassItem) {}
 
-    fun visit(method: MethodItem)
+    fun visit(field: FieldItem) {}
 
-    fun visit(pkg: PackageItem)
+    fun visit(constructor: ConstructorItem) {}
 
-    fun visit(packageList: PackageList)
+    fun visit(method: MethodItem) {}
 
-    fun visit(parameter: ParameterItem)
+    fun visit(pkg: PackageItem) {}
 
-    fun visit(property: PropertyItem)
+    fun visit(parameter: ParameterItem) {}
+
+    fun visit(property: PropertyItem) {}
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
index 243275c26..d980d3285 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
@@ -40,3 +40,5 @@ const val KT_RETENTION = "kotlin.annotation.Retention"
 /** True if the annotation name represents @Retention (either the Java or Kotlin version) */
 fun isRetention(qualifiedName: String?): Boolean =
     JAVA_RETENTION == qualifiedName || KT_RETENTION == qualifiedName
+
+const val JAVA_PACKAGE_INFO = "package-info.java"
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Language.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Language.kt
index 849b21c14..86f1748e0 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Language.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Language.kt
@@ -18,5 +18,5 @@ package com.android.tools.metalava.model
 
 enum class Language {
     KOTLIN,
-    JAVA
+    JAVA,
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MemberItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MemberItem.kt
index 1c441e39f..091ac816c 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MemberItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MemberItem.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.model
 
-interface MemberItem : Item {
+interface MemberItem : ClassContentItem, SelectableItem {
     /**
      * The name of this method/field. Constructors have the same name as their containing class'
      * simple name
@@ -53,33 +53,4 @@ interface MemberItem : Item {
     fun canBeExternallyOverridden(): Boolean {
         return !modifiers.isFinal() && containingClass().isExtensible()
     }
-
-    /** True if this member was inherited from an ancestor class or interface. */
-    val inheritedFromAncestor
-        get() = inheritedFrom != null
-
-    /**
-     * If this member is inherited from a super class (typically via [duplicate]) this field points
-     * to the original class it was inherited from
-     */
-    val inheritedFrom: ClassItem?
-
-    /**
-     * Duplicates this member item.
-     *
-     * This is only used when comparing two [Codebase]s, in which case it is called to inherit a
-     * member from a super class/interface when it exists in the other [Codebase]. The resulting
-     * [MemberItem] is expected to behave as if it was part of the [targetContainingClass] but is
-     * otherwise identical to `this`, e.g. if [targetContainingClass] is [hidden] then so should the
-     * returned [MemberItem].
-     *
-     * The [MemberItem.inheritedFrom] property in the returned [MemberItem] is set to
-     * [containingClass] of this [MemberItem].
-     *
-     * @param targetContainingClass the [ClassItem] that will be used as
-     *   [MemberItem.containingClass]. Note, this may be from a different [Codebase] implementation
-     *   than the [MemberItem] so implementations must be careful to avoid an unconditional
-     *   downcast.
-     */
-    fun duplicate(targetContainingClass: ClassItem): MemberItem
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
index eaef0b719..789a0e998 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
@@ -19,7 +19,7 @@ package com.android.tools.metalava.model
 import java.util.function.Predicate
 
 @MetalavaApi
-interface MethodItem : MemberItem, TypeParameterListOwner {
+interface MethodItem : CallableItem, InheritableItem {
     /**
      * The property this method is an accessor for; inverse of [PropertyItem.getter] and
      * [PropertyItem.setter]
@@ -27,14 +27,12 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
     val property: PropertyItem?
         get() = null
 
-    /** Whether this method is a constructor */
-    @MetalavaApi fun isConstructor(): Boolean
-
-    /** The type of this field. Returns the containing class for constructors */
-    @MetalavaApi fun returnType(): TypeItem
-
-    /** The list of parameters */
-    @MetalavaApi fun parameters(): List<ParameterItem>
+    @Deprecated(
+        message =
+            "There is no point in calling this method on MethodItem as it always returns false",
+        ReplaceWith("")
+    )
+    override fun isConstructor() = false
 
     /** Returns true if this method is a Kotlin extension method */
     fun isExtensionMethod(): Boolean
@@ -42,8 +40,6 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
     /** Returns the super methods that this method is overriding */
     fun superMethods(): List<MethodItem>
 
-    override fun type() = returnType()
-
     override fun findCorrespondingItemIn(
         codebase: Codebase,
         superMethods: Boolean,
@@ -65,9 +61,6 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
         else correspondingMethodItem
     }
 
-    /** Returns the main documentation for the method (the documentation before any tags). */
-    fun findMainDocumentation(): String
-
     fun allSuperMethods(): Sequence<MethodItem> {
         val original = superMethods().firstOrNull() ?: return emptySequence()
         return generateSequence(original) { item ->
@@ -76,52 +69,6 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
         }
     }
 
-    /** Types of exceptions that this method can throw */
-    fun throwsTypes(): List<ExceptionTypeItem>
-
-    /** Returns true if this method throws the given exception */
-    fun throws(qualifiedName: String): Boolean {
-        for (type in throwsTypes()) {
-            val throwableClass = type.erasedClass ?: continue
-            if (throwableClass.extends(qualifiedName)) {
-                return true
-            }
-        }
-
-        return false
-    }
-
-    fun filteredThrowsTypes(predicate: Predicate<Item>): Collection<ExceptionTypeItem> {
-        if (throwsTypes().isEmpty()) {
-            return emptyList()
-        }
-        return filteredThrowsTypes(predicate, LinkedHashSet())
-    }
-
-    private fun filteredThrowsTypes(
-        predicate: Predicate<Item>,
-        throwsTypes: LinkedHashSet<ExceptionTypeItem>
-    ): LinkedHashSet<ExceptionTypeItem> {
-        for (exceptionType in throwsTypes()) {
-            if (exceptionType is VariableTypeItem) {
-                throwsTypes.add(exceptionType)
-            } else {
-                val classItem = exceptionType.erasedClass ?: continue
-                if (predicate.test(classItem)) {
-                    throwsTypes.add(exceptionType)
-                } else {
-                    // Excluded, but it may have super class throwables that are included; if so,
-                    // include those.
-                    classItem
-                        .allSuperClasses()
-                        .firstOrNull { superClass -> predicate.test(superClass) }
-                        ?.let { superClass -> throwsTypes.add(superClass.type()) }
-                }
-            }
-        }
-        return throwsTypes
-    }
-
     /**
      * If this method requires override in the child class to prevent error when compiling the stubs
      */
@@ -135,10 +82,6 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
     override fun duplicate(targetContainingClass: ClassItem): MethodItem
 
     fun findPredicateSuperMethod(predicate: Predicate<Item>): MethodItem? {
-        if (isConstructor()) {
-            return null
-        }
-
         val superMethods = superMethods()
         for (method in superMethods) {
             if (predicate.test(method)) {
@@ -156,85 +99,11 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
         return null
     }
 
-    override fun baselineElementId() = buildString {
-        append(containingClass().qualifiedName())
-        append("#")
-        append(name())
-        append("(")
-        parameters().joinTo(this) { it.type().toSimpleType() }
-        append(")")
-    }
-
     override fun accept(visitor: ItemVisitor) {
         visitor.visit(this)
     }
 
-    override fun toStringForItem(): String {
-        return "${if (isConstructor()) "constructor" else "method"} ${
-            containingClass().qualifiedName()}.${name()}(${parameters().joinToString { it.type().toSimpleType() }})"
-    }
-
     companion object {
-        private fun compareMethods(
-            o1: MethodItem,
-            o2: MethodItem,
-            overloadsInSourceOrder: Boolean
-        ): Int {
-            val name1 = o1.name()
-            val name2 = o2.name()
-            if (name1 == name2) {
-                if (overloadsInSourceOrder) {
-                    val rankDelta = o1.sortingRank - o2.sortingRank
-                    if (rankDelta != 0) {
-                        return rankDelta
-                    }
-                }
-
-                // Compare by the rest of the signature to ensure stable output (we don't need to
-                // sort
-                // by return value or modifiers or modifiers or throws-lists since methods can't be
-                // overloaded
-                // by just those attributes
-                val p1 = o1.parameters()
-                val p2 = o2.parameters()
-                val p1n = p1.size
-                val p2n = p2.size
-                for (i in 0 until minOf(p1n, p2n)) {
-                    val compareTypes =
-                        p1[i]
-                            .type()
-                            .toTypeString()
-                            .compareTo(p2[i].type().toTypeString(), ignoreCase = true)
-                    if (compareTypes != 0) {
-                        return compareTypes
-                    }
-                    // (Don't compare names; they're not part of the signatures)
-                }
-                return p1n.compareTo(p2n)
-            }
-
-            return name1.compareTo(name2)
-        }
-
-        val comparator: Comparator<MethodItem> = Comparator { o1, o2 ->
-            compareMethods(o1, o2, false)
-        }
-        val sourceOrderComparator: Comparator<MethodItem> = Comparator { o1, o2 ->
-            val delta = o1.sortingRank - o2.sortingRank
-            if (delta == 0) {
-                // Within a source file all the items will have unique sorting ranks, but since
-                // we copy methods in from hidden super classes it's possible for ranks to clash,
-                // and in that case we'll revert to a signature based comparison
-                comparator.compare(o1, o2)
-            } else {
-                delta
-            }
-        }
-        val sourceOrderForOverloadedMethodsComparator: Comparator<MethodItem> =
-            Comparator { o1, o2 ->
-                compareMethods(o1, o2, true)
-            }
-
         /**
          * Compare two types to see if they are considered the same.
          *
@@ -289,7 +158,7 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
 
             // Compare modifier lists; note that here we need to
             // skip modifiers that don't apply in compat mode if set
-            if (!method.modifiers.equivalentTo(superMethod.modifiers)) {
+            if (!method.modifiers.equivalentTo(method, superMethod.modifiers)) {
                 return false
             }
 
@@ -335,116 +204,27 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
         }
     }
 
-    fun formatParameters(): String? {
-        // TODO: Generalize, allow callers to control whether to include annotations, whether to
-        // erase types,
-        // whether to include names, etc
-        if (parameters().isEmpty()) {
-            return ""
-        }
-        val sb = StringBuilder()
-        for (parameter in parameters()) {
-            if (sb.isNotEmpty()) {
-                sb.append(", ")
-            }
-            sb.append(parameter.type().toTypeString())
-        }
-
-        return sb.toString()
-    }
-
-    fun isImplicitConstructor(): Boolean {
-        return isConstructor() && modifiers.isPublic() && parameters().isEmpty()
-    }
-
-    /**
-     * Finds uncaught exceptions actually thrown inside this method (as opposed to ones declared in
-     * the signature)
-     */
-    fun findThrownExceptions(): Set<ClassItem> = codebase.unsupported()
-
-    /** If annotation method, returns the default value as a source expression */
-    fun defaultValue(): String = ""
-
-    fun hasDefaultValue(): Boolean {
-        return defaultValue() != ""
-    }
-
     /**
-     * Returns true if overloads of the method should be checked separately when checking signature
-     * of the method.
+     * Check whether this method is a synthetic enum method.
      *
-     * This works around the issue of actual method not generating overloads for @JvmOverloads
-     * annotation when the default is specified on expect side
-     * (https://youtrack.jetbrains.com/issue/KT-57537).
+     * i.e. `getEntries()` from Kotlin and `values()` and `valueOf(String)` from both Java and
+     * Kotlin.
      */
-    fun shouldExpandOverloads(): Boolean = false
-
-    /**
-     * Returns true if this method is a signature match for the given method (e.g. can be
-     * overriding). This checks that the name and parameter lists match, but ignores differences in
-     * parameter names, return value types and throws list types.
-     */
-    fun matches(other: MethodItem): Boolean {
-        if (this === other) return true
-
-        if (name() != other.name()) {
-            return false
-        }
-
-        val parameters1 = parameters()
-        val parameters2 = other.parameters()
-
-        if (parameters1.size != parameters2.size) {
-            return false
+    fun isEnumSyntheticMethod(): Boolean {
+        if (!containingClass().isEnum()) return false
+        val parameters = parameters()
+        return when (parameters.size) {
+            0 -> name().let { name -> name == JAVA_ENUM_VALUES || name == "getEntries" }
+            1 -> name() == JAVA_ENUM_VALUE_OF && parameters[0].type().isString()
+            else -> false
         }
-
-        for (i in parameters1.indices) {
-            val parameter1Type = parameters1[i].type()
-            val parameter2Type = parameters2[i].type()
-            if (parameter1Type == parameter2Type) continue
-            if (parameter1Type.toErasedTypeString() == parameter2Type.toErasedTypeString()) continue
-
-            val convertedType =
-                parameter1Type.convertType(other.containingClass(), containingClass())
-            if (convertedType != parameter2Type) return false
-        }
-        return true
     }
 
-    /**
-     * Returns whether this method has any types in its signature that does not match the given
-     * filter
-     */
-    fun hasHiddenType(filterReference: Predicate<Item>): Boolean {
-        for (parameter in parameters()) {
-            if (parameter.type().hasHiddenType(filterReference)) return true
-        }
-
-        if (returnType().hasHiddenType(filterReference)) return true
-
-        for (typeParameter in typeParameterList) {
-            if (typeParameter.typeBounds().any { it.hasHiddenType(filterReference) }) return true
-        }
-
-        return false
-    }
+    /** If annotation method, returns the default value as a source expression */
+    fun defaultValue(): String
 
-    /** Checks if there is a reference to a hidden class anywhere in the type. */
-    private fun TypeItem.hasHiddenType(filterReference: Predicate<Item>): Boolean {
-        return when (this) {
-            is PrimitiveTypeItem -> false
-            is ArrayTypeItem -> componentType.hasHiddenType(filterReference)
-            is ClassTypeItem ->
-                asClass()?.let { !filterReference.test(it) } == true ||
-                    outerClassType?.hasHiddenType(filterReference) == true ||
-                    arguments.any { it.hasHiddenType(filterReference) }
-            is VariableTypeItem -> !filterReference.test(asTypeParameter)
-            is WildcardTypeItem ->
-                extendsBound?.hasHiddenType(filterReference) == true ||
-                    superBound?.hasHiddenType(filterReference) == true
-            else -> throw IllegalStateException("Unrecognized type: $this")
-        }
+    fun hasDefaultValue(): Boolean {
+        return defaultValue() != ""
     }
 
     /** Whether this method is a getter/setter for an underlying Kotlin property (val/var) */
@@ -575,119 +355,3 @@ interface MethodItem : MemberItem, TypeParameterListOwner {
                 superMethods().count { it.modifiers.isAbstract() || it.modifiers.isDefault() } > 1)
     }
 }
-
-/**
- * Check to see if the method is overrideable.
- *
- * Private and static methods cannot be overridden.
- */
-private fun MethodItem.isOverrideable(): Boolean = !modifiers.isPrivate() && !modifiers.isStatic()
-
-/**
- * Compute the super methods of this method.
- *
- * A super method is a method from a super class or super interface that is directly overridden by
- * this method.
- */
-fun MethodItem.computeSuperMethods(): List<MethodItem> {
-    // Constructors and methods that are not overrideable will have no super methods.
-    if (isConstructor() || !isOverrideable()) {
-        return emptyList()
-    }
-
-    // TODO(b/321216636): Remove this awful hack.
-    // For some reason `psiMethod.findSuperMethods()` would return an empty list for this
-    // specific method. That is incorrect as it clearly overrides a method in `DrawScope` in
-    // the same package. However, it is unclear what makes this method distinct from any
-    // other method including overloaded methods in the same class that also override
-    // methods in`DrawScope`. Returning a correct non-empty list for that method results in
-    // the method being removed from an API signature file even though the super method is
-    // abstract and this is concrete. That is because AndroidX does not yet set
-    // `add-additional-overrides=yes`. When it does then this hack can be removed.
-    if (
-        containingClass().qualifiedName() ==
-            "androidx.compose.ui.graphics.drawscope.CanvasDrawScope" &&
-            name() == "drawImage" &&
-            toString() ==
-                "method androidx.compose.ui.graphics.drawscope.CanvasDrawScope.drawImage(androidx.compose.ui.graphics.ImageBitmap, long, long, long, long, float, androidx.compose.ui.graphics.drawscope.DrawStyle, androidx.compose.ui.graphics.ColorFilter, int)"
-    ) {
-        return emptyList()
-    }
-
-    // Ideally, the search for super methods would start from this method's ClassItem.
-    // Unfortunately, due to legacy reasons for methods that were inherited from another ClassItem
-    // it is necessary to start the search from the original ClassItem. That is because the psi
-    // model's implementation behaved this way and the code that is built of top of superMethods,
-    // like the code to determine if overriding methods should be elided from the API signature file
-    // relied on that behavior.
-    val startingClass = inheritedFrom ?: containingClass()
-    return buildSet { appendSuperMethods(this, startingClass) }.toList()
-}
-
-/**
- * Append the super methods of this method from the [cls] hierarchy to the [methods] set.
- *
- * @param methods the mutable, order preserving set of super [MethodItem].
- * @param cls the [ClassItem] whose super class and implemented interfaces will be searched for
- *   matching methods.
- */
-private fun MethodItem.appendSuperMethods(methods: MutableSet<MethodItem>, cls: ClassItem) {
-    // Method from SuperClass or its ancestors
-    cls.superClass()?.let { superClass ->
-        // Search for a matching method in the super class.
-        val superMethod = superClass.findMethod(this)
-        if (superMethod == null) {
-            // No matching method was found so continue searching in the super class.
-            appendSuperMethods(methods, superClass)
-        } else {
-            // Matching does not check modifiers match so make sure that the matched method is
-            // overrideable.
-            if (superMethod.isOverrideable()) {
-                methods.add(superMethod)
-            }
-        }
-    }
-
-    // Methods implemented from direct interfaces or its ancestors
-    appendSuperMethodsFromInterfaces(methods, cls)
-}
-
-/**
- * Append the super methods of this method from the interface hierarchy of [cls] to the [methods]
- * set.
- *
- * @param methods the mutable, order preserving set of super [MethodItem].
- * @param cls the [ClassItem] whose implemented interfaces will be searched for matching methods.
- */
-private fun MethodItem.appendSuperMethodsFromInterfaces(
-    methods: MutableSet<MethodItem>,
-    cls: ClassItem
-) {
-    for (itf in cls.interfaceTypes()) {
-        val itfClass = itf.asClass() ?: continue
-
-        // Find the method in the interface.
-        itfClass.findMethod(this)?.let { superMethod ->
-            // A matching method was found so add it to the super methods if it is overrideable.
-            if (superMethod.isOverrideable()) {
-                methods.add(superMethod)
-            }
-        }
-        // A method could not be found in this interface so search its interfaces.
-        ?: appendSuperMethodsFromInterfaces(methods, itfClass)
-    }
-}
-
-/**
- * Update the state of a [MethodItem] that has been copied from one [ClassItem] to another.
- *
- * This will update the [MethodItem] on which it is called to ensure that it is consistent with the
- * [ClassItem] to which it now belongs. Called from the implementations of [MethodItem.duplicate]
- * and [ClassItem.inheritMethodFromNonApiAncestor].
- */
-fun MethodItem.updateCopiedMethodState() {
-    val mutableModifiers = mutableModifiers()
-    if (mutableModifiers.isDefault() && !containingClass().isInterface()) {
-        mutableModifiers.setDefault(false)
-    }
-}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierList.kt
index 36313a054..4a5d819a0 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierList.kt
@@ -16,13 +16,9 @@
 
 package com.android.tools.metalava.model
 
-interface ModifierList {
-    val codebase: Codebase
-
+interface BaseModifierList {
     fun annotations(): List<AnnotationItem>
 
-    fun owner(): Item
-
     fun getVisibilityLevel(): VisibilityLevel
 
     fun isPublic(): Boolean
@@ -79,49 +75,36 @@ interface ModifierList {
 
     fun isActual(): Boolean = false
 
-    fun isEmpty(): Boolean
-
     fun isPackagePrivate() = !(isPublic() || isProtected() || isPrivate())
 
     fun isPublicOrProtected() = isPublic() || isProtected()
 
-    // Rename? It's not a full equality, it's whether an override's modifier set is significant
-    fun equivalentTo(other: ModifierList): Boolean {
-        if (isPublic() != other.isPublic()) return false
-        if (isProtected() != other.isProtected()) return false
-        if (isPrivate() != other.isPrivate()) return false
-
-        if (isStatic() != other.isStatic()) return false
-        if (isAbstract() != other.isAbstract()) return false
-        if (isFinal() != other.isFinal()) {
-            return false
-        }
-        if (isTransient() != other.isTransient()) return false
-        if (isVolatile() != other.isVolatile()) return false
-
-        // Default does not require an override to "remove" it
-        // if (isDefault() != other.isDefault()) return false
-
-        return true
-    }
-
-    /** Returns true if this modifier list contains the `@JvmSynthetic` annotation */
-    fun hasJvmSyntheticAnnotation(): Boolean = hasAnnotation(AnnotationItem::isJvmSynthetic)
-
     /**
-     * Returns true if this modifier list contains any suppress compatibility meta-annotations.
+     * Check whether this [ModifierList]'s modifiers are equivalent to the [other] [ModifierList]'s
+     * modifiers.
      *
-     * Metalava will suppress compatibility checks for APIs which are within the scope of a
-     * "suppress compatibility" meta-annotation, but they may still be written to API files or stub
-     * JARs.
+     * Modifier meaning does depend on the [Item] to which they belong, e.g. just because `final`
+     * and `deprecated` are `false` does not mean that the [Item] is not final or deprecated as the
+     * containing class may be final or deprecated.
      *
-     * "Suppress compatibility" meta-annotations allow Metalava to handle concepts like Jetpack
-     * experimental APIs, where developers can use the [RequiresOptIn] meta-annotation to mark
-     * feature sets with unstable APIs.
+     * It is used for:
+     * * Checking method overrides.
+     * * Checking consistent of classes whose definition is split across multiple signature files.
+     * * Testing the [InheritableItem.duplicate] works correctly.
+     *
+     * @param owner the optional [Item] that owns this [ModifierList] and which is used to tweak the
+     *   check to make it take into account the content within which they are being used. If it is
+     *   not provided then this will just compare modifiers like for like.
+     *
+     * TODO(b/356548977): Currently, [owner] only has an effect if it is a [MethodItem]. That is due
+     *   to it historically only being used for method overrides. However, as the previous list
+     *   shows that is no longer true so it will need to be updated to correctly handle the other
+     *   cases.
      */
-    fun hasSuppressCompatibilityMetaAnnotations(): Boolean {
-        return codebase.annotationManager.hasSuppressCompatibilityMetaAnnotations(this)
-    }
+    fun equivalentTo(owner: Item?, other: BaseModifierList): Boolean
+
+    /** Returns true if this modifier list contains the `@JvmSynthetic` annotation */
+    fun hasJvmSyntheticAnnotation(): Boolean = hasAnnotation(AnnotationItem::isJvmSynthetic)
 
     /** Returns true if this modifier list contains the given annotation */
     fun isAnnotatedWith(qualifiedName: String): Boolean {
@@ -133,15 +116,14 @@ interface ModifierList {
      * list
      */
     fun findAnnotation(qualifiedName: String): AnnotationItem? {
-        val mappedName = codebase.annotationManager.normalizeInputName(qualifiedName)
-        return findAnnotation { mappedName == it.qualifiedName }
+        return findAnnotation { qualifiedName == it.qualifiedName }
     }
 
     /**
      * Returns true if the visibility modifiers in this modifier list is as least as visible as the
      * ones in the given [other] modifier list
      */
-    fun asAccessibleAs(other: ModifierList): Boolean {
+    fun asAccessibleAs(other: BaseModifierList): Boolean {
         val otherLevel = other.getVisibilityLevel()
         val thisLevel = getVisibilityLevel()
         // Generally the access level enum order determines relative visibility. However, there is
@@ -167,19 +149,48 @@ interface ModifierList {
     fun getVisibilityModifiers(): String {
         return getVisibilityLevel().javaSourceCodeModifier
     }
+
+    /**
+     * Get a [MutableModifierList] from this.
+     *
+     * This will return the object on which it is called if that is already mutable, otherwise it
+     * will create a separate mutable copy of this.
+     */
+    fun toMutable(): MutableModifierList
+
+    /**
+     * Get an immutable [ModifierList] from this.
+     *
+     * This will return the object on which it is called if that is already immutable, otherwise it
+     * will create a separate immutable copy of this.
+     */
+    fun toImmutable(): ModifierList
 }
 
 /**
  * Returns the first annotation in the modifier list that matches the supplied predicate, or null
  * otherwise.
  */
-inline fun ModifierList.findAnnotation(predicate: (AnnotationItem) -> Boolean): AnnotationItem? {
+inline fun BaseModifierList.findAnnotation(
+    predicate: (AnnotationItem) -> Boolean
+): AnnotationItem? {
     return annotations().firstOrNull(predicate)
 }
 
 /**
  * Returns true iff the modifier list contains any annotation that matches the supplied predicate.
  */
-inline fun ModifierList.hasAnnotation(predicate: (AnnotationItem) -> Boolean): Boolean {
+inline fun BaseModifierList.hasAnnotation(predicate: (AnnotationItem) -> Boolean): Boolean {
     return annotations().any(predicate)
 }
+
+interface ModifierList : BaseModifierList {
+    /**
+     * Take a snapshot of this for use in [targetCodebase].
+     *
+     * Creates a deep snapshot, including snapshots of each annotation for use in [targetCodebase].
+     *
+     * @param targetCodebase The [Codebase] of which the snapshot will be part.
+     */
+    fun snapshot(targetCodebase: Codebase): ModifierList
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
index 1113bcf61..97b9f09df 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
@@ -237,7 +237,7 @@ private constructor(
         val separateLines =
             target != AnnotationTarget.SIGNATURE_FILE &&
                 when (item) {
-                    is MethodItem,
+                    is CallableItem,
                     is ClassItem,
                     is PackageItem -> true
                     is FieldItem -> item.isEnumConstant()
@@ -254,11 +254,6 @@ private constructor(
                     // Do not write @Deprecated for a parameter unless it was explicitly marked
                     // as deprecated.
                     item is ParameterItem -> item.originallyDeprecated
-                    // Do not write @Deprecated for a field if it was inherited from another class
-                    // and was not explicitly qualified.
-                    item is FieldItem ->
-                        if (item.inheritedFromAncestor) item.originallyDeprecated
-                        else item.effectivelyDeprecated
                     else -> item.effectivelyDeprecated
                 }
             if (writeDeprecated) {
@@ -302,7 +297,7 @@ private constructor(
                     // Special cased in stubs and signature files: emitted first
                     continue
                 } else {
-                    val typedefMode = list.codebase.annotationManager.typedefMode
+                    val typedefMode = item.codebase.annotationManager.typedefMode
                     if (typedefMode == TypedefMode.INLINE) {
                         val typedef = annotation.findTypedefAnnotation()
                         if (typedef != null) {
@@ -315,9 +310,7 @@ private constructor(
                     ) {
                         // For annotation references, only include the simple name
                         writer.write("@")
-                        writer.write(
-                            annotation.resolve()?.simpleName() ?: annotation.qualifiedName!!
-                        )
+                        writer.write(annotation.resolve()?.simpleName() ?: annotation.qualifiedName)
                         if (separateLines) {
                             writer.write("\n")
                         } else {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt
index e522c6a83..82035ce60 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.model
 
-interface MutableModifierList : ModifierList {
+interface MutableModifierList : BaseModifierList {
     fun setVisibilityLevel(level: VisibilityLevel)
 
     fun setStatic(static: Boolean)
@@ -63,11 +63,16 @@ interface MutableModifierList : ModifierList {
 
     fun setActual(actual: Boolean)
 
-    fun addAnnotation(annotation: AnnotationItem)
-
-    fun removeAnnotation(annotation: AnnotationItem)
-
-    fun removeAnnotations(predicate: (AnnotationItem) -> Boolean)
-
-    fun clearAnnotations(annotation: AnnotationItem)
+    fun addAnnotation(annotation: AnnotationItem?) {
+        if (annotation != null) mutateAnnotations { add(annotation) }
+    }
+
+    /**
+     * Mutate the [annotations] list.
+     *
+     * Provides a [MutableList] of the [annotations] that can be modified by [mutator]. Once the
+     * mutator exits the [annotations] list will be updated. The [MutableList] must not be accessed
+     * from outside [mutator].
+     */
+    fun mutateAnnotations(mutator: MutableList<AnnotationItem>.() -> Unit)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt
index 60cb576c2..f897d3867 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageItem.kt
@@ -16,62 +16,74 @@
 
 package com.android.tools.metalava.model
 
-interface PackageItem : Item {
+import com.android.tools.metalava.model.item.ResourceFile
+
+interface PackageItem : SelectableItem {
     /**
      * The overview documentation associated with the package; retrieved from an `overview.html`
-     * file.
+     * file listed in the source files.
+     *
+     * If present this is copied to an `overview.html` in the stubs package directory when
+     * generating documentation stubs.
      */
-    val overviewDocumentation: String?
+    val overviewDocumentation: ResourceFile?
         get() = null
 
     /** The qualified name of this package */
     fun qualifiedName(): String
 
-    /** All top level classes in this package */
-    fun topLevelClasses(): Sequence<ClassItem>
+    /**
+     * All top level classes in this package.
+     *
+     * This is a snapshot of the classes in this package and will not be affected by any additional
+     * classes added to the package after the list is returned.
+     */
+    fun topLevelClasses(): List<ClassItem>
 
-    /** All top level classes **and inner classes** in this package */
+    /**
+     * All top level classes **and nested classes** in this package flattened into a single
+     * [Sequence].
+     */
     fun allClasses(): Sequence<ClassItem> {
         return topLevelClasses().asSequence().flatMap { it.allClasses() }
     }
 
     override fun type(): TypeItem? = null
 
+    override fun setType(type: TypeItem) =
+        error("Cannot call setType(TypeItem) on PackageItem: $this")
+
     override fun findCorrespondingItemIn(
         codebase: Codebase,
         superMethods: Boolean,
         duplicate: Boolean,
     ) = codebase.findPackage(qualifiedName())
 
-    val isDefault
-        get() = qualifiedName().isEmpty()
-
     override fun parent(): PackageItem? =
         if (qualifiedName().isEmpty()) null else containingPackage()
 
-    override fun containingPackage(): PackageItem? {
-        val name = qualifiedName()
-        val lastDot = name.lastIndexOf('.')
-        return if (lastDot != -1) {
-            codebase.findPackage(name.substring(0, lastDot))
-        } else {
-            null
-        }
-    }
-
     override val effectivelyDeprecated: Boolean
         get() = originallyDeprecated
 
-    /** Whether this package is empty */
-    fun empty() = topLevelClasses().none()
-
     override fun baselineElementId() = qualifiedName()
 
     override fun accept(visitor: ItemVisitor) {
         visitor.visit(this)
     }
 
-    override fun toStringForItem() = "package ${qualifiedName()}"
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is PackageItem) return false
+
+        return qualifiedName() == other.qualifiedName()
+    }
+
+    override fun hashCodeForItem(): Int {
+        return qualifiedName().hashCode()
+    }
+
+    override fun toStringForItem() =
+        "package ${qualifiedName().let { if (it == "") "<root>" else it}}"
 
     companion object {
         val comparator: Comparator<PackageItem> = Comparator { a, b ->
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/PackageList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageList.kt
index 018134660..05e0260ee 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/PackageList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageList.kt
@@ -16,17 +16,14 @@
 
 package com.android.tools.metalava.model
 
-class PackageList(val codebase: Codebase, val packages: List<PackageItem>) {
-    fun accept(visitor: ItemVisitor) {
-        visitor.visit(this)
-    }
+class PackageList(val packages: List<PackageItem>) {
 
     /** All top level classes in all packages */
     fun allTopLevelClasses(): Sequence<ClassItem> {
         return packages.asSequence().flatMap { it.topLevelClasses() }
     }
 
-    /** All top level classes **and inner classes** in all packages */
+    /** All top level classes **and nested classes** in all packages */
     fun allClasses(): Sequence<ClassItem> {
         return packages.asSequence().flatMap { it.allClasses() }
     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt
index 95c7ff0cf..e0fdd2d91 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ParameterItem.kt
@@ -16,8 +16,10 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.item.DefaultValue
+
 @MetalavaApi
-interface ParameterItem : Item {
+interface ParameterItem : ClassContentItem, Item {
     /** The name of this field */
     fun name(): String
 
@@ -29,13 +31,16 @@ interface ParameterItem : Item {
         superMethods: Boolean,
         duplicate: Boolean,
     ) =
-        containingMethod()
+        containingCallable()
             .findCorrespondingItemIn(codebase, superMethods = superMethods, duplicate = duplicate)
             ?.parameters()
             ?.getOrNull(parameterIndex)
 
-    /** The containing method */
-    fun containingMethod(): MethodItem
+    /** The containing callable. */
+    fun containingCallable(): CallableItem
+
+    /** The possible containing method, returns null if this is a constructor parameter. */
+    fun possibleContainingMethod(): MethodItem? = containingCallable().let { it as? MethodItem }
 
     /** Index of this parameter in the parameter list (0-based) */
     val parameterIndex: Int
@@ -77,32 +82,78 @@ interface ParameterItem : Item {
      * The default value is the source string literal representation of the value, e.g. strings
      * would be surrounded by quotes, Booleans are the strings "true" or "false", and so on.
      */
-    fun defaultValue(): String?
+    fun defaultValueAsString(): String?
+
+    /** The default value of this [ParameterItem]. */
+    val defaultValue: DefaultValue
 
     /** Whether this is a varargs parameter */
-    fun isVarArgs(): Boolean
+    fun isVarArgs(): Boolean = modifiers.isVarArg()
 
     /** The property declared by this parameter; inverse of [PropertyItem.constructorParameter] */
     val property: PropertyItem?
         get() = null
 
-    override fun parent(): MethodItem? = containingMethod()
+    override fun parent(): CallableItem? = containingCallable()
 
     override val effectivelyDeprecated: Boolean
-        get() = originallyDeprecated || containingMethod().effectivelyDeprecated
+        get() = originallyDeprecated || containingCallable().effectivelyDeprecated
 
     override fun baselineElementId() =
-        containingMethod().baselineElementId() + " parameter #" + parameterIndex
+        containingCallable().baselineElementId() + " parameter #" + parameterIndex
 
     override fun accept(visitor: ItemVisitor) {
         visitor.visit(this)
     }
 
+    /**
+     * Returns whether this parameter is SAM convertible or a Kotlin lambda. If this parameter is
+     * the last parameter, it also means that it could be called in Kotlin using the trailing lambda
+     * syntax.
+     *
+     * Specifically this will attempt to handle the follow cases:
+     * - Java SAM interface = true
+     * - Kotlin SAM interface = false // Kotlin (non-fun) interfaces are not SAM convertible
+     * - Kotlin fun interface = true
+     * - Kotlin lambda = true
+     * - Any other type = false
+     */
+    fun isSamCompatibleOrKotlinLambda(): Boolean =
+        // TODO(b/354889186): Implement correctly
+        false
+
+    /**
+     * Create a duplicate of this for [containingCallable].
+     *
+     * The duplicate's [type] must have applied the [typeVariableMap] substitutions by using
+     * [TypeItem.convertType].
+     *
+     * This is called from within the constructor of the [containingCallable] so must only access
+     * its `name` and its reference. In particularly it must not access its
+     * [CallableItem.parameters] property as this is called during its initialization.
+     */
+    fun duplicate(
+        containingCallable: CallableItem,
+        typeVariableMap: TypeParameterBindings,
+    ): ParameterItem
+
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is ParameterItem) return false
+
+        return parameterIndex == other.parameterIndex &&
+            containingCallable() == other.containingCallable()
+    }
+
+    override fun hashCodeForItem(): Int {
+        return name().hashCode()
+    }
+
     override fun toStringForItem() = "parameter ${name()}"
 
-    override fun containingClass(): ClassItem = containingMethod().containingClass()
+    override fun containingClass(): ClassItem = containingCallable().containingClass()
 
-    override fun containingPackage(): PackageItem? = containingMethod().containingPackage()
+    override fun containingPackage(): PackageItem? = containingCallable().containingPackage()
 
     // TODO: modifier list
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt
index 739a016f5..9c0dcbedf 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/PropertyItem.kt
@@ -48,24 +48,23 @@ interface PropertyItem : MemberItem {
             it.name() == name()
         }
 
-    /** [PropertyItem]s are never inherited. */
-    override val inheritedFrom: ClassItem?
-        get() = null
-
-    /**
-     * Duplicates this property item.
-     *
-     * Override to specialize the return type.
-     */
-    override fun duplicate(targetContainingClass: ClassItem): PropertyItem =
-        codebase.unsupported("Not needed yet")
-
     override fun baselineElementId() = containingClass().qualifiedName() + "#" + name()
 
     override fun accept(visitor: ItemVisitor) {
         visitor.visit(this)
     }
 
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is PropertyItem) return false
+
+        return name() == other.name() && containingClass() == other.containingClass()
+    }
+
+    override fun hashCodeForItem(): Int {
+        return name().hashCode()
+    }
+
     override fun toStringForItem(): String = "property ${containingClass().fullName()}.${name()}"
 
     companion object {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
new file mode 100644
index 000000000..62d75f9c1
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/**
+ * An [Item] that can be selected to be a part of an API in its own right.
+ *
+ * e.g. a [MethodItem] is selectable because while a method's [MethodItem.containingClass] has to be
+ * part of the same API just because the [ClassItem] is selected does not mean that a [MethodItem]
+ * has to be.
+ *
+ * Conversely, a [ParameterItem] is not selectable because it cannot be selected on its own, it is
+ * an indivisible part of the [ParameterItem.containingCallable].
+ */
+interface SelectableItem : Item {
+    // At the moment this is a marker interface but over time more functionality related to
+    // selection will be migrated here, e.g. [Item.hidden] and related members.
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
index b508176ae..cc22ee0e7 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
@@ -26,6 +26,10 @@ interface SourceFile {
 
     fun getHeaderComments(): String? = null
 
+    /** Get all the imports. */
+    fun getImports() = getImports { true }
+
+    /** Get only those imports that reference [Item]s for which [predicate] returns `true`. */
     fun getImports(predicate: Predicate<Item>): Collection<Import> = emptyList()
 
     /**
@@ -56,7 +60,7 @@ interface SourceFile {
                             // that its child items are so make sure to visit them.
                             return TraversalAction.CONTINUE
                         }
-                        val doc = item.documentation
+                        val doc = item.documentation.text
                         if (doc.isNotBlank()) {
                             // Scan the documentation text to see if it contains any of the
                             // short names imported. It does not check whether the names
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt
index ae287896d..ee1c515a6 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TraversingVisitor.kt
@@ -41,6 +41,14 @@ abstract class TraversingVisitor : ItemVisitor {
     /** Visit the item returning an action for the [TraversingVisitor] to take. */
     abstract fun visitItem(item: Item): TraversalAction
 
+    override fun visit(codebase: Codebase) {
+        val packageList = codebase.getPackages()
+        for (it in packageList.packages) {
+            it.accept(this)
+            if (traversalFinished) return
+        }
+    }
+
     final override fun visit(cls: ClassItem) {
         when (visitItem(cls)) {
             TraversalAction.SKIP_TRAVERSAL -> {
@@ -70,8 +78,8 @@ abstract class TraversingVisitor : ItemVisitor {
                     if (traversalFinished) return
                 }
 
-                for (innerCls in cls.innerClasses()) {
-                    innerCls.accept(this)
+                for (nestedCls in cls.nestedClasses()) {
+                    nestedCls.accept(this)
                     if (traversalFinished) return
                 }
             }
@@ -83,6 +91,11 @@ abstract class TraversingVisitor : ItemVisitor {
         traversalFinished = action == TraversalAction.SKIP_TRAVERSAL
     }
 
+    final override fun visit(constructor: ConstructorItem) {
+        val action = visitItem(constructor)
+        traversalFinished = action == TraversalAction.SKIP_TRAVERSAL
+    }
+
     final override fun visit(method: MethodItem) {
         val action = visitItem(method)
         traversalFinished = action == TraversalAction.SKIP_TRAVERSAL
@@ -105,13 +118,6 @@ abstract class TraversingVisitor : ItemVisitor {
         }
     }
 
-    final override fun visit(packageList: PackageList) {
-        for (it in packageList.packages) {
-            it.accept(this)
-            if (traversalFinished) return
-        }
-    }
-
     final override fun visit(parameter: ParameterItem) {
         error("parameters should not be visited")
     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
index 109124b0c..b4df2b079 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.model
 
-import com.android.tools.metalava.model.TypeItem.Companion.equals
 import java.util.Objects
 import java.util.function.Predicate
 
@@ -72,7 +71,6 @@ interface TypeItem {
      *   [annotations] controls whether the annotations like @Nullable and @NonNull are included.
      * @param kotlinStyleNulls Controls whether it should return "@Nullable List<String>" as
      *   "List<String!>?".
-     * @param filter Specifies a filter to apply to the type annotations, if any.
      * @param spaceBetweenParameters Controls whether there should be a space between class type
      *   parameters, e.g. "java.util.Map<java.lang.Integer, java.lang.Number>" or
      *   "java.util.Map<java.lang.Integer,java.lang.Number>".
@@ -80,7 +78,6 @@ interface TypeItem {
     fun toTypeString(
         annotations: Boolean = false,
         kotlinStyleNulls: Boolean = false,
-        filter: Predicate<Item>? = null,
         spaceBetweenParameters: Boolean = false
     ): String
 
@@ -161,15 +158,28 @@ interface TypeItem {
 
     fun defaultValueString(): String = "null"
 
-    /** Creates an identical type, with a copy of this type's modifiers, so they can be mutated. */
-    fun duplicate(): TypeItem
+    /**
+     * Duplicates this type substituting in the provided [modifiers] in place of this instance's
+     * [modifiers].
+     */
+    fun substitute(modifiers: TypeModifiers): TypeItem
+
+    /**
+     * Return a [TypeItem] instance identical to this on except its [modifiers]'s
+     * [TypeModifiers.nullability] property is the same as the [nullability] parameter.
+     *
+     * If the parameter is the same as this instance's [modifiers]'s property then it will just
+     * return this instance, otherwise it will return a new instance with a new [TypeModifiers].
+     */
+    fun substitute(nullability: TypeNullability) =
+        if (modifiers.nullability == nullability) this
+        else substitute(modifiers.substitute(nullability))
 
     /**
-     * Creates an identical type, with a copy of this type's modifiers with the specified
-     * [withNullability] that can be modified further if needed.
+     * Return a [TypeItem] instance of the same type as this one that was produced by the [TypeItem]
+     * appropriate [TypeTransformer.transform] method.
      */
-    fun duplicate(withNullability: TypeNullability) =
-        duplicate().apply { modifiers.setNullability(withNullability) }
+    fun transform(transformer: TypeTransformer): TypeItem
 
     companion object {
         /** Shortens types, if configured */
@@ -183,7 +193,7 @@ interface TypeItem {
 
         /**
          * Removes java.lang. prefixes from types, unless it's in a subpackage such as
-         * java.lang.reflect. For simplicity we may also leave inner classes in the java.lang
+         * java.lang.reflect. For simplicity we may also leave nested classes in the java.lang
          * package untouched.
          *
          * NOTE: We only remove this from the front of the type; e.g. we'll replace
@@ -376,11 +386,10 @@ abstract class DefaultTypeItem(
     override fun toTypeString(
         annotations: Boolean,
         kotlinStyleNulls: Boolean,
-        filter: Predicate<Item>?,
         spaceBetweenParameters: Boolean
     ): String {
         return toTypeString(
-            TypeStringConfiguration(annotations, kotlinStyleNulls, filter, spaceBetweenParameters)
+            TypeStringConfiguration(annotations, kotlinStyleNulls, spaceBetweenParameters)
         )
     }
 
@@ -425,17 +434,14 @@ abstract class DefaultTypeItem(
          * @param kotlinStyleNulls Whether to represent nullability with Kotlin-style suffixes: `?`
          *   for nullable, no suffix for non-null, and `!` for platform nullability. For example,
          *   the Java type `@Nullable List<String>` would be represented as `List<String!>?`.
-         * @param filter A filter to apply to the type annotations, if any.
          * @param spaceBetweenParameters Whether to include a space between class type params.
          */
         private data class TypeStringConfiguration(
             val annotations: Boolean = false,
             val kotlinStyleNulls: Boolean = false,
-            val filter: Predicate<Item>? = null,
             val spaceBetweenParameters: Boolean = false,
         ) {
-            val isDefault =
-                !annotations && !kotlinStyleNulls && filter == null && !spaceBetweenParameters
+            val isDefault = !annotations && !kotlinStyleNulls && !spaceBetweenParameters
         }
 
         private fun StringBuilder.appendTypeString(
@@ -461,7 +467,7 @@ abstract class DefaultTypeItem(
                             arrayModifiers.add(deepComponentType.modifiers)
                             deepComponentType = deepComponentType.componentType
                         }
-                        val suffixes = arrayModifiers.map { it.nullability().suffix }.reversed()
+                        val suffixes = arrayModifiers.map { it.nullability.suffix }.reversed()
 
                         // Print the innermost component type.
                         appendTypeString(deepComponentType, configuration)
@@ -488,7 +494,7 @@ abstract class DefaultTypeItem(
                             append("[]")
                         }
                         if (configuration.kotlinStyleNulls) {
-                            append(type.modifiers.nullability().suffix)
+                            append(type.modifiers.nullability.suffix)
                         }
                     }
                 }
@@ -524,7 +530,7 @@ abstract class DefaultTypeItem(
                         append(">")
                     }
                     if (configuration.kotlinStyleNulls) {
-                        append(type.modifiers.nullability().suffix)
+                        append(type.modifiers.nullability.suffix)
                     }
                 }
                 is VariableTypeItem -> {
@@ -533,7 +539,7 @@ abstract class DefaultTypeItem(
                     }
                     append(type.name)
                     if (configuration.kotlinStyleNulls) {
-                        append(type.modifiers.nullability().suffix)
+                        append(type.modifiers.nullability.suffix)
                     }
                 }
                 is WildcardTypeItem -> {
@@ -580,7 +586,7 @@ abstract class DefaultTypeItem(
 
             // When nullability information is included, excluded bounds imply non-null when
             // kotlinStyleNulls is true and platform when it is false.
-            val nullability = extendsBound.modifiers.nullability()
+            val nullability = extendsBound.modifiers.nullability
             if (configuration.kotlinStyleNulls && nullability == TypeNullability.NONNULL)
                 return false
             if (!configuration.kotlinStyleNulls && nullability == TypeNullability.PLATFORM)
@@ -595,17 +601,9 @@ abstract class DefaultTypeItem(
             trailingSpace: Boolean = true
         ) {
             val annotations =
-                modifiers.annotations().filter { annotation ->
+                modifiers.annotations.filter { annotation ->
                     // If Kotlin-style nulls are printed, nullness annotations shouldn't be.
-                    if (configuration.kotlinStyleNulls && annotation.isNullnessAnnotation()) {
-                        return@filter false
-                    }
-
-                    val filter = configuration.filter ?: return@filter true
-                    val qualifiedName = annotation.qualifiedName ?: return@filter true
-                    val annotationClass =
-                        annotation.codebase.findClass(qualifiedName) ?: return@filter true
-                    filter.test(annotationClass)
+                    !(configuration.kotlinStyleNulls && annotation.isNullnessAnnotation())
                 }
             if (annotations.isEmpty()) return
 
@@ -680,7 +678,7 @@ abstract class DefaultTypeItem(
                 return qualifiedName
             }
 
-            // If class name contains $, it's not an ambiguous inner class name.
+            // If class name contains $, it's not an ambiguous nested class name.
             if (qualifiedName.indexOf('$') != -1) {
                 return qualifiedName.replace('.', '/')
             }
@@ -713,7 +711,10 @@ interface TypeArgumentTypeItem : TypeItem {
     override fun convertType(typeParameterBindings: TypeParameterBindings): TypeArgumentTypeItem
 
     /** Override to specialize the return type. */
-    override fun duplicate(): TypeArgumentTypeItem
+    override fun substitute(modifiers: TypeModifiers): TypeArgumentTypeItem
+
+    /** Override to specialize the return type. */
+    override fun transform(transformer: TypeTransformer): TypeArgumentTypeItem
 }
 
 /**
@@ -726,7 +727,10 @@ interface ReferenceTypeItem : TypeItem, TypeArgumentTypeItem {
     override fun convertType(typeParameterBindings: TypeParameterBindings): ReferenceTypeItem
 
     /** Override to specialize the return type. */
-    override fun duplicate(): ReferenceTypeItem
+    override fun substitute(modifiers: TypeModifiers): ReferenceTypeItem
+
+    /** Override to specialize the return type. */
+    override fun transform(transformer: TypeTransformer): ReferenceTypeItem
 }
 
 /**
@@ -742,6 +746,9 @@ interface BoundsTypeItem : TypeItem, ReferenceTypeItem
  * See https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-ExceptionType.
  */
 sealed interface ExceptionTypeItem : TypeItem, ReferenceTypeItem {
+    /** Override to specialize the return type. */
+    override fun transform(transformer: TypeTransformer): ExceptionTypeItem
+
     /**
      * Get the erased [ClassItem], if any.
      *
@@ -818,10 +825,22 @@ interface PrimitiveTypeItem : TypeItem {
         visitor.visit(this, other)
     }
 
-    override fun duplicate(): PrimitiveTypeItem
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers)"),
+    )
+    fun duplicate(modifiers: TypeModifiers): PrimitiveTypeItem
+
+    override fun substitute(modifiers: TypeModifiers): PrimitiveTypeItem =
+        if (modifiers !== this.modifiers) @Suppress("DEPRECATION") duplicate(modifiers) else this
 
     override fun convertType(typeParameterBindings: TypeParameterBindings): PrimitiveTypeItem {
-        return duplicate()
+        // Primitive type is never affected by a type mapping so always return this.
+        return this
+    }
+
+    override fun transform(transformer: TypeTransformer): PrimitiveTypeItem {
+        return transformer.transform(this)
     }
 
     override fun equalToType(other: TypeItem?): Boolean {
@@ -849,16 +868,43 @@ interface ArrayTypeItem : TypeItem, ReferenceTypeItem {
         visitor.visit(this, other)
     }
 
-    override fun duplicate(): ArrayTypeItem = duplicate(componentType.duplicate())
+    /**
+     * Duplicates this type substituting in the provided [modifiers] and [componentType] in place of
+     * this instance's [modifiers] and [componentType].
+     */
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, componentType)"),
+    )
+    fun duplicate(modifiers: TypeModifiers, componentType: TypeItem): ArrayTypeItem
+
+    override fun substitute(modifiers: TypeModifiers): ArrayTypeItem =
+        substitute(modifiers, componentType)
 
     /**
-     * Duplicates this type (including duplicating the modifiers so they can be independently
-     * mutated), but substituting in the provided [componentType] in place of this type's component.
+     * Return an [ArrayTypeItem] instance identical to this one except its [TypeItem.modifiers] and
+     * [ArrayTypeItem.componentType] properties are the same as the [modifiers] and [componentType]
+     * parameters respectively.
+     *
+     * If the parameters are the same as this instance's properties then it will just return this
+     * instance, otherwise it will return a new instance.
      */
-    fun duplicate(componentType: TypeItem): ArrayTypeItem
+    fun substitute(
+        modifiers: TypeModifiers = this.modifiers,
+        componentType: TypeItem = this.componentType,
+    ) =
+        if (modifiers !== this.modifiers || componentType !== this.componentType)
+            @Suppress("DEPRECATION") duplicate(modifiers, componentType)
+        else this
 
     override fun convertType(typeParameterBindings: TypeParameterBindings): ArrayTypeItem {
-        return duplicate(componentType.convertType(typeParameterBindings))
+        return substitute(
+            componentType = componentType.convertType(typeParameterBindings),
+        )
+    }
+
+    override fun transform(transformer: TypeTransformer): ArrayTypeItem {
+        return transformer.transform(this)
     }
 
     override fun equalToType(other: TypeItem?): Boolean {
@@ -884,7 +930,7 @@ interface ClassTypeItem : TypeItem, BoundsTypeItem, ReferenceTypeItem, Exception
      */
     val arguments: List<TypeArgumentTypeItem>
 
-    /** The outer class type of this class, if it is an inner type. */
+    /** The outer class type of this class, if it is a nested type. */
     val outerClassType: ClassTypeItem?
 
     /**
@@ -915,23 +961,61 @@ interface ClassTypeItem : TypeItem, BoundsTypeItem, ReferenceTypeItem, Exception
 
     override fun isJavaLangObject(): Boolean = qualifiedName == JAVA_LANG_OBJECT
 
-    override fun duplicate(): ClassTypeItem =
-        duplicate(outerClassType?.duplicate(), arguments.map { it.duplicate() })
+    /**
+     * Check to see whether this type is a functional type, i.e. references a function interface,
+     * which is an interface with at most one abstract method.
+     */
+    fun isFunctionalType(): Boolean = error("unsupported")
 
     /**
-     * Duplicates this type (including duplicating the modifiers, so they can be independently
-     * mutated), but substituting in the provided [outerClass] and [arguments] in place of this
-     * instance's [outerClass] and [arguments].
+     * Duplicates this type substituting in the provided [modifiers], [outerClassType] and
+     * [arguments] in place of this instance's [modifiers], [outerClassType] and [arguments].
      */
-    fun duplicate(outerClass: ClassTypeItem?, arguments: List<TypeArgumentTypeItem>): ClassTypeItem
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)"),
+    )
+    fun duplicate(
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
+        arguments: List<TypeArgumentTypeItem>,
+    ): ClassTypeItem
+
+    override fun substitute(modifiers: TypeModifiers): ClassTypeItem =
+        substitute(modifiers, outerClassType, arguments)
+
+    /**
+     * Return a [ClassTypeItem] instance identical to this one except its [TypeItem.modifiers],
+     * [ClassTypeItem.outerClassType] and [ClassTypeItem.arguments] properties are the same as the
+     * [modifiers], [outerClassType] and [arguments] parameters respectively.
+     *
+     * If the parameters are the same as this instance's properties then it will just return this
+     * instance, otherwise it will return a new instance.
+     */
+    fun substitute(
+        modifiers: TypeModifiers = this.modifiers,
+        outerClassType: ClassTypeItem? = this.outerClassType,
+        arguments: List<TypeArgumentTypeItem> = this.arguments,
+    ) =
+        if (
+            modifiers !== this.modifiers ||
+                outerClassType !== this.outerClassType ||
+                arguments !== this.arguments
+        )
+            @Suppress("DEPRECATION") duplicate(modifiers, outerClassType, arguments)
+        else this
 
     override fun convertType(typeParameterBindings: TypeParameterBindings): ClassTypeItem {
-        return duplicate(
-            outerClassType?.convertType(typeParameterBindings),
-            arguments.map { it.convertType(typeParameterBindings) }
+        return substitute(
+            outerClassType = outerClassType?.convertType(typeParameterBindings),
+            arguments = arguments.mapIfNotSame { it.convertType(typeParameterBindings) },
         )
     }
 
+    override fun transform(transformer: TypeTransformer): ClassTypeItem {
+        return transformer.transform(this)
+    }
+
     override fun equalToType(other: TypeItem?): Boolean {
         if (other !is ClassTypeItem) return false
         return qualifiedName == other.qualifiedName &&
@@ -976,13 +1060,29 @@ interface LambdaTypeItem : ClassTypeItem {
     /** The return type. */
     val returnType: TypeItem
 
-    override fun duplicate(): LambdaTypeItem =
-        duplicate(outerClassType?.duplicate(), arguments.map { it.duplicate() })
-
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)")
+    )
     override fun duplicate(
-        outerClass: ClassTypeItem?,
-        arguments: List<TypeArgumentTypeItem>
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
+        arguments: List<TypeArgumentTypeItem>,
     ): LambdaTypeItem
+
+    override fun substitute(modifiers: TypeModifiers): LambdaTypeItem =
+        substitute(modifiers, outerClassType, arguments)
+
+    /** Override to specialize the return type. */
+    override fun substitute(
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
+        arguments: List<TypeArgumentTypeItem>
+    ) = super.substitute(modifiers, outerClassType, arguments) as LambdaTypeItem
+
+    override fun transform(transformer: TypeTransformer): LambdaTypeItem {
+        return transformer.transform(this)
+    }
 }
 
 /** Represents a type variable type. */
@@ -1007,30 +1107,49 @@ interface VariableTypeItem : TypeItem, BoundsTypeItem, ReferenceTypeItem, Except
         visitor.visit(this, other)
     }
 
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers)")
+    )
+    fun duplicate(modifiers: TypeModifiers): VariableTypeItem
+
+    override fun substitute(modifiers: TypeModifiers): VariableTypeItem =
+        if (modifiers !== this.modifiers) @Suppress("DEPRECATION") duplicate(modifiers) else this
+
     override fun convertType(typeParameterBindings: TypeParameterBindings): ReferenceTypeItem {
-        val nullability = modifiers.nullability()
-        return (typeParameterBindings[asTypeParameter] ?: this).duplicate().apply {
-            // If this use of the type parameter is marked as nullable, then it overrides the
-            // nullability of the substituted type.
-            if (nullability == TypeNullability.NULLABLE) {
-                modifiers.setNullability(nullability)
-            } else {
-                // If the type that is replacing the type parameter has platform nullability, i.e.
-                // carries no information one way or another about whether it is nullable, then
-                // use the nullability of the use of the type parameter as while at worst it may
-                // also have no nullability information, it could have some, e.g. from a declaration
-                // nullability annotation.
-                val typeParameterNullability = modifiers.nullability()
-                if (typeParameterNullability == TypeNullability.PLATFORM) {
-                    modifiers.setNullability(nullability)
+        val nullability = modifiers.nullability
+        return typeParameterBindings[asTypeParameter]?.let { replacement ->
+            val replacementNullability =
+                when {
+                    // If this use of the type parameter is marked as nullable, then it overrides
+                    // the nullability of the substituted type.
+                    nullability == TypeNullability.NULLABLE -> nullability
+                    // If the type that is replacing the type parameter has platform nullability,
+                    // i.e. carries no information one way or another about whether it is nullable,
+                    // then use the nullability of the use of the type parameter as while at worst
+                    // it may also have no nullability information, it could have some, e.g. from a
+                    // declaration nullability annotation.
+                    replacement.modifiers.nullability == TypeNullability.PLATFORM -> nullability
+                    else -> null
                 }
+
+            if (replacementNullability == null) {
+                replacement
+            } else {
+                replacement.substitute(replacementNullability) as ReferenceTypeItem
             }
         }
+            ?:
+            // The type parameter binding does not contain a replacement for this variable so use
+            // this as is.
+            this
     }
 
-    override fun asClass() = asTypeParameter.asErasedType()?.asClass()
+    override fun transform(transformer: TypeTransformer): VariableTypeItem {
+        return transformer.transform(this)
+    }
 
-    override fun duplicate(): VariableTypeItem
+    override fun asClass() = asTypeParameter.asErasedType()?.asClass()
 
     override fun equalToType(other: TypeItem?): Boolean {
         return (other as? VariableTypeItem)?.name == name
@@ -1058,26 +1177,56 @@ interface WildcardTypeItem : TypeItem, TypeArgumentTypeItem {
         visitor.visit(this, other)
     }
 
-    override fun duplicate(): WildcardTypeItem =
-        duplicate(extendsBound?.duplicate(), superBound?.duplicate())
-
     /**
-     * Duplicates this type (including duplicating the modifiers so they can be independently
-     * mutated), but substituting in the provided [extendsBound] and [superBound] in place of this
-     * type's bounds.
+     * Duplicates this type substituting in the provided [modifiers], [extendsBound] and
+     * [superBound] in place of this instance's [modifiers], [extendsBound] and [superBound].
      */
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, extendsBound, superBound)"),
+    )
     fun duplicate(
+        modifiers: TypeModifiers,
         extendsBound: ReferenceTypeItem?,
         superBound: ReferenceTypeItem?,
     ): WildcardTypeItem
 
+    override fun substitute(modifiers: TypeModifiers): WildcardTypeItem =
+        substitute(modifiers, extendsBound, superBound)
+
+    /**
+     * Return a [WildcardTypeItem] instance identical to this one except its [TypeItem.modifiers],
+     * [WildcardTypeItem.extendsBound] and [WildcardTypeItem.superBound] properties are the same as
+     * the [modifiers], [extendsBound] and [superBound] parameters respectively.
+     *
+     * If the parameters are the same as this instance's properties then it will just return this
+     * instance, otherwise it will return a new instance.
+     */
+    fun substitute(
+        modifiers: TypeModifiers = this.modifiers,
+        extendsBound: ReferenceTypeItem? = this.extendsBound,
+        superBound: ReferenceTypeItem? = this.superBound,
+    ) =
+        if (
+            modifiers !== this.modifiers ||
+                extendsBound !== this.extendsBound ||
+                superBound !== this.superBound
+        )
+            @Suppress("DEPRECATION") duplicate(modifiers, extendsBound, superBound)
+        else this
+
     override fun convertType(typeParameterBindings: TypeParameterBindings): WildcardTypeItem {
-        return duplicate(
+        return substitute(
+            modifiers,
             extendsBound?.convertType(typeParameterBindings),
             superBound?.convertType(typeParameterBindings)
         )
     }
 
+    override fun transform(transformer: TypeTransformer): WildcardTypeItem {
+        return transformer.transform(this)
+    }
+
     override fun equalToType(other: TypeItem?): Boolean {
         if (other !is WildcardTypeItem) return false
         return extendsBound?.equalToType(other.extendsBound) != false &&
@@ -1089,6 +1238,43 @@ interface WildcardTypeItem : TypeItem, TypeArgumentTypeItem {
     override fun asClass(): ClassItem? = null
 }
 
+/**
+ * Create a [TypeTransformer] that will remove any type annotations for which [filter] returns false
+ * when called against the [AnnotationItem]'s [ClassItem] return by [AnnotationItem.resolve]. If
+ * that returns `null` then the [AnnotationItem] will be kept.
+ */
+fun typeUseAnnotationFilter(filter: Predicate<Item>): TypeTransformer =
+    object : BaseTypeTransformer() {
+        override fun transform(modifiers: TypeModifiers): TypeModifiers {
+            if (modifiers.annotations.isEmpty()) return modifiers
+            return modifiers.substitute(
+                annotations =
+                    modifiers.annotations.filter { annotationItem ->
+                        // If the annotation cannot be resolved then keep it.
+                        val annotationClass = annotationItem.resolve() ?: return@filter true
+                        filter.test(annotationClass)
+                    }
+            )
+        }
+    }
+
+/**
+ * Map the items in this list to a new list if [transform] returns at least one item which is not
+ * the same instance as its input, otherwise return this.
+ */
+fun <T> List<T>.mapIfNotSame(transform: (T) -> T): List<T> {
+    if (isEmpty()) return this
+    val newList = map(transform)
+    val i1 = iterator()
+    val i2 = newList.iterator()
+    while (i1.hasNext() && i2.hasNext()) {
+        val t1 = i1.next()
+        val t2 = i2.next()
+        if (t1 !== t2) return newList
+    }
+    return this
+}
+
 /**
  * Attempt to get the full name from the qualified name.
  *
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeModifiers.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeModifiers.kt
index cae324cc7..361c028d4 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeModifiers.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeModifiers.kt
@@ -22,38 +22,35 @@ package com.android.tools.metalava.model
  */
 interface TypeModifiers {
     /** The type-use annotations applied to the owning type. */
-    fun annotations(): List<AnnotationItem>
-
-    /** Adds the [annotation] to the list of annotations for the type. */
-    fun addAnnotation(annotation: AnnotationItem)
-
-    /** Removes the [annotation] from the list of annotations for the type, if it was present. */
-    fun removeAnnotation(annotation: AnnotationItem)
+    val annotations: List<AnnotationItem>
 
     /** The nullability of the type. */
-    fun nullability(): TypeNullability
+    val nullability: TypeNullability
 
     /**
-     * Updates the nullability of the type to [newNullability]. Does not add or remove any nullness
-     * annotations, so those should be handled separately through [addAnnotation] and/or
-     * [removeAnnotation], if needed.
+     * Return a [TypeModifiers] instance identical to this one except its
+     * [TypeModifiers.nullability] and [TypeModifiers.annotations] properties are the same as the
+     * [nullability] and [annotations] parameters respectively.
+     *
+     * If the parameters are the same as this instance's properties then it will just return this
+     * instance, otherwise it will return a new instance.
      */
-    fun setNullability(newNullability: TypeNullability)
-
-    /** Create a copy of this to which modifications can be made. */
-    fun duplicate(withNullability: TypeNullability? = null): TypeModifiers
+    fun substitute(
+        nullability: TypeNullability = this.nullability,
+        annotations: List<AnnotationItem> = this.annotations,
+    ): TypeModifiers
 
     /** Whether the [nullability] is [TypeNullability.NULLABLE]. */
     val isNullable
-        get() = nullability() == TypeNullability.NULLABLE
+        get() = nullability == TypeNullability.NULLABLE
 
     /** Whether the [nullability] is [TypeNullability.NONNULL]. */
     val isNonNull
-        get() = nullability() == TypeNullability.NONNULL
+        get() = nullability == TypeNullability.NONNULL
 
     /** Whether the [nullability] is [TypeNullability.PLATFORM]. */
     val isPlatformNullability
-        get() = nullability() == TypeNullability.PLATFORM
+        get() = nullability == TypeNullability.PLATFORM
 }
 
 /** An enum representing the possible nullness values of a type. */
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
index 15765af9f..1a621b257 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
@@ -25,6 +25,9 @@ interface TypeParameterItem : Item {
     /** The [VariableTypeItem] representing the type of this type parameter. */
     override fun type(): VariableTypeItem
 
+    override fun setType(type: TypeItem) =
+        error("Cannot call setType(TypeItem) on TypeParameterItem: $this")
+
     fun typeBounds(): List<BoundsTypeItem>
 
     /**
@@ -62,6 +65,17 @@ interface TypeParameterItem : Item {
         }
     }
 
+    override fun equalsToItem(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is TypeParameterItem) return false
+
+        return name() == other.name()
+    }
+
+    override fun hashCodeForItem(): Int {
+        return name().hashCode()
+    }
+
     override fun toStringForItem(): String =
         if (typeBounds().isEmpty() && !isReified()) name()
         else
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt
index 0387372f0..bcae985fb 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterList.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.android.tools.metalava.model.type.TypeItemFactory
 
 /**
@@ -51,7 +52,8 @@ interface TypeParameterList : List<TypeParameterItem> {
     }
 }
 
-class DefaultTypeParameterList(private val typeParameters: List<TypeParameterItem>) :
+class DefaultTypeParameterList
+private constructor(private val typeParameters: List<TypeParameterItem>) :
     TypeParameterList, List<TypeParameterItem> by typeParameters {
 
     private val toString by lazy {
@@ -80,14 +82,6 @@ class DefaultTypeParameterList(private val typeParameters: List<TypeParameterIte
     override fun hashCode() = typeParameters.hashCode()
 
     companion object {
-        /**
-         * Group up [typeParameters] and the [factory] that was used to resolve references when
-         * creating their [BoundsTypeItem]s.
-         */
-        data class TypeParametersAndFactory<F : TypeItemFactory<*, F>>(
-            val typeParameters: List<TypeParameterItem>,
-            val factory: F,
-        )
 
         /**
          * Create a list of [TypeParameterItem] and a corresponding [TypeItemFactory] from model
@@ -109,20 +103,18 @@ class DefaultTypeParameterList(private val typeParameters: List<TypeParameterIte
          * @param inputParams a list of the model specific type parameters.
          * @param paramFactory a function that will create a [TypeParameterItem] from the model
          *   specified parameter [P].
-         * @param boundsSetter a function that will create a list of [BoundsTypeItem] from the model
-         *   specific bounds and store it in [TypeParameterItem.typeBounds].
-         * @param I the type of the model specific [TypeParameterItem].
+         * @param boundsGetter a function that will create a list of [BoundsTypeItem] from the model
+         *   specific bounds which will be stored in [DefaultTypeParameterItem.bounds].
          * @param P the type of the underlying model specific type parameter objects.
          * @param F the type of the model specific [TypeItemFactory].
          */
-        fun <
-            I : TypeParameterItem, P, F : TypeItemFactory<*, F>> createTypeParameterItemsAndFactory(
+        fun <P, F : TypeItemFactory<*, F>> createTypeParameterItemsAndFactory(
             containingTypeItemFactory: F,
             scopeDescription: String,
             inputParams: List<P>,
-            paramFactory: (P) -> I,
-            boundsSetter: (F, I, P) -> List<BoundsTypeItem>,
-        ): TypeParametersAndFactory<F> {
+            paramFactory: (P) -> DefaultTypeParameterItem,
+            boundsGetter: (F, P) -> List<BoundsTypeItem>,
+        ): TypeParameterListAndFactory<F> {
             // First, create a Map from [TypeParameterItem] to the model specific parameter. Using
             // the [paramFactory] to convert the model specific parameter to a [TypeParameterItem].
             val typeParameterItemToBounds = inputParams.associateBy { param -> paramFactory(param) }
@@ -135,13 +127,22 @@ class DefaultTypeParameterList(private val typeParameters: List<TypeParameterIte
             // Then, create and set the bounds in the [TypeParameterItem] passing in the
             // [TypeItemFactory] to allow cross-references to type parameters to be resolved.
             for ((typeParameter, param) in typeParameterItemToBounds) {
-                val boundsTypeItem = boundsSetter(typeItemFactory, typeParameter, param)
-                if (typeParameter.typeBounds() !== boundsTypeItem)
-                    error("boundsSetter did not set bounds")
+                val boundsTypeItems = boundsGetter(typeItemFactory, param)
+                typeParameter.bounds = boundsTypeItems
             }
 
             // Pair the list up with the [TypeItemFactory] so that the latter can be reused.
-            return TypeParametersAndFactory(typeParameters, typeItemFactory)
+            val typeParameterList = DefaultTypeParameterList(typeParameters)
+            return TypeParameterListAndFactory(typeParameterList, typeItemFactory)
         }
     }
 }
+
+/**
+ * Group up [typeParameterList] and the [factory] that was used to resolve references when creating
+ * their [BoundsTypeItem]s.
+ */
+data class TypeParameterListAndFactory<F : TypeItemFactory<*, F>>(
+    val typeParameterList: TypeParameterList,
+    val factory: F,
+)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterScope.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterScope.kt
index 8e218a8fe..5848a9c3b 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterScope.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterScope.kt
@@ -109,16 +109,16 @@ sealed class TypeParameterScope private constructor() {
         }
 
         /**
-         * Collect all the type parameters in scope for the given [methodItem] then wrap them in an
+         * Collect all the type parameters in scope for the given [callableItem] then wrap them in a
          * [TypeParameterScope].
          */
-        fun from(methodItem: MethodItem): TypeParameterScope {
+        fun from(callableItem: CallableItem): TypeParameterScope {
             // Construct a scope from the owner.
-            return from(methodItem.containingClass())
+            return from(callableItem.containingClass())
                 // Nest this inside it.
                 .nestedScope(
-                    description = "method ${methodItem.name()}",
-                    methodItem.typeParameterList,
+                    description = "method/constructor ${callableItem.name()}",
+                    callableItem.typeParameterList,
                 )
         }
     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeTransformer.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeTransformer.kt
new file mode 100644
index 000000000..d6bd6f125
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeTransformer.kt
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+/**
+ * A visitor like pattern that can apply a transform to a [TypeItem].
+ *
+ * See [TypeItem.transform].
+ */
+interface TypeTransformer {
+    fun transform(typeItem: ArrayTypeItem): ArrayTypeItem = typeItem
+
+    fun transform(typeItem: ClassTypeItem): ClassTypeItem = typeItem
+
+    fun transform(typeItem: LambdaTypeItem): LambdaTypeItem = typeItem
+
+    fun transform(typeItem: PrimitiveTypeItem): PrimitiveTypeItem = typeItem
+
+    fun transform(typeItem: VariableTypeItem): VariableTypeItem = typeItem
+
+    fun transform(typeItem: WildcardTypeItem): WildcardTypeItem = typeItem
+}
+
+/**
+ * A [TypeTransformer] that recursively calls [TypeItem.transform] on each [TypeItem]'s
+ * [TypeItem.modifiers] and any contained [TypeItem] and then substitutes those in to the [TypeItem]
+ * using the appropriate `substitute(TypeModifiers,...)` method.
+ */
+open class BaseTypeTransformer : TypeTransformer {
+
+    open fun transform(modifiers: TypeModifiers): TypeModifiers = modifiers
+
+    override fun transform(typeItem: ArrayTypeItem): ArrayTypeItem {
+        return typeItem.substitute(
+            modifiers = transform(typeItem.modifiers),
+            componentType = typeItem.componentType.transform(this),
+        )
+    }
+
+    override fun transform(typeItem: ClassTypeItem): ClassTypeItem {
+        return typeItem.substitute(
+            modifiers = transform(typeItem.modifiers),
+            outerClassType = typeItem.outerClassType?.transform(this),
+            arguments = typeItem.arguments.mapIfNotSame { it.transform(this) }
+        )
+    }
+
+    override fun transform(typeItem: LambdaTypeItem): LambdaTypeItem {
+        return typeItem.substitute(
+            modifiers = transform(typeItem.modifiers),
+            outerClassType = typeItem.outerClassType?.transform(this),
+            arguments = typeItem.arguments.mapIfNotSame { it.transform(this) }
+        )
+    }
+
+    override fun transform(typeItem: PrimitiveTypeItem): PrimitiveTypeItem {
+        return typeItem.substitute(
+            modifiers = transform(typeItem.modifiers),
+        )
+    }
+
+    override fun transform(typeItem: VariableTypeItem): VariableTypeItem {
+        return typeItem.substitute(
+            modifiers = transform(typeItem.modifiers),
+        )
+    }
+
+    override fun transform(typeItem: WildcardTypeItem): WildcardTypeItem {
+        return typeItem.substitute(
+            modifiers = transform(typeItem.modifiers),
+            extendsBound = typeItem.extendsBound?.transform(this),
+            superBound = typeItem.superBound?.transform(this),
+        )
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt
index 5ead557a4..6e6366c40 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/VisibilityLevel.kt
@@ -31,11 +31,11 @@ enum class VisibilityLevel(
     /** String representation in user visible messages. */
     val userVisibleDescription: String,
     /** Representation in the internal flags. */
-    val visibilityFlagValue: Int
+    internal val visibilityFlagValue: Int
 ) {
-    PACKAGE_PRIVATE("", "", "package private", DefaultModifierList.PACKAGE_PRIVATE),
-    PRIVATE("private", "private", "private", DefaultModifierList.PRIVATE),
-    INTERNAL("internal", "internal", "internal", DefaultModifierList.INTERNAL),
-    PROTECTED("protected", "protected", "protected", DefaultModifierList.PROTECTED),
-    PUBLIC("public", "", "public", DefaultModifierList.PUBLIC)
+    PACKAGE_PRIVATE("", "", "package private", ModifierFlags.PACKAGE_PRIVATE),
+    PRIVATE("private", "private", "private", ModifierFlags.PRIVATE),
+    INTERNAL("internal", "internal", "internal", ModifierFlags.INTERNAL),
+    PROTECTED("protected", "protected", "protected", ModifierFlags.PROTECTED),
+    PUBLIC("public", "", "public", ModifierFlags.PUBLIC)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/CodebaseAssembler.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/CodebaseAssembler.kt
new file mode 100644
index 000000000..441af8999
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/CodebaseAssembler.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+
+/**
+ * A factory that will create a [DefaultCodebase] for a specific [CodebaseAssembler].
+ *
+ * An implementation of this must not try and access any [CodebaseAssembler] functions as it will
+ * not be fully initialized at the time this is called.
+ */
+typealias DefaultCodebaseFactory = (CodebaseAssembler) -> DefaultCodebase
+
+/**
+ * A [CodebaseAssembler] is responsible for providing a [Codebase] with access to classes which are
+ * present in the underlying model but not yet present in the [Codebase].
+ *
+ * Although, the interface is simple, the implementation will do a vast amount of the work of
+ * mapping an underlying model's representation of the API to a [Codebase], if not all of it.
+ */
+interface CodebaseAssembler {
+    /**
+     * Create a [DefaultPackageItem] for package called [packageName], with additional information
+     * from [packageDoc] whose containing package, if any, is [containingPackage].
+     */
+    fun createPackageItem(
+        packageName: String,
+        packageDoc: PackageDoc,
+        containingPackage: PackageItem?,
+    ): DefaultPackageItem
+
+    /**
+     * A [ClassItem] with [qualifiedName] could not be found in the associated [Codebase] so look in
+     * the underlying model's set of classes to see if one could be found there. If it could then
+     * create a [ClassItem] representation of it and return that, otherwise return null.
+     */
+    fun createClassFromUnderlyingModel(qualifiedName: String): ClassItem?
+
+    /**
+     * Overrideable hook, called from [DefaultCodebase.registerClass] for each new
+     * [DefaultClassItem].
+     */
+    fun newClassRegistered(classItem: DefaultClassItem) {}
+}
+
+/**
+ * Base [CodebaseAssembler] for use by models that do not use model specific implementations of the
+ * [Item] classes.
+ */
+abstract class DefaultCodebaseAssembler : CodebaseAssembler {
+
+    /** Factory for creating appropriate [Item] subclasses for the [Codebase] this is assembling. */
+    abstract val itemFactory: DefaultItemFactory
+
+    override fun createPackageItem(
+        packageName: String,
+        packageDoc: PackageDoc,
+        containingPackage: PackageItem?,
+    ): DefaultPackageItem {
+        val documentationFactory = packageDoc.commentFactory ?: "".toItemDocumentationFactory()
+        return itemFactory.createPackageItem(
+            packageDoc.fileLocation,
+            packageDoc.modifiers ?: createImmutableModifiers(VisibilityLevel.PUBLIC),
+            documentationFactory,
+            packageName,
+            containingPackage,
+            packageDoc.overview,
+        )
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt
new file mode 100644
index 000000000..f03a671aa
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.CallableBody
+import com.android.tools.metalava.model.CallableBodyFactory
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.reporter.FileLocation
+
+/**
+ * A lamda that given a [CallableItem] will create a list of [ParameterItem]s for it.
+ *
+ * This is called from within the constructor of the [ParameterItem.containingCallable] and can only
+ * access the [CallableItem.name] (to identify callables that have special nullability rules) and
+ * store a reference to it in [ParameterItem.containingCallable]. In particularly, it must not
+ * access [CallableItem.parameters] as that will not yet have been initialized when this is called.
+ */
+typealias ParameterItemsFactory = (CallableItem) -> List<ParameterItem>
+
+abstract class DefaultCallableItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    name: String,
+    containingClass: ClassItem,
+    override val typeParameterList: TypeParameterList,
+    returnType: TypeItem,
+    parameterItemsFactory: ParameterItemsFactory,
+    internal val throwsTypes: List<ExceptionTypeItem>,
+    callableBodyFactory: CallableBodyFactory,
+) :
+    DefaultMemberItem(
+        codebase,
+        fileLocation,
+        itemLanguage,
+        modifiers,
+        documentationFactory,
+        variantSelectorsFactory,
+        name,
+        containingClass,
+    ),
+    CallableItem {
+
+    /** Make it readable to subclasses but not writable. */
+    protected var returnType: TypeItem = returnType
+        private set
+
+    /**
+     * Create the [ParameterItem] list during initialization of this callable to allow them to
+     * contain an immutable reference to this object.
+     *
+     * The leaking of `this` to `parameterItemsFactory` is ok as implementations follow the rules
+     * explained in the documentation of [ParameterItemsFactory].
+     */
+    @Suppress("LeakingThis") internal val parameters = parameterItemsFactory(this)
+
+    override fun returnType(): TypeItem = returnType
+
+    override fun setType(type: TypeItem) {
+        returnType = type
+    }
+
+    final override fun parameters(): List<ParameterItem> = parameters
+
+    final override fun throwsTypes(): List<ExceptionTypeItem> = throwsTypes
+
+    /**
+     * Create the [CallableBody] during initialization of this callable to allow it to contain an
+     * immutable reference to this object.
+     *
+     * The leaking of `this` to `callableBodyFactory` is ok as implementations follow the rules
+     * explained in the documentation of [CallableBodyFactory].
+     */
+    final override val body: CallableBody = callableBodyFactory(@Suppress("LeakingThis") this)
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
new file mode 100644
index 000000000..30efa6b7e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.AnnotationRetention
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.MutableCodebase
+import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.type.DefaultResolvedClassTypeItem
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultClassItem(
+    codebase: MutableCodebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    private val source: SourceFile?,
+    final override val classKind: ClassKind,
+    private val containingClass: ClassItem?,
+    private val containingPackage: PackageItem,
+    private val qualifiedName: String,
+    final override val typeParameterList: TypeParameterList,
+    final override val origin: ClassOrigin,
+    private var superClassType: ClassTypeItem?,
+    private var interfaceTypes: List<ClassTypeItem>,
+) :
+    DefaultItem(
+        codebase = codebase,
+        fileLocation = fileLocation,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = variantSelectorsFactory,
+    ),
+    ClassItem {
+
+    private val simpleName = qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1)
+
+    private val fullName: String
+
+    init {
+        // Register the class first. Leaking `this` is ok as it only uses its qualified name and
+        // fileLocation, both of which have been initialized. If registration succeeded then wire
+        // the class into the containing package/containing class. If it failed, because it is a
+        // duplicate, then do nothing.
+        if (codebase.registerClass(@Suppress("LeakingThis") this)) {
+            // Only emit classes that were specified on the command line.
+            emit = emit && origin == ClassOrigin.COMMAND_LINE
+
+            // If this class is emittable then make sure its package is too.
+            if (emit) {
+                containingPackage.emit = true
+            }
+
+            if (containingClass == null) {
+                (containingPackage as DefaultPackageItem).addTopClass(this)
+                fullName = simpleName
+            } else {
+                (containingClass as DefaultClassItem).addNestedClass(this)
+                fullName = "${containingClass.fullName()}.$simpleName"
+            }
+        } else {
+            // The fullName needs to be initialized to something so initializing it to something
+            // invalid will ensure it is not accidentally used.
+            fullName = "duplicate class"
+        }
+    }
+
+    override fun getSourceFile() = source
+
+    final override fun containingPackage(): PackageItem = containingPackage
+
+    final override fun containingClass() = containingClass
+
+    final override fun qualifiedName() = qualifiedName
+
+    final override fun simpleName() = simpleName
+
+    final override fun fullName() = fullName
+
+    final override fun hasTypeVariables(): Boolean = typeParameterList.isNotEmpty()
+
+    /** Must only be used by [type] to cache its result. */
+    private lateinit var cachedType: ClassTypeItem
+
+    final override fun type(): ClassTypeItem {
+        if (!::cachedType.isInitialized) {
+            cachedType = createClassTypeItemForThis()
+        }
+        return cachedType
+    }
+
+    protected open fun createClassTypeItemForThis() =
+        DefaultResolvedClassTypeItem.createForClass(this)
+
+    final override var frozen = false
+        private set
+
+    override fun freeze() {
+        if (frozen) return
+        frozen = true
+        superClass()?.freeze()
+        for (interfaceType in interfaceTypes) {
+            interfaceType.asClass()?.freeze()
+        }
+    }
+
+    private fun ensureNotFrozen() {
+        if (frozen) error("Cannot modify frozen $this")
+    }
+
+    final override fun mutateModifiers(mutator: MutableModifierList.() -> Unit) {
+        ensureNotFrozen()
+        super.mutateModifiers(mutator)
+    }
+
+    final override fun superClassType(): ClassTypeItem? = superClassType
+
+    /** Set the super class [ClassTypeItem]. */
+    fun setSuperClassType(superClassType: ClassTypeItem?) {
+        ensureNotFrozen()
+        this.superClassType = superClassType
+    }
+
+    final override fun interfaceTypes(): List<ClassTypeItem> = interfaceTypes
+
+    final override fun setInterfaceTypes(interfaceTypes: List<ClassTypeItem>) {
+        ensureNotFrozen()
+        this.interfaceTypes = interfaceTypes
+    }
+
+    /** Cache of the results of calling [cacheAllInterfaces]. */
+    private var cacheAllInterfaces: List<ClassItem>? = null
+
+    final override fun allInterfaces(): Sequence<ClassItem> {
+        if (cacheAllInterfaces == null) {
+            cacheAllInterfaces = computeAllInterfaces()
+        }
+
+        return cacheAllInterfaces!!.asSequence()
+    }
+
+    /** Compute the value for [ClassItem.allInterfaces]. */
+    private fun computeAllInterfaces() = buildList {
+        // Add self as interface if applicable
+        if (isInterface()) {
+            add(this@DefaultClassItem)
+        }
+
+        // Add all the interfaces of super class
+        superClass()?.let { superClass -> superClass.allInterfaces().forEach { add(it) } }
+
+        // Add all the interfaces of direct interfaces
+        interfaceTypes().forEach { interfaceType ->
+            val itf = interfaceType.asClass()
+            itf?.allInterfaces()?.forEach { add(it) }
+        }
+    }
+
+    /** The mutable list of [ConstructorItem] that backs [constructors]. */
+    private val mutableConstructors = mutableListOf<ConstructorItem>()
+
+    final override fun constructors(): List<ConstructorItem> = mutableConstructors
+
+    /** Add a constructor to this class. */
+    fun addConstructor(constructor: ConstructorItem) {
+        ensureNotFrozen()
+        mutableConstructors += constructor
+
+        // Keep track of whether any implicit constructors were added.
+        if (constructor.isImplicitConstructor()) {
+            hasImplicitDefaultConstructor = true
+        }
+    }
+
+    /** Tracks whether the class has an implicit default constructor. */
+    private var hasImplicitDefaultConstructor = false
+
+    final override fun hasImplicitDefaultConstructor(): Boolean = hasImplicitDefaultConstructor
+
+    override fun createDefaultConstructor(visibility: VisibilityLevel): ConstructorItem {
+        return DefaultConstructorItem.createDefaultConstructor(
+            codebase = codebase,
+            itemLanguage = itemLanguage,
+            variantSelectorsFactory = variantSelectors::duplicate,
+            containingClass = this,
+            visibility = visibility,
+        )
+    }
+
+    /** The mutable list of [MethodItem] that backs [methods]. */
+    private val mutableMethods = mutableListOf<MethodItem>()
+
+    final override fun methods(): List<MethodItem> = mutableMethods
+
+    /** Add a method to this class. */
+    final override fun addMethod(method: MethodItem) {
+        ensureNotFrozen()
+        mutableMethods += method
+    }
+
+    /**
+     * Replace an existing method with [method], if no such method exists then just add [method] to
+     * the list of methods.
+     */
+    fun replaceOrAddMethod(method: MethodItem) {
+        ensureNotFrozen()
+        val iterator = mutableMethods.listIterator()
+        while (iterator.hasNext()) {
+            val existing = iterator.next()
+            if (existing == method) {
+                iterator.set(method)
+                return
+            }
+        }
+        mutableMethods += method
+    }
+
+    /** The mutable list of [FieldItem] that backs [fields]. */
+    private val mutableFields = mutableListOf<FieldItem>()
+
+    /** Add a field to this class. */
+    fun addField(field: FieldItem) {
+        ensureNotFrozen()
+        mutableFields += field
+    }
+
+    final override fun fields(): List<FieldItem> = mutableFields
+
+    /** The mutable list of [PropertyItem] that backs [properties]. */
+    private val mutableProperties = mutableListOf<PropertyItem>()
+
+    final override fun properties(): List<PropertyItem> = mutableProperties
+
+    /** Add a property to this class. */
+    fun addProperty(property: PropertyItem) {
+        ensureNotFrozen()
+        mutableProperties += property
+    }
+
+    /** The mutable list of nested [ClassItem] that backs [nestedClasses]. */
+    private val mutableNestedClasses = mutableListOf<ClassItem>()
+
+    final override fun nestedClasses(): List<ClassItem> = mutableNestedClasses
+
+    /** Add a nested class to this class. */
+    private fun addNestedClass(classItem: ClassItem) {
+        ensureNotFrozen()
+        mutableNestedClasses.add(classItem)
+    }
+
+    /** Cache result of [getRetention]. */
+    private var cacheRetention: AnnotationRetention? = null
+
+    final override fun getRetention(): AnnotationRetention {
+        cacheRetention?.let {
+            return it
+        }
+
+        if (!isAnnotationType()) {
+            error("getRetention() should only be called on annotation classes")
+        }
+
+        cacheRetention = ClassItem.findRetention(this)
+        return cacheRetention!!
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
new file mode 100644
index 000000000..e40c120ce
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.AnnotationManager
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.DefaultAnnotationItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.MutableCodebase
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.Reporter
+import java.io.File
+import java.util.HashMap
+
+private const val CLASS_ESTIMATE = 15000
+
+/** Base class of [Codebase]s. */
+open class DefaultCodebase(
+    final override var location: File,
+    description: String,
+    override val preFiltered: Boolean,
+    override val annotationManager: AnnotationManager,
+    private val trustedApi: Boolean,
+    private val supportsDocumentation: Boolean,
+    reporter: Reporter? = null,
+    val assembler: CodebaseAssembler,
+) : MutableCodebase {
+
+    final override var description: String = description
+        private set
+
+    final override fun trustedApi() = trustedApi
+
+    final override fun supportsDocumentation() = supportsDocumentation
+
+    final override fun toString() = description
+
+    override fun dispose() {
+        description += " [disposed]"
+    }
+
+    private val optionalReporter = reporter
+
+    override val reporter: Reporter
+        get() = optionalReporter ?: unsupported("reporter is not available")
+
+    /** Tracks [DefaultPackageItem] use in this [Codebase]. */
+    val packageTracker = PackageTracker(assembler::createPackageItem)
+
+    final override fun getPackages() = packageTracker.getPackages()
+
+    final override fun size() = packageTracker.size
+
+    final override fun findPackage(pkgName: String) = packageTracker.findPackage(pkgName)
+
+    fun findOrCreatePackage(
+        packageName: String,
+        packageDocs: PackageDocs = PackageDocs.EMPTY,
+    ) = packageTracker.findOrCreatePackage(packageName, packageDocs)
+
+    /** Add the package to this. */
+    fun addPackage(packageItem: DefaultPackageItem) {
+        packageTracker.addPackage(packageItem)
+    }
+
+    /**
+     * Map from fully qualified name to [DefaultClassItem] for every class created by this.
+     *
+     * Classes are added via [registerClass] while initialising the codebase.
+     */
+    protected val allClassesByName = HashMap<String, DefaultClassItem>(CLASS_ESTIMATE)
+
+    /** Find a class created by this [Codebase]. */
+    fun findClassInCodebase(className: String) = allClassesByName[className]
+
+    /**
+     * A list of the top-level classes declared in the codebase's source (rather than on its
+     * classpath).
+     */
+    private val topLevelClassesFromSource: MutableList<ClassItem> = ArrayList(CLASS_ESTIMATE)
+
+    final override fun getTopLevelClassesFromSource(): List<ClassItem> {
+        return topLevelClassesFromSource
+    }
+
+    fun addTopLevelClassFromSource(classItem: ClassItem) {
+        topLevelClassesFromSource.add(classItem)
+    }
+
+    override fun freezeClasses() {
+        for (classItem in topLevelClassesFromSource) {
+            classItem.freeze()
+        }
+    }
+
+    /**
+     * Look for classes in this [Codebase].
+     *
+     * A class can be added to this [Codebase] in two ways:
+     * * Created specifically for this [Codebase], i.e. its [ClassItem.codebase] is this. That can
+     *   happen during initialization or because [CodebaseAssembler.createClassFromUnderlyingModel]
+     *   creates a [ClassItem] in this [Codebase].
+     * * Created by another [Codebase] and returned by
+     *   [CodebaseAssembler.createClassFromUnderlyingModel], i.e. its [ClassItem.codebase] is NOT
+     *   this.
+     */
+    final override fun findClass(className: String): ClassItem? =
+        findClassInCodebase(className) ?: externalClassesByName[className]
+
+    /** Register [DefaultClassItem] with this [Codebase]. */
+    final override fun registerClass(classItem: DefaultClassItem): Boolean {
+        // Check for duplicates, ignore the class if it is a duplicate.
+        val qualifiedName = classItem.qualifiedName()
+        val existing = allClassesByName[qualifiedName]
+        if (existing != null) {
+            reporter.report(
+                Issues.DUPLICATE_SOURCE_CLASS,
+                classItem,
+                "Attempted to register $qualifiedName twice; once from ${existing.fileLocation.path} and this one from ${classItem.fileLocation.path}"
+            )
+            // The class was not registered.
+            return false
+        }
+
+        // Register it by name.
+        allClassesByName[qualifiedName] = classItem
+
+        // Perform any subclass specific processing on the newly registered class.
+        assembler.newClassRegistered(classItem)
+
+        // The class was registered.
+        return true
+    }
+
+    /** Map from name to an external class that was registered using [] */
+    private val externalClassesByName = mutableMapOf<String, ClassItem>()
+
+    /**
+     * Looks for an existing class in this [Codebase] and if that cannot be found then delegate to
+     * the [assembler] to see if it can create a class from the underlying model.
+     */
+    final override fun resolveClass(className: String): ClassItem? {
+        findClass(className)?.let {
+            return it
+        }
+        val created = assembler.createClassFromUnderlyingModel(className) ?: return null
+        // If the returned class was not created as part of this Codebase then register it as an
+        // external class so that findClass(...) will find it next time.
+        if (created.codebase !== this) {
+            // Register as an external class.
+            externalClassesByName[className] = created
+        }
+        return created
+    }
+
+    open override fun createAnnotation(
+        source: String,
+        context: Item?,
+    ): AnnotationItem? {
+        return DefaultAnnotationItem.create(this, source)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
new file mode 100644
index 000000000..6591e64aa
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.CallableBody
+import com.android.tools.metalava.model.CallableBodyFactory
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.createImmutableModifiers
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultConstructorItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    name: String,
+    containingClass: ClassItem,
+    typeParameterList: TypeParameterList,
+    returnType: ClassTypeItem,
+    parameterItemsFactory: ParameterItemsFactory,
+    throwsTypes: List<ExceptionTypeItem>,
+    callableBodyFactory: CallableBodyFactory,
+    private val implicitConstructor: Boolean,
+) :
+    DefaultCallableItem(
+        codebase = codebase,
+        fileLocation = fileLocation,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = variantSelectorsFactory,
+        name = name,
+        containingClass = containingClass,
+        typeParameterList = typeParameterList,
+        returnType = returnType,
+        parameterItemsFactory = parameterItemsFactory,
+        throwsTypes = throwsTypes,
+        callableBodyFactory = callableBodyFactory,
+    ),
+    ConstructorItem {
+
+    /** Override to specialize the return type. */
+    final override fun returnType() = super.returnType() as ClassTypeItem
+
+    /** Override to make sure that [type] is a [ClassTypeItem]. */
+    final override fun setType(type: TypeItem) {
+        super.setType(type as ClassTypeItem)
+    }
+
+    final override fun isImplicitConstructor() = implicitConstructor
+
+    companion object {
+        fun createDefaultConstructor(
+            codebase: Codebase,
+            itemLanguage: ItemLanguage,
+            variantSelectorsFactory: ApiVariantSelectorsFactory,
+            containingClass: ClassItem,
+            visibility: VisibilityLevel,
+        ): ConstructorItem {
+            val name = containingClass.simpleName()
+            val modifiers = createImmutableModifiers(visibility)
+
+            val ctorItem =
+                DefaultConstructorItem(
+                    codebase = codebase,
+                    // Use the location of the containing class for the default constructor.
+                    fileLocation = containingClass.fileLocation,
+                    itemLanguage = itemLanguage,
+                    modifiers = modifiers,
+                    documentationFactory = ItemDocumentation.NONE_FACTORY,
+                    variantSelectorsFactory = variantSelectorsFactory,
+                    name = name,
+                    containingClass = containingClass,
+                    typeParameterList = TypeParameterList.NONE,
+                    returnType = containingClass.type(),
+                    parameterItemsFactory = { emptyList() },
+                    throwsTypes = emptyList(),
+                    callableBodyFactory = CallableBody.UNAVAILABLE_FACTORY,
+                    // This is not an implicit constructor as it was not created by the compiler.
+                    implicitConstructor = false,
+                )
+            return ctorItem
+        }
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
new file mode 100644
index 000000000..0e0da4166
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultFieldItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    name: String,
+    containingClass: ClassItem,
+    private var type: TypeItem,
+    private val isEnumConstant: Boolean,
+    override val fieldValue: FieldValue?,
+) :
+    DefaultMemberItem(
+        codebase = codebase,
+        fileLocation = fileLocation,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = variantSelectorsFactory,
+        name = name,
+        containingClass = containingClass,
+    ),
+    FieldItem {
+
+    final override var inheritedFrom: ClassItem? = null
+
+    final override fun type(): TypeItem = type
+
+    final override fun setType(type: TypeItem) {
+        this.type = type
+    }
+
+    override fun duplicate(targetContainingClass: ClassItem) =
+        DefaultFieldItem(
+                codebase = codebase,
+                fileLocation = fileLocation,
+                itemLanguage = itemLanguage,
+                variantSelectorsFactory = variantSelectors::duplicate,
+                modifiers = modifiers,
+                documentationFactory = documentation::duplicate,
+                name = name(),
+                containingClass = targetContainingClass,
+                type = type,
+                isEnumConstant = isEnumConstant,
+                fieldValue = fieldValue,
+            )
+            .also { duplicated -> duplicated.inheritedFrom = containingClass() }
+
+    final override fun initialValue(requireConstant: Boolean) =
+        fieldValue?.initialValue(requireConstant)
+
+    final override fun isEnumConstant(): Boolean = isEnumConstant
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItem.kt
new file mode 100644
index 000000000..a4d36402e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItem.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.AbstractItem
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.reporter.FileLocation
+
+/**
+ * Base class that is common to models that do not incorporate their underlying model, if any, into
+ * their [Item] implementations.
+ */
+abstract class DefaultItem(
+    override val codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+) :
+    AbstractItem(
+        fileLocation,
+        itemLanguage,
+        modifiers,
+        documentationFactory,
+        variantSelectorsFactory,
+    ) {}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
new file mode 100644
index 000000000..cca274519
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.CallableBody
+import com.android.tools.metalava.model.CallableBodyFactory
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
+import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.reporter.FileLocation
+
+/**
+ * A lambda that when passed the [Item] will return the public name, or null if there is not one.
+ */
+typealias PublicNameProvider = (Item) -> String?
+
+/** A factory for creating [Item] instances suitable for use by many models. */
+class DefaultItemFactory(
+    /** The [DefaultCodebase] to which returned [Item]s will belong. */
+    private val codebase: DefaultCodebase,
+
+    /** The default language for [Item]s created by this. */
+    private val defaultItemLanguage: ItemLanguage,
+
+    /** The default [ApiVariantSelectorsFactory] for [Item]s created by this. */
+    private val defaultVariantSelectorsFactory: ApiVariantSelectorsFactory,
+) {
+    /** Create a [PackageItem]. */
+    fun createPackageItem(
+        fileLocation: FileLocation,
+        modifiers: BaseModifierList,
+        documentationFactory: ItemDocumentationFactory,
+        qualifiedName: String,
+        containingPackage: PackageItem?,
+        overviewDocumentation: ResourceFile?,
+    ): DefaultPackageItem {
+        return DefaultPackageItem(
+            codebase,
+            fileLocation,
+            defaultItemLanguage,
+            modifiers,
+            documentationFactory,
+            defaultVariantSelectorsFactory,
+            qualifiedName,
+            containingPackage,
+            overviewDocumentation,
+        )
+    }
+
+    /** Create a [ConstructorItem]. */
+    fun createClassItem(
+        fileLocation: FileLocation,
+        itemLanguage: ItemLanguage = defaultItemLanguage,
+        modifiers: BaseModifierList,
+        documentationFactory: ItemDocumentationFactory = ItemDocumentation.NONE_FACTORY,
+        source: SourceFile? = null,
+        classKind: ClassKind,
+        containingClass: ClassItem?,
+        containingPackage: PackageItem,
+        qualifiedName: String = "",
+        typeParameterList: TypeParameterList,
+        origin: ClassOrigin,
+        superClassType: ClassTypeItem?,
+        interfaceTypes: List<ClassTypeItem>,
+    ) =
+        DefaultClassItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            modifiers,
+            documentationFactory,
+            defaultVariantSelectorsFactory,
+            source,
+            classKind,
+            containingClass,
+            containingPackage,
+            qualifiedName,
+            typeParameterList,
+            origin,
+            superClassType,
+            interfaceTypes,
+        )
+
+    /** Create a [ConstructorItem]. */
+    fun createConstructorItem(
+        fileLocation: FileLocation,
+        itemLanguage: ItemLanguage = defaultItemLanguage,
+        modifiers: BaseModifierList,
+        documentationFactory: ItemDocumentationFactory,
+        name: String,
+        containingClass: ClassItem,
+        typeParameterList: TypeParameterList,
+        returnType: ClassTypeItem,
+        parameterItemsFactory: ParameterItemsFactory,
+        throwsTypes: List<ExceptionTypeItem>,
+        callableBodyFactory: CallableBodyFactory = CallableBody.UNAVAILABLE_FACTORY,
+        implicitConstructor: Boolean,
+    ): ConstructorItem =
+        DefaultConstructorItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            modifiers,
+            documentationFactory,
+            defaultVariantSelectorsFactory,
+            name,
+            containingClass,
+            typeParameterList,
+            returnType,
+            parameterItemsFactory,
+            throwsTypes,
+            callableBodyFactory,
+            implicitConstructor,
+        )
+
+    /** Create a [FieldItem]. */
+    fun createFieldItem(
+        fileLocation: FileLocation,
+        itemLanguage: ItemLanguage = defaultItemLanguage,
+        modifiers: BaseModifierList,
+        documentationFactory: ItemDocumentationFactory,
+        name: String,
+        containingClass: ClassItem,
+        type: TypeItem,
+        isEnumConstant: Boolean,
+        fieldValue: FieldValue?,
+    ): FieldItem =
+        DefaultFieldItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            defaultVariantSelectorsFactory,
+            modifiers,
+            documentationFactory,
+            name,
+            containingClass,
+            type,
+            isEnumConstant,
+            fieldValue,
+        )
+
+    /** Create a [MethodItem]. */
+    fun createMethodItem(
+        fileLocation: FileLocation,
+        itemLanguage: ItemLanguage = defaultItemLanguage,
+        modifiers: BaseModifierList,
+        documentationFactory: ItemDocumentationFactory,
+        name: String,
+        containingClass: ClassItem,
+        typeParameterList: TypeParameterList,
+        returnType: TypeItem,
+        parameterItemsFactory: ParameterItemsFactory,
+        throwsTypes: List<ExceptionTypeItem>,
+        callableBodyFactory: CallableBodyFactory = CallableBody.UNAVAILABLE_FACTORY,
+        annotationDefault: String,
+    ): MethodItem =
+        DefaultMethodItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            modifiers,
+            documentationFactory,
+            defaultVariantSelectorsFactory,
+            name,
+            containingClass,
+            typeParameterList,
+            returnType,
+            parameterItemsFactory,
+            throwsTypes,
+            callableBodyFactory,
+            annotationDefault,
+        )
+
+    /** Create a [ParameterItem]. */
+    fun createParameterItem(
+        fileLocation: FileLocation,
+        itemLanguage: ItemLanguage = defaultItemLanguage,
+        modifiers: BaseModifierList,
+        name: String,
+        publicNameProvider: PublicNameProvider,
+        containingCallable: CallableItem,
+        parameterIndex: Int,
+        type: TypeItem,
+        defaultValueFactory: DefaultValueFactory,
+    ): ParameterItem =
+        DefaultParameterItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            modifiers,
+            name,
+            publicNameProvider,
+            containingCallable,
+            parameterIndex,
+            type,
+            defaultValueFactory,
+        )
+
+    /** Create a [PropertyItem]. */
+    fun createPropertyItem(
+        fileLocation: FileLocation,
+        itemLanguage: ItemLanguage = defaultItemLanguage,
+        documentationFactory: ItemDocumentationFactory = ItemDocumentation.NONE_FACTORY,
+        modifiers: BaseModifierList,
+        name: String,
+        containingClass: ClassItem,
+        type: TypeItem,
+    ): PropertyItem =
+        DefaultPropertyItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            documentationFactory,
+            defaultVariantSelectorsFactory,
+            modifiers,
+            name,
+            containingClass,
+            type,
+        )
+
+    /**
+     * Create a [DefaultTypeParameterItem].
+     *
+     * This returns [DefaultTypeParameterItem] because access is needed to its
+     * [DefaultTypeParameterItem.bounds] after creation as full creation is a two stage process due
+     * to cyclical dependencies between [DefaultTypeParameterItem] in a type parameters list.
+     *
+     * TODO(b/351410134): Provide support in this factory for two stage initialization.
+     */
+    fun createTypeParameterItem(
+        modifiers: BaseModifierList,
+        name: String,
+        isReified: Boolean,
+    ) =
+        DefaultTypeParameterItem(
+            codebase,
+            defaultItemLanguage,
+            modifiers,
+            name,
+            isReified,
+        )
+}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMemberItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
similarity index 51%
rename from metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMemberItem.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
index 6d237fe8c..0566a1cfe 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMemberItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,37 +14,37 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava.model.psi
+package com.android.tools.metalava.model.item
 
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.reporter.FileLocation
-import com.intellij.psi.PsiJvmMember
 
-abstract class PsiMemberItem
-internal constructor(
-    codebase: PsiBasedCodebase,
-    element: PsiJvmMember,
-    fileLocation: FileLocation = PsiFileLocation(element),
-    modifiers: DefaultModifierList,
-    documentation: String,
-    internal val containingClass: ClassItem,
-    internal val name: String,
+abstract class DefaultMemberItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    private val name: String,
+    private val containingClass: ClassItem,
 ) :
-    PsiItem(
+    DefaultItem(
         codebase = codebase,
-        modifiers = modifiers,
-        documentation = documentation,
-        element = element,
         fileLocation = fileLocation,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = variantSelectorsFactory,
     ),
     MemberItem {
 
-    init {
-        emit = !modifiers.isExpect()
-    }
-
     final override fun name() = name
 
     final override fun containingClass() = containingClass
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
new file mode 100644
index 000000000..e94945cb0
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.CallableBodyFactory
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultMethodItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    name: String,
+    containingClass: ClassItem,
+    typeParameterList: TypeParameterList,
+    returnType: TypeItem,
+    parameterItemsFactory: ParameterItemsFactory,
+    throwsTypes: List<ExceptionTypeItem>,
+    callableBodyFactory: CallableBodyFactory,
+    private val annotationDefault: String = "",
+) :
+    DefaultCallableItem(
+        codebase,
+        fileLocation,
+        itemLanguage,
+        modifiers,
+        documentationFactory,
+        variantSelectorsFactory,
+        name,
+        containingClass,
+        typeParameterList,
+        returnType,
+        parameterItemsFactory,
+        throwsTypes,
+        callableBodyFactory,
+    ),
+    MethodItem {
+
+    final override var inheritedFrom: ClassItem? = null
+
+    override fun isExtensionMethod(): Boolean = false // java does not support extension methods
+
+    override fun defaultValue() = annotationDefault
+
+    private lateinit var superMethodList: List<MethodItem>
+
+    /**
+     * Super methods for a given method M with containing class C are calculated as follows:
+     * 1) Superclass Search: Traverse the class hierarchy, starting from C's direct superclass, and
+     *    add the first method that matches M's signature to the list.
+     * 2) Interface Supermethod Search: For each direct interface implemented by C, check if it
+     *    contains a method matching M's signature. If found, return that method. If not,
+     *    recursively apply this method to the direct interfaces of the current interface.
+     *
+     * Note: This method's implementation is based on MethodItem.matches method which only checks
+     * that name and parameter list types match. Parameter names, Return types and Throws list types
+     * are not matched
+     */
+    final override fun superMethods(): List<MethodItem> {
+        return if (containingClass().frozen) {
+            if (!::superMethodList.isInitialized) {
+                superMethodList = computeSuperMethods()
+            }
+            superMethodList
+        } else {
+            computeSuperMethods()
+        }
+    }
+
+    @Deprecated("This property should not be accessed directly.")
+    final override var _requiresOverride: Boolean? = null
+
+    override fun duplicate(targetContainingClass: ClassItem): MethodItem {
+        val typeVariableMap = targetContainingClass.mapTypeVariables(containingClass())
+
+        return DefaultMethodItem(
+                codebase = codebase,
+                fileLocation = fileLocation,
+                itemLanguage = itemLanguage,
+                modifiers = modifiers,
+                documentationFactory = documentation::duplicate,
+                variantSelectorsFactory = variantSelectors::duplicate,
+                name = name(),
+                containingClass = targetContainingClass,
+                typeParameterList = typeParameterList,
+                returnType = returnType.convertType(typeVariableMap),
+                parameterItemsFactory = { containingCallable ->
+                    // Duplicate the parameters
+                    parameters.map { it.duplicate(containingCallable, typeVariableMap) }
+                },
+                throwsTypes = throwsTypes,
+                annotationDefault = annotationDefault,
+                callableBodyFactory = body::duplicate,
+            )
+            .also { duplicated ->
+                duplicated.inheritedFrom = containingClass()
+
+                duplicated.updateCopiedMethodState()
+            }
+    }
+
+    /**
+     * Compute the super methods of this method.
+     *
+     * A super method is a method from a super class or super interface that is directly overridden
+     * by this method.
+     */
+    private fun computeSuperMethods(): List<MethodItem> {
+        // Methods that are not overrideable will have no super methods.
+        if (!isOverrideable()) {
+            return emptyList()
+        }
+
+        // TODO(b/321216636): Remove this awful hack.
+        // For some reason `psiMethod.findSuperMethods()` would return an empty list for this
+        // specific method. That is incorrect as it clearly overrides a method in `DrawScope` in the
+        // same package. However, it is unclear what makes this method distinct from any other
+        // method including overloaded methods in the same class that also override methods
+        // in`DrawScope`. Returning a correct non-empty list for that method results in the method
+        // being removed from an API signature file even though the super method is abstract and
+        // this is concrete. That is because AndroidX does not yet set
+        // `add-additional-overrides=yes`. When it does then this hack can be removed.
+        if (
+            containingClass().qualifiedName() ==
+                "androidx.compose.ui.graphics.drawscope.CanvasDrawScope" &&
+                name() == "drawImage" &&
+                toString() ==
+                    "method androidx.compose.ui.graphics.drawscope.CanvasDrawScope.drawImage(androidx.compose.ui.graphics.ImageBitmap, long, long, long, long, float, androidx.compose.ui.graphics.drawscope.DrawStyle, androidx.compose.ui.graphics.ColorFilter, int)"
+        ) {
+            return emptyList()
+        }
+
+        // Ideally, the search for super methods would start from this method's ClassItem.
+        // Unfortunately, due to legacy reasons for methods that were inherited from another
+        // ClassItem it is necessary to start the search from the original ClassItem. That is
+        // because the psi model's implementation behaved this way and the code that is built of top
+        // of superMethods, like the code to determine if overriding methods should be elided from
+        // the API signature file relied on that behavior.
+        val startingClass = inheritedFrom ?: containingClass()
+        return buildSet { appendSuperMethods(this, startingClass) }.toList()
+    }
+
+    /**
+     * Append the super methods of this method from the [cls] hierarchy to the [methods] set.
+     *
+     * @param methods the mutable, order preserving set of super [MethodItem].
+     * @param cls the [ClassItem] whose super class and implemented interfaces will be searched for
+     *   matching methods.
+     */
+    private fun appendSuperMethods(methods: MutableSet<MethodItem>, cls: ClassItem) {
+        // Method from SuperClass or its ancestors
+        cls.superClass()?.let { superClass ->
+            // Search for a matching method in the super class.
+            val superMethod = superClass.findMethod(this)
+            if (superMethod == null) {
+                // No matching method was found so continue searching in the super class.
+                appendSuperMethods(methods, superClass)
+            } else {
+                // Matching does not check modifiers match so make sure that the matched method is
+                // overrideable.
+                if (superMethod.isOverrideable()) {
+                    methods.add(superMethod)
+                }
+            }
+        }
+
+        // Methods implemented from direct interfaces or its ancestors
+        appendSuperMethodsFromInterfaces(methods, cls)
+    }
+
+    /**
+     * Append the super methods of this method from the interface hierarchy of [cls] to the
+     * [methods] set.
+     *
+     * @param methods the mutable, order preserving set of super [MethodItem].
+     * @param cls the [ClassItem] whose implemented interfaces will be searched for matching
+     *   methods.
+     */
+    private fun appendSuperMethodsFromInterfaces(methods: MutableSet<MethodItem>, cls: ClassItem) {
+        for (itf in cls.interfaceTypes()) {
+            val itfClass = itf.asClass() ?: continue
+
+            // Find the method in the interface.
+            itfClass.findMethod(this)?.let { superMethod ->
+                // A matching method was found so add it to the super methods if it is overrideable.
+                if (superMethod.isOverrideable()) {
+                    methods.add(superMethod)
+                }
+            }
+            // A method could not be found in this interface so search its interfaces.
+            ?: appendSuperMethodsFromInterfaces(methods, itfClass)
+        }
+    }
+
+    /**
+     * Update the state of a [MethodItem] that has been copied from one [ClassItem] to another.
+     *
+     * This will update the [MethodItem] on which it is called to ensure that it is consistent with
+     * the [ClassItem] to which it now belongs. Called from the implementations of
+     * [MethodItem.duplicate].
+     */
+    protected fun updateCopiedMethodState() {
+        if (modifiers.isDefault() && !containingClass().isInterface()) {
+            mutateModifiers { setDefault(false) }
+        }
+    }
+}
+
+/**
+ * Check to see if the method is overrideable.
+ *
+ * Private and static methods cannot be overridden.
+ */
+private fun MethodItem.isOverrideable(): Boolean = !modifiers.isPrivate() && !modifiers.isStatic()
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
new file mode 100644
index 000000000..2833fb0f6
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultPackageItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    private val qualifiedName: String,
+    val containingPackage: PackageItem?,
+    override val overviewDocumentation: ResourceFile?,
+) :
+    DefaultItem(
+        codebase = codebase,
+        fileLocation = fileLocation,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = documentationFactory,
+        variantSelectorsFactory = variantSelectorsFactory,
+    ),
+    PackageItem {
+
+    init {
+        // Newly created package's always have `emit = false` as they should only be emitted if they
+        // have at least one class that has `emit = true`. That will be updated, if necessary, when
+        // adding a class to the package.
+        emit = false
+    }
+
+    private val topClasses = mutableListOf<ClassItem>()
+
+    final override fun qualifiedName(): String = qualifiedName
+
+    final override fun topLevelClasses(): List<ClassItem> =
+        // Return a copy to avoid a ConcurrentModificationException.
+        topClasses.toList()
+
+    // N.A. a package cannot be contained in a class
+    override fun containingClass(): ClassItem? = null
+
+    final override fun containingPackage(): PackageItem? {
+        return containingPackage
+    }
+
+    fun addTopClass(classItem: ClassItem) {
+        topClasses.add(classItem)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
new file mode 100644
index 000000000..d4a447653
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterBindings
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultParameterItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    private val name: String,
+    protected val publicNameProvider: PublicNameProvider,
+    private val containingCallable: CallableItem,
+    override val parameterIndex: Int,
+    private var type: TypeItem,
+    defaultValueFactory: DefaultValueFactory,
+) :
+    DefaultItem(
+        codebase = codebase,
+        fileLocation = fileLocation,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = ItemDocumentation.NONE_FACTORY,
+        variantSelectorsFactory = ApiVariantSelectors.IMMUTABLE_FACTORY,
+    ),
+    ParameterItem {
+
+    init {
+        // Set the varargs modifier to true if the type is a varargs.
+        type.let { if (it is ArrayTypeItem && it.isVarargs) mutateModifiers { setVarArg(true) } }
+    }
+
+    /**
+     * Create the [DefaultValue] during initialization of this parameter to allow it to contain an
+     * immutable reference to this object.
+     */
+    final override val defaultValue = defaultValueFactory(this)
+
+    final override fun name(): String = name
+
+    final override fun publicName(): String? = publicNameProvider(this)
+
+    final override fun containingCallable(): CallableItem = containingCallable
+
+    final override fun type(): TypeItem = type
+
+    final override fun setType(type: TypeItem) {
+        this.type = type
+    }
+
+    final override fun hasDefaultValue(): Boolean = defaultValue.hasDefaultValue()
+
+    final override fun isDefaultValueKnown(): Boolean = defaultValue.isDefaultValueKnown()
+
+    final override fun defaultValueAsString(): String? = defaultValue.value()
+
+    override fun duplicate(
+        containingCallable: CallableItem,
+        typeVariableMap: TypeParameterBindings,
+    ) =
+        DefaultParameterItem(
+            codebase,
+            fileLocation,
+            itemLanguage,
+            modifiers,
+            name(),
+            publicNameProvider,
+            containingCallable,
+            parameterIndex,
+            type().convertType(typeVariableMap),
+            defaultValue::duplicate,
+        )
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
new file mode 100644
index 000000000..0f626bdff
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.reporter.FileLocation
+
+open class DefaultPropertyItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+    modifiers: BaseModifierList,
+    name: String,
+    containingClass: ClassItem,
+    private var type: TypeItem,
+) :
+    DefaultMemberItem(
+        codebase,
+        fileLocation,
+        itemLanguage,
+        modifiers,
+        documentationFactory,
+        variantSelectorsFactory,
+        name,
+        containingClass,
+    ),
+    PropertyItem {
+
+    final override fun type(): TypeItem = type
+
+    final override fun setType(type: TypeItem) {
+        this.type = type
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
new file mode 100644
index 000000000..7cd2fdaaa
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.BoundsTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.TypeParameterItem
+import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.type.DefaultTypeModifiers
+import com.android.tools.metalava.model.type.DefaultVariableTypeItem
+import com.android.tools.metalava.reporter.FileLocation
+
+/** A [TypeParameterItem] implementation suitable for use by multiple models. */
+open class DefaultTypeParameterItem(
+    codebase: Codebase,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    private val name: String,
+    private val isReified: Boolean,
+) :
+    DefaultItem(
+        codebase = codebase,
+        fileLocation = FileLocation.UNKNOWN,
+        itemLanguage = itemLanguage,
+        modifiers = modifiers,
+        documentationFactory = ItemDocumentation.NONE_FACTORY,
+        variantSelectorsFactory = ApiVariantSelectors.IMMUTABLE_FACTORY,
+    ),
+    TypeParameterItem {
+
+    final override fun name() = name
+
+    /** Must only be used by [type] to cache its result. */
+    private lateinit var variableTypeItem: VariableTypeItem
+
+    override fun type(): VariableTypeItem {
+        if (!::variableTypeItem.isInitialized) {
+            variableTypeItem = createVariableTypeItem()
+        }
+        return variableTypeItem
+    }
+
+    /** Create a [VariableTypeItem] for this [TypeParameterItem]. */
+    protected open fun createVariableTypeItem(): VariableTypeItem =
+        DefaultVariableTypeItem(DefaultTypeModifiers.emptyUndefinedModifiers, this)
+
+    lateinit var bounds: List<BoundsTypeItem>
+
+    final override fun typeBounds(): List<BoundsTypeItem> = bounds
+
+    final override fun isReified(): Boolean = isReified
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultValue.kt
new file mode 100644
index 000000000..aea824c63
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultValue.kt
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.FixedDefaultValue
+import com.android.tools.metalava.model.ParameterItem
+
+/**
+ * A lamda that given a [ParameterItem] will create a [DefaultValue] for it.
+ *
+ * This is called from within the constructor of the [ParameterItem] and should not access any
+ * properties of [ParameterItem] as they may not have been initialized. This should just store a
+ * reference for later use.
+ */
+typealias DefaultValueFactory = (ParameterItem) -> DefaultValue
+
+/**
+ * Represents a parameter's default value.
+ *
+ * TODO: Investigate this abstraction to see if it matches what we need. It is a little confusing as
+ *   [hasDefaultValue] and [isDefaultValueKnown] seem like they should be different but are
+ *   implemented in Psi and Turbine to be identical.
+ */
+interface DefaultValue {
+
+    /** A [DefaultValue] to use for a parameter that has no default value. */
+    @Suppress("ConvertObjectToDataObject") // Requires language level 1.9
+    object NONE : DefaultValue {
+        override fun hasDefaultValue() = false
+
+        override fun isDefaultValueKnown() = false
+
+        override fun value() = error("cannot call on NONE DefaultValue")
+
+        /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
+        override fun duplicate(parameter: ParameterItem) = this
+
+        /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
+        override fun snapshot(parameter: ParameterItem) = this
+
+        override fun toString() = "NONE"
+    }
+
+    /**
+     * A [DefaultValue] to use for a parameter that has a default value but its actual value is not
+     * known.
+     */
+    @Suppress("ConvertObjectToDataObject") // Requires language level 1.9
+    object UNKNOWN : DefaultValue {
+        override fun hasDefaultValue() = true
+
+        override fun isDefaultValueKnown() = false
+
+        override fun value() = error("cannot call on UNKNOWN DefaultValue")
+
+        /** This is suitable for use by [parameter] as it has no model or codebase dependencies. */
+        override fun duplicate(parameter: ParameterItem) = this
+
+        /** This is suitable for use in the snapshot as it has no model or codebase dependencies. */
+        override fun snapshot(parameter: ParameterItem) = this
+
+        override fun toString() = "UNKNOWN"
+    }
+
+    companion object {
+        /** Get a [DefaultValue] wrapper around a fixed [String] value. */
+        fun fixedDefaultValue(value: String?): DefaultValue {
+            return FixedDefaultValue(value)
+        }
+    }
+
+    /**
+     * Returns whether this parameter has a default value. In Kotlin, this is supported directly; in
+     * Java, it's supported via a special annotation, {@literal @DefaultValue("source"). This does
+     * not necessarily imply that the default value is accessible, and we know the body of the
+     * default value.
+     *
+     * @see isDefaultValueKnown
+     */
+    fun hasDefaultValue(): Boolean
+
+    /**
+     * Returns whether this parameter has an accessible default value that we plan to keep. This is
+     * a superset of [hasDefaultValue] - if we are not writing the default values to the signature
+     * file, then the default value might not be available, even though the parameter does have a
+     * default.
+     *
+     * @see hasDefaultValue
+     */
+    fun isDefaultValueKnown(): Boolean
+
+    /**
+     * Returns the default value.
+     *
+     * **This method should only be called if [isDefaultValueKnown] returned true!** (This is
+     * necessary since the null return value is a valid default value separate from no default value
+     * specified.)
+     *
+     * The default value is the source string literal representation of the value, e.g. strings
+     * would be surrounded by quotes, Booleans are the strings "true" or "false", and so on.
+     */
+    fun value(): String?
+
+    /**
+     * Return a duplicate of this instance to use by [parameter] which will be in the same type of
+     * [Codebase] as this.
+     */
+    fun duplicate(parameter: ParameterItem): DefaultValue
+
+    /**
+     * Creates a snapshot of this.
+     *
+     * The default implementation assumes that this is either dependent on a model or the codebase
+     * and so creates a new [DefaultValue] based on the functions above.
+     */
+    fun snapshot(parameter: ParameterItem) =
+        when {
+            !hasDefaultValue() -> NONE
+            !isDefaultValueKnown() -> UNKNOWN
+            else -> fixedDefaultValue(value())
+        }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/FieldValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/FieldValue.kt
new file mode 100644
index 000000000..cd7b49ec5
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/FieldValue.kt
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.FixedFieldValue
+
+interface FieldValue {
+    fun initialValue(requireConstant: Boolean): Any?
+
+    /**
+     * Creates a snapshot of this.
+     *
+     * The default implementation assumes that this is either dependent on a model or the codebase
+     * and so creates a new [FixedFieldValue] based on the functions above.
+     */
+    fun snapshot(): FieldValue = FixedFieldValue(initialValue(true), initialValue(false))
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageDocs.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageDocs.kt
new file mode 100644
index 000000000..7bb283e59
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageDocs.kt
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.reporter.FileLocation
+
+/** Set of [PackageDoc] for every documented package defined in the source. */
+class PackageDocs(
+    private val packages: Map<String, PackageDoc>,
+) {
+    /** The set of package names. */
+    val packageNames: Collection<String> = packages.keys
+
+    operator fun get(packageName: String): PackageDoc {
+        return packages[packageName] ?: PackageDoc.EMPTY
+    }
+
+    companion object {
+        val EMPTY: PackageDocs = PackageDocs(emptyMap())
+    }
+}
+
+/** Package specific documentation. */
+interface PackageDoc {
+    val fileLocation: FileLocation
+    val modifiers: BaseModifierList?
+
+    /**
+     * Factory for creating an [ItemDocumentation] instance containing the package level document.
+     *
+     * This factory will be invoked when creating the associated [PackageItem].
+     *
+     * If specified this is used for [PackageItem.documentation].
+     */
+    val commentFactory: ItemDocumentationFactory?
+
+    /**
+     * The `overview.html` file.
+     *
+     * If specified this is used for [PackageItem.overviewDocumentation].
+     */
+    val overview: ResourceFile?
+
+    companion object {
+        val EMPTY =
+            object : PackageDoc {
+                override val fileLocation: FileLocation
+                    get() = FileLocation.UNKNOWN
+
+                override val modifiers: BaseModifierList?
+                    get() = null
+
+                override val commentFactory
+                    get() = null
+
+                override val overview
+                    get() = null
+            }
+    }
+}
+
+/** Mutable package specific documentation for use in [gatherPackageJavadoc]. */
+data class MutablePackageDoc(
+    val qualifiedName: String,
+    override var fileLocation: FileLocation = FileLocation.UNKNOWN,
+    override var modifiers: BaseModifierList? = null,
+    override var commentFactory: ItemDocumentationFactory? = null,
+    override var overview: ResourceFile? = null,
+) : PackageDoc
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt
new file mode 100644
index 000000000..5db632df3
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/PackageTracker.kt
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.PackageList
+import com.android.tools.metalava.model.VisibilityLevel
+import java.util.HashMap
+
+private const val PACKAGE_ESTIMATE = 500
+
+typealias PackageItemFactory = (String, PackageDoc, PackageItem?) -> DefaultPackageItem
+
+class PackageTracker(private val packageItemFactory: PackageItemFactory) {
+    /** Map from package name to [DefaultPackageItem] of all packages in this. */
+    private val packagesByName = HashMap<String, DefaultPackageItem>(PACKAGE_ESTIMATE)
+
+    val size
+        get() = packagesByName.size
+
+    fun getPackages(): PackageList {
+        val list = packagesByName.values.toMutableList()
+        list.sortWith(PackageItem.comparator)
+        return PackageList(list)
+    }
+
+    fun findPackage(pkgName: String): DefaultPackageItem? {
+        return packagesByName[pkgName]
+    }
+
+    /**
+     * Searches for the package with [packageName] in this tracker and if not found creates the
+     * corresponding [DefaultPackageItem], supply additional information from [packageDocs] and adds
+     * the newly created [DefaultPackageItem] to this tracker.
+     *
+     * If the [DefaultPackageItem] exists and [PackageDocs] contains [PackageDoc.modifiers] for the
+     * package then make sure that the existing [DefaultPackageItem] has the same
+     * [DefaultPackageItem.modifiers], if not throw an exception.
+     *
+     * @param packageName the name of the package to create.
+     * @param packageDocs provides additional information needed for creating a package.
+     * @return the [DefaultPackageItem] that was found or created.
+     */
+    fun findOrCreatePackage(
+        packageName: String,
+        packageDocs: PackageDocs = PackageDocs.EMPTY,
+    ): DefaultPackageItem {
+        // Get the `PackageDoc`, if any, to use for creating this package.
+        val packageDoc = packageDocs[packageName]
+
+        // Check to see if the package already exists, if it does then return it.
+        findPackage(packageName)?.let { existing ->
+            // If the same package showed up multiple times, make sure they have the same modifiers.
+            // (Packages can't have public/private/etc., but they can have annotations, which are
+            // part of ModifierList.)
+            val modifiers = packageDoc.modifiers
+            if (modifiers != null && modifiers != existing.modifiers) {
+                error(
+                    String.format(
+                        "Contradicting declaration of package %s." +
+                            " Previously seen with modifiers \"%s\", but now with \"%s\"",
+                        packageName,
+                        existing.modifiers,
+                        modifiers
+                    ),
+                )
+            }
+
+            return existing
+        }
+
+        // Unless this is the root package, it has a containing package so get that before creating
+        // this package, so it can be passed into the `packageItemFactory`.
+        val containingPackageName = getContainingPackageName(packageName)
+        val containingPackage =
+            if (containingPackageName == null) null
+            else findOrCreatePackage(containingPackageName, packageDocs)
+
+        val packageItem = packageItemFactory(packageName, packageDoc, containingPackage)
+
+        // The packageItemFactory may provide its own modifiers so check to make sure that they are
+        // public.
+        if (packageItem.modifiers.getVisibilityLevel() != VisibilityLevel.PUBLIC)
+            error("Package $packageItem is not public")
+
+        addPackage(packageItem)
+
+        return packageItem
+    }
+
+    /**
+     * Gets the name of [packageName]'s containing package or `null` if [packageName] is `""`, i.e.
+     * the root package.
+     */
+    private fun getContainingPackageName(packageName: String): String? =
+        if (packageName == "") null
+        else
+            packageName.lastIndexOf('.').let { index ->
+                if (index == -1) {
+                    ""
+                } else {
+                    packageName.substring(0, index)
+                }
+            }
+
+    /** Add the package to this. */
+    fun addPackage(packageItem: DefaultPackageItem) {
+        packagesByName[packageItem.qualifiedName()] = packageItem
+    }
+
+    /**
+     * Create and track [PackageItem]s for every entry in [packageDocs] and make sure there is a
+     * root package.
+     */
+    fun createInitialPackages(packageDocs: PackageDocs) {
+        // Create packages for all the documentation packages.
+        for (packageName in packageDocs.packageNames) {
+            findOrCreatePackage(packageName, packageDocs)
+        }
+
+        // Make sure that there is a root package.
+        findOrCreatePackage("", packageDocs)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/ResourceFile.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/ResourceFile.kt
new file mode 100644
index 000000000..32cb755e0
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/ResourceFile.kt
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import java.io.File
+
+/**
+ * A resource file is one that is supplied on input to Metalava and copied through to the stubs
+ * unchanged.
+ *
+ * e.g. This is used for copying the `overview.html` file when generate documentation stubs.
+ */
+class ResourceFile(private val file: File) {
+    val content by lazy(LazyThreadSafetyMode.NONE) { file.readText() }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
new file mode 100644
index 000000000..cb9f393a0
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.snapshot
+
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DefaultTypeParameterList
+import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.ItemVisitor
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.ModifierList
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterItem
+import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.TypeParameterListAndFactory
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.item.DefaultCodebaseAssembler
+import com.android.tools.metalava.model.item.DefaultItemFactory
+import com.android.tools.metalava.model.item.DefaultPackageItem
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
+import com.android.tools.metalava.model.item.MutablePackageDoc
+import com.android.tools.metalava.model.item.PackageDoc
+import com.android.tools.metalava.model.item.PackageDocs
+
+/** Stack of [SnapshotTypeItemFactory] */
+internal typealias TypeItemFactoryStack = ArrayList<SnapshotTypeItemFactory>
+
+/** Push new [SnapshotTypeItemFactory] onto the top of the stack. */
+internal fun TypeItemFactoryStack.push(factory: SnapshotTypeItemFactory) {
+    add(factory)
+}
+
+/** Pop [SnapshotTypeItemFactory] from the top of the stack. */
+internal fun TypeItemFactoryStack.pop() {
+    removeLast()
+}
+
+/** Constructs a [Codebase] by taking a snapshot of another [Codebase] that is being visited. */
+class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(), DelegatedVisitor {
+
+    /**
+     * The [Codebase] that is under construction.
+     *
+     * Initialized in [visitCodebase].
+     */
+    private lateinit var codebase: DefaultCodebase
+
+    override val itemFactory: DefaultItemFactory by
+        lazy(LazyThreadSafetyMode.NONE) {
+            DefaultItemFactory(
+                codebase,
+                // Snapshots currently only support java.
+                defaultItemLanguage = ItemLanguage.JAVA,
+                // Snapshots have already been separated by API surface variants, so they can use
+                // the same immutable ApiVariantSelectors.
+                ApiVariantSelectors.IMMUTABLE_FACTORY,
+            )
+        }
+
+    /**
+     * The original [Codebase] that is being snapshotted construction.
+     *
+     * Initialized in [visitCodebase].
+     */
+    private lateinit var originalCodebase: Codebase
+
+    private val globalTypeItemFactory by
+        lazy(LazyThreadSafetyMode.NONE) { SnapshotTypeItemFactory(codebase) }
+
+    /**
+     * Stack of [SnapshotTypeItemFactory] that contain information about the [TypeParameterItem]s
+     * that are in scope and can resolve a type variable reference to the parameter.
+     */
+    private val typeItemFactoryStack = TypeItemFactoryStack()
+
+    /** Get the current [SnapshotTypeItemFactory], i.e. the closest enclosing one. */
+    private val typeItemFactory
+        get() = typeItemFactoryStack.last()
+
+    /**
+     * The current [PackageItem], set in [visitPackage], cleared in [afterVisitPackage], relies on
+     * the [PackageItem]s being visited as a flat list, not a package hierarchy.
+     */
+    private var currentPackage: DefaultPackageItem? = null
+
+    /**
+     * The current [ClassItem], that forms a stack through the [ClassItem.containingClass].
+     *
+     * Set (pushed on the stack) in [visitClass]. Reset (popped off the stack) in [afterVisitClass].
+     */
+    private var currentClass: DefaultClassItem? = null
+
+    /** Take a snapshot of this [ModifierList] for [codebase]. */
+    private fun ModifierList.snapshot() = snapshot(codebase)
+
+    /** General [TypeItem] specific snapshot. */
+    private fun TypeItem.snapshot() = typeItemFactory.getGeneralType(this)
+
+    /** [ClassTypeItem] specific snapshot. */
+    private fun ClassTypeItem.snapshot() = typeItemFactory.getGeneralType(this) as ClassTypeItem
+
+    /**
+     * Snapshots need to preserve class nesting when visiting otherwise [ClassItem.containingClass]
+     * will not be initialized correctly.
+     */
+    override val requiresClassNesting: Boolean
+        get() = true
+
+    override fun visitCodebase(codebase: Codebase) {
+        this.originalCodebase = codebase
+        val newCodebase =
+            DefaultCodebase(
+                location = codebase.location,
+                description = "snapshot of ${codebase.description}",
+                preFiltered = true,
+                annotationManager = codebase.annotationManager,
+                trustedApi = true,
+                // Supports documentation if the copied codebase does.
+                supportsDocumentation = codebase.supportsDocumentation(),
+                reporter = codebase.reporter,
+                assembler = this,
+            )
+
+        this.codebase = newCodebase
+        typeItemFactoryStack.push(globalTypeItemFactory)
+    }
+
+    override fun afterVisitCodebase(codebase: Codebase) {
+        typeItemFactoryStack.pop()
+    }
+
+    /**
+     * Construct a [PackageDocs] that contains a [PackageDoc] that in turn contains information
+     * extracted from [packageItem] that can be used to create a new [PackageItem] that is a
+     * snapshot of [packageItem].
+     */
+    private fun packageDocsForPackageItem(packageItem: PackageItem) =
+        MutablePackageDoc(
+                qualifiedName = packageItem.qualifiedName(),
+                fileLocation = packageItem.fileLocation,
+                modifiers = packageItem.modifiers.snapshot(),
+                commentFactory = packageItem.documentation::snapshot,
+                overview = packageItem.overviewDocumentation,
+            )
+            .let { PackageDocs(mapOf(it.qualifiedName to it)) }
+
+    override fun visitPackage(pkg: PackageItem) {
+        // Get a PackageDocs that contains a PackageDoc that contains information extracted from the
+        // PackageItem being visited. This is needed to ensure that the findOrCreatePackage(...)
+        // call below will use the correct information when creating the package. As only a single
+        // PackageDoc is provided for this package it means that if findOrCreatePackage(...) had to
+        // created a containing package that package would not have a PackageDocs and might be
+        // incorrect. However, that should not be a problem as the packages are visited in order
+        // such that a containing package is visited before any contained packages.
+        val packageDocs = packageDocsForPackageItem(pkg)
+        val packageName = pkg.qualifiedName()
+        val newPackage = codebase.findOrCreatePackage(packageName, packageDocs)
+        currentPackage = newPackage
+    }
+
+    override fun afterVisitPackage(pkg: PackageItem) {
+        currentPackage = null
+    }
+
+    /**
+     * Create a snapshot of this [TypeParameterList] and an associated [SnapshotTypeItemFactory].
+     *
+     * @param description the description to use when failing to resolve a type parameter by name.
+     */
+    private fun TypeParameterList.snapshot(description: String) =
+        if (this == TypeParameterList.NONE) TypeParameterListAndFactory(this, typeItemFactory)
+        else
+            DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+                typeItemFactory,
+                description,
+                this,
+                { typeParameterItem ->
+                    DefaultTypeParameterItem(
+                        codebase = codebase,
+                        itemLanguage = typeParameterItem.itemLanguage,
+                        modifiers = typeParameterItem.modifiers.snapshot(),
+                        name = typeParameterItem.name(),
+                        isReified = typeParameterItem.isReified()
+                    )
+                },
+                // Create, set and return the [BoundsTypeItem] list.
+                { typeItemFactory, typeParameterItem ->
+                    typeParameterItem.typeBounds().map { typeItemFactory.getBoundsType(it) }
+                },
+            )
+
+    /**
+     * Take a snapshot of the documentation.
+     *
+     * If necessary revert the documentation change that accompanied a deprecation change.
+     *
+     * Deprecating an API requires adding an `@Deprecated` annotation and an `@deprecated` Javadoc
+     * tag with text that explains why it is being deprecated and what will replace it. When the
+     * deprecation change is being reverted then this will remove the `@deprecated` tag and its
+     * associated text to avoid warnings when compiling and misleading information being written
+     * into the Javadoc.
+     */
+    private fun snapshotDocumentation(
+        itemToSnapshot: Item,
+        documentedItem: Item,
+    ): ItemDocumentationFactory {
+        // The documentation does not need to be reverted if...
+        if (
+            // the item is not being reverted
+            itemToSnapshot === documentedItem
+            // or if the deprecation status has not changed
+            ||
+                itemToSnapshot.effectivelyDeprecated == documentedItem.effectivelyDeprecated
+                // or if the item was previously deprecated
+                ||
+                itemToSnapshot.effectivelyDeprecated
+        )
+            return documentedItem.documentation::snapshot
+
+        val documentation = documentedItem.documentation
+        return { item -> documentation.snapshot(item).apply { removeDeprecatedSection() } }
+    }
+
+    override fun visitClass(cls: ClassItem) {
+        val classToSnapshot = cls.actualItemToSnapshot
+
+        // Create a TypeParameterList and SnapshotTypeItemFactory for the class.
+        val (typeParameterList, classTypeItemFactory) =
+            classToSnapshot.typeParameterList.snapshot("class ${classToSnapshot.qualifiedName()}")
+
+        // Push on the stack before resolving any types just in case they refer to a type parameter.
+        typeItemFactoryStack.push(classTypeItemFactory)
+
+        // Snapshot the super class type, if any.
+        val snapshotSuperClassType =
+            classToSnapshot.superClassType()?.let { superClassType ->
+                typeItemFactory.getSuperClassType(superClassType)
+            }
+        val snapshotInterfaceTypes =
+            classToSnapshot.interfaceTypes().map { typeItemFactory.getInterfaceType(it) }
+
+        val containingClass = currentClass
+        val containingPackage = currentPackage!!
+        val newClass =
+            itemFactory.createClassItem(
+                fileLocation = classToSnapshot.fileLocation,
+                itemLanguage = classToSnapshot.itemLanguage,
+                modifiers = classToSnapshot.modifiers.snapshot(),
+                documentationFactory = snapshotDocumentation(classToSnapshot, cls),
+                source = cls.sourceFile(),
+                classKind = classToSnapshot.classKind,
+                containingClass = containingClass,
+                containingPackage = containingPackage,
+                qualifiedName = classToSnapshot.qualifiedName(),
+                typeParameterList = typeParameterList,
+                origin = classToSnapshot.origin,
+                superClassType = snapshotSuperClassType,
+                interfaceTypes = snapshotInterfaceTypes,
+            )
+
+        currentClass = newClass
+    }
+
+    override fun afterVisitClass(cls: ClassItem) {
+        currentClass = currentClass?.containingClass() as? DefaultClassItem
+        typeItemFactoryStack.pop()
+    }
+
+    /** Push this [SnapshotTypeItemFactory] in scope before executing [body] and pop afterwards. */
+    private inline fun SnapshotTypeItemFactory.inScope(body: () -> Unit) {
+        typeItemFactoryStack.push(this)
+        body()
+        typeItemFactoryStack.pop()
+    }
+
+    /** Return a factory that will create a snapshot of this list of [ParameterItem]s. */
+    private fun List<ParameterItem>.snapshot(
+        containingCallable: CallableItem,
+        currentCallable: CallableItem
+    ): List<ParameterItem> {
+        return map { parameterItem ->
+            // Retrieve the public name immediately to remove any dependencies on this in the
+            // lambda passed to publicNameProvider.
+            val publicName = parameterItem.publicName()
+
+            // The parameter being snapshot may be from a previously released API, which may not
+            // track parameter names and so may have to auto-generate them. This code tries to avoid
+            // using the auto-generated names if possible. If the `publicName()` of the parameter
+            // being snapshot is not `null` then get its `name()` as that will either be set to the
+            // public name or another developer supplied name. Either way it will not be
+            // auto-generated. However, if its `publicName()` is `null` then its `name()` will be
+            // auto-generated so try and avoid that is possible. Instead, use the name of the
+            // corresponding parameter from `currentCallable` as that is more likely to have a
+            // developer supplied name, although it will be the same as `parameterItem` if
+            // `currentCallable` is not being reverted.
+            val name =
+                if (publicName != null) parameterItem.name()
+                else {
+                    val namedParameter = currentCallable.parameters()[parameterItem.parameterIndex]
+                    namedParameter.name()
+                }
+
+            itemFactory.createParameterItem(
+                fileLocation = parameterItem.fileLocation,
+                itemLanguage = parameterItem.itemLanguage,
+                modifiers = parameterItem.modifiers.snapshot(),
+                name = name,
+                publicNameProvider = { publicName },
+                containingCallable = containingCallable,
+                parameterIndex = parameterItem.parameterIndex,
+                type = parameterItem.type().snapshot(),
+                defaultValueFactory = parameterItem.defaultValue::snapshot,
+            )
+        }
+    }
+
+    override fun visitConstructor(constructor: ConstructorItem) {
+        val constructorToSnapshot = constructor.actualItemToSnapshot
+
+        // Create a TypeParameterList and SnapshotTypeItemFactory for the constructor.
+        val (typeParameterList, constructorTypeItemFactory) =
+            constructorToSnapshot.typeParameterList.snapshot(constructorToSnapshot.describe())
+
+        // Resolve any type parameters used in the constructor's parameter items within the scope of
+        // the constructor's SnapshotTypeItemFactory.
+        constructorTypeItemFactory.inScope {
+            val containingClass = currentClass!!
+            val newConstructor =
+                itemFactory.createConstructorItem(
+                    fileLocation = constructorToSnapshot.fileLocation,
+                    itemLanguage = constructorToSnapshot.itemLanguage,
+                    modifiers = constructorToSnapshot.modifiers.snapshot(),
+                    documentationFactory =
+                        snapshotDocumentation(constructorToSnapshot, constructor),
+                    name = constructorToSnapshot.name(),
+                    containingClass = containingClass,
+                    typeParameterList = typeParameterList,
+                    returnType = constructorToSnapshot.returnType().snapshot(),
+                    parameterItemsFactory = { containingCallable ->
+                        constructorToSnapshot.parameters().snapshot(containingCallable, constructor)
+                    },
+                    throwsTypes =
+                        constructorToSnapshot.throwsTypes().map {
+                            typeItemFactory.getExceptionType(it)
+                        },
+                    callableBodyFactory = constructorToSnapshot.body::snapshot,
+                    implicitConstructor = constructorToSnapshot.isImplicitConstructor(),
+                )
+
+            containingClass.addConstructor(newConstructor)
+        }
+    }
+
+    override fun visitMethod(method: MethodItem) {
+        val methodToSnapshot = method.actualItemToSnapshot
+
+        // Create a TypeParameterList and SnapshotTypeItemFactory for the method.
+        val (typeParameterList, methodTypeItemFactory) =
+            methodToSnapshot.typeParameterList.snapshot(methodToSnapshot.describe())
+
+        // Resolve any type parameters used in the method's parameter items within the scope of
+        // the method's SnapshotTypeItemFactory.
+        methodTypeItemFactory.inScope {
+            val containingClass = currentClass!!
+            val newMethod =
+                itemFactory.createMethodItem(
+                    fileLocation = methodToSnapshot.fileLocation,
+                    itemLanguage = methodToSnapshot.itemLanguage,
+                    modifiers = methodToSnapshot.modifiers.snapshot(),
+                    documentationFactory = snapshotDocumentation(methodToSnapshot, method),
+                    name = methodToSnapshot.name(),
+                    containingClass = containingClass,
+                    typeParameterList = typeParameterList,
+                    returnType = methodToSnapshot.returnType().snapshot(),
+                    parameterItemsFactory = { containingCallable ->
+                        methodToSnapshot.parameters().snapshot(containingCallable, method)
+                    },
+                    throwsTypes =
+                        methodToSnapshot.throwsTypes().map { typeItemFactory.getExceptionType(it) },
+                    callableBodyFactory = methodToSnapshot.body::snapshot,
+                    annotationDefault = methodToSnapshot.defaultValue(),
+                )
+
+            containingClass.addMethod(newMethod)
+        }
+    }
+
+    override fun visitField(field: FieldItem) {
+        val fieldToSnapshot = field.actualItemToSnapshot
+
+        val containingClass = currentClass!!
+        val newField =
+            itemFactory.createFieldItem(
+                fileLocation = fieldToSnapshot.fileLocation,
+                itemLanguage = fieldToSnapshot.itemLanguage,
+                modifiers = fieldToSnapshot.modifiers.snapshot(),
+                documentationFactory = snapshotDocumentation(fieldToSnapshot, field),
+                name = fieldToSnapshot.name(),
+                containingClass = containingClass,
+                type = fieldToSnapshot.type().snapshot(),
+                isEnumConstant = fieldToSnapshot.isEnumConstant(),
+                fieldValue = fieldToSnapshot.fieldValue?.snapshot(),
+            )
+
+        containingClass.addField(newField)
+    }
+
+    override fun visitProperty(property: PropertyItem) {
+        val propertyToSnapshot = property.actualItemToSnapshot
+
+        val containingClass = currentClass!!
+        val newProperty =
+            itemFactory.createPropertyItem(
+                fileLocation = propertyToSnapshot.fileLocation,
+                itemLanguage = propertyToSnapshot.itemLanguage,
+                modifiers = propertyToSnapshot.modifiers.snapshot(),
+                documentationFactory = snapshotDocumentation(propertyToSnapshot, property),
+                name = propertyToSnapshot.name(),
+                containingClass = containingClass,
+                type = propertyToSnapshot.type().snapshot(),
+            )
+
+        containingClass.addProperty(newProperty)
+    }
+
+    /**
+     * Take a snapshot of [qualifiedName].
+     *
+     * TODO(b/353737744): Handle resolving nested classes.
+     */
+    override fun createClassFromUnderlyingModel(qualifiedName: String): ClassItem? {
+        // Resolve the class in the original codebase, if possible.
+        val originalClass = originalCodebase.resolveClass(qualifiedName) ?: return null
+
+        // Take a snapshot of the class, that should add a new class to the snapshot codebase.
+        val visitor = NonFilteringDelegatingVisitor(this)
+        val originalPackage = originalClass.containingPackage()
+
+        // Set up the state for taking a snapshot of a class.
+        typeItemFactoryStack.push(globalTypeItemFactory)
+        visitPackage(originalPackage)
+        originalClass.accept(visitor)
+        afterVisitPackage(originalPackage)
+        typeItemFactoryStack.pop()
+
+        // Find the newly added class.
+        return codebase.findClass(originalClass.qualifiedName())!!
+    }
+
+    companion object {
+        /** Take a snapshot of [codebase]. */
+        fun takeSnapshot(
+            codebase: Codebase,
+            visitorFactory: (DelegatedVisitor) -> ItemVisitor = ::NonEmittableDelegatingVisitor,
+        ): Codebase {
+            // Create a snapshot taker that will construct the snapshot.
+            val taker = CodebaseSnapshotTaker()
+
+            // Wrap it in a visitor and visit the codebase.
+            val visitor = visitorFactory(taker)
+            codebase.accept(visitor)
+
+            // Return the constructed snapshot.
+            return taker.codebase
+        }
+    }
+}
+
+/**
+ * Get the actual item to snapshot, this takes into account whether the item has been reverted.
+ *
+ * The [Showability.revertItem] is only set to a non-null value if changes to this [Item] have been
+ * reverted AND this [Item] existed in the previously released API.
+ *
+ * This casts the [Showability.revertItem] to the same type as this is called upon. That is safe as,
+ * if set to a non-null value the [Showability.revertItem] will always point to an [Item] of the
+ * same type.
+ */
+val <reified T : Item> T.actualItemToSnapshot: T
+    inline get() = (showability.revertItem ?: this) as T
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonEmittableDelegatingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonEmittableDelegatingVisitor.kt
new file mode 100644
index 000000000..9f9f62f9a
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonEmittableDelegatingVisitor.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.snapshot
+
+import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.Item
+
+/**
+ * A [BaseItemVisitor] that will delegate to [delegate] but skip [Item]s whose [Item.emit] property
+ * is `false`.
+ *
+ * Preserves class nesting as required by the [delegate]'s [DelegatedVisitor.requiresClassNesting]
+ * property.
+ */
+class NonEmittableDelegatingVisitor(private val delegate: DelegatedVisitor) :
+    NonFilteringDelegatingVisitor(delegate) {
+
+    override fun skip(item: Item): Boolean {
+        return !item.emit
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
new file mode 100644
index 000000000..84b2aac30
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.snapshot
+
+import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.PropertyItem
+
+/**
+ * A [BaseItemVisitor] that will delegate to [delegate].
+ *
+ * Preserves class nesting as required by the [delegate]'s [DelegatedVisitor.requiresClassNesting]
+ * property.
+ */
+open class NonFilteringDelegatingVisitor(private val delegate: DelegatedVisitor) :
+    BaseItemVisitor(preserveClassNesting = delegate.requiresClassNesting) {
+
+    override fun visitCodebase(codebase: Codebase) {
+        delegate.visitCodebase(codebase)
+    }
+
+    override fun afterVisitCodebase(codebase: Codebase) {
+        delegate.afterVisitCodebase(codebase)
+    }
+
+    override fun visitPackage(pkg: PackageItem) {
+        delegate.visitPackage(pkg)
+    }
+
+    override fun afterVisitPackage(pkg: PackageItem) {
+        delegate.afterVisitPackage(pkg)
+    }
+
+    override fun visitClass(cls: ClassItem) {
+        delegate.visitClass(cls)
+    }
+
+    override fun afterVisitClass(cls: ClassItem) {
+        delegate.afterVisitClass(cls)
+    }
+
+    override fun visit(constructor: ConstructorItem) {
+        delegate.visitConstructor(constructor)
+    }
+
+    override fun visitMethod(method: MethodItem) {
+        delegate.visitMethod(method)
+    }
+
+    override fun visitField(field: FieldItem) {
+        delegate.visitField(field)
+    }
+
+    override fun visitProperty(property: PropertyItem) {
+        delegate.visitProperty(property)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt
new file mode 100644
index 000000000..08fa8a06f
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.snapshot
+
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.LambdaTypeItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeModifiers
+import com.android.tools.metalava.model.TypeParameterScope
+import com.android.tools.metalava.model.TypeTransformer
+import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.type.ContextNullability
+import com.android.tools.metalava.model.type.DefaultArrayTypeItem
+import com.android.tools.metalava.model.type.DefaultClassTypeItem
+import com.android.tools.metalava.model.type.DefaultLambdaTypeItem
+import com.android.tools.metalava.model.type.DefaultPrimitiveTypeItem
+import com.android.tools.metalava.model.type.DefaultTypeItemFactory
+import com.android.tools.metalava.model.type.DefaultTypeModifiers
+import com.android.tools.metalava.model.type.DefaultVariableTypeItem
+import com.android.tools.metalava.model.type.DefaultWildcardTypeItem
+
+/**
+ * A [DefaultTypeItemFactory] whose underlying type is another model's [TypeItem] that this will
+ * snapshot.
+ *
+ * TODO: Optimize by reusing them where possible as they are immutable.
+ */
+internal class SnapshotTypeItemFactory(
+    private val codebase: Codebase,
+    typeParameterScope: TypeParameterScope = TypeParameterScope.empty,
+) : DefaultTypeItemFactory<TypeItem, SnapshotTypeItemFactory>(typeParameterScope), TypeTransformer {
+
+    override fun self() = this
+
+    override fun createNestedFactory(scope: TypeParameterScope) =
+        SnapshotTypeItemFactory(codebase, scope)
+
+    override fun getType(
+        underlyingType: TypeItem,
+        contextNullability: ContextNullability,
+        isVarArg: Boolean
+    ) = underlyingType.transform(this)
+
+    /**
+     * Take a snapshot of the [TypeModifiers].
+     *
+     * Only the [TypeModifiers.annotations] is model and [Codebase] dependent. All the other parts
+     * are model independent with no connection to a specific [Codebase]. So, this is reused as is
+     * if there are no [TypeModifiers.annotations].
+     */
+    private fun TypeModifiers.snapshot() =
+        if (annotations.isEmpty()) {
+            this
+        } else {
+            DefaultTypeModifiers(
+                annotations.map { it.snapshot(codebase) },
+                nullability,
+            )
+        }
+
+    override fun transform(typeItem: ArrayTypeItem) =
+        DefaultArrayTypeItem(
+            typeItem.modifiers.snapshot(),
+            typeItem.componentType.transform(this),
+            typeItem.isVarargs,
+        )
+
+    override fun transform(typeItem: ClassTypeItem) =
+        DefaultClassTypeItem(
+            codebase,
+            typeItem.modifiers.snapshot(),
+            typeItem.qualifiedName,
+            typeItem.arguments.map { it.transform(this) },
+            typeItem.outerClassType?.transform(this),
+        )
+
+    override fun transform(typeItem: LambdaTypeItem) =
+        DefaultLambdaTypeItem(
+            codebase,
+            typeItem.modifiers.snapshot(),
+            typeItem.qualifiedName,
+            typeItem.arguments.map { it.transform(this) },
+            typeItem.outerClassType?.transform(this),
+            typeItem.isSuspend,
+            typeItem.receiverType?.transform(this),
+            typeItem.parameterTypes.map { it.transform(this) },
+            typeItem.returnType.transform(this),
+        )
+
+    override fun transform(typeItem: PrimitiveTypeItem) =
+        DefaultPrimitiveTypeItem(typeItem.modifiers.snapshot(), typeItem.kind)
+
+    override fun transform(typeItem: VariableTypeItem) =
+        DefaultVariableTypeItem(
+            typeItem.modifiers.snapshot(),
+            typeParameterScope.getTypeParameter(typeItem.name),
+        )
+
+    override fun transform(typeItem: WildcardTypeItem) =
+        DefaultWildcardTypeItem(
+            typeItem.modifiers.snapshot(),
+            typeItem.extendsBound?.transform(this),
+            typeItem.superBound?.transform(this),
+        )
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultArrayTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultArrayTypeItem.kt
index 4ad6843bb..9c6f1f57f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultArrayTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultArrayTypeItem.kt
@@ -26,7 +26,11 @@ class DefaultArrayTypeItem(
     override val componentType: TypeItem,
     override val isVarargs: Boolean,
 ) : ArrayTypeItem, DefaultTypeItem(modifiers) {
-    override fun duplicate(componentType: TypeItem): ArrayTypeItem {
-        return DefaultArrayTypeItem(modifiers.duplicate(), componentType, isVarargs)
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, componentType)"),
+    )
+    override fun duplicate(modifiers: TypeModifiers, componentType: TypeItem): ArrayTypeItem {
+        return DefaultArrayTypeItem(modifiers, componentType, isVarargs)
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt
index 5deb061a7..c2f59fb93 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultClassTypeItem.kt
@@ -22,12 +22,12 @@ import com.android.tools.metalava.model.DefaultTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
 import com.android.tools.metalava.model.TypeModifiers
 
-class DefaultClassTypeItem(
-    private val codebase: Codebase,
+open class DefaultClassTypeItem(
+    internal val codebase: Codebase,
     modifiers: TypeModifiers,
-    override val qualifiedName: String,
-    override val arguments: List<TypeArgumentTypeItem>,
-    override val outerClassType: ClassTypeItem?,
+    final override val qualifiedName: String,
+    final override val arguments: List<TypeArgumentTypeItem>,
+    final override val outerClassType: ClassTypeItem?,
 ) : ClassTypeItem, DefaultTypeItem(modifiers) {
     override val className: String = ClassTypeItem.computeClassName(qualifiedName)
 
@@ -36,16 +36,15 @@ class DefaultClassTypeItem(
 
     override fun asClass() = asClassCache
 
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)"),
+    )
     override fun duplicate(
-        outerClass: ClassTypeItem?,
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
         arguments: List<TypeArgumentTypeItem>
     ): ClassTypeItem {
-        return DefaultClassTypeItem(
-            codebase,
-            modifiers.duplicate(),
-            qualifiedName,
-            arguments,
-            outerClass
-        )
+        return DefaultClassTypeItem(codebase, modifiers, qualifiedName, arguments, outerClassType)
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt
new file mode 100644
index 000000000..30fc1b03b
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultLambdaTypeItem.kt
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.type
+
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.LambdaTypeItem
+import com.android.tools.metalava.model.TypeArgumentTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeModifiers
+
+class DefaultLambdaTypeItem(
+    codebase: Codebase,
+    modifiers: TypeModifiers,
+    qualifiedName: String,
+    arguments: List<TypeArgumentTypeItem>,
+    outerClassType: ClassTypeItem?,
+    override val isSuspend: Boolean,
+    override val receiverType: TypeItem?,
+    override val parameterTypes: List<TypeItem>,
+    override val returnType: TypeItem,
+) :
+    DefaultClassTypeItem(
+        codebase = codebase,
+        modifiers = modifiers,
+        qualifiedName = qualifiedName,
+        arguments = arguments,
+        outerClassType = outerClassType,
+    ),
+    LambdaTypeItem {
+
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)"),
+    )
+    override fun duplicate(
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
+        arguments: List<TypeArgumentTypeItem>
+    ): LambdaTypeItem {
+        return DefaultLambdaTypeItem(
+            codebase = codebase,
+            qualifiedName = qualifiedName,
+            arguments = arguments,
+            outerClassType = outerClassType,
+            modifiers = modifiers,
+            isSuspend = isSuspend,
+            receiverType = receiverType,
+            parameterTypes = parameterTypes,
+            returnType = returnType,
+        )
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultPrimitiveTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultPrimitiveTypeItem.kt
index c32939527..b65fe48b5 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultPrimitiveTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultPrimitiveTypeItem.kt
@@ -25,6 +25,10 @@ class DefaultPrimitiveTypeItem(
     modifiers: TypeModifiers,
     override val kind: Primitive,
 ) : PrimitiveTypeItem, DefaultTypeItem(modifiers) {
-    override fun duplicate(): PrimitiveTypeItem =
-        DefaultPrimitiveTypeItem(modifiers.duplicate(), kind)
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers)"),
+    )
+    override fun duplicate(modifiers: TypeModifiers): PrimitiveTypeItem =
+        DefaultPrimitiveTypeItem(modifiers, kind)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultResolvedClassTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultResolvedClassTypeItem.kt
index 9ba6724ac..70cf81b58 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultResolvedClassTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultResolvedClassTypeItem.kt
@@ -36,11 +36,16 @@ class DefaultResolvedClassTypeItem(
 
     override fun asClass() = classItem
 
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, outerClassType, arguments)"),
+    )
     override fun duplicate(
-        outerClass: ClassTypeItem?,
+        modifiers: TypeModifiers,
+        outerClassType: ClassTypeItem?,
         arguments: List<TypeArgumentTypeItem>
     ): ClassTypeItem {
-        return DefaultResolvedClassTypeItem(modifiers.duplicate(), classItem, arguments)
+        return DefaultResolvedClassTypeItem(modifiers, classItem, arguments)
     }
 
     companion object {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt
index 670090d07..d52a375c9 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt
@@ -23,48 +23,34 @@ import com.android.tools.metalava.model.TypeNullability
 
 /** Modifiers for a [TypeItem]. */
 class DefaultTypeModifiers(
-    private val annotations: MutableList<AnnotationItem>,
-    private var nullability: TypeNullability,
-    /**
-     * If non-null then this causes this instance to be treated as immutable and any attempt to
-     * mutate it will throw an exception with this as the reason.
-     */
-    private val immutableReason: String? = null,
+    override val annotations: List<AnnotationItem>,
+    override val nullability: TypeNullability,
 ) : TypeModifiers {
 
-    private fun ensureMutable() {
-        immutableReason?.let { reason -> error(reason) }
-    }
-
-    override fun annotations(): List<AnnotationItem> = annotations
-
-    override fun addAnnotation(annotation: AnnotationItem) {
-        ensureMutable()
-        annotations.add(annotation)
-    }
+    override fun substitute(
+        nullability: TypeNullability,
+        annotations: List<AnnotationItem>,
+    ): TypeModifiers =
+        if (nullability != this.nullability || annotations != this.annotations)
+            DefaultTypeModifiers(annotations, nullability)
+        else this
 
-    override fun removeAnnotation(annotation: AnnotationItem) {
-        ensureMutable()
-        annotations.remove(annotation)
-    }
-
-    override fun nullability(): TypeNullability {
-        return nullability
-    }
+    companion object {
+        /** A set of empty, non-null [TypeModifiers] for sharing. */
+        val emptyNonNullModifiers: TypeModifiers =
+            DefaultTypeModifiers(emptyList(), TypeNullability.NONNULL)
 
-    override fun setNullability(newNullability: TypeNullability) {
-        if (newNullability == nullability) return
-        ensureMutable()
-        nullability = newNullability
-    }
+        /** A set of empty, nullable [TypeModifiers] for sharing. */
+        val emptyNullableModifiers: TypeModifiers =
+            DefaultTypeModifiers(emptyList(), TypeNullability.NULLABLE)
 
-    override fun duplicate(withNullability: TypeNullability?) =
-        DefaultTypeModifiers(annotations.toMutableList(), withNullability ?: nullability)
+        /** A set of empty, platform [TypeModifiers] for sharing. */
+        val emptyPlatformModifiers: TypeModifiers =
+            DefaultTypeModifiers(emptyList(), TypeNullability.PLATFORM)
 
-    companion object {
-        /** A set of empty, non-null [TypeModifiers] for sharing. */
-        val emptyNonNullModifiers =
-            create(emptyList(), TypeNullability.NONNULL, "emptyNonNullModifiers is shared")
+        /** A set of empty, undefined [TypeModifiers] for sharing. */
+        val emptyUndefinedModifiers: TypeModifiers =
+            DefaultTypeModifiers(emptyList(), TypeNullability.UNDEFINED)
 
         /**
          * Create a [DefaultTypeModifiers].
@@ -75,7 +61,6 @@ class DefaultTypeModifiers(
         fun create(
             annotations: List<AnnotationItem>,
             knownNullability: TypeNullability? = null,
-            immutableReason: String? = null,
         ): TypeModifiers {
             // Use the known nullability, or find if there is a nullness annotation on the type,
             // defaulting to platform nullness if not.
@@ -85,7 +70,18 @@ class DefaultTypeModifiers(
                         .firstOrNull { it.isNullnessAnnotation() }
                         ?.let { TypeNullability.ofAnnotation(it) }
                         ?: TypeNullability.PLATFORM
-            return DefaultTypeModifiers(annotations.toMutableList(), nullability, immutableReason)
+
+            // If the annotations are empty then use one of the predefined instances.
+            if (annotations.isEmpty()) {
+                return when (nullability) {
+                    TypeNullability.NONNULL -> emptyNonNullModifiers
+                    TypeNullability.NULLABLE -> emptyNullableModifiers
+                    TypeNullability.PLATFORM -> emptyPlatformModifiers
+                    TypeNullability.UNDEFINED -> emptyUndefinedModifiers
+                }
+            }
+
+            return DefaultTypeModifiers(annotations, nullability)
         }
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultVariableTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultVariableTypeItem.kt
index 6d50d981d..a26ad7ba8 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultVariableTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultVariableTypeItem.kt
@@ -28,6 +28,10 @@ class DefaultVariableTypeItem(
 
     override val name: String = asTypeParameter.name()
 
-    override fun duplicate(): VariableTypeItem =
-        DefaultVariableTypeItem(modifiers.duplicate(), asTypeParameter)
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers)"),
+    )
+    override fun duplicate(modifiers: TypeModifiers): VariableTypeItem =
+        DefaultVariableTypeItem(modifiers, asTypeParameter)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultWildcardTypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultWildcardTypeItem.kt
index 204acf394..99ad5ca3f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultWildcardTypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultWildcardTypeItem.kt
@@ -26,12 +26,17 @@ class DefaultWildcardTypeItem(
     override val extendsBound: ReferenceTypeItem?,
     override val superBound: ReferenceTypeItem?,
 ) : WildcardTypeItem, DefaultTypeItem(modifiers) {
+    @Deprecated(
+        "implementation detail of this class",
+        replaceWith = ReplaceWith("substitute(modifiers, extendsBound, superBound)"),
+    )
     override fun duplicate(
+        modifiers: TypeModifiers,
         extendsBound: ReferenceTypeItem?,
         superBound: ReferenceTypeItem?
     ): WildcardTypeItem {
         return DefaultWildcardTypeItem(
-            modifiers.duplicate(),
+            modifiers,
             extendsBound,
             superBound,
         )
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
index 599489ab7..235306597 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
@@ -16,6 +16,9 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.item.CodebaseAssembler
+import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.item.PackageDoc
 import java.io.File
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNotNull
@@ -25,31 +28,32 @@ import org.junit.Test
 class DefaultAnnotationItemTest {
     // Placeholder for use in test where we don't need codebase functionality
     private val placeholderCodebase =
-        object : DefaultCodebase(File("").canonicalFile, "", false, noOpAnnotationManager) {
-            override fun supportsDocumentation() = false
+        DefaultCodebase(
+            location = File("").canonicalFile,
+            description = "",
+            preFiltered = false,
+            annotationManager = noOpAnnotationManager,
+            trustedApi = false,
+            supportsDocumentation = false,
+            assembler =
+                object : CodebaseAssembler {
+                    override fun createPackageItem(
+                        packageName: String,
+                        packageDoc: PackageDoc,
+                        containingPackage: PackageItem?,
+                    ) = error("unsupported")
 
-            override fun getPackages() = unsupported()
-
-            override fun size() = unsupported()
-
-            override fun findClass(className: String) = unsupported()
-
-            override fun resolveClass(className: String) = unsupported()
-
-            override fun findPackage(pkgName: String) = unsupported()
-
-            override fun trustedApi() = false
+                    override fun createClassFromUnderlyingModel(qualifiedName: String) = null
+                },
+        )
 
-            override fun createAnnotation(
-                source: String,
-                context: Item?,
-            ): AnnotationItem = unsupported()
-        }
+    private fun createDefaultAnnotationItem(source: String) =
+        DefaultAnnotationItem.create(placeholderCodebase, source)
+            ?: error("Could not create annotation from: '$source'")
 
     @Test
     fun testSimple() {
-        val annotation =
-            DefaultAnnotationItem.create(placeholderCodebase, "@androidx.annotation.Nullable")
+        val annotation = createDefaultAnnotationItem("@androidx.annotation.Nullable")
         assertEquals("@androidx.annotation.Nullable", annotation.toSource())
         assertEquals("androidx.annotation.Nullable", annotation.qualifiedName)
         assertTrue(annotation.attributes.isEmpty())
@@ -58,10 +62,7 @@ class DefaultAnnotationItemTest {
     @Test
     fun testIntRange() {
         val annotation =
-            DefaultAnnotationItem.create(
-                placeholderCodebase,
-                "@androidx.annotation.IntRange(from = 20, to = 40)"
-            )
+            createDefaultAnnotationItem("@androidx.annotation.IntRange(from = 20, to = 40)")
         assertEquals("@androidx.annotation.IntRange(from=20, to=40)", annotation.toSource())
         assertEquals("androidx.annotation.IntRange", annotation.qualifiedName)
         assertEquals(2, annotation.attributes.size)
@@ -74,8 +75,7 @@ class DefaultAnnotationItemTest {
     @Test
     fun testIntDef() {
         val annotation =
-            DefaultAnnotationItem.create(
-                placeholderCodebase,
+            createDefaultAnnotationItem(
                 "@androidx.annotation.IntDef({STYLE_NORMAL, STYLE_NO_TITLE, STYLE_NO_FRAME, STYLE_NO_INPUT})"
             )
         assertEquals(
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
index 05e8d4d9d..642068236 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
@@ -23,18 +23,40 @@ import kotlin.test.assertNotNull
 
 interface Assertions {
 
-    /** Get the class from the [Codebase], failing if it does not exist. */
-    fun Codebase.assertClass(qualifiedName: String): ClassItem {
+    /**
+     * Get the class from the [Codebase], failing if it does not exist.
+     *
+     * Checks to make sure that returned [ClassItem]'s [ClassItem.emit] property matches
+     * [expectedEmit]. That defaults to `true` as this is usually used to retrieve a class that is
+     * present in the source which have `emit = true` by default.
+     */
+    fun Codebase.assertClass(qualifiedName: String, expectedEmit: Boolean = true): ClassItem {
         val classItem = findClass(qualifiedName)
         assertNotNull(classItem, message = "Expected $qualifiedName to be defined")
+        assertEquals(
+            expectedEmit,
+            classItem.emit,
+            message = "Expected $qualifiedName to have emit=$expectedEmit"
+        )
         return classItem
     }
 
-    /** Resolve the class from the [Codebase], failing if it does not exist. */
-    fun Codebase.assertResolvedClass(qualifiedName: String): ClassItem {
-        val classItem = resolveClass(qualifiedName)
-        assertNotNull(classItem, message = "Expected $qualifiedName to be defined")
-        return classItem
+    /**
+     * Resolve the class from the [Codebase], failing if it does not exist.
+     *
+     * Checks to make sure that returned [ClassItem]'s [ClassItem.emit] property matches
+     * [expectedEmit]. That defaults to `true` as this is usually used to retrieve a class that is
+     * present in the source which have `emit = true` by default.
+     */
+    fun Codebase.assertResolvedClass(
+        qualifiedName: String,
+        expectedEmit: Boolean = false
+    ): ClassItem {
+        // Resolve the class which should make it available to assertClass(...) if it could be
+        // found.
+        resolveClass(qualifiedName)
+        // Assert that the class exists and has correct setting of `emit`.
+        return assertClass(qualifiedName, expectedEmit)
     }
 
     /** Get the package from the [Codebase], failing if it does not exist. */
@@ -60,9 +82,12 @@ interface Assertions {
 
     /** Get the constructor from the [ClassItem], failing if it does not exist. */
     fun ClassItem.assertConstructor(parameters: String): ConstructorItem {
-        val methodItem = findMethod(simpleName(), parameters)
-        assertNotNull(methodItem, message = "Expected ${simpleName()}($parameters) to be defined")
-        return assertIs(methodItem)
+        val constructorItem = findConstructor(parameters)
+        assertNotNull(
+            constructorItem,
+            message = "Expected ${simpleName()}($parameters) to be defined"
+        )
+        return assertIs(constructorItem)
     }
 
     /** Get the property from the [ClassItem], failing if it does not exist. */
@@ -124,7 +149,7 @@ interface Assertions {
      * Create a Kotlin like method description. It uses Kotlin structure for a method and Kotlin
      * style nulls but not Kotlin types.
      */
-    fun MethodItem.kotlinLikeDescription(): String = buildString {
+    fun CallableItem.kotlinLikeDescription(): String = buildString {
         if (isConstructor()) {
             append("constructor ")
         } else {
@@ -141,7 +166,7 @@ interface Assertions {
 
     /** Get the list of fully qualified annotation names associated with the [TypeItem]. */
     fun TypeItem.annotationNames(): List<String?> {
-        return modifiers.annotations().map { it.qualifiedName }
+        return modifiers.annotations.map { it.qualifiedName }
     }
 
     /** Get the list of fully qualified annotation names associated with the [Item]. */
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/transformer/CodebaseTransformer.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/transformer/CodebaseTransformer.kt
new file mode 100644
index 000000000..99c77b7ca
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/transformer/CodebaseTransformer.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testing.transformer
+
+import com.android.tools.metalava.model.Codebase
+import java.util.ServiceLoader
+
+interface CodebaseTransformer {
+
+    /** Transform the [codebase] into a different [Codebase] */
+    fun transform(codebase: Codebase): Codebase
+
+    companion object {
+
+        /**
+         * Find all the [CodebaseTransformer]s and apply as follows:
+         * 1. If none are available return [codebase].
+         * 2. If more than one are available fail.
+         * 3. Load the available one and apply to [codebase] returning the result.
+         */
+        fun transformIfAvailable(codebase: Codebase): Codebase {
+            // Try and load CodebaseTransformers.
+            val loader = ServiceLoader.load(CodebaseTransformer::class.java)
+
+            // If there are none then return the codebase unchanged.
+            if (loader.none()) return codebase
+
+            // Get the sole transformer.
+            val transformer = loader.toList().single()
+
+            // Apply it.
+            return transformer.transform(codebase)
+        }
+    }
+}
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/transformer/package-info.java b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/transformer/package-info.java
new file mode 100644
index 000000000..80303e022
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/transformer/package-info.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Contains classes to support running tests on a [com.android.tools.metalava.model.Codebase] created from another
+ * [Codebase].
+ */
+package com.android.tools.metalava.model.testing.transformer;
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/DefaultReportFormatter.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/DefaultReportFormatter.kt
new file mode 100644
index 000000000..d724987b2
--- /dev/null
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/DefaultReportFormatter.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.reporter
+
+/** Formats a [Report] for output. */
+open class DefaultReportFormatter protected constructor() : ReportFormatter {
+
+    protected open fun beginImportantSection(builder: StringBuilder) {}
+
+    protected open fun beginSeverity(builder: StringBuilder, severity: Severity) {}
+
+    protected open fun endSeverity(builder: StringBuilder) {}
+
+    protected open fun endImportantSection(builder: StringBuilder) {}
+
+    override fun format(report: Report) = buildString {
+        val (severity, relativePath, line, message, id) = report
+        beginImportantSection(this)
+        relativePath?.let {
+            append(it)
+            if (line > 0) append(":").append(line)
+            append(": ")
+        }
+
+        beginSeverity(this, severity)
+        when (severity) {
+            Severity.INFO -> {
+                append("info: ")
+            }
+            Severity.WARNING,
+            Severity.WARNING_ERROR_WHEN_NEW -> {
+                append("warning: ")
+            }
+            Severity.ERROR -> {
+                append("error: ")
+            }
+            Severity.INHERIT,
+            Severity.HIDDEN -> {}
+        }
+        endSeverity(this)
+        endImportantSection(this)
+
+        append(message)
+        append(severity.messageSuffix)
+        id?.let<Issues.Issue, Unit> { append(" [").append(it.name).append("]") }
+    }
+
+    companion object {
+        val DEFAULT = DefaultReportFormatter()
+    }
+}
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/DefaultReporter.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/DefaultReporter.kt
new file mode 100644
index 000000000..1ec30434e
--- /dev/null
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/DefaultReporter.kt
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.reporter
+
+import com.android.tools.metalava.reporter.Severity.ERROR
+import com.android.tools.metalava.reporter.Severity.HIDDEN
+import com.android.tools.metalava.reporter.Severity.WARNING
+import java.io.File
+import java.io.OutputStreamWriter
+import java.io.PrintWriter
+import java.nio.file.Path
+import java.util.function.Predicate
+
+class DefaultReporter(
+    private val environment: ReporterEnvironment,
+    private val issueConfiguration: IssueConfiguration,
+
+    /** [Baseline] file associated with this [Reporter]. */
+    private val baseline: Baseline? = null,
+
+    /**
+     * An error message associated with this [Reporter], which should be shown to the user when
+     * metalava finishes with errors.
+     */
+    private val errorMessage: String? = null,
+
+    /** Filter to hide issues reported on specific types of [Reportable]. */
+    private val reportableFilter: Predicate<Reportable>? = null,
+
+    /** Additional config properties. */
+    private val config: Config = Config(),
+) : Reporter {
+
+    /** A list of [Report] objects containing all the reported issues. */
+    private val reports = mutableListOf<Report>()
+
+    private var warningCount = 0
+
+    /**
+     * Configuration properties for the reporter.
+     *
+     * This contains properties that are shared across all instances of [DefaultReporter], except
+     * for the bootstrapping reporter. That receives a default instance of this.
+     */
+    class Config(
+        /** If true, treat all warnings as errors */
+        val warningsAsErrors: Boolean = false,
+
+        /** Formats the report suitable for use in a file. */
+        val fileReportFormatter: ReportFormatter = DefaultReportFormatter.DEFAULT,
+
+        /** Formats the report for output, e.g. to a terminal. */
+        val outputReportFormatter: ReportFormatter = fileReportFormatter,
+
+        /**
+         * Optional writer to which, if present, all errors, even if they were suppressed in
+         * baseline or via annotation, will be written.
+         */
+        val reportEvenIfSuppressedWriter: PrintWriter? = null,
+    )
+
+    /** The number of errors. */
+    var errorCount: Int = 0
+        private set
+
+    /** Returns whether any errors have been detected. */
+    fun hasErrors(): Boolean = errorCount > 0
+
+    override fun report(
+        id: Issues.Issue,
+        reportable: Reportable?,
+        message: String,
+        location: FileLocation,
+        maximumSeverity: Severity,
+    ): Boolean {
+        val severity = issueConfiguration.getSeverity(id)
+        val upgradedSeverity =
+            if (severity == WARNING && config.warningsAsErrors) {
+                ERROR
+            } else {
+                severity
+            }
+
+        // Limit the Severity to the maximum allowed.
+        val effectiveSeverity = minOf(upgradedSeverity, maximumSeverity)
+        if (effectiveSeverity == HIDDEN) {
+            return false
+        }
+
+        // When selecting a location to use for reporting the issue the location is used in
+        // preference to the item because the location is more specific. e.g. if the item is a
+        // method then the location may be a line within the body of the method.
+        val reportLocation =
+            when {
+                location.path != null -> location
+                else -> reportable?.fileLocation
+            }
+
+        val report =
+            Report(
+                severity = effectiveSeverity,
+                // Relativize the path before storing in the Report.
+                relativePath = reportLocation?.path?.relativizeLocationPath(),
+                line = reportLocation?.line ?: 0,
+                message = message,
+                issue = id,
+            )
+
+        // Optionally write to the --report-even-if-suppressed file.
+        reportEvenIfSuppressed(report)
+
+        if (isSuppressed(id, reportable, message)) {
+            return false
+        }
+
+        // Apply the reportable filter if one is provided.
+        if (reportable != null && reportableFilter?.test(reportable) == false) {
+            return false
+        }
+
+        if (baseline != null) {
+            // When selecting a key to use for in checking the baseline the reportable key is used
+            // in preference to the location because the reportable key is more stable. e.g. the
+            // location key may be for a specific line within a method which would change over time
+            // while a key based off a method's would stay the same.
+            val baselineKey =
+                when {
+                    // When available use the baseline key from the reportable.
+                    reportable != null -> reportable.baselineKey
+                    // Otherwise, use the baseline key from the file location.
+                    else -> location.baselineKey
+                }
+
+            if (baselineKey != null && baseline.mark(baselineKey, message, id)) return false
+        }
+
+        return doReport(report)
+    }
+
+    override fun isSuppressed(
+        id: Issues.Issue,
+        reportable: Reportable?,
+        message: String?
+    ): Boolean {
+        val severity = issueConfiguration.getSeverity(id)
+        if (severity == HIDDEN) {
+            return true
+        }
+
+        reportable ?: return false
+
+        // Suppress the issue if requested for the item.
+        return reportable.suppressedIssues().any { suppressMatches(it, id.name, message) }
+    }
+
+    private fun suppressMatches(value: String, id: String?, message: String?): Boolean {
+        id ?: return false
+
+        if (value == id) {
+            return true
+        }
+
+        if (
+            message != null &&
+                value.startsWith(id) &&
+                value.endsWith(message) &&
+                (value == "$id:$message" || value == "$id: $message")
+        ) {
+            return true
+        }
+
+        return false
+    }
+
+    /**
+     * Relativize this against the [ReporterEnvironment.rootFolder] if specified.
+     *
+     * Tests will set [ReporterEnvironment.rootFolder] to the temporary directory so that this can
+     * remove that from any paths that are reported to avoid the test having to be aware of the
+     * temporary directory.
+     */
+    private fun Path.relativizeLocationPath(): String {
+        // b/255575766: Note that `relativize` requires two paths to compare to have same types:
+        // either both of them are absolute paths or both of them are not absolute paths.
+        val path = environment.rootFolder.toPath().relativize(this) ?: this
+        return path.toString()
+    }
+
+    /** Alias to allow method reference to `dispatch` in [report] */
+    private fun doReport(report: Report): Boolean {
+        val severity = report.severity
+        when (severity) {
+            ERROR -> errorCount++
+            WARNING -> warningCount++
+            else -> {}
+        }
+
+        reports.add(report)
+        return true
+    }
+
+    private fun reportEvenIfSuppressed(report: Report): Boolean {
+        config.reportEvenIfSuppressedWriter?.println(config.fileReportFormatter.format(report))
+        return true
+    }
+
+    /** Print all the recorded errors to the given writer. Returns the number of errors printed. */
+    fun printErrors(writer: PrintWriter, maxErrors: Int): Int {
+        val errors = reports.filter { it.severity == ERROR }.take(maxErrors)
+        for (error in errors) {
+            val formattedMessage = config.outputReportFormatter.format(error)
+            writer.println(formattedMessage)
+        }
+        return errors.size
+    }
+
+    /** Write all reports. */
+    fun writeSavedReports() {
+        // Sort the reports in place. This will ensure that the errors output in [printErrors] are
+        // also sorted in the same order as that is called after this.
+        reports.sortWith(reportComparator)
+
+        // Print out all the save reports.
+        for (report in reports) {
+            val formattedMessage = config.outputReportFormatter.format(report)
+            environment.printReport(formattedMessage, report.severity)
+        }
+    }
+
+    /** Write the error message set to this [Reporter], if any errors have been detected. */
+    fun writeErrorMessage(writer: PrintWriter) {
+        if (hasErrors()) {
+            errorMessage?.let { writer.write(it) }
+        }
+    }
+
+    companion object {
+        private val reportComparator =
+            compareBy<Report>(
+                { it.relativePath },
+                { it.line },
+                { it.severity },
+                { it.issue?.name },
+                { it.message },
+            )
+    }
+}
+
+/**
+ * Provides access to information about the environment within which the [Reporter] will be being
+ * used.
+ */
+interface ReporterEnvironment {
+
+    /** Root folder, against which location paths will be relativized to simplify the output. */
+    val rootFolder: File
+
+    /** Print the report. */
+    fun printReport(message: String, severity: Severity)
+}
+
+class DefaultReporterEnvironment(
+    val stdout: PrintWriter = PrintWriter(OutputStreamWriter(System.out)),
+    val stderr: PrintWriter = PrintWriter(OutputStreamWriter(System.err)),
+) : ReporterEnvironment {
+
+    override val rootFolder = File("").absoluteFile
+
+    override fun printReport(message: String, severity: Severity) {
+        val output = if (severity == ERROR) stderr else stdout
+        output.println(message.trim())
+        output.flush()
+    }
+}
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
index 0a9097671..2b973e080 100644
--- a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
@@ -29,12 +29,17 @@ object Issues {
 
     val PARSE_ERROR by Issue(Severity.ERROR)
     val DUPLICATE_SOURCE_CLASS by Issue(Severity.WARNING)
+
+    val CONFIG_FILE_PROBLEM by Issue(Severity.ERROR)
+
     // Compatibility issues
+    val ADDED_ANNOTATION by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val ADDED_PACKAGE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
     val ADDED_CLASS by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
     val ADDED_METHOD by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
     val ADDED_FIELD by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
     val ADDED_INTERFACE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
+    val REMOVED_ANNOTATION by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val REMOVED_PACKAGE by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val REMOVED_CLASS by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val REMOVED_METHOD by Issue(Severity.ERROR, Category.COMPATIBILITY)
@@ -102,29 +107,30 @@ object Issues {
     val ANNOTATION_EXTRACTION by Issue(Severity.ERROR)
     val SUPERFLUOUS_PREFIX by Issue(Severity.WARNING)
     val HIDDEN_TYPEDEF_CONSTANT by Issue(Severity.ERROR)
-    val EXPECTED_PLATFORM_TYPE by Issue(Severity.HIDDEN)
     val INTERNAL_ERROR by Issue(Severity.ERROR)
     val RETURNING_UNEXPECTED_CONSTANT by Issue(Severity.WARNING)
     val DEPRECATED_OPTION by Issue(Severity.WARNING)
     val BOTH_PACKAGE_INFO_AND_HTML by Issue(Severity.WARNING, Category.DOCUMENTATION)
-    val UNMATCHED_MERGE_ANNOTATION by Issue(Severity.ERROR)
+    val UNMATCHED_MERGE_ANNOTATION by Issue(Severity.ERROR, Category.API_LINT)
+    val INCONSISTENT_MERGE_ANNOTATION by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
     // The plan is for this to be set as an error once (1) existing code is marked as @deprecated
     // and (2) the principle is adopted by the API council
-    val REFERENCES_DEPRECATED by Issue(Severity.HIDDEN)
-    val UNHIDDEN_SYSTEM_API by Issue(Severity.ERROR)
-    val SHOWING_MEMBER_IN_HIDDEN_CLASS by Issue(Severity.ERROR)
+    val REFERENCES_DEPRECATED by Issue(Severity.HIDDEN, Category.API_LINT)
+    val UNHIDDEN_SYSTEM_API by Issue(Severity.ERROR, Category.API_LINT)
+    val SHOWING_MEMBER_IN_HIDDEN_CLASS by Issue(Severity.ERROR, Category.API_LINT)
     val INVALID_NULLABILITY_ANNOTATION by Issue(Severity.ERROR)
-    val REFERENCES_HIDDEN by Issue(Severity.ERROR)
+    val REFERENCES_HIDDEN by Issue(Severity.ERROR, Category.API_LINT)
     val IGNORING_SYMLINK by Issue(Severity.INFO)
     val INVALID_NULLABILITY_ANNOTATION_WARNING by Issue(Severity.WARNING)
     // The plan is for this to be set as an error once (1) existing code is marked as @deprecated
     // and (2) the principle is adopted by the API council
-    val EXTENDS_DEPRECATED by Issue(Severity.HIDDEN)
-    val FORBIDDEN_TAG by Issue(Severity.ERROR)
+    val EXTENDS_DEPRECATED by Issue(Severity.HIDDEN, Category.API_LINT)
+    val FORBIDDEN_TAG by Issue(Severity.ERROR, Category.DOCUMENTATION)
     val MISSING_COLUMN by Issue(Severity.WARNING, Category.DOCUMENTATION)
     val INVALID_SYNTAX by Issue(Severity.ERROR)
+    val INVALID_PACKAGE by Issue(Severity.ERROR)
     val UNRESOLVED_IMPORT by Issue(Severity.INFO)
-    val HIDDEN_ABSTRACT_METHOD by Issue(Severity.ERROR)
+    val HIDDEN_ABSTRACT_METHOD by Issue(Severity.ERROR, Category.API_LINT)
 
     // API lint
     val START_WITH_LOWER by Issue(Severity.ERROR, Category.API_LINT)
@@ -207,7 +213,7 @@ object Issues {
     val UNIQUE_KOTLIN_OPERATOR by Issue(Severity.ERROR, Category.API_LINT)
     val SAM_SHOULD_BE_LAST by Issue(Severity.WARNING, Category.API_LINT)
     val MISSING_JVMSTATIC by Issue(Severity.WARNING, Category.API_LINT)
-    val DEFAULT_VALUE_CHANGE by Issue(Severity.ERROR, Category.API_LINT)
+    val DEFAULT_VALUE_CHANGE by Issue(Severity.ERROR, Category.COMPATIBILITY)
     val DOCUMENT_EXCEPTIONS by Issue(Severity.ERROR, Category.API_LINT)
     val FORBIDDEN_SUPER_CLASS by Issue(Severity.ERROR, Category.API_LINT)
     val MISSING_NULLABILITY by Issue(Severity.ERROR, Category.API_LINT)
@@ -232,6 +238,7 @@ object Issues {
     val UNFLAGGED_API by Issue(Severity.HIDDEN, Category.API_LINT)
     val FLAGGED_API_LITERAL by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
     val GETTER_SETTER_NULLABILITY by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
+    val CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED by Issue(Severity.HIDDEN, Category.API_LINT)
 
     fun findIssueById(id: String?): Issue? {
         return nameToIssue[id]
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Report.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Report.kt
new file mode 100644
index 000000000..b783da584
--- /dev/null
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Report.kt
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.reporter
+
+/** A report of an issue that was found. */
+data class Report(
+    val severity: Severity,
+    val relativePath: String?,
+    val line: Int,
+    val message: String,
+    val issue: Issues.Issue?,
+)
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PackageDocs.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/ReportFormatter.kt
similarity index 67%
rename from metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PackageDocs.kt
rename to metalava-reporter/src/main/java/com/android/tools/metalava/reporter/ReportFormatter.kt
index aba1dff10..b5ee19cc5 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PackageDocs.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/ReportFormatter.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2023 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,9 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava.model.psi
+package com.android.tools.metalava.reporter
 
-internal data class PackageDocs(
-    val packageDocs: MutableMap<String, String>,
-    val overviewDocs: MutableMap<String, String>,
-    val hiddenPackages: MutableSet<String>
-)
+/** Formats a [Report] object suitable for outputting, e.g. to a terminal or file. */
+interface ReportFormatter {
+    fun format(report: Report): String
+}
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
index 13a6d3120..bb923051d 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
@@ -63,6 +63,14 @@ object KnownSourceFiles {
             """
         )
 
+    val androidAnnotationHide: TestFile =
+        TestFiles.java(
+            """
+                /** @hide */
+                package android.annotation;
+            """
+        )
+
     val nonNullSource: TestFile =
         TestFiles.java(
             """
@@ -105,6 +113,14 @@ object KnownSourceFiles {
     """
         )
 
+    val libcodeUtilHide: TestFile =
+        TestFiles.java(
+            """
+                /** @hide */
+                package libcore.util;
+            """
+        )
+
     val libcoreNonNullSource: TestFile =
         TestFiles.java(
             """
@@ -148,6 +164,14 @@ object KnownSourceFiles {
             """
         )
 
+    val androidxAnnotationHide: TestFile =
+        TestFiles.java(
+            """
+                /** @hide */
+                package androidx.annotation;
+            """
+        )
+
     /** TYPE_USE version of [com.android.tools.metalava.intRangeAnnotationSource] */
     val intRangeTypeUseSource =
         java(
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestUtils.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestUtils.kt
index 6b673aa9c..85345747a 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestUtils.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/TestUtils.kt
@@ -29,6 +29,10 @@ fun html(to: String, @Language("HTML") source: String): TestFile {
     return TestFiles.source(to, source.trimIndent())
 }
 
+fun xml(to: String, @Language("XML") source: String): TestFile {
+    return TestFiles.xml(to, source.trimIndent())
+}
+
 fun java(to: String, @Language("JAVA") source: String): TestFile {
     return TestFiles.java(to, source.trimIndent())
 }
diff --git a/metalava/Android.bp b/metalava/Android.bp
index 120d56d3f..d9d75cf33 100644
--- a/metalava/Android.bp
+++ b/metalava/Android.bp
@@ -16,6 +16,12 @@ package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
+filegroup {
+    name: "metalava-resources",
+    srcs: ["src/main/resources/**/*"],
+    path: "src/main/resources",
+}
+
 // The metalava application. This must be built in this directory because the
 // path to this is hard-coded in Bazel rules that use metalava.
 java_binary_host {
@@ -27,7 +33,10 @@ java_binary_host {
         "src/main/java/**/*.java",
         "src/main/java/**/*.kt",
     ],
-    java_resources: [":metalava-version"],
+    java_resources: [
+        ":metalava-version",
+        ":metalava-resources",
+    ],
     static_libs: [
         "jsr305",
         "jsr330",
diff --git a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
index 1aef9c062..70925b4e0 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
@@ -17,12 +17,12 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.ANDROIDX_INT_DEF
-import com.android.tools.metalava.model.AnnotationAttributeValue
-import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.visitors.ApiVisitor
@@ -33,36 +33,41 @@ import java.util.regex.Pattern
 /** Misc API suggestions */
 class AndroidApiChecks(val reporter: Reporter) {
     fun check(codebase: Codebase) {
-        codebase.accept(
+        for (packageItem in codebase.getPackages().packages) {
+            // Get the package name with a trailing `.` to simplify prefix checking below. Without
+            // it the checks would have to check for `android` and `android.` separately.
+            val name = packageItem.qualifiedName() + "."
+
+            // Limit the checks to the android.* namespace (except for ICU)
+            if (!name.startsWith("android.") || name.startsWith("android.icu.")) continue
+
+            checkPackage(packageItem)
+        }
+    }
+
+    private fun checkPackage(packageItem: PackageItem) {
+        packageItem.accept(
             object :
                 ApiVisitor(
                     // Sort by source order such that warnings follow source line number order
-                    methodComparator = MethodItem.sourceOrderComparator,
+                    callableComparator = CallableItem.sourceOrderComparator,
                     config = @Suppress("DEPRECATION") options.apiVisitorConfig,
                 ) {
-                override fun skip(item: Item): Boolean {
-                    // Limit the checks to the android.* namespace (except for ICU)
-                    if (item is ClassItem) {
-                        val name = item.qualifiedName()
-                        return !(name.startsWith("android.") && !name.startsWith("android.icu."))
-                    }
-                    return super.skip(item)
-                }
-
                 override fun visitItem(item: Item) {
                     checkTodos(item)
                 }
 
+                override fun visitCallable(callable: CallableItem) {
+                    checkRequiresPermission(callable)
+                }
+
                 override fun visitMethod(method: MethodItem) {
-                    checkRequiresPermission(method)
-                    if (!method.isConstructor()) {
-                        checkVariable(
-                            method,
-                            "@return",
-                            "Return value of '" + method.name() + "'",
-                            method.returnType()
-                        )
-                    }
+                    checkVariable(
+                        method,
+                        "@return",
+                        "Return value of '" + method.name() + "'",
+                        method.returnType()
+                    )
                 }
 
                 override fun visitField(field: FieldItem) {
@@ -79,7 +84,7 @@ class AndroidApiChecks(val reporter: Reporter) {
                         "Parameter '" +
                             parameter.name() +
                             "' of '" +
-                            parameter.containingMethod().name() +
+                            parameter.containingCallable().name() +
                             "'",
                         parameter.type()
                     )
@@ -106,10 +111,10 @@ class AndroidApiChecks(val reporter: Reporter) {
 
     private fun findDocumentation(item: Item, tag: String?): String {
         if (item is ParameterItem) {
-            return findDocumentation(item.containingMethod(), item.name())
+            return findDocumentation(item.containingCallable(), item.name())
         }
 
-        val doc = item.documentation
+        val doc = item.documentation.text
         if (doc.isBlank()) {
             return ""
         }
@@ -187,49 +192,52 @@ class AndroidApiChecks(val reporter: Reporter) {
         }
     }
 
-    private fun checkRequiresPermission(method: MethodItem) {
-        val text = method.documentation
+    private fun checkRequiresPermission(callable: CallableItem) {
+        val text = callable.documentation
 
-        val annotation = method.modifiers.findAnnotation("androidx.annotation.RequiresPermission")
+        val annotation = callable.modifiers.findAnnotation("androidx.annotation.RequiresPermission")
         if (annotation != null) {
+            var conditional = false
+            val permissions = mutableListOf<String>()
             for (attribute in annotation.attributes) {
-                var values: List<AnnotationAttributeValue>? = null
                 when (attribute.name) {
                     "value",
                     "allOf",
                     "anyOf" -> {
-                        values = attribute.leafValues()
+                        attribute.leafValues().mapTo(permissions) { it.toSource() }
                     }
-                }
-                if (values == null || values.isEmpty()) {
-                    continue
-                }
-
-                for (value in values) {
-                    // var perm = String.valueOf(value.value())
-                    var perm = value.toSource()
-                    if (perm.indexOf('.') >= 0) perm = perm.substring(perm.lastIndexOf('.') + 1)
-                    if (text.contains(perm)) {
-                        reporter.report(
-                            // Why is that a problem? Sometimes you want to describe
-                            // particular use cases.
-                            Issues.REQUIRES_PERMISSION,
-                            method,
-                            "Method '" +
-                                method.name() +
-                                "' documentation mentions permissions already declared by @RequiresPermission"
-                        )
+                    "conditional" -> {
+                        conditional = attribute.value.value() == true
                     }
                 }
             }
+            for (item in permissions) {
+                val perm = item.substringAfterLast('.')
+                // Search for the permission name as a whole word.
+                val regex = Regex("""\b\Q$perm\E\b""")
+                val mentioned = text.contains(regex)
+                if (mentioned && !conditional) {
+                    reporter.report(
+                        Issues.REQUIRES_PERMISSION,
+                        callable,
+                        "Method '${callable.name()}' documentation duplicates auto-generated documentation by @RequiresPermission. If the permissions are only required under certain circumstances use conditional=true to suppress the auto-documentation"
+                    )
+                } else if (!mentioned && conditional) {
+                    reporter.report(
+                        Issues.CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED,
+                        callable,
+                        "Method '${callable.name()}' documentation does not explain when the conditional permission '$perm' is required."
+                    )
+                }
+            }
         } else if (
             text.contains("android.Manifest.permission") || text.contains("android.permission.")
         ) {
             reporter.report(
                 Issues.REQUIRES_PERMISSION,
-                method,
+                callable,
                 "Method '" +
-                    method.name() +
+                    callable.name() +
                     "' documentation mentions permissions without declaring @RequiresPermission"
             )
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
index 7103eab2c..316539bab 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
@@ -54,18 +54,15 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultAnnotationAttribute
 import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ModifierList
+import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.TraversingVisitor
-import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
-import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.source.SourceCodebase
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.model.text.ApiFile
 import com.android.tools.metalava.model.text.ApiParseException
 import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.typeNullability
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
@@ -92,7 +89,7 @@ class AnnotationsMerger(
 ) {
 
     /** Merge annotations which will appear in the output API. */
-    fun mergeQualifierAnnotations(files: List<File>) {
+    fun mergeQualifierAnnotationsFromFiles(files: List<File>) {
         mergeAll(
             files,
             ::mergeQualifierAnnotationsFromFile,
@@ -101,7 +98,7 @@ class AnnotationsMerger(
     }
 
     /** Merge annotations which control what is included in the output API. */
-    fun mergeInclusionAnnotations(files: List<File>) {
+    fun mergeInclusionAnnotationsFromFiles(files: List<File>) {
         mergeAll(
             files,
             {
@@ -122,7 +119,7 @@ class AnnotationsMerger(
     private fun mergeAll(
         mergeAnnotations: List<File>,
         mergeFile: (File) -> Unit,
-        mergeJavaStubsCodebase: (SourceCodebase) -> Unit
+        mergeJavaStubsCodebase: (Codebase) -> Unit
     ) {
         // Process each file (which are almost certainly directories) separately. That allows for a
         // single Java class to merge in annotations from multiple separate files.
@@ -179,7 +176,7 @@ class AnnotationsMerger(
         } else if (file.path.endsWith(DOT_XML)) {
             try {
                 val xml = file.readText()
-                mergeAnnotationsXml(file.path, xml)
+                mergeQualifierAnnotationsFromXml(file.path, xml)
             } catch (e: IOException) {
                 error("I/O problem during transform: $e")
             }
@@ -191,7 +188,7 @@ class AnnotationsMerger(
             try {
                 // .txt: Old style signature files
                 // Others: new signature files (e.g. kotlin-style nullness info)
-                mergeAnnotationsSignatureFile(file)
+                mergeQualifierAnnotationsFromSignatureFile(file)
             } catch (e: IOException) {
                 error("I/O problem during transform: $e")
             }
@@ -210,7 +207,7 @@ class AnnotationsMerger(
                 if (entry.name.endsWith(".xml")) {
                     val bytes = zis.readBytes()
                     val xml = String(bytes, UTF_8)
-                    mergeAnnotationsXml(jar.path + ": " + entry, xml)
+                    mergeQualifierAnnotationsFromXml(jar.path + ": " + entry, xml)
                 }
                 entry = zis.nextEntry
             }
@@ -225,7 +222,7 @@ class AnnotationsMerger(
         }
     }
 
-    private fun mergeAnnotationsXml(path: String, xml: String) {
+    private fun mergeQualifierAnnotationsFromXml(path: String, xml: String) {
         try {
             val document = parseDocument(xml, false)
             mergeDocument(document)
@@ -241,7 +238,7 @@ class AnnotationsMerger(
         }
     }
 
-    private fun mergeAnnotationsSignatureFile(file: File) {
+    private fun mergeQualifierAnnotationsFromSignatureFile(file: File) {
         try {
             val signatureCodebase =
                 ApiFile.parseApi(
@@ -257,7 +254,7 @@ class AnnotationsMerger(
     }
 
     private fun mergeAndValidateQualifierAnnotationsFromJavaStubsCodebase(
-        javaStubsCodebase: SourceCodebase
+        javaStubsCodebase: Codebase
     ) {
         mergeQualifierAnnotationsFromCodebase(javaStubsCodebase)
         if (options.validateNullabilityFromMergedStubs) {
@@ -272,18 +269,21 @@ class AnnotationsMerger(
         val visitor =
             object : ComparisonVisitor() {
                 override fun compare(old: Item, new: Item) {
-                    val newModifiers = new.modifiers
-                    for (annotation in old.modifiers.annotations()) {
-                        mergeAnnotation(annotation, newModifiers, new)
+                    val itemAnnotations = old.modifiers.annotations()
+                    mergeQualifierAnnotations(itemAnnotations, new)
+                    old.type()?.let {
+                        // Ignore type annotations that are duplicates of the item's annotations.
+                        val typeAnnotations =
+                            it.modifiers.annotations.filter { it !in itemAnnotations }
+                        mergeQualifierAnnotations(typeAnnotations, new)
                     }
-                    old.type()?.let { mergeTypeAnnotations(it, new) }
                 }
 
                 override fun removed(old: Item, from: Item?) {
                     // Do not report missing items if there are no annotations to copy.
                     if (old.modifiers.annotations().isEmpty()) {
                         old.type()?.let { typeItem ->
-                            if (typeItem.modifiers.annotations().isEmpty()) return
+                            if (typeItem.modifiers.annotations.isEmpty()) return
                         }
                             ?: return
                     }
@@ -294,41 +294,6 @@ class AnnotationsMerger(
                         "qualifier annotations were given for $old but no matching item was found"
                     )
                 }
-
-                private fun mergeAnnotation(
-                    annotation: AnnotationItem,
-                    newModifiers: ModifierList,
-                    new: Item
-                ) {
-                    var addAnnotation = false
-                    if (annotation.isNullnessAnnotation()) {
-                        if (!newModifiers.hasAnnotation(AnnotationItem::isNullnessAnnotation)) {
-                            addAnnotation = true
-                        }
-                    } else {
-                        // TODO: Check for other incompatibilities than nullness?
-                        val qualifiedName = annotation.qualifiedName ?: return
-                        if (newModifiers.findAnnotation(qualifiedName) == null) {
-                            addAnnotation = true
-                        }
-                    }
-
-                    if (addAnnotation) {
-                        mergeAnnotation(
-                            new,
-                            new.codebase.createAnnotation(
-                                annotation.toSource(showDefaultAttrs = false),
-                                new,
-                            )
-                        )
-                    }
-                }
-
-                private fun mergeTypeAnnotations(typeItem: TypeItem, new: Item) {
-                    for (annotation in typeItem.modifiers.annotations()) {
-                        mergeAnnotation(annotation, new.modifiers, new)
-                    }
-                }
             }
 
         CodebaseComparator(
@@ -341,15 +306,15 @@ class AnnotationsMerger(
         val visitor =
             object : TraversingVisitor() {
                 override fun visitItem(item: Item): TraversalAction {
-                    // Find any show/hide annotations or FlaggedApi annotations to copy from the
+                    // Find any show/hide annotations or FlaggedApi annotations to merge from the
                     // external to the main codebase. If there are none to copy then return.
-                    val annotationsToCopy =
+                    val annotationsToMerge =
                         item.modifiers.annotations().filter { annotation ->
                             val qualifiedName = annotation.qualifiedName
                             annotation.isShowabilityAnnotation() ||
                                 qualifiedName == ANDROID_FLAGGED_API
                         }
-                    if (annotationsToCopy.isEmpty()) {
+                    if (annotationsToMerge.isEmpty()) {
                         // Just because there are no annotations on an [Item] does not mean that
                         // there will not be on the children so make sure to visit them as normal.
                         return TraversalAction.CONTINUE
@@ -371,24 +336,22 @@ class AnnotationsMerger(
                                 return TraversalAction.SKIP_CHILDREN
                             }
 
-                    // Copy the annotations to the main item.
-                    val modifiers = mainItem.mutableModifiers()
-                    for (annotation in annotationsToCopy) {
-                        if (modifiers.findAnnotation(annotation.qualifiedName!!) == null) {
-                            mergeAnnotation(mainItem, annotation)
+                    // Merge the annotations to the main item, ignoring any that match, i.e. are of
+                    // the same type as, an existing annotation.
+                    mainItem.mutateModifiers {
+                        mutateAnnotations {
+                            for (annotation in annotationsToMerge) {
+                                val qualifiedName = annotation.qualifiedName
+                                if (none { it.qualifiedName == qualifiedName }) {
+                                    // TODO: This simply uses the AnnotationItem from the Codebase
+                                    //  being merged from in the Codebase being merged into. That is
+                                    //  not safe as the Codebases may be from different models.
+                                    add(annotation)
+                                }
+                            }
                         }
                     }
 
-                    // The hidden field in the main codebase is already initialized. So if the
-                    // element is hidden in the external codebase, hide it in the main codebase
-                    // too.
-                    if (item.hidden) {
-                        mainItem.hidden = true
-                    }
-                    if (item.originallyHidden) {
-                        mainItem.originallyHidden = true
-                    }
-
                     return TraversalAction.CONTINUE
                 }
             }
@@ -480,7 +443,7 @@ class AnnotationsMerger(
                     continue
                 }
 
-                mergeAnnotations(item, classItem)
+                mergeQualifierAnnotationsFromXmlElement(item, classItem)
             } else {
                 warning("No merge match for signature $signature")
             }
@@ -521,8 +484,8 @@ class AnnotationsMerger(
     ) {
         @Suppress("NAME_SHADOWING") val parameters = fixParameterString(parameters)
 
-        val methodItem: MethodItem? = classItem.findMethod(methodName, parameters)
-        if (methodItem == null) {
+        val callableItem = classItem.findCallable(methodName, parameters)
+        if (callableItem == null) {
             if (wellKnownIgnoredImport(containingClass)) {
                 return
             }
@@ -534,11 +497,11 @@ class AnnotationsMerger(
         }
 
         if (parameterIndex != -1) {
-            val parameterItem = methodItem.parameters()[parameterIndex]
-            mergeAnnotations(item, parameterItem)
+            val parameterItem = callableItem.parameters()[parameterIndex]
+            mergeQualifierAnnotationsFromXmlElement(item, parameterItem)
         } else {
             // Annotation on the method itself
-            mergeAnnotations(item, methodItem)
+            mergeQualifierAnnotationsFromXmlElement(item, callableItem)
         }
     }
 
@@ -560,7 +523,7 @@ class AnnotationsMerger(
             return
         }
 
-        mergeAnnotations(item, fieldItem)
+        mergeQualifierAnnotationsFromXmlElement(item, fieldItem)
     }
 
     private fun getAnnotationName(element: Element): String {
@@ -568,46 +531,17 @@ class AnnotationsMerger(
         assert(tagName == "annotation") { tagName }
 
         val qualifiedName = element.getAttribute(ATTR_NAME)
-        assert(qualifiedName != null && qualifiedName.isNotEmpty())
+        assert(qualifiedName.isNotEmpty())
         return qualifiedName
     }
 
-    private fun mergeAnnotations(xmlElement: Element, item: Item) {
-        loop@ for (annotationElement in getChildren(xmlElement)) {
-            val originalName = getAnnotationName(annotationElement)
-            val qualifiedName =
-                codebase.annotationManager.normalizeInputName(originalName) ?: originalName
-            if (hasNullnessConflicts(item, qualifiedName)) {
-                continue@loop
-            }
-
-            val annotationItem = createAnnotation(annotationElement) ?: continue
-            mergeAnnotation(item, annotationItem)
-        }
-    }
-
-    private fun hasNullnessConflicts(item: Item, qualifiedName: String): Boolean {
-        var haveNullable = false
-        var haveNotNull = false
-        for (existing in item.modifiers.annotations()) {
-            val name = existing.qualifiedName ?: continue
-            if (isNonNull(name)) {
-                haveNotNull = true
-            }
-            if (isNullable(name)) {
-                haveNullable = true
-            }
-            if (name == qualifiedName) {
-                return true
+    private fun mergeQualifierAnnotationsFromXmlElement(xmlElement: Element, item: Item) {
+        val annotationsToMerge =
+            getChildren(xmlElement).mapNotNull { annotationElement ->
+                createAnnotation(annotationElement)
             }
-        }
 
-        // Make sure we don't have a conflict between nullable and not nullable
-        if (isNonNull(qualifiedName) && haveNullable || isNullable(qualifiedName) && haveNotNull) {
-            warning("Found both @Nullable and @NonNull after import for $item")
-            return true
-        }
-        return false
+        mergeQualifierAnnotations(annotationsToMerge, item)
     }
 
     /**
@@ -620,7 +554,7 @@ class AnnotationsMerger(
         val tagName = annotationElement.tagName
         assert(tagName == "annotation") { tagName }
         val name = annotationElement.getAttribute(ATTR_NAME)
-        assert(name != null && name.isNotEmpty())
+        assert(name.isNotEmpty())
         when {
             name == "org.jetbrains.annotations.Range" -> {
                 val children = getChildren(annotationElement)
@@ -831,12 +765,78 @@ class AnnotationsMerger(
             name == SUPPORT_NULLABLE
     }
 
-    private fun mergeAnnotation(item: Item, annotation: AnnotationItem) {
-        item.mutableModifiers().addAnnotation(annotation)
-        if (annotation.isNullable()) {
-            item.type()?.modifiers?.setNullability(TypeNullability.NULLABLE)
-        } else if (annotation.isNonNull()) {
-            item.type()?.modifiers?.setNullability(TypeNullability.NONNULL)
+    /** Merge qualifier annotations in [annotations] into the [Item.modifiers] of [item]. */
+    private fun mergeQualifierAnnotations(annotations: List<AnnotationItem>, item: Item) {
+        if (annotations.isEmpty()) return
+
+        // Check to make sure that the annotations are not adding a conflicting type nullability.
+        val nullabilityBefore = item.modifiers.annotations().typeNullability
+        if (nullabilityBefore != null) {
+            val mergeNullability = annotations.typeNullability
+            if (mergeNullability != null && mergeNullability != nullabilityBefore) {
+                when (nullabilityBefore) {
+                    TypeNullability.NULLABLE ->
+                        reporter.report(
+                            Issues.INCONSISTENT_MERGE_ANNOTATION,
+                            item,
+                            "Merge conflict, has @Nullable (or equivalent) attempting to merge" +
+                                " @NonNull (or equivalent)"
+                        )
+                    TypeNullability.NONNULL ->
+                        reporter.report(
+                            Issues.INCONSISTENT_MERGE_ANNOTATION,
+                            item,
+                            "Merge conflict, has @NonNull (or equivalent) attempting to merge" +
+                                " @Nullable (or equivalent)"
+                        )
+                    else -> {}
+                }
+            }
+        }
+
+        item.mutateModifiers {
+            mutateAnnotations {
+                for (annotation in annotations) {
+                    // If the item already has nullness annotations then ignore any others.
+                    if (nullabilityBefore != null && annotation.isNullnessAnnotation()) continue
+
+                    // Ignore annotation that has the same type as an existing annotation.
+                    val qualifiedName = annotation.qualifiedName
+                    if (any { it.qualifiedName == qualifiedName }) continue
+
+                    val annotationToMerge =
+                        item.codebase.createAnnotation(
+                            annotation.toSource(showDefaultAttrs = false),
+                            item,
+                        )
+                            ?: continue
+
+                    add(annotationToMerge)
+                }
+            }
+        }
+
+        // Update the type nullability from the annotations, if necessary.
+        //
+        // Nullability annotations do not make sense on class definitions or in package-info.java
+        // files and in fact many nullability annotations do not support targeting them at all. Some
+        // nullability checkers do support annotating packages and classes with annotations to set
+        // the default nullability for unannotated types but Metalava does not currently support
+        // them. If it did then they would need special treatment here anyway so, for now we just
+        // ignore them.
+        if (item is ClassItem || item is PackageItem) return
+
+        // Check to make sure that the item has a type.
+        val typeItem = item.type() ?: return
+
+        // If the nullability after is null then nullability annotations cannot have been added so
+        // there is nothing to check.
+        val nullabilityAfter = item.modifiers.annotations().typeNullability ?: return
+
+        // If the type nullability has changed then update the type nullability to match.
+        if (nullabilityAfter != nullabilityBefore) {
+            // Finally, duplicate the type with the new nullability.
+            item.setType(typeItem.substitute(nullabilityAfter))
         }
     }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
index 11fbe4250..8ef4b30c8 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.manifest.emptyManifest
+import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
@@ -25,10 +26,11 @@ import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.BaseTypeVisitor
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
@@ -37,24 +39,17 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PackageList
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VariableTypeItem
-import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.psi.PsiClassItem
-import com.android.tools.metalava.model.psi.isKotlin
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
-import java.util.Collections
-import java.util.IdentityHashMap
 import java.util.Locale
 import java.util.function.Predicate
-import org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade
-import org.jetbrains.uast.UClass
 
 /**
  * The [ApiAnalyzer] is responsible for walking over the various classes and members and compute
@@ -95,9 +90,6 @@ class ApiAnalyzer(
          */
         val mergeInclusionAnnotations: List<File> = emptyList(),
 
-        /** Packages to import (if empty, include all) */
-        val stubImportPackages: Set<String> = emptySet(),
-
         /** The filter for all the show annotations. */
         val allShowAnnotations: AnnotationFilter = AnnotationFilter.emptyFilter(),
 
@@ -123,185 +115,43 @@ class ApiAnalyzer(
         propagateHiddenRemovedAndDocOnly()
     }
 
-    fun addConstructors(filter: Predicate<Item>) {
-        // Let's say we have
-        //  class GrandParent { public GrandParent(int) {} }
-        //  class Parent {  Parent(int) {} }
-        //  class Child { public Child(int) {} }
-        //
-        // Here Parent's constructor is not public. For normal stub generation we'd end up with
-        // this:
-        //  class GrandParent { public GrandParent(int) {} }
-        //  class Parent { }
-        //  class Child { public Child(int) {} }
-        //
-        // This doesn't compile - Parent can't have a default constructor since there isn't
-        // one for it to invoke on GrandParent.
-        //
-        // we can generate a fake constructor instead, such as
-        //   Parent() { super(0); }
-        //
-        // But it's hard to do this lazily; what if we're generating the Child class first?
-        // Therefore, we'll instead walk over the hierarchy and insert these constructors into the
-        // Item hierarchy such that code generation can find them.
-        //
-        // We also need to handle the throws list, so we can't just unconditionally insert package
-        // private constructors
-
-        // Keep track of all the ClassItems that have been visited so classes are only visited once.
-        val visited = Collections.newSetFromMap(IdentityHashMap<ClassItem, Boolean>())
-
-        // Add constructors to the classes by walking up the super hierarchy and recursively add
-        // constructors; we'll do it recursively to make sure that the superclass has had its
-        // constructors initialized first (such that we can match the parameter lists and throws
-        // signatures), and we use the tag fields to avoid looking at all the internal classes more
-        // than once.
-        packages
-            .allClasses()
-            .filter { filter.test(it) }
-            .forEach { addConstructors(it, filter, visited) }
-    }
-
-    /**
-     * Handle computing constructor hierarchy.
-     *
-     * We'll be setting several attributes: [ClassItem.stubConstructor] : The default constructor to
-     * invoke in this class from subclasses. **NOTE**: This constructor may not be part of the
-     * [ClassItem.constructors] list, e.g. for package private default constructors we've inserted
-     * (because there were no public constructors or constructors not using hidden parameter types.)
-     *
-     * [ConstructorItem.superConstructor] : The default constructor to invoke.
-     *
-     * @param visited contains the [ClassItem]s that have already been visited; this method adds
-     *   [cls] to it so [cls] will not be visited again.
-     */
-    private fun addConstructors(
-        cls: ClassItem,
-        filter: Predicate<Item>,
-        visited: MutableSet<ClassItem>
-    ) {
-        // What happens if we have
-        //  package foo:
-        //     public class A { public A(int) }
-        //  package bar
-        //     public class B extends A { public B(int) }
-        // If we just try inserting package private constructors here things will NOT work:
-        //  package foo:
-        //     public class A { public A(int); A() {} }
-        //  package bar
-        //     public class B extends A { public B(int); B() }
-        // because A <() is not accessible from B() -- it's outside the same package.
-        //
-        // So, we'll need to model the real constructors for all the scenarios where that works.
-        //
-        // The remaining challenge is that there will be some gaps: when we don't have a default
-        // constructor, subclass constructors will have to have an explicit super(args) call to pick
-        // the parent constructor to use. And which one? It generally doesn't matter; just pick one,
-        // but unfortunately, the super constructor can throw exceptions, and in that case the
-        // subclass constructor must also throw all those exceptions (you can't surround a super
-        // call with try/catch.)
-        //
-        // Luckily, this does not seem to be an actual problem with any of the source code that
-        // metalava currently processes. If it did become a problem then the solution would be to
-        // pick super constructors with a compatible set of throws.
-
-        if (cls in visited) {
-            return
-        }
-
-        // Don't add constructors to interfaces, enums, annotations, etc
-        if (!cls.isClass()) {
-            return
-        }
-
-        // Remember that we have visited this class so that it is not visited again. This does not
-        // strictly need to be done before visiting the super classes as there should not be cycles
-        // in the class hierarchy. However, if due to some invalid input there is then doing this
-        // here will prevent those cycles from causing a stack overflow.
-        visited.add(cls)
-
-        // First handle its super class hierarchy to make sure that we've already constructed super
-        // classes.
-        val superClass = cls.filteredSuperclass(filter)
-        superClass?.let { addConstructors(it, filter, visited) }
-
-        val superDefaultConstructor = superClass?.stubConstructor
-        if (superDefaultConstructor != null) {
-            cls.constructors().forEach { constructor ->
-                constructor.superConstructor = superDefaultConstructor
-            }
-        }
-
-        // Find default constructor, if one doesn't exist
-        val filteredConstructors = cls.filteredConstructors(filter).toList()
-        cls.stubConstructor =
-            if (filteredConstructors.isNotEmpty()) {
-                // Try to pick the constructor, select first by fewest throwables,
-                // then fewest parameters, then based on order in listFilter.test(cls)
-                filteredConstructors.reduce { first, second -> pickBest(first, second) }
-            } else if (
-                cls.constructors().isNotEmpty() ||
-                    // For text based codebase, stub constructor needs to be generated even if
-                    // cls.constructors() is empty, so that public default constructor is not
-                    // created.
-                    cls.codebase.preFiltered
-            ) {
-
-                // No accessible constructors are available so a package private constructor is
-                // created. Technically, the stub now has a constructor that isn't available at
-                // runtime, but apps creating subclasses inside the android.* package is not
-                // supported.
-                cls.createDefaultConstructor().also {
-                    it.mutableModifiers().setVisibilityLevel(VisibilityLevel.PACKAGE_PRIVATE)
-                    it.hidden = false
-                    it.superConstructor = superDefaultConstructor
-                }
-            } else {
-                null
-            }
-    }
-
     // TODO: Annotation test: @ParameterName, if present, must be supplied on *all* the arguments!
     // Warn about @DefaultValue("null"); they probably meant @DefaultNull
     // Supplying default parameter in override is not allowed!
 
-    private fun pickBest(current: ConstructorItem, next: ConstructorItem): ConstructorItem {
-        val currentThrowsCount = current.throwsTypes().size
-        val nextThrowsCount = next.throwsTypes().size
-
-        return if (currentThrowsCount < nextThrowsCount) {
-            current
-        } else if (currentThrowsCount > nextThrowsCount) {
-            next
-        } else {
-            val currentParameterCount = current.parameters().size
-            val nextParameterCount = next.parameters().size
-            if (currentParameterCount <= nextParameterCount) {
-                current
-            } else next
-        }
-    }
-
     fun generateInheritedStubs(filterEmit: Predicate<Item>, filterReference: Predicate<Item>) {
         // When analyzing libraries we may discover some new classes during traversal; these aren't
         // part of the API but may be super classes or interfaces; these will then be added into the
         // package class lists, which could trigger a concurrent modification, so create a snapshot
         // of the class list and iterate over it:
         val allClasses = packages.allClasses().toList()
-        allClasses.forEach {
-            if (filterEmit.test(it)) {
-                generateInheritedStubs(it, filterEmit, filterReference)
-            }
-        }
+
+        val visited = mutableSetOf<ClassItem>()
+        allClasses.forEach { generateInheritedStubs(it, filterEmit, filterReference, visited) }
     }
 
     private fun generateInheritedStubs(
         cls: ClassItem,
         filterEmit: Predicate<Item>,
-        filterReference: Predicate<Item>
+        filterReference: Predicate<Item>,
+        visited: MutableSet<ClassItem>,
     ) {
+        // If it is not a class, i.e. an interface, etc., then return.
         if (!cls.isClass()) return
-        if (cls.superClass() == null) return
+
+        // If already visited this class then ignore it. Otherwise, remember that this was visited.
+        if (cls in visited) return
+        visited += cls
+
+        // If it has no super class then ignore it.
+        val superClass = cls.superClass() ?: return
+
+        // If the class is not going to be emitted then do not inherit any methods into it.
+        if (!filterEmit.test(cls)) return
+
+        // Make sure that the super class has inherited the stubs and interfaces.
+        generateInheritedStubs(superClass, filterEmit, filterReference, visited)
+
         val allSuperClasses = cls.allSuperClasses()
         val hiddenSuperClasses =
             allSuperClasses.filter { !filterReference.test(it) && !it.isJavaLangObject() }
@@ -372,19 +222,11 @@ class ApiAnalyzer(
         // doesn't actually implement the interface, but still provides a matching signature for the
         // interface. Instead, we'll look through all of our interface methods and look for
         // potential overrides.
-        val interfaceNames = mutableMapOf<String, MutableList<MethodItem>>()
+        val inheritableMethods = MethodItemSet()
         for (interfaceType in interfaces) {
             val interfaceClass = interfaceType.asClass() ?: continue
             for (method in interfaceClass.methods()) {
-                val name = method.name()
-                val list =
-                    interfaceNames[name]
-                        ?: run {
-                            val list = ArrayList<MethodItem>()
-                            interfaceNames[name] = list
-                            list
-                        }
-                list.add(method)
+                inheritableMethods.add(method)
             }
         }
 
@@ -396,15 +238,7 @@ class ApiAnalyzer(
                 if (!method.modifiers.isAbstract() || !method.modifiers.isPublicOrProtected()) {
                     continue
                 }
-                val name = method.name()
-                val list =
-                    interfaceNames[name]
-                        ?: run {
-                            val list = ArrayList<MethodItem>()
-                            interfaceNames[name] = list
-                            list
-                        }
-                list.add(method)
+                inheritableMethods.add(method)
             }
         }
 
@@ -433,46 +267,22 @@ class ApiAnalyzer(
                     continue
                 }
 
-                val name = method.name()
-                val list =
-                    interfaceNames[name]
-                        ?: run {
-                            val list = ArrayList<MethodItem>()
-                            interfaceNames[name] = list
-                            list
-                        }
-                list.add(method)
+                inheritableMethods.add(method)
             }
         }
 
-        // Find all methods that are inherited from these classes into our class
-        // (making sure that we don't have duplicates, e.g. a method defined by one
-        // inherited class and then overridden by another closer one).
-        // map from method name to super methods overriding our interfaces
-        val map = HashMap<String, MutableList<MethodItem>>()
+        // Find all methods that are inherited from these classes into our class (making sure that
+        // we don't have duplicates, e.g. a method defined by one inherited class and then
+        // overridden by another closer one). map from method name to super methods overriding our
+        // interfaces
+        val inheritedMethods = MethodItemSet()
 
         for (superClass in hiddenSuperClasses) {
             for (method in superClass.methods()) {
                 val modifiers = method.modifiers
                 if (!modifiers.isPrivate() && !modifiers.isAbstract()) {
-                    val name = method.name()
-                    val candidates = interfaceNames[name] ?: continue
-                    val parameterCount = method.parameters().size
-                    for (superMethod in candidates) {
-                        if (parameterCount != superMethod.parameters().count()) {
-                            continue
-                        }
-                        if (method.matches(superMethod)) {
-                            val list =
-                                map[name]
-                                    ?: run {
-                                        val newList = ArrayList<MethodItem>()
-                                        map[name] = newList
-                                        newList
-                                    }
-                            list.add(method)
-                            break
-                        }
+                    if (inheritableMethods.containsMatchingMethod(method)) {
+                        inheritedMethods.add(method)
                     }
                 }
             }
@@ -480,21 +290,12 @@ class ApiAnalyzer(
 
         // Remove any methods that are overriding any of our existing methods
         for (method in cls.methods()) {
-            val name = method.name()
-            val candidates = map[name] ?: continue
-            val iterator = candidates.listIterator()
-            while (iterator.hasNext()) {
-                val inheritedMethod = iterator.next()
-                if (method.matches(inheritedMethod)) {
-                    iterator.remove()
-                }
-            }
+            inheritedMethods.removeMatchingMethods(method)
         }
 
         // Next remove any overrides among the remaining super methods (e.g. one method from a
-        // hidden parent is
-        // overriding another method from a more distant hidden parent).
-        map.values.forEach { methods ->
+        // hidden parent is overriding another method from a more distant hidden parent).
+        inheritedMethods.values.forEach { methods ->
             if (methods.size >= 2) {
                 for (candidate in ArrayList(methods)) {
                     for (superMethod in candidate.allSuperMethods()) {
@@ -504,45 +305,33 @@ class ApiAnalyzer(
             }
         }
 
-        val existingMethodMap = HashMap<String, MutableList<MethodItem>>()
+        // Add all the existing methods in the class to the set of existing methods.
+        val existingMethods = MethodItemSet()
         for (method in cls.methods()) {
-            val name = method.name()
-            val list =
-                existingMethodMap[name]
-                    ?: run {
-                        val newList = ArrayList<MethodItem>()
-                        existingMethodMap[name] = newList
-                        newList
-                    }
-            list.add(method)
+            existingMethods.add(method)
         }
 
         // We're now left with concrete methods in hidden parents that are implementing methods in
-        // public
-        // interfaces that are listed in this class. Create stubs for them:
-        map.values.flatten().forEach {
-            val method = cls.inheritMethodFromNonApiAncestor(it)
+        // public interfaces that are listed in this class. Create stubs for them:
+        inheritedMethods.values.flatten().forEach {
+            // Copy the method from the hidden class that is not part of the API into the class that
+            // is part of the API.
+            val method = it.duplicate(cls)
             /* Insert comment marker: This is useful for debugging purposes but doesn't
                belong in the stub
             method.documentation = "// Inlined stub from hidden parent class ${it.containingClass().qualifiedName()}\n" +
                     method.documentation
              */
 
-            val name = method.name()
-            val candidates = existingMethodMap[name]
-            if (candidates != null) {
-                val iterator = candidates.listIterator()
-                while (iterator.hasNext()) {
-                    val inheritedMethod = iterator.next()
-                    if (method.matches(inheritedMethod)) {
-                        // If we already have an override of this method, do not add it to the
-                        // methods list
-                        return@forEach
-                    }
-                }
+            // If we already have an override of this method, do not add it to the methods list
+            if (existingMethods.containsMatchingMethod(method)) {
+                return@forEach
             }
 
             cls.addMethod(method)
+
+            // Make sure that the same method is not added from multiple super classes.
+            existingMethods.add(method)
         }
     }
 
@@ -557,12 +346,8 @@ class ApiAnalyzer(
     /** If a file facade class has no public members, don't add it to the api */
     private fun hideEmptyKotlinFileFacadeClasses() {
         codebase.getPackages().allClasses().forEach { cls ->
-            val psi = (cls as? PsiClassItem)?.psi()
             if (
-                psi != null &&
-                    psi.isKotlin() &&
-                    psi is UClass &&
-                    psi.javaPsi is KtLightClassForFacade &&
+                cls.isFileFacade() &&
                     // a facade class needs to be emitted if it has any top-level fun/prop to emit
                     cls.members().none { member ->
                         // a member needs to be emitted if
@@ -587,7 +372,7 @@ class ApiAnalyzer(
         val mergeQualifierAnnotations = config.mergeQualifierAnnotations
         if (mergeQualifierAnnotations.isNotEmpty()) {
             AnnotationsMerger(sourceParser, codebase, reporter)
-                .mergeQualifierAnnotations(mergeQualifierAnnotations)
+                .mergeQualifierAnnotationsFromFiles(mergeQualifierAnnotations)
         }
     }
 
@@ -596,7 +381,7 @@ class ApiAnalyzer(
         val mergeInclusionAnnotations = config.mergeInclusionAnnotations
         if (mergeInclusionAnnotations.isNotEmpty()) {
             AnnotationsMerger(sourceParser, codebase, reporter)
-                .mergeInclusionAnnotations(mergeInclusionAnnotations)
+                .mergeInclusionAnnotationsFromFiles(mergeInclusionAnnotations)
         }
     }
 
@@ -605,159 +390,34 @@ class ApiAnalyzer(
      * methods and fields are hidden etc
      */
     private fun propagateHiddenRemovedAndDocOnly() {
-        packages.accept(
-            object : BaseItemVisitor(visitConstructorsAsMethods = true, nestInnerClasses = true) {
+        // Create a visitor to propagate hidden and docOnly from the containing package onto the top
+        // level classes and then propagate them, and removed status, down onto the nested classes
+        // and members.
+        val visitor =
+            object : BaseItemVisitor(preserveClassNesting = true) {
+
                 override fun visitPackage(pkg: PackageItem) {
-                    when {
-                        config.hidePackages.contains(pkg.qualifiedName()) -> pkg.hidden = true
-                        else -> {
-                            val showability = pkg.showability
-                            when {
-                                showability.show() -> pkg.hidden = false
-                                showability.hide() -> pkg.hidden = true
-                            }
-                        }
-                    }
-                    val containingPackage = pkg.containingPackage()
-                    if (containingPackage != null) {
-                        if (containingPackage.hidden && !containingPackage.isDefault) {
-                            pkg.hidden = true
-                        }
-                        if (containingPackage.docOnly) {
-                            pkg.docOnly = true
-                        }
-                    }
+                    pkg.variantSelectors.inheritInto()
                 }
 
                 override fun visitClass(cls: ClassItem) {
-                    val containingClass = cls.containingClass()
-                    val showability = cls.showability
-                    if (showability.show()) {
-                        cls.hidden = false
-                        // Make containing package non-hidden if it contains a show-annotation
-                        // class. Doclava does this in PackageInfo.isHidden().
-                        cls.containingPackage().hidden = false
-                        if (containingClass != null) {
-                            ensureParentVisible(cls)
-                        }
-                    } else if (showability.hide()) {
-                        cls.hidden = true
-                    } else if (containingClass != null) {
-                        if (containingClass.hidden) {
-                            cls.hidden = true
-                        } else if (
-                            containingClass.originallyHidden &&
-                                containingClass.hasShowSingleAnnotation()
-                        ) {
-                            // See explanation in visitMethod
-                            cls.hidden = true
-                        }
-                        if (containingClass.docOnly) {
-                            cls.docOnly = true
-                        }
-                        if (containingClass.removed) {
-                            cls.removed = true
-                        }
-                    } else {
-                        val containingPackage = cls.containingPackage()
-                        if (containingPackage.hidden && !containingPackage.isDefault) {
-                            cls.hidden = true
-                        } else if (containingPackage.originallyHidden) {
-                            // Package was marked hidden; it's been unhidden by some other
-                            // classes (marked with show annotations) but this class
-                            // should continue to default.
-                            cls.hidden = true
-                        }
-                        if (containingPackage.docOnly && !containingPackage.isDefault) {
-                            cls.docOnly = true
-                        }
-                        if (containingPackage.removed && !showability.show()) {
-                            cls.removed = true
-                        }
-                    }
+                    cls.variantSelectors.inheritInto()
                 }
 
-                override fun visitMethod(method: MethodItem) {
-                    val showability = method.showability
-                    if (showability.show()) {
-                        method.hidden = false
-                        ensureParentVisible(method)
-                    } else if (showability.hide()) {
-                        method.hidden = true
-                    } else {
-                        val containingClass = method.containingClass()
-                        if (containingClass.hidden) {
-                            method.hidden = true
-                        } else if (
-                            containingClass.originallyHidden &&
-                                containingClass.hasShowSingleAnnotation()
-                        ) {
-                            // This is a member in a class that was hidden but then unhidden;
-                            // but it was unhidden by a non-recursive (single) show annotation, so
-                            // don't inherit the show annotation into this item.
-                            method.hidden = true
-                        }
-                        if (containingClass.docOnly) {
-                            method.docOnly = true
-                        }
-                        if (containingClass.removed) {
-                            method.removed = true
-                        }
-                    }
+                override fun visitCallable(callable: CallableItem) {
+                    callable.variantSelectors.inheritInto()
                 }
 
                 override fun visitField(field: FieldItem) {
-                    val showability = field.showability
-                    if (showability.show()) {
-                        field.hidden = false
-                        ensureParentVisible(field)
-                    } else if (showability.hide()) {
-                        field.hidden = true
-                    } else {
-                        val containingClass = field.containingClass()
-                        if (
-                            containingClass.originallyHidden &&
-                                containingClass.hasShowSingleAnnotation()
-                        ) {
-                            // See explanation in visitMethod
-                            field.hidden = true
-                        }
-                        if (containingClass.docOnly) {
-                            field.docOnly = true
-                        }
-                        if (containingClass.removed) {
-                            field.removed = true
-                        }
-                    }
-                }
-
-                private fun ensureParentVisible(item: Item) {
-                    val parent = item.parent() ?: return
-                    if (!parent.hidden) {
-                        return
-                    }
-                    item.modifiers.findAnnotation(AnnotationItem::isShowAnnotation)?.let {
-                        violatingAnnotation ->
-                        reporter.report(
-                            Issues.SHOWING_MEMBER_IN_HIDDEN_CLASS,
-                            item,
-                            "Attempting to unhide ${item.describe()}, but surrounding ${parent.describe()} is " +
-                                "hidden and should also be annotated with $violatingAnnotation"
-                        )
-                    }
+                    field.variantSelectors.inheritInto()
                 }
             }
-        )
+
+        codebase.accept(visitor)
     }
 
     private fun checkSystemPermissions(method: MethodItem) {
-        if (
-            method.isImplicitConstructor()
-        ) { // Don't warn on non-source elements like implicit default constructors
-            return
-        }
-
-        val annotation = method.modifiers.findAnnotation(ANDROID_REQUIRES_PERMISSION)
+        val annotation = method.modifiers.findAnnotation(ANDROIDX_REQUIRES_PERMISSION)
         var hasAnnotation = false
 
         if (annotation != null) {
@@ -855,7 +515,7 @@ class ApiAnalyzer(
             !reporter.isSuppressed(Issues.UNHIDDEN_SYSTEM_API) &&
                 config.allShowAnnotations.isNotEmpty()
 
-        packages.accept(
+        codebase.accept(
             object :
                 ApiVisitor(
                     config = @Suppress("DEPRECATION") options.apiVisitorConfig,
@@ -916,7 +576,7 @@ class ApiAnalyzer(
                         checkHiddenShowAnnotations &&
                             item.hasShowAnnotation() &&
                             !item.originallyHidden &&
-                            !item.hasShowSingleAnnotation()
+                            !item.showability.showNonRecursive()
                     ) {
                         item.modifiers
                             .annotations()
@@ -969,36 +629,10 @@ class ApiAnalyzer(
                 }
 
                 override fun visitMethod(method: MethodItem) {
-                    if (!method.isConstructor()) {
-                        checkTypeReferencesHidden(
-                            method,
-                            method.returnType()
-                        ) // returnType is nullable only for constructors
-                    }
-
-                    // Make sure we don't annotate findViewById & getSystemService as @Nullable.
-                    // See for example b/68914170.
-                    val name = method.name()
-                    if (
-                        (name == "findViewById" || name == "getSystemService") &&
-                            method.parameters().size == 1 &&
-                            method.returnType().modifiers.isNullable
-                    ) {
-                        reporter.report(
-                            Issues.EXPECTED_PLATFORM_TYPE,
-                            method,
-                            "$method should not be annotated @Nullable; it should be left unspecified to make it a platform type"
-                        )
-                        val annotation = method.modifiers.findAnnotation(AnnotationItem::isNullable)
-                        annotation?.let { method.mutableModifiers().removeAnnotation(it) }
-                        // Have to also clear the annotation out of the return type itself, if it's
-                        // a type use annotation
-                        val typeAnnotation =
-                            method.returnType().modifiers.annotations().singleOrNull {
-                                it.isNullnessAnnotation()
-                            }
-                        typeAnnotation?.let { method.returnType().modifiers.removeAnnotation(it) }
-                    }
+                    checkTypeReferencesHidden(
+                        method,
+                        method.returnType()
+                    ) // returnType is nullable only for constructors
                 }
 
                 /** Check that the type doesn't refer to any hidden classes. */
@@ -1007,7 +641,10 @@ class ApiAnalyzer(
                         object : BaseTypeVisitor() {
                             override fun visitClassType(classType: ClassTypeItem) {
                                 val cls = classType.asClass() ?: return
-                                if (!filterReference.test(cls) && !cls.isFromClassPath()) {
+                                if (
+                                    !filterReference.test(cls) &&
+                                        cls.origin != ClassOrigin.CLASS_PATH
+                                ) {
                                     reporter.report(
                                         Issues.HIDDEN_TYPE_PARAMETER,
                                         item,
@@ -1110,12 +747,7 @@ class ApiAnalyzer(
         from: Item,
         usage: String
     ) {
-        if (config.stubImportPackages.contains(cl.containingPackage().qualifiedName())) {
-            // if the package is imported then it does not need stubbing.
-            return
-        }
-
-        if (cl.isFromClassPath()) {
+        if (cl.origin == ClassOrigin.CLASS_PATH) {
             return
         }
 
@@ -1155,9 +787,9 @@ class ApiAnalyzer(
             cantStripThis(containingClass, filter, notStrippable, cl, "as containing class")
         }
         // all visible inner classes will be included in stubs
-        cl.innerClasses()
+        cl.nestedClasses()
             .filter { it.isApiCandidate() }
-            .forEach { cantStripThis(it, filter, notStrippable, cl, "as inner class") }
+            .forEach { cantStripThis(it, filter, notStrippable, cl, "as nested class") }
         // blow open super class and interfaces
         // TODO: Consider using val superClass = cl.filteredSuperclass(filter)
         val superItems = cl.allInterfaces().toMutableSet()
@@ -1170,7 +802,7 @@ class ApiAnalyzer(
                 // this is not a desired practice, but it's happened, so we deal
                 // with it by finding the first super class which passes checkLevel for purposes of
                 // generating the doc & stub information, and proceeding normally.
-                if (!superItem.isFromClassPath()) {
+                if (superItem.origin != ClassOrigin.CLASS_PATH) {
                     reporter.report(
                         Issues.HIDDEN_SUPERCLASS,
                         cl,
@@ -1187,7 +819,7 @@ class ApiAnalyzer(
                 //   cantStripThis(superClass, filter, notStrippable, stubImportPackages, cl, "as
                 // super class")
 
-                if (superItem.isPrivate && !superItem.isFromClassPath()) {
+                if (superItem.isPrivate && superItem.origin != ClassOrigin.CLASS_PATH) {
                     reporter.report(
                         Issues.PRIVATE_SUPERCLASS,
                         cl,
@@ -1202,18 +834,18 @@ class ApiAnalyzer(
     }
 
     private fun cantStripThis(
-        methods: List<MethodItem>,
+        callables: List<CallableItem>,
         filter: Predicate<Item>,
         notStrippable: MutableSet<ClassItem>,
     ) {
-        // for each method, blow open the parameters, throws and return types. also blow open their
-        // generics
-        for (method in methods) {
-            if (!filter.test(method)) {
+        // for each callable, blow open the parameters, throws and return types. also blow open
+        // their generics
+        for (callable in callables) {
+            if (!filter.test(callable)) {
                 continue
             }
-            cantStripThis(method.typeParameterList, filter, notStrippable, method)
-            for (parameter in method.parameters()) {
+            cantStripThis(callable.typeParameterList, filter, notStrippable, callable)
+            for (parameter in callable.parameters()) {
                 cantStripThis(
                     parameter.type(),
                     parameter,
@@ -1222,12 +854,12 @@ class ApiAnalyzer(
                     "in parameter type"
                 )
             }
-            for (thrown in method.throwsTypes()) {
+            for (thrown in callable.throwsTypes()) {
                 if (thrown is VariableTypeItem) continue
                 val classItem = thrown.erasedClass ?: continue
-                cantStripThis(classItem, filter, notStrippable, method, "as exception")
+                cantStripThis(classItem, filter, notStrippable, callable, "as exception")
             }
-            cantStripThis(method.returnType(), method, filter, notStrippable, "in return type")
+            cantStripThis(callable.returnType(), callable, filter, notStrippable, "in return type")
         }
     }
 
@@ -1289,7 +921,7 @@ class ApiAnalyzer(
         val hiddenClasses = findHiddenClasses(type)
         val typeClassName = (type as? ClassTypeItem)?.qualifiedName
         for (hiddenClass in hiddenClasses) {
-            if (hiddenClass.isFromClassPath()) continue
+            if (hiddenClass.origin == ClassOrigin.CLASS_PATH) continue
             if (hiddenClass.qualifiedName() == typeClassName) {
                 // The type itself is hidden
                 reporter.report(
@@ -1328,13 +960,6 @@ class ApiAnalyzer(
             object : BaseTypeVisitor() {
                 override fun visitClassType(classType: ClassTypeItem) {
                     val asClass = classType.asClass() ?: return
-                    if (
-                        config.stubImportPackages.contains(
-                            asClass.containingPackage().qualifiedName()
-                        )
-                    ) {
-                        return
-                    }
                     if (asClass.isHiddenOrRemoved()) {
                         hiddenClasses.add(asClass)
                     }
@@ -1356,7 +981,7 @@ private fun String.capitalize(): String {
 }
 
 /** Returns true if this item is public or protected and so a candidate for inclusion in an API. */
-private fun Item.isApiCandidate(): Boolean {
+private fun SelectableItem.isApiCandidate(): Boolean {
     return !isHiddenOrRemoved() && (modifiers.isPublic() || modifiers.isProtected())
 }
 
@@ -1365,9 +990,58 @@ private fun Item.isApiCandidate(): Boolean {
  * also looks at any inherited documentation.
  */
 private fun Item.documentationContainsDeprecated(): Boolean {
-    if (documentation.contains("@deprecated")) return true
-    if (this is MethodItem && (documentation == "" || documentation.contains("@inheritDoc"))) {
+    val text = documentation.text
+    if (text.contains("@deprecated")) return true
+    if (this is MethodItem && (text == "" || text.contains("@inheritDoc"))) {
         return superMethods().any { it.documentationContainsDeprecated() }
     }
     return false
 }
+
+/**
+ * A set of [MethodItem]s.
+ *
+ * This is implemented as a [MutableMap] from the [MethodItem.name] to the list of [MethodItem]s
+ * with that name.
+ */
+private typealias MethodItemSet = HashMap<String, MutableList<MethodItem>>
+
+/**
+ * Add a method to the set.
+ *
+ * This does not check to see if the [MethodItem] exists already so it is possible that it will
+ * contain duplicate methods.
+ */
+private fun MethodItemSet.add(method: MethodItem) {
+    val name = method.name()
+    val list = computeIfAbsent(name) { mutableListOf() }
+    list.add(method)
+}
+
+/**
+ * Check to see whether the set contains a method that matches [method] as determined by
+ * [MethodItem.matches].
+ */
+private fun MethodItemSet.containsMatchingMethod(method: MethodItem): Boolean {
+    val name = method.name()
+    val list = this[name] ?: return false
+    for (existing in list) {
+        if (method.matches(existing)) {
+            return true
+        }
+    }
+    return false
+}
+
+/** Remove any method that matches [method] as determined by [MethodItem.matches]. */
+private fun MethodItemSet.removeMatchingMethods(method: MethodItem) {
+    val name = method.name()
+    val list = this[name] ?: return
+    val iterator = list.listIterator()
+    while (iterator.hasNext()) {
+        val existing = iterator.next()
+        if (method.matches(existing)) {
+            iterator.remove()
+        }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt b/metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt
index 36d9b7383..207cef4c2 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt
@@ -17,12 +17,13 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ClassContentItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.model.TypeParameterItem
+import com.android.tools.metalava.model.SelectableItem
 import java.util.function.Predicate
 
 /**
@@ -82,41 +83,46 @@ class ApiPredicate(
         val addAdditionalOverrides: Boolean = false,
     )
 
-    override fun test(member: Item): Boolean {
+    override fun test(item: Item): Boolean {
         // non-class, i.e., (literally) member declaration w/o emit flag, e.g., due to `expect`
         // Some [ClassItem], e.g., JvmInline, java.lang.* classes, may not set the emit flag.
-        if (member !is ClassItem && !member.emit) {
+        if (item !is ClassItem && !item.emit) {
             return false
         }
 
-        // Type Parameter references (e.g. T) aren't actual types, skip all visibility checks
-        if (member is TypeParameterItem) {
+        // If the item is not individually selectable (i.e. ParameterItem and TypeParameterItem)
+        // then whether it is included will always be determined by its owner. If it got to this
+        // point the chances are that its owner was selected, so just assume this is too.
+        if (item !is SelectableItem) {
             return true
         }
 
-        if (!config.allowClassesFromClasspath && member.isFromClassPath()) {
+        if (
+            !config.allowClassesFromClasspath &&
+                item is ClassContentItem &&
+                // This disallows classes from the source path not just the class path, contrary to
+                // what might be expected from the config property name.
+                item.origin != ClassOrigin.COMMAND_LINE
+        ) {
             return false
         }
 
         val visibleForAdditionalOverridePurpose =
             if (config.addAdditionalOverrides) {
-                member is MethodItem &&
-                    !member.isConstructor() &&
-                    member.isRequiredOverridingMethodForTextStub()
+                item is MethodItem && item.isRequiredOverridingMethodForTextStub()
             } else {
                 false
             }
 
-        var visible =
-            member.isPublic ||
-                member.isProtected ||
-                (member.isInternal &&
-                    member.hasShowAnnotation()) // TODO: Should this use checkLevel instead?
-        var hidden = member.hidden && !visibleForAdditionalOverridePurpose
-        if (!visible || hidden) {
-            return false
-        }
-        if (!includeApisForStubPurposes && includeOnlyForStubPurposes(member)) {
+        val itemSelectors = item.variantSelectors
+
+        // If the item or any of its containing classes are inaccessible then ignore it.
+        if (!itemSelectors.accessible) return false
+
+        var hidden = itemSelectors.hidden && !visibleForAdditionalOverridePurpose
+        if (hidden) return false
+
+        if (!includeApisForStubPurposes && includeOnlyForStubPurposes(item)) {
             return false
         }
 
@@ -127,57 +133,45 @@ class ApiPredicate(
         // Only the class definition is marked visible, and class attributes are
         // not affected.
         if (
-            member is ClassItem &&
-                member.superClass()?.let {
+            item is ClassItem &&
+                item.superClass()?.let {
                     it.hasShowAnnotation() && !includeOnlyForStubPurposes(it)
                 } == true
         ) {
-            return member.removed == matchRemoved
+            return itemSelectors.removed == matchRemoved
         }
 
-        var hasShowAnnotation = config.ignoreShown || member.hasShowAnnotation()
-        var docOnly = member.docOnly
-        var removed = member.removed
+        // If docOnly items are not included and this item is docOnly then ignore it.
+        if (!includeDocOnly && itemSelectors.docOnly) return false
+
+        // If removed status is not ignored and this item's status does not match what is required
+        // then ignore this item.
+        if (!ignoreRemoved && itemSelectors.removed != matchRemoved) return false
 
-        var clazz: ClassItem? =
-            when (member) {
-                is MemberItem -> member.containingClass()
-                is ClassItem -> member
+        val closestClass: ClassItem? =
+            when (item) {
+                is MemberItem -> item.containingClass()
+                is ClassItem -> item
                 else -> null
             }
 
-        if (clazz != null) {
-            var pkg: PackageItem? = clazz.containingPackage()
-            while (pkg != null) {
-                hidden = hidden or pkg.hidden
-                docOnly = docOnly or pkg.docOnly
-                removed = removed or pkg.removed
-                pkg = pkg.containingPackage()
+        if (!config.ignoreShown) {
+            var hasShowAnnotation = item.hasShowAnnotation()
+            var showClass = closestClass
+            while (showClass != null && !hasShowAnnotation) {
+                hasShowAnnotation = showClass.hasShowAnnotation()
+                showClass = showClass.containingClass()
             }
-        }
-        while (clazz != null) {
-            visible =
-                visible and
-                    (clazz.isPublic ||
-                        clazz.isProtected ||
-                        (clazz.isInternal && clazz.hasShowAnnotation()))
-            hasShowAnnotation =
-                hasShowAnnotation or (config.ignoreShown || clazz.hasShowAnnotation())
-            hidden = hidden or clazz.hidden
-            docOnly = docOnly or clazz.docOnly
-            removed = removed or clazz.removed
-            clazz = clazz.containingClass()
-        }
-
-        if (ignoreRemoved) {
-            removed = matchRemoved
+            if (!hasShowAnnotation) return false
         }
 
-        if (docOnly && includeDocOnly) {
-            docOnly = false
+        var hiddenClass = closestClass
+        while (hiddenClass != null) {
+            if (hiddenClass.hidden) return false
+            hiddenClass = hiddenClass.containingClass()
         }
 
-        return visible && hasShowAnnotation && !hidden && !docOnly && removed == matchRemoved
+        return true
     }
 
     /**
@@ -185,7 +179,7 @@ class ApiPredicate(
      * have at least one [AnnotationItem.isShowAnnotation] annotation and all those annotations are
      * also an [AnnotationItem.isShowForStubPurposes] annotation.
      */
-    private fun includeOnlyForStubPurposes(item: Item): Boolean {
+    private fun includeOnlyForStubPurposes(item: SelectableItem): Boolean {
         if (!item.codebase.annotationManager.hasAnyStubPurposesAnnotations()) {
             return false
         }
@@ -193,7 +187,7 @@ class ApiPredicate(
         return includeOnlyForStubPurposesRecursive(item)
     }
 
-    private fun includeOnlyForStubPurposesRecursive(item: Item): Boolean {
+    private fun includeOnlyForStubPurposesRecursive(item: SelectableItem): Boolean {
         // Get the item's API membership. If it belongs to an API surface then return `true` if the
         // API surface to which it belongs is the base API, and false otherwise.
         val membership = item.apiMembership()
@@ -237,7 +231,7 @@ class ApiPredicate(
     }
 
     /** Get the API to which this [Item] belongs, according to the annotations. */
-    private fun Item.apiMembership(): ApiMembership {
+    private fun SelectableItem.apiMembership(): ApiMembership {
         // If the item has a "show" annotation, then return whether it *only* has a "for stubs"
         // show annotation or not.
         //
diff --git a/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt b/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt
new file mode 100644
index 000000000..37437bacd
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.source.EnvironmentManager
+import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.Issues.Category
+import com.android.tools.metalava.reporter.Reportable
+import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.reporter.Severity
+
+/**
+ * A special [Reporter] that is passed to [EnvironmentManager.createSourceParser] which will in turn
+ * be passed through and be accessible as [Codebase.reporter].
+ *
+ * This will redirect the reports based on the [Category] to an appropriate [Reporter]. This is
+ * needed because a [Reporter] will produce a custom error message if any errors were reported
+ * through it and reporting an inappropriate issues could cause confusion. e.g. reporting an
+ * unresolved import through an API Lint [Reporter] would suggest that it be resolved by using
+ * `@SuppressWarnings` but that would not work.
+ *
+ * Issues in the [Category.COMPATIBILITY] should only be reported from the specific compatibility
+ * check not within the [Codebase] so attempting to report one of them will result in an error.
+ */
+class CategoryRedirectingReporter(
+    /** Destination for [Issues.Issue] in [Category.UNKNOWN]. */
+    private val defaultReporter: Reporter,
+    /** Destination for [Issues.Issue] in [Category.API_LINT] and [Category.DOCUMENTATION]. */
+    private val apiLintReporter: Reporter = defaultReporter,
+    /** Destination for [Issues.Issue] in [Category.COMPATIBILITY]. */
+    private val compatibilityReporter: Reporter = defaultReporter,
+) : Reporter {
+
+    override fun report(
+        id: Issues.Issue,
+        reportable: Reportable?,
+        message: String,
+        location: FileLocation,
+        maximumSeverity: Severity
+    ) =
+        when (id.category) {
+            Category.API_LINT,
+            Category.DOCUMENTATION ->
+                apiLintReporter.report(id, reportable, message, location, maximumSeverity)
+            Category.COMPATIBILITY ->
+                compatibilityReporter.report(id, reportable, message, location, maximumSeverity)
+            else -> defaultReporter.report(id, reportable, message, location, maximumSeverity)
+        }
+
+    override fun isSuppressed(id: Issues.Issue, reportable: Reportable?, message: String?) =
+        // It does not matter which reporter this is delegated to as it only depends on the
+        // reportable and the issue configuration which is identical for both.
+        defaultReporter.isSuppressed(id, reportable, message)
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt b/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
index 8b067a792..644aa4077 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
@@ -34,20 +35,7 @@ import java.util.function.Predicate
  * Visitor which visits all items in two matching codebases and matches up the items and invokes
  * [compare] on each pair, or [added] or [removed] when items are not matched
  */
-open class ComparisonVisitor(
-    /**
-     * Whether constructors should be visited as part of a [#visitMethod] call instead of just a
-     * [#visitConstructor] call. Helps simplify visitors that don't care to distinguish between the
-     * two cases. Defaults to true.
-     */
-    val visitConstructorsAsMethods: Boolean = true,
-    /**
-     * Normally if a new item is found, the visitor will only visit the top level newly added item,
-     * not all of its children. This flags enables you to request all individual items to also be
-     * visited.
-     */
-    val visitAddedItemsRecursively: Boolean = false
-) {
+open class ComparisonVisitor {
     open fun compare(old: Item, new: Item) {}
 
     open fun added(new: Item) {}
@@ -58,6 +46,8 @@ open class ComparisonVisitor(
 
     open fun compare(old: ClassItem, new: ClassItem) {}
 
+    open fun compare(old: CallableItem, new: CallableItem) {}
+
     open fun compare(old: ConstructorItem, new: ConstructorItem) {}
 
     open fun compare(old: MethodItem, new: MethodItem) {}
@@ -72,6 +62,8 @@ open class ComparisonVisitor(
 
     open fun added(new: ClassItem) {}
 
+    open fun added(new: CallableItem) {}
+
     open fun added(new: ConstructorItem) {}
 
     open fun added(new: MethodItem) {}
@@ -86,6 +78,8 @@ open class ComparisonVisitor(
 
     open fun removed(old: ClassItem, from: Item?) {}
 
+    open fun removed(old: CallableItem, from: ClassItem?) {}
+
     open fun removed(old: ConstructorItem, from: ClassItem?) {}
 
     open fun removed(old: MethodItem, from: ClassItem?) {}
@@ -181,25 +175,49 @@ class CodebaseComparator(
                         compare > 0 -> {
                             index2++
                             if (new.emit) {
-                                visitAdded(new, oldParent, visitor, newTree, filter)
+                                dispatchToAddedOrCompareIfItemWasMoved(
+                                    new,
+                                    oldParent,
+                                    visitor,
+                                    newTree,
+                                    filter
+                                )
                             }
                         }
                         compare < 0 -> {
                             index1++
                             if (old.emit) {
-                                visitRemoved(old, oldTree, visitor, newParent, filter)
+                                dispatchToRemovedOrCompareIfItemWasMoved(
+                                    old,
+                                    oldTree,
+                                    visitor,
+                                    newParent,
+                                    filter
+                                )
                             }
                         }
                         else -> {
                             if (new.emit) {
                                 if (old.emit) {
-                                    visitCompare(visitor, old, new)
+                                    dispatchToCompare(visitor, old, new)
                                 } else {
-                                    visitAdded(new, oldParent, visitor, newTree, filter)
+                                    dispatchToAddedOrCompareIfItemWasMoved(
+                                        new,
+                                        oldParent,
+                                        visitor,
+                                        newTree,
+                                        filter
+                                    )
                                 }
                             } else {
                                 if (old.emit) {
-                                    visitRemoved(old, oldTree, visitor, newParent, filter)
+                                    dispatchToRemovedOrCompareIfItemWasMoved(
+                                        old,
+                                        oldTree,
+                                        visitor,
+                                        newParent,
+                                        filter
+                                    )
                                 }
                             }
 
@@ -222,7 +240,13 @@ class CodebaseComparator(
                     while (index1 < length1) {
                         val oldTree = oldList[index1++]
                         val old = oldTree.item()
-                        visitRemoved(old, oldTree, visitor, newParent, filter)
+                        dispatchToRemovedOrCompareIfItemWasMoved(
+                            old,
+                            oldTree,
+                            visitor,
+                            newParent,
+                            filter
+                        )
                     }
                 }
             } else if (index2 < length2) {
@@ -231,7 +255,7 @@ class CodebaseComparator(
                     val newTree = newList[index2++]
                     val new = newTree.item()
 
-                    visitAdded(new, oldParent, visitor, newTree, filter)
+                    dispatchToAddedOrCompareIfItemWasMoved(new, oldParent, visitor, newTree, filter)
                 }
             } else {
                 break
@@ -239,7 +263,11 @@ class CodebaseComparator(
         }
     }
 
-    private fun visitAdded(
+    /**
+     * Checks to see whether [new] has actually been added or if it was just moved from elsewhere
+     * and dispatch to the appropriate method.
+     */
+    private fun dispatchToAddedOrCompareIfItemWasMoved(
         new: Item,
         oldParent: Item?,
         visitor: ComparisonVisitor,
@@ -264,58 +292,41 @@ class CodebaseComparator(
             }
 
         if (inherited != null) {
-            visitCompare(visitor, inherited, new)
+            dispatchToCompare(visitor, inherited, new)
             // Compare the children (recurse)
             if (inherited.parameters().isNotEmpty()) {
                 val parameters = inherited.parameters().map { ItemTree(it) }.toList()
                 compare(visitor, parameters, newTree.children, newTree.item(), inherited, filter)
             }
         } else {
-            visitAdded(visitor, new)
+            dispatchToAdded(visitor, new)
         }
     }
 
-    private fun visitAdded(visitor: ComparisonVisitor, new: Item) {
-        if (visitor.visitAddedItemsRecursively) {
-            new.accept(
-                object : ApiVisitor(config = apiVisitorConfig) {
-                    override fun visitItem(item: Item) {
-                        doVisitAdded(visitor, item)
-                    }
-                }
-            )
-        } else {
-            doVisitAdded(visitor, new)
-        }
-    }
-
-    @Suppress(
-        "USELESS_CAST"
-    ) // Overloaded visitor methods: be explicit about which one is being invoked
-    private fun doVisitAdded(visitor: ComparisonVisitor, item: Item) {
+    /** Dispatch to the [Item] specific `added(...)` method. */
+    private fun dispatchToAdded(visitor: ComparisonVisitor, item: Item) {
         visitor.added(item)
 
+        if (item is CallableItem) {
+            visitor.added(item)
+        }
+
         when (item) {
             is PackageItem -> visitor.added(item)
             is ClassItem -> visitor.added(item)
-            is MethodItem -> {
-                if (visitor.visitConstructorsAsMethods) {
-                    visitor.added(item)
-                } else {
-                    if (item is ConstructorItem) {
-                        visitor.added(item as ConstructorItem)
-                    } else {
-                        visitor.added(item as MethodItem)
-                    }
-                }
-            }
+            is ConstructorItem -> visitor.added(item)
+            is MethodItem -> visitor.added(item)
             is FieldItem -> visitor.added(item)
             is ParameterItem -> visitor.added(item)
             is PropertyItem -> visitor.added(item)
         }
     }
 
-    private fun visitRemoved(
+    /**
+     * Checks to see whether [new] has actually been removed or if it was just moved from elsewhere
+     * and dispatch to the appropriate method.
+     */
+    private fun dispatchToRemovedOrCompareIfItemWasMoved(
         old: Item,
         oldTree: ItemTree,
         visitor: ComparisonVisitor,
@@ -328,7 +339,7 @@ class CodebaseComparator(
         // class was hidden then the signature file may have listed the method as being
         // declared on the subclass
         val inheritedMethod =
-            if (old is MethodItem && !old.isConstructor() && newParent is ClassItem) {
+            if (old is MethodItem && newParent is ClassItem) {
                 val superMethod = newParent.findPredicateMethodWithSuper(old, filter)
 
                 if (superMethod != null && (filter == null || filter.test(superMethod))) {
@@ -341,7 +352,7 @@ class CodebaseComparator(
             }
 
         if (inheritedMethod != null) {
-            visitCompare(visitor, old, inheritedMethod)
+            dispatchToCompare(visitor, old, inheritedMethod)
             // Compare the children (recurse)
             if (inheritedMethod.parameters().isNotEmpty()) {
                 val parameters = inheritedMethod.parameters().map { ItemTree(it) }.toList()
@@ -377,58 +388,44 @@ class CodebaseComparator(
             }
 
         if (inheritedField != null) {
-            visitCompare(visitor, old, inheritedField)
+            dispatchToCompare(visitor, old, inheritedField)
             return
         }
-        visitRemoved(visitor, old, newParent)
+        dispatchToRemoved(visitor, old, newParent)
     }
 
-    @Suppress(
-        "USELESS_CAST"
-    ) // Overloaded visitor methods: be explicit about which one is being invoked
-    private fun visitRemoved(visitor: ComparisonVisitor, item: Item, from: Item?) {
+    /** Dispatch to the [Item] specific `removed(...)` method. */
+    private fun dispatchToRemoved(visitor: ComparisonVisitor, item: Item, from: Item?) {
         visitor.removed(item, from)
 
+        if (item is CallableItem) {
+            visitor.removed(item, from as ClassItem?)
+        }
+
         when (item) {
             is PackageItem -> visitor.removed(item, from)
             is ClassItem -> visitor.removed(item, from)
-            is MethodItem -> {
-                if (visitor.visitConstructorsAsMethods) {
-                    visitor.removed(item, from as ClassItem?)
-                } else {
-                    if (item is ConstructorItem) {
-                        visitor.removed(item as ConstructorItem, from as ClassItem?)
-                    } else {
-                        visitor.removed(item as MethodItem, from as ClassItem?)
-                    }
-                }
-            }
+            is ConstructorItem -> visitor.removed(item, from as ClassItem?)
+            is MethodItem -> visitor.removed(item, from as ClassItem?)
             is FieldItem -> visitor.removed(item, from as ClassItem?)
             is ParameterItem -> visitor.removed(item, from as MethodItem?)
             is PropertyItem -> visitor.removed(item, from as ClassItem?)
         }
     }
 
-    @Suppress(
-        "USELESS_CAST"
-    ) // Overloaded visitor methods: be explicit about which one is being invoked
-    private fun visitCompare(visitor: ComparisonVisitor, old: Item, new: Item) {
+    /** Dispatch to the [Item] specific `compare(...)` method. */
+    private fun dispatchToCompare(visitor: ComparisonVisitor, old: Item, new: Item) {
         visitor.compare(old, new)
 
+        if (old is CallableItem) {
+            visitor.compare(old, new as CallableItem)
+        }
+
         when (old) {
             is PackageItem -> visitor.compare(old, new as PackageItem)
             is ClassItem -> visitor.compare(old, new as ClassItem)
-            is MethodItem -> {
-                if (visitor.visitConstructorsAsMethods) {
-                    visitor.compare(old, new as MethodItem)
-                } else {
-                    if (old is ConstructorItem) {
-                        visitor.compare(old as ConstructorItem, new as MethodItem)
-                    } else {
-                        visitor.compare(old as MethodItem, new as MethodItem)
-                    }
-                }
-            }
+            is ConstructorItem -> visitor.compare(old, new as ConstructorItem)
+            is MethodItem -> visitor.compare(old, new as MethodItem)
             is FieldItem -> visitor.compare(old, new as FieldItem)
             is ParameterItem -> visitor.compare(old, new as ParameterItem)
             is PropertyItem -> visitor.compare(old, new as PropertyItem)
@@ -442,7 +439,8 @@ class CodebaseComparator(
         private fun typeRank(item: Item): Int {
             return when (item) {
                 is PackageItem -> 0
-                is MethodItem -> if (item.isConstructor()) 1 else 2
+                is ConstructorItem -> 1
+                is MethodItem -> 2
                 is FieldItem -> 3
                 is ClassItem -> 4
                 is ParameterItem -> 5
@@ -465,13 +463,13 @@ class CodebaseComparator(
                         is ClassItem -> {
                             item1.qualifiedName().compareTo((item2 as ClassItem).qualifiedName())
                         }
-                        is MethodItem -> {
+                        is CallableItem -> {
                             // Try to incrementally match aspects of the method until you can
                             // conclude
                             // whether they are the same or different.
                             // delta is 0 when the methods are the same, else not 0
                             // Start by comparing the names
-                            var delta = item1.name().compareTo((item2 as MethodItem).name())
+                            var delta = item1.name().compareTo((item2 as CallableItem).name())
                             if (delta == 0) {
                                 // If the names are the same then compare the number of parameters
                                 val parameters1 = item1.parameters()
@@ -544,9 +542,7 @@ class CodebaseComparator(
                             item1.parameterIndex.compareTo((item2 as ParameterItem).parameterIndex)
                         }
                         is AnnotationItem -> {
-                            (item1.qualifiedName ?: "").compareTo(
-                                (item2 as AnnotationItem).qualifiedName ?: ""
-                            )
+                            item1.qualifiedName.compareTo((item2 as AnnotationItem).qualifiedName)
                         }
                         is PropertyItem -> {
                             item1.name().compareTo((item2 as PropertyItem).name())
@@ -627,7 +623,7 @@ class CodebaseComparator(
             codebase.accept(
                 object :
                     ApiVisitor(
-                        nestInnerClasses = true,
+                        preserveClassNesting = true,
                         inlineInheritedFields = true,
                         filterEmit = predicate,
                         filterReference = predicate,
@@ -658,12 +654,6 @@ class CodebaseComparator(
                     override fun include(cls: ClassItem): Boolean =
                         if (acceptAll) true else super.include(cls)
 
-                    /**
-                     * Include all classes in the tree, even implicitly defined classes (such as
-                     * containing classes)
-                     */
-                    override fun shouldEmitClass(vc: VisitCandidate): Boolean = true
-
                     override fun afterVisitItem(item: Item) {
                         stack.pop()
                     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/Constants.kt b/metalava/src/main/java/com/android/tools/metalava/Constants.kt
index 359bbb29c..b919a23b0 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Constants.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Constants.kt
@@ -21,7 +21,6 @@ const val ORG_INTELLIJ_LANG_ANNOTATIONS_PREFIX = "org.intellij.lang.annotations.
 const val ANDROID_SYSTEM_API = "android.annotation.SystemApi"
 const val ANDROID_TEST_API = "android.annotation.TestApi"
 const val ANDROID_FLAGGED_API = "android.annotation.FlaggedApi"
-const val ANDROID_REQUIRES_PERMISSION = "android.annotation.RequiresPermission"
 const val RECENTLY_NULLABLE = "androidx.annotation.RecentlyNullable"
 const val RECENTLY_NONNULL = "androidx.annotation.RecentlyNonNull"
 const val ANDROID_NULLABLE = "android.annotation.Nullable"
diff --git a/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt b/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
index 328a9d372..3432dbb3e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
@@ -76,9 +76,6 @@ class ConvertJarsToSignatureFiles(
             val signatureFileLoader = SignatureFileLoader(annotationManager = annotationManager)
 
             val jarCodebase = jarCodebaseLoader.loadFromJarFile(apiJar)
-            val apiPredicateConfig = ApiPredicate.Config()
-            val apiEmit = ApiType.PUBLIC_API.getEmitFilter(apiPredicateConfig)
-            val apiReference = ApiType.PUBLIC_API.getReferenceFilter(apiPredicateConfig)
 
             if (api >= 28) {
                 // As of API 28 we'll put nullness annotations into the jar but some of them
@@ -100,15 +97,14 @@ class ConvertJarsToSignatureFiles(
                             val annotationClass =
                                 if (annotation.isNullable()) ANDROIDX_NULLABLE else ANDROIDX_NONNULL
 
-                            val modifiers = new.mutableModifiers()
-                            modifiers.removeAnnotation(annotation)
-
-                            modifiers.addAnnotation(
-                                new.codebase.createAnnotation(
-                                    "@$annotationClass",
-                                    new,
-                                )
-                            )
+                            val replacementAnnotation =
+                                new.codebase.createAnnotation("@$annotationClass", new)
+                            new.mutateModifiers {
+                                mutateAnnotations {
+                                    remove(annotation)
+                                    replacementAnnotation?.let { add(it) }
+                                }
+                            }
                         }
                     }
                 )
@@ -142,14 +138,19 @@ class ConvertJarsToSignatureFiles(
             }
 
             createReportFile(progressTracker, jarCodebase, newApiFile, "API") { printWriter ->
-                SignatureWriter(
-                    printWriter,
-                    apiEmit,
-                    apiReference,
-                    jarCodebase.preFiltered,
+                val signatureWriter =
+                    SignatureWriter(
+                        writer = printWriter,
+                        fileFormat = fileFormat,
+                    )
+
+                createFilteringVisitorForSignatures(
+                    delegate = signatureWriter,
                     fileFormat = fileFormat,
+                    apiType = ApiType.PUBLIC_API,
+                    preFiltered = jarCodebase.preFiltered,
                     showUnannotated = false,
-                    apiVisitorConfig = ApiVisitor.Config(),
+                    apiVisitorConfig = ApiVisitor.Config()
                 )
             }
 
@@ -244,7 +245,7 @@ class ConvertJarsToSignatureFiles(
         this ?: return
         if (!originallyDeprecated) {
             // Set the deprecated flag in the modifiers which underpins [originallyDeprecated].
-            mutableModifiers().setDeprecated(true)
+            mutateModifiers { setDeprecated(true) }
             progressTracker.progress("Turned deprecation on for $this from $source")
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt b/metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt
index fd07f85b7..519bb3a8e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt
@@ -83,7 +83,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
     init {
         /** Use the complete source representation of the item as the key. */
         fun useSourceAsKey(annotationItem: AnnotationItem): String {
-            val qualifiedName = annotationItem.qualifiedName!!
+            val qualifiedName = annotationItem.qualifiedName
             val attributes = annotationItem.attributes
             if (attributes.isEmpty()) {
                 return qualifiedName
@@ -121,7 +121,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
     }
 
     override fun getKeyForAnnotationItem(annotationItem: AnnotationItem): String {
-        val qualifiedName = annotationItem.qualifiedName!!
+        val qualifiedName = annotationItem.qualifiedName
 
         // Check to see if this requires a special [KeyFactory] and use it if it does.
         val keyFactory = annotationNameToKeyFactory.get(qualifiedName)
@@ -334,7 +334,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         annotation: AnnotationItem,
         classFinder: (String) -> ClassItem?
     ): Set<AnnotationTarget> {
-        val qualifiedName = annotation.qualifiedName ?: return NO_ANNOTATION_TARGETS
+        val qualifiedName = annotation.qualifiedName
         if (config.passThroughAnnotations.contains(qualifiedName)) {
             return ANNOTATION_IN_ALL_STUBS
         }
@@ -640,7 +640,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
 private class LazyAnnotationInfo(
     private val config: Config,
     private val annotationItem: AnnotationItem,
-) : AnnotationInfo(annotationItem.qualifiedName!!) {
+) : AnnotationInfo(annotationItem.qualifiedName) {
 
     /** Compute lazily to avoid doing any more work than strictly necessary. */
     override val showability: Showability by
diff --git a/metalava/src/main/java/com/android/tools/metalava/DefaultReporter.kt b/metalava/src/main/java/com/android/tools/metalava/DefaultReporter.kt
deleted file mode 100644
index 98fd38322..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/DefaultReporter.kt
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava
-
-import com.android.tools.metalava.cli.common.Terminal
-import com.android.tools.metalava.cli.common.TerminalColor
-import com.android.tools.metalava.cli.common.plainTerminal
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.PackageItem
-import com.android.tools.metalava.reporter.Baseline
-import com.android.tools.metalava.reporter.FileLocation
-import com.android.tools.metalava.reporter.IssueConfiguration
-import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.Reportable
-import com.android.tools.metalava.reporter.Reporter
-import com.android.tools.metalava.reporter.Severity
-import com.android.tools.metalava.reporter.Severity.ERROR
-import com.android.tools.metalava.reporter.Severity.HIDDEN
-import com.android.tools.metalava.reporter.Severity.INFO
-import com.android.tools.metalava.reporter.Severity.INHERIT
-import com.android.tools.metalava.reporter.Severity.WARNING
-import com.android.tools.metalava.reporter.Severity.WARNING_ERROR_WHEN_NEW
-import java.io.File
-import java.io.OutputStreamWriter
-import java.io.PrintWriter
-import java.nio.file.Path
-
-internal class DefaultReporter(
-    private val environment: ReporterEnvironment,
-    private val issueConfiguration: IssueConfiguration,
-
-    /** [Baseline] file associated with this [Reporter]. */
-    private val baseline: Baseline? = null,
-
-    /**
-     * An error message associated with this [Reporter], which should be shown to the user when
-     * metalava finishes with errors.
-     */
-    private val errorMessage: String? = null,
-
-    /** Filter to hide issues reported in packages which are not part of the API. */
-    private val packageFilter: PackageFilter? = null,
-
-    /** Additional config properties. */
-    private val config: Config = Config(),
-) : Reporter {
-    private var errors = mutableListOf<String>()
-    private var warningCount = 0
-
-    /**
-     * Configuration properties for the reporter.
-     *
-     * This contains properties that are shared across all instances of [DefaultReporter], except
-     * for the bootstrapping reporter. That receives a default instance of this.
-     */
-    class Config(
-        /** If true, treat all warnings as errors */
-        val warningsAsErrors: Boolean = false,
-
-        /** Whether output should be colorized */
-        val terminal: Terminal = plainTerminal,
-
-        /**
-         * Optional writer to which, if present, all errors, even if they were suppressed in
-         * baseline or via annotation, will be written.
-         */
-        val reportEvenIfSuppressedWriter: PrintWriter? = null,
-    )
-
-    /** The number of errors. */
-    val errorCount
-        get() = errors.size
-
-    /** Returns whether any errors have been detected. */
-    fun hasErrors(): Boolean = errors.size > 0
-
-    override fun report(
-        id: Issues.Issue,
-        reportable: Reportable?,
-        message: String,
-        location: FileLocation,
-        maximumSeverity: Severity,
-    ): Boolean {
-        val severity = issueConfiguration.getSeverity(id)
-        val upgradedSeverity =
-            if (severity == WARNING && config.warningsAsErrors) {
-                ERROR
-            } else {
-                severity
-            }
-
-        // Limit the Severity to the maximum allowed.
-        val effectiveSeverity = minOf(upgradedSeverity, maximumSeverity)
-        if (effectiveSeverity == HIDDEN) {
-            return false
-        }
-
-        fun dispatch(
-            which:
-                (
-                    severity: Severity, location: String?, message: String, id: Issues.Issue
-                ) -> Boolean
-        ): Boolean {
-            // When selecting a location to use for reporting the issue the location is used in
-            // preference to the item because the location is more specific. e.g. if the item is a
-            // method then the location may be a line within the body of the method.
-            val reportLocation =
-                when {
-                    location.path != null -> location
-                    else -> reportable?.fileLocation
-                }
-
-            return which(effectiveSeverity, reportLocation?.forReport(), message, id)
-        }
-
-        // Optionally write to the --report-even-if-suppressed file.
-        dispatch(this::reportEvenIfSuppressed)
-
-        if (isSuppressed(id, reportable, message)) {
-            return false
-        }
-
-        // If we are only emitting some packages (--stub-packages), don't report
-        // issues from other packages
-        val item = reportable as? Item
-        if (item != null) {
-            if (packageFilter != null) {
-                val pkg = (item as? PackageItem) ?: item.containingPackage()
-                if (pkg != null && !packageFilter.matches(pkg)) {
-                    return false
-                }
-            }
-        }
-
-        if (baseline != null) {
-            // When selecting a location to use for in checking the baseline the item is used in
-            // preference to the location because the item is more stable. e.g. the location may be
-            // for a specific line within a method which would change over time while the method
-            // signature would stay the same.
-            val baselineKey =
-                when {
-                    // When available use the baseline key from the reportable.
-                    reportable != null -> reportable.baselineKey
-                    // Otherwise, use the baseline key from the file location.
-                    else -> location.baselineKey
-                }
-
-            if (baselineKey != null && baseline.mark(baselineKey, message, id)) return false
-        }
-
-        return dispatch(this::doReport)
-    }
-
-    override fun isSuppressed(
-        id: Issues.Issue,
-        reportable: Reportable?,
-        message: String?
-    ): Boolean {
-        val severity = issueConfiguration.getSeverity(id)
-        if (severity == HIDDEN) {
-            return true
-        }
-
-        reportable ?: return false
-
-        // Suppress the issue if requested for the item.
-        return reportable.suppressedIssues().any { suppressMatches(it, id.name, message) }
-    }
-
-    private fun suppressMatches(value: String, id: String?, message: String?): Boolean {
-        id ?: return false
-
-        if (value == id) {
-            return true
-        }
-
-        if (
-            message != null &&
-                value.startsWith(id) &&
-                value.endsWith(message) &&
-                (value == "$id:$message" || value == "$id: $message")
-        ) {
-            return true
-        }
-
-        return false
-    }
-
-    /**
-     * Relativize the [absolutePath] against the [ReporterEnvironment.rootFolder] if specified.
-     *
-     * Tests will set [rootFolder] to the temporary directory so that this can remove that from any
-     * paths that are reported to avoid the test having to be aware of the temporary directory.
-     */
-    private fun relativizeLocationPath(absolutePath: Path): String {
-        // b/255575766: Note that [relativize] requires two paths to compare to have same types:
-        // either both of them are absolute paths or both of them are not absolute paths.
-        val path = environment.rootFolder.toPath().relativize(absolutePath) ?: absolutePath
-        return path.toString()
-    }
-
-    /**
-     * Convert the [FileLocation] to an optional string representation suitable for use in a report.
-     *
-     * See [relativizeLocationPath].
-     */
-    private fun FileLocation.forReport(): String? {
-        val pathString = path?.let { relativizeLocationPath(it) } ?: return null
-        return if (line > 0) "$pathString:$line" else pathString
-    }
-
-    /** Alias to allow method reference to `dispatch` in [report] */
-    private fun doReport(
-        severity: Severity,
-        location: String?,
-        message: String,
-        id: Issues.Issue?,
-    ): Boolean {
-        val terminal: Terminal = config.terminal
-        val formattedMessage = format(severity, location, message, id, terminal)
-        if (severity == ERROR) {
-            errors.add(formattedMessage)
-        } else if (severity == WARNING) {
-            warningCount++
-        }
-
-        environment.printReport(formattedMessage, severity)
-        return true
-    }
-
-    private fun format(
-        severity: Severity,
-        location: String?,
-        message: String,
-        id: Issues.Issue?,
-        terminal: Terminal,
-    ): String {
-        val sb = StringBuilder(100)
-
-        sb.append(terminal.attributes(bold = true))
-        location?.let { sb.append(it).append(": ") }
-        when (severity) {
-            INFO -> sb.append(terminal.attributes(foreground = TerminalColor.CYAN)).append("info: ")
-            WARNING,
-            WARNING_ERROR_WHEN_NEW ->
-                sb.append(terminal.attributes(foreground = TerminalColor.YELLOW))
-                    .append("warning: ")
-            ERROR ->
-                sb.append(terminal.attributes(foreground = TerminalColor.RED)).append("error: ")
-            INHERIT,
-            HIDDEN -> {}
-        }
-        sb.append(terminal.reset())
-        sb.append(message)
-        sb.append(severity.messageSuffix)
-        id?.let { sb.append(" [").append(it.name).append("]") }
-        return sb.toString()
-    }
-
-    private fun reportEvenIfSuppressed(
-        severity: Severity,
-        location: String?,
-        message: String,
-        id: Issues.Issue
-    ): Boolean {
-        config.reportEvenIfSuppressedWriter?.println(
-            format(severity, location, message, id, terminal = plainTerminal)
-        )
-        return true
-    }
-
-    /** Print all the recorded errors to the given writer. Returns the number of errors printer. */
-    fun printErrors(writer: PrintWriter, maxErrors: Int): Int {
-        var i = 0
-        errors.forEach loop@{
-            if (i >= maxErrors) {
-                return@loop
-            }
-            i++
-            writer.println(it)
-        }
-        return i
-    }
-
-    /** Write the error message set to this [Reporter], if any errors have been detected. */
-    fun writeErrorMessage(writer: PrintWriter) {
-        if (hasErrors()) {
-            errorMessage?.let { writer.write(it) }
-        }
-    }
-
-    fun getBaselineDescription(): String {
-        val file = baseline?.file
-        return if (file != null) {
-            "baseline ${file.path}"
-        } else {
-            "no baseline"
-        }
-    }
-}
-
-/**
- * Provides access to information about the environment within which the [Reporter] will be being
- * used.
- */
-interface ReporterEnvironment {
-
-    /** Root folder, against which location paths will be relativized to simplify the output. */
-    val rootFolder: File
-
-    /** Print the report. */
-    fun printReport(message: String, severity: Severity)
-}
-
-class DefaultReporterEnvironment(
-    val stdout: PrintWriter = PrintWriter(OutputStreamWriter(System.out)),
-    val stderr: PrintWriter = PrintWriter(OutputStreamWriter(System.err)),
-) : ReporterEnvironment {
-
-    override val rootFolder = File("").absoluteFile
-
-    override fun printReport(message: String, severity: Severity) {
-        val output = if (severity == ERROR) stderr else stdout
-        output.println(message.trim())
-        output.flush()
-    }
-}
diff --git a/metalava/src/main/java/com/android/tools/metalava/Driver.kt b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
index a33932182..15bf58aee 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Driver.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
@@ -28,7 +28,6 @@ import com.android.tools.metalava.cli.common.MetalavaCommand
 import com.android.tools.metalava.cli.common.SignatureFileLoader
 import com.android.tools.metalava.cli.common.VersionCommand
 import com.android.tools.metalava.cli.common.commonOptions
-import com.android.tools.metalava.cli.compatibility.ARG_CHECK_COMPATIBILITY_BASE_API
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
 import com.android.tools.metalava.cli.help.HelpCommand
 import com.android.tools.metalava.cli.internal.MakeAnnotationsPackagePrivateCommand
@@ -42,8 +41,9 @@ import com.android.tools.metalava.lint.ApiLint
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.ItemVisitor
-import com.android.tools.metalava.model.MergedCodebase
 import com.android.tools.metalava.model.ModelOptions
 import com.android.tools.metalava.model.psi.PsiModelOptions
 import com.android.tools.metalava.model.source.EnvironmentManager
@@ -51,9 +51,11 @@ import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.model.text.ApiClassResolution
 import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.stub.StubConstructorManager
 import com.android.tools.metalava.stub.StubWriter
+import com.android.tools.metalava.stub.createFilteringVisitorForStubs
 import com.github.ajalt.clikt.core.subcommands
 import com.google.common.base.Stopwatch
 import java.io.File
@@ -62,6 +64,7 @@ import java.io.PrintWriter
 import java.io.StringWriter
 import java.util.Arrays
 import java.util.concurrent.TimeUnit.SECONDS
+import java.util.function.Predicate
 import kotlin.system.exitProcess
 
 const val PROGRAM_NAME = "metalava"
@@ -127,7 +130,7 @@ internal fun processFlags(
     val stopwatch = Stopwatch.createStarted()
 
     val reporter = options.reporter
-    val reporterApiLint = options.reporterApiLint
+
     val annotationManager = options.annotationManager
     val modelOptions =
         // If the option was specified on the command line then use [ModelOptions] created from
@@ -151,6 +154,7 @@ internal fun processFlags(
             modelOptions = modelOptions,
             allowReadingComments = options.allowReadingComments,
             jdkHome = options.jdkHome,
+            projectDescription = options.projectDescription,
         )
 
     val signatureFileCache = options.signatureFileCache
@@ -159,7 +163,7 @@ internal fun processFlags(
         ActionContext(
             progressTracker = progressTracker,
             reporter = reporter,
-            reporterApiLint = reporterApiLint,
+            reporterApiLint = reporter,
             sourceParser = sourceParser,
         )
 
@@ -182,22 +186,10 @@ internal fun processFlags(
                     )
                 }
             val signatureFileLoader = SignatureFileLoader(annotationManager)
-            val textCodebase =
-                signatureFileLoader.loadFiles(
-                    SignatureFile.fromFiles(sources),
-                    classResolverProvider.classResolver,
-                )
-
-            // If this codebase was loaded in order to generate stubs then they will need some
-            // additional items to be added that were purposely removed from the signature files.
-            if (options.stubsDir != null) {
-                addMissingItemsRequiredForGeneratingStubs(
-                    sourceParser,
-                    textCodebase,
-                    reporterApiLint
-                )
-            }
-            textCodebase
+            signatureFileLoader.loadFiles(
+                SignatureFile.fromFiles(sources),
+                classResolverProvider.classResolver,
+            )
         } else if (sources.size == 1 && sources[0].path.endsWith(DOT_JAR)) {
             actionContext.loadFromJarFile(sources[0])
         } else if (sources.isNotEmpty() || options.sourcePath.isNotEmpty()) {
@@ -253,7 +245,7 @@ internal fun processFlags(
             error("Codebase does not support documentation, so it cannot be enhanced.")
         }
         progressTracker.progress("Enhancing docs: ")
-        val docAnalyzer = DocAnalyzer(executionEnvironment, codebase, reporterApiLint)
+        val docAnalyzer = DocAnalyzer(executionEnvironment, codebase, reporter)
         docAnalyzer.enhance()
         val applyApiLevelsXml = options.applyApiLevelsXml
         if (applyApiLevelsXml != null) {
@@ -294,65 +286,74 @@ internal fun processFlags(
         )
     }
 
-    // Based on the input flags, generates various output files such
-    // as signature files and/or stubs files
+    // Based on the input flags, generates various output files such as signature files and/or stubs
+    // files
     options.apiFile?.let { apiFile ->
-        val apiType = ApiType.PUBLIC_API
-        val apiEmit = apiType.getEmitFilter(options.apiPredicateConfig)
-        val apiReference = apiType.getReferenceFilter(options.apiPredicateConfig)
+        val fileFormat = options.signatureFileFormat
+        val codebaseFragment =
+            CodebaseFragment(codebase) { delegate ->
+                createFilteringVisitorForSignatures(
+                    delegate = delegate,
+                    fileFormat = fileFormat,
+                    apiType = ApiType.PUBLIC_API,
+                    preFiltered = codebase.preFiltered,
+                    showUnannotated = options.showUnannotated,
+                    apiVisitorConfig = options.apiVisitorConfig,
+                )
+            }
 
-        createReportFile(progressTracker, codebase, apiFile, "API") { printWriter ->
+        createReportFile(progressTracker, codebaseFragment, apiFile, "API") { printWriter ->
             SignatureWriter(
-                printWriter,
-                apiEmit,
-                apiReference,
-                codebase.preFiltered,
-                fileFormat = options.signatureFileFormat,
-                showUnannotated = options.showUnannotated,
-                apiVisitorConfig = options.apiVisitorConfig
+                writer = printWriter,
+                fileFormat = fileFormat,
             )
         }
     }
 
     options.removedApiFile?.let { apiFile ->
-        val apiType = ApiType.REMOVED
-        val removedEmit = apiType.getEmitFilter(options.apiPredicateConfig)
-        val removedReference = apiType.getReferenceFilter(options.apiPredicateConfig)
+        val fileFormat = options.signatureFileFormat
+        val codebaseFragment =
+            CodebaseFragment(codebase) { delegate ->
+                createFilteringVisitorForSignatures(
+                    delegate = delegate,
+                    fileFormat = fileFormat,
+                    apiType = ApiType.REMOVED,
+                    preFiltered = false,
+                    showUnannotated = options.showUnannotated,
+                    apiVisitorConfig = options.apiVisitorConfig,
+                )
+            }
 
         createReportFile(
             progressTracker,
-            codebase,
+            codebaseFragment,
             apiFile,
             "removed API",
             options.deleteEmptyRemovedSignatures
         ) { printWriter ->
             SignatureWriter(
-                printWriter,
-                removedEmit,
-                removedReference,
-                false,
-                options.includeSignatureFormatVersionRemoved,
-                options.signatureFileFormat,
-                options.showUnannotated,
-                options.apiVisitorConfig,
+                writer = printWriter,
+                emitHeader = options.includeSignatureFormatVersionRemoved,
+                fileFormat = fileFormat,
             )
         }
     }
 
-    val apiPredicateConfigIgnoreShown = options.apiPredicateConfig.copy(ignoreShown = true)
-    val apiReferenceIgnoreShown = ApiPredicate(config = apiPredicateConfigIgnoreShown)
-    options.dexApiFile?.let { apiFile ->
-        val apiFilter = FilterPredicate(ApiPredicate())
-
-        createReportFile(progressTracker, codebase, apiFile, "DEX API") { printWriter ->
-            DexApiWriter(printWriter, apiFilter, apiReferenceIgnoreShown, options.apiVisitorConfig)
-        }
-    }
-
     options.proguard?.let { proguard ->
+        val apiPredicateConfigIgnoreShown = options.apiPredicateConfig.copy(ignoreShown = true)
+        val apiReferenceIgnoreShown = ApiPredicate(config = apiPredicateConfigIgnoreShown)
         val apiEmit = FilterPredicate(ApiPredicate())
         createReportFile(progressTracker, codebase, proguard, "Proguard file") { printWriter ->
-            ProguardWriter(printWriter, apiEmit, apiReferenceIgnoreShown)
+            ProguardWriter(printWriter).let { proguardWriter ->
+                FilteringApiVisitor(
+                    proguardWriter,
+                    inlineInheritedFields = true,
+                    filterEmit = apiEmit,
+                    filterReference = apiReferenceIgnoreShown,
+                    preFiltered = codebase.preFiltered,
+                    config = options.apiVisitorConfig,
+                )
+            }
         }
     }
 
@@ -365,14 +366,13 @@ internal fun processFlags(
         actionContext.checkCompatibility(signatureFileCache, classResolverProvider, codebase, check)
     }
 
-    val previousApiFile = options.migrateNullsFrom
-    if (previousApiFile != null) {
+    val previouslyReleasedApi = options.migrateNullsFrom
+    if (previouslyReleasedApi != null) {
         val previous =
-            if (previousApiFile.path.endsWith(DOT_JAR)) {
-                actionContext.loadFromJarFile(previousApiFile)
-            } else {
-                signatureFileCache.load(signatureFile = SignatureFile.fromFile(previousApiFile))
-            }
+            previouslyReleasedApi.load(
+                jarLoader = { jarFile -> actionContext.loadFromJarFile(jarFile) },
+                signatureFileLoader = { signatureFiles -> signatureFileCache.load(signatureFiles) }
+            )
 
         // If configured, checks for newly added nullness information compared
         // to the previous stable API and marks the newly annotated elements
@@ -408,26 +408,6 @@ internal fun processFlags(
     )
 }
 
-/**
- * When generating stubs from text signature files some additional items are needed.
- *
- * Those items are:
- * * Constructors - in the signature file a missing constructor means no publicly visible
- *   constructor but the stub classes still need a constructor.
- */
-@Suppress("DEPRECATION")
-private fun addMissingItemsRequiredForGeneratingStubs(
-    sourceParser: SourceParser,
-    codebase: Codebase,
-    reporterApiLint: Reporter,
-) {
-    // Reuse the existing ApiAnalyzer support for adding constructors that is used in
-    // [loadFromSources], to make sure that the constructors are correct when generating stubs
-    // from source files.
-    val analyzer = ApiAnalyzer(sourceParser, codebase, reporterApiLint, options.apiAnalyzerConfig)
-    analyzer.addConstructors { _ -> true }
-}
-
 private fun ActionContext.subtractApi(
     signatureFileCache: SignatureFileCache,
     codebase: Codebase,
@@ -504,33 +484,15 @@ private fun ActionContext.checkCompatibility(
             }
         )
 
-    var baseApi: Codebase? = null
-
-    if (options.showUnannotated && apiType == ApiType.PUBLIC_API) {
-        val baseApiFile = options.baseApiForCompatCheck
-        if (baseApiFile != null) {
-            baseApi = signatureFileCache.load(signatureFile = SignatureFile.fromFile(baseApiFile))
-        }
-    } else if (options.baseApiForCompatCheck != null) {
-        // This option does not make sense with showAnnotation, as the "base" in that case
-        // is the non-annotated APIs.
-        throw MetalavaCliException(
-            "$ARG_CHECK_COMPATIBILITY_BASE_API is not compatible with --showAnnotation."
-        )
-    }
-
-    // Wrap the old Codebase in a [MergedCodebase].
-    val mergedOldCodebases = MergedCodebase(listOf(oldCodebase))
-
     // If configured, compares the new API with the previous API and reports
     // any incompatibilities.
     CompatibilityCheck.checkCompatibility(
         newCodebase,
-        mergedOldCodebases,
+        oldCodebase,
         apiType,
-        baseApi,
-        options.reporterCompatibilityReleased,
+        reporter,
         options.issueConfiguration,
+        options.apiCompatAnnotations,
     )
 }
 
@@ -634,7 +596,6 @@ private fun ActionContext.loadFromSources(
     analyzer.computeApi()
 
     val apiPredicateConfigIgnoreShown = options.apiPredicateConfig.copy(ignoreShown = true)
-    val filterEmit = ApiPredicate(ignoreRemoved = false, config = apiPredicateConfigIgnoreShown)
     val apiEmitAndReference = ApiPredicate(config = apiPredicateConfigIgnoreShown)
 
     // Copy methods from soon-to-be-hidden parents into descendant classes, when necessary. Do
@@ -649,6 +610,10 @@ private fun ActionContext.loadFromSources(
         options.validateNullabilityFromList
     )
     options.nullabilityAnnotationsValidator?.report()
+
+    // Prevent the codebase from being mutated.
+    codebase.freezeClasses()
+
     analyzer.handleStripping()
 
     // General API checks for Android APIs
@@ -669,27 +634,18 @@ private fun ActionContext.loadFromSources(
                 }
             )
 
-        val apiLintReporter = reporterApiLint as DefaultReporter
         ApiLint.check(
             codebase,
             previouslyReleasedApi,
-            apiLintReporter,
+            reporter,
             options.manifest,
             options.apiVisitorConfig,
         )
         progressTracker.progress(
-            "$PROGRAM_NAME ran api-lint in ${localTimer.elapsed(SECONDS)} seconds with ${apiLintReporter.getBaselineDescription()}"
+            "$PROGRAM_NAME ran api-lint in ${localTimer.elapsed(SECONDS)} seconds"
         )
     }
 
-    // Compute default constructors (and add missing package private constructors
-    // to make stubs compilable if necessary). Do this after all the checks as
-    // these are not part of the API.
-    if (options.stubsDir != null || options.docStubsDir != null) {
-        progressTracker.progress("Insert missing constructors: ")
-        analyzer.addConstructors(filterEmit)
-    }
-
     progressTracker.progress("Performing misc API checks: ")
     analyzer.performChecks()
 
@@ -766,22 +722,44 @@ private fun createStubFiles(
             }
         }
 
+    val codebaseFragment =
+        CodebaseFragment(codebase) { delegate ->
+            createFilteringVisitorForStubs(
+                delegate = delegate,
+                docStubs = docStubs,
+                preFiltered = codebase.preFiltered,
+                apiVisitorConfig = options.apiVisitorConfig,
+            )
+        }
+
+    // Add additional constructors needed by the stubs.
+    val filterEmit =
+        if (codebaseFragment.codebase.preFiltered) {
+            Predicate { true }
+        } else {
+            val apiPredicateConfigIgnoreShown = options.apiPredicateConfig.copy(ignoreShown = true)
+            ApiPredicate(ignoreRemoved = false, config = apiPredicateConfigIgnoreShown)
+        }
+    val stubConstructorManager = StubConstructorManager(codebaseFragment.codebase)
+    stubConstructorManager.addConstructors(filterEmit)
+
     val stubWriter =
         StubWriter(
             stubsDir = stubDir,
             generateAnnotations = options.generateAnnotations,
-            preFiltered = codebase.preFiltered,
             docStubs = docStubs,
             reporter = options.reporter,
             config = stubWriterConfig,
+            stubConstructorManager = stubConstructorManager,
         )
-    codebase.accept(stubWriter)
+
+    codebaseFragment.accept(stubWriter)
 
     if (docStubs) {
         // Overview docs? These are generally in the empty package.
         codebase.findPackage("")?.let { empty ->
             val overview = empty.overviewDocumentation
-            if (!overview.isNullOrBlank()) {
+            if (overview != null) {
                 stubWriter.writeDocOverview(empty, overview)
             }
         }
@@ -793,6 +771,26 @@ private fun createStubFiles(
     )
 }
 
+fun createReportFile(
+    progressTracker: ProgressTracker,
+    codebaseFragment: CodebaseFragment,
+    apiFile: File,
+    description: String?,
+    deleteEmptyFiles: Boolean = false,
+    createVisitorWriter: (PrintWriter) -> DelegatedVisitor,
+) {
+    createReportFile(
+        progressTracker,
+        codebaseFragment.codebase,
+        apiFile,
+        description,
+        deleteEmptyFiles,
+    ) {
+        val delegatedWriter = createVisitorWriter(it)
+        codebaseFragment.createVisitor(delegatedWriter)
+    }
+}
+
 @Suppress("DEPRECATION")
 fun createReportFile(
     progressTracker: ProgressTracker,
diff --git a/metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt b/metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt
index 1e0d3851b..39dfe4c21 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt
@@ -36,7 +36,7 @@ class ElidingPredicate(
     override fun test(method: Item): Boolean {
         // This method should be included, but if it's an exact duplicate
         // override then we can elide it.
-        return if (method is MethodItem && !method.isConstructor()) {
+        return if (method is MethodItem) {
             val differentSuper =
                 method.findPredicateSuperMethod(
                     // This predicate returns true if
diff --git a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
index 4fd24ff65..b2ce5ac25 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
@@ -23,6 +23,7 @@ import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationRetention
 import com.android.tools.metalava.model.AnnotationTarget
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
@@ -34,22 +35,14 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.findAnnotation
 import com.android.tools.metalava.model.psi.CodePrinter
-import com.android.tools.metalava.model.psi.PsiAnnotationItem
-import com.android.tools.metalava.model.psi.PsiMethodItem
-import com.android.tools.metalava.model.psi.UAnnotationItem
 import com.android.tools.metalava.model.psi.report
+import com.android.tools.metalava.model.psi.uAnnotation
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import com.google.common.xml.XmlEscapers
-import com.intellij.psi.JavaRecursiveElementVisitor
 import com.intellij.psi.PsiAnnotation
-import com.intellij.psi.PsiElement
-import com.intellij.psi.PsiField
-import com.intellij.psi.PsiModifier
 import com.intellij.psi.PsiNameValuePair
-import com.intellij.psi.PsiReferenceExpression
-import com.intellij.psi.PsiReturnStatement
 import java.io.BufferedOutputStream
 import java.io.File
 import java.io.FileOutputStream
@@ -61,7 +54,6 @@ import kotlin.text.Charsets.UTF_8
 import org.jetbrains.uast.UAnnotation
 import org.jetbrains.uast.UCallExpression
 import org.jetbrains.uast.UExpression
-import org.jetbrains.uast.USimpleNameReferenceExpression
 import org.jetbrains.uast.UastEmptyExpression
 import org.jetbrains.uast.UastFacade
 import org.jetbrains.uast.toUElement
@@ -169,7 +161,7 @@ class ExtractAnnotations(
         val pkg =
             when (item) {
                 is MemberItem -> item.containingClass().containingPackage()
-                is ParameterItem -> item.containingMethod().containingClass().containingPackage()
+                is ParameterItem -> item.containingCallable().containingClass().containingPackage()
                 else -> return
             }
 
@@ -187,8 +179,8 @@ class ExtractAnnotations(
         checkItem(field)
     }
 
-    override fun visitMethod(method: MethodItem) {
-        checkItem(method)
+    override fun visitCallable(callable: CallableItem) {
+        checkItem(callable)
     }
 
     override fun visitParameter(parameter: ParameterItem) {
@@ -198,7 +190,7 @@ class ExtractAnnotations(
     /** For a given item, extract the relevant annotations for that item */
     private fun checkItem(item: Item) {
         for (annotation in item.modifiers.annotations()) {
-            val qualifiedName = annotation.qualifiedName ?: continue
+            val qualifiedName = annotation.qualifiedName
             if (
                 qualifiedName.startsWith(JAVA_LANG_PREFIX) ||
                     qualifiedName.startsWith(ANDROIDX_ANNOTATION_PREFIX) ||
@@ -256,82 +248,16 @@ class ExtractAnnotations(
                     addItem(item, typeDefAnnotation)
 
                     if (
-                        item is PsiMethodItem &&
+                        item is MethodItem &&
                             !reporter.isSuppressed(Issues.RETURNING_UNEXPECTED_CONSTANT)
                     ) {
-                        verifyReturnedConstants(item, typeDefAnnotation, typeDefClass)
+                        item.body.verifyReturnedConstants(typeDefAnnotation, typeDefClass)
                     }
-                    continue
                 }
             }
         }
     }
 
-    /**
-     * Given a method whose return value is annotated with a typedef, runs checks on the typedef and
-     * flags any returned constants not in the list.
-     */
-    private fun verifyReturnedConstants(
-        item: PsiMethodItem,
-        typeDefAnnotation: AnnotationItem,
-        typeDefClass: ClassItem,
-    ) {
-        val uAnnotation = typeDefAnnotation.uAnnotation ?: return
-
-        val method = item.psiMethod
-        if (method.body != null) {
-            method.body?.accept(
-                object : JavaRecursiveElementVisitor() {
-                    private var constants: List<String>? = null
-
-                    override fun visitReturnStatement(statement: PsiReturnStatement) {
-                        val value = statement.returnValue
-                        if (value is PsiReferenceExpression) {
-                            val resolved = value.resolve() as? PsiField ?: return
-                            val modifiers = resolved.modifierList ?: return
-                            if (
-                                modifiers.hasModifierProperty(PsiModifier.STATIC) &&
-                                    modifiers.hasModifierProperty(PsiModifier.FINAL)
-                            ) {
-                                if (resolved.type.arrayDimensions > 0) {
-                                    return
-                                }
-                                val name = resolved.name
-
-                                // Make sure this is one of the allowed annotations
-                                val names =
-                                    constants
-                                        ?: run {
-                                            constants = computeValidConstantNames(uAnnotation)
-                                            constants!!
-                                        }
-                                if (names.isNotEmpty() && !names.contains(name)) {
-                                    val expected = names.joinToString { it }
-                                    reporter.report(
-                                        Issues.RETURNING_UNEXPECTED_CONSTANT,
-                                        value as PsiElement,
-                                        "Returning unexpected constant $name; is @${typeDefClass.simpleName()} missing this constant? Expected one of $expected"
-                                    )
-                                }
-                            }
-                        }
-                    }
-                }
-            )
-        }
-    }
-
-    private fun computeValidConstantNames(annotation: UAnnotation): List<String> {
-        val constants = annotation.findAttributeValue(ANNOTATION_ATTR_VALUE) ?: return emptyList()
-        if (constants is UCallExpression) {
-            return constants.valueArguments
-                .mapNotNull { (it as? USimpleNameReferenceExpression)?.identifier }
-                .toList()
-        }
-
-        return emptyList()
-    }
-
     /**
      * A writer which stores all its contents into a string and has the ability to mark a certain
      * freeze point and then reset back to it
@@ -375,7 +301,7 @@ class ExtractAnnotations(
             is ClassItem -> {
                 return escapeXml(qualifiedName())
             }
-            is MethodItem -> {
+            is CallableItem -> {
                 val sb = StringBuilder(100)
                 sb.append(escapeXml(containingClass().qualifiedName()))
                 sb.append(' ')
@@ -419,7 +345,7 @@ class ExtractAnnotations(
                 return escapeXml(containingClass().qualifiedName()) + " " + name()
             }
             is ParameterItem -> {
-                return containingMethod().getExternalAnnotationSignature() +
+                return containingCallable().getExternalAnnotationSignature() +
                     " " +
                     this.parameterIndex
             }
@@ -544,16 +470,4 @@ class ExtractAnnotations(
     private fun isInlinedConstant(annotationItem: AnnotationItem): Boolean {
         return annotationItem.isTypeDefAnnotation()
     }
-
-    companion object {
-        private val AnnotationItem.uAnnotation: UAnnotation?
-            get() =
-                when (this) {
-                    is UAnnotationItem -> uAnnotation
-                    is PsiAnnotationItem ->
-                        // Imported annotation
-                        psiAnnotation.toUElement(UAnnotation::class.java)
-                    else -> null
-                }
-    }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt b/metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt
index 12416c38a..bee5de793 100644
--- a/metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt
@@ -25,8 +25,7 @@ class FilterPredicate(private val wrapped: Predicate<Item>) : Predicate<Item> {
     override fun test(method: Item): Boolean {
         return when {
             wrapped.test(method) -> true
-            method is MethodItem ->
-                !method.isConstructor() && method.findPredicateSuperMethod(wrapped) != null
+            method is MethodItem -> method.findPredicateSuperMethod(wrapped) != null
             else -> false
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
index ef91db61d..9ad3d0886 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
@@ -16,9 +16,11 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
@@ -30,6 +32,7 @@ import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.psi.CodePrinter
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import com.android.utils.XmlUtils
 import java.io.PrintWriter
 import java.util.function.Predicate
@@ -45,22 +48,9 @@ import java.util.function.Predicate
  */
 class JDiffXmlWriter(
     private val writer: PrintWriter,
-    filterEmit: Predicate<Item>,
-    filterReference: Predicate<Item>,
-    private val preFiltered: Boolean,
     private val apiName: String? = null,
-    showUnannotated: Boolean,
-    config: Config,
-) :
-    ApiVisitor(
-        visitConstructorsAsMethods = false,
-        nestInnerClasses = false,
-        inlineInheritedFields = true,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
-        showUnannotated = showUnannotated,
-        config = config,
-    ) {
+) : DelegatedVisitor {
+
     override fun visitCodebase(codebase: Codebase) {
         writer.print("<api")
 
@@ -239,9 +229,7 @@ class JDiffXmlWriter(
     }
 
     private fun writeSuperClassAttribute(cls: ClassItem) {
-        val superClass =
-            if (preFiltered) cls.superClassType() else cls.filteredSuperClassType(filterReference)
-
+        val superClass = cls.superClassType()
         val superClassString =
             when {
                 cls.isAnnotationType() -> JAVA_LANG_ANNOTATION
@@ -261,12 +249,9 @@ class JDiffXmlWriter(
     }
 
     private fun writeInterfaceList(cls: ClassItem) {
-        val interfaces =
-            if (preFiltered) cls.interfaceTypes().asSequence()
-            else cls.filteredInterfaceTypes(filterReference).asSequence()
-
-        if (interfaces.any()) {
-            interfaces.sortedWith(TypeItem.totalComparator).forEach { item ->
+        val interfaces = cls.interfaceTypes()
+        if (interfaces.isNotEmpty()) {
+            interfaces.forEach { item ->
                 writer.print("<implements name=\"")
                 val type = item.toTypeString()
                 writer.print(XmlUtils.toXmlAttributeValue(formatType(type)))
@@ -275,8 +260,8 @@ class JDiffXmlWriter(
         }
     }
 
-    private fun writeParameterList(method: MethodItem) {
-        method.parameters().asSequence().forEach { parameter ->
+    private fun writeParameterList(callable: CallableItem) {
+        callable.parameters().asSequence().forEach { parameter ->
             // NOTE: We report parameter name as "null" rather than the real name to match
             // doclava's behavior
             writer.print("<parameter name=\"null\" type=\"")
@@ -294,13 +279,9 @@ class JDiffXmlWriter(
         return typeString.replace(",", ", ").replace(",  ", ", ")
     }
 
-    private fun writeThrowsList(method: MethodItem) {
-        val throws =
-            when {
-                preFiltered -> method.throwsTypes().asSequence()
-                else -> method.filteredThrowsTypes(filterReference).asSequence()
-            }
-        if (throws.any()) {
+    private fun writeThrowsList(callable: CallableItem) {
+        val throws = callable.throwsTypes()
+        if (throws.isNotEmpty()) {
             throws.sortedWith(ExceptionTypeItem.fullNameComparator).forEach { type ->
                 writer.print("<exception name=\"")
                 @Suppress("DEPRECATION") writer.print(type.fullName())
@@ -311,4 +292,29 @@ class JDiffXmlWriter(
             }
         }
     }
+
+    /**
+     * Create an [ApiVisitor] that will filter the [Item] to which is applied according to the
+     * supplied parameters and in a manner appropriate for writing signatures, e.g. not nesting
+     * classes. It will delegate any visitor calls that pass through its filter to this
+     * [JDiffXmlWriter] instance.
+     */
+    fun createFilteringVisitor(
+        filterEmit: Predicate<Item>,
+        filterReference: Predicate<Item>,
+        preFiltered: Boolean,
+        showUnannotated: Boolean,
+        filterSuperClassType: Boolean = true,
+    ): ApiVisitor =
+        FilteringApiVisitor(
+            this,
+            inlineInheritedFields = true,
+            interfaceListComparator = TypeItem.totalComparator,
+            filterEmit = filterEmit,
+            filterReference = filterReference,
+            preFiltered = preFiltered,
+            filterSuperClassType = filterSuperClassType,
+            showUnannotated = showUnannotated,
+            config = ApiVisitor.Config(),
+        )
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt b/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
index 8ff081e16..fb818a238 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
@@ -70,6 +70,10 @@ sealed interface JarCodebaseLoader {
             analyzer.computeApi()
             analyzer.mergeExternalQualifierAnnotations()
             analyzer.generateInheritedStubs(apiEmit, apiReference)
+
+            // Prevent the codebase from being mutated.
+            codebase.freezeClasses()
+
             return codebase
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt b/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
index 2e54f79fd..9a9d7ae1d 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
@@ -22,7 +22,6 @@ import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
 import com.android.tools.metalava.cli.common.stderr
-import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.BasicReporter
 import com.github.ajalt.clikt.parameters.arguments.argument
 
@@ -82,13 +81,14 @@ class JarToJDiffCommand :
 
                 createReportFile(progressTracker, codebase, xmlFile, "JDiff File") { printWriter ->
                     JDiffXmlWriter(
-                        writer = printWriter,
-                        filterEmit = apiEmit,
-                        filterReference = apiReference,
-                        preFiltered = false,
-                        showUnannotated = false,
-                        config = ApiVisitor.Config(),
-                    )
+                            writer = printWriter,
+                        )
+                        .createFilteringVisitor(
+                            filterEmit = apiEmit,
+                            filterReference = apiReference,
+                            preFiltered = false,
+                            showUnannotated = false,
+                        )
                 }
             }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
index ab56cab47..022cb6f15 100644
--- a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
@@ -16,26 +16,14 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.psi.PsiEnvironmentManager
-import com.android.tools.metalava.model.psi.PsiFieldItem
-import com.android.tools.metalava.model.psi.PsiParameterItem
-import com.android.tools.metalava.model.psi.report
-import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
-import com.intellij.lang.java.lexer.JavaLexer
-import org.jetbrains.kotlin.lexer.KtTokens
-import org.jetbrains.kotlin.psi.KtObjectDeclaration
-import org.jetbrains.kotlin.psi.KtProperty
-import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
-import org.jetbrains.kotlin.psi.psiUtil.isPublic
-import org.jetbrains.uast.UField
+import com.intellij.psi.util.PsiUtil
 
 // Enforces the interoperability guidelines outlined in
 //   https://android.github.io/kotlin-guides/interop.html
@@ -47,51 +35,22 @@ class KotlinInteropChecks(val reporter: Reporter) {
     private val javaLanguageLevel =
         PsiEnvironmentManager.javaLanguageLevelFromString(options.javaLanguageLevelAsString)
 
-    fun check(codebase: Codebase) {
-        codebase.accept(
-            object :
-                ApiVisitor(
-                    // Sort by source order such that warnings follow source line number order
-                    methodComparator = MethodItem.sourceOrderComparator,
-                    // No need to check "for stubs only APIs" (== "implicit" APIs)
-                    includeApisForStubPurposes = false,
-                    config = @Suppress("DEPRECATION") options.apiVisitorConfig,
-                ) {
-                private var isKotlin = false
-
-                override fun visitClass(cls: ClassItem) {
-                    isKotlin = cls.isKotlin()
-                }
-
-                override fun visitMethod(method: MethodItem) {
-                    checkMethod(method, isKotlin)
-                }
-
-                override fun visitField(field: FieldItem) {
-                    checkField(field, isKotlin)
-                }
-            }
-        )
-    }
-
     fun checkField(field: FieldItem, isKotlin: Boolean = field.isKotlin()) {
         if (isKotlin) {
-            ensureCompanionFieldJvmField(field)
+            field.ensureCompanionFieldJvmField()
         }
         ensureFieldNameNotKeyword(field)
     }
 
     fun checkMethod(method: MethodItem, isKotlin: Boolean = method.isKotlin()) {
-        if (!method.isConstructor()) {
-            if (isKotlin) {
-                ensureDefaultParamsHaveJvmOverloads(method)
-                ensureCompanionJvmStatic(method)
-                ensureExceptionsDocumented(method)
-            } else {
-                ensureMethodNameNotKeyword(method)
-                ensureParameterNamesNotKeywords(method)
-                ensureLambdaLastParameter(method)
-            }
+        if (isKotlin) {
+            ensureDefaultParamsHaveJvmOverloads(method)
+            ensureCompanionJvmStatic(method)
+            ensureExceptionsDocumented(method)
+        } else {
+            ensureMethodNameNotKeyword(method)
+            ensureParameterNamesNotKeywords(method)
+            ensureLambdaLastParameter(method)
         }
     }
 
@@ -100,11 +59,12 @@ class KotlinInteropChecks(val reporter: Reporter) {
             return
         }
 
-        val exceptions = method.findThrownExceptions()
+        val exceptions = method.body.findThrownExceptions()
         if (exceptions.isEmpty()) {
             return
         }
-        val doc = method.documentation.ifEmpty { method.property?.documentation.orEmpty() }
+        val doc =
+            method.documentation.text.ifEmpty { method.property?.documentation?.text.orEmpty() }
         for (exception in exceptions.sortedBy { it.qualifiedName() }) {
             val checked =
                 !(exception.extends("java.lang.RuntimeException") ||
@@ -139,76 +99,6 @@ class KotlinInteropChecks(val reporter: Reporter) {
         }
     }
 
-    private fun ensureCompanionFieldJvmField(field: FieldItem) {
-        val modifiers = field.modifiers
-        if (modifiers.isPublic() && modifiers.isFinal()) {
-            // UAST will inline const fields into the surrounding class, so we have to
-            // dip into Kotlin PSI to figure out if this field was really declared in
-            // a companion object
-            val psi = (field as PsiFieldItem).psi()
-            if (psi is UField) {
-                val sourcePsi = psi.sourcePsi
-                if (sourcePsi is KtProperty) {
-                    val companionClassName = sourcePsi.containingClassOrObject?.name
-                    if (companionClassName == "Companion") {
-                        // JvmField cannot be applied to const property
-                        // (https://github.com/JetBrains/kotlin/blob/dc7b1fbff946d1476cc9652710df85f65664baee/compiler/frontend.java/src/org/jetbrains/kotlin/resolve/jvm/checkers/JvmFieldApplicabilityChecker.kt#L46)
-                        if (!modifiers.isConst()) {
-                            if (modifiers.findAnnotation("kotlin.jvm.JvmField") == null) {
-                                reporter.report(
-                                    Issues.MISSING_JVMSTATIC,
-                                    field,
-                                    "Companion object constants like ${field.name()} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
-                                )
-                            } else if (modifiers.findAnnotation("kotlin.jvm.JvmStatic") != null) {
-                                reporter.report(
-                                    Issues.MISSING_JVMSTATIC,
-                                    field,
-                                    "Companion object constants like ${field.name()} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
-                                )
-                            }
-                        }
-                    }
-                } else if (sourcePsi is KtObjectDeclaration && sourcePsi.isCompanion()) {
-                    // We are checking if we have public properties that we can expect to be
-                    // constant
-                    // (that is, declared via `val`) but that aren't declared 'const' in a companion
-                    // object that are not annotated with @JvmField or annotated with @JvmStatic
-                    // https://developer.android.com/kotlin/interop#companion_constants
-                    val ktProperties =
-                        sourcePsi.declarations.filter { declaration ->
-                            declaration is KtProperty &&
-                                declaration.isPublic &&
-                                !declaration.isVar &&
-                                !declaration.hasModifier(KtTokens.CONST_KEYWORD) &&
-                                declaration.annotationEntries.none { annotationEntry ->
-                                    annotationEntry.shortName?.asString() == "JvmField"
-                                }
-                        }
-                    for (ktProperty in ktProperties) {
-                        if (
-                            ktProperty.annotationEntries.none { annotationEntry ->
-                                annotationEntry.shortName?.asString() == "JvmStatic"
-                            }
-                        ) {
-                            reporter.report(
-                                Issues.MISSING_JVMSTATIC,
-                                ktProperty,
-                                "Companion object constants like ${ktProperty.name} should be marked @JvmField for Java interoperability; see https://developer.android.com/kotlin/interop#companion_constants"
-                            )
-                        } else {
-                            reporter.report(
-                                Issues.MISSING_JVMSTATIC,
-                                ktProperty,
-                                "Companion object constants like ${ktProperty.name} should be using @JvmField, not @JvmStatic; see https://developer.android.com/kotlin/interop#companion_constants"
-                            )
-                        }
-                    }
-                }
-            }
-        }
-    }
-
     private fun ensureLambdaLastParameter(method: MethodItem) {
         val parameters = method.parameters()
         if (parameters.size > 1) {
@@ -377,7 +267,7 @@ class KotlinInteropChecks(val reporter: Reporter) {
             "java.lang.Iterable" -> return false
         }
 
-        return parameter is PsiParameterItem && parameter.isSamCompatibleOrKotlinLambda()
+        return parameter.isSamCompatibleOrKotlinLambda()
     }
 
     private fun isKotlinHardKeyword(keyword: String): Boolean {
@@ -419,6 +309,6 @@ class KotlinInteropChecks(val reporter: Reporter) {
 
     /** Returns true if the given string is a reserved Java keyword */
     private fun isJavaKeyword(keyword: String): Boolean {
-        return JavaLexer.isKeyword(keyword, javaLanguageLevel)
+        return PsiUtil.isKeyword(keyword, javaLanguageLevel)
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
index 7afe7bd53..ec39b95e7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
@@ -35,6 +35,7 @@ import com.android.tools.metalava.cli.lint.ApiLintOptions
 import com.android.tools.metalava.cli.signature.SignatureFormatOptions
 import com.android.tools.metalava.model.source.SourceModelProvider
 import com.android.tools.metalava.reporter.DEFAULT_BASELINE_NAME
+import com.android.tools.metalava.reporter.DefaultReporter
 import com.github.ajalt.clikt.core.CliktCommand
 import com.github.ajalt.clikt.core.context
 import com.github.ajalt.clikt.parameters.arguments.argument
@@ -185,21 +186,21 @@ class MainCommand(
             executionEnvironment.testEnvironment?.sourceModelProvider
             // Otherwise, use the one specified on the command line, or the default.
             ?: SourceModelProvider.getImplementation(optionGroup.sourceModelProvider)
-        sourceModelProvider
-            .createEnvironmentManager(executionEnvironment.disableStderrDumping())
-            .use { processFlags(executionEnvironment, it, progressTracker) }
 
-        if (
-            optionGroup.allReporters.any { it.hasErrors() } &&
-                !commonBaselineOptions.passBaselineUpdates
-        ) {
+        try {
+            sourceModelProvider
+                .createEnvironmentManager(executionEnvironment.disableStderrDumping())
+                .use { processFlags(executionEnvironment, it, progressTracker) }
+        } finally {
+            // Write all saved reports. Do this even if the previous code threw an exception.
+            optionGroup.allReporters.forEach { it.writeSavedReports() }
+        }
+
+        val allReporters = optionGroup.allReporters
+        if (allReporters.any { it.hasErrors() } && !commonBaselineOptions.passBaselineUpdates) {
             // Repeat the errors at the end to make it easy to find the actual problems.
             if (issueReportingOptions.repeatErrorsMax > 0) {
-                repeatErrors(
-                    stderr,
-                    optionGroup.allReporters,
-                    issueReportingOptions.repeatErrorsMax
-                )
+                repeatErrors(stderr, allReporters, issueReportingOptions.repeatErrorsMax)
             }
 
             // Make sure that the process exits with an error code.
diff --git a/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt b/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt
index 39cb20a8d..423ee8ba5 100644
--- a/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt
@@ -30,7 +30,6 @@ class MarkPackagesAsRecent(val filter: PackageFilter) :
     ApiVisitor(
         filterEmit = apiPredicate(),
         filterReference = apiPredicate(),
-        includeEmptyOuterClasses = true,
         config = @Suppress("DEPRECATION") options.apiVisitorConfig,
     ) {
     override fun include(cls: ClassItem): Boolean {
diff --git a/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt b/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
index c45f7f6fb..c79760dc5 100644
--- a/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava
 import com.android.tools.metalava.cli.common.MetalavaCliException
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
@@ -49,16 +50,16 @@ class NullabilityAnnotationsValidator(
     }
 
     private interface Issue {
-        val method: MethodItem
+        val callable: CallableItem
     }
 
     private data class Error(
-        override val method: MethodItem,
+        override val callable: CallableItem,
         val label: String,
         val type: ErrorType
     ) : Issue {
         override fun toString(): String {
-            return "ERROR: $method, $label, $type"
+            return "ERROR: $callable, $label, $type"
         }
     }
 
@@ -67,12 +68,12 @@ class NullabilityAnnotationsValidator(
     }
 
     private data class Warning(
-        override val method: MethodItem,
+        override val callable: CallableItem,
         val label: String,
         val type: WarningType
     ) : Issue {
         override fun toString(): String {
-            return "WARNING: $method, $label, $type"
+            return "WARNING: $callable, $label, $type"
         }
     }
 
@@ -80,8 +81,8 @@ class NullabilityAnnotationsValidator(
     private val warnings: MutableList<Warning> = mutableListOf()
 
     /**
-     * Validate all of the methods in the classes named in [topLevelClassNames] and in all their
-     * nested classes. Violations are stored by the validator and will be reported by [report].
+     * Validate all the methods in the classes named in [topLevelClassNames] and in all their nested
+     * classes. Violations are stored by the validator and will be reported by [report].
      */
     fun validateAll(codebase: Codebase, topLevelClassNames: List<String>) {
         for (topLevelClassName in topLevelClassNames) {
@@ -92,11 +93,10 @@ class NullabilityAnnotationsValidator(
                     )
             // Visit methods to check their return type, and parameters to check them. Don't visit
             // constructors as we don't want to check their return types. This visits members of
-            // inner classes as well.
+            // nested classes as well.
             topLevelClass.accept(
                 object :
                     ApiVisitor(
-                        visitConstructorsAsMethods = false,
                         config = @Suppress("DEPRECATION") options.apiVisitorConfig,
                     ) {
 
@@ -106,7 +106,7 @@ class NullabilityAnnotationsValidator(
 
                     override fun visitParameter(parameter: ParameterItem) {
                         checkItem(
-                            parameter.containingMethod(),
+                            parameter.containingCallable(),
                             parameter.toString(),
                             parameter.type(),
                             parameter
@@ -134,24 +134,24 @@ class NullabilityAnnotationsValidator(
         }
     }
 
-    private fun checkItem(method: MethodItem, label: String, type: TypeItem?, item: Item) {
+    private fun checkItem(callable: CallableItem, label: String, type: TypeItem?, item: Item) {
         if (type == null) {
-            throw MetalavaCliException("Missing type on $method item $label")
+            throw MetalavaCliException("Missing type on $callable item $label")
         }
         val annotations = item.modifiers.annotations()
         val nullabilityAnnotations = annotations.filter(this::isAnyNullabilityAnnotation)
         if (nullabilityAnnotations.size > 1) {
-            errors.add(Error(method, label, ErrorType.MULTIPLE))
+            errors.add(Error(callable, label, ErrorType.MULTIPLE))
             return
         }
-        checkItemNullability(type, nullabilityAnnotations.firstOrNull(), method, label)
+        checkItemNullability(type, nullabilityAnnotations.firstOrNull(), callable, label)
         // TODO: When type annotations are supported, we should check all the type parameters too.
         // We can do invoke this method recursively, using a suitably descriptive label.
         assert(!SUPPORT_TYPE_USE_ANNOTATIONS)
     }
 
     private fun isNullFromTypeParam(it: AnnotationItem) =
-        it.qualifiedName?.endsWith("NullFromTypeParam") == true
+        it.qualifiedName.endsWith("NullFromTypeParam")
 
     private fun isAnyNullabilityAnnotation(it: AnnotationItem) =
         it.isNullnessAnnotation() || isNullFromTypeParam(it)
@@ -159,22 +159,22 @@ class NullabilityAnnotationsValidator(
     private fun checkItemNullability(
         type: TypeItem,
         nullability: AnnotationItem?,
-        method: MethodItem,
+        callable: CallableItem,
         label: String
     ) {
         when {
             // Primitive (may not have nullability):
             type is PrimitiveTypeItem -> {
                 if (nullability != null) {
-                    errors.add(Error(method, label, ErrorType.ON_PRIMITIVE))
+                    errors.add(Error(callable, label, ErrorType.ON_PRIMITIVE))
                 }
             }
             // Array (see comment):
             type is ArrayTypeItem -> {
                 // TODO: When type annotations are supported, we should check the annotation on both
                 // the array itself and the component type. Until then, there's nothing we can
-                // safely do, because e.g. a method parameter declared as '@NonNull Object[]' means
-                // a non-null array of unspecified-nullability Objects if that is a PARAMETER
+                // safely do, because e.g. a callable parameter declared as '@NonNull Object[]'
+                // means a non-null array of unspecified-nullability Objects if that is a PARAMETER
                 // annotation, but an unspecified-nullability array of non-null Objects if that is a
                 // TYPE_USE annotation.
                 assert(!SUPPORT_TYPE_USE_ANNOTATIONS)
@@ -182,15 +182,16 @@ class NullabilityAnnotationsValidator(
             // Type parameter reference (should have nullability):
             type is VariableTypeItem -> {
                 if (nullability == null) {
-                    warnings.add(Warning(method, label, WarningType.MISSING))
+                    warnings.add(Warning(callable, label, WarningType.MISSING))
                 }
             }
             // Anything else (should have nullability, may not be null-from-type-param):
             else -> {
                 when {
-                    nullability == null -> warnings.add(Warning(method, label, WarningType.MISSING))
+                    nullability == null ->
+                        warnings.add(Warning(callable, label, WarningType.MISSING))
                     isNullFromTypeParam(nullability) ->
-                        errors.add(Error(method, label, ErrorType.BAD_TYPE_PARAM))
+                        errors.add(Error(callable, label, ErrorType.BAD_TYPE_PARAM))
                 }
             }
         }
@@ -222,7 +223,7 @@ class NullabilityAnnotationsValidator(
         // Fatal issues are thrown.
         if (fatalIssues.isNotEmpty()) {
             fatalIssues.forEach {
-                reporter.report(Issues.INVALID_NULLABILITY_ANNOTATION, it.method, it.toString())
+                reporter.report(Issues.INVALID_NULLABILITY_ANNOTATION, it.callable, it.toString())
             }
         }
 
@@ -235,7 +236,7 @@ class NullabilityAnnotationsValidator(
             nonFatalIssues.forEach {
                 reporter.report(
                     Issues.INVALID_NULLABILITY_ANNOTATION_WARNING,
-                    it.method,
+                    it.callable,
                     "Nullability issue: $it"
                 )
             }
diff --git a/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt b/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt
index 7b2669824..c76d18e9a 100644
--- a/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt
@@ -17,10 +17,10 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.TypeItem
@@ -29,13 +29,13 @@ import com.android.tools.metalava.model.hasAnnotation
 
 /**
  * Performs null migration analysis, looking at previous API signature files and new signature
- * files, and replacing new @Nullable and @NonNull annotations with @RecentlyNullable
- * and @RecentlyNonNull.
+ * files, and replacing @Nullable and @NonNull annotations added to APIs that have previously been
+ * released with @RecentlyNullable and @RecentlyNonNull.
  *
  * TODO: Enforce compatibility across type use annotations, e.g. changing parameter value from
  *   {@code @NonNull List<@Nullable String>} to {@code @NonNull List<@NonNull String>} is forbidden.
  */
-class NullnessMigration : ComparisonVisitor(visitAddedItemsRecursively = true) {
+class NullnessMigration : ComparisonVisitor() {
     override fun compare(old: Item, new: Item) {
         if (hasNullnessInformation(new) && !hasNullnessInformation(old)) {
             new.markRecent()
@@ -46,7 +46,7 @@ class NullnessMigration : ComparisonVisitor(visitAddedItemsRecursively = true) {
     // having nullness annotations: those APIs are themselves new, so there's no reason
     // to mark the nullness contract as migration (warning- rather than error-severity)
 
-    override fun compare(old: MethodItem, new: MethodItem) {
+    override fun compare(old: CallableItem, new: CallableItem) {
         @Suppress("ConstantConditionIf")
         if (SUPPORT_TYPE_USE_ANNOTATIONS) {
             val newType = new.returnType()
@@ -126,8 +126,12 @@ fun Item.markRecent() {
     // Nullness information change: Add migration annotation
     val annotationClass = if (annotation.isNullable()) RECENTLY_NULLABLE else RECENTLY_NONNULL
 
-    val modifiers = mutableModifiers()
-    modifiers.removeAnnotation(annotation)
+    val replacementAnnotation = codebase.createAnnotation("@$annotationClass", this)
 
-    modifiers.addAnnotation(codebase.createAnnotation("@$annotationClass", this))
+    mutateModifiers {
+        mutateAnnotations {
+            remove(annotation)
+            replacementAnnotation?.let { add(it) }
+        }
+    }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/Options.kt b/metalava/src/main/java/com/android/tools/metalava/Options.kt
index 8a0a0a8d1..df7b7a9f6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Options.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Options.kt
@@ -23,12 +23,15 @@ import com.android.tools.metalava.cli.common.CommonOptions
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.cli.common.IssueReportingOptions
 import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.PreviouslyReleasedApi
 import com.android.tools.metalava.cli.common.SourceOptions
 import com.android.tools.metalava.cli.common.Terminal
 import com.android.tools.metalava.cli.common.TerminalColor
 import com.android.tools.metalava.cli.common.Verbosity
 import com.android.tools.metalava.cli.common.enumOption
+import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.fileForPathInner
+import com.android.tools.metalava.cli.common.map
 import com.android.tools.metalava.cli.common.stringToExistingDir
 import com.android.tools.metalava.cli.common.stringToExistingFile
 import com.android.tools.metalava.cli.common.stringToNewDir
@@ -39,15 +42,21 @@ import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
 import com.android.tools.metalava.cli.lint.ApiLintOptions
 import com.android.tools.metalava.cli.signature.SignatureFormatOptions
+import com.android.tools.metalava.config.ConfigParser
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.manifest.emptyManifest
 import com.android.tools.metalava.model.AnnotationManager
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.TypedefMode
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.source.DEFAULT_KOTLIN_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.text.ApiClassResolution
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Baseline
+import com.android.tools.metalava.reporter.DefaultReporter
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.Reportable
 import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.stub.StubWriterConfig
 import com.android.utils.SdkUtils.wrap
@@ -66,6 +75,7 @@ import java.io.IOException
 import java.io.PrintWriter
 import java.io.StringWriter
 import java.util.Optional
+import java.util.function.Predicate
 import kotlin.properties.ReadWriteProperty
 import kotlin.reflect.KProperty
 import org.jetbrains.jps.model.java.impl.JavaSdkUtil
@@ -136,7 +146,6 @@ private const val INDENT_WIDTH = 45
 const val ARG_CLASS_PATH = "--classpath"
 const val ARG_SOURCE_FILES = "--source-files"
 const val ARG_API_CLASS_RESOLUTION = "--api-class-resolution"
-const val ARG_DEX_API = "--dex-api"
 const val ARG_SDK_VALUES = "--sdk-values"
 const val ARG_MERGE_QUALIFIER_ANNOTATIONS = "--merge-qualifier-annotations"
 const val ARG_MERGE_INCLUSION_ANNOTATIONS = "--merge-inclusion-annotations"
@@ -152,7 +161,6 @@ const val ARG_EXTRACT_ANNOTATIONS = "--extract-annotations"
 const val ARG_EXCLUDE_DOCUMENTATION_FROM_STUBS = "--exclude-documentation-from-stubs"
 const val ARG_ENHANCE_DOCUMENTATION = "--enhance-documentation"
 const val ARG_SKIP_READING_COMMENTS = "--ignore-comments"
-const val ARG_HIDE_PACKAGE = "--hide-package"
 const val ARG_MANIFEST = "--manifest"
 const val ARG_MIGRATE_NULLNESS = "--migrate-nullness"
 const val ARG_HIDE_ANNOTATION = "--hide-annotation"
@@ -180,7 +188,6 @@ const val ARG_INCLUDE_SOURCE_RETENTION = "--include-source-retention"
 const val ARG_PASS_THROUGH_ANNOTATION = "--pass-through-annotation"
 const val ARG_EXCLUDE_ANNOTATION = "--exclude-annotation"
 const val ARG_STUB_PACKAGES = "--stub-packages"
-const val ARG_STUB_IMPORT_PACKAGES = "--stub-import-packages"
 const val ARG_DELETE_EMPTY_REMOVED_SIGNATURES = "--delete-empty-removed-signatures"
 const val ARG_SUBTRACT_API = "--subtract-api"
 const val ARG_TYPEDEFS_IN_SIGNATURES = "--typedefs-in-signatures"
@@ -188,7 +195,9 @@ const val ARG_IGNORE_CLASSES_ON_CLASSPATH = "--ignore-classes-on-classpath"
 const val ARG_SDK_JAR_ROOT = "--sdk-extensions-root"
 const val ARG_SDK_INFO_FILE = "--sdk-extensions-info"
 const val ARG_USE_K2_UAST = "--Xuse-k2-uast"
+const val ARG_PROJECT = "--project"
 const val ARG_SOURCE_MODEL_PROVIDER = "--source-model-provider"
+const val ARG_CONFIG_FILE = "--config-file"
 
 class Options(
     private val commonOptions: CommonOptions = CommonOptions(),
@@ -221,14 +230,10 @@ class Options(
     private val hideAnnotationsBuilder = AnnotationFilterBuilder()
     /** Internal builder backing [revertAnnotations] */
     private val revertAnnotationsBuilder = AnnotationFilterBuilder()
-    /** Internal list backing [stubImportPackages] */
-    private val mutableStubImportPackages: MutableSet<String> = mutableSetOf()
     /** Internal list backing [mergeQualifierAnnotations] */
     private val mutableMergeQualifierAnnotations: MutableList<File> = mutableListOf()
     /** Internal list backing [mergeInclusionAnnotations] */
     private val mutableMergeInclusionAnnotations: MutableList<File> = mutableListOf()
-    /** Internal list backing [hidePackages] */
-    private val mutableHidePackages: MutableList<String> = mutableListOf()
     /** Internal list backing [passThroughAnnotations] */
     private val mutablePassThroughAnnotations: MutableSet<String> = mutableSetOf()
     /** Internal list backing [excludeAnnotations] */
@@ -315,6 +320,23 @@ class Options(
     /** All source files to parse */
     var sources: List<File> = mutableSources
 
+    /** Lint project description that describes project's module structure in details */
+    var projectDescription: File? = null
+
+    val configFiles by
+        option(
+                ARG_CONFIG_FILE,
+                help =
+                    """
+                        A configuration file that can be consumed by Metalava. This can be specified
+                        multiple times in which case later config files will override/merge with
+                        earlier ones.
+                    """,
+                metavar = "<file>",
+            )
+            .existingFile()
+            .multiple(required = false)
+
     val apiClassResolution by
         enumOption(
             help =
@@ -339,11 +361,25 @@ class Options(
     /** Packages to include (if null, include all) */
     private var stubPackages: PackageFilter? = null
 
-    /** Packages to import (if empty, include all) */
-    private var stubImportPackages: Set<String> = mutableStubImportPackages
-
-    /** Packages to exclude/hide */
-    var hidePackages: List<String> = mutableHidePackages
+    /**
+     * An optional [Reportable] predicate that will ignore issues from (i.e. return false for)
+     * [Item]s that do not match the [stubPackages] filter. If no [stubPackages] filter is provided
+     * then this will be `null`.
+     */
+    private val reportableFilter: Predicate<Reportable>? by
+        lazy(LazyThreadSafetyMode.NONE) {
+            stubPackages?.let { packageFilter ->
+                Predicate { reportable ->
+                    // If we are only emitting some packages (--stub-packages), don't report
+                    // issues from other packages
+                    (reportable as? Item)?.let { item ->
+                        val pkg = (item as? PackageItem) ?: item.containingPackage()
+                        pkg == null || packageFilter.matches(pkg)
+                    }
+                        ?: true
+                }
+            }
+        }
 
     /** Packages that we should skip generating even if not hidden; typically only used by tests */
     val skipEmitPackages
@@ -416,11 +452,9 @@ class Options(
     val apiAnalyzerConfig by lazy {
         ApiAnalyzer.Config(
             manifest = manifest,
-            hidePackages = hidePackages,
             skipEmitPackages = skipEmitPackages,
             mergeQualifierAnnotations = mergeQualifierAnnotations,
             mergeInclusionAnnotations = mergeInclusionAnnotations,
-            stubImportPackages = stubImportPackages,
             allShowAnnotations = allShowAnnotations,
             apiPredicateConfig = apiPredicateConfig,
         )
@@ -450,7 +484,6 @@ class Options(
 
     internal val stubWriterConfig by lazy {
         StubWriterConfig(
-            apiVisitorConfig = apiVisitorConfig,
             kotlinStubs = kotlinStubs,
             includeDocumentationInStubs = includeDocumentationInStubs,
         )
@@ -480,9 +513,6 @@ class Options(
     /** Like [apiFile], but with JDiff xml format. */
     var apiXmlFile: File? = null
 
-    /** If set, a file to write the DEX signatures to. Corresponds to [ARG_DEX_API]. */
-    var dexApiFile: File? = null
-
     /** Path to directory to write SDK values to */
     var sdkValueDir: File? = null
 
@@ -519,13 +549,32 @@ class Options(
     private var excludeAnnotations = mutableExcludeAnnotations
 
     /** A signature file to migrate nullness data from */
-    var migrateNullsFrom: File? = null
+    val migrateNullsFrom by
+        option(
+                ARG_MIGRATE_NULLNESS,
+                metavar = "<api file>",
+                help =
+                    """
+                        Compare nullness information with the previous stable API
+                        and mark newly annotated APIs as under migration.
+                    """
+                        .trimIndent()
+            )
+            .existingFile()
+            .multiple()
+            .map {
+                PreviouslyReleasedApi.optionalPreviouslyReleasedApi(
+                    ARG_MIGRATE_NULLNESS,
+                    it,
+                    onlyUseLastForCurrentApiSurface = false
+                )
+            }
 
     /** The list of compatibility checks to run */
     val compatibilityChecks: List<CheckRequest> by compatibilityCheckOptions::compatibilityChecks
 
-    /** The API to use a base for the otherwise checked API during compat checks. */
-    val baseApiForCompatCheck by compatibilityCheckOptions::baseApiForCompatCheck
+    /** The set of annotation classes that should be treated as API compatibility important */
+    val apiCompatAnnotations by compatibilityCheckOptions::apiCompatAnnotations
 
     /** Existing external annotation files to merge in */
     private var mergeQualifierAnnotations: List<File> = mutableMergeQualifierAnnotations
@@ -608,15 +657,9 @@ class Options(
     /** [IssueConfiguration] used by all reporters. */
     val issueConfiguration by issueReportingOptions::issueConfiguration
 
-    /** [Reporter] for general use. */
+    /** [Reporter] that will redirect [Issues.Issue] depending on their [Issues.Category]. */
     lateinit var reporter: Reporter
-
-    /**
-     * [Reporter] for "api-lint".
-     *
-     * Initialized in [parse].
-     */
-    lateinit var reporterApiLint: Reporter
+        private set
 
     /**
      * [Reporter] for "check-compatibility:*:released". (i.e. [ARG_CHECK_COMPATIBILITY_API_RELEASED]
@@ -624,7 +667,7 @@ class Options(
      *
      * Initialized in [parse].
      */
-    lateinit var reporterCompatibilityReleased: Reporter
+    private lateinit var reporterCompatibilityReleased: Reporter
 
     internal var allReporters: List<DefaultReporter> = emptyList()
 
@@ -740,7 +783,6 @@ class Options(
                     nullabilityWarningsTxt = stringToNewFile(getValue(args, ++index))
                 ARG_NULLABILITY_ERRORS_NON_FATAL -> nullabilityErrorsFatal = false
                 ARG_SDK_VALUES -> sdkValueDir = stringToNewDir(getValue(args, ++index))
-                ARG_DEX_API -> dexApiFile = stringToNewFile(getValue(args, ++index))
                 ARG_SHOW_UNANNOTATED -> showUnannotated = true
                 ARG_HIDE_ANNOTATION -> hideAnnotationsBuilder.add(getValue(args, ++index))
                 ARG_REVERT_ANNOTATION -> revertAnnotationsBuilder.add(getValue(args, ++index))
@@ -760,7 +802,6 @@ class Options(
                     annotations.split(",").forEach { path -> mutableExcludeAnnotations.add(path) }
                 }
                 ARG_PROGUARD -> proguard = stringToNewFile(getValue(args, ++index))
-                ARG_HIDE_PACKAGE -> mutableHidePackages.add(getValue(args, ++index))
                 ARG_STUB_PACKAGES -> {
                     val packages = getValue(args, ++index)
                     val filter =
@@ -772,22 +813,12 @@ class Options(
                             }
                     filter.addPackages(packages)
                 }
-                ARG_STUB_IMPORT_PACKAGES -> {
-                    val packages = getValue(args, ++index)
-                    for (pkg in packages.split(File.pathSeparatorChar)) {
-                        mutableStubImportPackages.add(pkg)
-                        mutableHidePackages.add(pkg)
-                    }
-                }
                 ARG_IGNORE_CLASSES_ON_CLASSPATH -> {
                     allowClassesFromClasspath = false
                 }
                 ARG_DELETE_EMPTY_REMOVED_SIGNATURES -> deleteEmptyRemovedSignatures = true
                 ARG_EXTRACT_ANNOTATIONS ->
                     externalAnnotations = stringToNewFile(getValue(args, ++index))
-                ARG_MIGRATE_NULLNESS -> {
-                    migrateNullsFrom = stringToExistingFile(getValue(args, ++index))
-                }
 
                 // Extracting API levels
                 ARG_ANDROID_JAR_PATTERN -> {
@@ -862,6 +893,9 @@ class Options(
                     compileSdkVersion = getValue(args, ++index)
                 }
                 ARG_USE_K2_UAST -> useK2Uast = true
+                ARG_PROJECT -> {
+                    projectDescription = stringToExistingFile(getValue(args, ++index))
+                }
                 ARG_SDK_JAR_ROOT -> {
                     sdkJarRoot = stringToExistingDir(getValue(args, ++index))
                 }
@@ -942,31 +976,38 @@ class Options(
 
         // Initialize the reporters.
         val baseline = generalReportingOptions.baseline
-        reporter =
-            DefaultReporter(
-                environment = executionEnvironment.reporterEnvironment,
-                issueConfiguration = issueConfiguration,
+        val reporterUnknown =
+            createReporter(
+                executionEnvironment = executionEnvironment,
                 baseline = baseline,
-                packageFilter = stubPackages,
-                config = issueReportingOptions.reporterConfig,
+                errorMessage = null,
             )
-        reporterApiLint =
-            DefaultReporter(
-                environment = executionEnvironment.reporterEnvironment,
-                issueConfiguration = issueConfiguration,
+
+        val reporterApiLint =
+            createReporter(
+                executionEnvironment = executionEnvironment,
                 baseline = apiLintOptions.baseline ?: baseline,
                 errorMessage = apiLintOptions.errorMessage,
-                packageFilter = stubPackages,
-                config = issueReportingOptions.reporterConfig,
             )
-        reporterCompatibilityReleased =
-            DefaultReporter(
-                environment = executionEnvironment.reporterEnvironment,
-                issueConfiguration = issueConfiguration,
+
+        // [Reporter] for "check-compatibility:*:released".
+        // i.e.
+        //      [ARG_CHECK_COMPATIBILITY_API_RELEASED] and
+        //      [ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED].
+        val reporterCompatibilityReleased =
+            createReporter(
+                executionEnvironment = executionEnvironment,
                 baseline = compatibilityCheckOptions.baseline ?: baseline,
                 errorMessage = compatibilityCheckOptions.errorMessage,
-                packageFilter = stubPackages,
-                config = issueReportingOptions.reporterConfig,
+            )
+
+        // A Reporter that will redirect issues to the appropriate reporter based on the issue's
+        // Category.
+        reporter =
+            CategoryRedirectingReporter(
+                defaultReporter = reporterUnknown,
+                apiLintReporter = reporterApiLint,
+                compatibilityReporter = reporterCompatibilityReleased,
             )
 
         // Build "all baselines" and "all reporters"
@@ -976,19 +1017,38 @@ class Options(
             listOfNotNull(baseline, apiLintOptions.baseline, compatibilityCheckOptions.baseline)
 
         // Reporters are non-null.
-        // Downcast to DefaultReporter to gain access to some implementation specific functionality.
         allReporters =
             listOf(
-                    issueReportingOptions.bootstrapReporter,
-                    reporter,
-                    reporterApiLint,
-                    reporterCompatibilityReleased,
-                )
-                .map { it as DefaultReporter }
+                issueReportingOptions.bootstrapReporter,
+                reporterUnknown,
+                reporterApiLint,
+                reporterCompatibilityReleased,
+            )
 
         updateClassPath()
+
+        // Make sure that any config files are processed.
+        ConfigParser.parse(reporter, configFiles)
     }
 
+    /**
+     * Create a [Reporter] that checks for known issues in [baseline] and prints [errorMessage], if
+     * provided, when errors have been reported.
+     */
+    private fun createReporter(
+        executionEnvironment: ExecutionEnvironment,
+        baseline: Baseline?,
+        errorMessage: String?,
+    ) =
+        DefaultReporter(
+            environment = executionEnvironment.reporterEnvironment,
+            issueConfiguration = issueConfiguration,
+            baseline = baseline,
+            errorMessage = errorMessage,
+            reportableFilter = reportableFilter,
+            config = issueReportingOptions.reporterConfig,
+        )
+
     fun isDeveloperPreviewBuild(): Boolean = currentCodeName != null
 
     /** Update the classpath to insert android.jar or JDK classpath elements if necessary */
@@ -1047,9 +1107,7 @@ class Options(
         }
 
         // Get all the android.jar. They are in platforms-#
-        var apiLevel = minApi - 1
-        while (true) {
-            apiLevel++
+        for (apiLevel in minApi.rangeTo(currentApiLevel)) {
             try {
                 var jar: File? = null
                 if (apiLevel == currentApiLevel) {
@@ -1183,6 +1241,8 @@ object OptionsHelp {
                 "One or more directories or jars (separated by " +
                     "`${File.pathSeparator}`) containing classes that should be on the classpath when parsing the " +
                     "source files",
+                "$ARG_PROJECT <xmlfile>",
+                "Project description written in XML according to Lint's project model.",
                 "$ARG_MERGE_QUALIFIER_ANNOTATIONS <file>",
                 "An external annotations file to merge and overlay " +
                     "the sources, or a directory of such files. Should be used for annotations intended for " +
@@ -1207,9 +1267,6 @@ object OptionsHelp {
                 "Specifies that errors encountered during validation of " +
                     "nullability annotations should not be treated as errors. They will be written out to the " +
                     "file specified in $ARG_NULLABILITY_WARNINGS_TXT instead.",
-                "$ARG_HIDE_PACKAGE <package>",
-                "Remove the given packages from the API even if they have not been " +
-                    "marked with @hide",
                 "$ARG_HIDE_ANNOTATION <annotation class>",
                 "Treat any elements annotated with the given annotation " + "as hidden",
                 ARG_SHOW_UNANNOTATED,
@@ -1242,8 +1299,6 @@ object OptionsHelp {
                 "",
                 "Extracting Signature Files:",
                 // TODO: Document --show-annotation!
-                "$ARG_DEX_API <file>",
-                "Generate a DEX signature descriptor file listing the APIs",
                 "$ARG_PROGUARD <file>",
                 "Write a ProGuard keep file for the API",
                 "$ARG_SDK_VALUES <dir>",
@@ -1274,11 +1329,6 @@ object OptionsHelp {
                     "from the generated stubs. (Copyright notices are not affected by this, they are always included. " +
                     "Documentation stubs (--doc-stubs) are not affected.)",
                 "",
-                "Diffs and Checks:",
-                "$ARG_MIGRATE_NULLNESS <api file>",
-                "Compare nullness information with the previous stable API " +
-                    "and mark newly annotated APIs as under migration.",
-                "",
                 "Extracting Annotations:",
                 "$ARG_EXTRACT_ANNOTATIONS <zipfile>",
                 "Extracts source annotations from the source files and writes " +
diff --git a/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt b/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt
index d555eefc7..6dc259930 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt
@@ -19,33 +19,21 @@ package com.android.tools.metalava
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.VisibilityLevel
-import com.android.tools.metalava.model.visitors.ApiVisitor
 import java.io.PrintWriter
-import java.util.function.Predicate
 
 class ProguardWriter(
     private val writer: PrintWriter,
-    filterEmit: Predicate<Item>,
-    filterReference: Predicate<Item>
-) :
-    ApiVisitor(
-        visitConstructorsAsMethods = false,
-        nestInnerClasses = false,
-        inlineInheritedFields = true,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
-        config = @Suppress("DEPRECATION") options.apiVisitorConfig,
-    ) {
+) : DelegatedVisitor {
 
     override fun visitClass(cls: ClassItem) {
         writer.print("-keep class ")
-        writer.print(cls.qualifiedNameWithDollarInnerClasses())
+        writer.print(cls.qualifiedNameWithDollarNestedClasses())
         writer.print(" {\n")
     }
 
@@ -132,6 +120,6 @@ class ProguardWriter(
         t ?: return ""
         if (t is ArrayTypeItem) return getCleanTypeName(t.componentType) + "[]"
         val cls = t.asClass() ?: return t.toCanonicalType()
-        return cls.qualifiedNameWithDollarInnerClasses()
+        return cls.qualifiedNameWithDollarNestedClasses()
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt b/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt
index 5deca4bef..9c776ae4f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt
@@ -38,7 +38,11 @@ class SignatureFileCache(annotationManager: AnnotationManager) {
     fun load(signatureFiles: List<SignatureFile>, classResolver: ClassResolver? = null): Codebase {
         val key = CacheKey(signatureFiles, classResolver)
         return map.computeIfAbsent(key) { k ->
-            signatureFileLoader.loadFiles(k.signatureFiles, k.classResolver)
+            signatureFileLoader.loadFiles(k.signatureFiles, k.classResolver).apply {
+                // Freeze the classes before caching to avoid any changes being made to cached and
+                // potentially shared objects.
+                freezeClasses()
+            }
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt b/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
index 365935484..274380da7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
@@ -16,8 +16,11 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
@@ -29,30 +32,15 @@ import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import java.io.PrintWriter
-import java.util.BitSet
-import java.util.function.Predicate
 
 class SignatureWriter(
     private val writer: PrintWriter,
-    filterEmit: Predicate<Item>,
-    filterReference: Predicate<Item>,
-    private val preFiltered: Boolean,
     private var emitHeader: EmitFileHeader = EmitFileHeader.ALWAYS,
     private val fileFormat: FileFormat,
-    showUnannotated: Boolean,
-    apiVisitorConfig: Config,
-) :
-    ApiVisitor(
-        visitConstructorsAsMethods = false,
-        nestInnerClasses = false,
-        inlineInheritedFields = true,
-        methodComparator = fileFormat.overloadedMethodOrder.comparator,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
-        showUnannotated = showUnannotated,
-        config = apiVisitorConfig,
-    ) {
+) : DelegatedVisitor {
+
     init {
         // If a header must always be written out (even if the file is empty) then write it here.
         if (emitHeader == EmitFileHeader.ALWAYS) {
@@ -88,33 +76,13 @@ class SignatureWriter(
     }
 
     override fun visitConstructor(constructor: ConstructorItem) {
-        fun writeConstructor(skipMask: BitSet? = null) {
-            write("    ctor ")
-            writeModifiers(constructor)
-            writeTypeParameterList(constructor.typeParameterList, addSpace = true)
-            write(constructor.containingClass().fullName())
-            writeParameterList(constructor, skipMask)
-            writeThrowsList(constructor)
-            write(";\n")
-        }
-
-        // Workaround for https://youtrack.jetbrains.com/issue/KT-57537
-        if (constructor.shouldExpandOverloads()) {
-            val parameters = constructor.parameters()
-            val defaultMask = BitSet(parameters.size)
-
-            // fill the bitmask for all parameters
-            parameters.forEachIndexed { i, item -> defaultMask.set(i, item.hasDefaultValue()) }
-
-            // expand overloads ordered by number of parameters, skipping last parameters first
-            for (i in parameters.indices) {
-                if (!defaultMask.get(i)) continue
-                writeConstructor(defaultMask)
-                defaultMask.clear(i)
-            }
-        }
-
-        writeConstructor()
+        write("    ctor ")
+        writeModifiers(constructor)
+        writeTypeParameterList(constructor.typeParameterList, addSpace = true)
+        write(constructor.containingClass().fullName())
+        writeParameterList(constructor)
+        writeThrowsList(constructor)
+        write(";\n")
     }
 
     override fun visitField(field: FieldItem) {
@@ -224,23 +192,17 @@ class SignatureWriter(
         modifierListWriter.write(item.actualItem)
     }
 
-    /** Get the filtered super class type, ignoring java.lang.Object. */
-    private fun getFilteredSuperClassTypeFor(cls: ClassItem): TypeItem? {
-        val superClassItem =
-            if (preFiltered) cls.superClassType() else cls.filteredSuperClassType(filterReference)
-        return if (superClassItem == null || superClassItem.isJavaLangObject()) null
-        else superClassItem
-    }
-
     private fun writeSuperClassStatement(cls: ClassItem) {
         if (cls.isEnum() || cls.isAnnotationType() || cls.isInterface()) {
             return
         }
 
-        getFilteredSuperClassTypeFor(cls)?.let { superClassType ->
-            write(" extends")
-            writeExtendsOrImplementsType(superClassType)
-        }
+        /** Get the super class type, ignoring java.lang.Object. */
+        val superClassType = cls.superClassType()
+        if (superClassType == null || superClassType.isJavaLangObject()) return
+
+        write(" extends")
+        writeExtendsOrImplementsType(superClassType)
     }
 
     private fun writeExtendsOrImplementsType(typeItem: TypeItem) {
@@ -248,7 +210,6 @@ class SignatureWriter(
             typeItem.toTypeString(
                 annotations = fileFormat.includeTypeUseAnnotations,
                 kotlinStyleNulls = fileFormat.kotlinStyleNulls,
-                filter = filterReference
             )
         write(" ")
         write(superClassString)
@@ -258,57 +219,16 @@ class SignatureWriter(
         if (cls.isAnnotationType()) {
             return
         }
-        val isInterface = cls.isInterface()
 
-        val unfilteredInterfaceTypes = cls.interfaceTypes()
-        val interfaces =
-            if (preFiltered) unfilteredInterfaceTypes
-            else cls.filteredInterfaceTypes(filterReference)
-        if (interfaces.isEmpty()) {
-            return
-        }
+        // There is no need to sort the interface types as that is done by the `interfaceTypes()`
+        // method, using the `interfaceListAccessor(...)` method.
+        val orderedInterfaces = cls.interfaceTypes()
+        if (orderedInterfaces.isEmpty()) return
 
-        // Sort before prepending the super class (if this is an interface) as the super class
-        // always comes first because it was previously written out by writeSuperClassStatement.
-        @Suppress("DEPRECATION")
-        val comparator =
-            if (fileFormat.sortWholeExtendsList) TypeItem.totalComparator
-            else TypeItem.partialComparator
-        val sortedInterfaces = interfaces.sortedWith(comparator)
-
-        // Combine the super class and interfaces into a full list of them.
-        val fullInterfaces =
-            if (isInterface && !fileFormat.sortWholeExtendsList) {
-                // Previously, when the first interface in the extends list was stored in
-                // superClass, if that interface was visible in the signature then it would always
-                // be first even though the other interfaces are sorted in alphabetical order. This
-                // implements similar logic.
-                val firstUnfilteredInterfaceType = unfilteredInterfaceTypes.first()
-                val firstFilteredInterfaceType = interfaces.first()
-                if (firstFilteredInterfaceType == firstUnfilteredInterfaceType) {
-                    buildList {
-                        // The first interface in the interfaces list is also the first interface in
-                        // the filtered interfaces list so add it first.
-                        add(firstFilteredInterfaceType)
-
-                        // Add the remaining interfaces in sorted order.
-                        if (sortedInterfaces.size > 1) {
-                            for (interfaceType in sortedInterfaces) {
-                                if (interfaceType != firstFilteredInterfaceType) {
-                                    add(interfaceType)
-                                }
-                            }
-                        }
-                    }
-                } else {
-                    sortedInterfaces
-                }
-            } else sortedInterfaces
-
-        val label = if (isInterface) " extends" else " implements"
+        val label = if (cls.isInterface()) " extends" else " implements"
         write(label)
 
-        fullInterfaces.forEach { typeItem -> writeExtendsOrImplementsType(typeItem) }
+        orderedInterfaces.forEach { typeItem -> writeExtendsOrImplementsType(typeItem) }
     }
 
     private fun writeTypeParameterList(typeList: TypeParameterList, addSpace: Boolean) {
@@ -321,13 +241,10 @@ class SignatureWriter(
         }
     }
 
-    private fun writeParameterList(method: MethodItem, skipMask: BitSet? = null) {
+    private fun writeParameterList(callable: CallableItem) {
         write("(")
         var writtenParams = 0
-        method.parameters().asSequence().forEachIndexed { i, parameter ->
-            // skip over defaults when generating @JvmOverloads permutations
-            if (skipMask != null && skipMask.get(i)) return@forEachIndexed
-
+        callable.parameters().asSequence().forEach { parameter ->
             if (writtenParams > 0) {
                 write(", ")
             }
@@ -356,7 +273,7 @@ class SignatureWriter(
 
             if (parameter.isDefaultValueKnown() && !fileFormat.conciseDefaultValues) {
                 write(" = ")
-                val defaultValue = parameter.defaultValue()
+                val defaultValue = parameter.defaultValueAsString()
                 if (defaultValue != null) {
                     write(defaultValue)
                 } else {
@@ -376,7 +293,6 @@ class SignatureWriter(
             type.toTypeString(
                 annotations = fileFormat.includeTypeUseAnnotations,
                 kotlinStyleNulls = fileFormat.kotlinStyleNulls,
-                filter = filterReference
             )
 
         // Strip java.lang. prefix
@@ -385,17 +301,11 @@ class SignatureWriter(
         write(typeString)
     }
 
-    private fun writeThrowsList(method: MethodItem) {
-        val throws =
-            when {
-                preFiltered -> method.throwsTypes().asSequence()
-                else -> method.filteredThrowsTypes(filterReference).asSequence()
-            }
-        if (throws.any()) {
+    private fun writeThrowsList(callable: CallableItem) {
+        val throws = callable.throwsTypes()
+        if (throws.isNotEmpty()) {
             write(" throws ")
-            throws.asSequence().sortedWith(ExceptionTypeItem.fullNameComparator).forEachIndexed {
-                i,
-                type ->
+            throws.sortedWith(ExceptionTypeItem.fullNameComparator).forEachIndexed { i, type ->
                 if (i > 0) {
                     write(", ")
                 }
@@ -410,3 +320,80 @@ enum class EmitFileHeader {
     NEVER,
     IF_NONEMPTY_FILE
 }
+
+/**
+ * Get the filtered list of [ClassItem.interfaceTypes], in the correct legacy order.
+ *
+ * Historically, on interface classes its first implemented interface type was stored in the
+ * [ClassItem.superClassType] and if it was not filtered out it was always written out first in the
+ * signature files, while the rest of the interface types were sorted by their [ClassItem.fullName].
+ * This implements that behavior.
+ */
+private fun getInterfacesInOrder(
+    classItem: ClassItem,
+    filteredInterfaceTypes: List<ClassTypeItem>,
+    unfilteredInterfaceTypes: List<ClassTypeItem>,
+): List<ClassTypeItem> {
+    // Sort before prepending the super class (if this is an interface) as the super class
+    // always comes first because it was previously written out by writeSuperClassStatement.
+    @Suppress("DEPRECATION")
+    val sortedInterfaces = filteredInterfaceTypes.sortedWith(TypeItem.partialComparator)
+
+    // Combine the super class and interfaces into a full list of them.
+    if (classItem.isInterface()) {
+        // Previously, when the first interface in the extends list was stored in
+        // superClass, if that interface was visible in the signature then it would always
+        // be first even though the other interfaces are sorted in alphabetical order. This
+        // implements similar logic.
+        val firstUnfilteredInterfaceType = unfilteredInterfaceTypes.first()
+
+        // Check to see whether the first unfiltered interface type is in the sorted set of
+        // interfaces. If it is, and it is not the first then it needs moving to the beginning.
+        val index = sortedInterfaces.indexOf(firstUnfilteredInterfaceType)
+        if (index > 0) {
+            // Create a mutable list and move the first unfiltered interface type to the beginning.
+            return sortedInterfaces.toMutableList().also { mutable ->
+                // Remove it from its existing position.
+                mutable.removeAt(index)
+
+                // Add it at the beginning.
+                mutable.add(0, firstUnfilteredInterfaceType)
+            }
+        }
+    }
+
+    return sortedInterfaces
+}
+
+/**
+ * Create an [ApiVisitor] that will filter the [Item] to which is applied according to the supplied
+ * parameters and in a manner appropriate for writing signatures, e.g. flattening nested classes. It
+ * will delegate any visitor calls that pass through its filter to this [SignatureWriter] instance.
+ */
+fun createFilteringVisitorForSignatures(
+    delegate: DelegatedVisitor,
+    fileFormat: FileFormat,
+    apiType: ApiType,
+    preFiltered: Boolean,
+    showUnannotated: Boolean,
+    apiVisitorConfig: ApiVisitor.Config,
+): ApiVisitor {
+    val filterEmit = apiType.getEmitFilter(apiVisitorConfig.apiPredicateConfig)
+    val filterReference = apiType.getReferenceFilter(apiVisitorConfig.apiPredicateConfig)
+
+    val (interfaceListSorter, interfaceListComparator) =
+        if (fileFormat.sortWholeExtendsList) Pair(null, TypeItem.totalComparator)
+        else Pair(::getInterfacesInOrder, null)
+    return FilteringApiVisitor(
+        delegate = delegate,
+        inlineInheritedFields = true,
+        callableComparator = fileFormat.overloadedMethodOrder.comparator,
+        interfaceListSorter = interfaceListSorter,
+        interfaceListComparator = interfaceListComparator,
+        filterEmit = filterEmit,
+        filterReference = filterReference,
+        preFiltered = preFiltered,
+        showUnannotated = showUnannotated,
+        config = apiVisitorConfig,
+    )
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
index 33c4235e0..861b6224e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
@@ -17,11 +17,11 @@
 package com.android.tools.metalava.apilevels
 
 import com.android.tools.metalava.actualItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.options
 import java.util.function.Predicate
@@ -42,8 +42,7 @@ fun addApisFromCodebase(
     codebase.accept(
         object :
             ApiVisitor(
-                visitConstructorsAsMethods = true,
-                nestInnerClasses = false,
+                preserveClassNesting = false,
                 filterEmit = providedFilterEmit,
                 filterReference = providedFilterReference,
                 config = @Suppress("DEPRECATION") options.apiVisitorConfig,
@@ -157,11 +156,11 @@ fun addApisFromCodebase(
                 }
             }
 
-            override fun visitMethod(method: MethodItem) {
-                if (method.isPrivate || method.isPackagePrivate) {
+            override fun visitCallable(callable: CallableItem) {
+                if (callable.isPrivate || callable.isPackagePrivate) {
                     return
                 }
-                currentClass?.addMethod(method.nameInApi(), apiLevel, method.actualDeprecated)
+                currentClass?.addMethod(callable.nameInApi(), apiLevel, callable.actualDeprecated)
             }
 
             override fun visitField(field: FieldItem) {
@@ -181,7 +180,7 @@ fun addApisFromCodebase(
             }
 
             /** The name of the method in this [Api], based on [useInternalNames] */
-            fun MethodItem.nameInApi(): String {
+            fun CallableItem.nameInApi(): String {
                 return if (useInternalNames) {
                     internalName() +
                         // Use "V" instead of the type of the constructor for backwards
@@ -227,15 +226,15 @@ fun addApisFromCodebase(
 }
 
 /**
- * Like [MethodItem.internalName] but is the desc-portion of the internal signature, e.g. for the
+ * Like [CallableItem.internalName] but is the desc-portion of the internal signature, e.g. for the
  * method "void create(int x, int y)" the internal name of the constructor is "create" and the desc
  * is "(II)V"
  */
-fun MethodItem.internalDesc(voidConstructorTypes: Boolean = false): String {
+fun CallableItem.internalDesc(voidConstructorTypes: Boolean = false): String {
     val sb = StringBuilder()
     sb.append("(")
 
-    // Non-static inner classes get an implicit constructor parameter for the
+    // Inner, i.e. non-static nested, classes get an implicit constructor parameter for the
     // outer type
     if (
         isConstructor() &&
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt
index 42d585175..8419e8f1a 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/ExecutionEnvironment.kt
@@ -17,10 +17,10 @@
 package com.android.tools.metalava.cli.common
 
 import com.android.tools.lint.detector.api.assertionsEnabled
-import com.android.tools.metalava.DefaultReporterEnvironment
 import com.android.tools.metalava.ENV_VAR_METALAVA_DUMP_ARGV
-import com.android.tools.metalava.ReporterEnvironment
 import com.android.tools.metalava.model.source.SourceModelProvider
+import com.android.tools.metalava.reporter.DefaultReporterEnvironment
+import com.android.tools.metalava.reporter.ReporterEnvironment
 import java.io.OutputStreamWriter
 import java.io.PrintWriter
 import java.io.StringWriter
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt
index 127d5722d..2454cd507 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/IssueReportingOptions.kt
@@ -16,13 +16,13 @@
 
 package com.android.tools.metalava.cli.common
 
-import com.android.tools.metalava.DefaultReporter
-import com.android.tools.metalava.DefaultReporterEnvironment
-import com.android.tools.metalava.ReporterEnvironment
+import com.android.tools.metalava.reporter.DefaultReporter
+import com.android.tools.metalava.reporter.DefaultReporterEnvironment
 import com.android.tools.metalava.reporter.ERROR_WHEN_NEW_SUFFIX
 import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.reporter.ReporterEnvironment
 import com.android.tools.metalava.reporter.Severity
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.default
@@ -74,7 +74,7 @@ class IssueReportingOptions(
      * A slight complexity is that this [Reporter] and its [IssueConfiguration] are both modified
      * and used during the process of processing the options.
      */
-    internal val bootstrapReporter: Reporter =
+    internal val bootstrapReporter: DefaultReporter =
         DefaultReporter(
             reporterEnvironment,
             issueConfiguration,
@@ -172,7 +172,7 @@ class IssueReportingOptions(
 
             DefaultReporter.Config(
                 warningsAsErrors = warningsAsErrors,
-                terminal = commonOptions.terminal,
+                outputReportFormatter = TerminalReportFormatter.forTerminal(commonOptions.terminal),
                 reportEvenIfSuppressedWriter = reportEvenIfSuppressedWriter,
             )
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt
index 2bf8e3191..fdcac5895 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt
@@ -48,7 +48,11 @@ sealed interface PreviouslyReleasedApi {
          * return a [JarBasedApi] or [SignatureBasedApi] for a list of jar files and a list of
          * signature files respectively.
          */
-        internal fun optionalPreviouslyReleasedApi(optionName: String, files: List<File>) =
+        internal fun optionalPreviouslyReleasedApi(
+            optionName: String,
+            files: List<File>,
+            onlyUseLastForCurrentApiSurface: Boolean = true
+        ) =
             if (files.isEmpty()) null
             else {
                 // Partition the files into jar and non-jar files, the latter are assumed to be
@@ -56,7 +60,8 @@ sealed interface PreviouslyReleasedApi {
                 val (jarFiles, signatureFiles) =
                     files.partition { it.path.endsWith(SdkConstants.DOT_JAR) }
                 when {
-                    jarFiles.isEmpty() -> SignatureBasedApi.fromFiles(signatureFiles)
+                    jarFiles.isEmpty() ->
+                        SignatureBasedApi.fromFiles(signatureFiles, onlyUseLastForCurrentApiSurface)
                     signatureFiles.isEmpty() ->
                         if (jarFiles.size > 1)
                             throw IllegalStateException(
@@ -113,14 +118,18 @@ data class SignatureBasedApi(val signatureFiles: List<SignatureFile>) : Previous
     }
 
     companion object {
-        fun fromFiles(files: List<File>): SignatureBasedApi {
+        fun fromFiles(
+            files: List<File>,
+            onlyUseLastForCurrentApiSurface: Boolean = true
+        ): SignatureBasedApi {
             val lastIndex = files.size - 1
             return SignatureBasedApi(
                 files.mapIndexed { index, file ->
                     SignatureFile(
                         file,
                         // The last file is assumed to be for the current API surface.
-                        forCurrentApiSurface = index == lastIndex,
+                        forCurrentApiSurface =
+                            !onlyUseLastForCurrentApiSurface || index == lastIndex,
                     )
                 }
             )
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/TerminalReportFormatter.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/TerminalReportFormatter.kt
new file mode 100644
index 000000000..a29115910
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/TerminalReportFormatter.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.common
+
+import com.android.tools.metalava.reporter.DefaultReportFormatter
+import com.android.tools.metalava.reporter.Report
+import com.android.tools.metalava.reporter.ReportFormatter
+import com.android.tools.metalava.reporter.Severity
+
+/** Formats a [Report] for output. */
+internal class TerminalReportFormatter
+private constructor(
+    /** Whether output should be colorized */
+    val terminal: Terminal = plainTerminal,
+) : DefaultReportFormatter() {
+
+    override fun beginImportantSection(builder: StringBuilder) {
+        builder.append(terminal.attributes(bold = true))
+    }
+
+    override fun beginSeverity(builder: StringBuilder, severity: Severity) {
+        when (severity) {
+            Severity.INFO -> {
+                builder.append(terminal.attributes(foreground = TerminalColor.CYAN))
+            }
+            Severity.WARNING,
+            Severity.WARNING_ERROR_WHEN_NEW -> {
+                builder.append(terminal.attributes(foreground = TerminalColor.YELLOW))
+            }
+            Severity.ERROR -> {
+                builder.append(terminal.attributes(foreground = TerminalColor.RED))
+            }
+            else -> {}
+        }
+    }
+
+    override fun endSeverity(builder: StringBuilder) {
+        builder.append(terminal.reset())
+    }
+
+    companion object {
+        fun forTerminal(terminal: Terminal): ReportFormatter = TerminalReportFormatter(terminal)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt
index 3bc9ae823..7a717caf2 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt
@@ -30,16 +30,17 @@ import com.android.tools.metalava.model.Codebase
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.multiple
 import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.unique
 import java.io.File
 
 const val ARG_CHECK_COMPATIBILITY_API_RELEASED = "--check-compatibility:api:released"
 const val ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED = "--check-compatibility:removed:released"
-const val ARG_CHECK_COMPATIBILITY_BASE_API = "--check-compatibility:base"
 const val ARG_ERROR_MESSAGE_CHECK_COMPATIBILITY_RELEASED = "--error-message:compatibility:released"
 
 const val ARG_BASELINE_CHECK_COMPATIBILITY_RELEASED = "--baseline:compatibility:released"
 const val ARG_UPDATE_BASELINE_CHECK_COMPATIBILITY_RELEASED =
     "--update-baseline:compatibility:released"
+const val ARG_API_COMPAT_ANNOTATION = "--api-compat-annotation"
 
 /** The name of the group, can be used in help text to refer to the options in this group. */
 const val COMPATIBILITY_CHECK_GROUP = "Compatibility Checks"
@@ -58,22 +59,6 @@ class CompatibilityCheckOptions(
                 .trimIndent(),
     ) {
 
-    internal val baseApiForCompatCheck: File? by
-        option(
-                ARG_CHECK_COMPATIBILITY_BASE_API,
-                help =
-                    """
-                        When performing a compat check, use the provided signature file as a base
-                        api, which is treated as part of the API being checked. This allows us to
-                        compute the full API surface from a partial API surface (e.g. the current
-                         @SystemApi txt file), which allows us to recognize when an API is moved
-                         from the partial API to the base API and avoid incorrectly flagging this
-                     """
-                        .trimIndent(),
-            )
-            .existingFile()
-            .allowStructuredOptionName()
-
     private val checkReleasedApi: CheckRequest? by
         option(
                 ARG_CHECK_COMPATIBILITY_API_RELEASED,
@@ -112,6 +97,22 @@ class CompatibilityCheckOptions(
             .allowStructuredOptionName()
             .map { CheckRequest.optionalCheckRequest(it, ApiType.REMOVED) }
 
+    internal val apiCompatAnnotations: Set<String> by
+        option(
+                ARG_API_COMPAT_ANNOTATION,
+                help =
+                    """
+                        Specify an annotation important for API compatibility.
+
+                        Adding/removing this annotation will be considered an incompatible change.
+                        The fully qualified name of the annotation should be passed.
+                    """
+                        .trimIndent(),
+                metavar = "<annotation>",
+            )
+            .multiple()
+            .unique()
+
     /**
      * If set, metalava will show this error message when "check-compatibility:*:released" fails.
      * (i.e. [ARG_CHECK_COMPATIBILITY_API_RELEASED] and [ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED])
diff --git a/metalava/src/main/java/com/android/tools/metalava/DexApiWriter.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/DexApiWriter.kt
similarity index 64%
rename from metalava/src/main/java/com/android/tools/metalava/DexApiWriter.kt
rename to metalava/src/main/java/com/android/tools/metalava/cli/signature/DexApiWriter.kt
index 6407e5e44..896c7ac70 100644
--- a/metalava/src/main/java/com/android/tools/metalava/DexApiWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/DexApiWriter.kt
@@ -14,35 +14,27 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.cli.signature
 
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.visitors.ApiVisitor
 import java.io.PrintWriter
-import java.util.function.Predicate
 
-class DexApiWriter(
+internal class DexApiWriter(
     private val writer: PrintWriter,
-    filterEmit: Predicate<Item>,
-    filterReference: Predicate<Item>,
-    config: Config,
-) :
-    ApiVisitor(
-        visitConstructorsAsMethods = true,
-        nestInnerClasses = false,
-        inlineInheritedFields = true,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
-        config = config,
-    ) {
+) : DelegatedVisitor {
+
     override fun visitClass(cls: ClassItem) {
-        if (filterEmit.test(cls)) {
-            writer.print(cls.type().internalName())
-            writer.print("\n")
-        }
+        writer.print(cls.type().internalName())
+        writer.print("\n")
+    }
+
+    override fun visitConstructor(constructor: ConstructorItem) {
+        writeCallable(constructor)
     }
 
     override fun visitMethod(method: MethodItem) {
@@ -50,18 +42,22 @@ class DexApiWriter(
             return
         }
 
-        writer.print(method.containingClass().type().internalName())
+        writeCallable(method)
+    }
+
+    private fun writeCallable(callable: CallableItem) {
+        writer.print(callable.containingClass().type().internalName())
         writer.print("->")
-        writer.print(method.internalName())
+        writer.print(callable.internalName())
         writer.print("(")
-        for (pi in method.parameters()) {
+        for (pi in callable.parameters()) {
             writer.print(pi.type().internalName())
         }
         writer.print(")")
-        if (method.isConstructor()) {
+        if (callable.isConstructor()) {
             writer.print("V")
         } else {
-            val returnType = method.returnType()
+            val returnType = callable.returnType()
             writer.print(returnType.internalName())
         }
         writer.print("\n")
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
index 99d1988f3..e9e2c1848 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.cli.signature
 
+import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.OptionsDelegate
 import com.android.tools.metalava.SignatureWriter
 import com.android.tools.metalava.cli.common.MetalavaCliException
@@ -23,6 +24,7 @@ import com.android.tools.metalava.cli.common.MetalavaSubCommand
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
+import com.android.tools.metalava.createFilteringVisitorForSignatures
 import com.android.tools.metalava.createReportFile
 import com.android.tools.metalava.model.text.ApiFile
 import com.android.tools.metalava.model.text.ApiParseException
@@ -84,14 +86,20 @@ class MergeSignaturesCommand :
         try {
             val codebase = ApiFile.parseApi(SignatureFile.fromFiles(files))
             createReportFile(progressTracker, codebase, out, description = "Merged file") {
-                SignatureWriter(
-                    writer = it,
-                    filterEmit = { true },
-                    filterReference = { true },
+                val fileFormat = signatureFormat.fileFormat
+                val signatureWriter =
+                    SignatureWriter(
+                        writer = it,
+                        fileFormat = fileFormat,
+                    )
+
+                createFilteringVisitorForSignatures(
+                    delegate = signatureWriter,
+                    fileFormat = fileFormat,
+                    apiType = ApiType.ALL,
                     preFiltered = true,
-                    fileFormat = signatureFormat.fileFormat,
                     showUnannotated = false,
-                    apiVisitorConfig = ApiVisitor.Config(),
+                    apiVisitorConfig = ApiVisitor.Config()
                 )
             }
         } catch (e: ApiParseException) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt
index 058778f00..a9cacf201 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.cli.signature
 
 import com.android.tools.metalava.ApiType
-import com.android.tools.metalava.DexApiWriter
 import com.android.tools.metalava.OptionsDelegate
 import com.android.tools.metalava.cli.common.MetalavaSubCommand
 import com.android.tools.metalava.cli.common.SignatureFileLoader
@@ -28,26 +27,34 @@ import com.android.tools.metalava.createReportFile
 import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.text.SignatureFile
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.arguments.multiple
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.required
+
+const val ARG_OUT = "--out"
 
 class SignatureToDexCommand :
     MetalavaSubCommand(
-        help = "Convert an API signature file into a file containing a list of DEX signatures.",
+        help = "Convert API signature files into a file containing a list of DEX signatures.",
     ) {
 
-    private val apiFile by
+    private val apiFiles by
         argument(
                 name = "<api-file>",
-                help = "API signature file to convert to DEX signatures.",
+                help = "API signature files to convert to DEX signatures.",
             )
             .existingFile()
+            .multiple(required = true)
 
-    private val dexFile by
-        argument(
-                name = "<dex-file>",
+    private val outFile by
+        option(
+                ARG_OUT,
                 help = "Output DEX signatures file.",
             )
             .newFile()
+            .required()
 
     override fun run() {
         // Make sure that none of the code called by this command accesses the global `options`
@@ -55,7 +62,7 @@ class SignatureToDexCommand :
         OptionsDelegate.disallowAccess()
 
         val signatureFileLoader = SignatureFileLoader(annotationManager = noOpAnnotationManager)
-        val signatureApi = signatureFileLoader.load(SignatureFile.fromFile(apiFile))
+        val signatureApi = signatureFileLoader.loadFiles(SignatureFile.fromFiles(apiFiles))
 
         val apiVisitorConfig = ApiVisitor.Config()
         val apiPredicateConfig = apiVisitorConfig.apiPredicateConfig
@@ -63,13 +70,20 @@ class SignatureToDexCommand :
         val apiEmit = apiType.getEmitFilter(apiPredicateConfig)
         val apiReference = apiType.getReferenceFilter(apiPredicateConfig)
 
-        createReportFile(progressTracker, signatureApi, dexFile, "DEX API") { printWriter ->
+        createReportFile(progressTracker, signatureApi, outFile, "DEX API") { printWriter ->
             DexApiWriter(
-                printWriter,
-                apiEmit,
-                apiReference,
-                apiVisitorConfig,
-            )
+                    printWriter,
+                )
+                .let { dexApiWriter ->
+                    FilteringApiVisitor(
+                        dexApiWriter,
+                        inlineInheritedFields = true,
+                        filterEmit = apiEmit,
+                        filterReference = apiReference,
+                        preFiltered = signatureApi.preFiltered,
+                        config = apiVisitorConfig,
+                    )
+                }
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
index ca52dd93e..86d38ee08 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
@@ -58,8 +58,10 @@ class SignatureToJDiffCommand :
         option(
                 help =
                     """
-                        Determines whether duplicate inherited methods should be stripped from the
-                        output or not.
+                        Determines whether types that are not defined within the input signature
+                        file should be stripped from the output or not. This does not include
+                        super class types, i.e. the `extends` attribute in the generated JDiff file.
+                        Historically, they have not been filtered.
                     """
                         .trimIndent()
             )
@@ -160,14 +162,17 @@ class SignatureToJDiffCommand :
         val apiName = xmlFile.nameWithoutExtension.replace(' ', '_')
         createReportFile(progressTracker, outputApi, xmlFile, "JDiff File") { printWriter ->
             JDiffXmlWriter(
-                printWriter,
-                apiEmit,
-                apiReference,
-                signatureApi.preFiltered && !strip,
-                apiName,
-                showUnannotated = false,
-                ApiVisitor.Config(),
-            )
+                    writer = printWriter,
+                    apiName = apiName,
+                )
+                .createFilteringVisitor(
+                    filterEmit = apiEmit,
+                    filterReference = apiReference,
+                    preFiltered = signatureApi.preFiltered && !strip,
+                    showUnannotated = false,
+                    // Historically, the super class type has not been filtered.
+                    filterSuperClassType = false,
+                )
         }
     }
 }
@@ -197,9 +202,11 @@ private fun computeDelta(
     apiVisitorConfig: ApiVisitor.Config,
 ): Codebase {
     // Compute just the delta
-    return TextCodebaseBuilder.build(baseFile, signatureApi.annotationManager) {
-        description = "Delta between $baseApi and $signatureApi"
-
+    return TextCodebaseBuilder.build(
+        location = baseFile,
+        description = "Delta between $baseApi and $signatureApi",
+        annotationManager = signatureApi.annotationManager,
+    ) {
         CodebaseComparator(apiVisitorConfig = apiVisitorConfig)
             .compare(
                 object : ComparisonVisitor() {
diff --git a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
index 44de4b7ca..e42d51c7c 100644
--- a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
@@ -24,20 +24,25 @@ import com.android.tools.metalava.ComparisonVisitor
 import com.android.tools.metalava.JVM_DEFAULT_WITH_COMPATIBILITY
 import com.android.tools.metalava.cli.common.MetalavaCliException
 import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.Item.Companion.describe
+import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MergedCodebase
 import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.MultipleTypeVisitor
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.VariableTypeItem
-import com.android.tools.metalava.model.psi.PsiItem
 import com.android.tools.metalava.options
+import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Issues.Issue
@@ -55,29 +60,30 @@ class CompatibilityCheck(
     private val apiType: ApiType,
     private val reporter: Reporter,
     private val issueConfiguration: IssueConfiguration,
+    private val apiCompatAnnotations: Set<String>,
 ) : ComparisonVisitor() {
 
     var foundProblems = false
 
-    private fun containingMethod(item: Item): MethodItem? {
+    private fun possibleContainingMethod(item: Item): MethodItem? {
         if (item is MethodItem) {
             return item
         }
         if (item is ParameterItem) {
-            return item.containingMethod()
+            return item.possibleContainingMethod()
         }
         return null
     }
 
     private fun compareItemNullability(old: Item, new: Item) {
-        val oldMethod = containingMethod(old)
-        val newMethod = containingMethod(new)
+        val oldMethod = possibleContainingMethod(old)
+        val newMethod = possibleContainingMethod(new)
 
         if (oldMethod != null && newMethod != null) {
             if (
                 oldMethod.containingClass().qualifiedName() !=
                     newMethod.containingClass().qualifiedName() ||
-                    ((oldMethod.inheritedFrom != null) != (newMethod.inheritedFrom != null))
+                    (oldMethod.inheritedFromAncestor != newMethod.inheritedFromAncestor)
             ) {
                 // If the old method and new method are defined on different classes, then it's
                 // possible that the old method was previously overridden and we omitted it.
@@ -87,17 +93,45 @@ class CompatibilityCheck(
             }
         }
 
-        compareTypeNullability(old.type(), new.type(), new)
+        // In a final method, you can change a parameter from nonnull to nullable.
+        // This will also allow a constructor parameter to be changed from nonnull to nullable if
+        // the class is not extensible.
+        // TODO: Allow the parameter of any constructor to be switched from nonnull to nullable as
+        //  they can never be overridden.
+        val allowNonNullToNullable =
+            new is ParameterItem && !new.containingCallable().canBeExternallyOverridden()
+        // In a final method, you can change a method return from nullable to nonnull
+        val allowNullableToNonNull = new is MethodItem && !new.canBeExternallyOverridden()
+
+        old.type()
+            ?.accept(
+                object : MultipleTypeVisitor() {
+                    override fun visitType(type: TypeItem, other: List<TypeItem>) {
+                        val newType = other.singleOrNull() ?: return
+                        compareTypeNullability(
+                            type,
+                            newType,
+                            new,
+                            allowNonNullToNullable,
+                            allowNullableToNonNull,
+                        )
+                    }
+                },
+                listOfNotNull(new.type())
+            )
     }
 
-    private fun compareTypeNullability(old: TypeItem?, new: TypeItem?, context: Item) {
-        old ?: return
-        new ?: return
-
+    private fun compareTypeNullability(
+        old: TypeItem,
+        new: TypeItem,
+        context: Item,
+        allowNonNullToNullable: Boolean,
+        allowNullableToNonNull: Boolean,
+    ) {
         // Should not remove nullness information
         // Can't change information incompatibly
-        val oldNullability = old.modifiers.nullability()
-        val newNullability = new.modifiers.nullability()
+        val oldNullability = old.modifiers.nullability
+        val newNullability = new.modifiers.nullability
         if (
             (oldNullability == TypeNullability.NONNULL ||
                 oldNullability == TypeNullability.NULLABLE) &&
@@ -109,12 +143,6 @@ class CompatibilityCheck(
                 "Attempted to remove nullability from ${new.toTypeString()} (was $oldNullability) in ${describe(context)}"
             )
         } else if (oldNullability != newNullability) {
-            // In a final method, you can change a parameter from nonnull to nullable
-            val allowNonNullToNullable =
-                context is ParameterItem && !context.containingMethod().canBeExternallyOverridden()
-            // In a final method, you can change a method return from nullable to nonnull
-            val allowNullableToNonNull =
-                context is MethodItem && !context.canBeExternallyOverridden()
             if (
                 (oldNullability == TypeNullability.NULLABLE &&
                     newNullability == TypeNullability.NONNULL &&
@@ -171,6 +199,25 @@ class CompatibilityCheck(
             )
         }
 
+        apiCompatAnnotations.forEach { annotation ->
+            val isOldAnnotated = oldModifiers.isAnnotatedWith(annotation)
+            val newAnnotation = newModifiers.findAnnotation(annotation)
+            if (isOldAnnotated && newAnnotation == null) {
+                report(
+                    Issues.REMOVED_ANNOTATION,
+                    new,
+                    "Cannot remove @$annotation annotation from ${describe(old)}: Incompatible change",
+                )
+            } else if (!isOldAnnotated && newAnnotation != null) {
+                report(
+                    Issues.ADDED_ANNOTATION,
+                    new,
+                    "Cannot add @$annotation annotation to ${describe(old)}: Incompatible change",
+                    newAnnotation.fileLocation,
+                )
+            }
+        }
+
         compareItemNullability(old, new)
     }
 
@@ -188,7 +235,7 @@ class CompatibilityCheck(
                 report(
                     Issues.PARAMETER_NAME_CHANGE,
                     new,
-                    "Attempted to change parameter name from $prevName to $newName in ${describe(new.containingMethod())}"
+                    "Attempted to change parameter name from $prevName to $newName in ${describe(new.containingCallable())}"
                 )
             }
         }
@@ -310,7 +357,7 @@ class CompatibilityCheck(
 
             if (oldModifiers.isStatic() != newModifiers.isStatic()) {
                 val hasPublicConstructor = old.constructors().any { it.isPublic }
-                if (!old.isInnerClass() || hasPublicConstructor) {
+                if (!old.isNestedClass() || hasPublicConstructor) {
                     report(
                         Issues.CHANGED_STATIC,
                         new,
@@ -434,58 +481,118 @@ class CompatibilityCheck(
         }
     }
 
-    override fun compare(old: MethodItem, new: MethodItem) {
+    override fun compare(old: CallableItem, new: CallableItem) {
         val oldModifiers = old.modifiers
         val newModifiers = new.modifiers
 
-        val oldReturnType = old.returnType()
-        val newReturnType = new.returnType()
-        if (!new.isConstructor()) {
-            if (!compatibleReturnTypes(oldReturnType, newReturnType)) {
-                // For incompatible type variable changes, include the type bounds in the string.
-                val oldTypeString = describeBounds(oldReturnType)
-                val newTypeString = describeBounds(newReturnType)
-                val message =
-                    "${describe(new, capitalize = true)} has changed return type from $oldTypeString to $newTypeString"
-                report(Issues.CHANGED_TYPE, new, message)
+        val oldVisibility = oldModifiers.getVisibilityString()
+        val newVisibility = newModifiers.getVisibilityString()
+        if (oldVisibility != newVisibility) {
+            // Only report issue if the change is a decrease in access; e.g. public -> protected
+            if (!newModifiers.asAccessibleAs(oldModifiers)) {
+                report(
+                    Issues.CHANGED_SCOPE,
+                    new,
+                    "${describe(new, capitalize = true)} changed visibility from $oldVisibility to $newVisibility"
+                )
             }
+        }
 
-            // Annotation methods
-            if (
-                new.containingClass().isAnnotationType() &&
-                    old.containingClass().isAnnotationType() &&
-                    new.defaultValue() != old.defaultValue()
-            ) {
-                val prevValue = old.defaultValue()
-                val prevString =
-                    if (prevValue.isEmpty()) {
-                        "nothing"
-                    } else {
-                        prevValue
-                    }
-
-                val newValue = new.defaultValue()
-                val newString =
-                    if (newValue.isEmpty()) {
-                        "nothing"
-                    } else {
-                        newValue
-                    }
-                val message =
-                    "${describe(
+        if (old.effectivelyDeprecated != new.effectivelyDeprecated) {
+            report(
+                Issues.CHANGED_DEPRECATED,
+                new,
+                "${describe(
                     new,
                     capitalize = true
-                )} has changed value from $prevString to $newString"
+                )} has changed deprecation state ${old.effectivelyDeprecated} --> ${new.effectivelyDeprecated}"
+            )
+        }
 
-                // Adding a default value to an annotation method is safe
-                val annotationMethodAddingDefaultValue =
-                    new.containingClass().isAnnotationType() && old.defaultValue().isEmpty()
+        for (throwType in old.throwsTypes()) {
+            // Get the throwable class, if none could be found then it is either because there is an
+            // error in the codebase or the codebase is incomplete, either way reporting an error
+            // would be unhelpful.
+            val throwableClass = throwType.erasedClass ?: continue
+            if (!new.throws(throwableClass.qualifiedName())) {
+                // exclude 'throws' changes to finalize() overrides with no arguments
+                if (old.name() != "finalize" || old.parameters().isNotEmpty()) {
+                    report(
+                        Issues.CHANGED_THROWS,
+                        new,
+                        "${describe(new, capitalize = true)} no longer throws exception ${throwType.description()}"
+                    )
+                }
+            }
+        }
 
-                if (!annotationMethodAddingDefaultValue) {
-                    report(Issues.CHANGED_VALUE, new, message)
+        for (throwType in new.filteredThrowsTypes(filterReference)) {
+            // Get the throwable class, if none could be found then it is either because there is an
+            // error in the codebase or the codebase is incomplete, either way reporting an error
+            // would be unhelpful.
+            val throwableClass = throwType.erasedClass ?: continue
+            if (!old.throws(throwableClass.qualifiedName())) {
+                // exclude 'throws' changes to finalize() overrides with no arguments
+                if (!(old.name() == "finalize" && old.parameters().isEmpty())) {
+                    val message =
+                        "${describe(new, capitalize = true)} added thrown exception ${throwType.description()}"
+                    report(Issues.CHANGED_THROWS, new, message)
                 }
             }
         }
+    }
+
+    override fun compare(old: MethodItem, new: MethodItem) {
+        val oldModifiers = old.modifiers
+        val newModifiers = new.modifiers
+
+        val oldReturnType = old.returnType()
+        val newReturnType = new.returnType()
+
+        if (!compatibleReturnTypes(oldReturnType, newReturnType)) {
+            // For incompatible type variable changes, include the type bounds in the string.
+            val oldTypeString = describeBounds(oldReturnType)
+            val newTypeString = describeBounds(newReturnType)
+            val message =
+                "${describe(new, capitalize = true)} has changed return type from $oldTypeString to $newTypeString"
+            report(Issues.CHANGED_TYPE, new, message)
+        }
+
+        // Annotation methods
+        if (
+            new.containingClass().isAnnotationType() &&
+                old.containingClass().isAnnotationType() &&
+                new.defaultValue() != old.defaultValue()
+        ) {
+            val prevValue = old.defaultValue()
+            val prevString =
+                if (prevValue.isEmpty()) {
+                    "nothing"
+                } else {
+                    prevValue
+                }
+
+            val newValue = new.defaultValue()
+            val newString =
+                if (newValue.isEmpty()) {
+                    "nothing"
+                } else {
+                    newValue
+                }
+            val message =
+                "${describe(
+                new,
+                capitalize = true
+            )} has changed value from $prevString to $newString"
+
+            // Adding a default value to an annotation method is safe
+            val annotationMethodAddingDefaultValue =
+                new.containingClass().isAnnotationType() && old.defaultValue().isEmpty()
+
+            if (!annotationMethodAddingDefaultValue) {
+                report(Issues.CHANGED_VALUE, new, message)
+            }
+        }
 
         // Check for changes in abstract, but only for regular classes; older signature files
         // sometimes describe interface methods as abstract
@@ -565,76 +672,6 @@ class CompatibilityCheck(
             )
         }
 
-        val oldVisibility = oldModifiers.getVisibilityString()
-        val newVisibility = newModifiers.getVisibilityString()
-        if (oldVisibility != newVisibility) {
-            // Only report issue if the change is a decrease in access; e.g. public -> protected
-            if (!newModifiers.asAccessibleAs(oldModifiers)) {
-                report(
-                    Issues.CHANGED_SCOPE,
-                    new,
-                    "${describe(new, capitalize = true)} changed visibility from $oldVisibility to $newVisibility"
-                )
-            }
-        }
-
-        if (old.effectivelyDeprecated != new.effectivelyDeprecated) {
-            report(
-                Issues.CHANGED_DEPRECATED,
-                new,
-                "${describe(
-                    new,
-                    capitalize = true
-                )} has changed deprecation state ${old.effectivelyDeprecated} --> ${new.effectivelyDeprecated}"
-            )
-        }
-
-        /*
-        // see JLS 3 13.4.20 "Adding or deleting a synchronized modifier of a method does not break "
-        // "compatibility with existing binaries."
-        if (oldModifiers.isSynchronized() != newModifiers.isSynchronized()) {
-            report(
-                Errors.CHANGED_SYNCHRONIZED, new,
-                "${describe(
-                    new,
-                    capitalize = true
-                )} has changed 'synchronized' qualifier from ${oldModifiers.isSynchronized()} to ${newModifiers.isSynchronized()}"
-            )
-        }
-        */
-
-        for (throwType in old.throwsTypes()) {
-            // Get the throwable class, if none could be found then it is either because there is an
-            // error in the codebase or the codebase is incomplete, either way reporting an error
-            // would be unhelpful.
-            val throwableClass = throwType.erasedClass ?: continue
-            if (!new.throws(throwableClass.qualifiedName())) {
-                // exclude 'throws' changes to finalize() overrides with no arguments
-                if (old.name() != "finalize" || old.parameters().isNotEmpty()) {
-                    report(
-                        Issues.CHANGED_THROWS,
-                        new,
-                        "${describe(new, capitalize = true)} no longer throws exception ${throwType.description()}"
-                    )
-                }
-            }
-        }
-
-        for (throwType in new.filteredThrowsTypes(filterReference)) {
-            // Get the throwable class, if none could be found then it is either because there is an
-            // error in the codebase or the codebase is incomplete, either way reporting an error
-            // would be unhelpful.
-            val throwableClass = throwType.erasedClass ?: continue
-            if (!old.throws(throwableClass.qualifiedName())) {
-                // exclude 'throws' changes to finalize() overrides with no arguments
-                if (!(old.name() == "finalize" && old.parameters().isEmpty())) {
-                    val message =
-                        "${describe(new, capitalize = true)} added thrown exception ${throwType.description()}"
-                    report(Issues.CHANGED_THROWS, new, message)
-                }
-            }
-        }
-
         if (new.modifiers.isInline()) {
             val oldTypes = old.typeParameterList
             val newTypes = new.typeParameterList
@@ -781,7 +818,7 @@ class CompatibilityCheck(
     }
 
     @Suppress("DEPRECATION")
-    private fun handleAdded(issue: Issue, item: Item) {
+    private fun handleAdded(issue: Issue, item: SelectableItem) {
         if (item.originallyHidden) {
             // This is an element which is hidden but is referenced from
             // some public API. This is an error, but some existing code
@@ -839,12 +876,23 @@ class CompatibilityCheck(
         handleAdded(error, new)
     }
 
-    override fun added(new: MethodItem) {
-        // *Overriding* methods from super classes that are outside the
-        // API is OK (e.g. overriding toString() from java.lang.Object)
-        val superMethods = new.superMethods()
-        for (superMethod in superMethods) {
-            if (superMethod.isFromClassPath()) {
+    override fun added(new: CallableItem) {
+        if (new is MethodItem) {
+            // *Overriding* methods from super classes that are outside the
+            // API is OK (e.g. overriding toString() from java.lang.Object)
+            val superMethods = new.superMethods()
+            for (superMethod in superMethods) {
+                if (superMethod.origin == ClassOrigin.CLASS_PATH) {
+                    return
+                }
+            }
+
+            // In most cases it is not permitted to add a new method to an interface, even with a
+            // default implementation because it could create ambiguity if client code implements
+            // two interfaces that each now define methods with the same signature.
+            // Annotation types cannot implement other interfaces, however, so it is permitted to
+            // add new default methods to annotation types.
+            if (new.containingClass().isAnnotationType() && new.hasDefaultValue()) {
                 return
             }
         }
@@ -854,21 +902,10 @@ class CompatibilityCheck(
         // an abstract method, because method's abstractness affects how users use it.
         // See if there's a member from inherited class
         val inherited =
-            if (new.isConstructor()) {
-                null
-            } else {
+            if (new is MethodItem) {
                 new.containingClass()
                     .findMethod(new, includeSuperClasses = true, includeInterfaces = false)
-            }
-
-        // In most cases it is not permitted to add a new method to an interface, even with a
-        // default implementation because it could could create ambiguity if client code implements
-        // two interfaces that each now define methods with the same signature.
-        // Annotation types cannot implement other interfaces, however, so it is permitted to add
-        // add new default methods to annotation types.
-        if (new.containingClass().isAnnotationType() && new.hasDefaultValue()) {
-            return
-        }
+            } else null
 
         // It is ok to add a new abstract method to a class that has no public constructors
         if (
@@ -888,13 +925,9 @@ class CompatibilityCheck(
                             new.modifiers.isStatic() -> Issues.ADDED_METHOD
                             new.modifiers.isDefault() -> {
                                 // Hack to always mark added Kotlin interface methods as abstract
-                                // until
-                                // we properly support JVM default methods for Kotlin. This has to
-                                // check
-                                // if it's a PsiItem because TextItem doesn't support isKotlin.
-                                //
+                                // until we properly support JVM default methods for Kotlin.
                                 // TODO(b/200077254): Remove Kotlin special case
-                                if (new is PsiItem && new.isKotlin()) {
+                                if (new.itemLanguage == ItemLanguage.KOTLIN) {
                                     Issues.ADDED_ABSTRACT_METHOD
                                 } else {
                                     Issues.ADDED_METHOD
@@ -927,20 +960,25 @@ class CompatibilityCheck(
         handleRemoved(error, old)
     }
 
-    override fun removed(old: MethodItem, from: ClassItem?) {
+    override fun removed(old: CallableItem, from: ClassItem?) {
         // See if there's a member from inherited class
         val inherited =
-            if (old.isConstructor()) {
-                null
-            } else {
+            if (old is MethodItem) {
                 // This can also return self, specially handled below
-                from?.findMethod(
-                    old,
-                    includeSuperClasses = true,
-                    includeInterfaces = from.isInterface()
-                )
-            }
-        if (inherited == null || inherited != old && inherited.isHiddenOrRemoved()) {
+                from
+                    ?.findMethod(
+                        old,
+                        includeSuperClasses = true,
+                        includeInterfaces = from.isInterface()
+                    )
+                    ?.let {
+                        // If it was inherited but should still be treated as if it was removed then
+                        // pretend that it was not inherited.
+                        if (it.treatAsRemoved(old)) null else it
+                    }
+            } else null
+
+        if (inherited == null) {
             val error =
                 if (old.effectivelyDeprecated) Issues.REMOVED_DEPRECATED_METHOD
                 else Issues.REMOVED_METHOD
@@ -948,6 +986,20 @@ class CompatibilityCheck(
         }
     }
 
+    /**
+     * Check the [Item] to see whether it should be treated as if it was removed.
+     *
+     * If an [Item] is an unstable API that will be reverted then it will not be treated as if it
+     * was removed. That is because reverting it will replace it with the old item against which it
+     * is being compared in this compatibility check. So, while this specific item will not appear
+     * in the API the old item will and so it has not been removed.
+     *
+     * Otherwise, an [Item] will be treated as it was removed it if it is hidden/removed or the
+     * [possibleMatch] does not match.
+     */
+    private fun MethodItem.treatAsRemoved(possibleMatch: MethodItem) =
+        !showability.revertUnstableApi() && (isHiddenOrRemoved() || this != possibleMatch)
+
     override fun removed(old: FieldItem, from: ClassItem?) {
         val inherited =
             from?.findField(
@@ -967,6 +1019,7 @@ class CompatibilityCheck(
         issue: Issue,
         item: Item,
         message: String,
+        location: FileLocation = FileLocation.UNKNOWN,
         maximumSeverity: Severity = Severity.UNLIMITED,
     ) {
         if (item.isCompatibilitySuppressed()) {
@@ -975,7 +1028,7 @@ class CompatibilityCheck(
             // treat all issues for all unchecked items as `Severity.IGNORE`.
             return
         }
-        if (reporter.report(issue, item, message, maximumSeverity = maximumSeverity)) {
+        if (reporter.report(issue, item, message, location, maximumSeverity = maximumSeverity)) {
             // If the issue was reported and was an error then remember that this found some
             // problems so that the process can be aborted after finishing the checks.
             val severity = minOf(maximumSeverity, issueConfiguration.getSeverity(issue))
@@ -989,11 +1042,11 @@ class CompatibilityCheck(
         @Suppress("DEPRECATION")
         fun checkCompatibility(
             newCodebase: Codebase,
-            oldCodebases: MergedCodebase,
+            oldCodebase: Codebase,
             apiType: ApiType,
-            baseApi: Codebase?,
             reporter: Reporter,
             issueConfiguration: IssueConfiguration,
+            apiCompatAnnotations: Set<String>,
         ) {
             val filter =
                 apiType
@@ -1008,17 +1061,18 @@ class CompatibilityCheck(
                     apiType,
                     reporter,
                     issueConfiguration,
+                    apiCompatAnnotations,
                 )
 
             val oldFullCodebase =
                 if (options.showUnannotated && apiType == ApiType.PUBLIC_API) {
-                    baseApi?.let { MergedCodebase(oldCodebases.children + baseApi) } ?: oldCodebases
+                    MergedCodebase(listOf(oldCodebase))
                 } else {
                     // To avoid issues with partial oldCodeBase we fill gaps with newCodebase, the
                     // first parameter is master, so we don't change values of oldCodeBase
-                    MergedCodebase(oldCodebases.children + newCodebase)
+                    MergedCodebase(listOf(oldCodebase, newCodebase))
                 }
-            val newFullCodebase = MergedCodebase(listOfNotNull(newCodebase, baseApi))
+            val newFullCodebase = MergedCodebase(listOf(newCodebase))
 
             CodebaseComparator(
                     apiVisitorConfig = @Suppress("DEPRECATION") options.apiVisitorConfig,
@@ -1027,7 +1081,7 @@ class CompatibilityCheck(
 
             val message =
                 "Found compatibility problems checking " +
-                    "the ${apiType.displayName} API (${newCodebase.location}) against the API in ${oldCodebases.children.last().location}"
+                    "the ${apiType.displayName} API (${newCodebase.location}) against the API in ${oldCodebase.location}"
 
             if (checker.foundProblems) {
                 throw MetalavaCliException(exitCode = -1, stderr = message)
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/Config.kt b/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
new file mode 100644
index 000000000..16c7e85df
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+/** The top level configuration object. */
+class Config
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt b/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
new file mode 100644
index 000000000..66076d422
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.reporter.Severity
+import java.io.File
+import java.net.URI
+import java.nio.file.Paths
+import javax.xml.XMLConstants
+import javax.xml.parsers.SAXParserFactory
+import javax.xml.validation.SchemaFactory
+import org.xml.sax.SAXParseException
+import org.xml.sax.helpers.DefaultHandler
+
+/** Parser for XML configuration files. */
+class ConfigParser(private val reporter: Reporter) : DefaultHandler() {
+
+    private fun reportParseException(exception: SAXParseException, severity: Severity) {
+        val systemIdAsURI = URI.create(exception.systemId)
+        val location = FileLocation.createLocation(Paths.get(systemIdAsURI), exception.lineNumber)
+        reporter.report(
+            Issues.CONFIG_FILE_PROBLEM,
+            null,
+            "Problem parsing configuration file: ${exception.message}",
+            location,
+            // The issue has a severity of ERROR, this limits it to whatever is required by the
+            // caller.
+            maximumSeverity = severity,
+        )
+    }
+
+    override fun warning(exception: SAXParseException) {
+        reportParseException(exception, Severity.WARNING_ERROR_WHEN_NEW)
+    }
+
+    override fun error(exception: SAXParseException) {
+        reportParseException(exception, Severity.ERROR)
+    }
+
+    override fun fatalError(exception: SAXParseException) {
+        reportParseException(exception, Severity.ERROR)
+    }
+
+    companion object {
+        /** Parse a list of configuration files in order, returning a single [Config] object. */
+        fun parse(reporter: Reporter, files: List<File>): Config {
+            val schemaUrl = ConfigParser::class.java.getResource("/schemas/config.xsd")
+            val schemafactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI)
+            val schema = schemafactory.newSchema(schemaUrl)
+
+            val saxParserFactory = SAXParserFactory.newNSInstance()
+            saxParserFactory.schema = schema
+            val saxParser = saxParserFactory.newSAXParser()
+            val configParser = ConfigParser(reporter)
+            for (file in files) {
+                saxParser.parse(file, configParser)
+            }
+            return Config()
+        }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
index 79e2dc8bb..e880566b9 100644
--- a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
@@ -20,7 +20,6 @@ import com.android.tools.lint.LintCliClient
 import com.android.tools.lint.checks.ApiLookup
 import com.android.tools.lint.detector.api.ApiConstraint
 import com.android.tools.lint.detector.api.editDistance
-import com.android.tools.lint.helpers.DefaultJavaEvaluator
 import com.android.tools.metalava.PROGRAM_NAME
 import com.android.tools.metalava.SdkIdentifier
 import com.android.tools.metalava.apilevels.ApiToExtensionsMap
@@ -29,8 +28,10 @@ import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.JAVA_LANG_PREFIX
@@ -39,7 +40,7 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.getAttributeValue
-import com.android.tools.metalava.model.psi.PsiMethodItem
+import com.android.tools.metalava.model.getCallableParameterDescriptorUsingDots
 import com.android.tools.metalava.model.psi.containsLinkTags
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.options
@@ -134,9 +135,7 @@ class DocAnalyzer(
                     for (annotation in annotations) {
                         val name = annotation.qualifiedName
                         if (
-                            name != null &&
-                                name.endsWith("Thread") &&
-                                name.startsWith(ANDROIDX_ANNOTATION_PREFIX)
+                            name.endsWith("Thread") && name.startsWith(ANDROIDX_ANNOTATION_PREFIX)
                         ) {
                             if (result == null) {
                                 result = mutableListOf()
@@ -176,7 +175,7 @@ class DocAnalyzer(
                     visitedClasses: MutableSet<String> = mutableSetOf()
                 ) {
                     val name = annotation.qualifiedName
-                    if (name == null || name.startsWith(JAVA_LANG_PREFIX)) {
+                    if (name.startsWith(JAVA_LANG_PREFIX)) {
                         // Ignore java.lang.Retention etc.
                         return
                     }
@@ -213,7 +212,7 @@ class DocAnalyzer(
 
                     // TODO: Resource type annotations
 
-                    // Handle inner annotations
+                    // Handle nested annotations
                     annotation.resolve()?.modifiers?.annotations()?.forEach { nested ->
                         if (depth == 20) { // Temp debugging
                             throw StackOverflowError(
@@ -247,21 +246,23 @@ class DocAnalyzer(
                         // don't include the docs (since it may conflict with more specific
                         // conditions
                         // outlined in the docs).
+                        val documentation = item.documentation
                         val doc =
                             when (item) {
                                 is ParameterItem -> {
                                     item
-                                        .containingMethod()
+                                        .containingCallable()
+                                        .documentation
                                         .findTagDocumentation("param", item.name())
                                         ?: ""
                                 }
-                                is MethodItem -> {
+                                is CallableItem -> {
                                     // Don't inspect param docs (and other tags) for this purpose.
-                                    item.findMainDocumentation() +
-                                        (item.findTagDocumentation("return") ?: "")
+                                    documentation.findMainDocumentation() +
+                                        (documentation.findTagDocumentation("return") ?: "")
                                 }
                                 else -> {
-                                    item.documentation
+                                    documentation
                                 }
                             }
                         if (doc.contains("null") && mentionsNull.matcher(doc).find()) {
@@ -273,7 +274,7 @@ class DocAnalyzer(
                         is FieldItem -> {
                             addDoc(annotation, "memberDoc", item)
                         }
-                        is MethodItem -> {
+                        is CallableItem -> {
                             addDoc(annotation, "memberDoc", item)
                             addDoc(annotation, "returnDoc", item)
                         }
@@ -593,7 +594,7 @@ class DocAnalyzer(
         doc ?: return
 
         when (item) {
-            is ParameterItem -> item.containingMethod().appendDocumentation(doc, item.name())
+            is ParameterItem -> item.containingCallable().appendDocumentation(doc, item.name())
             is MethodItem ->
                 // Document as part of return annotation, not member doc
                 item.appendDocumentation(doc, if (returnValue) "@return" else null)
@@ -602,40 +603,41 @@ class DocAnalyzer(
     }
 
     private fun addDoc(annotation: AnnotationItem, tag: String, item: Item) {
-        // TODO: Cache: we shouldn't have to keep looking this up over and over
-        // for example for the nullable/non-nullable annotation classes that
-        // are used everywhere!
+        // Resolve the annotation class, returning immediately if it could not be found.
         val cls = annotation.resolve() ?: return
 
-        val documentation = cls.findTagDocumentation(tag)
-        if (documentation != null) {
-            assert(documentation.startsWith("@$tag")) { documentation }
-            // TODO: Insert it in the right place (@return or @param)
-            val section =
-                when {
-                    documentation.startsWith("@returnDoc") -> "@return"
-                    documentation.startsWith("@paramDoc") -> "@param"
-                    documentation.startsWith("@memberDoc") -> null
-                    else -> null
-                }
+        // Documentation of the annotation class that is to be copied into the item where the
+        // annotation is used.
+        val annotationDocumentation = cls.documentation
+
+        // Get the text for the supplied tag as that is what needs to be copied into the use site.
+        // If there is no such text then return immediately.
+        val taggedText = annotationDocumentation.findTagDocumentation(tag) ?: return
+
+        assert(taggedText.startsWith("@$tag")) { taggedText }
+        val section =
+            when {
+                taggedText.startsWith("@returnDoc") -> "@return"
+                taggedText.startsWith("@paramDoc") -> "@param"
+                taggedText.startsWith("@memberDoc") -> null
+                else -> null
+            }
 
-            val insert =
-                stripLeadingAsterisks(stripMetaTags(documentation.substring(tag.length + 2)))
-            val qualified =
-                if (containsLinkTags(insert)) {
-                    val original = "/** $insert */"
-                    val qualified = cls.fullyQualifiedDocumentation(original)
-                    if (original != qualified) {
-                        qualified.substring(if (qualified[3] == ' ') 4 else 3, qualified.length - 2)
-                    } else {
-                        insert
-                    }
+        val insert = stripLeadingAsterisks(stripMetaTags(taggedText.substring(tag.length + 2)))
+        val qualified =
+            if (containsLinkTags(insert)) {
+                val original = "/** $insert */"
+                val qualified = annotationDocumentation.fullyQualifiedDocumentation(original)
+                if (original != qualified) {
+                    qualified.substring(if (qualified[3] == ' ') 4 else 3, qualified.length - 2)
                 } else {
                     insert
                 }
+            } else {
+                insert
+            }
 
-            item.appendDocumentation(qualified, section) // 2: @ and space after tag
-        }
+        item.appendDocumentation(qualified, section) // 2: @ and space after tag
     }
 
     private fun stripLeadingAsterisks(s: String): String {
@@ -676,17 +678,7 @@ class DocAnalyzer(
         codebase.accept(
             object : ApiVisitor(config = apiVisitorConfig) {
                 override fun visitItem(item: Item) {
-                    var doc = item.documentation
-                    if (doc.isBlank()) {
-                        return
-                    }
-
-                    // Work around javadoc cutting off the summary line after the first ". ".
-                    val firstDot = doc.indexOf(".")
-                    if (firstDot > 0 && doc.regionMatches(firstDot - 1, "e.g. ", 0, 5, false)) {
-                        doc = doc.substring(0, firstDot) + ".g.&nbsp;" + doc.substring(firstDot + 4)
-                        item.documentation = doc
-                    }
+                    item.documentation.workAroundJavaDocSummaryTruncationIssue()
                 }
             }
         )
@@ -704,21 +696,26 @@ class DocAnalyzer(
         codebase.accept(
             object :
                 ApiVisitor(
-                    visitConstructorsAsMethods = true,
                     config = apiVisitorConfig,
                 ) {
-                override fun visitMethod(method: MethodItem) {
+
+                override fun visitCallable(callable: CallableItem) {
                     // Do not add API information to implicit constructor. It is not clear exactly
                     // why this is needed but without it some existing tests break.
                     // TODO(b/302290849): Investigate this further.
-                    if (method.isImplicitConstructor()) {
+                    if (callable is ConstructorItem && callable.isImplicitConstructor()) {
                         return
                     }
-                    addApiLevelDocumentation(apiLookup.getMethodVersion(method), method)
-                    val methodName = method.name()
-                    val key = "${method.containingClass().qualifiedName()}#$methodName"
-                    elementToSdkExtSinceMap[key]?.let { addApiExtensionsDocumentation(it, method) }
-                    addDeprecatedDocumentation(apiLookup.getMethodDeprecatedIn(method), method)
+                    addApiLevelDocumentation(apiLookup.getCallableVersion(callable), callable)
+                    val methodName = callable.name()
+                    val key = "${callable.containingClass().qualifiedName()}#$methodName"
+                    elementToSdkExtSinceMap[key]?.let {
+                        addApiExtensionsDocumentation(it, callable)
+                    }
+                    addDeprecatedDocumentation(
+                        apiLookup.getCallableDeprecatedIn(callable),
+                        callable
+                    )
                 }
 
                 override fun visitClass(cls: ClassItem) {
@@ -869,12 +866,10 @@ fun ApiLookup.getClassVersion(cls: ClassItem): Int {
     return getClassVersions(owner).minApiLevel()
 }
 
-val defaultEvaluator = DefaultJavaEvaluator(null, null)
-
-fun ApiLookup.getMethodVersion(method: MethodItem): Int {
+fun ApiLookup.getCallableVersion(method: CallableItem): Int {
     val containingClass = method.containingClass()
     val owner = containingClass.qualifiedName()
-    val desc = method.getApiLookupMethodDescription()
+    val desc = method.getCallableParameterDescriptorUsingDots()
     // Metalava uses the class name as the name of the constructor but the ApiLookup uses <init>.
     val name = if (method.isConstructor()) "<init>" else method.name()
     return getMethodVersions(owner, name, desc).minApiLevel()
@@ -891,22 +886,11 @@ fun ApiLookup.getClassDeprecatedIn(cls: ClassItem): Int {
     return getClassDeprecatedInVersions(owner).minApiLevel()
 }
 
-fun ApiLookup.getMethodDeprecatedIn(method: MethodItem): Int {
-    val containingClass = method.containingClass()
+fun ApiLookup.getCallableDeprecatedIn(callable: CallableItem): Int {
+    val containingClass = callable.containingClass()
     val owner = containingClass.qualifiedName()
-    val desc = method.getApiLookupMethodDescription() ?: return -1
-    return getMethodDeprecatedInVersions(owner, method.name(), desc).minApiLevel()
-}
-
-/** Get the method description suitable for use in [ApiLookup.getMethodVersions]. */
-fun MethodItem.getApiLookupMethodDescription(): String? {
-    val psiMethodItem = this as PsiMethodItem
-    val psiMethod = psiMethodItem.psiMethod
-    return defaultEvaluator.getMethodDescription(
-        psiMethod,
-        includeName = false,
-        includeReturn = false
-    )
+    val desc = callable.getCallableParameterDescriptorUsingDots() ?: return -1
+    return getMethodDeprecatedInVersions(owner, callable.name(), desc).minApiLevel()
 }
 
 fun ApiLookup.getFieldDeprecatedIn(field: FieldItem): Int {
@@ -1050,7 +1034,7 @@ private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAnd
                     // Nomenclature differences:
                     //   - constructors are named "<init>()V" in api-versions.xml, but
                     //     "ClassName()V" in PsiItems
-                    //   - inner classes are named "Outer#Inner" in api-versions.xml, but
+                    //   - nested classes are named "Outer#Inner" in api-versions.xml, but
                     //     "Outer.Inner" in PsiItems
                     when (qualifiedName) {
                         "class" -> {
diff --git a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
index 722277fcf..9b06056b7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
@@ -53,12 +53,15 @@ import com.android.tools.metalava.lint.ResourceType.XML
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.InheritableItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
 import com.android.tools.metalava.model.JAVA_LANG_THROWABLE
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.MethodItem
@@ -73,8 +76,6 @@ import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.findAnnotation
 import com.android.tools.metalava.model.hasAnnotation
-import com.android.tools.metalava.model.psi.PsiFileLocation
-import com.android.tools.metalava.model.psi.PsiMethodItem
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.options
 import com.android.tools.metalava.reporter.FileLocation
@@ -178,21 +179,10 @@ import com.android.tools.metalava.reporter.Issues.VISIBLY_SYNCHRONIZED
 import com.android.tools.metalava.reporter.Reportable
 import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.reporter.Severity
-import com.intellij.psi.JavaRecursiveElementVisitor
-import com.intellij.psi.PsiClassObjectAccessExpression
-import com.intellij.psi.PsiElement
-import com.intellij.psi.PsiSynchronizedStatement
-import com.intellij.psi.PsiThisExpression
 import java.io.StringWriter
 import java.util.Locale
 import java.util.function.Predicate
 import org.jetbrains.kotlin.util.capitalizeDecapitalize.toUpperCaseAsciiOnly
-import org.jetbrains.uast.UCallExpression
-import org.jetbrains.uast.UClassLiteralExpression
-import org.jetbrains.uast.UMethod
-import org.jetbrains.uast.UQualifiedReferenceExpression
-import org.jetbrains.uast.UThisExpression
-import org.jetbrains.uast.visitor.AbstractUastVisitor
 
 /**
  * The [ApiLint] analyzer checks the API against a known set of preferred API practices by the
@@ -214,7 +204,7 @@ private constructor(
         filterReference = ApiType.PUBLIC_API.getReferenceFilter(config.apiPredicateConfig),
         config = config,
         // Sort by source order such that warnings follow source line number order.
-        methodComparator = MethodItem.sourceOrderComparator,
+        callableComparator = CallableItem.sourceOrderComparator,
     ) {
 
     /** Predicate that checks if the item appears in the signature file. */
@@ -254,7 +244,7 @@ private constructor(
 
                 // With show annotations we might be flagging API that is filtered out: hide these
                 // here
-                val testItem = if (item is ParameterItem) item.containingMethod() else item
+                val testItem = if (item is ParameterItem) item.containingCallable() else item
                 if (!filterEmit.test(testItem)) {
                     return false
                 }
@@ -366,23 +356,40 @@ private constructor(
         val constructors = cls.filteredConstructors(filterReference)
         val superClass = cls.filteredSuperclass(filterReference)
         val interfaces = cls.filteredInterfaceTypes(filterReference).asSequence()
-        val allMethods = methods.asSequence() + constructors.asSequence()
+        val allCallables = methods.asSequence() + constructors.asSequence()
         reporter.withContext(cls) {
-            checkClass(cls, methods, constructors, allMethods, fields, superClass, interfaces)
+            checkClass(cls, methods, constructors, allCallables, fields, superClass, interfaces)
         }
     }
 
-    override fun visitMethod(method: MethodItem) {
-        reporter.withContext(method) {
-            checkMethod(method, filterReference)
-            val returnType = method.returnType()
-            checkType(returnType, method)
-            checkNullableCollections(returnType, method)
-            checkMethodSuffixListenableFutureReturn(returnType, method)
-            for (parameter in method.parameters()) {
+    override fun visitCallable(callable: CallableItem) {
+        reporter.withContext(callable) {
+            checkExceptions(callable, filterReference)
+            checkContextFirst(callable)
+            checkListenerLast(callable)
+            checkHasFlaggedApi(callable)
+            checkFlaggedApiLiteral(callable)
+            val returnType = callable.returnType()
+            checkType(returnType, callable)
+            checkNullableCollections(returnType, callable)
+            for (parameter in callable.parameters()) {
                 checkType(parameter.type(), parameter)
             }
-            checkParameterOrder(method)
+            checkParameterOrder(callable)
+        }
+    }
+
+    override fun visitMethod(method: MethodItem) {
+        reporter.withContext(method) {
+            checkMethodNames(method)
+            checkProtected(method)
+            checkSynchronized(method)
+            checkIntentBuilder(method)
+            checkUnits(method)
+            checkTense(method)
+            checkClone(method)
+            checkCallbackOrListenerMethod(method)
+            checkMethodSuffixListenableFutureReturn(method)
             kotlinInterop.checkMethod(method)
         }
     }
@@ -413,7 +420,7 @@ private constructor(
         cls: ClassItem,
         methods: Sequence<MethodItem>,
         constructors: Sequence<ConstructorItem>,
-        methodsAndConstructors: Sequence<MethodItem>,
+        callables: Sequence<CallableItem>,
         fields: Sequence<FieldItem>,
         superClass: ClassItem?,
         interfaces: Sequence<TypeItem>
@@ -429,16 +436,16 @@ private constructor(
         checkBuilder(cls, methods, constructors, superClass, interfaces)
         checkAidl(cls, superClass, interfaces)
         checkInternal(cls)
-        checkLayering(cls, methodsAndConstructors, fields)
+        checkLayering(cls, callables, fields)
         checkBooleans(methods)
         checkFlags(fields)
         checkGoogle(cls, methods, fields)
         checkManager(cls, methods, constructors)
         checkStaticUtils(cls, methods, constructors, fields)
-        checkCallbackHandlers(cls, methodsAndConstructors, superClass)
+        checkCallbackHandlers(cls, callables, superClass)
         checkGenericCallbacks(cls, methods, constructors, fields)
         checkResourceNames(cls, fields)
-        checkFiles(methodsAndConstructors)
+        checkFiles(callables)
         checkManagerList(cls, methods)
         checkAbstractInner(cls)
         checkError(cls, superClass)
@@ -470,24 +477,6 @@ private constructor(
         checkFlaggedApiLiteral(field)
     }
 
-    private fun checkMethod(method: MethodItem, filterReference: Predicate<Item>) {
-        if (!method.isConstructor()) {
-            checkMethodNames(method)
-            checkProtected(method)
-            checkSynchronized(method)
-            checkIntentBuilder(method)
-            checkUnits(method)
-            checkTense(method)
-            checkClone(method)
-            checkCallbackOrListenerMethod(method)
-        }
-        checkExceptions(method, filterReference)
-        checkContextFirst(method)
-        checkListenerLast(method)
-        checkHasFlaggedApi(method)
-        checkFlaggedApiLiteral(method)
-    }
-
     private fun checkFlaggedApiLiteral(item: Item) {
         if (item.codebase.preFiltered) {
             // Flag constants aren't ever API, so prefiltered codebases would always only contain
@@ -693,7 +682,7 @@ private constructor(
     }
 
     private fun checkCallbackOrListenerMethod(method: MethodItem) {
-        if (method.isConstructor() || method.modifiers.isStatic() || method.modifiers.isFinal()) {
+        if (method.modifiers.isStatic() || method.modifiers.isFinal()) {
             return
         }
         val cls = method.containingClass()
@@ -907,7 +896,7 @@ private constructor(
     private fun checkParcelable(
         cls: ClassItem,
         methods: Sequence<MethodItem>,
-        constructors: Sequence<MethodItem>,
+        constructors: Sequence<ConstructorItem>,
         fields: Sequence<FieldItem>
     ) {
         if (!cls.implements("android.os.Parcelable")) {
@@ -1075,64 +1064,36 @@ private constructor(
     }
 
     private fun checkSynchronized(method: MethodItem) {
-        fun reportError(method: MethodItem, psi: PsiElement? = null) {
+
+        /**
+         * Report an error.
+         *
+         * @param synchronizedStatementLocation an optional [FileLocation] of the synchronized
+         *   statement that is the root of the problem.
+         */
+        fun reportError(synchronizedStatementLocation: FileLocation? = null) {
             val message = StringBuilder("Internal locks must not be exposed")
-            if (psi != null) {
+            if (synchronizedStatementLocation != null) {
                 message.append(" (synchronizing on this or class is still externally observable)")
             }
             message.append(": ")
             message.append(method.describe())
-            val location = PsiFileLocation.fromPsiElement(psi)
+            val location = synchronizedStatementLocation ?: FileLocation.UNKNOWN
             report(VISIBLY_SYNCHRONIZED, method, message.toString(), location)
         }
 
         if (method.modifiers.isSynchronized()) {
-            reportError(method)
-        } else if (method is PsiMethodItem) {
-            val psiMethod = method.psiMethod
-            if (psiMethod is UMethod) {
-                psiMethod.accept(
-                    object : AbstractUastVisitor() {
-                        override fun afterVisitCallExpression(node: UCallExpression) {
-                            super.afterVisitCallExpression(node)
-
-                            if (node.methodName == "synchronized" && node.receiver == null) {
-                                val arg = node.valueArguments.firstOrNull()
-                                if (
-                                    arg is UThisExpression ||
-                                        arg is UClassLiteralExpression ||
-                                        arg is UQualifiedReferenceExpression &&
-                                            arg.receiver is UClassLiteralExpression
-                                ) {
-                                    reportError(
-                                        method,
-                                        arg.sourcePsi ?: node.sourcePsi ?: node.javaPsi
-                                    )
-                                }
-                            }
-                        }
-                    }
-                )
-            } else {
-                psiMethod.body?.accept(
-                    object : JavaRecursiveElementVisitor() {
-                        override fun visitSynchronizedStatement(
-                            statement: PsiSynchronizedStatement
-                        ) {
-                            super.visitSynchronizedStatement(statement)
-
-                            val lock = statement.lockExpression
-                            if (
-                                lock == null ||
-                                    lock is PsiThisExpression ||
-                                    // locking on any class is visible
-                                    lock is PsiClassObjectAccessExpression
-                            ) {
-                                reportError(method, lock ?: statement)
-                            }
-                        }
-                    }
-                )
+            // The synchronizing is being done implicitly bny the method so there is no more
+            // specific location to provide.
+            reportError()
+        } else {
+            // Find any visible synchronized statements in the method body.
+            val synchronizedLocations = method.body.findVisiblySynchronizedLocations()
+
+            for (location in synchronizedLocations) {
+                // Report the location of the synchronized statement that is synchronizing on
+                // `this` or the `class` object and causing the problem.
+                reportError(location)
             }
         }
     }
@@ -1422,7 +1383,7 @@ private constructor(
 
     private fun checkLayering(
         cls: ClassItem,
-        methodsAndConstructors: Sequence<MethodItem>,
+        callables: Sequence<CallableItem>,
         fields: Sequence<FieldItem>
     ) {
         fun packageRank(pkg: PackageItem): Int {
@@ -1484,8 +1445,8 @@ private constructor(
             }
         }
 
-        for (method in methodsAndConstructors) {
-            val returnType = method.returnType()
+        for (callable in callables) {
+            val returnType = callable.returnType()
             val returnTypeRank = getTypeRank(returnType)
             if (returnTypeRank != -1 && returnTypeRank < classRank) {
                 report(
@@ -1497,7 +1458,7 @@ private constructor(
                 )
             }
 
-            for (parameter in method.parameters()) {
+            for (parameter in callable.parameters()) {
                 val parameterTypeRank = getTypeRank(parameter.type())
                 if (parameterTypeRank != -1 && parameterTypeRank < classRank) {
                     report(
@@ -1716,8 +1677,8 @@ private constructor(
                 is MethodItem -> item.findPredicateSuperMethod(filterReference)
                 is ParameterItem ->
                     item
-                        .containingMethod()
-                        .findPredicateSuperMethod(filterReference)
+                        .possibleContainingMethod()
+                        ?.findPredicateSuperMethod(filterReference)
                         ?.parameters()
                         ?.find { it.parameterIndex == item.parameterIndex }
                 else -> null
@@ -1836,14 +1797,14 @@ private constructor(
         }
     }
 
-    private fun checkExceptions(method: MethodItem, filterReference: Predicate<Item>) {
-        for (throwableType in method.filteredThrowsTypes(filterReference)) {
+    private fun checkExceptions(callable: CallableItem, filterReference: Predicate<Item>) {
+        for (throwableType in callable.filteredThrowsTypes(filterReference)) {
             // Get the throwable class, which for a type parameter will be the lower bound. A
             // method that throws a type parameter is treated as if it throws its lower bound, so
             // it makes sense for this check to treat it as if it was replaced with its lower bound.
             val throwableClass = throwableType.erasedClass ?: continue
             if (isUncheckedException(throwableClass)) {
-                report(BANNED_THROW, method, "Methods must not throw unchecked exceptions")
+                report(BANNED_THROW, callable, "Methods must not throw unchecked exceptions")
             } else if (throwableType is VariableTypeItem) {
                 // Preserve legacy behavior where the following check did nothing for type
                 // parameters as a type parameters qualifiedName(), which is just its name without
@@ -1855,12 +1816,12 @@ private constructor(
                     "java.lang.Error" -> {
                         report(
                             GENERIC_EXCEPTION,
-                            method,
+                            callable,
                             "Methods must not throw generic exceptions (`$qualifiedName`)"
                         )
                     }
                     "android.os.RemoteException" -> {
-                        when (method.containingClass().qualifiedName()) {
+                        when (callable.containingClass().qualifiedName()) {
                             "android.content.ContentProviderClient",
                             "android.os.Binder",
                             "android.os.IBinder" -> {
@@ -1869,7 +1830,7 @@ private constructor(
                             else -> {
                                 report(
                                     RETHROW_REMOTE_EXCEPTION,
-                                    method,
+                                    callable,
                                     "Methods calling system APIs should rethrow `RemoteException` as `RuntimeException` (but do not list it in the throws clause)"
                                 )
                             }
@@ -1949,7 +1910,7 @@ private constructor(
 
     private fun checkHasFlaggedApi(item: Item) {
         // Cannot flag an implicit constructor.
-        if (item is MethodItem && item.isImplicitConstructor()) return
+        if (item is ConstructorItem && item.isImplicitConstructor()) return
 
         fun itemOrAnyContainingClasses(predicate: Predicate<Item>): Boolean {
             var it: Item? = item
@@ -2030,7 +1991,14 @@ private constructor(
         // Check the deprecated status, if it has changed
         val previousDeprecated = previousItem.effectivelyDeprecated
         val currentDeprecated = currentItem.effectivelyDeprecated
-        if (currentDeprecated != previousDeprecated) {
+        if (
+            currentDeprecated != previousDeprecated &&
+                currentItem.originallyDeprecated != previousItem.originallyDeprecated
+        ) {
+            val location =
+                if (currentItem.originallyDeprecated)
+                    currentItem.modifiers.findAnnotation(JAVA_LANG_DEPRECATED)?.fileLocation
+                else null
             fun deprecatedStatus(b: Boolean): String {
                 return if (b) "deprecated" else "not deprecated"
             }
@@ -2040,7 +2008,8 @@ private constructor(
                 UNFLAGGED_API,
                 currentItem,
                 "Changes from $previous to $current must be flagged with @FlaggedApi: ${currentItem.describe()}",
-                maximumSeverity = Severity.WARNING_ERROR_WHEN_NEW
+                location = location ?: FileLocation.UNKNOWN,
+                maximumSeverity = Severity.WARNING_ERROR_WHEN_NEW,
             )
             // Reporting the same issue on the same Item is pointless as the first report will
             // update the baseline and so suppress the second report so return immediately.
@@ -2071,19 +2040,19 @@ private constructor(
         val itemType = item.type() ?: return
         val inherited =
             when (item) {
-                is ParameterItem -> item.containingMethod().inheritedFromAncestor
-                is FieldItem -> item.inheritedFromAncestor
-                is MethodItem -> item.inheritedFromAncestor
+                is ParameterItem -> item.possibleContainingMethod()?.inheritedFromAncestor == true
+                is InheritableItem -> item.inheritedFromAncestor
                 else -> false
             }
         val superItems =
             when (item) {
                 is ParameterItem ->
-                    item.containingMethod().superMethods().mapNotNull {
+                    item.possibleContainingMethod()?.superMethods()?.mapNotNull {
                         it.parameters().find { param ->
                             item.parameterIndex == param.parameterIndex
                         }
                     }
+                        ?: emptyList()
                 is MethodItem -> item.superMethods()
                 else -> emptyList()
             }
@@ -2148,7 +2117,7 @@ private constructor(
             when (item) {
                 is ParameterItem -> {
                     // We don't enforce this check on constructor params
-                    if (item.containingMethod().isConstructor()) return
+                    if (item.containingCallable().isConstructor()) return
                     if (type.modifiers.isNonNull) {
                         // TODO (b/344859664): Skip warning for inner type
                         if (supers.anyTypeHasNullability(TypeNullability.PLATFORM) && !isInner) {
@@ -2168,7 +2137,7 @@ private constructor(
                         }
                     }
                 }
-                is MethodItem -> {
+                is CallableItem -> {
                     if (type.modifiers.isNullable) {
                         // TODO (b/344859664): Skip warning for inner type
                         if (supers.anyTypeHasNullability(TypeNullability.PLATFORM) && !isInner) {
@@ -2197,7 +2166,7 @@ private constructor(
         return any { type ->
             // Variable types have been excluded from the check because of previous inconsistency
             // in modeling their nullability.
-            type !is VariableTypeItem && type.modifiers.nullability() == nullability
+            type !is VariableTypeItem && type.modifiers.nullability == nullability
         }
     }
 
@@ -2270,7 +2239,7 @@ private constructor(
 
     private fun checkCallbackHandlers(
         cls: ClassItem,
-        methodsAndConstructors: Sequence<MethodItem>,
+        callables: Sequence<CallableItem>,
         superClass: ClassItem?
     ) {
         fun packageContainsSegment(packageName: String?, segment: String): Boolean {
@@ -2325,10 +2294,10 @@ private constructor(
             }
         }
 
-        val found = mutableMapOf<String, MethodItem>()
-        val byName = mutableMapOf<String, MutableList<MethodItem>>()
-        for (method in methodsAndConstructors) {
-            val name = method.name()
+        val found = mutableMapOf<String, CallableItem>()
+        val byName = mutableMapOf<String, MutableList<CallableItem>>()
+        for (callable in callables) {
+            val name = callable.name()
             if (name.startsWith("unregister")) {
                 continue
             }
@@ -2342,20 +2311,20 @@ private constructor(
             val list =
                 byName[name]
                     ?: run {
-                        val new = mutableListOf<MethodItem>()
+                        val new = mutableListOf<CallableItem>()
                         byName[name] = new
                         new
                     }
-            list.add(method)
+            list.add(callable)
 
-            for (parameter in method.parameters()) {
+            for (parameter in callable.parameters()) {
                 val type = parameter.type().toTypeString()
                 if (
                     type.endsWith("Listener") ||
                         type.endsWith("Callback") ||
                         type.endsWith("Callbacks")
                 ) {
-                    found[name] = method
+                    found[name] = callable
                 }
             }
         }
@@ -2391,10 +2360,11 @@ private constructor(
         }
     }
 
-    private fun checkContextFirst(method: MethodItem) {
-        val parameters = method.parameters()
+    private fun checkContextFirst(callable: CallableItem) {
+        val parameters = callable.parameters()
         // The first parameter for a Kotlin extension method is the receiver
-        val effectivelyFirstParameterPosition = if (method.isExtensionMethod()) 1 else 0
+        val effectivelyFirstParameterPosition =
+            if (callable is MethodItem && callable.isExtensionMethod()) 1 else 0
         val effectivelySecondParameterPosition = effectivelyFirstParameterPosition + 1
         if (parameters.size <= effectivelySecondParameterPosition) return
         val firstParameterTypeString =
@@ -2406,7 +2376,7 @@ private constructor(
                     report(
                         CONTEXT_FIRST,
                         p,
-                        "Context is distinct, so it must be the first argument (method `${method.name()}`)"
+                        "Context is distinct, so it must be the first argument (method `${callable.name()}`)"
                     )
                 }
             }
@@ -2418,15 +2388,15 @@ private constructor(
                     report(
                         CONTEXT_FIRST,
                         p,
-                        "ContentResolver is distinct, so it must be the first argument (method `${method.name()}`)"
+                        "ContentResolver is distinct, so it must be the first argument (method `${callable.name()}`)"
                     )
                 }
             }
         }
     }
 
-    private fun checkListenerLast(method: MethodItem) {
-        val name = method.name()
+    private fun checkListenerLast(callable: CallableItem) {
+        val name = callable.name()
         if (name.contains("Listener") || name.contains("Callback")) {
             return
         }
@@ -2434,10 +2404,10 @@ private constructor(
         // Suspend functions add a synthetic `Continuation` parameter at the end - this is invisible
         // to Kotlin callers so just ignore it.
         val parameters =
-            if (method.modifiers.isSuspend()) {
-                method.parameters().dropLast(1)
+            if (callable.modifiers.isSuspend()) {
+                callable.parameters().dropLast(1)
             } else {
-                method.parameters()
+                callable.parameters()
             }
         if (parameters.size > 1) {
             var found = false
@@ -2453,7 +2423,7 @@ private constructor(
                     report(
                         LISTENER_LAST,
                         parameter,
-                        "Listeners should always be at end of argument list (method `${method.name()}`)"
+                        "Listeners should always be at end of argument list (method `${callable.name()}`)"
                     )
                 }
             }
@@ -2565,21 +2535,21 @@ private constructor(
         }
     }
 
-    private fun checkFiles(methodsAndConstructors: Sequence<MethodItem>) {
-        var hasFile: MutableSet<MethodItem>? = null
+    private fun checkFiles(callables: Sequence<CallableItem>) {
+        var hasFile: MutableSet<CallableItem>? = null
         var hasStream: MutableSet<String>? = null
-        for (method in methodsAndConstructors) {
-            for (parameter in method.parameters()) {
+        for (callable in callables) {
+            for (parameter in callable.parameters()) {
                 when (parameter.type().toTypeString()) {
                     "java.io.File" -> {
                         val set =
                             hasFile
                                 ?: run {
-                                    val new = mutableSetOf<MethodItem>()
+                                    val new = mutableSetOf<CallableItem>()
                                     hasFile = new
                                     new
                                 }
-                        set.add(method)
+                        set.add(callable)
                     }
                     "java.io.FileDescriptor",
                     "android.os.ParcelFileDescriptor",
@@ -2592,7 +2562,7 @@ private constructor(
                                     hasStream = new
                                     new
                                 }
-                        set.add(method.name())
+                        set.add(callable.name())
                     }
                 }
             }
@@ -3233,12 +3203,9 @@ private constructor(
             }
     }
 
-    private fun checkMethodSuffixListenableFutureReturn(type: TypeItem, method: MethodItem) {
-        if (
-            type.toTypeString().contains(listenableFuture) &&
-                !method.isConstructor() &&
-                !method.name().endsWith("Async")
-        ) {
+    private fun checkMethodSuffixListenableFutureReturn(method: MethodItem) {
+        val typeString = method.returnType().toTypeString()
+        if (typeString.contains(listenableFuture) && !method.name().endsWith("Async")) {
             report(
                 ASYNC_SUFFIX_FUTURE,
                 method,
@@ -3252,18 +3219,18 @@ private constructor(
      * Make sure that any parameters with default values (in Kotlin) come after all required,
      * non-trailing-lambda parameters.
      */
-    private fun checkParameterOrder(method: MethodItem) {
-        // Ignore Java / non-PSI backed MethodItems
-        if (!method.isKotlin() || method !is PsiMethodItem) {
+    private fun checkParameterOrder(callable: CallableItem) {
+        // Ignore Java
+        if (!callable.isKotlin()) {
             return
         }
         // Suspend functions add a synthetic `Continuation` parameter at the end - this is invisible
         // to Kotlin callers so just ignore it.
         val parameters =
-            if (method.modifiers.isSuspend()) {
-                method.parameters().dropLast(1)
+            if (callable.modifiers.isSuspend()) {
+                callable.parameters().dropLast(1)
             } else {
-                method.parameters()
+                callable.parameters()
             }
         val (optionalParameters, requiredParameters) = parameters.partition { it.hasDefaultValue() }
         if (requiredParameters.isEmpty() || optionalParameters.isEmpty()) return
@@ -3302,7 +3269,7 @@ private constructor(
         getter: MethodItem,
         setter: MethodItem
     ) {
-        if (getterType.modifiers.nullability() != setterType.modifiers.nullability()) {
+        if (getterType.modifiers.nullability != setterType.modifiers.nullability) {
             val getterTypeString = getterType.toTypeString(kotlinStyleNulls = true)
             val setterTypeString = setterType.toTypeString(kotlinStyleNulls = true)
             report(
@@ -3497,7 +3464,8 @@ private constructor(
         private fun isServiceDumpMethod(item: Item) =
             when (item) {
                 is MethodItem -> isServiceDumpMethod(item)
-                is ParameterItem -> isServiceDumpMethod(item.containingMethod())
+                is ParameterItem -> item.possibleContainingMethod()?.let { isServiceDumpMethod(it) }
+                        ?: false
                 else -> false
             }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt b/metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
index 9387ab2ab..fb491a322 100644
--- a/metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
@@ -19,33 +19,29 @@ package com.android.tools.metalava.model.visitors
 import com.android.tools.metalava.ApiPredicate
 import com.android.tools.metalava.PackageFilter
 import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.ItemVisitor
+import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
 import java.util.function.Predicate
 
 open class ApiVisitor(
     /**
-     * Whether constructors should be visited as part of a [#visitMethod] call instead of just a
-     * [#visitConstructor] call. Helps simplify visitors that don't care to distinguish between the
-     * two cases. Defaults to true.
-     */
-    visitConstructorsAsMethods: Boolean = true,
-    /**
-     * Whether inner classes should be visited "inside" a class; when this property is true, inner
+     * Whether nested classes should be visited "inside" a class; when this property is true, nested
      * classes are visited before the [#afterVisitClass] method is called; when false, it's done
      * afterwards. Defaults to false.
      */
-    nestInnerClasses: Boolean = false,
+    preserveClassNesting: Boolean = false,
 
     /** Whether to include inherited fields too */
     val inlineInheritedFields: Boolean = true,
 
-    /** Comparator to sort methods with. */
-    val methodComparator: Comparator<MethodItem> = MethodItem.comparator,
+    /** Comparator to sort callables with. */
+    val callableComparator: Comparator<CallableItem> = CallableItem.comparator,
 
     /** The filter to use to determine if we should emit an item */
     val filterEmit: Predicate<Item>,
@@ -53,13 +49,6 @@ open class ApiVisitor(
     /** The filter to use to determine if we should emit a reference to an item */
     val filterReference: Predicate<Item>,
 
-    /**
-     * Whether the visitor should include visiting top-level classes that have nothing other than
-     * non-empty inner classes within. Typically these are not included in signature files, but when
-     * generating stubs we need to include them.
-     */
-    val includeEmptyOuterClasses: Boolean = false,
-
     /**
      * Whether this visitor should visit elements that have not been annotated with one of the
      * annotations passed in using the --show-annotation flag. This is normally true, but signature
@@ -70,7 +59,7 @@ open class ApiVisitor(
 
     /** Configuration that may come from the command line. */
     config: Config,
-) : BaseItemVisitor(visitConstructorsAsMethods, nestInnerClasses) {
+) : BaseItemVisitor(preserveClassNesting) {
 
     private val packageFilter: PackageFilter? = config.packageFilter
 
@@ -87,17 +76,11 @@ open class ApiVisitor(
 
     constructor(
         /**
-         * Whether constructors should be visited as part of a [#visitMethod] call instead of just a
-         * [#visitConstructor] call. Helps simplify visitors that don't care to distinguish between
-         * the two cases. Defaults to true.
-         */
-        visitConstructorsAsMethods: Boolean = true,
-        /**
-         * Whether inner classes should be visited "inside" a class; when this property is true,
-         * inner classes are visited before the [#afterVisitClass] method is called; when false,
+         * Whether nested classes should be visited "inside" a class; when this property is true,
+         * nested classes are visited before the [#afterVisitClass] method is called; when false,
          * it's done afterwards. Defaults to false.
          */
-        nestInnerClasses: Boolean = false,
+        preserveClassNesting: Boolean = false,
 
         /** Whether to ignore APIs with annotations in the --show-annotations list */
         ignoreShown: Boolean = true,
@@ -105,8 +88,8 @@ open class ApiVisitor(
         /** Whether to match APIs marked for removal instead of the normal API */
         remove: Boolean = false,
 
-        /** Comparator to sort methods with. */
-        methodComparator: Comparator<MethodItem> = MethodItem.comparator,
+        /** Comparator to sort callables with. */
+        callableComparator: Comparator<CallableItem> = CallableItem.comparator,
 
         /**
          * The filter to use to determine if we should emit an item. If null, the default value is
@@ -131,10 +114,9 @@ open class ApiVisitor(
         /** Configuration that may come from the command line. */
         config: Config,
     ) : this(
-        visitConstructorsAsMethods = visitConstructorsAsMethods,
-        nestInnerClasses = nestInnerClasses,
+        preserveClassNesting = preserveClassNesting,
         inlineInheritedFields = true,
-        methodComparator = methodComparator,
+        callableComparator = callableComparator,
         filterEmit = filterEmit
                 ?: ApiPredicate(
                     matchRemoved = remove,
@@ -149,23 +131,26 @@ open class ApiVisitor(
         config = config,
     )
 
-    // The API visitor lazily visits packages only when there's a match within at least one class;
-    // this property keeps track of whether we've already visited the current package
-    var visitingPackage = false
+    /**
+     * Visit a [List] of [ClassItem]s after sorting it into order defined by
+     * [ClassItem.classNameSorter].
+     */
+    private fun visitClassList(classes: List<ClassItem>) {
+        classes.sortedWith(ClassItem.classNameSorter()).forEach { it.accept(this) }
+    }
 
+    /**
+     * Implement to redirect to [VisitCandidate.accept] if necessary,
+     *
+     * This is not called by this [ApiVisitor]. Instead, it calls [VisitCandidate.accept] which does
+     * not delegate to this method but visits the class and its members itself so that it can access
+     * the filtered and sorted members. However, this may be called by some other code calling
+     * [ClassItem.accept] directly on this [ApiVisitor]. In that case this creates and then
+     * delegates through to the [VisitCandidate.visitWrappedClassAndFilteredMembers]
+     */
     override fun visit(cls: ClassItem) {
-        if (!include(cls)) {
-            return
-        }
-
-        // We build up a separate data structure such that we can compute the
-        // sets of fields, methods, etc even for inner classes (recursively); that way
-        // we can easily and up front determine whether we have any matches for
-        // inner classes (which is vital for computing the removed-api for example, where
-        // only something like the appearance of a removed method inside an inner class
-        // results in the outer class being described in the signature file.
-        val candidate = VisitCandidate(cls)
-        candidate.accept()
+        // Get a VisitCandidate and visit it, if needed.
+        getVisitCandidateIfNeeded(cls)?.visitWrappedClassAndFilteredMembers()
     }
 
     override fun visit(pkg: PackageItem) {
@@ -173,17 +158,24 @@ open class ApiVisitor(
             return
         }
 
-        // For the API visitor packages are visited lazily; only when we encounter
-        // an unfiltered item within the class
-        pkg.topLevelClasses().asSequence().sortedWith(ClassItem.classNameSorter()).forEach {
-            it.accept(this)
-        }
+        // Get the list of classes to visit directly. If nested classes are to appear as nested
+        // then just visit the top level classes directly and then the nested classes will be
+        // visited
+        // by their containing classes. Otherwise, flatten the nested classes and treat them all as
+        // top level classes.
+        val classesToVisitDirectly: List<ClassItem> =
+            packageClassesAsSequence(pkg).mapNotNull { getVisitCandidateIfNeeded(it) }.toList()
 
-        if (visitingPackage) {
-            visitingPackage = false
-            afterVisitPackage(pkg)
-            afterVisitItem(pkg)
-        }
+        // If none of the classes in this package will be visited them ignore the package entirely.
+        if (classesToVisitDirectly.isEmpty()) return
+
+        visitItem(pkg)
+        visitPackage(pkg)
+
+        visitClassList(classesToVisitDirectly)
+
+        afterVisitPackage(pkg)
+        afterVisitItem(pkg)
     }
 
     /** @return Whether this class is generally one that we want to recurse into */
@@ -195,102 +187,89 @@ open class ApiVisitor(
             return false
         }
 
-        return cls.emit || cls.codebase.preFiltered
+        return cls.emit
     }
 
     /**
-     * @return Whether the given VisitCandidate's visitor should recurse into the given
-     *   VisitCandidate's class
+     * Returns a [VisitCandidate] if the [cls] needs to be visited, otherwise return `null`.
+     *
+     * The [cls] needs to be visited if it passes the various checks that determine whether it
+     * should be emitted as part of an API surface as determined by [filterEmit] and
+     * [filterReference].
      */
-    fun include(vc: VisitCandidate): Boolean {
-        if (!include(vc.cls)) {
-            return false
-        }
-        return shouldEmitClassBody(vc) || shouldEmitInnerClasses(vc)
-    }
+    private fun getVisitCandidateIfNeeded(cls: ClassItem): VisitCandidate? {
+        if (!include(cls)) return null
 
-    /**
-     * @return Whether this class should be visited Note that if [include] returns true then we will
-     *   still visit classes that are contained by this one
-     */
-    open fun shouldEmitClass(vc: VisitCandidate): Boolean {
-        return vc.cls.emit && (includeEmptyOuterClasses || shouldEmitClassBody(vc))
-    }
+        // Check to see whether this class should be emitted in its entirety. If not then it may
+        // still be emitted if it contains emittable members.
+        val emit = filterEmit.test(cls)
 
-    /**
-     * @return Whether the body of this class (everything other than the inner classes) emits
-     *   anything
-     */
-    private fun shouldEmitClassBody(vc: VisitCandidate): Boolean {
-        return when {
-            filterEmit.test(vc.cls) -> true
-            vc.nonEmpty() -> filterReference.test(vc.cls)
-            else -> false
-        }
-    }
+        // If the class is emitted then create a VisitCandidate immediately.
+        if (emit) return VisitCandidate(cls)
 
-    /** @return Whether the inner classes of this class will emit anything */
-    fun shouldEmitInnerClasses(vc: VisitCandidate): Boolean {
-        return vc.innerClasses.any { shouldEmitAnyClass(it) }
-    }
+        // Check to see if the class could be emitted if it contains emittable members. If not then
+        // return `null` to ignore this class. This will happen for a hidden class, e.g. package
+        // private, that implements/overrides methods from the API.
+        if (!filterReference.test(cls)) return null
+
+        // Create a VisitCandidate to encapsulate the emittable members, if any.
+        val vc = VisitCandidate(cls)
 
-    /** @return Whether this class will emit anything */
-    private fun shouldEmitAnyClass(vc: VisitCandidate): Boolean {
-        return shouldEmitClassBody(vc) || shouldEmitInnerClasses(vc)
+        // Check to see if the class has any emittable members, if not return `null` to ignore this
+        // class.
+        if (vc.containsNoEmittableMembers()) return null
+
+        // The class is emittable so return it.
+        return vc
     }
 
-    companion object {
+    /**
+     * Encapsulates a [ClassItem] that is being visited and its members, filtered by [filterEmit],
+     * and sorted by various members specific comparators.
+     *
+     * The purpose of this is to store the lists of filtered and sorted members that were created
+     * during filtering of the classes in the [PackageItem] visit method. They need to be stored as
+     * they can take a long time to generate and will be needed again when visiting the class
+     * contents.
+     *
+     * Note: This implements [ClassItem] to allow visiting code to be more easily shared between
+     * this and [BaseItemVisitor]. It must not escape out of this class, e.g. be passed to
+     * `visitClass(...)`.
+     */
+    private inner class VisitCandidate(val cls: ClassItem) : ClassItem by cls {
+
         /**
-         * Comparator that will order [FieldItem]s such that those for which
-         * [FieldItem.isEnumConstant] returns `true` will come before those for which it is `false`.
+         * If the list this is called upon is empty then just return [emptyList], else apply the
+         * [transform] to the list and return that.
          */
-        private val fieldComparatorEnumConstantFirst =
-            Comparator.comparing(FieldItem::isEnumConstant)
-                .reversed()
-                .thenComparing(FieldItem.comparator)
-    }
+        private inline fun <T> List<T>.mapIfNotEmpty(transform: List<T>.() -> List<T>) =
+            if (isEmpty()) emptyList() else transform(this)
 
-    inner class VisitCandidate(val cls: ClassItem) {
-        val innerClasses by
-            lazy(LazyThreadSafetyMode.NONE) {
-                val clsInnerClasses = cls.innerClasses()
-                if (clsInnerClasses.isEmpty()) {
-                    emptyList()
-                } else {
-                    clsInnerClasses
-                        .asSequence()
-                        .sortedWith(ClassItem.classNameSorter())
-                        .map { VisitCandidate(it) }
-                        .toList()
+        /**
+         * Sort the sequence into a [List].
+         *
+         * The standard [Sequence.sortedWith] will sort it into a list and then return a sequence
+         * wrapper which would then have to be converted back into a list. Instead, this just sorts
+         * it into a [List] and returns that.
+         */
+        private fun <T> Sequence<T>.sortToList(comparator: Comparator<in T>) =
+            if (none()) emptyList()
+            else
+                toMutableList().let {
+                    // Sort the list in place.
+                    it.sortWith(comparator)
+                    // Return the sorter list.
+                    it
                 }
-            }
 
-        private val constructors by
-            lazy(LazyThreadSafetyMode.NONE) {
-                val clsConstructors = cls.constructors()
-                if (clsConstructors.isEmpty()) {
-                    emptyList()
-                } else {
-                    clsConstructors
-                        .asSequence()
-                        .filter { filterEmit.test(it) }
-                        .sortedWith(methodComparator)
-                        .toList()
-                }
+        private val constructors =
+            cls.constructors().mapIfNotEmpty {
+                asSequence().filter { filterEmit.test(it) }.sortToList(callableComparator)
             }
 
-        private val methods by
-            lazy(LazyThreadSafetyMode.NONE) {
-                val clsMethods = cls.methods()
-                if (clsMethods.isEmpty()) {
-                    emptyList()
-                } else {
-                    clsMethods
-                        .asSequence()
-                        .filter { filterEmit.test(it) }
-                        .sortedWith(methodComparator)
-                        .toList()
-                }
+        private val methods =
+            cls.methods().mapIfNotEmpty {
+                asSequence().filter { filterEmit.test(it) }.sortToList(callableComparator)
             }
 
         private val fields by
@@ -303,73 +282,55 @@ open class ApiVisitor(
                     }
 
                 // Sort the fields so that enum constants come first.
-                fieldSequence.sortedWith(fieldComparatorEnumConstantFirst)
+                fieldSequence.sortToList(FieldItem.comparatorEnumConstantFirst)
             }
 
-        private val properties by
-            lazy(LazyThreadSafetyMode.NONE) {
-                val clsProperties = cls.properties()
-                if (clsProperties.isEmpty()) {
-                    emptyList()
-                } else {
-                    clsProperties
-                        .asSequence()
-                        .filter { filterEmit.test(it) }
-                        .sortedWith(PropertyItem.comparator)
-                        .toList()
-                }
+        private val properties =
+            cls.properties().mapIfNotEmpty {
+                asSequence().filter { filterEmit.test(it) }.sortToList(PropertyItem.comparator)
             }
 
-        /** Whether the class body contains any Item's (other than inner Classes) */
-        fun nonEmpty(): Boolean {
-            return !(constructors.none() && methods.none() && fields.none() && properties.none())
-        }
-
-        fun accept() {
-            if (!include(this)) {
-                return
-            }
-
-            val emitThis = shouldEmitClass(this)
-            if (emitThis) {
-                if (!visitingPackage) {
-                    visitingPackage = true
-                    val pkg = cls.containingPackage()
-                    visitItem(pkg)
-                    visitPackage(pkg)
-                }
-
-                visitItem(cls)
-                visitClass(cls)
+        /** Whether the class body contains any emmittable [MemberItem]s. */
+        fun containsNoEmittableMembers() =
+            constructors.isEmpty() && methods.isEmpty() && fields.isEmpty() && properties.isEmpty()
 
-                for (constructor in constructors) {
-                    constructor.accept(this@ApiVisitor)
-                }
+        /**
+         * Intercepts the call to visit this class and instead of using the default implementation
+         * which delegate to the appropriate method in [visitor] calls
+         */
+        override fun accept(visitor: ItemVisitor) {
+            if (visitor !== this@ApiVisitor)
+                error(
+                    "VisitCandidate instance must only be visited by its creating ApiVisitor, not $visitor"
+                )
+            visitWrappedClassAndFilteredMembers()
+        }
 
-                for (method in methods) {
-                    method.accept(this@ApiVisitor)
-                }
+        internal fun visitWrappedClassAndFilteredMembers() {
+            visitItem(cls)
+            visitClass(cls)
 
-                for (property in properties) {
-                    property.accept(this@ApiVisitor)
-                }
-                for (field in fields) {
-                    field.accept(this@ApiVisitor)
-                }
+            for (constructor in constructors) {
+                constructor.accept(this@ApiVisitor)
             }
 
-            if (nestInnerClasses) { // otherwise done below
-                innerClasses.forEach { it.accept() }
+            for (method in methods) {
+                method.accept(this@ApiVisitor)
             }
 
-            if (emitThis) {
-                afterVisitClass(cls)
-                afterVisitItem(cls)
+            for (property in properties) {
+                property.accept(this@ApiVisitor)
+            }
+            for (field in fields) {
+                field.accept(this@ApiVisitor)
             }
 
-            if (!nestInnerClasses) {
-                innerClasses.forEach { it.accept() }
+            if (preserveClassNesting) { // otherwise done in visit(PackageItem)
+                visitClassList(cls.nestedClasses().mapNotNull { getVisitCandidateIfNeeded(it) })
             }
+
+            afterVisitClass(cls)
+            afterVisitItem(cls)
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt b/metalava/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
new file mode 100644
index 000000000..03f5c5d84
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.visitors
+
+import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.ExceptionTypeItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemVisitor
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeTransformer
+import com.android.tools.metalava.model.typeUseAnnotationFilter
+import java.util.function.Predicate
+
+/**
+ * An [ApiVisitor] that filters the input and forwards it to the [delegate] [ItemVisitor].
+ *
+ * This defines a number of `Filtering*Item` classes that will filter out any [Item] references for
+ * which [filterReference] returns false. They are not suitable for general use. Their sole purpose
+ * is to provide enough functionality for use when writing a representation of the item, e.g. for
+ * signatures, stubs, etc. That means that there may be some methods that are not use by those
+ * writers which will allow access to unfiltered `Item`s.
+ *
+ * Preserves class nesting as required by the [delegate]'s [DelegatedVisitor.requiresClassNesting]
+ * property.
+ */
+class FilteringApiVisitor(
+    val delegate: DelegatedVisitor,
+    inlineInheritedFields: Boolean = true,
+    callableComparator: Comparator<CallableItem> = CallableItem.comparator,
+    /**
+     * Optional lambda for sorting the filtered, list of interface types from a [ClassItem].
+     *
+     * This will only be called if the filtered list contains 2 or more elements.
+     *
+     * This is provided primarily to allow usages where the interface order cannot be enforced by
+     * [interfaceListComparator]. In that case this should be provided and [interfaceListComparator]
+     * should be left unspecified so that the order of the list returned by this is unchanged.
+     *
+     * If this is `null` then it will behave as if it just returned the filtered interface types it
+     * was passed.
+     *
+     * This is mutually exclusive with [interfaceListComparator].
+     */
+    private val interfaceListSorter:
+        ((ClassItem, List<ClassTypeItem>, List<ClassTypeItem>) -> List<ClassTypeItem>)? =
+        null,
+    /**
+     * Optional comparator to use for sorting interface list types.
+     *
+     * This is mutually exclusive with [interfaceListSorter].
+     */
+    private val interfaceListComparator: Comparator<TypeItem>? = null,
+    filterEmit: Predicate<Item>,
+    filterReference: Predicate<Item>,
+    private val preFiltered: Boolean,
+    private val filterSuperClassType: Boolean = true,
+    showUnannotated: Boolean = true,
+    config: Config,
+) :
+    ApiVisitor(
+        preserveClassNesting = delegate.requiresClassNesting,
+        inlineInheritedFields = inlineInheritedFields,
+        callableComparator = callableComparator,
+        filterEmit = filterEmit,
+        filterReference = filterReference,
+        showUnannotated = showUnannotated,
+        config = config,
+    ),
+    ItemVisitor {
+
+    /**
+     * A [TypeTransformer] that will remove any type annotations for which [filterReference] returns
+     * false when called against the annotation's [ClassItem].
+     */
+    private val typeAnnotationFilter = typeUseAnnotationFilter(filterReference)
+
+    override fun visitCodebase(codebase: Codebase) {
+        // This does not create a filtering wrapper around the Codebase as the classes to which this
+        // currently delegates do not access any fields within the Codebase.
+        delegate.visitCodebase(codebase)
+    }
+
+    override fun afterVisitCodebase(codebase: Codebase) {
+        // This does not create a filtering wrapper around the Codebase as the classes to which this
+        // currently delegates do not access any fields within the Codebase.
+        delegate.afterVisitCodebase(codebase)
+    }
+
+    override fun visitPackage(pkg: PackageItem) {
+        delegate.visitPackage(pkg)
+    }
+
+    override fun afterVisitPackage(pkg: PackageItem) {
+        delegate.afterVisitPackage(pkg)
+    }
+
+    /** Stack of the containing classes. */
+    private val containingClassStack = ArrayDeque<FilteringClassItem?>()
+
+    /** The current [ClassItem] being visited, */
+    private var currentClassItem: FilteringClassItem? = null
+
+    override fun visitClass(cls: ClassItem) {
+        // Switch the current class, if any, to be a containing class.
+        containingClassStack.addLast(currentClassItem)
+
+        // Create a new FilteringClassItem for the current class and visit it before its contents.
+        currentClassItem = FilteringClassItem(delegate = cls)
+        delegate.visitClass(currentClassItem!!)
+    }
+
+    override fun afterVisitClass(cls: ClassItem) {
+        // Consistency check to make sure that the visitClass/afterVisitClass are called correctly.
+        if (currentClassItem?.delegate !== cls)
+            throw IllegalStateException("Expected ${currentClassItem?.delegate}, found ${cls}")
+
+        // Visit the class after its contents.
+        delegate.afterVisitClass(currentClassItem!!)
+
+        // Switch back to the containing class, if any.
+        currentClassItem = containingClassStack.removeLast()
+    }
+
+    override fun visitConstructor(constructor: ConstructorItem) {
+        val filteringConstructor = FilteringConstructorItem(constructor)
+        delegate.visitConstructor(filteringConstructor)
+    }
+
+    override fun visitMethod(method: MethodItem) {
+        val filteringMethod = FilteringMethodItem(method)
+        delegate.visitMethod(filteringMethod)
+    }
+
+    override fun visitField(field: FieldItem) {
+        val filteringField = FilteringFieldItem(field)
+        delegate.visitField(filteringField)
+    }
+
+    override fun visitProperty(property: PropertyItem) {
+        val filteringProperty = FilteringPropertyItem(property)
+        delegate.visitProperty(filteringProperty)
+    }
+
+    /**
+     * [SourceFile] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringSourceFile(val delegate: SourceFile) : SourceFile by delegate {
+
+        override fun getImports() = delegate.getImports(filterReference)
+    }
+
+    /**
+     * [ClassItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringClassItem(
+        val delegate: ClassItem,
+    ) : ClassItem by delegate {
+
+        override fun getSourceFile() = delegate.getSourceFile()?.let { FilteringSourceFile(it) }
+
+        override fun superClass() = superClassType()?.asClass()
+
+        override fun superClassType() =
+            if (!filterSuperClassType || preFiltered) delegate.superClassType()
+            else delegate.filteredSuperClassType(filterReference)?.transform(typeAnnotationFilter)
+
+        override fun interfaceTypes(): List<ClassTypeItem> {
+            // Get the filtered list from the delegate.
+            val filtered =
+                if (preFiltered) delegate.interfaceTypes()
+                else delegate.filteredInterfaceTypes(filterReference).toList()
+
+            // If the list is empty then nothing else is needed.
+            if (filtered.isEmpty()) return emptyList()
+
+            // Order the list.
+            val ordered =
+                when {
+                    // 0. If the list only has 1 element then it does not need sorting
+                    filtered.size == 1 -> filtered
+
+                    // 1. Use the custom sorter, if available.
+                    interfaceListSorter != null -> {
+                        // Make sure a interfaceListComparator was not provided as well.
+                        interfaceListComparator?.let {
+                            error(
+                                "Cannot specify both interfaceListSorter and interfaceListComparator"
+                            )
+                        }
+
+                        // Get the unfiltered lists from the delegate.
+                        val unfiltered =
+                            if (preFiltered) {
+                                // If pre-filtered then the filtered and unfiltered are the
+                                // same.
+                                filtered
+                            } else delegate.interfaceTypes()
+
+                        interfaceListSorter.invoke(delegate, filtered, unfiltered)
+                    }
+
+                    // 2. Sort using the comparator, if available.
+                    interfaceListComparator != null -> {
+                        filtered.sortedWith(interfaceListComparator)
+                    }
+
+                    // 3. Preserve the input order.
+                    else -> filtered
+                }
+
+            // If required then filter annotation types from the ordered list before returning.
+            return if (preFiltered) ordered
+            else
+                ordered.map {
+                    // Filter any inaccessible annotations from the interfaces
+                    it.transform(typeAnnotationFilter)
+                }
+        }
+
+        override fun constructors() =
+            delegate
+                .filteredConstructors(filterReference)
+                .map { FilteringConstructorItem(it) }
+                .toList()
+
+        override fun fields(): List<FieldItem> =
+            delegate.filteredFields(filterReference, showUnannotated).map { FilteringFieldItem(it) }
+    }
+
+    /**
+     * [ParameterItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringParameterItem(private val delegate: ParameterItem) :
+        ParameterItem by delegate {
+
+        override fun type() = delegate.type().transform(typeAnnotationFilter)
+    }
+
+    /** Get the [MethodItem.returnType] and apply the [typeAnnotationFilter] to it. */
+    fun filteredReturnType(callableItem: CallableItem) =
+        callableItem.returnType().transform(typeAnnotationFilter)
+
+    /** Get the [MethodItem.parameters] and wrap each one in a [FilteringParameterItem]. */
+    fun filteredParameters(callableItem: CallableItem): List<ParameterItem> =
+        callableItem.parameters().map { FilteringParameterItem(it) }
+
+    /**
+     * Get the [MethodItem.filteredThrowsTypes] and apply [typeAnnotationFilter] to each
+     * [ExceptionTypeItem] in the list.
+     */
+    private fun filteredThrowsTypes(callableItem: CallableItem) =
+        if (preFiltered) callableItem.throwsTypes()
+        else
+            callableItem.filteredThrowsTypes(filterReference).map {
+                it.transform(typeAnnotationFilter)
+            }
+
+    /**
+     * [ConstructorItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringConstructorItem(private val delegate: ConstructorItem) :
+        ConstructorItem by delegate {
+
+        override fun containingClass() = FilteringClassItem(delegate.containingClass())
+
+        override fun returnType() = filteredReturnType(delegate) as ClassTypeItem
+
+        override fun parameters() = filteredParameters(delegate)
+
+        override fun throwsTypes() = filteredThrowsTypes(delegate)
+    }
+
+    /**
+     * [MethodItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringMethodItem(private val delegate: MethodItem) :
+        MethodItem by delegate {
+
+        override fun returnType() = filteredReturnType(delegate)
+
+        override fun parameters() = filteredParameters(delegate)
+
+        override fun throwsTypes() = filteredThrowsTypes(delegate)
+    }
+
+    /**
+     * [FieldItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringFieldItem(private val delegate: FieldItem) :
+        FieldItem by delegate {
+
+        override fun type() = delegate.type().transform(typeAnnotationFilter)
+    }
+
+    /**
+     * [PropertyItem] that will filter out anything which is not to be written out by the
+     * [FilteringApiVisitor.delegate].
+     */
+    private inner class FilteringPropertyItem(private val delegate: PropertyItem) :
+        PropertyItem by delegate {
+
+        override fun type() = delegate.type().transform(typeAnnotationFilter)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
index 17c8137fe..349caa146 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
@@ -17,28 +17,30 @@
 package com.android.tools.metalava.stub
 
 import com.android.tools.metalava.actualItem
-import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.JAVA_LANG_STRING
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterBindings
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VariableTypeItem
 import java.io.PrintWriter
-import java.util.function.Predicate
 
 internal class JavaStubWriter(
     private val writer: PrintWriter,
     private val modifierListWriter: ModifierListWriter,
-    private val filterEmit: Predicate<Item>,
-    private val filterReference: Predicate<Item>,
-    private val preFiltered: Boolean = true,
     private val config: StubWriterConfig,
-) : BaseItemVisitor() {
+    private val stubConstructorManager: StubConstructorManager,
+) : DelegatedVisitor {
 
     override fun visitClass(cls: ClassItem) {
         if (cls.isTopLevelClass()) {
@@ -51,7 +53,7 @@ internal class JavaStubWriter(
                 // All the classes referenced in the stubs are fully qualified, so no imports are
                 // needed. However, in some cases for javadoc, replacement with fully qualified name
                 // fails, and thus we need to include imports for the stubs to compile.
-                cls.getSourceFile()?.getImports(filterReference)?.let {
+                cls.getSourceFile()?.getImports()?.let {
                     for (item in it) {
                         if (item.isMember) {
                             writer.println("import static ${item.pattern};")
@@ -86,30 +88,33 @@ internal class JavaStubWriter(
         generateInterfaceList(cls)
         writer.print(" {\n")
 
+        // Enum constants must be written out first.
         if (cls.isEnum()) {
             var first = true
-            // Enums should preserve the original source order, not alphabetical etc. sort
-            for (field in cls.filteredFields(filterReference, true).sortedBy { it.sortingRank }) {
-                if (field.isEnumConstant()) {
-                    if (first) {
-                        first = false
-                    } else {
-                        writer.write(",\n")
-                    }
-                    appendDocumentation(field, writer, config)
+            // While enum order is significant at runtime as it affects `Enum.ordinal` and its
+            // comparable order it is not significant in the stubs so sort alphabetically. That
+            // matches the order in the documentation and the signature files. It is theoretically
+            // possible for an annotation processor to care about the order but any that did would
+            // be poorly written and would break on stubs created from signature files.
+            val enumConstants =
+                cls.fields().filter { it.isEnumConstant() }.sortedWith(FieldItem.comparator)
+            for (enumConstant in enumConstants) {
+                if (first) {
+                    first = false
+                } else {
+                    writer.write(",\n")
+                }
+                appendDocumentation(enumConstant, writer, config)
 
-                    // Append the modifier list even though the enum constant does not actually have
-                    // modifiers as that will write the annotations which it does have and ignore
-                    // the modifiers.
-                    appendModifiers(field)
+                // Append the modifier list even though the enum constant does not actually have
+                // modifiers as that will write the annotations which it does have and ignore
+                // the modifiers.
+                appendModifiers(enumConstant)
 
-                    writer.write(field.name())
-                }
+                writer.write(enumConstant.name())
             }
             writer.println(";")
         }
-
-        generateMissingConstructors(cls)
     }
 
     override fun afterVisitClass(cls: ClassItem) {
@@ -128,9 +133,7 @@ internal class JavaStubWriter(
             return
         }
 
-        val superClass =
-            if (preFiltered) cls.superClassType() else cls.filteredSuperClassType(filterReference)
-
+        val superClass = cls.superClassType()
         if (superClass != null && !superClass.isJavaLangObject()) {
             writer.print(" extends ")
             writer.print(superClass.toTypeString())
@@ -143,13 +146,11 @@ internal class JavaStubWriter(
             return
         }
 
-        val interfaces =
-            if (preFiltered) cls.interfaceTypes() else cls.filteredInterfaceTypes(filterReference)
-
-        if (interfaces.any()) {
+        val interfaces = cls.interfaceTypes()
+        if (interfaces.isNotEmpty()) {
             val label = if (cls.isInterface()) " extends" else " implements"
             writer.print(label)
-            interfaces.forEachIndexed { index, type ->
+            interfaces.sortedWith(TypeItem.totalComparator).forEachIndexed { index, type ->
                 if (index > 0) {
                     writer.print(",")
                 }
@@ -171,10 +172,6 @@ internal class JavaStubWriter(
     }
 
     override fun visitConstructor(constructor: ConstructorItem) {
-        writeConstructor(constructor, constructor.superConstructor)
-    }
-
-    private fun writeConstructor(constructor: MethodItem, superConstructor: MethodItem?) {
         writer.println()
         appendDocumentation(constructor, writer, config)
         appendModifiers(constructor)
@@ -186,81 +183,35 @@ internal class JavaStubWriter(
 
         writer.print(" { ")
 
-        writeConstructorBody(constructor, superConstructor)
+        writeConstructorBody(constructor)
         writer.println(" }")
     }
 
-    private fun writeConstructorBody(constructor: MethodItem, superConstructor: MethodItem?) {
-        // Find any constructor in parent that we can compile against
-        superConstructor?.let { it ->
-            val parameters = it.parameters()
+    private fun writeConstructorBody(constructor: ConstructorItem) {
+        val optionalSuperConstructor =
+            stubConstructorManager.optionalSuperConstructor(constructor.containingClass())
+        optionalSuperConstructor?.let { superConstructor ->
+            val parameters = superConstructor.parameters()
             if (parameters.isNotEmpty()) {
-                val includeCasts =
-                    it.containingClass().constructors().filter { filterReference.test(it) }.size > 1
                 writer.print("super(")
-                parameters.forEachIndexed { index, parameter ->
+
+                // Get the types to which this class binds the super class's type parameters, if
+                // any.
+                val typeParameterBindings =
+                    constructor
+                        .containingClass()
+                        .mapTypeVariables(superConstructor.containingClass())
+
+                for ((index, parameter) in parameters.withIndex()) {
                     if (index > 0) {
                         writer.write(", ")
                     }
-                    val type = parameter.type()
-                    if (type !is PrimitiveTypeItem) {
-                        if (includeCasts) {
-                            // Casting to the erased type could lead to unchecked warnings (which
-                            // are suppressed) but avoids having to deal with parameterized types
-                            // and ensures that casting to a vararg parameter uses an array type.
-                            val typeString = type.toErasedTypeString()
-                            writer.write("(")
-                            if (type is VariableTypeItem) {
-                                // The super constructor's parameter is a type variable: so see if
-                                // it should be mapped back to a type specified by this class. e.g.
-                                // Given:
-                                //   class Bar<T extends Number> {
-                                //       public Bar(int i) {}
-                                //       public Bar(T t) {}
-                                //   }
-                                //   class Foo extends Bar<Integer> {
-                                //       public Foo(Integer i) { super(i); }
-                                //   }
-                                //
-                                // The stub for Foo should use:
-                                //     super((Integer) i);
-                                // Not:
-                                //     super((Number) i);
-                                //
-                                // However, if the super class is referenced as a raw type then
-                                // there will be no mapping in which case fall back to the erased
-                                // type which will use the type variable's lower bound. e.g.
-                                // Given:
-                                //   class Foo extends Bar {
-                                //       public Foo(Integer i) { super(i); }
-                                //   }
-                                //
-                                // The stub for Foo should use:
-                                //     super((Number) i);
-                                val map =
-                                    constructor
-                                        .containingClass()
-                                        .mapTypeVariables(it.containingClass())
-                                val cast = map[type.asTypeParameter]?.toTypeString() ?: typeString
-                                writer.write(cast)
-                            } else {
-                                writer.write(typeString)
-                            }
-                            writer.write(")")
-                        }
-                        writer.write("null")
-                    } else {
-                        // Add cast for things like shorts and bytes
-                        val typeString = type.toTypeString()
-                        if (
-                            typeString != "boolean" && typeString != "int" && typeString != "long"
-                        ) {
-                            writer.write("(")
-                            writer.write(typeString)
-                            writer.write(")")
-                        }
-                        writer.write(type.defaultValueString())
-                    }
+                    // Always make sure to add appropriate casts to the parameters in the super call
+                    // as without the casts the compiler will fail if there is more than one
+                    // constructor that could match.
+                    val defaultValueWithCast =
+                        defaultValueWithCastForType(parameter.type(), typeParameterBindings)
+                    writer.write(defaultValueWithCast)
                 }
                 writer.print("); ")
             }
@@ -269,16 +220,79 @@ internal class JavaStubWriter(
         writeThrowStub()
     }
 
-    private fun generateMissingConstructors(cls: ClassItem) {
-        val clsStubConstructor = cls.stubConstructor
-        val constructors = cls.filteredConstructors(filterEmit)
-        // If the default stub constructor is not publicly visible then it won't be output during
-        // the normal visiting
-        // so visit it specially to ensure that it is output.
-        if (clsStubConstructor != null && !constructors.contains(clsStubConstructor)) {
-            visitConstructor(clsStubConstructor)
-            return
+    /**
+     * Get the string representation of the default value for [type], it will include a cast if
+     * necessary.
+     *
+     * If [type] is a [VariableTypeItem] then it will map it to the appropriate type given the
+     * [typeParameterBindings]. See the comment in the body for more details.
+     */
+    private fun defaultValueWithCastForType(
+        type: TypeItem,
+        typeParameterBindings: TypeParameterBindings,
+    ): String {
+        // Handle special cases and non-reference types, drop through to handle the default
+        // reference type.
+        when (type) {
+            is PrimitiveTypeItem -> {
+                val kind = type.kind
+                return when (kind) {
+                    PrimitiveTypeItem.Primitive.BOOLEAN,
+                    PrimitiveTypeItem.Primitive.INT,
+                    PrimitiveTypeItem.Primitive.LONG -> kind.defaultValueString
+                    else -> "(${kind.primitiveName})${kind.defaultValueString}"
+                }
+            }
+            is ClassTypeItem -> {
+                val qualifiedName = type.qualifiedName
+                when (qualifiedName) {
+                    JAVA_LANG_STRING -> return "\"\""
+                }
+            }
         }
+
+        // Get the actual type that the super constructor expects, taking into account any type
+        // parameter mappings.
+        val mappedType =
+            if (type is VariableTypeItem) {
+                // The super constructor's parameter is a type variable: so see if it should be
+                // mapped back to a type specified by this class. e.g.
+                //
+                // Given:
+                //   class Bar<T extends Number> {
+                //       public Bar(int i) {}
+                //       public Bar(T t) {}
+                //   }
+                //   class Foo extends Bar<Integer> {
+                //       public Foo(Integer i) { super(i); }
+                //   }
+                //
+                // The stub for Foo should use:
+                //     super((Integer) i);
+                // Not:
+                //     super((Number) i);
+                //
+                // However, if the super class is referenced as a raw type then there will be no
+                // mapping in which case fall back to the erased type which will use the type
+                // variable's lower bound. e.g.
+                //
+                // Given:
+                //   class Foo extends Bar {
+                //       public Foo(Integer i) { super(i); }
+                //   }
+                //
+                // The stub for Foo should use:
+                //     super((Number) i);
+                type.convertType(typeParameterBindings)
+            } else {
+                type
+            }
+
+        // Casting to the erased type could lead to unchecked warnings (which are suppressed) but
+        // avoids having to deal with parameterized types and ensures that casting to a vararg
+        // parameter uses an array type.
+        val erasedTypeString = mappedType.toErasedTypeString()
+        return "($erasedTypeString)null"
     }
 
     override fun visitMethod(method: MethodItem) {
@@ -293,7 +307,7 @@ internal class JavaStubWriter(
         generateTypeParameterList(typeList = method.typeParameterList, addSpace = true)
 
         val returnType = method.returnType()
-        writer.print(returnType.toTypeString(annotations = false, filter = filterReference))
+        writer.print(returnType.toTypeString(annotations = false))
 
         writer.print(' ')
         writer.print(method.name())
@@ -327,11 +341,11 @@ internal class JavaStubWriter(
 
         appendDocumentation(field, writer, config)
         appendModifiers(field)
-        writer.print(field.type().toTypeString(annotations = false, filter = filterReference))
+        writer.print(field.type().toTypeString(annotations = false))
         writer.print(' ')
         writer.print(field.name())
         val needsInitialization =
-            field.modifiers.isFinal() &&
+            field.actualItem.modifiers.isFinal() &&
                 field.initialValue(true) == null &&
                 field.containingClass().isClass()
         field.writeValueWithSemicolon(
@@ -353,16 +367,14 @@ internal class JavaStubWriter(
         writer.write("throw new RuntimeException(\"Stub!\");")
     }
 
-    private fun generateParameterList(method: MethodItem) {
+    private fun generateParameterList(callable: CallableItem) {
         writer.print("(")
-        method.parameters().asSequence().forEachIndexed { i, parameter ->
+        callable.parameters().asSequence().forEachIndexed { i, parameter ->
             if (i > 0) {
                 writer.print(", ")
             }
             appendModifiers(parameter)
-            writer.print(
-                parameter.type().toTypeString(annotations = false, filter = filterReference)
-            )
+            writer.print(parameter.type().toTypeString(annotations = false))
             writer.print(' ')
             val name = parameter.publicName() ?: parameter.name()
             writer.print(name)
@@ -370,15 +382,9 @@ internal class JavaStubWriter(
         writer.print(")")
     }
 
-    private fun generateThrowsList(method: MethodItem) {
-        // Note that throws types are already sorted internally to help comparison matching
-        val throws =
-            if (preFiltered) {
-                method.throwsTypes().asSequence()
-            } else {
-                method.filteredThrowsTypes(filterReference).asSequence()
-            }
-        if (throws.any()) {
+    private fun generateThrowsList(callable: CallableItem) {
+        val throws = callable.throwsTypes()
+        if (throws.isNotEmpty()) {
             writer.print(" throws ")
             throws.sortedWith(ExceptionTypeItem.fullNameComparator).forEachIndexed { i, type ->
                 if (i > 0) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/KotlinStubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/KotlinStubWriter.kt
deleted file mode 100644
index fe94cc7d7..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/stub/KotlinStubWriter.kt
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.stub
-
-import com.android.tools.metalava.model.BaseItemVisitor
-import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.ModifierListWriter
-import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterList
-import com.android.tools.metalava.model.psi.PsiClassItem
-import java.io.PrintWriter
-import java.util.function.Predicate
-
-internal class KotlinStubWriter(
-    private val writer: PrintWriter,
-    private val modifierListWriter: ModifierListWriter,
-    private val filterReference: Predicate<Item>,
-    private val preFiltered: Boolean = true,
-    private val config: StubWriterConfig,
-) : BaseItemVisitor() {
-
-    override fun visitClass(cls: ClassItem) {
-        if (cls.isTopLevelClass()) {
-            val qualifiedName = cls.containingPackage().qualifiedName()
-            if (qualifiedName.isNotBlank()) {
-                writer.println("package $qualifiedName")
-                writer.println()
-            }
-            cls.getSourceFile()?.getImports(filterReference)?.let {
-                for (item in it) {
-                    writer.println("import ${item.pattern}")
-                }
-                writer.println()
-            }
-        }
-        appendDocumentation(cls, writer, config)
-
-        writer.println("@file:Suppress(\"ALL\")")
-
-        appendModifiers(cls)
-
-        when {
-            cls.isAnnotationType() -> writer.print("annotation class")
-            cls.isInterface() -> writer.print("interface")
-            cls.isEnum() -> writer.print("enum class")
-            else -> writer.print("class")
-        }
-
-        writer.print(" ")
-        writer.print(cls.simpleName())
-
-        generateTypeParameterList(typeList = cls.typeParameterList, addSpace = false)
-        val printedSuperClass = generateSuperClassDeclaration(cls)
-        generateInterfaceList(cls, printedSuperClass)
-        writer.print(" {\n")
-    }
-
-    private fun generateTypeParameterList(typeList: TypeParameterList, addSpace: Boolean) {
-        val typeListString = typeList.toString()
-        if (typeListString.isNotEmpty()) {
-            writer.print(typeListString)
-
-            if (addSpace) {
-                writer.print(' ')
-            }
-        }
-    }
-
-    private fun appendModifiers(item: Item) = modifierListWriter.write(item)
-
-    private fun generateSuperClassDeclaration(cls: ClassItem): Boolean {
-        if (cls.isEnum() || cls.isAnnotationType()) {
-            // No extends statement for enums and annotations; it's implied by the "enum" and
-            // "@interface" keywords
-            return false
-        }
-
-        val superClass =
-            if (preFiltered) cls.superClassType() else cls.filteredSuperClassType(filterReference)
-
-        if (superClass != null && !superClass.isJavaLangObject()) {
-            val qualifiedName =
-                superClass.toTypeString() // TODO start passing language = Language.KOTLIN
-            writer.print(" : ")
-
-            if (qualifiedName.contains("<")) {
-                // TODO: push this into the model at filter-time such that clients don't need
-                // to remember to do this!!
-                val s = superClass.asClass()
-                if (s != null) {
-                    val replaced = superClass.convertType(cls, s)
-                    writer.print(replaced.toTypeString())
-                    return true
-                }
-            }
-            (cls as PsiClassItem).psiClass.superClassType
-            writer.print(qualifiedName)
-            // TODO: print out arguments to the parent constructor
-            writer.print("()")
-            return true
-        }
-        return false
-    }
-
-    private fun generateInterfaceList(cls: ClassItem, printedSuperClass: Boolean) {
-        if (cls.isAnnotationType()) {
-            // No extends statement for annotations; it's implied by the "@interface" keyword
-            return
-        }
-
-        val interfaces =
-            if (preFiltered) cls.interfaceTypes().asSequence()
-            else cls.filteredInterfaceTypes(filterReference).asSequence()
-
-        if (interfaces.any()) {
-            if (printedSuperClass) {
-                writer.print(",")
-            } else {
-                writer.print(" :")
-            }
-            interfaces.forEachIndexed { index, type ->
-                if (index > 0) {
-                    writer.print(",")
-                }
-                writer.print(" ")
-                writer.print(type.toTypeString()) // TODO start passing language = Language.KOTLIN
-            }
-        }
-    }
-
-    private fun writeType(type: TypeItem?) {
-        type ?: return
-
-        val typeString =
-            type.toTypeString(
-                annotations = false,
-                kotlinStyleNulls = true,
-                filter = filterReference
-                // TODO pass in language = Language.KOTLIN
-            )
-
-        writer.print(typeString)
-    }
-
-    override fun visitMethod(method: MethodItem) {
-        if (method.isKotlinProperty()) return // will be handled by visitProperty
-
-        writer.println()
-        appendDocumentation(method, writer, config)
-
-        // TODO: Should be an annotation
-        generateThrowsList(method)
-
-        appendModifiers(method)
-        generateTypeParameterList(typeList = method.typeParameterList, addSpace = true)
-
-        writer.print("fun ")
-        writer.print(method.name())
-        generateParameterList(method)
-
-        writer.print(": ")
-        val returnType = method.returnType()
-        writeType(returnType)
-
-        if (method.containingClass().isAnnotationType()) {
-            val default = method.defaultValue()
-            if (default.isNotEmpty()) {
-                writer.print(" default ")
-                writer.print(default)
-            }
-        }
-
-        if (ModifierListWriter.requiresMethodBodyInStubs(method)) {
-            writer.print(" = ")
-            writeThrowStub()
-        }
-        writer.println()
-    }
-
-    override fun afterVisitClass(cls: ClassItem) {
-        writer.println("}\n\n")
-    }
-
-    private fun writeThrowStub() {
-        writer.write("error(\"Stub!\")")
-    }
-
-    private fun generateParameterList(method: MethodItem) {
-        writer.print("(")
-        method.parameters().asSequence().forEachIndexed { i, parameter ->
-            if (i > 0) {
-                writer.print(", ")
-            }
-            appendModifiers(parameter)
-            val name = parameter.publicName() ?: parameter.name()
-            writer.print(name)
-            writer.print(": ")
-            writeType(parameter.type())
-        }
-        writer.print(")")
-    }
-
-    private fun generateThrowsList(method: MethodItem) {
-        // Note that throws types are already sorted internally to help comparison matching
-        val throws =
-            if (preFiltered) {
-                method.throwsTypes().asSequence()
-            } else {
-                method.filteredThrowsTypes(filterReference).asSequence()
-            }
-        if (throws.any()) {
-            writer.print("@Throws(")
-            throws.asSequence().sortedWith(ExceptionTypeItem.fullNameComparator).forEachIndexed {
-                i,
-                type ->
-                if (i > 0) {
-                    writer.print(",")
-                }
-                writer.print(type.toTypeString())
-                writer.print("::class")
-            }
-            writer.print(")")
-        }
-    }
-}
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt
new file mode 100644
index 000000000..5350adeb0
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.stub
+
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.PackageList
+import com.android.tools.metalava.model.VisibilityLevel
+import java.util.function.Predicate
+
+class StubConstructorManager(codebase: Codebase) {
+
+    private val packages: PackageList = codebase.getPackages()
+
+    /** Map from [ClassItem] to [StubConstructors]. */
+    private val classToStubConstructors = mutableMapOf<ClassItem, StubConstructors>()
+
+    /**
+     * Contains information about constructors needed when generating stubs for a specific class.
+     */
+    private class StubConstructors(
+        /**
+         * The default constructor to invoke on the class from subclasses.
+         *
+         * Note that in some cases [stubConstructor] may not be in [ClassItem.constructors], e.g.
+         * when we need to create a constructor to match a public parent class with a non-default
+         * constructor and the one in the code is not a match, e.g. is marked `@hide`.
+         *
+         * Is `null` if the class has a default constructor that is accessible.
+         */
+        val stubConstructor: ConstructorItem?,
+
+        /**
+         * The constructor that constructors in a stub class must delegate to in their `super` call.
+         *
+         * Is `null` if the super class has a default constructor.
+         */
+        val superConstructor: ConstructorItem?,
+    ) {
+        companion object {
+            val EMPTY = StubConstructors(null, null)
+        }
+    }
+
+    fun addConstructors(filter: Predicate<Item>) {
+        // Let's say we have
+        //  class GrandParent { public GrandParent(int) {} }
+        //  class Parent {  Parent(int) {} }
+        //  class Child { public Child(int) {} }
+        //
+        // Here Parent's constructor is not public. For normal stub generation we'd end up with
+        // this:
+        //  class GrandParent { public GrandParent(int) {} }
+        //  class Parent { }
+        //  class Child { public Child(int) {} }
+        //
+        // This doesn't compile - Parent can't have a default constructor since there isn't
+        // one for it to invoke on GrandParent.
+        //
+        // we can generate a fake constructor instead, such as
+        //   Parent() { super(0); }
+        //
+        // But it's hard to do this lazily; what if we're generating the Child class first?
+        // Therefore, we'll instead walk over the hierarchy and insert these constructors into the
+        // Item hierarchy such that code generation can find them.
+        //
+        // We also need to handle the throws list, so we can't just unconditionally insert package
+        // private constructors
+
+        // Add constructors to the classes by walking up the super hierarchy and recursively add
+        // constructors; we'll do it recursively to make sure that the superclass has had its
+        // constructors initialized first (such that we can match the parameter lists and throws
+        // signatures), and we use the tag fields to avoid looking at all the internal classes more
+        // than once.
+        packages.allClasses().filter { filter.test(it) }.forEach { addConstructors(it, filter) }
+    }
+
+    /**
+     * Handle computing constructor hierarchy.
+     *
+     * We'll be setting several attributes: [StubConstructors.stubConstructor] : The default
+     * constructor to invoke in this class from subclasses. **NOTE**: This constructor may not be
+     * part of the [ClassItem.constructors] list, e.g. for package private default constructors
+     * we've inserted (because there were no public constructors or constructors not using hidden
+     * parameter types.)
+     *
+     * [StubConstructors.superConstructor] : The super constructor to invoke.
+     */
+    private fun addConstructors(
+        cls: ClassItem,
+        filter: Predicate<Item>,
+    ): StubConstructors {
+
+        // Don't add constructors to interfaces, enums, annotations, etc
+        if (!cls.isClass()) {
+            return StubConstructors.EMPTY
+        }
+
+        // What happens if we have
+        //  package foo:
+        //     public class A { public A(int) }
+        //  package bar
+        //     public class B extends A { public B(int) }
+        // If we just try inserting package private constructors here things will NOT work:
+        //  package foo:
+        //     public class A { public A(int); A() {} }
+        //  package bar
+        //     public class B extends A { public B(int); B() }
+        // because A <() is not accessible from B() -- it's outside the same package.
+        //
+        // So, we'll need to model the real constructors for all the scenarios where that works.
+        //
+        // The remaining challenge is that there will be some gaps: when we don't have a default
+        // constructor, subclass constructors will have to have an explicit super(args) call to pick
+        // the parent constructor to use. And which one? It generally doesn't matter; just pick one,
+        // but unfortunately, the super constructor can throw exceptions, and in that case the
+        // subclass constructor must also throw all those exceptions (you can't surround a super
+        // call with try/catch.)
+        //
+        // Luckily, this does not seem to be an actual problem with any of the source code that
+        // metalava currently processes. If it did become a problem then the solution would be to
+        // pick super constructors with a compatible set of throws.
+
+        // If this class has already been visited then return the StubConstructors that was created.
+        classToStubConstructors[cls]?.let {
+            return it
+        }
+
+        // Remember that we have visited this class so that it is not visited again. This does not
+        // strictly need to be done before visiting the super classes as there should not be cycles
+        // in the class hierarchy. However, if due to some invalid input there is then doing this
+        // here will prevent those cycles from causing a stack overflow. This will be overridden
+        // with the actual constructors below.
+        classToStubConstructors[cls] = StubConstructors.EMPTY
+
+        // First handle its super class hierarchy to make sure that we've already constructed super
+        // classes.
+        val superClass = cls.filteredSuperclass(filter)
+        val superClassConstructors = superClass?.let { addConstructors(it, filter) }
+
+        val superDefaultConstructor = superClassConstructors?.stubConstructor
+
+        // Find default constructor, if one doesn't exist
+        val filteredConstructors = cls.filteredConstructors(filter).toList()
+        val stubConstructor =
+            if (filteredConstructors.isNotEmpty()) {
+                // Try to pick the constructor, select first by fewest throwables,
+                // then fewest parameters, then based on order in listFilter.test(cls)
+                filteredConstructors.reduce { first, second -> pickBest(first, second) }
+            } else if (
+                cls.constructors().isNotEmpty() ||
+                    // For text based codebase, stub constructor needs to be generated even if
+                    // cls.constructors() is empty, so that public default constructor is not
+                    // created.
+                    cls.codebase.preFiltered
+            ) {
+
+                // No accessible constructors are available so a package private constructor is
+                // created. Technically, the stub now has a constructor that isn't available at
+                // runtime, but apps creating subclasses inside the android.* package is not
+                // supported.
+                cls.createDefaultConstructor(VisibilityLevel.PACKAGE_PRIVATE)
+            } else {
+                null
+            }
+
+        if (stubConstructor == null && superDefaultConstructor == null) {
+            return StubConstructors.EMPTY
+        }
+
+        return StubConstructors(
+                stubConstructor = stubConstructor,
+                superConstructor = superDefaultConstructor,
+            )
+            .also {
+                // Save it away for retrieval by subclasses.
+                classToStubConstructors[cls] = it
+            }
+    }
+
+    private fun pickBest(current: ConstructorItem, next: ConstructorItem): ConstructorItem {
+        val currentThrowsCount = current.throwsTypes().size
+        val nextThrowsCount = next.throwsTypes().size
+
+        return if (currentThrowsCount < nextThrowsCount) {
+            current
+        } else if (currentThrowsCount > nextThrowsCount) {
+            next
+        } else {
+            val currentParameterCount = current.parameters().size
+            val nextParameterCount = next.parameters().size
+            if (currentParameterCount <= nextParameterCount) {
+                current
+            } else next
+        }
+    }
+
+    /**
+     * Get the optional synthetic constructor, if created, for [classItem].
+     *
+     * If a [ClassItem] does not have an accessible constructor then one will be synthesized for use
+     * by subclasses. This method returns that constructor, or `null` if there was no synthetic
+     * constructor.
+     */
+    fun optionalSyntheticConstructor(classItem: ClassItem): ConstructorItem? {
+        val stubConstructor = classToStubConstructors[classItem]?.stubConstructor ?: return null
+        if (stubConstructor in classItem.constructors()) return null
+        return stubConstructor
+    }
+
+    /** Get the optional super constructor, if needed, for [classItem]. */
+    fun optionalSuperConstructor(classItem: ClassItem): ConstructorItem? {
+        return classToStubConstructors[classItem]?.superConstructor
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
index c2f949d03..275933ba1 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
@@ -19,17 +19,22 @@ package com.android.tools.metalava.stub
 import com.android.tools.metalava.ApiPredicate
 import com.android.tools.metalava.FilterPredicate
 import com.android.tools.metalava.actualItem
-import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.ItemVisitor
 import com.android.tools.metalava.model.Language
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.item.ResourceFile
 import com.android.tools.metalava.model.psi.trimDocIndent
+import com.android.tools.metalava.model.removeDeprecatedSection
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.BufferedWriter
@@ -38,28 +43,22 @@ import java.io.FileWriter
 import java.io.IOException
 import java.io.PrintWriter
 import java.io.Writer
-import java.util.regex.Pattern
 
 internal class StubWriter(
     private val stubsDir: File,
     private val generateAnnotations: Boolean = false,
-    private val preFiltered: Boolean = true,
     private val docStubs: Boolean,
     private val reporter: Reporter,
     private val config: StubWriterConfig,
-) :
-    ApiVisitor(
-        visitConstructorsAsMethods = false,
-        nestInnerClasses = true,
-        inlineInheritedFields = true,
-        // Methods are by default sorted in source order in stubs, to encourage methods
-        // that are near each other in the source to show up near each other in the documentation
-        methodComparator = MethodItem.sourceOrderComparator,
-        filterEmit = FilterPredicate(apiPredicate(docStubs, config)),
-        filterReference = apiPredicate(docStubs, config),
-        includeEmptyOuterClasses = true,
-        config = config.apiVisitorConfig,
-    ) {
+    private val stubConstructorManager: StubConstructorManager,
+) : DelegatedVisitor {
+
+    /**
+     * Stubs need to preserve class nesting when visiting otherwise nested classes will not be
+     * nested inside their containing class properly.
+     */
+    override val requiresClassNesting: Boolean
+        get() = true
 
     override fun visitPackage(pkg: PackageItem) {
         getPackageDir(pkg, create = true)
@@ -71,7 +70,8 @@ internal class StubWriter(
         }
     }
 
-    fun writeDocOverview(pkg: PackageItem, content: String) {
+    fun writeDocOverview(pkg: PackageItem, resourceFile: ResourceFile) {
+        val content = resourceFile.content
         if (content.isBlank()) {
             return
         }
@@ -185,7 +185,7 @@ internal class StubWriter(
     /** The writer to write the stubs file to */
     private var textWriter: PrintWriter = errorTextWriter
 
-    private var stubWriter: BaseItemVisitor? = null
+    private var stubWriter: DelegatedVisitor? = null
 
     override fun visitClass(cls: ClassItem) {
         if (cls.isTopLevelClass()) {
@@ -211,28 +211,31 @@ internal class StubWriter(
 
             stubWriter =
                 if (kotlin) {
-                    KotlinStubWriter(
-                        textWriter,
-                        modifierListWriter,
-                        filterReference,
-                        preFiltered,
-                        config,
-                    )
+                    error("Generating Kotlin stubs is not supported")
                 } else {
-                    JavaStubWriter(
-                        textWriter,
-                        modifierListWriter,
-                        filterEmit,
-                        filterReference,
-                        preFiltered,
-                        config,
-                    )
+                    JavaStubWriter(textWriter, modifierListWriter, config, stubConstructorManager)
                 }
 
             // Copyright statements from the original file?
             cls.getSourceFile()?.getHeaderComments()?.let { textWriter.println(it) }
         }
         stubWriter?.visitClass(cls)
+
+        dispatchStubsConstructorIfAvailable(cls)
+    }
+
+    /**
+     * Stubs that have no accessible constructor may still need to generate one and that constructor
+     * is available from [StubConstructorManager.optionalSyntheticConstructor].
+     */
+    private fun dispatchStubsConstructorIfAvailable(cls: ClassItem) {
+        // If a special constructor had to be synthesized for the class then it will not be in the
+        // ClassItem's list of constructors that would be visited automatically. So, this will visit
+        // it explicitly to make sure it appears in the stubs.
+        val syntheticConstructor = stubConstructorManager.optionalSyntheticConstructor(cls)
+        if (syntheticConstructor != null) {
+            visitConstructor(syntheticConstructor)
+        }
     }
 
     override fun afterVisitClass(cls: ClassItem) {
@@ -250,38 +253,53 @@ internal class StubWriter(
         stubWriter?.visitConstructor(constructor)
     }
 
-    override fun afterVisitConstructor(constructor: ConstructorItem) {
-        stubWriter?.afterVisitConstructor(constructor)
-    }
-
     override fun visitMethod(method: MethodItem) {
         stubWriter?.visitMethod(method)
     }
 
-    override fun afterVisitMethod(method: MethodItem) {
-        stubWriter?.afterVisitMethod(method)
-    }
-
     override fun visitField(field: FieldItem) {
         stubWriter?.visitField(field)
     }
-
-    override fun afterVisitField(field: FieldItem) {
-        stubWriter?.afterVisitField(field)
-    }
 }
 
-private fun apiPredicate(docStubs: Boolean, config: StubWriterConfig) =
-    ApiPredicate(
-        includeDocOnly = docStubs,
-        config = config.apiVisitorConfig.apiPredicateConfig.copy(ignoreShown = true),
+/**
+ * Create an [ApiVisitor] that will filter the [Item] to which is applied according to the supplied
+ * parameters and in a manner appropriate for writing stubs, e.g. nesting classes. It will delegate
+ * any visitor calls that pass through its filter to this [StubWriter] instance.
+ */
+fun createFilteringVisitorForStubs(
+    delegate: DelegatedVisitor,
+    docStubs: Boolean,
+    preFiltered: Boolean,
+    apiVisitorConfig: ApiVisitor.Config,
+): ItemVisitor {
+    val filterReference =
+        ApiPredicate(
+            includeDocOnly = docStubs,
+            config = apiVisitorConfig.apiPredicateConfig.copy(ignoreShown = true),
+        )
+    val filterEmit = FilterPredicate(filterReference)
+    return FilteringApiVisitor(
+        delegate = delegate,
+        inlineInheritedFields = true,
+        // Sort methods in stubs based on their signature. The order of methods in stubs is
+        // irrelevant, e.g. it does not affect compilation or document generation. However, having a
+        // consistent order will prevent churn in the generated stubs caused by changes to Metalava
+        // itself or changes to the order of methods in the sources.
+        callableComparator = CallableItem.comparator,
+        filterEmit = filterEmit,
+        filterReference = filterReference,
+        preFiltered = preFiltered,
+        config = apiVisitorConfig,
     )
+}
 
 internal fun appendDocumentation(item: Item, writer: PrintWriter, config: StubWriterConfig) {
     if (config.includeDocumentationInStubs) {
-        val documentation = item.fullyQualifiedDocumentation()
-        if (documentation.isNotBlank()) {
-            val trimmed = trimDocIndent(documentation)
+        val documentation = item.documentation
+        val text = documentation.fullyQualifiedDocumentation()
+        if (text.isNotBlank()) {
+            val trimmed = trimDocIndent(text)
             val output = revertDocumentationDeprecationChange(item, trimmed)
             writer.println(output)
             writer.println()
@@ -289,33 +307,6 @@ internal fun appendDocumentation(item: Item, writer: PrintWriter, config: StubWr
     }
 }
 
-/** Regular expression to match the start of a doc comment. */
-private const val DOC_COMMENT_START_RE = """\Q/**\E"""
-/**
- * Regular expression to match the end of a block comment. If the block comment is at the start of a
- * line, preceded by some white space then it includes all that white space.
- */
-private const val BLOCK_COMMENT_END_RE = """(?m:^\s*)?\Q*/\E"""
-
-/**
- * Regular expression to match the start of a line Javadoc tag, i.e. a Javadoc tag at the beginning
- * of a line. Optionally, includes the preceding white space and a `*` forming a left hand border.
- */
-private const val START_OF_LINE_TAG_RE = """(?m:^\s*)\Q*\E\s*@"""
-
-/**
- * A [Pattern[] for matching an `@deprecated` tag and its associated text. If the tag is at the
- * start of the line then it includes everything from the start of the line. It includes everything
- * up to the end of the comment (apart from the line for the end of the comment) or the start of the
- * next line tag.
- */
-private val deprecatedTagPattern =
-    """((?m:^\s*\*\s*)?@deprecated\b(?m:\s*.*?))($START_OF_LINE_TAG_RE|$BLOCK_COMMENT_END_RE)"""
-        .toPattern(Pattern.DOTALL)
-
-/** A [Pattern] that matches a blank, i.e. white space only, doc comment. */
-private val blankDocCommentPattern = """$DOC_COMMENT_START_RE\s*$BLOCK_COMMENT_END_RE""".toPattern()
-
 /**
  * Revert the documentation change that accompanied a deprecation change.
  *
@@ -339,26 +330,5 @@ fun revertDocumentationDeprecationChange(currentItem: Item, docs: String): Strin
     )
         return docs
 
-    // Find the `@deprecated` tag.
-    val deprecatedTagMatcher = deprecatedTagPattern.matcher(docs)
-    if (!deprecatedTagMatcher.find()) {
-        // Nothing to do as the documentation does not include @deprecated.
-        return docs
-    }
-
-    // Remove the @deprecated tag and associated text.
-    val withoutDeprecated =
-        // The part before the `@deprecated` tag.
-        docs.substring(0, deprecatedTagMatcher.start(1)) +
-            // The part after the `@deprecated` tag.
-            docs.substring(deprecatedTagMatcher.end(1))
-
-    // Check to see if the resulting document comment is empty and if it is then discard it all
-    // together.
-    val emptyDocCommentMatcher = blankDocCommentPattern.matcher(withoutDeprecated)
-    return if (emptyDocCommentMatcher.matches()) {
-        ""
-    } else {
-        withoutDeprecated
-    }
+    return removeDeprecatedSection(docs)
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt
index 8f41c6ae0..1b1f5aea6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriterConfig.kt
@@ -16,15 +16,11 @@
 
 package com.android.tools.metalava.stub
 
-import com.android.tools.metalava.model.visitors.ApiVisitor
-
 /**
  * Contains configuration for [StubWriter] that can, or at least could, come from command line
  * options.
  */
 internal data class StubWriterConfig(
-    val apiVisitorConfig: ApiVisitor.Config = ApiVisitor.Config(),
-
     /**
      * If true then generate kotlin stubs if the source is kotlin, otherwise generate java stubs.
      */
diff --git a/metalava/src/main/resources/schemas/config.xsd b/metalava/src/main/resources/schemas/config.xsd
new file mode 100644
index 000000000..ae1bd4ba6
--- /dev/null
+++ b/metalava/src/main/resources/schemas/config.xsd
@@ -0,0 +1,20 @@
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<!-- Schema for a configuration file supplied to Metalava with the `config-file` option. -->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.google.com/tools/metalava/config">
+    <xs:element name="config"/>
+</xs:schema>
diff --git a/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt b/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt
index 8a3ae8ffb..ff1d791c8 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.ARG_WARNING
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
+import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -75,7 +76,8 @@ class AndroidApiChecksTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/pkg/PermissionTest.java:14: error: Method 'test0' documentation mentions permissions without declaring @RequiresPermission [RequiresPermission]
-                src/android/pkg/PermissionTest.java:21: error: Method 'test1' documentation mentions permissions already declared by @RequiresPermission [RequiresPermission]
+                src/android/pkg/PermissionTest.java:21: error: Method 'test1' documentation duplicates auto-generated documentation by @RequiresPermission. If the permissions are only required under certain circumstances use conditional=true to suppress the auto-documentation [RequiresPermission]
+                src/android/pkg/PermissionTest.java:41: warning: Method 'conditionalBad' documentation does not explain when the conditional permission 'ACCESS_COARSE_LOCATION' is required. [ConditionalRequiresPermissionNotExplained]
                 """,
             sourceFiles =
                 arrayOf(
@@ -109,6 +111,20 @@ class AndroidApiChecksTest : DriverTest() {
                         @RequiresPermission(allOf = Manifest.permission.ACCESS_COARSE_LOCATION)
                         public void test2() {
                         }
+
+                        /**
+                         * Sometimes requires {@link Manifest.permission#ACCESS_COARSE_LOCATION}.
+                         */
+                        @RequiresPermission(allOf = Manifest.permission.ACCESS_COARSE_LOCATION, conditional = true)
+                        public void conditionalOk() {
+                        }
+
+                        /**
+                         * Not documenting the conditional permission.
+                         */
+                        @RequiresPermission(allOf = Manifest.permission.ACCESS_COARSE_LOCATION, conditional = true)
+                        public void conditionalBad() {
+                        }
                     }
                     """
                     ),
@@ -126,7 +142,58 @@ class AndroidApiChecksTest : DriverTest() {
                     """
                     ),
                     requiresPermissionSource
-                )
+                ),
+            extraArguments =
+                arrayOf(ARG_WARNING, Issues.CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED.name),
+        )
+    }
+
+    @Test
+    fun `Document Permissions ignore when permission is subset of a word`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android;
+
+                            public abstract class Manifest {
+                                public static final class permission {
+                                    public static final String PERMISSION = "android.permission.PERMISSION";
+                                }
+                            }
+                        """
+                    ),
+                    requiresPermissionSource,
+                    java(
+                        """
+                            package android.pkg;
+
+                            import android.Manifest;
+                            import android.annotation.RequiresPermission;
+
+                            public class PermissionTest {
+                                /**
+                                 * While this contains the name of the permission it is not actually
+                                 * referring to the permission ARG_PERMISSION.
+                                 */
+                                @RequiresPermission(Manifest.permission.PERMISSION)
+                                public void test0() {
+                                }
+
+                                /**
+                                 * While this contains the name of the permission it is not actually
+                                 * referring to the permission PERMISSION_ARG.
+                                 */
+                                @RequiresPermission(Manifest.permission.PERMISSION)
+                                public void test0() {
+                                }
+                            }
+                        """
+                    ),
+                ),
+            extraArguments =
+                arrayOf(ARG_WARNING, Issues.CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED.name),
         )
     }
 
@@ -136,9 +203,9 @@ class AndroidApiChecksTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/android/pkg/IntentActionTest.java:30: error: Field 'BAR_FOO_ERROR_ACTION' is missing @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION) [SdkConstant]
                 src/android/pkg/IntentActionTest.java:19: error: Field 'FOO_BAR_ERROR_ACTION' is missing @BroadcastBehavior [BroadcastBehavior]
                 src/android/pkg/IntentActionTest.java:19: error: Field 'FOO_BAR_ERROR_ACTION' is missing @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) [SdkConstant]
+                src/android/pkg/IntentActionTest.java:30: error: Field 'BAR_FOO_ERROR_ACTION' is missing @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION) [SdkConstant]
                 """,
             sourceFiles =
                 arrayOf(
@@ -188,9 +255,9 @@ class AndroidApiChecksTest : DriverTest() {
         check(
             expectedIssues =
                 """
+                src/android/pkg/NullMentions.java:9: warning: Field 'field2' documentation mentions 'null' without declaring @NonNull or @Nullable [Nullable]
                 src/android/pkg/NullMentions.java:18: warning: Parameter 'param1' of 'method3' documentation mentions 'null' without declaring @NonNull or @Nullable [Nullable]
                 src/android/pkg/NullMentions.java:21: warning: Return value of 'method4' documentation mentions 'null' without declaring @NonNull or @Nullable [Nullable]
-                src/android/pkg/NullMentions.java:9: warning: Field 'field2' documentation mentions 'null' without declaring @NonNull or @Nullable [Nullable]
                 """,
             extraArguments = arrayOf(ARG_WARNING, "Nullable"), // Hidden by default
             sourceFiles =
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt
new file mode 100644
index 000000000..9bc6558e6
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationRetentionTest.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import org.junit.Test
+
+class AnnotationRetentionTest : DriverTest() {
+
+    @RequiresCapabilities(Capability.JAVA)
+    @Test
+    fun `Annotation retention - java`() {
+        // For annotations where the java.lang.annotation classes themselves are not
+        // part of the source tree, ensure that we compute the right retention (runtime, meaning
+        // it should show up in the stubs file.).
+        check(
+            format = FileFormat.V3,
+            extraArguments = arrayOf(ARG_EXCLUDE_ALL_ANNOTATIONS),
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public @interface Foo {
+                                String value();
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package android.annotation;
+                            import static java.lang.annotation.ElementType.*;
+                            import java.lang.annotation.*;
+                            @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
+                            @Retention(RetentionPolicy.CLASS)
+                            @SuppressWarnings("ALL")
+                            public @interface SuppressLint {
+                                String[] value();
+                            }
+                        """
+                    ),
+                ),
+            api =
+                """
+                    // Signature format: 3.0
+                    package android.annotation {
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.LOCAL_VARIABLE}) public @interface SuppressLint {
+                        method public abstract String[] value();
+                      }
+                    }
+                    package test.pkg {
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Foo {
+                        method public abstract String value();
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    // For annotations where the java.lang.annotation classes themselves are not
+                    // part of the source tree, ensure that we compute the right retention (runtime,
+                    // meaning it should show up in the stubs file.).
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)
+                            public @interface Foo {
+                            public java.lang.String value();
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package android.annotation;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)
+                            @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.LOCAL_VARIABLE})
+                            public @interface SuppressLint {
+                            public java.lang.String[] value();
+                            }
+                        """
+                    )
+                )
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Annotation retention - kotlin`() {
+        // For annotations where the java.lang.annotation classes themselves are not
+        // part of the source tree, ensure that we compute the right retention (runtime, meaning
+        // it should show up in the stubs file.).
+        check(
+            format = FileFormat.V3,
+            extraArguments = arrayOf(ARG_EXCLUDE_ALL_ANNOTATIONS),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+
+                            @DslMarker
+                            annotation class ImplicitRuntimeRetention
+
+                            @Retention(AnnotationRetention.RUNTIME)
+                            annotation class ExplicitRuntimeRetention
+                        """
+                    )
+                ),
+            api =
+                """
+                    // Signature format: 3.0
+                    package test.pkg {
+                      @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) public @interface ExplicitRuntimeRetention {
+                      }
+                      @kotlin.DslMarker public @interface ImplicitRuntimeRetention {
+                      }
+                    }
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
index ebfcca10a..b70b6d75d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
@@ -19,6 +19,8 @@ package com.android.tools.metalava
 import com.android.tools.metalava.cli.common.ARG_WARNING
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.testing.KnownSourceFiles.androidxAnnotationHide
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -29,6 +31,108 @@ class AnnotationsMergerTest : DriverTest() {
     //   - annotation specified with different parameters (e.g @Size(4) vs @Size(6))
     // Test with jar file
 
+    @Test
+    fun `Merge conflicting nullability when merging from sources`() {
+        check(
+            format = FileFormat.V2,
+            sourceFiles =
+                arrayOf(
+                    androidxAnnotationHide,
+                    androidxNullableSource,
+                    androidxNonNullSource,
+                    java(
+                        """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public class MyTest {
+                                private MyTest() {}
+                                public @NonNull Number nonNull;
+                                public @Nullable Number nullable;
+                            }
+                        """
+                    )
+                ),
+            mergeJavaStubAnnotations =
+                """
+                    package test.pkg;
+                    import androidx.annotation.Nullable;
+                    import androidx.annotation.NonNull;
+                    public class MyTest {
+                        private MyTest() {}
+                        public @Nullable Number nonNull;
+                        public @NonNull Number nullable;
+                    }
+                """,
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class MyTest {
+                        field @NonNull public Number nonNull;
+                        field @Nullable public Number nullable;
+                      }
+                    }
+                """,
+            expectedIssues =
+                """
+                    src/test/pkg/MyTest.java:6: warning: Merge conflict, has @NonNull (or equivalent) attempting to merge @Nullable (or equivalent) (ErrorWhenNew) [InconsistentMergeAnnotation]
+                    src/test/pkg/MyTest.java:7: warning: Merge conflict, has @Nullable (or equivalent) attempting to merge @NonNull (or equivalent) (ErrorWhenNew) [InconsistentMergeAnnotation]
+                """,
+        )
+    }
+
+    @Test
+    fun `Merge conflicting nullability when merging from XML`() {
+        check(
+            format = FileFormat.V2,
+            sourceFiles =
+                arrayOf(
+                    androidxAnnotationHide,
+                    androidxNullableSource,
+                    androidxNonNullSource,
+                    java(
+                        """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public class MyTest {
+                                private MyTest() {}
+                                public @NonNull Number nonNull;
+                                public @Nullable Number nullable;
+                            }
+                        """
+                    )
+                ),
+            mergeXmlAnnotations =
+                """<?xml version="1.0" encoding="UTF-8"?>
+                    <root>
+                      <item name="test.pkg.MyTest nonNull">
+                        <annotation name="androidx.annotation.Nullable" />
+                      </item>
+                      <item name="test.pkg.MyTest nullable">
+                        <annotation name="androidx.annotation.NonNull" />
+                      </item>
+                    </root>
+                """,
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class MyTest {
+                        field @NonNull public Number nonNull;
+                        field @Nullable public Number nullable;
+                      }
+                    }
+                """,
+            expectedIssues =
+                """
+                    src/test/pkg/MyTest.java:6: warning: Merge conflict, has @NonNull (or equivalent) attempting to merge @Nullable (or equivalent) (ErrorWhenNew) [InconsistentMergeAnnotation]
+                    src/test/pkg/MyTest.java:7: warning: Merge conflict, has @Nullable (or equivalent) attempting to merge @NonNull (or equivalent) (ErrorWhenNew) [InconsistentMergeAnnotation]
+                """,
+        )
+    }
+
     @Test
     fun `Signature files contain annotations`() {
         check(
@@ -55,15 +159,11 @@ class AnnotationsMergerTest : DriverTest() {
                     uiThreadSource,
                     intRangeAnnotationSource,
                     androidxNonNullSource,
-                    androidxNullableSource
-                ),
-            // Skip the annotations themselves from the output
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
+                    androidxNullableSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -204,7 +304,9 @@ class AnnotationsMergerTest : DriverTest() {
                     """
                     ),
                     libcoreNonNullSource,
-                    libcoreNullableSource
+                    libcoreNullableSource,
+                    // Hide libcore.util classes.
+                    KnownSourceFiles.libcodeUtilHide,
                 ),
             mergeJavaStubAnnotations =
                 """
@@ -229,8 +331,6 @@ class AnnotationsMergerTest : DriverTest() {
                 """,
             extraArguments =
                 arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "libcore.util",
                     ARG_WARNING,
                     Issues.UNMATCHED_MERGE_ANNOTATION.name,
                 ),
@@ -313,7 +413,6 @@ class AnnotationsMergerTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "libcore.util")
         )
     }
 
@@ -335,7 +434,9 @@ class AnnotationsMergerTest : DriverTest() {
                 """
                     ),
                     libcoreNonNullSource,
-                    libcoreNullableSource
+                    libcoreNullableSource,
+                    // Hide libcore.util classes.
+                    KnownSourceFiles.libcodeUtilHide,
                 ),
             mergeJavaStubAnnotations =
                 """
@@ -353,7 +454,6 @@ class AnnotationsMergerTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "libcore.util")
         )
     }
 
@@ -380,7 +480,9 @@ class AnnotationsMergerTest : DriverTest() {
                     """
                     ),
                     libcoreNonNullSource,
-                    libcoreNullableSource
+                    libcoreNullableSource,
+                    // Hide libcore.util classes.
+                    KnownSourceFiles.libcodeUtilHide,
                 ),
             mergeJavaStubAnnotations =
                 """
@@ -390,7 +492,7 @@ class AnnotationsMergerTest : DriverTest() {
                 import libcore.util.Nullable;
 
                 public class PublicClass {
-                    @NonNull public @NonNull String publicMethod(@Nullable Object object) {return "";}
+                    @NonNull public String publicMethod(@Nullable Object object) {return "";}
                 }
                 """,
             api =
@@ -402,7 +504,6 @@ class AnnotationsMergerTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "libcore.util")
         )
     }
 
@@ -412,7 +513,7 @@ class AnnotationsMergerTest : DriverTest() {
             format = FileFormat.V2,
             expectedIssues =
                 """
-                    inclusion/src/test/pkg/Example.java:13: warning: inclusion annotations were given for method test.pkg.HiddenExample.notPresentWithAnnotations() but no matching item was found [UnmatchedMergeAnnotation]
+                    inclusion1/src/test/pkg/HiddenExample.java:7: warning: inclusion annotations were given for method test.pkg.HiddenExample.notPresentWithAnnotations() but no matching item was found [UnmatchedMergeAnnotation]
                 """,
             sourceFiles =
                 arrayOf(
@@ -453,6 +554,11 @@ class AnnotationsMergerTest : DriverTest() {
                                 @test.annotation.Hide void bHidden();
                                 @test.annotation.Hide @test.annotation.Show void cShown();
                             }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
 
                             @test.annotation.Hide
                             public interface HiddenExample {
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
index 44cc4973a..e0a5d9a26 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
@@ -32,70 +32,70 @@ class ApiAnalyzerTest : DriverTest() {
             showAnnotations = arrayOf("android.annotation.SystemApi"),
             expectedIssues =
                 """
-                src/test/pkg/SystemApiClass.java:7: error: badAbstractHiddenMethod cannot be hidden and abstract when SystemApiClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
-                src/test/pkg/PublicClass.java:5: error: badAbstractHiddenMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
-                src/test/pkg/PublicClass.java:6: error: badPackagePrivateMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
-            """,
+                    src/test/pkg/PublicClass.java:5: error: badAbstractHiddenMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
+                    src/test/pkg/PublicClass.java:6: error: badPackagePrivateMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
+                    src/test/pkg/SystemApiClass.java:7: error: badAbstractHiddenMethod cannot be hidden and abstract when SystemApiClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
+                """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import android.annotation.SystemApi;
-                    public abstract class PublicClass {
-                        /** @hide */
-                        public abstract boolean badAbstractHiddenMethod() { return true; }
-                        abstract void badPackagePrivateMethod() { }
-                        /**
-                         * This method does not fail because it is visible due to showAnnotations,
-                         * instead it will fail when running analysis on public API. See test below.
-                         * @hide
-                         */
-                        @SystemApi
-                        public abstract boolean goodAbstractSystemHiddenMethod() { return true; }
-                    }
-                """
+                            package test.pkg;
+                            import android.annotation.SystemApi;
+                            public abstract class PublicClass {
+                                /** @hide */
+                                public abstract boolean badAbstractHiddenMethod() { return true; }
+                                abstract void badPackagePrivateMethod() { }
+                                /**
+                                 * This method does not fail because it is visible due to showAnnotations,
+                                 * instead it will fail when running analysis on public API. See test below.
+                                 * @hide
+                                 */
+                                @SystemApi
+                                public abstract boolean goodAbstractSystemHiddenMethod() { return true; }
+                            }
+                        """
                     ),
                     java(
                         """
-                    package test.pkg;
-                    import android.annotation.SystemApi;
-                    public abstract class PublicClassWithHiddenConstructor {
-                        private PublicClassWithHiddenConstructor() { }
-                        /** @hide */
-                        public abstract boolean goodAbstractHiddenMethod() { return true; }
-                    }
-                """
+                            package test.pkg;
+                            import android.annotation.SystemApi;
+                            public abstract class PublicClassWithHiddenConstructor {
+                                private PublicClassWithHiddenConstructor() { }
+                                /** @hide */
+                                public abstract boolean goodAbstractHiddenMethod() { return true; }
+                            }
+                        """
                     ),
                     java(
                         """
-                   package test.pkg;
-                   import android.annotation.SystemApi;
-                   /** @hide */
-                   @SystemApi
-                   public abstract class SystemApiClass {
-                        /** @hide */
-                        public abstract boolean badAbstractHiddenMethod() { return true; }
-                        /**
-                         * This method is OK, because it matches visibility of the class
-                         * @hide
-                         */
-                        @SystemApi
-                        public abstract boolean goodAbstractSystemHiddenMethod() { return true; }
-                        public abstract boolean goodAbstractPublicMethod() { return true; }
-                   }
-               """
+                           package test.pkg;
+                           import android.annotation.SystemApi;
+                           /** @hide */
+                           @SystemApi
+                           public abstract class SystemApiClass {
+                                /** @hide */
+                                public abstract boolean badAbstractHiddenMethod() { return true; }
+                                /**
+                                 * This method is OK, because it matches visibility of the class
+                                 * @hide
+                                 */
+                                @SystemApi
+                                public abstract boolean goodAbstractSystemHiddenMethod() { return true; }
+                                public abstract boolean goodAbstractPublicMethod() { return true; }
+                           }
+                       """
                     ),
                     java(
                         """
-                    package test.pkg;
-                    import android.annotation.SystemApi;
-                    /** This class is OK because it is all hidden @hide */
-                    public abstract class HiddenClass {
-                        public abstract boolean goodAbstractHiddenMethod() { return true; }
-                    }
-                """
+                            package test.pkg;
+                            import android.annotation.SystemApi;
+                            /** This class is OK because it is all hidden @hide */
+                            public abstract class HiddenClass {
+                                public abstract boolean goodAbstractHiddenMethod() { return true; }
+                            }
+                        """
                     ),
                     systemApiSource
                 )
@@ -107,26 +107,26 @@ class ApiAnalyzerTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/PublicClass.java:5: error: badAbstractHiddenMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
-                src/test/pkg/PublicClass.java:6: error: badPackagePrivateMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
-                src/test/pkg/PublicClass.java:9: error: badAbstractSystemHiddenMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
-            """,
+                    src/test/pkg/PublicClass.java:5: error: badAbstractHiddenMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
+                    src/test/pkg/PublicClass.java:6: error: badPackagePrivateMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
+                    src/test/pkg/PublicClass.java:9: error: badAbstractSystemHiddenMethod cannot be hidden and abstract when PublicClass has a visible constructor, in case a third-party attempts to subclass it. [HiddenAbstractMethod]
+                """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import android.annotation.SystemApi;
-                    public abstract class PublicClass {
-                        /** @hide */
-                        public abstract boolean badAbstractHiddenMethod() { return true; }
-                        abstract void badPackagePrivateMethod() { }
-                        /** @hide */
-                        @SystemApi
-                        public abstract boolean badAbstractSystemHiddenMethod() { return true; }
-                    }
-                """
+                            package test.pkg;
+                            import android.annotation.SystemApi;
+                            public abstract class PublicClass {
+                                /** @hide */
+                                public abstract boolean badAbstractHiddenMethod() { return true; }
+                                abstract void badPackagePrivateMethod() { }
+                                /** @hide */
+                                @SystemApi
+                                public abstract boolean badAbstractSystemHiddenMethod() { return true; }
+                            }
+                        """
                     ),
                     systemApiSource
                 )
@@ -138,10 +138,10 @@ class ApiAnalyzerTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:20: error: Method test.pkg.MyClass.inheritedNoCommentInParent(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match [DeprecationMismatch]
-                src/test/pkg/MyClass.java:23: error: Method test.pkg.MyClass.notInheritedNoComment(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match [DeprecationMismatch]
-                src/test/pkg/MyInterface.java:17: error: Method test.pkg.MyInterface.inheritedNoCommentInParent(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match [DeprecationMismatch]
-            """,
+                    src/test/pkg/MyClass.java:20: error: Method test.pkg.MyClass.inheritedNoCommentInParent(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match [DeprecationMismatch]
+                    src/test/pkg/MyClass.java:23: error: Method test.pkg.MyClass.notInheritedNoComment(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match [DeprecationMismatch]
+                    src/test/pkg/MyInterface.java:17: error: Method test.pkg.MyInterface.inheritedNoCommentInParent(): @Deprecated annotation (present) and @deprecated doc tag (not present) do not match [DeprecationMismatch]
+                """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
                 arrayOf(
@@ -204,47 +204,43 @@ class ApiAnalyzerTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.java:3: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden1 [ReferencesHidden]
-                src/test/pkg/Foo.java:4: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden2 [ReferencesHidden]
-                src/test/pkg/Foo.java:5: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden3 [ReferencesHidden]
-                src/test/pkg/Foo.java:6: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden4 [ReferencesHidden]
-                src/test/pkg/Foo.java:3: warning: Field Foo.fieldReferencesHidden1 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
-                src/test/pkg/Foo.java:4: warning: Field Foo.fieldReferencesHidden2 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
-                src/test/pkg/Foo.java:5: warning: Field Foo.fieldReferencesHidden3 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
-                src/test/pkg/Foo.java:6: warning: Field Foo.fieldReferencesHidden4 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
-            """
-                    .trimIndent(),
+                    src/test/pkg/Foo.java:3: warning: Field Foo.fieldReferencesHidden1 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
+                    src/test/pkg/Foo.java:3: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden1 [ReferencesHidden]
+                    src/test/pkg/Foo.java:4: warning: Field Foo.fieldReferencesHidden2 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
+                    src/test/pkg/Foo.java:4: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden2 [ReferencesHidden]
+                    src/test/pkg/Foo.java:5: warning: Field Foo.fieldReferencesHidden3 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
+                    src/test/pkg/Foo.java:5: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden3 [ReferencesHidden]
+                    src/test/pkg/Foo.java:6: warning: Field Foo.fieldReferencesHidden4 references hidden type test.pkg.Hidden. [HiddenTypeParameter]
+                    src/test/pkg/Foo.java:6: error: Class test.pkg.Hidden is hidden but was referenced (in field type) from public field test.pkg.Foo.fieldReferencesHidden4 [ReferencesHidden]
+                """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
                 arrayOf(
                     java(
                         """
-                        package test.pkg;
-                        /** @hide */
-                        public class Hidden {}
-                    """
-                            .trimIndent()
+                            package test.pkg;
+                            /** @hide */
+                            public class Hidden {}
+                        """
                     ),
                     java(
                         """
-                        package test.pkg;
-                        public class Outer<P1> {
-                            public class Inner<P2> {}
-                        }
-                    """
-                            .trimIndent()
+                            package test.pkg;
+                            public class Outer<P1> {
+                                public class Inner<P2> {}
+                            }
+                        """
                     ),
                     java(
                         """
-                        package test.pkg;
-                        public class Foo {
-                            public Hidden fieldReferencesHidden1;
-                            public Outer<Hidden> fieldReferencesHidden2;
-                            public Outer<Foo>.Inner<Hidden> fieldReferencesHidden3;
-                            public Outer<Hidden>.Inner<Foo> fieldReferencesHidden4;
-                        }
-                    """
-                            .trimIndent()
+                            package test.pkg;
+                            public class Foo {
+                                public Hidden fieldReferencesHidden1;
+                                public Outer<Hidden> fieldReferencesHidden2;
+                                public Outer<Foo>.Inner<Hidden> fieldReferencesHidden3;
+                                public Outer<Hidden>.Inner<Foo> fieldReferencesHidden4;
+                            }
+                        """
                     )
                 )
         )
@@ -303,10 +299,10 @@ class ApiAnalyzerTest : DriverTest() {
                             /** @deprecated */
                             @Deprecated
                             public void bar() { throw new RuntimeException("Stub!"); }
+                            public void baz(@Deprecated int i) { throw new RuntimeException("Stub!"); }
                             /** @deprecated */
                             @Deprecated
                             public <T> void foo(@Deprecated T t) { throw new RuntimeException("Stub!"); }
-                            public void baz(@Deprecated int i) { throw new RuntimeException("Stub!"); }
                             }
                         """
                     ),
@@ -368,10 +364,10 @@ class ApiAnalyzerTest : DriverTest() {
                             /** @deprecated */
                             @Deprecated
                             public void bar() { throw new RuntimeException("Stub!"); }
+                            public void baz(@Deprecated int i) { throw new RuntimeException("Stub!"); }
                             /** @deprecated */
                             @Deprecated
                             public void foo(@Deprecated java.lang.String t) { throw new RuntimeException("Stub!"); }
-                            public void baz(@Deprecated int i) { throw new RuntimeException("Stub!"); }
                             }
                         """
                     ),
@@ -453,7 +449,7 @@ class ApiAnalyzerTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/test/pkg/TestClass.kt:20: error: Parameter references deprecated type test.pkg.TestClass in test.pkg.TestClassKt.getCommentDeprecated(): this method should also be deprecated [ReferencesDeprecated]
+                    src/test/pkg/TestClass.kt:20: error: Parameter references deprecated type test.pkg.TestClass in test.pkg.TestClassKt.getCommentDeprecated(): this method should also be deprecated [ReferencesDeprecated]
                 """,
         )
     }
@@ -579,9 +575,9 @@ class ApiAnalyzerTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                    src/test/pkg/HiddenInterface.kt:5: error: Class test.pkg.HiddenInterface is hidden but was referenced (in return type) from public method test.pkg.PublicClass.returnsHiddenInterface() [ReferencesHidden]
-                    src/test/pkg/HiddenInterface.kt:5: warning: Return type of unavailable type test.pkg.HiddenInterface in test.pkg.PublicClass.returnsHiddenInterface() [UnavailableSymbol]
                     src/test/pkg/HiddenInterface.kt:5: warning: Method test.pkg.PublicClass.returnsHiddenInterface() references hidden type test.pkg.HiddenInterface. [HiddenTypeParameter]
+                    src/test/pkg/HiddenInterface.kt:5: warning: Return type of unavailable type test.pkg.HiddenInterface in test.pkg.PublicClass.returnsHiddenInterface() [UnavailableSymbol]
+                    src/test/pkg/HiddenInterface.kt:5: error: Class test.pkg.HiddenInterface is hidden but was referenced (in return type) from public method test.pkg.PublicClass.returnsHiddenInterface() [ReferencesHidden]
                 """,
         )
     }
@@ -593,27 +589,25 @@ class ApiAnalyzerTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                        package test.pkg;
-                        public class Container {
-                            private class PrivateInnerClass {}
-                            public class PublicInnerClass extends PrivateInnerClass {}
-                        }
-                    """
-                            .trimIndent()
+                            package test.pkg;
+                            public class Container {
+                                private class PrivateInnerClass {}
+                                public class PublicInnerClass extends PrivateInnerClass {}
+                            }
+                        """
                     )
                 ),
             api =
                 """
-                package test.pkg {
-                  public class Container {
-                    ctor public Container();
-                  }
-                  public class Container.PublicInnerClass {
-                    ctor public Container.PublicInnerClass();
-                  }
-                }
-            """
-                    .trimIndent(),
+                    package test.pkg {
+                      public class Container {
+                        ctor public Container();
+                      }
+                      public class Container.PublicInnerClass {
+                        ctor public Container.PublicInnerClass();
+                      }
+                    }
+                """,
             expectedIssues =
                 "src/test/pkg/Container.java:4: warning: Public class test.pkg.Container.PublicInnerClass extends private class test.pkg.Container.PrivateInnerClass [PrivateSuperclass]"
         )
@@ -626,23 +620,23 @@ class ApiAnalyzerTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                        package test.pkg;
-                        /** @deprecated */
-                        @Deprecated
-                        public class DeprecatedOuterClass {
-                            public class EffectivelyDeprecatedInnerClass extends DeprecatedOuterClass {
-                                public void usesDeprecatedOuterClass(DeprecatedOuterClass doc) {}
+                            package test.pkg;
+                            /** @deprecated */
+                            @Deprecated
+                            public class DeprecatedOuterClass {
+                                public class EffectivelyDeprecatedInnerClass extends DeprecatedOuterClass {
+                                    public void usesDeprecatedOuterClass(DeprecatedOuterClass doc) {}
+                                }
                             }
-                        }
-                    """
+                        """
                     ),
                     java(
                         """
-                        package test.pkg;
-                        public class NotDeprecatedClass extends DeprecatedOuterClass {
-                            public void usesDeprecatedOuterClass(DeprecatedOuterClass doc) {}
-                        }
-                    """
+                            package test.pkg;
+                            public class NotDeprecatedClass extends DeprecatedOuterClass {
+                                public void usesDeprecatedOuterClass(DeprecatedOuterClass doc) {}
+                            }
+                        """
                     )
                 ),
             api =
@@ -666,8 +660,8 @@ class ApiAnalyzerTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                    src/test/pkg/NotDeprecatedClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedOuterClass in test.pkg.NotDeprecatedClass.usesDeprecatedOuterClass(): this method should also be deprecated [ReferencesDeprecated]
                     src/test/pkg/NotDeprecatedClass.java:2: error: Extending deprecated super class class test.pkg.DeprecatedOuterClass from test.pkg.NotDeprecatedClass: this class should also be deprecated [ExtendsDeprecated]
+                    src/test/pkg/NotDeprecatedClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedOuterClass in test.pkg.NotDeprecatedClass.usesDeprecatedOuterClass(): this method should also be deprecated [ReferencesDeprecated]
                 """,
         )
     }
@@ -679,47 +673,47 @@ class ApiAnalyzerTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                        package test.pkg;
-                        /** @deprecated */
-                        @Deprecated
-                        public class DeprecatedOuterClass {
-                            public class EffectivelyDeprecatedInnerClass {}
-                        }
-                    """
+                            package test.pkg;
+                            /** @deprecated */
+                            @Deprecated
+                            public class DeprecatedOuterClass {
+                                public class EffectivelyDeprecatedInnerClass {}
+                            }
+                        """
                     ),
                     java(
                         """
-                        package test.pkg;
-                        public class NotDeprecatedClass extends DeprecatedOuterClass.EffectivelyDeprecatedInnerClass {
-                            public void usesEffectivelyDeprecatedInnerClass(DeprecatedOuterClass.EffectivelyDeprecatedInnerClass edic) {}
-                        }
-                    """
+                            package test.pkg;
+                            public class NotDeprecatedClass extends DeprecatedOuterClass.EffectivelyDeprecatedInnerClass {
+                                public void usesEffectivelyDeprecatedInnerClass(DeprecatedOuterClass.EffectivelyDeprecatedInnerClass edic) {}
+                            }
+                        """
                     )
                 ),
             api =
                 """
-                package test.pkg {
-                  @Deprecated public class DeprecatedOuterClass {
-                    ctor @Deprecated public DeprecatedOuterClass();
-                  }
-                  @Deprecated public class DeprecatedOuterClass.EffectivelyDeprecatedInnerClass {
-                    ctor @Deprecated public DeprecatedOuterClass.EffectivelyDeprecatedInnerClass();
-                  }
-                  public class NotDeprecatedClass extends test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass {
-                    ctor public NotDeprecatedClass();
-                    method public void usesEffectivelyDeprecatedInnerClass(test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass!);
-                  }
-                }
-            """,
+                    package test.pkg {
+                      @Deprecated public class DeprecatedOuterClass {
+                        ctor @Deprecated public DeprecatedOuterClass();
+                      }
+                      @Deprecated public class DeprecatedOuterClass.EffectivelyDeprecatedInnerClass {
+                        ctor @Deprecated public DeprecatedOuterClass.EffectivelyDeprecatedInnerClass();
+                      }
+                      public class NotDeprecatedClass extends test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass {
+                        ctor public NotDeprecatedClass();
+                        method public void usesEffectivelyDeprecatedInnerClass(test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass!);
+                      }
+                    }
+                """,
             extraArguments =
                 arrayOf(ARG_ERROR, "ReferencesDeprecated", ARG_ERROR, "ExtendsDeprecated"),
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/test/pkg/NotDeprecatedClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass in test.pkg.NotDeprecatedClass.usesEffectivelyDeprecatedInnerClass(): this method should also be deprecated [ReferencesDeprecated]
-                src/test/pkg/NotDeprecatedClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedOuterClass in test.pkg.NotDeprecatedClass.usesEffectivelyDeprecatedInnerClass(): this method should also be deprecated [ReferencesDeprecated]
-                src/test/pkg/NotDeprecatedClass.java:2: error: Extending deprecated super class class test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass from test.pkg.NotDeprecatedClass: this class should also be deprecated [ExtendsDeprecated]
-            """,
+                    src/test/pkg/NotDeprecatedClass.java:2: error: Extending deprecated super class class test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass from test.pkg.NotDeprecatedClass: this class should also be deprecated [ExtendsDeprecated]
+                    src/test/pkg/NotDeprecatedClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedOuterClass in test.pkg.NotDeprecatedClass.usesEffectivelyDeprecatedInnerClass(): this method should also be deprecated [ReferencesDeprecated]
+                    src/test/pkg/NotDeprecatedClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedOuterClass.EffectivelyDeprecatedInnerClass in test.pkg.NotDeprecatedClass.usesEffectivelyDeprecatedInnerClass(): this method should also be deprecated [ReferencesDeprecated]
+                """,
         )
     }
 
@@ -750,25 +744,106 @@ class ApiAnalyzerTest : DriverTest() {
                 ),
             api =
                 """
-                package test.pkg {
-                  @Deprecated public class DeprecatedClass {
-                    ctor @Deprecated public DeprecatedClass();
-                  }
-                  public class NotDeprecatedClass {
-                    ctor public NotDeprecatedClass();
-                    method public java.util.List<test.pkg.DeprecatedClass!>! usesDeprecated(java.util.List<test.pkg.DeprecatedClass!>!);
-                  }
-                }
-            """
-                    .trimIndent(),
+                    package test.pkg {
+                      @Deprecated public class DeprecatedClass {
+                        ctor @Deprecated public DeprecatedClass();
+                      }
+                      public class NotDeprecatedClass {
+                        ctor public NotDeprecatedClass();
+                        method public java.util.List<test.pkg.DeprecatedClass!>! usesDeprecated(java.util.List<test.pkg.DeprecatedClass!>!);
+                      }
+                    }
+                """,
             extraArguments = arrayOf(ARG_ERROR, "ReferencesDeprecated"),
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/test/pkg/NotDeprecatedClass.java:4: error: Return type references deprecated type test.pkg.DeprecatedClass in test.pkg.NotDeprecatedClass.usesDeprecated(): this method should also be deprecated [ReferencesDeprecated]
-                src/test/pkg/NotDeprecatedClass.java:4: error: Parameter references deprecated type test.pkg.DeprecatedClass in test.pkg.NotDeprecatedClass.usesDeprecated(): this method should also be deprecated [ReferencesDeprecated]
-            """
-                    .trimIndent()
+                    src/test/pkg/NotDeprecatedClass.java:4: error: Parameter references deprecated type test.pkg.DeprecatedClass in test.pkg.NotDeprecatedClass.usesDeprecated(): this method should also be deprecated [ReferencesDeprecated]
+                    src/test/pkg/NotDeprecatedClass.java:4: error: Return type references deprecated type test.pkg.DeprecatedClass in test.pkg.NotDeprecatedClass.usesDeprecated(): this method should also be deprecated [ReferencesDeprecated]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test propagation of @hide through package and class nesting`() {
+        //
+        check(
+            // Include system API annotations as a show annotation overrides hidden on a class that
+            // is in a hidden package.
+            includeSystemApiAnnotations = true,
+            // This is set to true so any class that is incorrectly unhidden will be included in the
+            // generated API and fail the test.
+            showUnannotated = true,
+            sourceFiles =
+                arrayOf(
+                    // Package "test.a" is hidden but "test.a.B" os marked with a show annotation so
+                    // that should cause "test.a" to be unhidden. However, "test.a.C" should still
+                    // be hidden as it inherits that from "test.a".
+                    java(
+                        """
+                            /** @hide */
+                            package test.a;
+                        """
+                    ),
+                    java(
+                        """
+                            package test.a;
+                            public class A {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.a;
+                            /** @hide */
+                            @android.annotation.SystemApi
+                            public class B {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.a;
+                            public class C {}
+                        """
+                    ),
+                    // Package "test.a.b" is not hidden itself but should inherit the hidden status
+                    // of the containing package "test.a" even though test.a has been unhidden
+                    // because of "test.a.B" having a show annotation. This should then be unhidden
+                    // because "test.a.b.B" has a show annotation but "test.a.b.C" should still be
+                    // hidden as it inherits it from "test.a".
+                    java(
+                        """
+                            package test.a.b;
+                            public class A {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.a.b;
+                            /** @hide */
+                            @android.annotation.SystemApi
+                            public class B {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.a.b;
+                            public class C {}
+                        """
+                    ),
+                ),
+            api =
+                """
+                    package test.a {
+                      public class B {
+                        ctor public B();
+                      }
+                    }
+                    package test.a.b {
+                      public class B {
+                        ctor public B();
+                      }
+                    }
+                """,
         )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
index c8242a68a..93928c48a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
@@ -21,12 +21,12 @@ package com.android.tools.metalava
 import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
 import com.android.tools.metalava.cli.common.ARG_ERROR
 import com.android.tools.metalava.cli.common.ARG_HIDE
-import com.android.tools.metalava.cli.common.ARG_WARNING
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.FileFormat.OverloadedMethodOrder
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -154,7 +154,9 @@ class ApiFileTest : DriverTest() {
                     }
                     """
                     ),
-                    supportParameterName
+                    supportParameterName,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -165,7 +167,6 @@ class ApiFileTest : DriverTest() {
                       }
                     }
                  """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -190,7 +191,9 @@ class ApiFileTest : DriverTest() {
                     }
                     """
                     ),
-                    supportDefaultValue
+                    supportDefaultValue,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -202,7 +205,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                  """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -246,13 +248,16 @@ class ApiFileTest : DriverTest() {
                     java(
                         """
                     package some.other.pkg;
+                    /** @hide */
                     public class Constants {
                         public static class Misc {
                             public static final int SIZE = 5;
                         }
                     }
                     """
-                    )
+                    ),
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -263,7 +268,7 @@ class ApiFileTest : DriverTest() {
                     method public android.graphics.Bitmap? drawToBitmap(android.view.View, android.graphics.Bitmap.Config config = android.graphics.Bitmap.Config.ARGB_8888);
                     method public void emptyLambda(kotlin.jvm.functions.Function0<kotlin.Unit> sizeOf = {});
                     method public void method1(int myInt = 42, Integer? myInt2 = null, int myByte = 42, String str = "hello world", java.lang.String... args);
-                    method public void method2(int myInt, int myInt2 = (2 * myInt) * some.other.pkg.Constants.Misc.SIZE);
+                    method public void method2(int myInt, int myInt2 = (2*myInt) * some.other.pkg.Constants.Misc.SIZE);
                     method public void method3(String str, int myInt, int myInt2 = double(myInt) + str.length);
                     field public static final test.pkg.Foo.Companion Companion;
                   }
@@ -273,13 +278,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
-                    ARG_HIDE_PACKAGE,
-                    "some.other.pkg"
-                ),
         )
     }
 
@@ -327,6 +325,7 @@ class ApiFileTest : DriverTest() {
                     import java.util.Locale;
                     import java.util.Map;
 
+                    /** @hide */
                     public class LruCache<K, V> {
                         @Nullable
                         protected V create(@NonNull K key) {
@@ -344,7 +343,9 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     androidxNullableSource,
-                    androidxNonNullSource
+                    androidxNonNullSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -355,13 +356,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.collection"
-                ),
         )
     }
 
@@ -441,6 +435,50 @@ class ApiFileTest : DriverTest() {
         )
     }
 
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Kotlin Reified Methods`() {
+        check(
+            format = FileFormat.V2,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                    package test.pkg;
+
+                    public class Context {
+                        @SuppressWarnings("unchecked")
+                        public final <T> T getSystemService(Class<T> serviceClass) {
+                            return null;
+                        }
+                    }
+                    """
+                    ),
+                    kotlin(
+                        """
+                    package test.pkg
+
+                    inline fun <reified T> Context.systemService1() = getSystemService(T::class.java)
+                    inline fun Context.systemService2() = getSystemService(String::class.java)
+                    """
+                    )
+                ),
+            api =
+                """
+                package test.pkg {
+                  public class Context {
+                    ctor public Context();
+                    method public final <T> T getSystemService(Class<T>);
+                  }
+                  public final class TestKt {
+                    method public static inline <reified T> T systemService1(@NonNull test.pkg.Context);
+                    method public static inline String systemService2(@NonNull test.pkg.Context);
+                  }
+                }
+                """
+        )
+    }
+
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Kotlin Reified Methods 2`() {
@@ -607,6 +645,12 @@ class ApiFileTest : DriverTest() {
                     }
                     """
                     ),
+                    java(
+                        """
+                            /** @hide */
+                            package test.pkg2;
+                        """
+                    ),
                     kotlin(
                         """
                     package test.pkg2
@@ -622,7 +666,9 @@ class ApiFileTest : DriverTest() {
                     )
                     """
                     ),
-                    uiThreadSource
+                    uiThreadSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -636,10 +682,6 @@ class ApiFileTest : DriverTest() {
             format = FileFormat.V3,
             extraArguments =
                 arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
-                    ARG_HIDE_PACKAGE,
-                    "test.pkg2",
                     ARG_HIDE,
                     "ReferencesHidden",
                     ARG_HIDE,
@@ -751,7 +793,9 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -784,8 +828,6 @@ class ApiFileTest : DriverTest() {
             format = FileFormat.V3,
             extraArguments =
                 arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
                     ARG_HIDE,
                     "ReferencesHidden",
                     ARG_HIDE,
@@ -1024,7 +1066,9 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -1064,7 +1108,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -1180,7 +1223,9 @@ class ApiFileTest : DriverTest() {
                         )
                         .indented(),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -1225,8 +1270,7 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments =
-                arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation", ARG_KOTLIN_SOURCE, "1.8")
+            extraArguments = arrayOf(ARG_KOTLIN_SOURCE, "1.8")
         )
     }
 
@@ -1264,7 +1308,9 @@ class ApiFileTest : DriverTest() {
                         fun String.blahblahblah(firstArg: String = "hello", secondArg: Int = 42, thirdArg: String = "world") {
                         }
                     """
-                    )
+                    ),
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -1280,7 +1326,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -1818,102 +1863,6 @@ class ApiFileTest : DriverTest() {
         )
     }
 
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Annotation retention`() {
-        // For annotations where the java.lang.annotation classes themselves are not
-        // part of the source tree, ensure that we compute the right retention (runtime, meaning
-        // it should show up in the stubs file.).
-        check(
-            format = FileFormat.V3,
-            extraArguments = arrayOf(ARG_EXCLUDE_ALL_ANNOTATIONS),
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    public @interface Foo {
-                        String value();
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.annotation;
-                    import static java.lang.annotation.ElementType.*;
-                    import java.lang.annotation.*;
-                    @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
-                    @Retention(RetentionPolicy.CLASS)
-                    @SuppressWarnings("ALL")
-                    public @interface SuppressLint {
-                        String[] value();
-                    }
-                    """
-                    ),
-                    kotlin(
-                        """
-                    package test.pkg
-
-                    @DslMarker
-                    annotation class ImplicitRuntimeRetention
-
-                    @Retention(AnnotationRetention.RUNTIME)
-                    annotation class ExplicitRuntimeRetention {
-                    }
-                    """
-                            .trimIndent()
-                    )
-                ),
-            api =
-                """
-            // Signature format: 3.0
-            package android.annotation {
-              @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.LOCAL_VARIABLE}) public @interface SuppressLint {
-                method public abstract String[] value();
-              }
-            }
-            package test.pkg {
-              @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.RUNTIME) public @interface ExplicitRuntimeRetention {
-              }
-              @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Foo {
-                method public abstract String value();
-              }
-              @kotlin.DslMarker public @interface ImplicitRuntimeRetention {
-              }
-            }
-            """
-                    .trimIndent(),
-            stubFiles =
-                arrayOf(
-                    // For annotations where the java.lang.annotation classes themselves are not
-                    // part of the source tree, ensure that we compute the right retention (runtime,
-                    // meaning
-                    // it should show up in the stubs file.).
-                    java(
-                        """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)
-                    public @interface Foo {
-                    public java.lang.String value();
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.annotation;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)
-                    @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.LOCAL_VARIABLE})
-                    public @interface SuppressLint {
-                    public java.lang.String[] value();
-                    }
-                    """
-                    )
-                )
-        )
-    }
-
     @Test
     fun `Superclass signature extraction`() {
         // Make sure superclass statement is correct; inherited method from parent that has same
@@ -2080,91 +2029,6 @@ class ApiFileTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Warn about findViewById`() {
-        // Include as many modifiers as possible to see which ones are included
-        // in the signature files, and the expected sorting order.
-        // Note that the signature files treat "deprecated" as a fake modifier.
-        // Note also how the "protected" modifier on the interface method gets
-        // promoted to public.
-        check(
-            format = FileFormat.V2,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    import android.annotation.Nullable;
-
-                    @SuppressWarnings("ALL")
-                    public abstract class Foo {
-                        @Nullable public String findViewById(int id) { return ""; }
-                    }
-                    """
-                    ),
-                    nullableSource
-                ),
-            expectedIssues =
-                """
-                src/test/pkg/Foo.java:6: warning: method test.pkg.Foo.findViewById(int) should not be annotated @Nullable; it should be left unspecified to make it a platform type [ExpectedPlatformType]
-                """,
-            extraArguments = arrayOf(ARG_WARNING, "ExpectedPlatformType"),
-            api =
-                """
-                package test.pkg {
-                  public abstract class Foo {
-                    ctor public Foo();
-                    method public String findViewById(int);
-                  }
-                }
-                """
-        )
-    }
-
-    @Test
-    fun `Remove findViewById type nullness annotation`() {
-        check(
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    import libcore.util.Nullable;
-
-                    @SuppressWarnings("ALL")
-                    public abstract class Foo {
-                        public @Nullable String findViewById(int id) { return ""; }
-                        public @Nullable String notFindViewById(int id) { return ""; }
-                    }
-                    """
-                    ),
-                    libcoreNullableSource
-                ),
-            expectedIssues =
-                """
-                src/test/pkg/Foo.java:6: warning: method test.pkg.Foo.findViewById(int) should not be annotated @Nullable; it should be left unspecified to make it a platform type [ExpectedPlatformType]
-                """,
-            extraArguments = arrayOf(ARG_WARNING, "ExpectedPlatformType"),
-            skipEmitPackages = listOf("libcore.util"),
-            format =
-                FileFormat.V5.copy(
-                    kotlinNameTypeOrder = true,
-                    includeTypeUseAnnotations = true,
-                    kotlinStyleNulls = false
-                ),
-            api =
-                """
-                package test.pkg {
-                  public abstract class Foo {
-                    ctor public Foo();
-                    method public findViewById(_: int): String;
-                    method @Nullable public notFindViewById(_: int): @Nullable String;
-                  }
-                }
-                """
-        )
-    }
-
     @Test
     fun `Package with only hidden classes should be removed from signature files`() {
         // Checks that if we have packages that are hidden, or contain only hidden or doconly
@@ -3114,15 +2978,6 @@ class ApiFileTest : DriverTest() {
                       }
                     }
                     """,
-            dexApi =
-                """
-                Ltest/pkg/Child;
-                Ltest/pkg/Child;-><init>()V
-                Ltest/pkg/Child;->toString()Ljava/lang/String;
-                Ltest/pkg/Parent;
-                Ltest/pkg/Parent;-><init>()V
-                Ltest/pkg/Parent;->toString()Ljava/lang/String;
-            """
         )
     }
 
@@ -3219,7 +3074,6 @@ class ApiFileTest : DriverTest() {
         // Real-world example: HttpResponseCache implements OkCacheContainer but hides the only
         // inherited method
         check(
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "com.squareup.okhttp"),
             sourceFiles =
                 arrayOf(
                     java(
@@ -3242,6 +3096,7 @@ class ApiFileTest : DriverTest() {
                     java(
                         """
                     package com.squareup.okhttp;
+                    /** @hide */
                     public interface OkCacheContainer {
                       Cache getCache();
                     }
@@ -3250,6 +3105,7 @@ class ApiFileTest : DriverTest() {
                     java(
                         """
                     package com.squareup.okhttp;
+                    /** @hide */
                     public class Cache {
                     }
                     """
@@ -3849,7 +3705,9 @@ class ApiFileTest : DriverTest() {
                     """
                         )
                         .indented(),
-                    visibleForTestingSource
+                    visibleForTestingSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -3862,7 +3720,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -3873,10 +3730,10 @@ class ApiFileTest : DriverTest() {
                 arrayOf(ARG_ERROR, "ReferencesDeprecated", ARG_ERROR, "ExtendsDeprecated"),
             expectedIssues =
                 """
-            src/test/pkg/MyClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedClass in test.pkg.MyClass.method1(): this method should also be deprecated [ReferencesDeprecated]
-            src/test/pkg/MyClass.java:4: error: Return type references deprecated type test.pkg.DeprecatedInterface in test.pkg.MyClass.method2(): this method should also be deprecated [ReferencesDeprecated]
             src/test/pkg/MyClass.java:2: error: Extending deprecated super class class test.pkg.DeprecatedClass from test.pkg.MyClass: this class should also be deprecated [ExtendsDeprecated]
             src/test/pkg/MyClass.java:2: error: Implementing interface of deprecated type test.pkg.DeprecatedInterface in test.pkg.MyClass: this class should also be deprecated [ExtendsDeprecated]
+            src/test/pkg/MyClass.java:3: error: Parameter references deprecated type test.pkg.DeprecatedClass in test.pkg.MyClass.method1(): this method should also be deprecated [ReferencesDeprecated]
+            src/test/pkg/MyClass.java:4: error: Return type references deprecated type test.pkg.DeprecatedInterface in test.pkg.MyClass.method2(): this method should also be deprecated [ReferencesDeprecated]
             """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -4142,9 +3999,10 @@ class ApiFileTest : DriverTest() {
                     }
                     """
                     ),
-                    androidxNonNullSource
+                    androidxNonNullSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             expectedIssues = "",
             api =
                 """
@@ -4532,9 +4390,10 @@ class ApiFileTest : DriverTest() {
                     }
                 """
                     ),
-                    androidxIntRangeSource
+                    androidxIntRangeSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 """
                 // Signature format: 3.0
@@ -4570,9 +4429,10 @@ class ApiFileTest : DriverTest() {
                     }
                 """
                     ),
-                    androidxIntRangeSource
+                    androidxIntRangeSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 """
                 // Signature format: 2.0
@@ -4605,9 +4465,10 @@ class ApiFileTest : DriverTest() {
                     }
                 """
                     ),
-                    androidxIntRangeSource
+                    androidxIntRangeSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 """
                 // Signature format: 3.0
@@ -4697,7 +4558,9 @@ class ApiFileTest : DriverTest() {
                     }
                     """
                     ),
-                    supportDefaultValue
+                    supportDefaultValue,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -4709,7 +4572,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                  """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -4753,19 +4615,23 @@ class ApiFileTest : DriverTest() {
                     java(
                         """
                     package some.other.pkg;
+                    /** @hide */
                     public class Constants {
                         public static class Misc {
                             public static final int SIZE = 5;
                         }
                     }
                     """
-                    )
+                    ),
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
                 // Signature format: 4.0
                 package test.pkg {
                   public final class Foo {
+                    ctor public Foo();
                     ctor public Foo(optional String a, optional String b);
                     method public android.graphics.Bitmap? drawToBitmap(android.view.View, optional android.graphics.Bitmap.Config config);
                     method public void emptyLambda(optional kotlin.jvm.functions.Function0<kotlin.Unit> sizeOf);
@@ -4780,13 +4646,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
-                    ARG_HIDE_PACKAGE,
-                    "some.other.pkg"
-                ),
         )
     }
 
@@ -4834,6 +4693,7 @@ class ApiFileTest : DriverTest() {
                     import java.util.Locale;
                     import java.util.Map;
 
+                    /** @hide */
                     public class LruCache<K, V> {
                         @Nullable
                         protected V create(@NonNull K key) {
@@ -4851,7 +4711,9 @@ class ApiFileTest : DriverTest() {
                     """
                     ),
                     androidxNullableSource,
-                    androidxNonNullSource
+                    androidxNonNullSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -4862,38 +4724,6 @@ class ApiFileTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.collection"
-                ),
-        )
-    }
-
-    @Test
-    fun `Test type erasure and dexApi from signature`() {
-        check(
-            signatureSources =
-                arrayOf(
-                    """
-                package android.widget {
-
-                  @android.widget.RemoteViews.RemoteView public class ListView extends android.widget.AbsListView {
-                    method protected <T extends android.view.View> T findViewTraversal(@IdRes int);
-                    method protected long tryAcquireShared(long);
-                  }
-
-                }
-                """
-                ),
-            dexApi =
-                """
-            Landroid/widget/ListView;
-            Landroid/widget/ListView;->findViewTraversal(I)Landroid/view/View;
-            Landroid/widget/ListView;->tryAcquireShared(J)J
-            """
         )
     }
 
@@ -5062,6 +4892,9 @@ class ApiFileTest : DriverTest() {
                             private val bar: Int = 0
                         )
 
+                        // When all args are optional, the compiler generates a no-arg constructor
+                        // even when @JvmOverloads is not used:
+                        // https://kotlinlang.org/docs/java-to-kotlin-interop.html#overloads-generation
                         class AllOptionalNoJvmOverloads(
                             private val foo: Int = 0,
                             private val bar: Int = 0
@@ -5092,6 +4925,7 @@ class ApiFileTest : DriverTest() {
                     ctor public AllOptionalJvmOverloads(optional int foo, optional int bar);
                   }
                   public final class AllOptionalNoJvmOverloads {
+                    ctor public AllOptionalNoJvmOverloads();
                     ctor public AllOptionalNoJvmOverloads(optional int foo, optional int bar);
                   }
                   public final class SomeOptionalJvmOverloads {
@@ -5265,9 +5099,10 @@ class ApiFileTest : DriverTest() {
                         fun returnsNonNullImplicitly() = "42"
                     """
                     ),
-                    androidxIntRangeSource
+                    androidxIntRangeSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 """
                 // Signature format: 2.0
@@ -5298,9 +5133,10 @@ class ApiFileTest : DriverTest() {
                     fun bar()
                 """
                     ),
-                    restrictToSource
+                    restrictToSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             format = FileFormat.V4,
             api =
                 """
@@ -5330,9 +5166,11 @@ class ApiFileTest : DriverTest() {
                     private fun veryFun(): Boolean = true
                 """
                     ),
-                    restrictToSource
+                    restrictToSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation", "--show-unannotated"),
+            extraArguments = arrayOf("--show-unannotated"),
             hideAnnotations =
                 arrayOf(
                     "androidx.annotation.RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY)"
@@ -5633,9 +5471,10 @@ class ApiFileTest : DriverTest() {
                     )
                     """
                     ),
-                    androidxIntRangeSource
+                    androidxIntRangeSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 """
                 package test.pkg {
@@ -5770,6 +5609,8 @@ class ApiFileTest : DriverTest() {
                     ),
                     restrictToSource,
                     visibleForTestingSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -5778,8 +5619,6 @@ class ApiFileTest : DriverTest() {
                     "kotlin.PublishedApi",
                     ARG_HIDE_ANNOTATION,
                     "androidx.annotation.RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP)",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation"
                 ),
             format = FileFormat.V4,
             api =
@@ -5975,7 +5814,9 @@ class ApiFileTest : DriverTest() {
                         }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -5992,8 +5833,6 @@ class ApiFileTest : DriverTest() {
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 )
         )
     }
@@ -6070,6 +5909,8 @@ class ApiFileTest : DriverTest() {
                     ),
                     systemApiSource,
                     testApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -6089,8 +5930,6 @@ class ApiFileTest : DriverTest() {
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                     ARG_SHOW_FOR_STUB_PURPOSES_ANNOTATION,
                     "android.annotation.SystemApi",
                 )
@@ -6138,7 +5977,9 @@ class ApiFileTest : DriverTest() {
                         }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             removedApi =
                 """
@@ -6153,8 +5994,6 @@ class ApiFileTest : DriverTest() {
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 )
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
index 242345f5d..5b62e9f2c 100644
--- a/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
@@ -22,6 +22,7 @@ import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.cli.lint.ARG_API_LINT
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import java.io.File
 import org.junit.Test
@@ -180,13 +181,7 @@ class BaselineTest : DriverTest() {
             format = FileFormat.V2,
             includeSystemApiAnnotations = true,
             extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
-                    ARG_API_LINT
-                ),
+                arrayOf(ARG_SHOW_ANNOTATION, "android.annotation.TestApi", ARG_API_LINT),
             baselineTestInfo =
                 BaselineTestInfo(
                     inputContents = "",
@@ -245,7 +240,9 @@ class BaselineTest : DriverTest() {
                     """
                     ),
                     testApiSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt b/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
index cffb82991..16db60926 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
@@ -16,14 +16,26 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.model.Assertions
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.MergedCodebase
 import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.text.ApiFile
+import com.android.tools.metalava.model.text.SignatureFile
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.testing.TemporaryFolderOwner
+import com.android.tools.metalava.testing.signature
 import org.junit.Assert.assertEquals
+import org.junit.Rule
 import org.junit.Test
+import org.junit.rules.TemporaryFolder
+
+class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
+    @get:Rule override val temporaryFolder = TemporaryFolder()
 
-class ComparisonVisitorTest {
     @Test
     fun `prefer first's real children even when first is only implied`() {
         val new =
@@ -88,4 +100,59 @@ class ComparisonVisitorTest {
             )
         assertEquals("TypeInFirst", methodType)
     }
+
+    @Test
+    fun `Test make sure that method with emit=false is ignored during comparison`() {
+
+        fun TestFile.readCodebase(): Codebase {
+            val signatureFile = SignatureFile(createFile(temporaryFolder.root))
+            return ApiFile.parseApi(signatureFile, noOpAnnotationManager)
+        }
+
+        val signatureFile =
+            signature(
+                "old.txt",
+                """
+                        // Signature format: 2.0
+                        package test.pkg {
+                            public class Foo {
+                                method public void foo();
+                            }
+                        }
+                    """
+            )
+
+        // Create a codebase with a method that has emit = false
+        val oldCodebase =
+            signatureFile.readCodebase().apply {
+                // Mark the method as emit=false
+                assertClass("test.pkg.Foo").methods().forEach { it.emit = false }
+            }
+
+        // Create an identical codebase except that the method has emit = true, the default.
+        val newCodebase = signatureFile.readCodebase()
+
+        // Compare the two.
+        val differences = mutableListOf<String>()
+        CodebaseComparator(ApiVisitor.Config())
+            .compare(
+                object : ComparisonVisitor() {
+                    override fun compare(old: MethodItem, new: MethodItem) {
+                        differences += "$old was changed"
+                    }
+
+                    override fun added(new: MethodItem) {
+                        differences += "$new was added"
+                    }
+
+                    override fun removed(old: MethodItem, from: ClassItem?) {
+                        differences += "$old was removed"
+                    }
+                },
+                oldCodebase,
+                newCodebase
+            )
+        // TODO(b/347885819): The method should be treated as being added not changed.
+        assertEquals("method test.pkg.Foo.foo() was changed", differences.joinToString("\n"))
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/DefaultReporterTest.kt b/metalava/src/test/java/com/android/tools/metalava/DefaultReporterTest.kt
index 536e88593..62838cdd5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DefaultReporterTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DefaultReporterTest.kt
@@ -19,6 +19,10 @@ package com.android.tools.metalava
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.reporter.BaselineKey
+import com.android.tools.metalava.reporter.DefaultReporter
+import com.android.tools.metalava.reporter.DefaultReporterEnvironment
+import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reportable
@@ -301,19 +305,84 @@ class DefaultReporterTest : DriverTest() {
             checkFileMethod(Severity.WARNING_ERROR_WHEN_NEW)
             checkFileMethod(Severity.WARNING)
             checkFileMethod(Severity.HIDDEN)
+
+            // Write any saved reports.
+            reporter.writeSavedReports()
         }
 
         assertEquals(
             """
-                error: reportable/maximum=error [MissingNullability]
-                warning: reportable/maximum=warning (ErrorWhenNew) [MissingNullability]
+                warning: file/maximum=warning [MissingNullability]
                 warning: reportable/maximum=warning [MissingNullability]
-                error: file/maximum=error [MissingNullability]
                 warning: file/maximum=warning (ErrorWhenNew) [MissingNullability]
-                warning: file/maximum=warning [MissingNullability]
+                warning: reportable/maximum=warning (ErrorWhenNew) [MissingNullability]
+                error: file/maximum=error [MissingNullability]
+                error: reportable/maximum=error [MissingNullability]
             """
                 .trimIndent(),
             stringWriter.toString().trimEnd()
         )
     }
+
+    @Test
+    fun `test suppressed writer`() {
+        val fakeReportable: Reportable =
+            object : Reportable {
+                override val fileLocation = FileLocation.UNKNOWN
+                override val baselineKey: BaselineKey = BaselineKey.UNKNOWN
+
+                override fun suppressedIssues() = setOf(Issues.HIDDEN_SUPERCLASS.name)
+            }
+        val suppressedFile = temporaryFolder.newFile("suppressed.txt")
+        val stringWriter = StringWriter()
+        suppressedFile.printWriter().use { reportEvenIfSuppressedWriter ->
+            PrintWriter(stringWriter).use { writer ->
+                val reporterEnvironment =
+                    DefaultReporterEnvironment(
+                        stdout = writer,
+                        stderr = writer,
+                    )
+                val reporter =
+                    DefaultReporter(
+                        environment = reporterEnvironment,
+                        issueConfiguration = IssueConfiguration(),
+                        config =
+                            DefaultReporter.Config(
+                                reportEvenIfSuppressedWriter = reportEvenIfSuppressedWriter,
+                            ),
+                    )
+
+                reporter.report(
+                    Issues.HIDDEN_SUPERCLASS,
+                    fakeReportable,
+                    "HIDDEN_SUPERCLASS",
+                )
+
+                reporter.report(
+                    Issues.BROADCAST_BEHAVIOR,
+                    fakeReportable,
+                    "BROADCAST_BEHAVIOR",
+                )
+
+                // Write any saved reports.
+                reporter.writeSavedReports()
+            }
+        }
+
+        assertEquals(
+            """
+                warning: HIDDEN_SUPERCLASS [HiddenSuperclass]
+                error: BROADCAST_BEHAVIOR [BroadcastBehavior]
+            """
+                .trimIndent(),
+            suppressedFile.readText().trimEnd(),
+            message = "suppressed file"
+        )
+
+        assertEquals(
+            "error: BROADCAST_BEHAVIOR [BroadcastBehavior]",
+            stringWriter.toString().trimEnd(),
+            message = "intercepted stdout"
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt b/metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt
index 4f44a34e1..a4d786b27 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt
@@ -50,11 +50,141 @@ class DeprecatedTestCase : DriverTest() {
                       }
                     }
                 """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /** @deprecated */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            @Deprecated
+                            public class Foo {
+                            @Deprecated
+                            public Foo(int p1, @Deprecated int p2) { throw new RuntimeException("Stub!"); }
+                            @Deprecated
+                            public void method(int p1, @Deprecated int p2) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                ),
+        )
+    }
+
+    @Test
+    fun `Test deprecated is not written out for field inherited from deprecated hidden class`() {
+        // Makes sure that deprecated status is not copied when the inherited field is only
+        // deprecated implicitly because it is contained with a class that is deprecated.
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            /** @deprecated */
+                            @Deprecated
+                            interface Constants {
+                                int INHERITED = 0;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+
+                            public class Foo implements Constants {
+                                private Foo() {}
+                                public static final int CONSTANT = 1;
+                            }
+                        """
+                    ),
+                ),
+            api =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        field public static final int CONSTANT = 1; // 0x1
+                        field public static final int INHERITED = 0; // 0x0
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Foo {
+                            Foo() { throw new RuntimeException("Stub!"); }
+                            public static final int CONSTANT = 1; // 0x1
+                            public static final int INHERITED = 0; // 0x0
+                            }
+                        """
+                    )
+                ),
         )
     }
 
     @Test
-    fun `Test deprecated not written out for field inherited from hidden class`() {
+    fun `Test deprecated is written out for deprecated field inherited from hidden class`() {
+        // Makes sure that deprecated status is copied when the inherited field is explicitly
+        // deprecated.
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            interface Constants {
+                                /** @deprecated */
+                                @Deprecated
+                                int INHERITED = 0;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+
+                            public class Foo implements Constants {
+                                private Foo() {}
+                                public static final int CONSTANT = 1;
+                            }
+                        """
+                    ),
+                ),
+            api =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        field public static final int CONSTANT = 1; // 0x1
+                        field @Deprecated public static final int INHERITED = 0; // 0x0
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Foo {
+                            Foo() { throw new RuntimeException("Stub!"); }
+                            public static final int CONSTANT = 1; // 0x1
+                            /** @deprecated */
+                            @Deprecated public static final int INHERITED = 0; // 0x0
+                            }
+                        """
+                    )
+                ),
+        )
+    }
+
+    @Test
+    fun `Test deprecated is written out for field inherited into deprecated class from hidden class`() {
         check(
             sourceFiles =
                 arrayOf(
@@ -86,10 +216,27 @@ class DeprecatedTestCase : DriverTest() {
                     package test.pkg {
                       @Deprecated public class Foo {
                         field @Deprecated public static final int CONSTANT = 1; // 0x1
-                        field public static final int INHERITED = 0; // 0x0
+                        field @Deprecated public static final int INHERITED = 0; // 0x0
                       }
                     }
                 """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /** @deprecated */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            @Deprecated
+                            public class Foo {
+                            @Deprecated
+                            Foo() { throw new RuntimeException("Stub!"); }
+                            @Deprecated public static final int CONSTANT = 1; // 0x1
+                            @Deprecated public static final int INHERITED = 0; // 0x0
+                            }
+                        """
+                    )
+                ),
         )
     }
 
@@ -143,6 +290,7 @@ class DeprecatedTestCase : DriverTest() {
             api = """
                     // Signature format: 5.0
                 """,
+            stubPaths = emptyArray(),
         )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
index e7e2e758c..a361abc34 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
@@ -39,9 +39,9 @@ import com.android.tools.metalava.cli.common.ARG_SOURCE_PATH
 import com.android.tools.metalava.cli.common.ARG_VERBOSE
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.cli.common.TestEnvironment
+import com.android.tools.metalava.cli.compatibility.ARG_API_COMPAT_ANNOTATION
 import com.android.tools.metalava.cli.compatibility.ARG_BASELINE_CHECK_COMPATIBILITY_RELEASED
 import com.android.tools.metalava.cli.compatibility.ARG_CHECK_COMPATIBILITY_API_RELEASED
-import com.android.tools.metalava.cli.compatibility.ARG_CHECK_COMPATIBILITY_BASE_API
 import com.android.tools.metalava.cli.compatibility.ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED
 import com.android.tools.metalava.cli.compatibility.ARG_ERROR_MESSAGE_CHECK_COMPATIBILITY_RELEASED
 import com.android.tools.metalava.cli.compatibility.ARG_UPDATE_BASELINE_CHECK_COMPATIBILITY_RELEASED
@@ -64,6 +64,7 @@ import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.SignatureFile
 import com.android.tools.metalava.model.text.assertSignatureFilesMatch
 import com.android.tools.metalava.model.text.prepareSignatureFileForTest
+import com.android.tools.metalava.reporter.ReporterEnvironment
 import com.android.tools.metalava.reporter.Severity
 import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.TemporaryFolderOwner
@@ -79,7 +80,7 @@ import java.io.FileNotFoundException
 import java.io.PrintStream
 import java.io.PrintWriter
 import java.io.StringWriter
-import java.net.URL
+import java.net.URI
 import kotlin.text.Charsets.UTF_8
 import org.intellij.lang.annotations.Language
 import org.junit.Assert.assertEquals
@@ -376,12 +377,11 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
 
     @Suppress("DEPRECATION")
     protected fun check(
+        configFiles: Array<TestFile> = emptyArray(),
         /** Any jars to add to the class path */
         classpath: Array<TestFile>? = null,
         /** The API signature content (corresponds to --api) */
         @Language("TEXT") api: String? = null,
-        /** The DEX API (corresponds to --dex-api) */
-        dexApi: String? = null,
         /** The removed API (corresponds to --removed-api) */
         removedApi: String? = null,
         /** The subtract api signature content (corresponds to --subtract-api) */
@@ -447,9 +447,8 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
          * In order from narrowest to widest API.
          */
         checkCompatibilityRemovedApiReleasedList: List<String> = emptyList(),
-        /** An optional API signature to use as the base API codebase during compat checks */
-        @Language("TEXT") checkCompatibilityBaseApi: String? = null,
         @Language("TEXT") migrateNullsApi: String? = null,
+        migrateNullsApiList: List<String> = listOfNotNull(migrateNullsApi),
         /** An optional Proguard keep file to generate */
         @Language("Proguard") proguard: String? = null,
         /** Show annotations (--show-annotation arguments) */
@@ -458,6 +457,8 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         showForStubPurposesAnnotations: Array<String> = emptyArray(),
         /** Hide annotations (--hide-annotation arguments) */
         hideAnnotations: Array<String> = emptyArray(),
+        /** API Compatibility important annotations (--api-compat-annotation) */
+        apiCompatAnnotations: Set<String> = emptySet(),
         /** No compat check meta-annotations (--no-compat-check-meta-annotation arguments) */
         suppressCompatibilityMetaAnnotations: Array<String> = emptyArray(),
         /** If using [showAnnotations], whether to include unannotated */
@@ -533,8 +534,10 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         sourceFiles: Array<TestFile> = emptyArray(),
         /** The common source files to pass to the analyzer */
         commonSourceFiles: Array<TestFile> = emptyArray(),
+        /** Lint project description */
+        projectDescription: TestFile? = null,
         /** [ARG_REPEAT_ERRORS_MAX] */
-        repeatErrorsMax: Int = 0
+        repeatErrorsMax: Int = 0,
     ) {
         // Ensure different API clients don't interfere with each other
         try {
@@ -614,6 +617,8 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 )
         }
 
+        val projectDescriptionFile = projectDescription?.createFile(project)
+
         val apiClassResolutionArgs =
             arrayOf(ARG_API_CLASS_RESOLUTION, apiClassResolution.optionValue)
 
@@ -680,6 +685,11 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 }
             }
 
+        val configFileArgs =
+            configFiles
+                .flatMap { listOf(ARG_CONFIG_FILE, it.indented().createFile(project).path) }
+                .toTypedArray()
+
         val mergeAnnotationsArgs =
             if (mergeXmlAnnotations != null) {
                 val merged = File(project, "merged-annotations.xml")
@@ -742,16 +752,6 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 emptyArray()
             }
 
-        val checkCompatibilityBaseApiFile =
-            useExistingSignatureFileOrCreateNewFile(
-                project,
-                checkCompatibilityBaseApi,
-                "compatibility-base-api.txt"
-            )
-
-        val migrateNullsApiFile =
-            useExistingSignatureFileOrCreateNewFile(project, migrateNullsApi, "stable-api.txt")
-
         val manifestFileArgs =
             if (manifest != null) {
                 val file = File(project, "manifest.xml")
@@ -762,15 +762,20 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
             }
 
         val migrateNullsArguments =
-            if (migrateNullsApiFile != null) {
-                arrayOf(ARG_MIGRATE_NULLNESS, migrateNullsApiFile.path)
-            } else {
-                emptyArray()
-            }
+            migrateNullsApiList.contentOrPathListToArgsArray(
+                project,
+                "stable-api.txt",
+                ARG_MIGRATE_NULLNESS
+            )
 
-        val checkCompatibilityBaseApiArguments =
-            if (checkCompatibilityBaseApiFile != null) {
-                arrayOf(ARG_CHECK_COMPATIBILITY_BASE_API, checkCompatibilityBaseApiFile.path)
+        val apiCompatAnnotationArguments =
+            if (apiCompatAnnotations.isNotEmpty()) {
+                val args = mutableListOf<String>()
+                for (annotation in apiCompatAnnotations) {
+                    args.add(ARG_API_COMPAT_ANNOTATION)
+                    args.add(annotation)
+                }
+                args.toTypedArray()
             } else {
                 emptyArray()
             }
@@ -868,15 +873,6 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         val apiFile: File = newFile("public-api.txt")
         val apiArgs = arrayOf(ARG_API, apiFile.path)
 
-        var dexApiFile: File? = null
-        val dexApiArgs =
-            if (dexApi != null) {
-                dexApiFile = temporaryFolder.newFile("public-dex.txt")
-                arrayOf(ARG_DEX_API, dexApiFile.path)
-            } else {
-                emptyArray()
-            }
-
         val subtractApiFile: File?
         val subtractApiArgs =
             if (subtractApi != null) {
@@ -1038,9 +1034,9 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 androidJar.path,
                 *classpathArgs,
                 *kotlinPathArgs,
+                *configFileArgs,
                 *removedArgs,
                 *apiArgs,
-                *dexApiArgs,
                 *subtractApiArgs,
                 *stubsArgs,
                 *quiet,
@@ -1050,7 +1046,6 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 *inclusionAnnotationsArgs,
                 *migrateNullsArguments,
                 *releasedApiCheck.arguments(project),
-                *checkCompatibilityBaseApiArguments,
                 *releasedRemovedApiCheck.arguments(project),
                 *proguardKeepArguments,
                 *manifestFileArgs,
@@ -1058,6 +1053,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 *baselineCheck.args,
                 *baselineApiLintCheck.args,
                 *baselineCheckCompatibilityReleasedCheck.args,
+                *apiCompatAnnotationArguments,
                 *showAnnotationArguments,
                 *hideAnnotationArguments,
                 *suppressCompatMetaAnnotationArguments,
@@ -1070,7 +1066,6 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 *validateNullabilityFromListArgs,
                 format.outputFlags(),
                 *apiClassResolutionArgs,
-                *sourceList,
                 *extraArguments,
                 *errorMessageApiLintArgs,
                 *errorMessageCheckCompatibilityReleasedArgs,
@@ -1079,9 +1074,17 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 *apiLintArgs,
             ) +
                 buildList {
-                        if (commonSourcePath != null) {
-                            add(ARG_COMMON_SOURCE_PATH)
-                            add(commonSourcePath)
+                        if (projectDescriptionFile != null) {
+                            add(ARG_PROJECT)
+                            add(projectDescriptionFile.absolutePath)
+                            // When project description is provided,
+                            // skip listing (common) sources
+                        } else {
+                            addAll(sourceList)
+                            if (commonSourcePath != null) {
+                                add(ARG_COMMON_SOURCE_PATH)
+                                add(commonSourcePath)
+                            }
                         }
                     }
                     .toTypedArray()
@@ -1138,18 +1141,6 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         baselineApiLintCheck.apply()
         baselineCheckCompatibilityReleasedCheck.apply()
 
-        if (dexApi != null && dexApiFile != null) {
-            assertTrue(
-                "${dexApiFile.path} does not exist even though --dex-api was used",
-                dexApiFile.exists()
-            )
-            val actualText = readFile(dexApiFile)
-            assertEquals(
-                stripComments(dexApi, DOT_TXT, stripLineComments = false).trimIndent(),
-                actualText
-            )
-        }
-
         if (removedApi != null && removedApiFile != null) {
             assertTrue(
                 "${removedApiFile.path} does not exist even though --removed-api was used",
@@ -1320,15 +1311,11 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
 
         /** The arguments to pass to Metalava. */
         fun arguments(project: File): Array<out String> {
-            if (fileOrSignatureContentsList.isEmpty()) return emptyArray()
-
-            val paths =
-                fileOrSignatureContentsList.mapNotNull {
-                    useExistingSignatureFileOrCreateNewFile(project, it, newBasename)?.path
-                }
-
-            // For each path in the list generate an option with the path as the value.
-            return paths.flatMap { listOf(optionName, it) }.toTypedArray()
+            return fileOrSignatureContentsList.contentOrPathListToArgsArray(
+                project,
+                newBasename,
+                optionName
+            )
         }
     }
 
@@ -1337,13 +1324,14 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         assertNotNull(output)
         assertTrue(output.exists())
         val url =
-            URL(
-                "jar:" +
-                    SdkUtils.fileToUrlString(output) +
-                    "!/" +
-                    pkg.replace('.', '/') +
-                    "/annotations.xml"
-            )
+            URI(
+                    "jar:" +
+                        SdkUtils.fileToUrlString(output) +
+                        "!/" +
+                        pkg.replace('.', '/') +
+                        "/annotations.xml"
+                )
+                .toURL()
         val stream = url.openStream()
         try {
             val bytes = stream.readBytes()
@@ -1408,6 +1396,33 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 }
             }
 
+        /**
+         * Converts the contents of the list, which may be either the name of a file or the contents
+         * of a file into an array of arguments.
+         *
+         * This will use files supplied and create new files from the contents of the file and then
+         * precede each file by the [optionName].
+         *
+         * @param project the project directory for the test.
+         * @param baseName the base name of the files, including extension. Any created files will
+         *   have a unique name based on this name.
+         * @param optionName the name of the option to use in the arguments.
+         */
+        private fun List<String>.contentOrPathListToArgsArray(
+            project: File,
+            baseName: String,
+            optionName: String
+        ): Array<String> {
+            if (isEmpty()) return emptyArray()
+
+            val paths = mapNotNull {
+                useExistingSignatureFileOrCreateNewFile(project, it, baseName)?.path
+            }
+
+            // For each path in the list generate an option with the path as the value.
+            return paths.flatMap { listOf(optionName, it) }.toTypedArray()
+        }
+
         private fun findNonExistentFile(project: File, basename: String): File {
             // Split the basename into the name without any extension an optional extension.
             val index = basename.lastIndexOf('.')
diff --git a/metalava/src/test/java/com/android/tools/metalava/DuplicateClassTest.kt b/metalava/src/test/java/com/android/tools/metalava/DuplicateClassTest.kt
new file mode 100644
index 000000000..b5ef9295f
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/DuplicateClassTest.kt
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+
+class DuplicateClassTest : DriverTest() {
+
+    @Test
+    fun `Test duplicate classes`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            public class Foo {}
+                        """
+                    ),
+                    java(
+                        "src2/test/pkg/Foo.java",
+                        """
+                            package test.pkg;
+
+                            public class Foo {}
+                        """
+                    )
+                ),
+            expectedIssues =
+                """
+                    src2/test/pkg/Foo.java:3: warning: Attempted to register test.pkg.Foo twice; once from TESTROOT/src/test/pkg/Foo.java and this one from TESTROOT/src2/test/pkg/Foo.java [DuplicateSourceClass]
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
index b1d465617..3e8aec91a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -75,7 +76,9 @@ class ExtractAnnotationsTest : DriverTest() {
                 )
                 .indented(),
             intDefAnnotationSource,
-            intRangeAnnotationSource
+            intRangeAnnotationSource,
+            // Hide android.annotation classes.
+            KnownSourceFiles.androidAnnotationHide,
         )
 
     @Test
@@ -556,8 +559,7 @@ class ExtractAnnotationsTest : DriverTest() {
     @Test
     fun `No typedef signatures in api files`() {
         check(
-            extraArguments =
-                arrayOf(ARG_HIDE_PACKAGE, "android.annotation", ARG_TYPEDEFS_IN_SIGNATURES, "none"),
+            extraArguments = arrayOf(ARG_TYPEDEFS_IN_SIGNATURES, "none"),
             format = FileFormat.V2,
             sourceFiles = sourceFiles1,
             api =
@@ -590,13 +592,7 @@ class ExtractAnnotationsTest : DriverTest() {
     @Test
     fun `Inlining typedef signatures in api files`() {
         check(
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
-                    ARG_TYPEDEFS_IN_SIGNATURES,
-                    "inline"
-                ),
+            extraArguments = arrayOf(ARG_TYPEDEFS_IN_SIGNATURES, "inline"),
             format = FileFormat.V2,
             sourceFiles = sourceFiles1,
             api =
@@ -629,8 +625,7 @@ class ExtractAnnotationsTest : DriverTest() {
     @Test
     fun `Referencing typedef signatures in api files`() {
         check(
-            extraArguments =
-                arrayOf(ARG_HIDE_PACKAGE, "android.annotation", ARG_TYPEDEFS_IN_SIGNATURES, "ref"),
+            extraArguments = arrayOf(ARG_TYPEDEFS_IN_SIGNATURES, "ref"),
             format = FileFormat.V2,
             sourceFiles = sourceFiles1,
             api =
diff --git a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
index e7c04f6a9..83b15e777 100644
--- a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
@@ -20,6 +20,7 @@ import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import java.util.Locale
 import kotlin.test.assertEquals
@@ -233,8 +234,6 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
 
         val args =
             arrayOf(
-                ARG_HIDE_PACKAGE,
-                "android.annotation",
                 "--warning",
                 "UnflaggedApi",
                 *apiVersionsArgs,
@@ -258,6 +257,8 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         addAll(sourceFiles)
                         addAll(annotationsList)
                         add(flagsFile)
+                        // Hide android.annotation classes.
+                        add(KnownSourceFiles.androidAnnotationHide)
                     }
                     .toTypedArray(),
             api = expectations.expectedApi,
@@ -1324,6 +1325,7 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                         public final void method(@android.annotation.Nullable java.lang.String p) { throw new RuntimeException("Stub!"); }
                         public void nativeMethod() { throw new RuntimeException("Stub!"); }
                         public static final int field;
+                        static { field = 0; }
                         }
                     """
                 ),
@@ -1797,4 +1799,172 @@ class FlaggedApiTest(private val config: Configuration) : DriverTest() {
                 ),
         )
     }
+
+    @Test
+    fun `Test that pulling method up into super class can be reverted`() {
+        val stubsWithFlaggedApis =
+            arrayOf(
+                java(
+                    """
+                        package test.pkg;
+                        @SuppressWarnings({"unchecked", "deprecation", "all"})
+                        public class Bar {
+                        public Bar() { throw new RuntimeException("Stub!"); }
+                        @android.annotation.FlaggedApi("test.pkg.flags.foo_bar")
+                        public void method() { throw new RuntimeException("Stub!"); }
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.pkg;
+                        @SuppressWarnings({"unchecked", "deprecation", "all"})
+                        public class Foo extends test.pkg.Bar {
+                        Foo() { throw new RuntimeException("Stub!"); }
+                        }
+                    """
+                ),
+            )
+
+        val stubsWithoutFlaggedApis =
+            arrayOf(
+                java(
+                    """
+                        package test.pkg;
+                        @SuppressWarnings({"unchecked", "deprecation", "all"})
+                        public class Bar {
+                        public Bar() { throw new RuntimeException("Stub!"); }
+                        }
+                    """
+                ),
+                // TODO(b/337840740): Foo should have method().
+                java(
+                    """
+                        package test.pkg;
+                        @SuppressWarnings({"unchecked", "deprecation", "all"})
+                        public class Foo extends test.pkg.Bar {
+                        Foo() { throw new RuntimeException("Stub!"); }
+                        }
+                    """
+                ),
+            )
+
+        checkFlaggedApis(
+            java(
+                """
+                    package test.pkg;
+
+                    import android.annotation.FlaggedApi;
+                    import test.pkg.flags.Flags;
+
+                    public class Bar {
+                        // This is flagged as the method was pulled up from Foo.
+                        @FlaggedApi(Flags.FLAG_FOO_BAR)
+                        public void method() {}
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    import android.annotation.FlaggedApi;
+                    import test.pkg.flags.Flags;
+
+                    public class Foo extends Bar {
+                        private Foo() {}
+                    }
+                """
+            ),
+            // The previously released public api.
+            previouslyReleasedApi =
+                mapOf(
+                    Surface.PUBLIC to
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Bar {
+                                ctor public Bar();
+                              }
+                              public class Foo {
+                                method public void method();
+                              }
+                            }
+                        """,
+                ),
+            expectationsList =
+                listOf(
+                    Expectations(
+                        Surface.PUBLIC,
+                        Flagged.WITH,
+                        expectedApi =
+                            """
+                                // Signature format: 2.0
+                                package test.pkg {
+                                  public class Bar {
+                                    ctor public Bar();
+                                    method @FlaggedApi("test.pkg.flags.foo_bar") public void method();
+                                  }
+                                  public class Foo extends test.pkg.Bar {
+                                  }
+                                }
+                            """,
+                        expectedStubs = stubsWithFlaggedApis,
+                    ),
+                    Expectations(
+                        Surface.PUBLIC,
+                        Flagged.WITHOUT,
+                        expectedApi =
+                            // TODO(b/337840740): Foo should have method().
+                            """
+                                // Signature format: 2.0
+                                package test.pkg {
+                                  public class Bar {
+                                    ctor public Bar();
+                                  }
+                                  public class Foo extends test.pkg.Bar {
+                                  }
+                                }
+                            """,
+                        expectedStubs = stubsWithoutFlaggedApis,
+                    ),
+                    Expectations(
+                        Surface.SYSTEM,
+                        Flagged.WITH,
+                        expectedApi =
+                            """
+                                // Signature format: 2.0
+                            """,
+                        expectedStubs = stubsWithFlaggedApis,
+                    ),
+                    Expectations(
+                        Surface.SYSTEM,
+                        Flagged.WITHOUT,
+                        expectedApi =
+                            """
+                                // Signature format: 2.0
+                            """,
+                        expectedStubs = stubsWithoutFlaggedApis,
+                    ),
+                    Expectations(
+                        Surface.MODULE_LIB,
+                        Flagged.WITH,
+                        expectedApi =
+                            """
+                                // Signature format: 2.0
+                            """,
+                        expectedStubs = stubsWithFlaggedApis,
+                    ),
+                    Expectations(
+                        Surface.MODULE_LIB,
+                        Flagged.WITHOUT,
+                        expectedApi =
+                            """
+                                // Signature format: 2.0
+                            """,
+                        expectedStubs = stubsWithoutFlaggedApis,
+                    ),
+                ),
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/InterfaceTypeListOrderTest.kt b/metalava/src/test/java/com/android/tools/metalava/InterfaceTypeListOrderTest.kt
new file mode 100644
index 000000000..8b674f791
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/InterfaceTypeListOrderTest.kt
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+
+/** Test for the [FileFormat.sortWholeExtendsList] property. */
+class InterfaceTypeListOrderTest : DriverTest() {
+    private fun runOrderTest(fileFormat: FileFormat, api: String) {
+        check(
+            format = fileFormat,
+            checkCompilation = true,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            interface PackagePrivate {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            public interface Public {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.other;
+                            // This sorts before test.pkg.Public when qualified name is used and
+                            // after when full name is used.
+                            public interface Special {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.other;
+                            // This sorts before test.pkg.Public when qualified name is used and
+                            // uses source order when full name is used.
+                            public interface Public {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            // Check the behavior on an interface when the first type is private.
+                            // In this case when `FileFormat.sortWholeExtendsList=false` then
+                            // `test.other.Special` should be last in the list and
+                            // `test.other.Public` should be after `test.pkg.Public` as they are
+                            // partially sorted by full name, maintaining source order when the
+                            // full names match.
+                            public interface InterfaceFirstPrivate extends PackagePrivate, test.other.Special, Public, test.other.Public {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            // Check the behavior on an interface when the first type is not private.
+                            // In this case when `FileFormat.sortWholeExtendsList=false` then
+                            // `test.other.Special` should be first in the signature list even
+                            // though it sorts to the end because the first interface is always
+                            // written out first if it is not hidden.
+                            // `test.other.Public` should be after `test.pkg.Public` as they are
+                            // partially sorted by full name, maintaining source order when the
+                            // full names match.
+                            public interface InterfaceFirstNotPrivate extends test.other.Special, PackagePrivate, Public, test.other.Public {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            // Check the behavior on a class when the first type is private.
+                            // In this case when `FileFormat.sortWholeExtendsList=false` then
+                            // `test.other.Special` should be last in the list and
+                            // `test.other.Public` should be after `test.pkg.Public` as they are
+                            // partially sorted by full name, maintaining source order when the
+                            // full names match.
+                            public class ClassFirstPrivate implements PackagePrivate, test.other.Special, Public, test.other.Public {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            // Check the behavior on a class when the first type is not private.
+                            // In this case when `FileFormat.sortWholeExtendsList=false` then
+                            // `test.other.Special` should be last in the list and
+                            // `test.other.Public` should be after `test.pkg.Public` as they are
+                            // partially sorted by full name, maintaining source order when the
+                            // full names match.
+                            public class ClassFirstNotPrivate implements test.other.Special, PackagePrivate, Public, test.other.Public {}
+                        """
+                    ),
+                ),
+            api = api,
+        )
+    }
+
+    @Test
+    fun `First interface is private, legacy order`() {
+        runOrderTest(
+            fileFormat = FileFormat.V2,
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.other {
+                      public interface Public {
+                      }
+                      public interface Special {
+                      }
+                    }
+                    package test.pkg {
+                      public class ClassFirstNotPrivate implements test.pkg.Public test.other.Public test.other.Special {
+                        ctor public ClassFirstNotPrivate();
+                      }
+                      public class ClassFirstPrivate implements test.pkg.Public test.other.Public test.other.Special {
+                        ctor public ClassFirstPrivate();
+                      }
+                      public interface InterfaceFirstNotPrivate extends test.other.Special test.pkg.Public test.other.Public {
+                      }
+                      public interface InterfaceFirstPrivate extends test.pkg.Public test.other.Public test.other.Special {
+                      }
+                      public interface Public {
+                      }
+                    }
+                """,
+        )
+    }
+
+    @Test
+    fun `First interface is private, full order`() {
+        // All the `implements` lists are in the same order as the whole list is sorted first by
+        // full name and then by qualified name.
+        runOrderTest(
+            fileFormat = FileFormat.V2.copy(specifiedSortWholeExtendsList = true),
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.other {
+                      public interface Public {
+                      }
+                      public interface Special {
+                      }
+                    }
+                    package test.pkg {
+                      public class ClassFirstNotPrivate implements test.other.Public test.pkg.Public test.other.Special {
+                        ctor public ClassFirstNotPrivate();
+                      }
+                      public class ClassFirstPrivate implements test.other.Public test.pkg.Public test.other.Special {
+                        ctor public ClassFirstPrivate();
+                      }
+                      public interface InterfaceFirstNotPrivate extends test.other.Public test.pkg.Public test.other.Special {
+                      }
+                      public interface InterfaceFirstPrivate extends test.other.Public test.pkg.Public test.other.Special {
+                      }
+                      public interface Public {
+                      }
+                    }
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt b/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt
index 408bdaa3d..1e0233da7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt
@@ -17,8 +17,9 @@
 package com.android.tools.metalava
 
 import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.psi.REPORT_UNRESOLVED_SYMBOLS
-import com.android.tools.metalava.model.psi.packageHtmlToJavadoc
+import com.android.tools.metalava.model.source.utils.packageHtmlToJavadoc
 import com.android.tools.metalava.testing.java
 import org.intellij.lang.annotations.Language
 import org.junit.Assert.assertEquals
@@ -29,6 +30,8 @@ class JavadocTest : DriverTest() {
     private fun checkStubs(
         @Language("JAVA") source: String,
         warnings: String? = "",
+        expectedFail: String? = null,
+        apiLint: String? = null,
         api: String? = null,
         extraArguments: Array<String> = emptyArray(),
         docStubs: Boolean = false,
@@ -40,8 +43,10 @@ class JavadocTest : DriverTest() {
             sourceFiles = sourceFiles,
             showAnnotations = showAnnotations,
             stubFiles = arrayOf(java(source)),
+            expectedFail = expectedFail,
             expectedIssues = warnings,
             checkCompilation = true,
+            apiLint = apiLint,
             api = api,
             extraArguments = extraArguments,
             docStubs = docStubs,
@@ -189,6 +194,18 @@ class JavadocTest : DriverTest() {
         checkStubs(
             extraArguments = arrayOf(ARG_SKIP_READING_COMMENTS),
             docStubs = false,
+            // Enable API lint to make sure that some issues will be reported.
+            apiLint = "",
+            expectedFail = DefaultLintErrorMessage,
+            // These warnings prove that lint is enabled and will report MutableBareField and
+            // MissingNullability, issues that would be reported on test.hidden.Hidden if it was not
+            // hidden by the package-info.java.
+            warnings =
+                """
+                    src/test/pkg1/SomeClass.java:29: error: Bare field importance must be marked final, or moved behind accessors if mutable [MutableBareField]
+                    src/test/pkg2/OtherClass.java:7: error: Missing nullability on field `foo` in class `class test.pkg2.OtherClass` [MissingNullability]
+                    src/test/pkg2/OtherClass.java:7: error: Bare field foo must be marked final, or moved behind accessors if mutable [MutableBareField]
+                """,
             sourceFiles =
                 arrayOf(
                     java(
@@ -233,7 +250,7 @@ class JavadocTest : DriverTest() {
                     public class OtherClass {
                         public static final int FOCUS_INPUT = 1;
                         public static final int FOCUS_ACCESSIBILITY = 2;
-                        public int foo;
+                        public String foo;
                         public void bar(int baz, boolean bar);
                     }
                     """
@@ -246,9 +263,25 @@ class JavadocTest : DriverTest() {
                     public class LocalClass {
                     }
                     """
+                    ),
+                    // Make sure that hiding a package by using `@hide` in the Javadoc of a
+                    // package-info.java file still works when allowReadingComments = false.
+                    java(
+                        """
+                            /** @hide */
+                            package test.hidden;
+                        """
+                    ),
+                    java(
+                        """
+                            package test.hidden;
+
+                            public class Hidden {
+                                public String bareMutableFieldMissingNullability;
+                            }
+                        """,
                     )
                 ),
-            warnings = "",
             source =
                 """
                     package test.pkg1;
@@ -680,13 +713,13 @@ class JavadocTest : DriverTest() {
                 public abstract class AsyncTaskLoader<D> {
                 public AsyncTaskLoader() { throw new RuntimeException("Stub!"); }
                 /**
-                 * Called if the task was canceled before it was completed.  Gives the class a chance
-                 * to clean up post-cancellation and to properly dispose of the result.
+                 * Sends the result of the load to the registered listener. Should only be called by subclasses.
                  *
-                 * @param data The value that was returned by {@link #loadInBackground}, or null
-                 * if the task threw {@link android.os.OperationCanceledException OperationCanceledException}.
+                 * Must be called from the process's main thread.
+                 *
+                 * @param data the result of the load
                  */
-                public void onCanceled(D data) { throw new RuntimeException("Stub!"); }
+                public void deliverResult(java.lang.Object data) { throw new RuntimeException("Stub!"); }
                 /**
                  * Called on a worker thread to perform the actual load and to return
                  * the result of the load operation.
@@ -709,13 +742,13 @@ class JavadocTest : DriverTest() {
                  */
                 public abstract java.lang.Object loadInBackground();
                 /**
-                 * Sends the result of the load to the registered listener. Should only be called by subclasses.
-                 *
-                 * Must be called from the process's main thread.
+                 * Called if the task was canceled before it was completed.  Gives the class a chance
+                 * to clean up post-cancellation and to properly dispose of the result.
                  *
-                 * @param data the result of the load
+                 * @param data The value that was returned by {@link #loadInBackground}, or null
+                 * if the task threw {@link android.os.OperationCanceledException OperationCanceledException}.
                  */
-                public void deliverResult(java.lang.Object data) { throw new RuntimeException("Stub!"); }
+                public void onCanceled(D data) { throw new RuntimeException("Stub!"); }
                 }
                 """
         )
diff --git a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
index 294828c43..01eb9c30a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
@@ -207,7 +207,7 @@ class KotlinInteropChecksTest : DriverTest() {
                         fun ok(int: Int = 0, int2: Int = 0) { }
                     }
 
-                    class Foo {
+                    class Foo(string: String = "default", long: Long = 0) {
                         fun ok1() { }
                         fun ok2(int: Int) { }
                         fun ok3(int: Int, int2: Int) { }
diff --git a/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
index 6bf6fc36e..200fc2494 100644
--- a/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
@@ -49,6 +49,9 @@ Usage: metalava main [options] [flags]...
   The default sub-command that is run if no sub-command is specified.
 
 Options:
+  --config-file <file>                       A configuration file that can be consumed by Metalava. This can be
+                                             specified multiple times in which case later config files will
+                                             override/merge with earlier ones.
   --api-class-resolution [api|api:classpath]
                                              Determines how class resolution is performed when loading API signature
                                              files. Any classes that cannot be found will be treated as empty.",
@@ -62,6 +65,8 @@ Options:
                                              annotation which is itself annotated with the given meta-annotation.
   --manifest <file>                          A manifest file, used to check permissions to cross check APIs and retrieve
                                              min_sdk_version. (default: no manifest)
+  --migrate-nullness <api file>              Compare nullness information with the previous stable API and mark newly
+                                             annotated APIs as under migration.
   --hide-sdk-extensions-newer-than INT       Ignore SDK extensions version INT and above. Used to exclude finalized but
                                              not yet released SDK extensions.
   --typedefs-in-signatures [none|ref|inline]
@@ -116,6 +121,8 @@ API sources:
 --classpath <paths>
                                              One or more directories or jars (separated by `:`) containing classes that
                                              should be on the classpath when parsing the source files
+--project <xmlfile>
+                                             Project description written in XML according to Lint's project model.
 --merge-qualifier-annotations <file>
                                              An external annotations file to merge and overlay the sources, or a
                                              directory of such files. Should be used for annotations intended for
@@ -140,9 +147,6 @@ API sources:
                                              Specifies that errors encountered during validation of nullability
                                              annotations should not be treated as errors. They will be written out to
                                              the file specified in --nullability-warnings-txt instead.
---hide-package <package>
-                                             Remove the given packages from the API even if they have not been marked
-                                             with @hide
 --hide-annotation <annotation class>
                                              Treat any elements annotated with the given annotation as hidden
 --show-unannotated
@@ -175,8 +179,6 @@ API sources:
 
 
 Extracting Signature Files:
---dex-api <file>
-                                             Generate a DEX signature descriptor file listing the APIs
 --proguard <file>
                                              Write a ProGuard keep file for the API
 --sdk-values <dir>
@@ -211,12 +213,6 @@ Generating Stubs:
                                              Documentation stubs (--doc-stubs) are not affected.)
 
 
-Diffs and Checks:
---migrate-nullness <api file>
-                                             Compare nullness information with the previous stable API and mark newly
-                                             annotated APIs as under migration.
-
-
 Extracting Annotations:
 --extract-annotations <zipfile>
                                              Extracts source annotations from the source files and writes them into the
diff --git a/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt
index 49b781c62..5e36749f1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/NormalizeOutputAnnotationTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -62,12 +63,9 @@ class NormalizeOutputAnnotationTest : DriverTest() {
                     """
                         )
                         .indented(),
-                    requiresPermissionSource
-                ),
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
+                    requiresPermissionSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             format = FileFormat.V4,
             api =
diff --git a/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt b/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
index 5fb335c91..802e02640 100644
--- a/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -30,36 +31,37 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.NonNull;
-                    import androidx.annotation.Nullable;
-                    public class MyTest {
-                        public Double convert0(Float f) { return null; }
-                        @Nullable public Double convert1(@NonNull Float f) { return null; }
-                        @Nullable public Double convert2(@NonNull Float f) { return null; }
-                        @NonNull public Double convert3(@Nullable Float f) { return null; }
-                        @NonNull public Double convert4(@NonNull Float f) { return null; }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.NonNull;
+                            import androidx.annotation.Nullable;
+                            public class MyTest {
+                                public Double convert0(Float f) { return null; }
+                                @Nullable public Double convert1(@NonNull Float f) { return null; }
+                                @Nullable public Double convert2(@NonNull Float f) { return null; }
+                                @NonNull public Double convert3(@Nullable Float f) { return null; }
+                                @NonNull public Double convert4(@NonNull Float f) { return null; }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
-                // Signature format: 3.0
-                package test.pkg {
-                  public class MyTest {
-                    ctor public MyTest();
-                    method public Double! convert0(Float!);
-                    method public Double? convert1(Float);
-                    method public Double? convert2(Float);
-                    method public Double convert3(Float?);
-                    method public Double convert4(Float);
-                  }
-                }
+                    // Signature format: 3.0
+                    package test.pkg {
+                      public class MyTest {
+                        ctor public MyTest();
+                        method public Double! convert0(Float!);
+                        method public Double? convert1(Float);
+                        method public Double? convert2(Float);
+                        method public Double convert3(Float?);
+                        method public Double convert4(Float);
+                      }
+                    }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -71,49 +73,50 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    public abstract class MyTest {
-                        private MyTest() { }
-                        @Nullable public Double convert1(Float f) { return null; }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public abstract class MyTest {
+                                private MyTest() { }
+                                @Nullable public Double convert1(Float f) { return null; }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public abstract class MyTest {
-                    method public Double convert1(Float);
-                  }
-                }
+                    package test.pkg {
+                      public abstract class MyTest {
+                        method public Double convert1(Float);
+                      }
+                    }
                 """,
             api =
                 """
-                package test.pkg {
-                  public abstract class MyTest {
-                    method @Nullable public Double convert1(Float);
-                  }
-                }
+                    package test.pkg {
+                      public abstract class MyTest {
+                        method @Nullable public Double convert1(Float);
+                      }
+                    }
                 """,
             stubFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public abstract class MyTest {
-                    MyTest() { throw new RuntimeException("Stub!"); }
-                    @androidx.annotation.RecentlyNullable
-                    public java.lang.Double convert1(java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    }
-                    """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public abstract class MyTest {
+                            MyTest() { throw new RuntimeException("Stub!"); }
+                            @androidx.annotation.RecentlyNullable
+                            public java.lang.Double convert1(java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            }
+                        """,
                     )
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -125,47 +128,48 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.NonNull;
-                    public abstract class MyTest {
-                        private MyTest() { }
-                        public Double convert1(@NonNull Float f) { return null; }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.NonNull;
+                            public abstract class MyTest {
+                                private MyTest() { }
+                                public Double convert1(@NonNull Float f) { return null; }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public abstract class MyTest {
-                    method public Double convert1(Float);
-                  }
-                }
+                    package test.pkg {
+                      public abstract class MyTest {
+                        method public Double convert1(Float);
+                      }
+                    }
                 """,
             api =
                 """
-                package test.pkg {
-                  public abstract class MyTest {
-                    method public Double convert1(@NonNull Float);
-                  }
-                }
+                    package test.pkg {
+                      public abstract class MyTest {
+                        method public Double convert1(@NonNull Float);
+                      }
+                    }
                 """,
             stubFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public abstract class MyTest {
-                    MyTest() { throw new RuntimeException("Stub!"); }
-                    public java.lang.Double convert1(@androidx.annotation.RecentlyNonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    )
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public abstract class MyTest {
+                            MyTest() { throw new RuntimeException("Stub!"); }
+                            public java.lang.Double convert1(@androidx.annotation.RecentlyNonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -177,69 +181,70 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    public class MyTest {
-                        public Double convert0(Float f) { return null; }
-                        @Nullable public Double convert1(@NonNull Float f) { return null; }
-                        @Nullable public Double convert2(@NonNull Float f) { return null; }
-                        @Nullable public Double convert3(@NonNull Float f) { return null; }
-                        @Nullable public Double convert4(@NonNull Float f) { return null; }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public class MyTest {
+                                public Double convert0(Float f) { return null; }
+                                @Nullable public Double convert1(@NonNull Float f) { return null; }
+                                @Nullable public Double convert2(@NonNull Float f) { return null; }
+                                @Nullable public Double convert3(@NonNull Float f) { return null; }
+                                @Nullable public Double convert4(@NonNull Float f) { return null; }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public class MyTest {
-                    ctor public MyTest();
-                    method public Double convert0(Float);
-                    method public Double convert1(Float);
-                    method @RecentlyNullable public Double convert2(@RecentlyNonNull Float);
-                    method @RecentlyNullable public Double convert3(@RecentlyNonNull Float);
-                    method @Nullable public Double convert4(@NonNull Float);
-                  }
-                }
+                    package test.pkg {
+                      public class MyTest {
+                        ctor public MyTest();
+                        method public Double convert0(Float);
+                        method public Double convert1(Float);
+                        method @RecentlyNullable public Double convert2(@RecentlyNonNull Float);
+                        method @RecentlyNullable public Double convert3(@RecentlyNonNull Float);
+                        method @Nullable public Double convert4(@NonNull Float);
+                      }
+                    }
                 """,
             api =
                 """
-                package test.pkg {
-                  public class MyTest {
-                    ctor public MyTest();
-                    method public Double convert0(Float);
-                    method @Nullable public Double convert1(@NonNull Float);
-                    method @Nullable public Double convert2(@NonNull Float);
-                    method @Nullable public Double convert3(@NonNull Float);
-                    method @Nullable public Double convert4(@NonNull Float);
-                  }
-                }
+                    package test.pkg {
+                      public class MyTest {
+                        ctor public MyTest();
+                        method public Double convert0(Float);
+                        method @Nullable public Double convert1(@NonNull Float);
+                        method @Nullable public Double convert2(@NonNull Float);
+                        method @Nullable public Double convert3(@NonNull Float);
+                        method @Nullable public Double convert4(@NonNull Float);
+                      }
+                    }
                 """,
             stubFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public class MyTest {
-                    public MyTest() { throw new RuntimeException("Stub!"); }
-                    public java.lang.Double convert0(java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    @androidx.annotation.RecentlyNullable
-                    public java.lang.Double convert1(@androidx.annotation.RecentlyNonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    @android.annotation.Nullable
-                    public java.lang.Double convert2(@android.annotation.NonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    @android.annotation.Nullable
-                    public java.lang.Double convert3(@android.annotation.NonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    @android.annotation.Nullable
-                    public java.lang.Double convert4(@android.annotation.NonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    )
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class MyTest {
+                            public MyTest() { throw new RuntimeException("Stub!"); }
+                            public java.lang.Double convert0(java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            @androidx.annotation.RecentlyNullable
+                            public java.lang.Double convert1(@androidx.annotation.RecentlyNonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            @android.annotation.Nullable
+                            public java.lang.Double convert2(@android.annotation.NonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            @android.annotation.Nullable
+                            public java.lang.Double convert3(@android.annotation.NonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            @android.annotation.Nullable
+                            public java.lang.Double convert4(@android.annotation.NonNull java.lang.Float f) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -251,49 +256,50 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    public class MyTest {
-                        public Double convert0(Float f) { return null; }
-                        @Nullable public Double convert1(@NonNull Float f) { return null; }
-                        @Nullable public Double convert2(@NonNull Float f) { return null; }
-                        @Nullable public Double convert3(@NonNull Float f) { return null; }
-                        @Nullable public Double convert4(@NonNull Float f) { return null; }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public class MyTest {
+                                public Double convert0(Float f) { return null; }
+                                @Nullable public Double convert1(@NonNull Float f) { return null; }
+                                @Nullable public Double convert2(@NonNull Float f) { return null; }
+                                @Nullable public Double convert3(@NonNull Float f) { return null; }
+                                @Nullable public Double convert4(@NonNull Float f) { return null; }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public class MyTest {
-                    ctor public MyTest();
-                    method public Double convert0(Float);
-                    method public Double convert1(Float);
-                    method @RecentlyNullable public Double convert2(@RecentlyNonNull Float);
-                    method @RecentlyNullable public Double convert3(@RecentlyNonNull Float);
-                    method @Nullable public Double convert4(@NonNull Float);
-                  }
-                }
+                    package test.pkg {
+                      public class MyTest {
+                        ctor public MyTest();
+                        method public Double convert0(Float);
+                        method public Double convert1(Float);
+                        method @RecentlyNullable public Double convert2(@RecentlyNonNull Float);
+                        method @RecentlyNullable public Double convert3(@RecentlyNonNull Float);
+                        method @Nullable public Double convert4(@NonNull Float);
+                      }
+                    }
                 """,
             api =
                 """
-                // Signature format: 3.0
-                package test.pkg {
-                  public class MyTest {
-                    ctor public MyTest();
-                    method public Double! convert0(Float!);
-                    method public Double? convert1(Float);
-                    method public Double? convert2(Float);
-                    method public Double? convert3(Float);
-                    method public Double? convert4(Float);
-                  }
-                }
+                    // Signature format: 3.0
+                    package test.pkg {
+                      public class MyTest {
+                        ctor public MyTest();
+                        method public Double! convert0(Float!);
+                        method public Double? convert1(Float);
+                        method public Double? convert2(Float);
+                        method public Double? convert3(Float);
+                        method public Double? convert4(Float);
+                      }
+                    }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -305,47 +311,47 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    public class Test {
-                        public @libcore.util.NonNull Object compute() {
-                            return 5;
-                        }
-                    }
-                    """
+                            package test.pkg;
+                            public class Test {
+                                public @libcore.util.NonNull Object compute() {
+                                    return 5;
+                                }
+                            }
+                        """
                     ),
                     java(
                         """
-                    package libcore.util;
-                    import static java.lang.annotation.ElementType.TYPE_USE;
-                    import static java.lang.annotation.ElementType.TYPE_PARAMETER;
-                    import static java.lang.annotation.RetentionPolicy.SOURCE;
-                    import java.lang.annotation.Documented;
-                    import java.lang.annotation.Retention;
-                    @Documented
-                    @Retention(SOURCE)
-                    @Target({TYPE_USE})
-                    public @interface NonNull {
-                       int from() default Integer.MIN_VALUE;
-                       int to() default Integer.MAX_VALUE;
-                    }
-                    """
-                    )
+                            package libcore.util;
+                            import static java.lang.annotation.ElementType.TYPE_USE;
+                            import static java.lang.annotation.ElementType.TYPE_PARAMETER;
+                            import static java.lang.annotation.RetentionPolicy.SOURCE;
+                            import java.lang.annotation.Documented;
+                            import java.lang.annotation.Retention;
+                            @Documented
+                            @Retention(SOURCE)
+                            @Target({TYPE_USE})
+                            public @interface NonNull {
+                               int from() default Integer.MIN_VALUE;
+                               int to() default Integer.MAX_VALUE;
+                            }
+                        """
+                    ),
                 ),
             api =
                 """
-                package libcore.util {
-                  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public @interface NonNull {
-                    method public abstract int from() default java.lang.Integer.MIN_VALUE;
-                    method public abstract int to() default java.lang.Integer.MAX_VALUE;
-                  }
-                }
-                package test.pkg {
-                  public class Test {
-                    ctor public Test();
-                    method @NonNull public Object compute();
-                  }
-                }
-                """
+                    package libcore.util {
+                      @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public @interface NonNull {
+                        method public abstract int from() default java.lang.Integer.MIN_VALUE;
+                        method public abstract int to() default java.lang.Integer.MAX_VALUE;
+                      }
+                    }
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                        method @NonNull public Object compute();
+                      }
+                    }
+                """,
         )
     }
 
@@ -357,53 +363,54 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    import java.util.List;
-                    public class Test {
-                        public @Nullable Integer compute1(@Nullable java.util.List<@Nullable String> list) {
-                            return 5;
-                        }
-                        public @Nullable Integer compute2(@Nullable java.util.List<@Nullable List<?>> list) {
-                            return 5;
-                        }
-                        public Integer compute3(@NonNull String @Nullable [] @Nullable [] array) {
-                            return 5;
-                        }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            import java.util.List;
+                            public class Test {
+                                public @Nullable Integer compute1(@Nullable java.util.List<@Nullable String> list) {
+                                    return 5;
+                                }
+                                public @Nullable Integer compute2(@Nullable java.util.List<@Nullable List<?>> list) {
+                                    return 5;
+                                }
+                                public Integer compute3(@NonNull String @Nullable [] @Nullable [] array) {
+                                    return 5;
+                                }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     """
-                // Signature format: 2.0
-                package test.pkg {
-                  public class Test {
-                    ctor public Test();
-                    method @Nullable public @Nullable Integer compute1(@Nullable java.util.List<java.lang.@Nullable String>);
-                    method @Nullable public @Nullable Integer compute2(@Nullable java.util.List<java.util.@Nullable List<?>>);
-                    method public Integer compute3(@NonNull String[][]);
-                  }
-                }
-                """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public class Test {
+                            ctor public Test();
+                            method @Nullable public @Nullable Integer compute1(@Nullable java.util.List<java.lang.@Nullable String>);
+                            method @Nullable public @Nullable Integer compute2(@Nullable java.util.List<java.util.@Nullable List<?>>);
+                            method public Integer compute3(@NonNull String[][]);
+                          }
+                        }
+                    """
                 } else {
                     """
-                // Signature format: 2.0
-                package test.pkg {
-                  public class Test {
-                    ctor public Test();
-                    method @Nullable public Integer compute1(@Nullable java.util.List<java.lang.String>);
-                    method @Nullable public Integer compute2(@Nullable java.util.List<java.util.List<?>>);
-                    method public Integer compute3(@NonNull String[][]);
-                  }
-                }
-                """
-                }
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public class Test {
+                            ctor public Test();
+                            method @Nullable public Integer compute1(@Nullable java.util.List<java.lang.String>);
+                            method @Nullable public Integer compute2(@Nullable java.util.List<java.util.List<?>>);
+                            method public Integer compute3(@NonNull String[][]);
+                          }
+                        }
+                    """
+                },
         )
     }
 
@@ -415,46 +422,47 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    import java.util.List;
-                    public class Test {
-                        public @Nullable Integer compute1(@Nullable java.util.List<@Nullable String> list) {
-                            return 5;
-                        }
-                        public @Nullable Integer compute2(@NonNull java.util.List<@NonNull List<?>> list) {
-                            return 5;
-                        }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            import java.util.List;
+                            public class Test {
+                                public @Nullable Integer compute1(@Nullable java.util.List<@Nullable String> list) {
+                                    return 5;
+                                }
+                                public @Nullable Integer compute2(@NonNull java.util.List<@NonNull List<?>> list) {
+                                    return 5;
+                                }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     """
-                package test.pkg {
-                  public class Test {
-                    ctor public Test();
-                    method @Nullable public Integer compute1(@Nullable java.util.List<@Nullable java.lang.String>);
-                    method @Nullable public Integer compute2(@NonNull java.util.List<@NonNull java.util.List<?>>);
-                  }
-                }
-                """
+                        package test.pkg {
+                          public class Test {
+                            ctor public Test();
+                            method @Nullable public Integer compute1(@Nullable java.util.List<@Nullable java.lang.String>);
+                            method @Nullable public Integer compute2(@NonNull java.util.List<@NonNull java.util.List<?>>);
+                          }
+                        }
+                    """
                 } else {
                     """
-                package test.pkg {
-                  public class Test {
-                    ctor public Test();
-                    method @Nullable public Integer compute1(@Nullable java.util.List<java.lang.String>);
-                    method @Nullable public Integer compute2(@NonNull java.util.List<java.util.List<?>>);
-                  }
-                }
-                """
-                }
+                        package test.pkg {
+                          public class Test {
+                            ctor public Test();
+                            method @Nullable public Integer compute1(@Nullable java.util.List<java.lang.String>);
+                            method @Nullable public Integer compute2(@NonNull java.util.List<java.util.List<?>>);
+                          }
+                        }
+                    """
+                },
         )
     }
 
@@ -466,70 +474,71 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    public class Foo {
-                       public static char @NonNull [] toChars(int codePoint) { return new char[0]; }
-                       public static int codePointAt(char @NonNull [] a, int index) { throw new RuntimeException("Stub!"); }
-                       public <T> T @NonNull [] toArray(T @NonNull [] a);
-                       // New APIs should not be marked *recently* nullable; they're fully nullable
-                       public static @NonNull String newMethod(@Nullable String argument) { return ""; }
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public class Foo {
+                               public static char @NonNull [] toChars(int codePoint) { return new char[0]; }
+                               public static int codePointAt(char @NonNull [] a, int index) { throw new RuntimeException("Stub!"); }
+                               public <T> T @NonNull [] toArray(T @NonNull [] a);
+                               // New APIs should not be marked *recently* nullable; they're fully nullable
+                               public static @NonNull String newMethod(@Nullable String argument) { return ""; }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             // TODO: Handle multiple nullness annotations
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public static int codePointAt(char[], int);
-                    method public <T> T[] toArray(T[]);
-                    method public static char[] toChars(int);
-                  }
-                }
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public static int codePointAt(char[], int);
+                        method public <T> T[] toArray(T[]);
+                        method public static char[] toChars(int);
+                      }
+                    }
                 """,
             stubFiles =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     arrayOf(
                         java(
                             """
-                        package test.pkg;
-                        @SuppressWarnings({"unchecked", "deprecation", "all"})
-                        public class Foo {
-                        public Foo() { throw new RuntimeException("Stub!"); }
-                        public static char @androidx.annotation.RecentlyNonNull [] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
-                        public static int codePointAt(char @androidx.annotation.RecentlyNonNull [] a, int index) { throw new RuntimeException("Stub!"); }
-                        public <T> T @android.annotation.RecentlyNonNull [] toArray(T @androidx.annotation.RecentlyNonNull [] a) { throw new RuntimeException("Stub!"); }
-                        @androidx.annotation.NonNull
-                        public static java.lang.String newMethod(@android.annotation.Nullable java.lang.String argument) { throw new RuntimeException("Stub!"); }
-                        }
-                    """
-                        )
+                                package test.pkg;
+                                @SuppressWarnings({"unchecked", "deprecation", "all"})
+                                public class Foo {
+                                public Foo() { throw new RuntimeException("Stub!"); }
+                                public static int codePointAt(char @androidx.annotation.RecentlyNonNull [] a, int index) { throw new RuntimeException("Stub!"); }
+                                @androidx.annotation.NonNull
+                                public static java.lang.String newMethod(@android.annotation.Nullable java.lang.String argument) { throw new RuntimeException("Stub!"); }
+                                public <T> T @android.annotation.RecentlyNonNull [] toArray(T @androidx.annotation.RecentlyNonNull [] a) { throw new RuntimeException("Stub!"); }
+                                public static char @androidx.annotation.RecentlyNonNull [] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
+                                }
+                            """
+                        ),
                     )
                 } else {
                     arrayOf(
                         java(
                             """
-                        package test.pkg;
-                        @SuppressWarnings({"unchecked", "deprecation", "all"})
-                        public class Foo {
-                        public Foo() { throw new RuntimeException("Stub!"); }
-                        public static char[] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
-                        public static int codePointAt(char[] a, int index) { throw new RuntimeException("Stub!"); }
-                        public <T> T[] toArray(T[] a) { throw new RuntimeException("Stub!"); }
-                        @android.annotation.NonNull
-                        public static java.lang.String newMethod(@android.annotation.Nullable java.lang.String argument) { throw new RuntimeException("Stub!"); }
-                        }
-                        """
-                        )
+                                package test.pkg;
+                                @SuppressWarnings({"unchecked", "deprecation", "all"})
+                                public class Foo {
+                                public Foo() { throw new RuntimeException("Stub!"); }
+                                public static int codePointAt(char[] a, int index) { throw new RuntimeException("Stub!"); }
+                                @android.annotation.NonNull
+                                public static java.lang.String newMethod(@android.annotation.Nullable java.lang.String argument) { throw new RuntimeException("Stub!"); }
+                                public <T> T[] toArray(T[] a) { throw new RuntimeException("Stub!"); }
+                                public static char[] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
+                                }
+                            """
+                        ),
                     )
-                }
+                },
         )
     }
 
@@ -541,64 +550,65 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
-                    public class Foo {
-                       public static char @NonNull [] toChars(int codePoint) { return new char[0]; }
-                       public static int codePointAt(char @NonNull [] a, int index) { throw new RuntimeException("Stub!"); }
-                       public <T> T @NonNull [] toArray(T @NonNull [] a);
-                    }
-                    """
+                            package test.pkg;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            public class Foo {
+                               public static char @NonNull [] toChars(int codePoint) { return new char[0]; }
+                               public static int codePointAt(char @NonNull [] a, int index) { throw new RuntimeException("Stub!"); }
+                               public <T> T @NonNull [] toArray(T @NonNull [] a);
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             // TODO: Handle multiple nullness annotations
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public static int codePointAt(char[], int);
-                    method public <T> T[] toArray(T[]);
-                    method public static char[] toChars(int);
-                  }
-                }
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public static int codePointAt(char[], int);
+                        method public <T> T[] toArray(T[]);
+                        method public static char[] toChars(int);
+                      }
+                    }
                 """,
             stubFiles =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     arrayOf(
                         java(
                             """
-                        package test.pkg;
-                        @SuppressWarnings({"unchecked", "deprecation", "all"})
-                        public class Foo {
-                        public Foo() { throw new RuntimeException("Stub!"); }
-                        public static char @androidx.annotation.RecentlyNonNull [] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
-                        public static int codePointAt(char @androidx.annotation.RecentlyNonNull [] a, int index) { throw new RuntimeException("Stub!"); }
-                        public <T> T @androidx.annotation.RecentlyNonNull [] toArray(T @androidx.annotation.RecentlyNonNull [] a) { throw new RuntimeException("Stub!"); }
-                        }
-                        """
-                        )
+                                package test.pkg;
+                                @SuppressWarnings({"unchecked", "deprecation", "all"})
+                                public class Foo {
+                                public Foo() { throw new RuntimeException("Stub!"); }
+                                public static int codePointAt(char @androidx.annotation.RecentlyNonNull [] a, int index) { throw new RuntimeException("Stub!"); }
+                                public <T> T @androidx.annotation.RecentlyNonNull [] toArray(T @androidx.annotation.RecentlyNonNull [] a) { throw new RuntimeException("Stub!"); }
+                                public static char @androidx.annotation.RecentlyNonNull [] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
+                                }
+                            """
+                        ),
                     )
                 } else {
                     arrayOf(
                         java(
                             """
-                        package test.pkg;
-                        @SuppressWarnings({"unchecked", "deprecation", "all"})
-                        public class Foo {
-                        public Foo() { throw new RuntimeException("Stub!"); }
-                        public static char[] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
-                        public static int codePointAt(char[] a, int index) { throw new RuntimeException("Stub!"); }
-                        public <T> T[] toArray(T[] a) { throw new RuntimeException("Stub!"); }
-                        }
-                        """
-                        )
+                                package test.pkg;
+                                @SuppressWarnings({"unchecked", "deprecation", "all"})
+                                public class Foo {
+                                public Foo() { throw new RuntimeException("Stub!"); }
+                                public static int codePointAt(char[] a, int index) { throw new RuntimeException("Stub!"); }
+                                public <T> T[] toArray(T[] a) { throw new RuntimeException("Stub!"); }
+                                public static char[] toChars(int codePoint) { throw new RuntimeException("Stub!"); }
+                                }
+                            """
+                        ),
                     )
-                }
+                },
         )
     }
 
@@ -610,69 +620,70 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import androidx.annotation.NonNull;
-                    import java.lang.reflect.TypeVariable;
+                            package test.pkg;
+                            import androidx.annotation.NonNull;
+                            import java.lang.reflect.TypeVariable;
 
-                    public class Foo {
-                        @NonNull public java.lang.reflect.Constructor<?> @NonNull [] getConstructors() {
-                            return null;
-                        }
+                            public class Foo {
+                                @NonNull public java.lang.reflect.Constructor<?> @NonNull [] getConstructors() {
+                                    return null;
+                                }
 
-                        public synchronized @NonNull TypeVariable<@NonNull Class<T>> @NonNull [] getTypeParameters() {
-                            return null;
-                        }
-                    }
-                    """
+                                public synchronized @NonNull TypeVariable<@NonNull Class<T>> @NonNull [] getTypeParameters() {
+                                    return null;
+                                }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public class Foo {
-                    ctor public Foo();
-                    method public java.lang.reflect.Constructor<?>[] getConstructors();
-                    method public synchronized java.lang.reflect.TypeVariable<@java.lang.Class<T>>[] getTypeParameters();
-                  }
-                }
-            """,
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public java.lang.reflect.Constructor<?>[] getConstructors();
+                        method public synchronized java.lang.reflect.TypeVariable<@java.lang.Class<T>>[] getTypeParameters();
+                      }
+                    }
+                """,
             stubFiles =
                 if (SUPPORT_TYPE_USE_ANNOTATIONS) {
                     arrayOf(
                         java(
                             """
-                        package test.pkg;
-                        @SuppressWarnings({"unchecked", "deprecation", "all"})
-                        public class Foo {
-                        public Foo() { throw new RuntimeException("Stub!"); }
-                        @androidx.annotation.RecentlyNonNull
-                        public java.lang.reflect.Constructor<?> @androidx.annotation.RecentlyNonNull [] getConstructors() { throw new RuntimeException("Stub!"); }
-                        @androidx.annotation.RecentlyNonNull
-                        public synchronized java.lang.reflect.TypeVariable<java.lang.@androidx.annotation.RecentlyNonNull Class<T>> @androidx.annotation.RecentlyNonNull [] getTypeParameters() { throw new RuntimeException("Stub!"); }
-                        }
-                        """
-                        )
+                                package test.pkg;
+                                @SuppressWarnings({"unchecked", "deprecation", "all"})
+                                public class Foo {
+                                public Foo() { throw new RuntimeException("Stub!"); }
+                                @androidx.annotation.RecentlyNonNull
+                                public java.lang.reflect.Constructor<?> @androidx.annotation.RecentlyNonNull [] getConstructors() { throw new RuntimeException("Stub!"); }
+                                @androidx.annotation.RecentlyNonNull
+                                public synchronized java.lang.reflect.TypeVariable<java.lang.@androidx.annotation.RecentlyNonNull Class<T>> @androidx.annotation.RecentlyNonNull [] getTypeParameters() { throw new RuntimeException("Stub!"); }
+                                }
+                            """
+                        ),
                     )
                 } else {
                     arrayOf(
                         java(
                             """
-                        package test.pkg;
-                        @SuppressWarnings({"unchecked", "deprecation", "all"})
-                        public class Foo {
-                        public Foo() { throw new RuntimeException("Stub!"); }
-                        @androidx.annotation.RecentlyNonNull
-                        public java.lang.reflect.Constructor<?>[] getConstructors() { throw new RuntimeException("Stub!"); }
-                        @androidx.annotation.RecentlyNonNull
-                        public synchronized java.lang.reflect.TypeVariable<java.lang.Class<T>>[] getTypeParameters() { throw new RuntimeException("Stub!"); }
-                        }
-                        """
-                        )
+                                package test.pkg;
+                                @SuppressWarnings({"unchecked", "deprecation", "all"})
+                                public class Foo {
+                                public Foo() { throw new RuntimeException("Stub!"); }
+                                @androidx.annotation.RecentlyNonNull
+                                public java.lang.reflect.Constructor<?>[] getConstructors() { throw new RuntimeException("Stub!"); }
+                                @androidx.annotation.RecentlyNonNull
+                                public synchronized java.lang.reflect.TypeVariable<java.lang.Class<T>>[] getTypeParameters() { throw new RuntimeException("Stub!"); }
+                                }
+                            """
+                        ),
                     )
-                }
+                },
         )
     }
 
@@ -685,190 +696,235 @@ class NullnessMigrationTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
+                            package test.pkg;
 
-                    import androidx.annotation.NonNull;
-                    import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            import androidx.annotation.Nullable;
 
-                    public interface Appendable {
-                        @NonNull Appendable append(@Nullable java.lang.CharSequence csq) throws IOException;
-                    }
-                    """
+                            public interface Appendable {
+                                @NonNull Appendable append(@Nullable java.lang.CharSequence csq) throws IOException;
+                            }
+                        """
                     ),
                     java(
                         """
-                    package test.pkg;
+                            package test.pkg;
 
-                    import androidx.annotation.NonNull;
-                    import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
+                            import androidx.annotation.Nullable;
 
-                    /** @hide */
-                    @android.annotation.SystemApi
-                    public interface ForSystemUse {
-                        @NonNull Object foo(@Nullable String foo);
-                    }
-                    """
+                            public class PublicClass {
+                                public PublicClass(@Nullable String s) {}
+                                @Nullable public String method(@NonNull Integer i) {}
+                                @Nullable public String field;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+
+                            import androidx.annotation.NonNull;
+                            import androidx.annotation.Nullable;
+
+                            /** @hide */
+                            @android.annotation.SystemApi
+                            public class ForSystemUse {
+                                public ForSystemUse(@NonNull String s) {}
+                                @NonNull public Object foo(@Nullable String foo) {return "";}
+                                @Nullable public String bar;
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                ),
+            migrateNullsApiList =
+                listOf(
+                    """
+                        package test.pkg {
+                          public interface Appendable {
+                            method public Appendable append(java.lang.CharSequence csq) throws IOException;
+                          }
+                          public class PublicClass {
+                            ctor public PublicClass(String);
+                            method public String method(Integer);
+                            field public String field;
+                          }
+                        }
+                    """,
+                    """
+                        package test.pkg {
+                          public class ForSystemUse {
+                            ctor public ForSystemUse(String);
+                            method public Object foo(String foo);
+                            field public String bar;
+                          }
+                        }
+                    """,
                 ),
-            migrateNullsApi =
-                """
-                package test.pkg {
-                  public interface Appendable {
-                    method public Appendable append(java.lang.CharSequence csq) throws IOException;
-                  }
-                  public class ForSystemUse {
-                    method public Object foo(String foo);
-                  }
-                }
-            """,
             stubFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public interface Appendable {
-                    @androidx.annotation.RecentlyNonNull
-                    public test.pkg.Appendable append(@androidx.annotation.RecentlyNullable java.lang.CharSequence csq);
-                    }
-                    """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public interface Appendable {
+                            @androidx.annotation.RecentlyNonNull
+                            public test.pkg.Appendable append(@androidx.annotation.RecentlyNullable java.lang.CharSequence csq);
+                            }
+                        """
                     ),
                     java(
+                        // TODO(b/347885819): The `field` should be `@RecentlyNullable`.
                         """
-                    package test.pkg;
-                    /** @hide */
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public interface ForSystemUse {
-                    @androidx.annotation.RecentlyNonNull
-                    public java.lang.Object foo(@androidx.annotation.RecentlyNullable java.lang.String foo);
-                    }
-                    """
-                    )
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class PublicClass {
+                            public PublicClass(@androidx.annotation.RecentlyNullable java.lang.String s) { throw new RuntimeException("Stub!"); }
+                            @androidx.annotation.RecentlyNullable
+                            public java.lang.String method(@androidx.annotation.RecentlyNonNull java.lang.Integer i) { throw new RuntimeException("Stub!"); }
+                            @androidx.annotation.RecentlyNullable public java.lang.String field;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            /** @hide */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class ForSystemUse {
+                            public ForSystemUse(@androidx.annotation.RecentlyNonNull java.lang.String s) { throw new RuntimeException("Stub!"); }
+                            @androidx.annotation.RecentlyNonNull
+                            public java.lang.Object foo(@androidx.annotation.RecentlyNullable java.lang.String foo) { throw new RuntimeException("Stub!"); }
+                            @androidx.annotation.RecentlyNullable public java.lang.String bar;
+                            }
+                        """
+                    ),
                 ),
             api =
                 """
-                package test.pkg {
-                  public interface ForSystemUse {
-                    method @NonNull public Object foo(@Nullable String);
-                  }
-                }
-                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class ForSystemUse {
+                        ctor public ForSystemUse(@NonNull String);
+                        method @NonNull public Object foo(@Nullable String);
+                        field @Nullable public String bar;
+                      }
+                    }
+                """,
         )
     }
 
     @Test
     fun `Test inherited methods`() {
         check(
-            expectedIssues = """
-                """,
             migrateNullsApi =
                 """
-                package test.pkg {
-                  public class Child1 extends test.pkg.Parent {
-                  }
-                  public class Child2 extends test.pkg.Parent {
-                    method public void method0(java.lang.String, int);
-                    method public void method4(java.lang.String, int);
-                  }
-                  public class Parent {
-                    method public void method1(java.lang.String, int);
-                    method public void method2(java.lang.String, int);
-                    method public void method3(java.lang.String, int);
-                  }
-                }
+                    package test.pkg {
+                      public class Child1 extends test.pkg.Parent {
+                      }
+                      public class Child2 extends test.pkg.Parent {
+                        method public void method0(java.lang.String, int);
+                        method public void method4(java.lang.String, int);
+                      }
+                      public class Parent {
+                        method public void method1(java.lang.String, int);
+                        method public void method2(java.lang.String, int);
+                        method public void method3(java.lang.String, int);
+                      }
+                    }
                 """,
             sourceFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
+                            package test.pkg;
 
-                    import androidx.annotation.NonNull;
+                            import androidx.annotation.NonNull;
 
-                    public class Child1 extends Parent {
-                        private Child1() {}
-                        @Override
-                        public void method1(@NonNull String first, int second) {
-                        }
-                    }
-                    """
+                            public class Child1 extends Parent {
+                                private Child1() {}
+                                @Override
+                                public void method1(@NonNull String first, int second) {
+                                }
+                            }
+                        """
                     ),
                     java(
                         """
-                    package test.pkg;
+                            package test.pkg;
 
-                    import androidx.annotation.NonNull;
+                            import androidx.annotation.NonNull;
 
-                    public class Child2 extends Parent {
-                        private Child2() {}
-                        @Override
-                        public void method0(String first, int second) {
-                        }
-                        @Override
-                        public void method1(String first, int second) {
-                        }
-                        @Override
-                        public void method2(@NonNull String first, int second) {
-                        }
-                        @Override
-                        public void method3(String first, int second) {
-                        }
-                        @Override
-                        public void method4(String first, int second) {
-                        }
-                    }
-                    """
+                            public class Child2 extends Parent {
+                                private Child2() {}
+                                @Override
+                                public void method0(String first, int second) {
+                                }
+                                @Override
+                                public void method1(String first, int second) {
+                                }
+                                @Override
+                                public void method2(@NonNull String first, int second) {
+                                }
+                                @Override
+                                public void method3(String first, int second) {
+                                }
+                                @Override
+                                public void method4(String first, int second) {
+                                }
+                            }
+                        """
                     ),
                     java(
                         """
-                    package test.pkg;
+                            package test.pkg;
 
-                    import androidx.annotation.Nullable;
-                    import androidx.annotation.NonNull;
+                            import androidx.annotation.Nullable;
+                            import androidx.annotation.NonNull;
 
-                    public class Parent {
-                        private Parent() { }
-                        public void method1(String first, int second) {
-                        }
-                        public void method2(@NonNull String first, int second) {
-                        }
-                        public void method3(String first, int second) {
-                        }
-                    }
-                    """
+                            public class Parent {
+                                private Parent() { }
+                                public void method1(String first, int second) {
+                                }
+                                public void method2(@NonNull String first, int second) {
+                                }
+                                public void method3(String first, int second) {
+                                }
+                            }
+                        """
                     ),
                     androidxNonNullSource,
-                    androidxNullableSource
+                    androidxNullableSource,
                 ),
             stubFiles =
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public class Child1 extends test.pkg.Parent {
-                    Child1() { throw new RuntimeException("Stub!"); }
-                    public void method1(@androidx.annotation.RecentlyNonNull java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
-                    }
-                    """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Child1 extends test.pkg.Parent {
+                            Child1() { throw new RuntimeException("Stub!"); }
+                            public void method1(@androidx.annotation.RecentlyNonNull java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
                     ),
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public class Child2 extends test.pkg.Parent {
-                    Child2() { throw new RuntimeException("Stub!"); }
-                    public void method0(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
-                    public void method1(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
-                    public void method2(@androidx.annotation.RecentlyNonNull java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
-                    public void method3(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
-                    public void method4(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    )
-                )
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Child2 extends test.pkg.Parent {
+                            Child2() { throw new RuntimeException("Stub!"); }
+                            public void method0(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
+                            public void method1(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
+                            public void method2(@androidx.annotation.RecentlyNonNull java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
+                            public void method3(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
+                            public void method4(java.lang.String first, int second) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
+                ),
         )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
index 852b202d8..54e949e93 100644
--- a/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
@@ -90,7 +90,7 @@ Sub-commands:
   help                                       Provides help for general metalava concepts
   jar-to-jdiff                               Convert a jar file into a file in the JDiff XML format.
   merge-signatures                           Merge multiple signature files together into a single file.
-  signature-to-dex                           Convert an API signature file into a file containing a list of DEX
+  signature-to-dex                           Convert API signature files into a file containing a list of DEX
                                              signatures.
   signature-to-jdiff                         Convert an API signature file into a file in the JDiff XML format.
   update-signature-header                    Updates the header of signature files to a different format.
@@ -111,7 +111,7 @@ Sub-commands:
         assertEquals(
             """
 
-                metalava version: 1.0.0-alpha10
+                metalava version: 1.0.0-alpha12
 
             """
                 .trimIndent(),
diff --git a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
new file mode 100644
index 000000000..ba34a1843
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import com.android.tools.metalava.testing.xml
+import org.junit.Test
+
+@RequiresCapabilities(Capability.KOTLIN)
+class ProjectDescriptionTest : DriverTest() {
+
+    @Test
+    fun `conflict declarations`() {
+        // Example from b/364480872
+        // Conflict declarations in Foo.java and Foo.kt are intentional.
+        // project.xml will use "androidMain" as root so that it can discard one in jvmMain.
+        check(
+            commonSourceFiles =
+                arrayOf(
+                    kotlin(
+                        "commonMain/src/some/common/Bogus.kt",
+                        """
+                            // bogus file to trigger multi-folder structure
+                            package some.common
+
+                            class Bogus
+                        """
+                    )
+                ),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        "androidMain/src/some/pkg/Foo.kt",
+                        """
+                            package some.pkg
+
+                            class Foo {
+                              companion object {
+                                @JvmStatic
+                                public fun foo(x: String): String {
+                                  return x
+                                }
+                              }
+                            }
+                        """
+                    ),
+                    java(
+                        "androidMain/src/test/Bar.java",
+                        """
+                            package test;
+
+                            import some.pkg.Foo;
+
+                            public class Bar {
+                                public String bar(String x) {
+                                    return Foo.foo(x);
+                                }
+                            }
+                        """
+                    ),
+                    java(
+                        "jvmMain/src/some/pkg/Foo.java",
+                        """
+                            package some.pkg;
+
+                            public class Foo {
+                                public static String foo(String x) {
+                                    return x;
+                                }
+                            }
+                        """
+                    ),
+                ),
+            projectDescription =
+                xml(
+                    "project.xml",
+                    """
+                        <project>
+                          <module name="app" android="true" library="false">
+                            <src file="androidMain/src/some/pkg/Foo.kt" />
+                            <src file="androidMain/src/test/Bar.java" />
+                          </module>
+                        </project>
+                    """
+                ),
+            api =
+                """
+                package some.pkg {
+                  public final class Foo {
+                    ctor public Foo();
+                    field public static final some.pkg.Foo.Companion Companion;
+                  }
+                  public static final class Foo.Companion {
+                    method public String foo(String x);
+                  }
+                }
+                package test {
+                  public class Bar {
+                    ctor public Bar();
+                    method public String! bar(String!);
+                  }
+                }
+                """
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
index eea746db7..2148bd189 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
@@ -5,6 +5,7 @@ import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -52,12 +53,9 @@ class ShowAnnotationTest : DriverTest() {
                     }
                 """
                     ),
-                    systemApiSource
-                ),
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -112,12 +110,9 @@ class ShowAnnotationTest : DriverTest() {
                     }
                 """
                     ),
-                    systemApiSource
-                ),
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -174,14 +169,14 @@ class ShowAnnotationTest : DriverTest() {
                     }
                     """
                     ),
-                    testApiSource
+                    testApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             api =
                 """
@@ -232,7 +227,9 @@ class ShowAnnotationTest : DriverTest() {
                         long CONSTANT3 = 42;
                     }
                     """
-                    )
+                    ),
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             stubFiles =
                 arrayOf(
@@ -271,8 +268,6 @@ class ShowAnnotationTest : DriverTest() {
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 )
         )
     }
@@ -314,14 +309,14 @@ class ShowAnnotationTest : DriverTest() {
                     }
                 """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_SINGLE_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             api =
                 """
@@ -421,15 +416,15 @@ class ShowAnnotationTest : DriverTest() {
                     }
                     """
                     ),
-                    restrictToSource
+                    restrictToSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_UNANNOTATED,
                     ARG_SHOW_ANNOTATION,
                     "androidx.annotation.RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP)",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation"
                 ),
             api =
                 """
@@ -477,6 +472,7 @@ class ShowAnnotationTest : DriverTest() {
                     java(
                         """
                     package test.annotation;
+                    /** @hide */
                     public @interface Api {
                         enum Type {A, B}
                         Type type() default Type.A;
@@ -489,8 +485,6 @@ class ShowAnnotationTest : DriverTest() {
                     ARG_SHOW_UNANNOTATED,
                     ARG_SHOW_ANNOTATION,
                     "test.annotation.Api(type=test.annotation.Api.Type.A)",
-                    ARG_HIDE_PACKAGE,
-                    "test.annotation"
                 ),
             api =
                 """
@@ -538,7 +532,6 @@ class ShowAnnotationTest : DriverTest() {
                   }
                 }
                 """,
-            extraArguments = arrayOf(ARG_HIDE_ANNOTATION, "androidx.annotation.IntDef")
         )
     }
 
@@ -591,7 +584,9 @@ class ShowAnnotationTest : DriverTest() {
                     }
                     """
                     ),
-                    restrictToSource
+                    restrictToSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             expectedIssues = null,
             api =
@@ -613,13 +608,7 @@ class ShowAnnotationTest : DriverTest() {
                 }
                 """,
             extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "androidx.annotation.RestrictTo",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
-                    ARG_SHOW_UNANNOTATED
-                )
+                arrayOf(ARG_SHOW_ANNOTATION, "androidx.annotation.RestrictTo", ARG_SHOW_UNANNOTATED)
         )
     }
 
@@ -644,11 +633,14 @@ class ShowAnnotationTest : DriverTest() {
                         """
                     package test.annotation;
 
+                    /** @hide */
                     public @interface Api {
                         String value();
                     }
                     """
-                    )
+                    ),
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             classpath =
                 arrayOf(
@@ -681,8 +673,6 @@ class ShowAnnotationTest : DriverTest() {
                     ARG_SHOW_UNANNOTATED,
                     ARG_SHOW_ANNOTATION,
                     "test.annotation.Api",
-                    ARG_HIDE_PACKAGE,
-                    "test.annotation"
                 ),
             api =
                 """
@@ -864,6 +854,8 @@ class ShowAnnotationTest : DriverTest() {
                     ),
                     systemApiSource,
                     testApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
@@ -871,8 +863,6 @@ class ShowAnnotationTest : DriverTest() {
                     "android.annotation.SystemApi",
                     ARG_SHOW_FOR_STUB_PURPOSES_ANNOTATION,
                     "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             api =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ShowForStubPurposesAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/ShowForStubPurposesAnnotationTest.kt
index f15762d65..bbaba13e3 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ShowForStubPurposesAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ShowForStubPurposesAnnotationTest.kt
@@ -379,23 +379,23 @@ class ShowForStubPurposesAnnotationTest : DriverTest() {
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class SystemClass {
                     public SystemClass() { throw new RuntimeException("Stub!"); }
-                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
-                    public void system() { throw new RuntimeException("Stub!"); }
                     public void module() { throw new RuntimeException("Stub!"); }
                     public void moduleAndSystem() { throw new RuntimeException("Stub!"); }
+                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void referFromModuleToSystem(test.pkg.SystemClass2 arg) { throw new RuntimeException("Stub!"); }
+                    public void system() { throw new RuntimeException("Stub!"); }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class NestedDefault {
                     public NestedDefault() { throw new RuntimeException("Stub!"); }
+                    public void module() { throw new RuntimeException("Stub!"); }
                     public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void system() { throw new RuntimeException("Stub!"); }
-                    public void module() { throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class NestedModule {
                     public NestedModule() { throw new RuntimeException("Stub!"); }
-                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void module() { throw new RuntimeException("Stub!"); }
+                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     }
                     }
                     """
@@ -406,21 +406,21 @@ class ShowForStubPurposesAnnotationTest : DriverTest() {
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class PublicClass {
                     public PublicClass() { throw new RuntimeException("Stub!"); }
+                    public void module() { throw new RuntimeException("Stub!"); }
                     public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void system() { throw new RuntimeException("Stub!"); }
-                    public void module() { throw new RuntimeException("Stub!"); }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class NestedDefault {
                     public NestedDefault() { throw new RuntimeException("Stub!"); }
+                    public void module() { throw new RuntimeException("Stub!"); }
                     public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void system() { throw new RuntimeException("Stub!"); }
-                    public void module() { throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class NestedModule {
                     public NestedModule() { throw new RuntimeException("Stub!"); }
-                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void module() { throw new RuntimeException("Stub!"); }
+                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     }
                     }
                     """
@@ -440,8 +440,8 @@ class ShowForStubPurposesAnnotationTest : DriverTest() {
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class ModuleClass {
                     public ModuleClass() { throw new RuntimeException("Stub!"); }
-                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     public void module() { throw new RuntimeException("Stub!"); }
+                    public void noAnnotation() { throw new RuntimeException("Stub!"); }
                     }
                     """
                     )
@@ -483,9 +483,9 @@ class ShowForStubPurposesAnnotationTest : DriverTest() {
                 ),
             expectedIssues =
                 """
+                src/test/pkg/SystemClass.java:6: error: Parameter arg references hidden type test.pkg.ModuleClass. [HiddenTypeParameter]
                 src/test/pkg/SystemClass.java:6: error: Class test.pkg.ModuleClass is hidden but was referenced (in parameter type) from public parameter arg in test.pkg.SystemClass.foo(test.pkg.ModuleClass arg) [ReferencesHidden]
                 src/test/pkg/SystemClass.java:6: error: Parameter of unavailable type test.pkg.ModuleClass in test.pkg.SystemClass.foo() [UnavailableSymbol]
-                src/test/pkg/SystemClass.java:6: error: Parameter arg references hidden type test.pkg.ModuleClass. [HiddenTypeParameter]
                 """,
             expectedFail = DefaultLintErrorMessage,
         )
diff --git a/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt b/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
index f60353c42..e6edc50a1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
@@ -33,18 +33,18 @@ import org.junit.Test
 
 class SignatureInputOutputTest : Assertions {
     /**
-     * Parses the API (without a header line, the header from [format] will be added) from the
+     * Parses the API (without a header line, the header from [fileFormat] will be added) from the
      * [signature], runs the [codebaseTest] on the parsed codebase, and then writes the codebase
-     * back out in the [format], verifying that the output matches the original [signature].
+     * back out in the [fileFormat], verifying that the output matches the original [signature].
      *
      * This tests both [ApiFile] and [SignatureWriter].
      */
     private fun runInputOutputTest(
         signature: String,
-        format: FileFormat,
+        fileFormat: FileFormat,
         codebaseTest: (Codebase) -> Unit
     ) {
-        val fullSignature = format.header() + signature
+        val fullSignature = fileFormat.header() + signature
         val codebase = ApiFile.parseApi("test", fullSignature)
 
         codebaseTest(codebase)
@@ -55,20 +55,26 @@ class SignatureInputOutputTest : Assertions {
                     val signatureWriter =
                         SignatureWriter(
                             writer = printWriter,
-                            filterEmit = { true },
-                            filterReference = { true },
-                            preFiltered = false,
                             emitHeader = EmitFileHeader.IF_NONEMPTY_FILE,
-                            fileFormat = format,
+                            fileFormat = fileFormat,
+                        )
+
+                    val visitor =
+                        createFilteringVisitorForSignatures(
+                            delegate = signatureWriter,
+                            fileFormat = fileFormat,
+                            apiType = ApiType.ALL,
+                            preFiltered = true,
                             showUnannotated = false,
-                            apiVisitorConfig = ApiVisitor.Config(),
+                            apiVisitorConfig = ApiVisitor.Config()
                         )
-                    codebase.accept(signatureWriter)
+
+                    codebase.accept(visitor)
                 }
                 stringWriter.toString()
             }
 
-        assertSignatureFilesMatch(signature, output, format)
+        assertSignatureFilesMatch(signature, output, fileFormat)
     }
 
     @Test
@@ -314,7 +320,7 @@ class SignatureInputOutputTest : Assertions {
 
             assertThat(param.hasDefaultValue()).isTrue()
             assertThat(param.isDefaultValueKnown()).isTrue()
-            assertThat(param.defaultValue()).isEqualTo("3")
+            assertThat(param.defaultValueAsString()).isEqualTo("3")
         }
     }
 
@@ -496,19 +502,19 @@ class SignatureInputOutputTest : Assertions {
 
             val annotationArrayArray = method.returnType()
             assertThat(annotationArrayArray).isInstanceOf(ArrayTypeItem::class.java)
-            assertThat(annotationArrayArray.modifiers.annotations().map { it.qualifiedName })
+            assertThat(annotationArrayArray.modifiers.annotations.map { it.qualifiedName })
                 .containsExactly("androidx.annotation.A")
 
             val annotationArray = (annotationArrayArray as ArrayTypeItem).componentType
             assertThat(annotationArray).isInstanceOf(ArrayTypeItem::class.java)
-            assertThat(annotationArray.modifiers.annotations().map { it.qualifiedName })
+            assertThat(annotationArray.modifiers.annotations.map { it.qualifiedName })
                 .containsExactly("androidx.annotation.B")
 
             val annotation = (annotationArray as ArrayTypeItem).componentType
             assertThat(annotation).isInstanceOf(ClassTypeItem::class.java)
             assertThat((annotation as ClassTypeItem).qualifiedName)
                 .isEqualTo("java.lang.annotation.Annotation")
-            assertThat(annotation.modifiers.annotations().map { it.qualifiedName })
+            assertThat(annotation.modifiers.annotations.map { it.qualifiedName })
                 .containsExactly("androidx.annotation.C")
         }
     }
@@ -527,10 +533,10 @@ class SignatureInputOutputTest : Assertions {
         runInputOutputTest(api, format) { codebase ->
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val superClassType = fooClass.superClassType()
-            assertThat(superClassType!!.modifiers.annotations().map { it.qualifiedName })
+            assertThat(superClassType!!.modifiers.annotations.map { it.qualifiedName })
                 .containsExactly("test.pkg.A")
             val interfaceType = fooClass.interfaceTypes().single()
-            assertThat(interfaceType.modifiers.annotations().map { it.qualifiedName })
+            assertThat(interfaceType.modifiers.annotations.map { it.qualifiedName })
                 .containsExactly("test.pkg.B")
         }
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt b/metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt
index 82bf8a006..538df1bb2 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/SignatureWriterTest.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.model.visitors.ApiVisitor
 import java.io.PrintWriter
 import java.io.StringWriter
 import kotlin.test.assertEquals
@@ -35,13 +34,8 @@ class SignatureWriterTest {
                     val writer =
                         SignatureWriter(
                             writer = it,
-                            filterEmit = { true },
-                            filterReference = { true },
-                            preFiltered = false,
                             emitHeader = EmitFileHeader.IF_NONEMPTY_FILE,
                             fileFormat = fileFormat,
-                            showUnannotated = false,
-                            apiVisitorConfig = ApiVisitor.Config(),
                         )
                     body(writer)
                 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt b/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt
index 7152435c1..b9c1d53a0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt
@@ -165,8 +165,8 @@ class SystemServiceCheckTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/test/pkg/MyTest2.java:6: error: None of the permissions foo.bar.PERMISSION1, foo.bar.PERMISSION2 are defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 src/test/pkg/MyTest2.java:6: error: Method 'myMethod1' must be protected with a system permission. [RequiresPermission]
+                src/test/pkg/MyTest2.java:6: error: None of the permissions foo.bar.PERMISSION1, foo.bar.PERMISSION2 are defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 """,
             includeSystemApiAnnotations = true,
             sourceFiles =
@@ -277,9 +277,9 @@ class SystemServiceCheckTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
+                src/test/pkg/MyTest2.java:6: error: Method 'test' must be protected with a system permission. [RequiresPermission]
                 src/test/pkg/MyTest2.java:6: error: Permission 'Manifest.permission.MY_PERMISSION' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 src/test/pkg/MyTest2.java:6: error: Permission 'Manifest.permission.MY_PERMISSION2' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
-                src/test/pkg/MyTest2.java:6: error: Method 'test' must be protected with a system permission. [RequiresPermission]
                 """,
             includeSystemApiAnnotations = true,
             sourceFiles =
@@ -312,8 +312,8 @@ class SystemServiceCheckTest : DriverTest() {
             expectedIssues =
                 """
                 manifest.xml: error: Failed to parse TESTROOT/manifest.xml: The markup in the document preceding the root element must be well-formed. [ParseError]
-                src/test/pkg/MyTest2.java:7: error: None of the permissions foo.bar.PERMISSION1, foo.bar.PERMISSION2 are defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 src/test/pkg/MyTest2.java:7: error: Method 'test' must be protected with a system permission. [RequiresPermission]
+                src/test/pkg/MyTest2.java:7: error: None of the permissions foo.bar.PERMISSION1, foo.bar.PERMISSION2 are defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 """,
             includeSystemApiAnnotations = true,
             sourceFiles =
diff --git a/metalava/src/test/java/com/android/tools/metalava/TypeUseAnnotationFilteringTest.kt b/metalava/src/test/java/com/android/tools/metalava/TypeUseAnnotationFilteringTest.kt
new file mode 100644
index 000000000..44f55482b
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/TypeUseAnnotationFilteringTest.kt
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+
+class TypeUseAnnotationFilteringTest : DriverTest() {
+
+    private fun runTypeUseTest(
+        typeUseAnnotationVisibility: String,
+        api: String,
+        stubFiles: Array<TestFile>,
+    ) {
+        check(
+            format =
+                FileFormat.V5.copy(
+                    kotlinNameTypeOrder = true,
+                    includeTypeUseAnnotations = true,
+                ),
+            sourceFiles =
+                arrayOf(
+                    KnownSourceFiles.nonNullSource,
+                    KnownSourceFiles.nullableSource,
+                    java(
+                        """
+                            package test.annotation;
+                            import java.lang.annotation.ElementType;
+                            import java.lang.annotation.Target;
+
+                            @Target(ElementType.TYPE_USE)
+                            $typeUseAnnotationVisibility @interface TypeUse {}
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            import android.annotation.NonNull;
+                            import android.annotation.Nullable;
+                            import test.annotation.TypeUse;
+                            public abstract class Class extends @TypeUse Exception implements Interface<@TypeUse @NonNull String, @Nullable Integer> {
+                                public Class(@TypeUse float f) throws @TypeUse IllegalStateException {}
+                                public @TypeUse long field;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            import android.annotation.NonNull;
+                            import android.annotation.Nullable;
+                            import java.util.List;
+                            import java.util.Map;
+                            import test.annotation.TypeUse;
+                            public interface Interface<T, @TypeUse S> extends Map.Entry<@TypeUse @NonNull T, @Nullable S>, @TypeUse Runnable {
+                                @TypeUse @NonNull T method(@TypeUse int p) throws @TypeUse IllegalStateException;
+                            }
+                        """
+                    ),
+                ),
+            api = api,
+            stubFiles = stubFiles,
+        )
+    }
+
+    @Test
+    fun `Keep type use annotations`() {
+        // TODO: The type use annotations seem to be in the wrong place.
+        runTypeUseTest(
+            typeUseAnnotationVisibility = "public",
+            api =
+                """
+                    // Signature format: 5.0
+                    // - include-type-use-annotations=yes
+                    // - kotlin-name-type-order=yes
+                    package test.annotation {
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE) public @interface TypeUse {
+                      }
+                    }
+                    package test.pkg {
+                      public abstract class Class extends java.lang.@test.annotation.TypeUse Exception implements test.pkg.Interface<java.lang.@test.annotation.TypeUse String,java.lang.Integer?> {
+                        ctor public Class(@test.annotation.TypeUse _: @test.annotation.TypeUse float) throws java.lang.IllegalStateException;
+                        field @test.annotation.TypeUse public field: @test.annotation.TypeUse long;
+                      }
+                      public interface Interface<T, S> extends java.util.Map.Entry<@test.annotation.TypeUse T,S?> java.lang.@test.annotation.TypeUse Runnable {
+                        method @test.annotation.TypeUse public method(@test.annotation.TypeUse _: @test.annotation.TypeUse int): @test.annotation.TypeUse T throws java.lang.IllegalStateException;
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public abstract class Class extends java.lang.Exception implements test.pkg.Interface<java.lang.String,java.lang.Integer> {
+                            public Class(@test.annotation.TypeUse float f) throws java.lang.IllegalStateException { throw new RuntimeException("Stub!"); }
+                            @test.annotation.TypeUse public long field;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public interface Interface<T, S> extends java.util.Map.Entry<T,S>, java.lang.Runnable {
+                            @android.annotation.NonNull
+                            @test.annotation.TypeUse
+                            public T method(@test.annotation.TypeUse int p) throws java.lang.IllegalStateException;
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @Test
+    fun `Discard type use annotations`() {
+        runTypeUseTest(
+            typeUseAnnotationVisibility = "",
+            api =
+                """
+                    // Signature format: 5.0
+                    // - include-type-use-annotations=yes
+                    // - kotlin-name-type-order=yes
+                    package test.pkg {
+                      public abstract class Class extends java.lang.Exception implements test.pkg.Interface<java.lang.String,java.lang.Integer?> {
+                        ctor public Class(_: float) throws java.lang.IllegalStateException;
+                        field public field: long;
+                      }
+                      public interface Interface<T, S> extends java.util.Map.Entry<T,S?> java.lang.Runnable {
+                        method public method(_: int): T throws java.lang.IllegalStateException;
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public abstract class Class extends java.lang.Exception implements test.pkg.Interface<java.lang.String,java.lang.Integer> {
+                            public Class(float f) throws java.lang.IllegalStateException { throw new RuntimeException("Stub!"); }
+                            public long field;
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public interface Interface<T, S> extends java.util.Map.Entry<T,S>, java.lang.Runnable {
+                            @android.annotation.NonNull
+                            public T method(int p) throws java.lang.IllegalStateException;
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
index d130dfafc..abf8a1b39 100644
--- a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
@@ -21,7 +21,7 @@ import com.android.tools.metalava.model.testing.FilterAction.EXCLUDE
 import com.android.tools.metalava.model.testing.FilterByProvider
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
@@ -190,53 +190,6 @@ abstract class UastTestBase : DriverTest() {
         )
     }
 
-    @Test
-    fun `Kotlin Reified Methods`() {
-        // TODO: once fix for https://youtrack.jetbrains.com/issue/KT-39209 is available (231),
-        //  FE1.0 UAST will have implicit nullability too.
-        //  Put this back to ApiFileTest, before `Kotlin Reified Methods 2`
-        val n = if (isK2) " @Nullable" else ""
-        check(
-            format = FileFormat.V2,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-
-                    public class Context {
-                        @SuppressWarnings("unchecked")
-                        public final <T> T getSystemService(Class<T> serviceClass) {
-                            return null;
-                        }
-                    }
-                    """
-                    ),
-                    kotlin(
-                        """
-                    package test.pkg
-
-                    inline fun <reified T> Context.systemService1() = getSystemService(T::class.java)
-                    inline fun Context.systemService2() = getSystemService(String::class.java)
-                    """
-                    )
-                ),
-            api =
-                """
-                package test.pkg {
-                  public class Context {
-                    ctor public Context();
-                    method public final <T> T getSystemService(Class<T>);
-                  }
-                  public final class TestKt {
-                    method$n public static inline <reified T> T systemService1(@NonNull test.pkg.Context);
-                    method public static inline String systemService2(@NonNull test.pkg.Context);
-                  }
-                }
-                """
-        )
-    }
-
     @Test
     fun `Annotation on parameters of data class synthetic copy`() {
         // https://youtrack.jetbrains.com/issue/KT-57003
@@ -394,6 +347,40 @@ abstract class UastTestBase : DriverTest() {
         )
     }
 
+    @FilterByProvider("psi", "k2", action = EXCLUDE)
+    @Test
+    fun `internal setter with delegation`() {
+        // https://youtrack.jetbrains.com/issue/KT-70458
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        class Test {
+                          var prop = "zzz"
+                            internal set
+                          var lazyProp by lazy { setOf("zzz") }
+                            internal set
+                        }
+                        """
+                    )
+                ),
+            api =
+                """
+                package test.pkg {
+                  public final class Test {
+                    ctor public Test();
+                    method public java.util.Set<java.lang.String> getLazyProp();
+                    method public String getProp();
+                    property public final java.util.Set<java.lang.String> lazyProp;
+                    property public final String prop;
+                  }
+                }
+                """
+        )
+    }
+
     @Test
     fun `non-last vararg type`() {
         // https://youtrack.jetbrains.com/issue/KT-57547
@@ -469,9 +456,10 @@ abstract class UastTestBase : DriverTest() {
                         fun foo(p: Int) {}
                     """
                     ),
-                    requiresApiSource
+                    requiresApiSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
             api =
                 """
                 package test.pkg {
@@ -666,9 +654,11 @@ abstract class UastTestBase : DriverTest() {
                     ctor public PowerMetric.Type.Battery();
                   }
                   public static final class PowerMetric.Type.Energy extends test.pkg.PowerMetric.Type {
+                    ctor public PowerMetric.Type.Energy();
                     ctor public PowerMetric.Type.Energy(optional java.util.Map<test.pkg.PowerCategory,${upperBound}test.pkg.PowerCategoryDisplayLevel> energyCategories);
                   }
                   public static final class PowerMetric.Type.Power extends test.pkg.PowerMetric.Type {
+                    ctor public PowerMetric.Type.Power();
                     ctor public PowerMetric.Type.Power(optional java.util.Map<test.pkg.PowerCategory,${upperBound}test.pkg.PowerCategoryDisplayLevel> powerCategories);
                   }
                 }
@@ -804,6 +794,36 @@ abstract class UastTestBase : DriverTest() {
         )
     }
 
+    @Test
+    fun `Upper bound wildcards -- suspend continuation with generic collection`() {
+        val wildcard = if (isK2) "" else "? extends "
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+
+                        class Test {
+                          suspend fun foo(): Set<String> {
+                            return setOf("blah")
+                          }
+                        }
+                        """
+                    )
+                ),
+            api =
+                """
+                package test.pkg {
+                  public final class Test {
+                    ctor public Test();
+                    method public suspend Object? foo(kotlin.coroutines.Continuation<? super java.util.Set<${wildcard}java.lang.String>>);
+                  }
+                }
+                """
+        )
+    }
+
     @Test
     fun `boxed type argument as method return type`() {
         // https://youtrack.jetbrains.com/issue/KT-57579
diff --git a/metalava/src/test/java/com/android/tools/metalava/UnhideApisTest.kt b/metalava/src/test/java/com/android/tools/metalava/UnhideApisTest.kt
index f5035a723..66701ed77 100644
--- a/metalava/src/test/java/com/android/tools/metalava/UnhideApisTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/UnhideApisTest.kt
@@ -43,11 +43,11 @@ class UnhideApisTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-            src/test/pkg/Foo.java:3: error: Class test.pkg.Hidden1 is not public but was referenced (in field type) from public field test.pkg.Foo.hidden1 [ReferencesHidden]
-            src/test/pkg/Foo.java:4: error: Class test.pkg.Hidden2 is hidden but was referenced (in field type) from public field test.pkg.Foo.hidden2 [ReferencesHidden]
             src/test/pkg/Foo.java:2: error: Class test.pkg.Hidden1 is not public but was referenced (as type parameter) from public class test.pkg.Foo [ReferencesHidden]
             src/test/pkg/Foo.java:2: error: Class test.pkg.Hidden2 is hidden but was referenced (as type parameter) from public class test.pkg.Foo [ReferencesHidden]
             src/test/pkg/Foo.java:2: error: Class test.pkg.Hidden3 is hidden but was referenced (as type parameter) from public class test.pkg.Foo [ReferencesHidden]
+            src/test/pkg/Foo.java:3: error: Class test.pkg.Hidden1 is not public but was referenced (in field type) from public field test.pkg.Foo.hidden1 [ReferencesHidden]
+            src/test/pkg/Foo.java:4: error: Class test.pkg.Hidden2 is hidden but was referenced (in field type) from public field test.pkg.Foo.hidden2 [ReferencesHidden]
             src/test/pkg/Foo.java:5: error: Class test.pkg.Hidden1 is not public but was referenced (in parameter type) from public parameter hidden1 in test.pkg.Foo.method(test.pkg.Hidden1 hidden1, test.pkg.Hidden2 hidden2) [ReferencesHidden]
             src/test/pkg/Foo.java:5: error: Class test.pkg.Hidden2 is hidden but was referenced (in parameter type) from public parameter hidden2 in test.pkg.Foo.method(test.pkg.Hidden1 hidden1, test.pkg.Hidden2 hidden2) [ReferencesHidden]
             src/test/pkg/Foo.java:5: error: Class test.pkg.Hidden3 is hidden but was referenced (as exception) from public method test.pkg.Foo.method(test.pkg.Hidden1,test.pkg.Hidden2) [ReferencesHidden]
@@ -154,19 +154,19 @@ class UnhideApisTest : DriverTest() {
             // TODO: Test annotations! (values, annotation classes, etc.)
             expectedIssues =
                 """
+                    src/test/pkg1/Usage.java:7: warning: Field Usage.myClass1 references hidden type test.pkg1.Class3. [HiddenTypeParameter]
                     src/test/pkg1/Usage.java:7: error: Class test.pkg1.Class3 is not public but was referenced (in field type) from public field test.pkg1.Usage.myClass1 [ReferencesHidden]
+                    src/test/pkg1/Usage.java:8: warning: Field Usage.myClass2 references hidden type test.pkg1.Class4. [HiddenTypeParameter]
                     src/test/pkg1/Usage.java:8: error: Class test.pkg1.Class4 is not public but was referenced (in field type) from public field test.pkg1.Usage.myClass2 [ReferencesHidden]
+                    src/test/pkg1/Usage.java:9: warning: Field Usage.myClass3 references hidden type test.pkg1.Class5. [HiddenTypeParameter]
                     src/test/pkg1/Usage.java:9: error: Class test.pkg1.Class5 is not public but was referenced (in field type) from public field test.pkg1.Usage.myClass3 [ReferencesHidden]
+                    src/test/pkg1/Usage.java:10: warning: Parameter list references hidden type test.pkg1.Class7. [HiddenTypeParameter]
                     src/test/pkg1/Usage.java:10: error: Class test.pkg1.Class6 is not public but was referenced (as type parameter) from public method test.pkg1.Usage.mySort(java.util.List<test.pkg1.Class7>,T) [ReferencesHidden]
                     src/test/pkg1/Usage.java:10: error: Class test.pkg1.Class7 is not public but was referenced (in parameter type) from public parameter list in test.pkg1.Usage.mySort(java.util.List<test.pkg1.Class7> list, T element) [ReferencesHidden]
+                    src/test/pkg1/Usage.java:11: warning: Parameter myargs references hidden type test.pkg1.Class8. [HiddenTypeParameter]
                     src/test/pkg1/Usage.java:11: error: Class test.pkg1.Class8 is not public but was referenced (in parameter type) from public parameter myargs in test.pkg1.Usage.ellipsisType(test.pkg1.Class8... myargs) [ReferencesHidden]
-                    src/test/pkg1/Usage.java:12: error: Class test.pkg1.Class9 is not public but was referenced (in parameter type) from public parameter myargs in test.pkg1.Usage.arrayType(test.pkg1.Class9[] myargs) [ReferencesHidden]
                     src/test/pkg1/Usage.java:12: warning: Parameter myargs references hidden type test.pkg1.Class9. [HiddenTypeParameter]
-                    src/test/pkg1/Usage.java:11: warning: Parameter myargs references hidden type test.pkg1.Class8. [HiddenTypeParameter]
-                    src/test/pkg1/Usage.java:10: warning: Parameter list references hidden type test.pkg1.Class7. [HiddenTypeParameter]
-                    src/test/pkg1/Usage.java:7: warning: Field Usage.myClass1 references hidden type test.pkg1.Class3. [HiddenTypeParameter]
-                    src/test/pkg1/Usage.java:8: warning: Field Usage.myClass2 references hidden type test.pkg1.Class4. [HiddenTypeParameter]
-                    src/test/pkg1/Usage.java:9: warning: Field Usage.myClass3 references hidden type test.pkg1.Class5. [HiddenTypeParameter]
+                    src/test/pkg1/Usage.java:12: error: Class test.pkg1.Class9 is not public but was referenced (in parameter type) from public parameter myargs in test.pkg1.Usage.arrayType(test.pkg1.Class9[] myargs) [ReferencesHidden]
                     """,
             expectedFail = DefaultLintErrorMessage,
             api =
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
index 4283c3646..30ed7092d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
@@ -103,8 +103,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Attempted to remove nullability from java.lang.Int (was NONNULL) in method test.pkg.Foo.bar(Int) [InvalidNullConversion]
                 load-api.txt:4: error: Method test.pkg.Foo.bar has changed return type from void to java.lang.Int [ChangedType]
+                load-api.txt:4: error: Attempted to remove nullability from java.lang.Int (was NONNULL) in method test.pkg.Foo.bar(Int) [InvalidNullConversion]
             """,
             signatureSource =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt
index 2582cadef..e51dac7bc 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt
@@ -527,24 +527,24 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Constructor test.pkg.Foo has removed 'final' qualifier [RemovedFinalStrict]
-            """,
+                    load-api.txt:4: error: Method test.pkg.Foo.foo has removed 'final' qualifier [RemovedFinalStrict]
+                """,
             signatureSource =
                 """
-                package test.pkg {
-                    public class Foo {
-                        ctor public Foo();
+                    package test.pkg {
+                        public class Foo {
+                            method public void foo();
+                        }
                     }
-                }
-            """,
+                """,
             checkCompatibilityApiReleased =
                 """
-                package test.pkg {
-                    public final class Foo {
-                        ctor public Foo();
+                    package test.pkg {
+                        public final class Foo {
+                            method public void foo();
+                        }
                     }
-                }
-            """
+                """
         )
     }
 
@@ -554,7 +554,6 @@ class BinaryCompatibilityClassesTest : DriverTest() {
             expectedIssues =
                 """
                 load-api.txt:3: error: Class test.pkg.Foo added 'final' qualifier [AddedFinal]
-                load-api.txt:4: error: Constructor test.pkg.Foo has added 'final' qualifier [AddedFinal]
             """,
             signatureSource =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt
index affdee32f..11c5a0002 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt
@@ -26,8 +26,8 @@ class BinaryCompatibilityInterfaceFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Attempted to remove nullability from java.lang.String (was NONNULL) in field test.pkg.Foo.bar [InvalidNullConversion]
                 load-api.txt:4: error: Field test.pkg.Foo.bar has changed type from int to java.lang.String [ChangedType]
+                load-api.txt:4: error: Attempted to remove nullability from java.lang.String (was NONNULL) in field test.pkg.Foo.bar [InvalidNullConversion]
             """,
             signatureSource =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt
index 27f739f80..515b2376d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt
@@ -26,8 +26,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
                     load-api.txt:4: error: Added method test.pkg.Foo.baz(int) [AddedAbstractMethod]
+                    released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
                 """,
             signatureSource =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt
index dad071097..2c2fbbef5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt
@@ -146,8 +146,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
             expectedIssues =
                 """
                 released-api.txt:4: error: Removed method test.pkg.Foo.bar() [RemovedMethod]
-                released-api.txt:6: error: Removed method test.pkg.Foo.bax() [RemovedMethod]
                 released-api.txt:5: error: Removed method test.pkg.Foo.baz() [RemovedMethod]
+                released-api.txt:6: error: Removed method test.pkg.Foo.bax() [RemovedMethod]
             """,
             signatureSource =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt
index 15a598ff5..7a76f6640 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt
@@ -185,18 +185,18 @@ class BinaryCompatibilityPackagesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:12: error: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:14: error: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
-                load-api.txt:13: error: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:5: error: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
                 load-api.txt:3: error: Class test.pkg.ClassToEnum changed class/interface declaration [ChangedClass]
                 load-api.txt:4: error: Class test.pkg.ClassToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:8: error: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:5: error: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
                 load-api.txt:6: error: Class test.pkg.EnumToClass changed class/interface declaration [ChangedClass]
                 load-api.txt:7: error: Class test.pkg.EnumToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:11: error: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:8: error: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
                 load-api.txt:9: error: Class test.pkg.InterfaceToClass changed class/interface declaration [ChangedClass]
                 load-api.txt:10: error: Class test.pkg.InterfaceToEnum changed class/interface declaration [ChangedClass]
+                load-api.txt:11: error: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:12: error: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:13: error: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:14: error: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
             """
                     .trimIndent(),
             signatureSource =
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
index d0b0dcfb1..8b3bd90f7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
@@ -16,10 +16,9 @@
 
 package com.android.tools.metalava.cli.common
 
-import com.android.tools.metalava.DefaultReporter
-import com.android.tools.metalava.ReporterEnvironment
 import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.reporter.ReporterEnvironment
 import com.android.tools.metalava.reporter.Severity
 import java.io.File
 import org.junit.Assert.assertEquals
@@ -57,7 +56,7 @@ Issue Reporting:
         .trimIndent()
 
 /**
- * JUnit [TestRule] that will intercept calls to [DefaultReporter.reportPrinter], save them into a
+ * JUnit [TestRule] that will intercept calls to [ReporterEnvironment.printReport], save them into a
  * couple of buffers and then allow the test to verify them. If there are any unverified errors then
  * the test will fail. The other issues will only be verified when requested.
  */
@@ -167,6 +166,9 @@ class IssueReportingOptionsTest :
     @Test
     fun `Test issue severity options with case insensitive names`() {
         runTest("--hide", "arrayreturn") {
+            // Write any saved reports.
+            options.bootstrapReporter.writeSavedReports()
+
             reportCollector.verifyAll(
                 "warning: Case-insensitive issue matching is deprecated, use --hide ArrayReturn instead of --hide arrayreturn [DeprecatedOption]"
             )
@@ -213,6 +215,9 @@ class IssueReportingOptionsTest :
     @Test
     fun `Test issue severity options can affect issues related to processing the options`() {
         runTest("--error", "DeprecatedOption", "--hide", "arrayreturn") {
+            // Write any saved reports.
+            options.bootstrapReporter.writeSavedReports()
+
             reportCollector.verifyErrors(
                 "error: Case-insensitive issue matching is deprecated, use --hide ArrayReturn instead of --hide arrayreturn [DeprecatedOption]\n"
             )
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt
index 2a5e39bbe..6e56b3d36 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt
@@ -34,11 +34,6 @@ Compatibility Checks:
 
   Options controlling which, if any, compatibility checks are performed against a previously released API.
 
-  --check-compatibility:base <file>          When performing a compat check, use the provided signature file as a base
-                                             api, which is treated as part of the API being checked. This allows us to
-                                             compute the full API surface from a partial API surface (e.g. the current
-                                             @SystemApi txt file), which allows us to recognize when an API is moved
-                                             from the partial API to the base API and avoid incorrectly flagging this
   --check-compatibility:api:released <file>  Check compatibility of the previously released API.
 
                                              When multiple files are provided any files that are a delta on another file
@@ -52,6 +47,10 @@ Compatibility Checks:
                                              must come after the other file, e.g. if `system` is a delta on `public`
                                              then `public` must come first, then `system`. Or, in other words, they must
                                              be provided in order from the narrowest API to the widest API.
+  --api-compat-annotation <annotation>       Specify an annotation important for API compatibility.
+
+                                             Adding/removing this annotation will be considered an incompatible change.
+                                             The fully qualified name of the annotation should be passed.
   --error-message:compatibility:released <message>
                                              If set, this is output when errors are detected in
                                              --check-compatibility:api:released or
@@ -225,4 +224,17 @@ class CompatibilityCheckOptionsTest :
                 )
         }
     }
+
+    @Test
+    fun `api compat annotations multiple values`() {
+        runTest(
+            ARG_API_COMPAT_ANNOTATION,
+            "com.example.MyAnnotation",
+            ARG_API_COMPAT_ANNOTATION,
+            "com.example.MyOtherAnnotation",
+        ) {
+            assertThat(options.apiCompatAnnotations)
+                .containsExactly("com.example.MyAnnotation", "com.example.MyOtherAnnotation")
+        }
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
index e2d16f2b9..9e949d63e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
@@ -39,6 +39,7 @@ Available Issues                             |  Category                |   Defa
   ActionValue                                |  api_lint                |   error
   AddSealed                                  |  compatibility           |   error
   AddedAbstractMethod                        |  compatibility           |   error
+  AddedAnnotation                            |  compatibility           |   error
   AddedClass                                 |  compatibility           |   hidden
   AddedField                                 |  compatibility           |   hidden
   AddedFinal                                 |  compatibility           |   error
@@ -79,11 +80,13 @@ Available Issues                             |  Category                |   Defa
   ChangedVolatile                            |  compatibility           |   error
   CompileTimeConstant                        |  api_lint                |   error
   ConcreteCollection                         |  api_lint                |   error
+  ConditionalRequiresPermissionNotExplained  |  api_lint                |   hidden
   ConfigFieldName                            |  api_lint                |   error
+  ConfigFileProblem                          |  unknown                 |   error
   ConflictingShowAnnotations                 |  unknown                 |   error
   ContextFirst                               |  api_lint                |   error
   ContextNameSuffix                          |  api_lint                |   error
-  DefaultValueChange                         |  api_lint                |   error
+  DefaultValueChange                         |  compatibility           |   error
   Deprecated                                 |  documentation           |   hidden
   DeprecatedOption                           |  unknown                 |   warning
   DeprecationMismatch                        |  documentation           |   error
@@ -94,12 +97,11 @@ Available Issues                             |  Category                |   Defa
   EqualsAndHashCode                          |  api_lint                |   error
   ExceptionName                              |  api_lint                |   error
   ExecutorRegistration                       |  api_lint                |   warning
-  ExpectedPlatformType                       |  unknown                 |   hidden
-  ExtendsDeprecated                          |  unknown                 |   hidden
+  ExtendsDeprecated                          |  api_lint                |   hidden
   ExtendsError                               |  api_lint                |   error
   FlaggedApiLiteral                          |  api_lint                |   warning_error_when_new
   ForbiddenSuperClass                        |  api_lint                |   error
-  ForbiddenTag                               |  unknown                 |   error
+  ForbiddenTag                               |  documentation           |   error
   FractionFloat                              |  api_lint                |   error
   FunRemoval                                 |  compatibility           |   error
   GenericCallbacks                           |  api_lint                |   error
@@ -108,12 +110,13 @@ Available Issues                             |  Category                |   Defa
   GetterSetterNames                          |  api_lint                |   error
   GetterSetterNullability                    |  api_lint                |   warning_error_when_new
   HeavyBitSet                                |  api_lint                |   error
-  HiddenAbstractMethod                       |  unknown                 |   error
+  HiddenAbstractMethod                       |  api_lint                |   error
   HiddenSuperclass                           |  documentation           |   warning
   HiddenTypeParameter                        |  documentation           |   warning
   HiddenTypedefConstant                      |  unknown                 |   error
   IgnoringSymlink                            |  unknown                 |   info
   IllegalStateException                      |  api_lint                |   warning
+  InconsistentMergeAnnotation                |  api_lint                |   warning_error_when_new
   InfixRemoval                               |  compatibility           |   error
   IntDef                                     |  documentation           |   hidden
   IntentBuilderName                          |  api_lint                |   warning
@@ -127,6 +130,7 @@ Available Issues                             |  Category                |   Defa
   InvalidNullabilityAnnotation               |  unknown                 |   error
   InvalidNullabilityAnnotationWarning        |  unknown                 |   warning
   InvalidNullabilityOverride                 |  api_lint                |   error
+  InvalidPackage                             |  unknown                 |   error
   InvalidSyntax                              |  unknown                 |   error
   IoError                                    |  unknown                 |   error
   KotlinDefaultParameterOrder                |  api_lint                |   error
@@ -174,9 +178,10 @@ Available Issues                             |  Category                |   Defa
   ProtectedMember                            |  api_lint                |   error
   PublicTypedef                              |  api_lint                |   error
   RawAidl                                    |  api_lint                |   error
-  ReferencesDeprecated                       |  unknown                 |   hidden
-  ReferencesHidden                           |  unknown                 |   error
+  ReferencesDeprecated                       |  api_lint                |   hidden
+  ReferencesHidden                           |  api_lint                |   error
   RegistrationName                           |  api_lint                |   error
+  RemovedAnnotation                          |  compatibility           |   error
   RemovedClass                               |  compatibility           |   error
   RemovedDeprecatedClass                     |  compatibility           |   inherit
   RemovedDeprecatedField                     |  compatibility           |   inherit
@@ -198,7 +203,7 @@ Available Issues                             |  Category                |   Defa
   SdkConstant                                |  documentation           |   error
   ServiceName                                |  api_lint                |   error
   SetterReturnsThis                          |  api_lint                |   warning
-  ShowingMemberInHiddenClass                 |  unknown                 |   error
+  ShowingMemberInHiddenClass                 |  api_lint                |   error
   SingleMethodInterface                      |  api_lint                |   error
   SingletonConstructor                       |  api_lint                |   error
   SingularCallback                           |  api_lint                |   error
@@ -212,9 +217,9 @@ Available Issues                             |  Category                |   Defa
   TopLevelBuilder                            |  api_lint                |   warning
   UnavailableSymbol                          |  documentation           |   warning
   UnflaggedApi                               |  api_lint                |   hidden
-  UnhiddenSystemApi                          |  unknown                 |   error
+  UnhiddenSystemApi                          |  api_lint                |   error
   UniqueKotlinOperator                       |  api_lint                |   error
-  UnmatchedMergeAnnotation                   |  unknown                 |   error
+  UnmatchedMergeAnnotation                   |  api_lint                |   error
   UnresolvedClass                            |  documentation           |   error
   UnresolvedImport                           |  unknown                 |   info
   UnresolvedLink                             |  documentation           |   error
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt
index 2f98c73c8..98f82c521 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToDexCommandTest.kt
@@ -22,16 +22,16 @@ import org.junit.Test
 
 private val signatureToDexHelp =
     """
-Usage: metalava signature-to-dex [options] <api-file> <dex-file>
+Usage: metalava signature-to-dex [options] <api-file>...
 
-  Convert an API signature file into a file containing a list of DEX signatures.
+  Convert API signature files into a file containing a list of DEX signatures.
 
 Options:
+  --out <file>                               Output DEX signatures file. (required)
   -h, -?, --help                             Show this message and exit
 
 Arguments:
-  <api-file>                                 API signature file to convert to DEX signatures.
-  <dex-file>                                 Output DEX signatures file.
+  <api-file>                                 API signature files to convert to DEX signatures.
     """
         .trimIndent()
 
@@ -47,37 +47,69 @@ class SignatureToDexCommandTest :
         }
     }
 
-    private fun checkDexSignatures(signature: String, expectedDex: String) {
+    private fun checkDexSignatures(vararg signatures: String, expectedDex: String) {
         commandTest {
             args += listOf("signature-to-dex")
 
-            val apiFile = inputFile("api.txt", signature.trimIndent())
+            for ((index, signature) in signatures.withIndex()) {
+                val apiFile = inputFile("api$index.txt", signature.trimIndent())
+                args += apiFile.path
+            }
 
-            args += apiFile.path
+            val outFile = outputFile("out.dex")
+            args += ARG_OUT
+            args += outFile.path
 
-            val dexFile = outputFile("out.dex")
-            args += dexFile.path
-
-            verify { assertEquals(expectedDex.trimIndent(), dexFile.readText().trim()) }
+            verify { assertEquals(expectedDex.trimIndent(), outFile.readText().trim()) }
         }
     }
 
     @Test
     fun `Test generate dex signatures`() {
         checkDexSignatures(
-            signature =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Child extends test.pkg.Parent {
+                    ctor public Child();
+                    method public String toString();
+                  }
+                  public class Parent {
+                    ctor public Parent();
+                  }
+                }
+            """,
+            expectedDex =
                 """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      public class Child extends test.pkg.Parent {
-                        ctor public Child();
-                        method public String toString();
-                      }
-                      public class Parent {
-                        ctor public Parent();
-                      }
-                    }
+                    Ltest/pkg/Child;
+                    Ltest/pkg/Child;-><init>()V
+                    Ltest/pkg/Child;->toString()Ljava/lang/String;
+                    Ltest/pkg/Parent;
+                    Ltest/pkg/Parent;-><init>()V
                 """,
+        )
+    }
+
+    @Test
+    fun `Test generate dex signatures - split across multiple files`() {
+        checkDexSignatures(
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Parent {
+                    ctor public Parent();
+                  }
+                }
+            """,
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Child extends test.pkg.Parent {
+                    ctor public Child();
+                    method public String toString();
+                  }
+                }
+            """,
             expectedDex =
                 """
                     Ltest/pkg/Child;
@@ -92,21 +124,20 @@ class SignatureToDexCommandTest :
     @Test
     fun `Test generate dex signatures erased types`() {
         checkDexSignatures(
-            signature =
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      public class Child {
-                        ctor public Child();
-                      }
-                      public class Parent {
-                        ctor public Parent();
-                        method protected <T extends test.pkg.Child> T findChild(String);
-                        method protected <T> T findObject(String);
-                        method protected java.util.List<String> getNames();
-                      }
-                    }
-                """,
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Child {
+                    ctor public Child();
+                  }
+                  public class Parent {
+                    ctor public Parent();
+                    method protected <T extends test.pkg.Child> T findChild(String);
+                    method protected <T> T findObject(String);
+                    method protected java.util.List<String> getNames();
+                  }
+                }
+            """,
             expectedDex =
                 """
                     Ltest/pkg/Child;
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
index 9c3b41ad9..88db018e9 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
@@ -30,8 +30,10 @@ Usage: metalava signature-to-jdiff [options] <api-file> <xml-file>
   Convert an API signature file into a file in the JDiff XML format.
 
 Options:
-  --strip / --no-strip                       Determines whether duplicate inherited methods should be stripped from the
-                                             output or not. (default: false)
+  --strip / --no-strip                       Determines whether types that are not defined within the input signature
+                                             file should be stripped from the output or not. This does not include super
+                                             class types, i.e. the `extends` attribute in the generated JDiff file.
+                                             Historically, they have not been filtered. (default: false)
   --format-for-legacy-files <format-specifier>
                                              Optional format to use when reading legacy, i.e. no longer supported,
                                              format versions. Forces the signature file to be parsed as if it was in
@@ -606,6 +608,108 @@ $signatureToJdiffHelp
                     .trimIndent()
         }
     }
+
+    @Test
+    fun `Test producing full JDiff for class with super class and interfaces`() {
+        jdiffConversionTest {
+            formatForLegacyFiles = FileFormat.V2
+
+            api =
+                """
+                    package test.pkg {
+                      public class Test extends Number implements Comparable<Test> {
+                        field public static final int FIELD = 1;
+                      }
+                    }
+                """
+
+            expectedXml =
+                """
+                    <api name="api" xmlns:metalava="http://www.android.com/metalava/">
+                    <package name="test.pkg"
+                    >
+                    <class name="Test"
+                     extends="java.lang.Number"
+                     abstract="false"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    <implements name="java.lang.Comparable&lt;java.lang.Test>">
+                    </implements>
+                    <field name="FIELD"
+                     type="int"
+                     transient="false"
+                     volatile="false"
+                     value="1"
+                     static="true"
+                     final="true"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    </field>
+                    </class>
+                    </package>
+                    </api>
+                """
+        }
+    }
+
+    @Test
+    fun `Test producing delta JDiff for class with super class and interfaces`() {
+        jdiffConversionTest {
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test extends Number implements Comparable<Test> {
+                        field public static final int FIELD = 1;
+                      }
+                    }
+                """
+
+            baseApi =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test extends Number implements Comparable<Test> {
+                      }
+                    }
+                """
+
+            expectedXml =
+                """
+                    <api name="api" xmlns:metalava="http://www.android.com/metalava/">
+                    <package name="test.pkg"
+                    >
+                    <class name="Test"
+                     extends="java.lang.Number"
+                     abstract="false"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    <implements name="java.lang.Comparable&lt;java.lang.Test>">
+                    </implements>
+                    <field name="FIELD"
+                     type="int"
+                     transient="false"
+                     volatile="false"
+                     value="1"
+                     static="true"
+                     final="true"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    </field>
+                    </class>
+                    </package>
+                    </api>
+                """
+        }
+    }
 }
 
 fun BaseCommandTest<SignatureToJDiffCommand>.jdiffConversionTest(body: JDiffTestConfig.() -> Unit) {
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ApiCompatAnnotationsTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ApiCompatAnnotationsTest.kt
new file mode 100644
index 000000000..ee09486ca
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ApiCompatAnnotationsTest.kt
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.compatibility
+
+import com.android.tools.metalava.DriverTest
+import org.junit.Test
+
+class ApiCompatAnnotationsTest : DriverTest() {
+
+    @Test
+    fun `Test adding annotation to class not passed in apiCompatAnnotations`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            signatureSource =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      @test.pkg.MyAnnotation public final class Foo {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+        )
+    }
+
+    @Test
+    fun `Test removing annotation from function not passed in apiCompatAnnotations`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method @test.pkg.MyAnnotation @test.pkg.MySecondAnnotation public void bar();
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MySecondAnnotation {
+                      }
+                    }
+                """,
+            signatureSource =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method @test.pkg.MyAnnotation public void bar();
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MySecondAnnotation {
+                      }
+                    }
+                """,
+            apiCompatAnnotations = setOf("test.pkg.MyAnnotation"),
+        )
+    }
+
+    @Test
+    fun `Test adding annotation from class passed in apiCompatAnnotations`() {
+        check(
+            expectedIssues =
+                """
+                load-api.txt:3: error: Cannot add @test.pkg.MyAnnotation annotation to class test.pkg.Foo: Incompatible change [AddedAnnotation]
+                """,
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            signatureSource =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      @test.pkg.MyAnnotation public final class Foo {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            apiCompatAnnotations = setOf("test.pkg.MyAnnotation"),
+        )
+    }
+
+    @Test
+    fun `Test removing annotation from class passed in apiCompatAnnotations`() {
+        check(
+            expectedIssues =
+                """
+                load-api.txt:3: error: Cannot remove @test.pkg.MyAnnotation annotation from class test.pkg.Foo: Incompatible change [RemovedAnnotation]
+                """,
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      @test.pkg.MyAnnotation public final class Foo {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            signatureSource =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            apiCompatAnnotations = setOf("test.pkg.MyAnnotation"),
+        )
+    }
+
+    @Test
+    fun `Test adding annotation from function passed in apiCompatAnnotations`() {
+        check(
+            expectedIssues =
+                """
+                load-api.txt:4: error: Cannot add @test.pkg.MyAnnotation annotation to method test.pkg.Foo.bar(): Incompatible change [AddedAnnotation]
+                """,
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method public void bar();
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            signatureSource =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method @test.pkg.MyAnnotation public void bar();
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            apiCompatAnnotations = setOf("test.pkg.MyAnnotation"),
+        )
+    }
+
+    @Test
+    fun `Test removing annotation from function passed in apiCompatAnnotations`() {
+        check(
+            expectedIssues =
+                """
+                load-api.txt:4: error: Cannot remove @test.pkg.MyAnnotation annotation from method test.pkg.Foo.bar(): Incompatible change [RemovedAnnotation]
+                """,
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method @test.pkg.MyAnnotation public void bar();
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            signatureSource =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public final class Foo {
+                        method public void bar();
+                      }
+
+                      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
+                      }
+                    }
+                """,
+            apiCompatAnnotations = setOf("test.pkg.MyAnnotation"),
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
index bbd2ca64e..377f1143b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
@@ -108,22 +108,20 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     8,
                     """
-                error: Method android.content.ComponentName.clone has changed return type from java.lang.Object to android.content.ComponentName [ChangedType]
+                warning: Class javax.xml.XMLConstants added 'final' qualifier [AddedFinal]
+                warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.KeyManagementException [ChangedThrows]
+                warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.NoSuchAlgorithmException [ChangedThrows]
+                warning: Constructor java.nio.charset.Charset no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
                 warning: Method android.content.ComponentName.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
                 warning: Method android.gesture.Gesture.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
                 warning: Method android.gesture.GesturePoint.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
                 warning: Method android.gesture.GestureStroke.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.KeyManagementException [ChangedThrows]
-                warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.NoSuchAlgorithmException [ChangedThrows]
-                warning: Constructor java.nio.charset.Charset no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
                 warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
                 warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.UnsupportedCharsetException [ChangedThrows]
                 warning: Method java.nio.charset.Charset.isSupported no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
                 warning: Method java.util.regex.Matcher.appendReplacement no longer throws exception java.lang.IllegalStateException [ChangedThrows]
                 warning: Method java.util.regex.Matcher.start no longer throws exception java.lang.IllegalStateException [ChangedThrows]
                 warning: Method java.util.regex.Pattern.compile no longer throws exception java.util.regex.PatternSyntaxException [ChangedThrows]
-                warning: Class javax.xml.XMLConstants added 'final' qualifier [AddedFinal]
-                error: Removed constructor javax.xml.XMLConstants() [RemovedMethod]
                 warning: Method javax.xml.parsers.DocumentBuilder.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
                 warning: Method javax.xml.parsers.DocumentBuilderFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
                 warning: Method javax.xml.parsers.SAXParser.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
@@ -133,6 +131,8 @@ abstract class CompatibilityCheckAndroidApisTest(
                 warning: Method org.w3c.dom.Element.getElementsByTagNameNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
                 warning: Method org.w3c.dom.Element.hasAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
                 warning: Method org.w3c.dom.NamedNodeMap.getNamedItemNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                error: Method android.content.ComponentName.clone has changed return type from java.lang.Object to android.content.ComponentName [ChangedType]
+                error: Removed constructor javax.xml.XMLConstants() [RemovedMethod]
                 """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
@@ -147,10 +147,10 @@ abstract class CompatibilityCheckAndroidApisTest(
                     18,
                     """
                 error: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
-                error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
+                error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
                 error: Removed class android.renderscript.Program [RemovedClass]
                 error: Removed class android.renderscript.ProgramStore [RemovedClass]
-                error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
+                error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
                 """,
                     hide(
                         "AddedClass",
@@ -169,19 +169,19 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     19,
                     """
-                error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
-                warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
                 warning: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
-                warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
                 warning: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
-                warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
                 warning: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
-                warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
                 warning: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
                 warning: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
+                warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
+                warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
+                warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
+                warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
+                error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
+                error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
+                error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
+                error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
                 """,
                     // The last warning above is not right; seems to be a PSI jar loading bug. It
                     // returns the wrong return type!
@@ -198,9 +198,9 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     20,
                     """
-                error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
-                warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
                 warning: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
+                warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
+                error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
                 """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
index 70069aad5..3caf9f008 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
@@ -18,7 +18,6 @@ package com.android.tools.metalava.compatibility
 
 import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
 import com.android.tools.metalava.ANDROID_SYSTEM_API
-import com.android.tools.metalava.ARG_HIDE_PACKAGE
 import com.android.tools.metalava.ARG_SHOW_ANNOTATION
 import com.android.tools.metalava.ARG_SHOW_UNANNOTATED
 import com.android.tools.metalava.DriverTest
@@ -36,6 +35,7 @@ import com.android.tools.metalava.restrictToSource
 import com.android.tools.metalava.suppressLintSource
 import com.android.tools.metalava.systemApiSource
 import com.android.tools.metalava.testApiSource
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -346,8 +346,8 @@ class CompatibilityCheckTest : DriverTest() {
                 released-api.txt:3: error: Removed class test.pkg.FacetProvider [RemovedInterface]
                 released-api.txt:6: error: Removed class test.pkg.FacetProviderAdapter [RemovedInterface]
                 src/test/pkg/FacetProviderAdapterImpl.java:6: error: Attempted to remove nullability from test.pkg.FacetProvider (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.getFacetProvider(int) [InvalidNullConversion]
-                src/test/pkg/FacetProviderAdapterImpl.java:13: error: Attempted to remove nullability from java.lang.Object (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?>) [InvalidNullConversion]
                 src/test/pkg/FacetProviderAdapterImpl.java:13: error: Attempted to remove nullability from java.lang.Class<?> (was NULLABLE) in parameter facetClass in test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?> facetClass) [InvalidNullConversion]
+                src/test/pkg/FacetProviderAdapterImpl.java:13: error: Attempted to remove nullability from java.lang.Object (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?>) [InvalidNullConversion]
             """
         )
     }
@@ -362,10 +362,8 @@ class CompatibilityCheckTest : DriverTest() {
             expectedIssues =
                 """
                 src/test/pkg/Java.java:2: error: Class test.pkg.Java added 'final' qualifier [AddedFinal]
-                src/test/pkg/Java.java:3: error: Constructor test.pkg.Java has added 'final' qualifier [AddedFinal]
                 src/test/pkg/Java.java:4: error: Method test.pkg.Java.method has added 'final' qualifier [AddedFinal]
                 src/test/pkg/Kotlin.kt:3: error: Class test.pkg.Kotlin added 'final' qualifier [AddedFinal]
-                src/test/pkg/Kotlin.kt:3: error: Constructor test.pkg.Kotlin has added 'final' qualifier [AddedFinal]
                 src/test/pkg/Kotlin.kt:4: error: Method test.pkg.Kotlin.method has added 'final' qualifier [AddedFinal]
                 """,
             checkCompatibilityApiReleased =
@@ -1049,9 +1047,10 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    suppressLintSource
+                    suppressLintSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "android.annotation")
         )
     }
 
@@ -1060,9 +1059,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/ExportedProperty.java:15: error: Method test.pkg.ExportedProperty.category has changed value from "" to nothing [ChangedValue]
-                src/test/pkg/ExportedProperty.java:14: error: Method test.pkg.ExportedProperty.floating has changed value from 1.0f to 1.1f [ChangedValue]
                 src/test/pkg/ExportedProperty.java:13: error: Method test.pkg.ExportedProperty.prefix has changed value from "" to "hello" [ChangedValue]
+                src/test/pkg/ExportedProperty.java:14: error: Method test.pkg.ExportedProperty.floating has changed value from 1.0f to 1.1f [ChangedValue]
+                src/test/pkg/ExportedProperty.java:15: error: Method test.pkg.ExportedProperty.category has changed value from "" to nothing [ChangedValue]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1196,8 +1195,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
                 released-api.txt:4: error: Removed constructor test.pkg.Class1() [RemovedMethod]
+                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -2029,14 +2028,14 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             checkCompatibilityApiReleased =
                 """
@@ -2077,14 +2076,14 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             checkCompatibilityApiReleased =
                 """
@@ -2100,103 +2099,6 @@ class CompatibilityCheckTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Incompatible changes to released API signature codebase`() {
-        // Incompatible changes to a released System API should be detected
-        // in case of partial files
-        check(
-            expectedIssues =
-                """
-                released-api.txt:6: error: Removed method test.pkg.Foo.method2() [RemovedMethod]
-                """,
-            signatureSource =
-                """
-                // Signature format: 3.0
-                package test.pkg {
-                  public final class Foo {
-                    ctor public Foo();
-                    method public void method1();
-                  }
-                }
-                """,
-            checkCompatibilityApiReleased =
-                """
-                package test.pkg {
-                  public final class Foo {
-                    ctor public Foo();
-                    method public void method1();
-                    method public void method2();
-                    method public void method3();
-                  }
-                }
-                """,
-            checkCompatibilityBaseApi =
-                """
-                package test.pkg {
-                  public final class Foo {
-                    ctor public Foo();
-                    method public void method3();
-                  }
-                }
-                """,
-        )
-    }
-
-    @Test
-    fun `Partial text file which adds methods to show-annotation API`() {
-        // This happens in system and test files where we only include APIs that differ
-        // from the base IDE. When parsing these code bases we need to gracefully handle
-        // references to inner classes.
-        check(
-            includeSystemApiAnnotations = true,
-            expectedIssues =
-                """
-                released-api.txt:5: error: Removed method android.rolecontrollerservice.RoleControllerService.onClearRoleHolders() [RemovedMethod]
-                """,
-            sourceFiles =
-                arrayOf(
-                    java(
-                            """
-                    package android.rolecontrollerservice;
-
-                    public class Service {
-                    }
-                    """
-                        )
-                        .indented(),
-                    java(
-                        """
-                    package android.rolecontrollerservice;
-                    import android.annotation.SystemApi;
-
-                    /** @hide */
-                    @SystemApi
-                    public abstract class RoleControllerService extends Service {
-                        public abstract void onGrantDefaultRoles();
-                    }
-                    """
-                    ),
-                    systemApiSource
-                ),
-            extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "android.annotation.TestApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
-                ),
-            checkCompatibilityApiReleased =
-                """
-                package android.rolecontrollerservice {
-                  public abstract class RoleControllerService extends android.rolecontrollerservice.Service {
-                    ctor public RoleControllerService();
-                    method public abstract void onClearRoleHolders();
-                  }
-                }
-                """
-        )
-    }
-
     @Test
     fun `Regression test for bug 120847535`() {
         // Regression test for
@@ -2233,7 +2135,9 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                         )
                         .indented(),
-                    testApiSource
+                    testApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             api =
                 """
@@ -2245,11 +2149,6 @@ class CompatibilityCheckTest : DriverTest() {
                   }
                 }
             """,
-            extraArguments =
-                arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
-                ),
             checkCompatibilityApiReleased =
                 """
                 package test.view {
@@ -2271,12 +2170,12 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
                 released-api.txt:4: error: Removed constructor test.pkg.Class1() [RemovedMethod]
-                src/test/pkg/MyClass.java:5: error: Method test.pkg.MyClass.myMethod2 has changed 'abstract' qualifier [ChangedAbstract]
-                src/test/pkg/MyClass.java:6: error: Method test.pkg.MyClass.myMethod3 has changed 'static' qualifier [ChangedStatic]
                 released-api.txt:15: error: Removed class test.pkg.MyOldClass [RemovedClass]
                 released-api.txt:18: error: Removed package test.pkg3 [RemovedPackage]
+                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
+                src/test/pkg/MyClass.java:5: error: Method test.pkg.MyClass.myMethod2 has changed 'abstract' qualifier [ChangedAbstract]
+                src/test/pkg/MyClass.java:6: error: Method test.pkg.MyClass.myMethod3 has changed 'static' qualifier [ChangedStatic]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -2361,9 +2260,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:7: error: Removed deprecated class test.pkg.DeprecatedClass [RemovedDeprecatedClass]
                 released-api.txt:4: error: Removed deprecated constructor test.pkg.SomeClass() [RemovedDeprecatedMethod]
                 released-api.txt:5: error: Removed deprecated method test.pkg.SomeClass.deprecatedMethod() [RemovedDeprecatedMethod]
+                released-api.txt:7: error: Removed deprecated class test.pkg.DeprecatedClass [RemovedDeprecatedClass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -2393,84 +2292,6 @@ class CompatibilityCheckTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Test check release with base api`() {
-        check(
-            expectedIssues = "",
-            checkCompatibilityApiReleased =
-                """
-                package test.pkg {
-                  public class SomeClass {
-                      method public static void publicMethodA();
-                      method public static void publicMethodB();
-                  }
-                }
-                """,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-
-                    public class SomeClass {
-                      public static void publicMethodA();
-                    }
-                    """
-                    )
-                ),
-            checkCompatibilityBaseApi =
-                """
-                package test.pkg {
-                  public class SomeClass {
-                      method public static void publicMethodB();
-                  }
-                }
-            """
-        )
-    }
-
-    @Test
-    fun `Test check a class moving from the released api to the base api`() {
-        check(
-            checkCompatibilityApiReleased =
-                """
-                package test.pkg {
-                  public class SomeClass1 {
-                    method public void method1();
-                  }
-                  public class SomeClass2 {
-                    method public void oldMethod();
-                  }
-                }
-                """,
-            checkCompatibilityBaseApi =
-                """
-                package test.pkg {
-                  public class SomeClass2 {
-                    method public void newMethod();
-                  }
-                }
-            """,
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-
-                    public class SomeClass1 {
-                        public void method1();
-                    }
-                    """
-                    )
-                ),
-            expectedIssues =
-                """
-            released-api.txt:7: error: Removed method test.pkg.SomeClass2.oldMethod() [RemovedMethod]
-            """
-                    .trimIndent()
-        )
-    }
-
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Implicit nullness`() {
@@ -2685,14 +2506,14 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             expectedIssues = ""
         )
@@ -2742,14 +2563,14 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             expectedIssues = ""
         )
@@ -2995,14 +2816,14 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             expectedIssues =
                 """
@@ -3046,9 +2867,8 @@ class CompatibilityCheckTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/foobar/Foo.java:8: error: Class android.foobar.Foo.Nested added 'final' qualifier [AddedFinal]
-                src/android/foobar/Foo.java:8: error: Constructor android.foobar.Foo.Nested has added 'final' qualifier [AddedFinal]
-                src/android/foobar/Foo.java:9: error: Method android.foobar.Foo.Nested.existing has changed return type from void to int [ChangedType]
                 src/android/foobar/Foo.java:9: error: Method android.foobar.Foo.Nested.existing has added 'final' qualifier [AddedFinal]
+                src/android/foobar/Foo.java:9: error: Method android.foobar.Foo.Nested.existing has changed return type from void to int [ChangedType]
                 """
         )
     }
@@ -3085,14 +2905,14 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             expectedIssues = """
                 """
@@ -3448,9 +3268,10 @@ class CompatibilityCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    androidxNonNullSource
+                    androidxNonNullSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
@@ -3591,8 +3412,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:12: error: Class test.pkg.ParentClass.AnotherBadInnerClass changed 'static' qualifier [ChangedStatic]
                 load-api.txt:9: error: Class test.pkg.ParentClass.BadInnerClass changed 'static' qualifier [ChangedStatic]
+                load-api.txt:12: error: Class test.pkg.ParentClass.AnotherBadInnerClass changed 'static' qualifier [ChangedStatic]
             """,
             checkCompatibilityApiReleased =
                 """
@@ -3729,8 +3550,8 @@ class CompatibilityCheckTest : DriverTest() {
             expectedIssues =
                 """
                 src/test/pkg/JavaInterface.java:4: error: Added method test.pkg.JavaInterface.noDefault() [AddedAbstractMethod]
-                src/test/pkg/KotlinInterface.kt:5: error: Added method test.pkg.KotlinInterface.hasDefault() [AddedAbstractMethod]
                 src/test/pkg/KotlinInterface.kt:4: error: Added method test.pkg.KotlinInterface.noDefault() [AddedAbstractMethod]
+                src/test/pkg/KotlinInterface.kt:5: error: Added method test.pkg.KotlinInterface.hasDefault() [AddedAbstractMethod]
             """,
             checkCompatibilityApiReleased =
                 """
@@ -3802,18 +3623,18 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:12: error: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:14: error: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
-                load-api.txt:13: error: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:5: error: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
                 load-api.txt:3: error: Class test.pkg.ClassToEnum changed class/interface declaration [ChangedClass]
                 load-api.txt:4: error: Class test.pkg.ClassToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:8: error: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:5: error: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
                 load-api.txt:6: error: Class test.pkg.EnumToClass changed class/interface declaration [ChangedClass]
                 load-api.txt:7: error: Class test.pkg.EnumToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:11: error: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:8: error: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
                 load-api.txt:9: error: Class test.pkg.InterfaceToClass changed class/interface declaration [ChangedClass]
                 load-api.txt:10: error: Class test.pkg.InterfaceToEnum changed class/interface declaration [ChangedClass]
+                load-api.txt:11: error: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:12: error: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:13: error: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:14: error: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
             """
                     .trimIndent(),
             signatureSource =
@@ -4421,24 +4242,24 @@ class CompatibilityCheckTest : DriverTest() {
             expectedIssues =
                 """
                 error: Method test.pkg.MyCollection.add has changed 'abstract' qualifier [ChangedAbstract]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.add [ParameterNameChange]
                 error: Method test.pkg.MyCollection.addAll has changed 'abstract' qualifier [ChangedAbstract]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.addAll [ParameterNameChange]
                 error: Method test.pkg.MyCollection.clear has changed 'abstract' qualifier [ChangedAbstract]
-                load-api.txt:5: error: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
-                load-api.txt:5: error: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
-                load-api.txt:6: error: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
-                load-api.txt:6: error: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
                 error: Method test.pkg.MyCollection.remove has changed 'abstract' qualifier [ChangedAbstract]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.remove [ParameterNameChange]
                 error: Method test.pkg.MyCollection.removeAll has changed 'abstract' qualifier [ChangedAbstract]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.removeAll [ParameterNameChange]
                 error: Method test.pkg.MyCollection.retainAll has changed 'abstract' qualifier [ChangedAbstract]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.retainAll [ParameterNameChange]
                 error: Method test.pkg.MyCollection.size has changed 'abstract' qualifier [ChangedAbstract]
                 error: Method test.pkg.MyCollection.toArray has changed 'abstract' qualifier [ChangedAbstract]
                 error: Method test.pkg.MyCollection.toArray has changed 'abstract' qualifier [ChangedAbstract]
+                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.add [ParameterNameChange]
+                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.addAll [ParameterNameChange]
+                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.remove [ParameterNameChange]
+                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.removeAll [ParameterNameChange]
+                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.retainAll [ParameterNameChange]
                 error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.toArray [ParameterNameChange]
+                load-api.txt:5: error: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
+                load-api.txt:5: error: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
+                load-api.txt:6: error: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
+                load-api.txt:6: error: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -4801,6 +4622,58 @@ class CompatibilityCheckTest : DriverTest() {
         )
     }
 
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test removal of implicit no-args constructor is flagged`() {
+        check(
+            expectedIssues =
+                "released-api.txt:8: error: Removed constructor test.pkg.RemoveNoArgsCtor() [RemovedMethod]",
+            checkCompatibilityApiReleased =
+                """
+                    package test.pkg {
+                      public final class KeepNoArgsCtor {
+                        ctor public KeepNoArgsCtor();
+                        ctor public KeepNoArgsCtor(optional int one, optional int two);
+                      }
+                      public final class RemoveNoArgsCtor {
+                        ctor public RemoveNoArgsCtor();
+                        ctor public RemoveNoArgsCtor(optional int one, optional int two);
+                        ctor public RemoveNoArgsCtor(String str);
+                      }
+                    }
+                """,
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            // The kotlin compiler generates a no-args constructor because all
+                            // parameters to the primary constructor have default values
+                            class KeepNoArgsCtor(one: Int = 1, two: Int = 2)
+                            class RemoveNoArgsCtor(str: String) {
+                                // This is a secondary constructor, so a no-args constructor isn't
+                                // generated even though all parameters have default values
+                                constructor(one: Int = 1, two: Int = 2): this("")
+                            }
+                        """
+                    )
+                ),
+            api =
+                """
+                    package test.pkg {
+                      public final class KeepNoArgsCtor {
+                        ctor public KeepNoArgsCtor();
+                        ctor public KeepNoArgsCtor(optional int one, optional int two);
+                      }
+                      public final class RemoveNoArgsCtor {
+                        ctor public RemoveNoArgsCtor(optional int one, optional int two);
+                        ctor public RemoveNoArgsCtor(String str);
+                      }
+                    }
+                """
+        )
+    }
+
     // TODO: Check method signatures changing incompatibly (look especially out for adding new
     // overloaded methods and comparator getting confused!)
     //   ..equals on the method items should actually be very useful!
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
index f07bec304..1db2cf40b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
@@ -360,4 +360,145 @@ class NullnessCompatibilityTest : DriverTest() {
                 """
         )
     }
+
+    @Test
+    fun `Array type component nullness changes`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public String[] foo(String![], String?[], String?[]?[]);
+                      }
+                    }
+                """,
+            sourceFiles =
+                arrayOf(
+                    signature(
+                        """
+                            // Signature format: 5.0
+                            package test.pkg {
+                              public class Foo {
+                                ctor public Foo();
+                                method public String?[] foo(String[], String[], String![][]);
+                              }
+                            }
+                        """
+                    )
+                ),
+            expectedIssues =
+                """
+                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo(String[],String[],String[][]) [InvalidNullConversion]
+                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter arg2 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
+                    api.txt:5: error: Attempted to change nullability of java.lang.String[] (from NULLABLE to NONNULL) in parameter arg3 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
+                    api.txt:5: error: Attempted to remove nullability from java.lang.String (was NULLABLE) in parameter arg3 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
+                """,
+        )
+    }
+
+    @Test
+    fun `Class type argument nullness changes`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public java.util.Map<java.lang.Number?, java.util.List<java.lang.String>!> foo();
+                      }
+                    }
+                """,
+            sourceFiles =
+                arrayOf(
+                    signature(
+                        """
+                            // Signature format: 5.0
+                            package test.pkg {
+                              public class Foo {
+                                ctor public Foo();
+                                method public java.util.Map<java.lang.Number!, java.util.List<java.lang.String?>> foo();
+                              }
+                            }
+                        """
+                    )
+                ),
+            expectedIssues =
+                """
+                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                    api.txt:5: error: Attempted to remove nullability from java.lang.Number (was NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                """,
+        )
+    }
+
+    @Test
+    fun `Outer class type arguments nullness changes`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public test.pkg.Outer<java.lang.String>.Inner foo();
+                      }
+                    }
+                """,
+            sourceFiles =
+                arrayOf(
+                    signature(
+                        """
+                            // Signature format: 5.0
+                            package test.pkg {
+                              public class Foo {
+                                ctor public Foo();
+                                method public test.pkg.Outer<java.lang.String?>.Inner foo();
+                              }
+                            }
+                        """
+                    )
+                ),
+            expectedIssues =
+                """
+                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                """,
+        )
+    }
+
+    @Test
+    fun `Wildcard bounds nullness changes`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        method public java.util.Map<? extends java.lang.Number?, ? super java.lang.String> foo();
+                      }
+                    }
+                """,
+            sourceFiles =
+                arrayOf(
+                    signature(
+                        """
+                            // Signature format: 5.0
+                            package test.pkg {
+                              public class Foo {
+                                ctor public Foo();
+                                method public java.util.Map<? extends java.lang.Number, ? super java.lang.String!> foo();
+                              }
+                            }
+                        """
+                    )
+                ),
+            expectedIssues =
+                """
+                    api.txt:5: warning: Attempted to change nullability of java.lang.Number (from NULLABLE to NONNULL) in method test.pkg.Foo.foo() (ErrorWhenNew) [InvalidNullConversion]
+                    api.txt:5: error: Attempted to remove nullability from java.lang.String (was NONNULL) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                """,
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
index dcd8d6e71..ae2fa2841 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
@@ -16,13 +16,13 @@
 
 package com.android.tools.metalava.compatibility
 
-import com.android.tools.metalava.ARG_HIDE_PACKAGE
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.ApiClassResolution
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.supportParameterName
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -144,9 +144,10 @@ class ParameterNameChangeTest : DriverTest() {
                             }
                         """
                     ),
-                    supportParameterName
+                    supportParameterName,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation"),
         )
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
index 80a464e4d..abf81c5f4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
@@ -16,12 +16,12 @@
 
 package com.android.tools.metalava.compatibility
 
-import com.android.tools.metalava.ARG_HIDE_PACKAGE
 import com.android.tools.metalava.ARG_SHOW_ANNOTATION
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.systemApiSource
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -34,9 +34,9 @@ class ThrowsCompatibilityTest : DriverTest() {
                 """
                     src/test/pkg/MyClass.java:7: error: Method test.pkg.MyClass.method1 added thrown exception java.io.IOException [ChangedThrows]
                     src/test/pkg/MyClass.java:8: error: Method test.pkg.MyClass.method2 no longer throws exception java.io.IOException [ChangedThrows]
+                    src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 added thrown exception java.lang.UnsupportedOperationException [ChangedThrows]
                     src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 no longer throws exception java.io.IOException [ChangedThrows]
                     src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 no longer throws exception java.lang.NumberFormatException [ChangedThrows]
-                    src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 added thrown exception java.lang.UnsupportedOperationException [ChangedThrows]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -76,9 +76,9 @@ class ThrowsCompatibilityTest : DriverTest() {
             expectedIssues =
                 """
                     src/test/pkg/MyClass.kt:4: error: Constructor test.pkg.MyClass added thrown exception test.pkg.MyException [ChangedThrows]
+                    src/test/pkg/MyClass.kt:9: error: Method test.pkg.MyClass.method1 added thrown exception test.pkg.MyException [ChangedThrows]
                     src/test/pkg/MyClass.kt:12: error: Method test.pkg.MyClass.getProperty1 added thrown exception test.pkg.MyException [ChangedThrows]
                     src/test/pkg/MyClass.kt:15: error: Method test.pkg.MyClass.getProperty2 added thrown exception test.pkg.MyException [ChangedThrows]
-                    src/test/pkg/MyClass.kt:9: error: Method test.pkg.MyClass.method1 added thrown exception test.pkg.MyException [ChangedThrows]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -129,8 +129,8 @@ class ThrowsCompatibilityTest : DriverTest() {
                     src/test/pkg/MyClass.java:7: error: Method test.pkg.MyClass.method1 added thrown exception T (extends java.lang.Throwable)} [ChangedThrows]
                     src/test/pkg/MyClass.java:8: error: Method test.pkg.MyClass.method2 no longer throws exception T (extends java.lang.Throwable)} [ChangedThrows]
                     src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 added thrown exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
-                    src/test/pkg/MyClass.java:10: error: Method test.pkg.MyClass.method4 no longer throws exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
                     src/test/pkg/MyClass.java:10: error: Method test.pkg.MyClass.method4 added thrown exception X (extends java.io.IOException)} [ChangedThrows]
+                    src/test/pkg/MyClass.java:10: error: Method test.pkg.MyClass.method4 no longer throws exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -213,14 +213,14 @@ class ThrowsCompatibilityTest : DriverTest() {
                             }
                         """
                     ),
-                    systemApiSource
+                    systemApiSource,
+                    // Hide android.annotation classes.
+                    KnownSourceFiles.androidAnnotationHide,
                 ),
             extraArguments =
                 arrayOf(
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
-                    ARG_HIDE_PACKAGE,
-                    "android.annotation",
                 ),
             checkCompatibilityApiReleased =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/ConfigTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/ConfigTest.kt
new file mode 100644
index 000000000..cc535f3b0
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/ConfigTest.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.lint.checks.infrastructure.TestFiles
+import com.android.tools.metalava.DriverTest
+import org.junit.Test
+
+class ConfigTest : DriverTest() {
+    @Test
+    fun `Empty config file`() {
+        check(
+            configFiles =
+                arrayOf(
+                    TestFiles.xml(
+                        "config.xml",
+                        """
+                            <config xmlns="http://www.google.com/tools/metalava/config"/>
+                        """,
+                    )
+                ),
+        )
+    }
+
+    @Test
+    fun `Invalid config file`() {
+        check(
+            configFiles =
+                arrayOf(
+                    TestFiles.xml(
+                        "config.xml",
+                        """
+                            <invalid xmlns="http://www.google.com/tools/metalava/config"/>
+                        """,
+                    )
+                ),
+            expectedIssues =
+                "config.xml:1: error: Problem parsing configuration file: cvc-elt.1.a: Cannot find the declaration of element 'invalid'. [ConfigFileProblem]",
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt
index e4ecba9fd..b98aa7d40 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt
@@ -133,14 +133,14 @@ class DocAnalyzerRangeTest : DriverTest() {
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class TypedefTest {
                     public TypedefTest() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * @param style Value is {@link test.pkg.TypedefTest#STYLE_NORMAL}, {@link test.pkg.TypedefTest#STYLE_NO_TITLE}, {@link test.pkg.TypedefTest#STYLE_NO_FRAME}, or {@link test.pkg.TypedefTest#STYLE_NO_INPUT}
-                     */
-                    public void setStyle(int style, int theme) { throw new RuntimeException("Stub!"); }
                     /**
                      * @param flags Value is either <code>0</code> or a combination of {@link test.pkg.TypedefTest#STYLE_NORMAL}, {@link test.pkg.TypedefTest#STYLE_NO_TITLE}, {@link test.pkg.TypedefTest#STYLE_NO_FRAME}, {@link test.pkg.TypedefTest#STYLE_NO_INPUT}, 2, and 3 + 1
                      */
                     public void setFlags(java.lang.Object first, int flags) { throw new RuntimeException("Stub!"); }
+                    /**
+                     * @param style Value is {@link test.pkg.TypedefTest#STYLE_NORMAL}, {@link test.pkg.TypedefTest#STYLE_NO_TITLE}, {@link test.pkg.TypedefTest#STYLE_NO_FRAME}, or {@link test.pkg.TypedefTest#STYLE_NO_INPUT}
+                     */
+                    public void setStyle(int style, int theme) { throw new RuntimeException("Stub!"); }
                     public static final int STYLE_NORMAL = 0; // 0x0
                     public static final int STYLE_NO_FRAME = 2; // 0x2
                     public static final int STYLE_NO_INPUT = 3; // 0x3
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
index cf4631036..8228fe689 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
@@ -1480,13 +1480,6 @@ class DocAnalyzerTest : DriverTest() {
                     public Foo() { throw new RuntimeException("Stub!"); }
                     @Deprecated
                     public void foo() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * {@inheritDoc}
-                     * @deprecated Blah blah blah 1
-                     */
-                    @Deprecated
-                    @androidx.annotation.NonNull
-                    public java.lang.String toString() { throw new RuntimeException("Stub!"); }
                     /**
                      * My description
                      * @deprecated Existing deprecation message.
@@ -1494,6 +1487,13 @@ class DocAnalyzerTest : DriverTest() {
                      */
                     @Deprecated
                     public int hashCode() { throw new RuntimeException("Stub!"); }
+                    /**
+                     * {@inheritDoc}
+                     * @deprecated Blah blah blah 1
+                     */
+                    @Deprecated
+                    @androidx.annotation.NonNull
+                    public java.lang.String toString() { throw new RuntimeException("Stub!"); }
                     }
                     """
                     )
@@ -1714,40 +1714,43 @@ class DocAnalyzerTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package test.pkg;
-                    import java.lang.annotation.ElementType;
-                    import java.lang.annotation.Retention;
-                    import java.lang.annotation.RetentionPolicy;
-                    import java.lang.annotation.Target;
-                    /**
-                     * More text here
-                     * @memberDoc Important {@link another.pkg.Bar#BAR}
-                     * and here
-                     */
-                    @Target({ ElementType.FIELD })
-                    @Retention(RetentionPolicy.SOURCE)
-                    public @interface Foo { }
-                """
+                            package test.pkg;
+                            import java.lang.annotation.ElementType;
+                            import java.lang.annotation.Retention;
+                            import java.lang.annotation.RetentionPolicy;
+                            import java.lang.annotation.Target;
+                            /**
+                             * More text here
+                             * @memberDoc Important {@link another.pkg.Bar#BAR}
+                             * and here
+                             */
+                            @Target({ ElementType.FIELD })
+                            @Retention(RetentionPolicy.SOURCE)
+                            public @interface Foo { }
+                        """
                     ),
                     java(
                         """
-                    package another.pkg;
-                    public class Bar {
-                        public String BAR = "BAAAAR";
-                    }
-                """
+                            package another.pkg;
+                            public class Bar {
+                                public String BAR = "BAAAAR";
+                            }
+                        """
                     ),
                     java(
                         """
-                    package yetonemore.pkg;
-                    public class Fun {
-                        /**
-                         * Separate comment
-                         */
-                        @test.pkg.Foo
-                        public static final String FUN = "FUN";
-                    }
-                """
+                            package yetonemore.pkg;
+                            public class Fun {
+                                @test.pkg.Foo
+                                public Fun() {}
+
+                                /**
+                                 * Separate comment
+                                 */
+                                @test.pkg.Foo
+                                public static final String FUN = "FUN";
+                            }
+                        """
                     )
                 ),
             docStubs = true,
@@ -1755,19 +1758,23 @@ class DocAnalyzerTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                    package yetonemore.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public class Fun {
-                    public Fun() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * Separate comment
-                     * <br>
-                     * Important {@link another.pkg.Bar#BAR}
-                     * and here
-                     */
-                    public static final java.lang.String FUN = "FUN";
-                    }
-                """
+                            package yetonemore.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Fun {
+                            /**
+                             * Important {@link another.pkg.Bar#BAR}
+                             * and here
+                             */
+                            public Fun() { throw new RuntimeException("Stub!"); }
+                            /**
+                             * Separate comment
+                             * <br>
+                             * Important {@link another.pkg.Bar#BAR}
+                             * and here
+                             */
+                            public static final java.lang.String FUN = "FUN";
+                            }
+                        """
                     )
                 )
         )
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
index ee11581e5..43d9b2b11 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.lint
 
-import com.android.tools.metalava.ARG_HIDE_PACKAGE
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.androidxNonNullSource
 import com.android.tools.metalava.androidxNullableSource
@@ -24,6 +23,7 @@ import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.restrictToSource
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -224,8 +224,6 @@ class ApiLintBaselineTest : DriverTest() {
                 ),
             extraArguments =
                 arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx",
                     ARG_HIDE,
                     "HiddenSuperclass",
                     ARG_HIDE,
@@ -288,6 +286,8 @@ class ApiLintBaselineTest : DriverTest() {
                     androidxNonNullSource,
                     androidxNullableSource,
                     restrictToSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt
index 200f7a8ad..84d7a1c35 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintFilteringTest.kt
@@ -75,10 +75,10 @@ class ApiLintFilteringTest(private val previouslyReleasedApiUse: PreviouslyRelea
                 ),
             expectedIssuesWithoutPreviouslyReleasedApi =
                 """
-                    src/test/pkg/Foo.java:4: error: Must override both equals and hashCode; missing one in test.pkg.Foo [EqualsAndHashCode]
                     src/test/pkg/Foo.java:3: error: Missing nullability on parameter `s` in method `method` [MissingNullability]
-                    src/test/pkg/Foo.java:5: error: Bare field field must be marked final, or moved behind accessors if mutable [MutableBareField]
+                    src/test/pkg/Foo.java:4: error: Must override both equals and hashCode; missing one in test.pkg.Foo [EqualsAndHashCode]
                     src/test/pkg/Foo.java:5: error: Missing nullability on field `field` in class `class test.pkg.Foo` [MissingNullability]
+                    src/test/pkg/Foo.java:5: error: Bare field field must be marked final, or moved behind accessors if mutable [MutableBareField]
                 """,
             previouslyReleasedApi =
                 """
@@ -116,10 +116,10 @@ class ApiLintFilteringTest(private val previouslyReleasedApiUse: PreviouslyRelea
                 ),
             expectedIssuesWithoutPreviouslyReleasedApi =
                 """
-                    src/test/pkg/Foo.java:5: error: Must override both equals and hashCode; missing one in test.pkg.Foo [EqualsAndHashCode]
                     src/test/pkg/Foo.java:3: error: Missing nullability on parameter `s` in method `method` [MissingNullability]
-                    src/test/pkg/Foo.java:4: error: Bare field field must be marked final, or moved behind accessors if mutable [MutableBareField]
                     src/test/pkg/Foo.java:4: error: Missing nullability on field `field` in class `class test.pkg.Foo` [MissingNullability]
+                    src/test/pkg/Foo.java:4: error: Bare field field must be marked final, or moved behind accessors if mutable [MutableBareField]
+                    src/test/pkg/Foo.java:5: error: Must override both equals and hashCode; missing one in test.pkg.Foo [EqualsAndHashCode]
                 """,
             previouslyReleasedApi =
                 """
@@ -132,10 +132,10 @@ class ApiLintFilteringTest(private val previouslyReleasedApiUse: PreviouslyRelea
             expectedIssuesWithPreviouslyReleasedApi =
                 // Notice that the `EqualsAndHashCode` issue is reported as a warning, not an error.
                 """
-                    src/test/pkg/Foo.java:5: warning: Must override both equals and hashCode; missing one in test.pkg.Foo (ErrorWhenNew) [EqualsAndHashCode]
                     src/test/pkg/Foo.java:3: error: Missing nullability on parameter `s` in method `method` [MissingNullability]
-                    src/test/pkg/Foo.java:4: error: Bare field field must be marked final, or moved behind accessors if mutable [MutableBareField]
                     src/test/pkg/Foo.java:4: error: Missing nullability on field `field` in class `class test.pkg.Foo` [MissingNullability]
+                    src/test/pkg/Foo.java:4: error: Bare field field must be marked final, or moved behind accessors if mutable [MutableBareField]
+                    src/test/pkg/Foo.java:5: warning: Must override both equals and hashCode; missing one in test.pkg.Foo (ErrorWhenNew) [EqualsAndHashCode]
                 """,
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
index 08c1f0856..ab8d870d0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
@@ -47,11 +47,11 @@ class ApiLintTest : DriverTest() {
                 src/android/pkg/HTMLWriter.java:3: warning: Acronyms should not be capitalized in class names: was `HTMLWriter`, should this be `HtmlWriter`? [AcronymName]
                 src/android/pkg/MyStringImpl.java:3: error: Don't expose your implementation details: `MyStringImpl` ends with `Impl` [EndsWithImpl]
                 src/android/pkg/badlyNamedClass.java:5: error: Class must start with uppercase char: badlyNamedClass [StartWithUpper]
+                src/android/pkg/badlyNamedClass.java:6: error: Constant field names must be named with only upper case characters: `android.pkg.badlyNamedClass#BadlyNamedField`, should be `BADLY_NAMED_FIELD`? [AllUpper]
                 src/android/pkg/badlyNamedClass.java:7: error: Method name must start with lowercase char: BadlyNamedMethod1 [StartWithLower]
                 src/android/pkg/badlyNamedClass.java:9: warning: Acronyms should not be capitalized in method names: was `fromHTMLToHTML`, should this be `fromHtmlToHtml`? [AcronymName]
                 src/android/pkg/badlyNamedClass.java:10: warning: Acronyms should not be capitalized in method names: was `toXML`, should this be `toXml`? [AcronymName]
                 src/android/pkg/badlyNamedClass.java:12: warning: Acronyms should not be capitalized in method names: was `getID`, should this be `getId`? [AcronymName]
-                src/android/pkg/badlyNamedClass.java:6: error: Constant field names must be named with only upper case characters: `android.pkg.badlyNamedClass#BadlyNamedField`, should be `BADLY_NAMED_FIELD`? [AllUpper]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -168,11 +168,11 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
-                src/android/pkg/Constants.java:14: error: All constants must be defined at compile time: android.pkg.Constants#FOO [CompileTimeConstant]
-                src/android/pkg/Constants.java:12: warning: If min/max could change in future, make them dynamic methods: android.pkg.Constants#MAX_FOO [MinMaxConstant]
-                src/android/pkg/Constants.java:11: warning: If min/max could change in future, make them dynamic methods: android.pkg.Constants#MIN_FOO [MinMaxConstant]
-                src/android/pkg/Constants.java:10: error: Constant field names must be named with only upper case characters: `android.pkg.Constants#myStrings`, should be `MY_STRINGS`? [AllUpper]
                 src/android/pkg/Constants.java:8: error: Constant field names must be named with only upper case characters: `android.pkg.Constants#strings`, should be `STRINGS`? [AllUpper]
+                src/android/pkg/Constants.java:10: error: Constant field names must be named with only upper case characters: `android.pkg.Constants#myStrings`, should be `MY_STRINGS`? [AllUpper]
+                src/android/pkg/Constants.java:11: warning: If min/max could change in future, make them dynamic methods: android.pkg.Constants#MIN_FOO [MinMaxConstant]
+                src/android/pkg/Constants.java:12: warning: If min/max could change in future, make them dynamic methods: android.pkg.Constants#MAX_FOO [MinMaxConstant]
+                src/android/pkg/Constants.java:14: error: All constants must be defined at compile time: android.pkg.Constants#FOO [CompileTimeConstant]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -369,8 +369,8 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
-                src/android/accounts/Actions.java:7: error: Intent action constant name must be ACTION_FOO: ACCOUNT_ADDED [IntentName]
                 src/android/accounts/Actions.java:6: error: Inconsistent action value; expected `android.accounts.action.ACCOUNT_OPENED`, was `android.accounts.ACCOUNT_OPENED` [ActionValue]
+                src/android/accounts/Actions.java:7: error: Intent action constant name must be ACTION_FOO: ACCOUNT_ADDED [IntentName]
                 src/android/accounts/Actions.java:8: error: Intent action constant name must be ACTION_FOO: SOMETHING [IntentName]
                 """,
             expectedFail = DefaultLintErrorMessage,
@@ -400,8 +400,8 @@ class ApiLintTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/accounts/Extras.java:5: error: Inconsistent extra value; expected `android.accounts.extra.AUTOMATIC_RULE_ID`, was `android.app.extra.AUTOMATIC_RULE_ID` [ActionValue]
-                src/android/accounts/Extras.java:7: error: Intent extra constant name must be EXTRA_FOO: RULE_ID [IntentName]
                 src/android/accounts/Extras.java:6: error: Intent extra constant name must be EXTRA_FOO: SOMETHING_EXTRA [IntentName]
+                src/android/accounts/Extras.java:7: error: Intent extra constant name must be EXTRA_FOO: RULE_ID [IntentName]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -550,16 +550,16 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
-                src/android/pkg/MyClass.java:11: error: Non-static field ALSO_BAD_CONSTANT must be named using fooBar style [StartWithLower]
-                src/android/pkg/MyClass.java:11: error: Constant ALSO_BAD_CONSTANT must be marked static final [AllUpper]
-                src/android/pkg/MyClass.java:7: error: Non-static field AlsoBadName must be named using fooBar style [StartWithLower]
-                src/android/pkg/MyClass.java:10: error: Bare field BAD_CONSTANT must be marked final, or moved behind accessors if mutable [MutableBareField]
-                src/android/pkg/MyClass.java:10: error: Constant BAD_CONSTANT must be marked static final [AllUpper]
                 src/android/pkg/MyClass.java:5: error: Bare field badMutable must be marked final, or moved behind accessors if mutable [MutableBareField]
-                src/android/pkg/MyClass.java:9: error: Bare field badStaticMutable must be marked final, or moved behind accessors if mutable [MutableBareField]
                 src/android/pkg/MyClass.java:6: error: Internal field mBadName must not be exposed [InternalField]
+                src/android/pkg/MyClass.java:7: error: Non-static field AlsoBadName must be named using fooBar style [StartWithLower]
                 src/android/pkg/MyClass.java:8: error: Constant field names must be named with only upper case characters: `android.pkg.MyClass#sBadStaticName`, should be `S_BAD_STATIC_NAME`? [AllUpper]
                 src/android/pkg/MyClass.java:8: error: Internal field sBadStaticName must not be exposed [InternalField]
+                src/android/pkg/MyClass.java:9: error: Bare field badStaticMutable must be marked final, or moved behind accessors if mutable [MutableBareField]
+                src/android/pkg/MyClass.java:10: error: Constant BAD_CONSTANT must be marked static final [AllUpper]
+                src/android/pkg/MyClass.java:10: error: Bare field BAD_CONSTANT must be marked final, or moved behind accessors if mutable [MutableBareField]
+                src/android/pkg/MyClass.java:11: error: Constant ALSO_BAD_CONSTANT must be marked static final [AllUpper]
+                src/android/pkg/MyClass.java:11: error: Non-static field ALSO_BAD_CONSTANT must be named using fooBar style [StartWithLower]
                 src/android/pkg/MyClass.java:15: error: Internal field mBad must not be exposed [InternalField]
                 """,
             expectedFail = DefaultLintErrorMessage,
@@ -666,9 +666,9 @@ class ApiLintTest : DriverTest() {
                 src/android/pkg/MyClass.java:10: error: Use ListenableFuture (library), or a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal (platform) instead of java.util.concurrent.CompletableFuture (parameter param in android.pkg.MyClass.bad2(java.util.concurrent.CompletableFuture<java.lang.String> param)) [BadFuture]
                 src/android/pkg/MyClass.java:11: error: Use ListenableFuture (library), or a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal (platform) instead of java.util.concurrent.Future (method android.pkg.MyClass.bad3()) [BadFuture]
                 src/android/pkg/MyClass.java:12: error: Use ListenableFuture (library), or a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal (platform) instead of java.util.concurrent.Future (parameter param in android.pkg.MyClass.bad4(java.util.concurrent.Future<java.lang.String> param)) [BadFuture]
-                src/android/pkg/MyClass.java:21: error: BadCompletableFuture should not extend `java.util.concurrent.CompletableFuture`. In AndroidX, use (but do not extend) ListenableFuture. In platform, use a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal`. [BadFuture]
                 src/android/pkg/MyClass.java:17: error: BadFuture should not extend `java.util.concurrent.Future`. In AndroidX, use (but do not extend) ListenableFuture. In platform, use a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal`. [BadFuture]
                 src/android/pkg/MyClass.java:19: error: BadFutureClass should not implement `java.util.concurrent.Future`. In AndroidX, use (but do not extend) ListenableFuture. In platform, use a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal`. [BadFuture]
+                src/android/pkg/MyClass.java:21: error: BadCompletableFuture should not extend `java.util.concurrent.CompletableFuture`. In AndroidX, use (but do not extend) ListenableFuture. In platform, use a combination of OutcomeReceiver<R,E>, Executor, and CancellationSignal`. [BadFuture]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -720,9 +720,9 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
+                src/android/pkg/MyClass.java:14: error: Don't expose @StringDef: SomeString must be hidden. [PublicTypedef]
                 src/android/pkg/MyClass.java:19: error: Don't expose @IntDef: SomeInt must be hidden. [PublicTypedef]
                 src/android/pkg/MyClass.java:24: error: Don't expose @LongDef: SomeLong must be hidden. [PublicTypedef]
-                src/android/pkg/MyClass.java:14: error: Don't expose @StringDef: SomeString must be hidden. [PublicTypedef]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -857,9 +857,9 @@ class ApiLintTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/pkg/MyClass1.java:3: error: Inconsistent class name; should be `<Foo>Activity`, was `MyClass1` [ContextNameSuffix]
+                src/android/pkg/MyClass1.java:3: error: MyClass1 should not extend `Activity`. Activity subclasses are impossible to compose. Expose a composable API instead. [ForbiddenSuperClass]
                 src/android/pkg/MyClass1.java:6: warning: Methods implemented by developers should follow the on<Something> style, was `badlyNamedAbstractMethod` [OnNameExpected]
                 src/android/pkg/MyClass1.java:7: warning: If implemented by developer, should follow the on<Something> style; otherwise consider marking final [OnNameExpected]
-                src/android/pkg/MyClass1.java:3: error: MyClass1 should not extend `Activity`. Activity subclasses are impossible to compose. Expose a composable API instead. [ForbiddenSuperClass]
                 src/android/pkg/MyClass2.java:3: error: Inconsistent class name; should be `<Foo>Provider`, was `MyClass2` [ContextNameSuffix]
                 src/android/pkg/MyClass3.java:3: error: Inconsistent class name; should be `<Foo>Service`, was `MyClass3` [ContextNameSuffix]
                 src/android/pkg/MyClass4.java:3: error: Inconsistent class name; should be `<Foo>Receiver`, was `MyClass4` [ContextNameSuffix]
@@ -1026,9 +1026,9 @@ class ApiLintTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/content/MyClass1.java:8: warning: Field type `android.view.View` violates package layering: nothing in `package android.content` should depend on `package android.view` [PackageLayering]
-                src/android/content/MyClass1.java:8: warning: Method return type `android.view.View` violates package layering: nothing in `package android.content` should depend on `package android.view` [PackageLayering]
                 src/android/content/MyClass1.java:8: warning: Method parameter type `android.view.View` violates package layering: nothing in `package android.content` should depend on `package android.view` [PackageLayering]
                 src/android/content/MyClass1.java:8: warning: Method parameter type `android.view.View` violates package layering: nothing in `package android.content` should depend on `package android.view` [PackageLayering]
+                src/android/content/MyClass1.java:8: warning: Method return type `android.view.View` violates package layering: nothing in `package android.content` should depend on `package android.view` [PackageLayering]
                 """,
             sourceFiles =
                 arrayOf(
@@ -1311,8 +1311,8 @@ class ApiLintTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/pkg/MyClass.java:6: error: Parameter type is concrete collection (`java.util.HashMap`); must be higher-level interface [ConcreteCollection]
-                src/android/pkg/MyClass.java:10: error: Return type is concrete collection (`java.util.Vector`); must be higher-level interface [ConcreteCollection]
                 src/android/pkg/MyClass.java:10: error: Parameter type is concrete collection (`java.util.LinkedList`); must be higher-level interface [ConcreteCollection]
+                src/android/pkg/MyClass.java:10: error: Return type is concrete collection (`java.util.Vector`); must be higher-level interface [ConcreteCollection]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -1411,9 +1411,9 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
+                src/android/pkg/MyClass.java:7: error: Type must not be heavy BitSet (field android.pkg.MyClass.bitset) [HeavyBitSet]
                 src/android/pkg/MyClass.java:9: error: Type must not be heavy BitSet (method android.pkg.MyClass.reverse(java.util.BitSet)) [HeavyBitSet]
                 src/android/pkg/MyClass.java:9: error: Type must not be heavy BitSet (parameter bitset in android.pkg.MyClass.reverse(java.util.BitSet bitset)) [HeavyBitSet]
-                src/android/pkg/MyClass.java:7: error: Type must not be heavy BitSet (field android.pkg.MyClass.bitset) [HeavyBitSet]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -1716,8 +1716,8 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
-                src/android/pkg/MyClass.java:16: warning: Registration methods should have overload that accepts delivery Executor: `registerWrongCallback` [ExecutorRegistration]
                 src/android/pkg/MyClass.java:6: warning: Registration methods should have overload that accepts delivery Executor: `MyClass` [ExecutorRegistration]
+                src/android/pkg/MyClass.java:16: warning: Registration methods should have overload that accepts delivery Executor: `registerWrongCallback` [ExecutorRegistration]
                 """,
             sourceFiles =
                 arrayOf(
@@ -1831,8 +1831,8 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
-                src/android/pkg/CheckFiles.java:13: warning: Methods accepting `File` should also accept `FileDescriptor` or streams: method android.pkg.CheckFiles.error(int,java.io.File) [StreamFiles]
                 src/android/pkg/CheckFiles.java:9: warning: Methods accepting `File` should also accept `FileDescriptor` or streams: constructor android.pkg.CheckFiles(android.content.Context,java.io.File) [StreamFiles]
+                src/android/pkg/CheckFiles.java:13: warning: Methods accepting `File` should also accept `FileDescriptor` or streams: method android.pkg.CheckFiles.error(int,java.io.File) [StreamFiles]
                 """,
             sourceFiles =
                 arrayOf(
@@ -1865,8 +1865,8 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
-                src/android/pkg/CheckFiles.java:13: warning: Methods accepting `File` should also accept `FileDescriptor` or streams: method android.pkg.CheckFiles.error(int,java.io.File) [StreamFiles]
                 src/android/pkg/CheckFiles.java:9: warning: Methods accepting `File` should also accept `FileDescriptor` or streams: constructor android.pkg.CheckFiles(android.content.Context,java.io.File) [StreamFiles]
+                src/android/pkg/CheckFiles.java:13: warning: Methods accepting `File` should also accept `FileDescriptor` or streams: method android.pkg.CheckFiles.error(int,java.io.File) [StreamFiles]
                 """,
             sourceFiles =
                 arrayOf(
@@ -2391,9 +2391,9 @@ class ApiLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
+                src/android/content/Context.java:10: error: Inconsistent service value; expected `other`, was `something` (Note: Do not change the name of already released services, which will break tools using `adb shell dumpsys`. Instead add `@SuppressLint("ServiceName"))` [ServiceName]
                 src/android/content/Context.java:11: error: Inconsistent service constant name; expected `SOMETHING_SERVICE`, was `OTHER_MANAGER` [ServiceName]
                 src/android/content/Context.java:12: error: Inconsistent service constant name; expected `OTHER_SERVICE`, was `OTHER_MANAGER_SERVICE` [ServiceName]
-                src/android/content/Context.java:10: error: Inconsistent service value; expected `other`, was `something` (Note: Do not change the name of already released services, which will break tools using `adb shell dumpsys`. Instead add `@SuppressLint("ServiceName"))` [ServiceName]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -2909,8 +2909,8 @@ class ApiLintTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/pkg/Cases.java:7: error: Cases.BadCallback can be replaced with OutcomeReceiver<R,E> (platform) or suspend fun / ListenableFuture (AndroidX). [GenericCallbacks]
-                src/android/pkg/Cases.java:15: error: Cases.BadGenericListener can be replaced with OutcomeReceiver<R,E> (platform) or suspend fun / ListenableFuture (AndroidX). [GenericCallbacks]
                 src/android/pkg/Cases.java:11: error: Cases.BadListener can be replaced with OutcomeReceiver<R,E> (platform) or suspend fun / ListenableFuture (AndroidX). [GenericCallbacks]
+                src/android/pkg/Cases.java:15: error: Cases.BadGenericListener can be replaced with OutcomeReceiver<R,E> (platform) or suspend fun / ListenableFuture (AndroidX). [GenericCallbacks]
             """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -3019,13 +3019,6 @@ class ApiLintTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-src/android/pkg/Interface.kt:104: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
-src/android/pkg/Interface.kt:114: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
-src/android/pkg/Interface.kt:125: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
-src/android/pkg/Interface.kt:136: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
-src/android/pkg/Interface.kt:142: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
-src/android/pkg/Interface.kt:152: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
-src/android/pkg/Interface.kt:158: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
 src/android/pkg/Interface.kt:18: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
 src/android/pkg/Interface.kt:28: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
 src/android/pkg/Interface.kt:39: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
@@ -3035,6 +3028,13 @@ src/android/pkg/Interface.kt:66: error: Parameter `default` has a default value
 src/android/pkg/Interface.kt:72: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
 src/android/pkg/Interface.kt:82: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
 src/android/pkg/Interface.kt:92: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:104: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:114: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:125: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:136: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:142: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:152: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
+src/android/pkg/Interface.kt:158: error: Parameter `default` has a default value and should come after all parameters without default values (except for a trailing lambda parameter) [KotlinDefaultParameterOrder]
             """
                     .trimIndent(),
             expectedFail = DefaultLintErrorMessage,
@@ -3273,4 +3273,35 @@ src/android/pkg/Interface.kt:92: error: Parameter `default` has a default value
                 )
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `throw unresolved error`() {
+        // Regression test from b/364736827
+        check(
+            expectedIssues = "",
+            apiLint = "",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+
+                        import kotlin.random.Random
+
+                        public class SubspaceSemanticsNodeInteraction() {
+                            /**
+                             * @throws [UnresolvedAssertionError] if failed
+                             */
+                            public fun assertDoesNotExist() {
+                                if (Random.nextBoolean()) {
+                                    throw UnresolvedAssertionError("Failed")
+                                }
+                            }
+                        }
+                    """
+                    )
+                )
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/AutoBoxingTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/AutoBoxingTest.kt
index 93c94f26e..80e369593 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/AutoBoxingTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/AutoBoxingTest.kt
@@ -35,11 +35,11 @@ class AutoBoxingTest : DriverTest() {
                 """
                 src/test/pkg/KotlinClass.kt:4: error: Must avoid boxed primitives (`java.lang.Double`) [AutoBoxing]
                 src/test/pkg/KotlinClass.kt:6: error: Must avoid boxed primitives (`java.lang.Boolean`) [AutoBoxing]
+                src/test/pkg/MyClass.java:7: error: Must avoid boxed primitives (`java.lang.Integer`) [AutoBoxing]
                 src/test/pkg/MyClass.java:9: error: Must avoid boxed primitives (`java.lang.Long`) [AutoBoxing]
-                src/test/pkg/MyClass.java:12: error: Must avoid boxed primitives (`java.lang.Short`) [AutoBoxing]
                 src/test/pkg/MyClass.java:12: error: Must avoid boxed primitives (`java.lang.Double`) [AutoBoxing]
+                src/test/pkg/MyClass.java:12: error: Must avoid boxed primitives (`java.lang.Short`) [AutoBoxing]
                 src/test/pkg/MyClass.java:14: error: Must avoid boxed primitives (`java.lang.Boolean`) [AutoBoxing]
-                src/test/pkg/MyClass.java:7: error: Must avoid boxed primitives (`java.lang.Integer`) [AutoBoxing]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/CheckBuilderTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/CheckBuilderTest.kt
index f74f3a8f7..5d6a9629b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/CheckBuilderTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/CheckBuilderTest.kt
@@ -34,19 +34,19 @@ class CheckBuilderTest : DriverTest() {
                 src/android/pkg/Bad.java:13: warning: Builder must be final: android.pkg.Bad.BadBuilder [StaticFinalBuilder]
                 src/android/pkg/Bad.java:13: warning: Builder must be static: android.pkg.Bad.BadBuilder [StaticFinalBuilder]
                 src/android/pkg/Bad.java:14: warning: Builder constructor arguments must be mandatory (i.e. not @Nullable): parameter badParameter in android.pkg.Bad.BadBuilder(String badParameter) [OptionalBuilderConstructorArgument]
-                src/android/pkg/Bad.java:38: warning: Builder methods names should use setFoo() / addFoo() / clearFoo() style: method android.pkg.Bad.BadBuilder.withBadSetterStyle(boolean) [BuilderSetStyle]
-                src/android/pkg/Bad.java:41: warning: Builder setter must be @NonNull: method android.pkg.Bad.BadBuilder.setReturnsNullable(boolean) [SetterReturnsThis]
-                src/android/pkg/Bad.java:43: warning: Getter should be on the built object, not the builder: method android.pkg.Bad.BadBuilder.getOnBuilder() [GetterOnBuilder]
-                src/android/pkg/Bad.java:45: warning: Methods must return the builder object (return type android.pkg.Bad.BadBuilder instead of void): method android.pkg.Bad.BadBuilder.setNotReturningBuilder(boolean) [SetterReturnsThis]
                 src/android/pkg/Bad.java:20: warning: android.pkg.Bad does not declare a `getWithoutMatchingGetters()` method matching method android.pkg.Bad.BadBuilder.addWithoutMatchingGetter(String) [MissingGetterMatchingBuilder]
                 src/android/pkg/Bad.java:23: warning: android.pkg.Bad does not declare a `isWithoutMatchingGetter()` method matching method android.pkg.Bad.BadBuilder.setWithoutMatchingGetter(boolean) [MissingGetterMatchingBuilder]
                 src/android/pkg/Bad.java:26: warning: android.pkg.Bad does not declare a `getPluralWithoutMatchingGetters()` method matching method android.pkg.Bad.BadBuilder.addPluralWithoutMatchingGetter(java.util.Collection<java.lang.String>) [MissingGetterMatchingBuilder]
                 src/android/pkg/Bad.java:32: warning: android.pkg.Bad does not declare a getter method matching method android.pkg.Bad.BadBuilder.addPluralWithoutMatchingGetters(java.util.Collection<java.lang.String>) (expected one of: [getPluralWithoutMatchingGetters(), getPluralWithoutMatchingGetterses()]) [MissingGetterMatchingBuilder]
+                src/android/pkg/Bad.java:38: warning: Builder methods names should use setFoo() / addFoo() / clearFoo() style: method android.pkg.Bad.BadBuilder.withBadSetterStyle(boolean) [BuilderSetStyle]
+                src/android/pkg/Bad.java:41: warning: Builder setter must be @NonNull: method android.pkg.Bad.BadBuilder.setReturnsNullable(boolean) [SetterReturnsThis]
+                src/android/pkg/Bad.java:43: warning: Getter should be on the built object, not the builder: method android.pkg.Bad.BadBuilder.getOnBuilder() [GetterOnBuilder]
                 src/android/pkg/Bad.java:45: warning: android.pkg.Bad does not declare a `isNotReturningBuilder()` method matching method android.pkg.Bad.BadBuilder.setNotReturningBuilder(boolean) [MissingGetterMatchingBuilder]
-                src/android/pkg/Bad.java:57: warning: Methods must return the builder object (return type android.pkg.Bad.BadGenericBuilder<T> instead of T): method android.pkg.Bad.BadGenericBuilder.setBoolean(boolean) [SetterReturnsThis]
+                src/android/pkg/Bad.java:45: warning: Methods must return the builder object (return type android.pkg.Bad.BadBuilder instead of void): method android.pkg.Bad.BadBuilder.setNotReturningBuilder(boolean) [SetterReturnsThis]
                 src/android/pkg/Bad.java:51: warning: android.pkg.Bad.NoBuildMethodBuilder does not declare a `build()` method, but builder classes are expected to [MissingBuildMethod]
-                src/android/pkg/TopLevelBuilder.java:3: warning: Builder should be defined as inner class: android.pkg.TopLevelBuilder [TopLevelBuilder]
+                src/android/pkg/Bad.java:57: warning: Methods must return the builder object (return type android.pkg.Bad.BadGenericBuilder<T> instead of T): method android.pkg.Bad.BadGenericBuilder.setBoolean(boolean) [SetterReturnsThis]
                 src/android/pkg/TopLevelBuilder.java:3: warning: android.pkg.TopLevelBuilder does not declare a `build()` method, but builder classes are expected to [MissingBuildMethod]
+                src/android/pkg/TopLevelBuilder.java:3: warning: Builder should be defined as inner class: android.pkg.TopLevelBuilder [TopLevelBuilder]
                 src/test/pkg/BadClass.java:6: warning: Builder must be final: test.pkg.BadClass.Builder [StaticFinalBuilder]
                 src/test/pkg/BadInterface.java:6: warning: Builder must be final: test.pkg.BadInterface.Builder [StaticFinalBuilder]
                 """,
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt
index d1b30daca..0c5c19ea5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/FlaggedApiLintTest.kt
@@ -108,16 +108,16 @@ class FlaggedApiLintTest : DriverTest() {
             expectedIssues =
                 """
                     src/android/foobar/Bad.java:3: warning: New API must be flagged with @FlaggedApi: class android.foobar.Bad [UnflaggedApi]
-                    src/android/foobar/Bad.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.Bad.bad() [UnflaggedApi]
-                    src/android/foobar/BadHiddenSuperClass.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.Bad.inheritedBad() [UnflaggedApi]
                     src/android/foobar/Bad.java:4: warning: New API must be flagged with @FlaggedApi: field android.foobar.Bad.BAD [UnflaggedApi]
-                    src/android/foobar/BadHiddenSuperClass.java:4: warning: New API must be flagged with @FlaggedApi: field android.foobar.Bad.INHERITED_BAD [UnflaggedApi]
-                    src/android/foobar/Bad.java:7: warning: New API must be flagged with @FlaggedApi: class android.foobar.Bad.BadAnnotation [UnflaggedApi]
+                    src/android/foobar/Bad.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.Bad.bad() [UnflaggedApi]
                     src/android/foobar/Bad.java:6: warning: New API must be flagged with @FlaggedApi: class android.foobar.Bad.BadInterface [UnflaggedApi]
-                    src/android/foobar/ExistingClass.java:10: warning: New API must be flagged with @FlaggedApi: method android.foobar.ExistingClass.bad() [UnflaggedApi]
+                    src/android/foobar/Bad.java:7: warning: New API must be flagged with @FlaggedApi: class android.foobar.Bad.BadAnnotation [UnflaggedApi]
+                    src/android/foobar/BadHiddenSuperClass.java:4: warning: New API must be flagged with @FlaggedApi: field android.foobar.Bad.INHERITED_BAD [UnflaggedApi]
+                    src/android/foobar/BadHiddenSuperClass.java:4: warning: New API must be flagged with @FlaggedApi: field android.foobar.ExistingClass.INHERITED_BAD [UnflaggedApi]
+                    src/android/foobar/BadHiddenSuperClass.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.Bad.inheritedBad() [UnflaggedApi]
                     src/android/foobar/BadHiddenSuperClass.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.ExistingClass.inheritedBad() [UnflaggedApi]
                     src/android/foobar/ExistingClass.java:9: warning: New API must be flagged with @FlaggedApi: field android.foobar.ExistingClass.BAD [UnflaggedApi]
-                    src/android/foobar/BadHiddenSuperClass.java:4: warning: New API must be flagged with @FlaggedApi: field android.foobar.ExistingClass.INHERITED_BAD [UnflaggedApi]
+                    src/android/foobar/ExistingClass.java:10: warning: New API must be flagged with @FlaggedApi: method android.foobar.ExistingClass.bad() [UnflaggedApi]
                 """,
             apiLint =
                 """
@@ -282,8 +282,8 @@ class FlaggedApiLintTest : DriverTest() {
             showAnnotations = arrayOf("android.annotation.SystemApi"),
             expectedIssues =
                 """
-                    src/android/foobar/BadHiddenSuperClass.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.Bad.badInherited() [UnflaggedApi]
                     src/android/foobar/BadHiddenSuperClass.java:4: warning: New API must be flagged with @FlaggedApi: field android.foobar.Bad.BAD_INHERITED [UnflaggedApi]
+                    src/android/foobar/BadHiddenSuperClass.java:5: warning: New API must be flagged with @FlaggedApi: method android.foobar.Bad.badInherited() [UnflaggedApi]
                 """,
             apiLint =
                 """
@@ -432,13 +432,13 @@ class FlaggedApiLintTest : DriverTest() {
             expectedIssues =
                 """
                     src/android/foobar/Bad.java:6: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
+                    src/android/foobar/Bad.java:8: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
                     src/android/foobar/Bad.java:10: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
+                    src/android/foobar/Bad.java:12: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
+                    src/android/foobar/Bad.java:14: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
                     src/android/foobar/Bad.java:17: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (furthermore, the current flag literal seems to be malformed). (ErrorWhenNew) [FlaggedApiLiteral]
                     src/android/foobar/Bad.java:19: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_NONEXISTENT_FLAG, however this flag doesn't seem to exist). (ErrorWhenNew) [FlaggedApiLiteral]
                     src/android/foobar/Bad.java:21: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.baz.Flags.FLAG_NON_EXISTENT_PACKAGE, however this flag doesn't seem to exist). (ErrorWhenNew) [FlaggedApiLiteral]
-                    src/android/foobar/Bad.java:8: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
-                    src/android/foobar/Bad.java:14: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
-                    src/android/foobar/Bad.java:12: warning: @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.foobar.Flags.FLAG_MY_FEATURE). (ErrorWhenNew) [FlaggedApiLiteral]
                 """,
             apiLint = "",
             sourceFiles =
@@ -580,7 +580,7 @@ class FlaggedApiLintTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/Foo.java:7: warning: Changes from not deprecated to deprecated must be flagged with @FlaggedApi: class test.pkg.Foo [UnflaggedApi]
+                    src/test/pkg/Foo.java:6: warning: Changes from not deprecated to deprecated must be flagged with @FlaggedApi: class test.pkg.Foo [UnflaggedApi]
                 """,
             apiLint =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt
index 51ad1d1aa..3ef1329f0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/NullabilityLintTest.kt
@@ -37,11 +37,11 @@ class NullabilityLintTest : DriverTest() {
             apiLint = "", // enabled
             expectedIssues =
                 """
+                src/android/pkg/Foo.java:7: error: Missing nullability on field `badField` in class `class android.pkg.Foo` [MissingNullability]
                 src/android/pkg/Foo.java:11: error: Missing nullability on parameter `name` in method `Foo` [MissingNullability]
                 src/android/pkg/Foo.java:12: error: Missing nullability on parameter `value` in method `setBadValue` [MissingNullability]
                 src/android/pkg/Foo.java:13: error: Missing nullability on method `getBadValue` return [MissingNullability]
                 src/android/pkg/Foo.java:20: error: Missing nullability on parameter `duration` in method `methodMissingParamAnnotations` [MissingNullability]
-                src/android/pkg/Foo.java:7: error: Missing nullability on field `badField` in class `class android.pkg.Foo` [MissingNullability]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -330,12 +330,12 @@ class NullabilityLintTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.java:16: error: Invalid nullability on type java.lang.String in method `bar` return. Method override cannot use a nullable type when the corresponding type from the super method is platform-nullness. [InvalidNullabilityOverride]
-                src/test/pkg/Foo.java:16: error: Invalid nullability on type java.lang.String in parameter `baz` in method `bar`. Parameter in method override cannot use a non-null type when the corresponding type from the super method is platform-nullness. [InvalidNullabilityOverride]
-                src/test/pkg/Foo.java:19: error: Invalid nullability on type java.lang.String in parameter `y` in method `x`. Parameter in method override cannot use a non-null type when the corresponding type from the super method is platform-nullness. [InvalidNullabilityOverride]
                 src/test/pkg/Foo.java:8: error: Missing nullability on method `bar` return [MissingNullability]
                 src/test/pkg/Foo.java:8: error: Missing nullability on parameter `baz` in method `bar` [MissingNullability]
                 src/test/pkg/Foo.java:11: error: Missing nullability on parameter `y` in method `x` [MissingNullability]
+                src/test/pkg/Foo.java:16: error: Invalid nullability on type java.lang.String in method `bar` return. Method override cannot use a nullable type when the corresponding type from the super method is platform-nullness. [InvalidNullabilityOverride]
+                src/test/pkg/Foo.java:16: error: Invalid nullability on type java.lang.String in parameter `baz` in method `bar`. Parameter in method override cannot use a non-null type when the corresponding type from the super method is platform-nullness. [InvalidNullabilityOverride]
+                src/test/pkg/Foo.java:19: error: Invalid nullability on type java.lang.String in parameter `y` in method `x`. Parameter in method override cannot use a non-null type when the corresponding type from the super method is platform-nullness. [InvalidNullabilityOverride]
                 """,
             apiLint = "",
             expectedFail = DefaultLintErrorMessage,
@@ -679,14 +679,14 @@ class NullabilityLintTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                    src/test/pkg/Foo.java:5: error: Missing nullability on method `getArray` return [MissingNullability]
                     src/test/pkg/Foo.java:5: error: Missing nullability on inner type java.lang.String in method `getArray` return [MissingInnerNullability]
-                    src/test/pkg/Foo.java:6: error: Missing nullability on method `getMap` return [MissingNullability]
+                    src/test/pkg/Foo.java:5: error: Missing nullability on method `getArray` return [MissingNullability]
                     src/test/pkg/Foo.java:6: error: Missing nullability on inner type java.lang.Number in method `getMap` return [MissingInnerNullability]
                     src/test/pkg/Foo.java:6: error: Missing nullability on inner type java.lang.String in method `getMap` return [MissingInnerNullability]
-                    src/test/pkg/Foo.java:7: error: Missing nullability on method `getWildcardMap` return [MissingNullability]
+                    src/test/pkg/Foo.java:6: error: Missing nullability on method `getMap` return [MissingNullability]
                     src/test/pkg/Foo.java:7: error: Missing nullability on inner type java.lang.Number in method `getWildcardMap` return [MissingInnerNullability]
                     src/test/pkg/Foo.java:7: error: Missing nullability on inner type java.lang.String in method `getWildcardMap` return [MissingInnerNullability]
+                    src/test/pkg/Foo.java:7: error: Missing nullability on method `getWildcardMap` return [MissingNullability]
                 """,
             sourceFiles =
                 arrayOf(
@@ -714,8 +714,8 @@ class NullabilityLintTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                    src/test/pkg/Foo.java:7: error: Invalid nullability on type java.lang.String method `foo` return. Method override cannot use a nullable type when the corresponding type from the super method is non-null. [InvalidNullabilityOverride]
                     src/test/pkg/Foo.java:7: error: Invalid nullability on type java.lang.String in parameter `arg` in method `foo`. Parameter in method override cannot use a non-null type when the corresponding type from the super method is nullable. [InvalidNullabilityOverride]
+                    src/test/pkg/Foo.java:7: error: Invalid nullability on type java.lang.String method `foo` return. Method override cannot use a nullable type when the corresponding type from the super method is non-null. [InvalidNullabilityOverride]
                 """,
             sourceFiles =
                 arrayOf(
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
index 6f60249c3..3f21f413c 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
@@ -18,7 +18,6 @@ package com.android.tools.metalava.stub
 
 import com.android.tools.metalava.ARG_EXCLUDE_ALL_ANNOTATIONS
 import com.android.tools.metalava.ARG_EXCLUDE_ANNOTATION
-import com.android.tools.metalava.ARG_HIDE_PACKAGE
 import com.android.tools.metalava.ARG_PASS_THROUGH_ANNOTATION
 import com.android.tools.metalava.androidxNullableSource
 import com.android.tools.metalava.libcoreNonNullSource
@@ -26,6 +25,7 @@ import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.requiresApiSource
 import com.android.tools.metalava.supportParameterName
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -324,8 +324,6 @@ class StubsAnnotationTest : AbstractStubsTest() {
                 arrayOf(
                     ARG_PASS_THROUGH_ANNOTATION,
                     "androidx.annotation.RequiresApi,androidx.annotation.Nullable",
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation"
                 ),
             sourceFiles =
                 arrayOf(
@@ -342,7 +340,9 @@ class StubsAnnotationTest : AbstractStubsTest() {
                     ),
                     supportParameterName,
                     requiresApiSource,
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             source =
                 """
@@ -350,10 +350,10 @@ class StubsAnnotationTest : AbstractStubsTest() {
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public class MyClass {
                 public MyClass() { throw new RuntimeException("Stub!"); }
-                @androidx.annotation.RequiresApi(21)
-                public void testMethod() { throw new RuntimeException("Stub!"); }
                 @androidx.annotation.Nullable
                 public java.lang.String anotherTestMethod() { throw new RuntimeException("Stub!"); }
+                @androidx.annotation.RequiresApi(21)
+                public void testMethod() { throw new RuntimeException("Stub!"); }
                 }
                  """
         )
@@ -515,6 +515,22 @@ class StubsAnnotationTest : AbstractStubsTest() {
                 @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
                 @java.lang.annotation.Target({java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD})
                 public @interface ExportedProperty {
+                public java.lang.String category() default "";
+                public float floating() default 1.0f;
+                public boolean formatToHexString() default false;
+                public double from() default java.lang.Double.NEGATIVE_INFINITY;
+                public double fromWithCast() default (double)java.lang.Float.NEGATIVE_INFINITY;
+                public boolean hasAdjacentMapping() default false;
+                public int integer() default 1;
+                public double large_floating() default 1.0;
+                public long large_integer() default 1L;
+                public char letter() default 'a';
+                public char[] letters1() default {};
+                public char[] letters2() default {'a', 'b', 'c'};
+                public int math() default 7;
+                public short medium() default 1;
+                public java.lang.Class<? extends java.lang.Number> myCls() default java.lang.Integer.class;
+                public java.lang.String prefix() default "";
                 /**
                  * When resolveId is true, and if the annotated field/method return value
                  * is an int, the value is converted to an Android's resource name.
@@ -523,25 +539,9 @@ class StubsAnnotationTest : AbstractStubsTest() {
                  * resource name, false otherwise
                  */
                 public boolean resolveId() default false;
-                public java.lang.String prefix() default "";
-                public java.lang.String category() default "";
-                public boolean formatToHexString() default false;
-                public boolean hasAdjacentMapping() default false;
-                public java.lang.Class<? extends java.lang.Number> myCls() default java.lang.Integer.class;
-                public char[] letters1() default {};
-                public char[] letters2() default {'a', 'b', 'c'};
-                public double from() default java.lang.Double.NEGATIVE_INFINITY;
-                public double fromWithCast() default (double)java.lang.Float.NEGATIVE_INFINITY;
-                public test.pkg.ExportedProperty.InnerAnnotation value() default @test.pkg.ExportedProperty.InnerAnnotation;
-                public char letter() default 'a';
-                public int integer() default 1;
-                public long large_integer() default 1L;
-                public float floating() default 1.0f;
-                public double large_floating() default 1.0;
                 public byte small() default 1;
-                public short medium() default 1;
-                public int math() default 7;
                 public int unit() default test.pkg.ExportedProperty.PX;
+                public test.pkg.ExportedProperty.InnerAnnotation value() default @test.pkg.ExportedProperty.InnerAnnotation;
                 public static final int DP = 0; // 0x0
                 public static final int PX = 1; // 0x1
                 public static final int SP = 2; // 0x2
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsClassTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsClassTest.kt
index 1bf277422..968c542f2 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsClassTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsClassTest.kt
@@ -179,10 +179,10 @@ class StubsClassTest : AbstractStubsTest() {
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public class MyClass extends test.pkg.PublicParent {
                 public MyClass() { throw new RuntimeException("Stub!"); }
-                public void method4() { throw new RuntimeException("Stub!"); }
-                public static void method3b() { throw new RuntimeException("Stub!"); }
                 public void method2() { throw new RuntimeException("Stub!"); }
                 public void method3() { throw new RuntimeException("Stub!"); }
+                public static void method3b() { throw new RuntimeException("Stub!"); }
+                public void method4() { throw new RuntimeException("Stub!"); }
                 public static final java.lang.String CONSTANT = "MyConstant";
                 }
                 """,
@@ -332,11 +332,11 @@ class StubsClassTest : AbstractStubsTest() {
             format = FileFormat.V2,
             expectedIssues =
                 """
-                src/test/pkg/PublicApi.java:4: error: Class test.pkg.HiddenType is not public but was referenced (in return type) from public method test.pkg.PublicApi.getHiddenType() [ReferencesHidden]
-                src/test/pkg/PublicApi.java:5: error: Class test.pkg.HiddenType4 is hidden but was referenced (in return type) from public method test.pkg.PublicApi.getHiddenType4() [ReferencesHidden]
-                src/test/pkg/PublicApi.java:5: warning: Return type of unavailable type test.pkg.HiddenType4 in test.pkg.PublicApi.getHiddenType4() [UnavailableSymbol]
                 src/test/pkg/PublicApi.java:4: warning: Method test.pkg.PublicApi.getHiddenType() references hidden type test.pkg.HiddenType. [HiddenTypeParameter]
+                src/test/pkg/PublicApi.java:4: error: Class test.pkg.HiddenType is not public but was referenced (in return type) from public method test.pkg.PublicApi.getHiddenType() [ReferencesHidden]
                 src/test/pkg/PublicApi.java:5: warning: Method test.pkg.PublicApi.getHiddenType4() references hidden type test.pkg.HiddenType4. [HiddenTypeParameter]
+                src/test/pkg/PublicApi.java:5: warning: Return type of unavailable type test.pkg.HiddenType4 in test.pkg.PublicApi.getHiddenType4() [UnavailableSymbol]
+                src/test/pkg/PublicApi.java:5: error: Class test.pkg.HiddenType4 is hidden but was referenced (in return type) from public method test.pkg.PublicApi.getHiddenType4() [ReferencesHidden]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
@@ -450,8 +450,8 @@ class StubsClassTest : AbstractStubsTest() {
             format = FileFormat.V2,
             expectedIssues =
                 """
-                src/test/pkg/PublicApi.java:4: error: Class test.pkg.PublicApi.HiddenInner is hidden but was referenced (in parameter type) from public parameter inner in test.pkg.PublicApi(test.pkg.PublicApi.HiddenInner inner) [ReferencesHidden]
                 src/test/pkg/PublicApi.java:4: warning: Parameter inner references hidden type test.pkg.PublicApi.HiddenInner. [HiddenTypeParameter]
+                src/test/pkg/PublicApi.java:4: error: Class test.pkg.PublicApi.HiddenInner is hidden but was referenced (in parameter type) from public parameter inner in test.pkg.PublicApi(test.pkg.PublicApi.HiddenInner inner) [ReferencesHidden]
                 """,
             expectedFail = DefaultLintErrorMessage,
             sourceFiles =
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
index 2aa68c8ec..99dc5e593 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
@@ -140,11 +140,11 @@ class StubsConstructorTest : AbstractStubsTest() {
                     public Constructors() { throw new RuntimeException("Stub!"); }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child extends test.pkg.Constructors.Parent {
-                    public Child(java.lang.String arg1, int arg2, long arg3, boolean arg4, short arg5) { super(null, 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
+                    public Child(java.lang.String arg1, int arg2, long arg3, boolean arg4, short arg5) { super("", 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child2 extends test.pkg.Constructors.Parent {
-                    Child2() { super(null, 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
+                    Child2() { super("", 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child3 extends test.pkg.Constructors.Child2 {
@@ -152,7 +152,7 @@ class StubsConstructorTest : AbstractStubsTest() {
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child4 extends test.pkg.Constructors.Parent {
-                    Child4() { super(null, 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
+                    Child4() { super("", 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Parent {
@@ -224,11 +224,11 @@ class StubsConstructorTest : AbstractStubsTest() {
                     public Constructors() { throw new RuntimeException("Stub!"); }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child extends test.pkg.Constructors.Parent {
-                    public Child(java.lang.String s, int i, long l, boolean b, short sh) { super(null, 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
+                    public Child(java.lang.String s, int i, long l, boolean b, short sh) { super("", 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child2 extends test.pkg.Constructors.Parent {
-                    Child2() { super(null, 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
+                    Child2() { super("", 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child3 extends test.pkg.Constructors.Child2 {
@@ -236,7 +236,7 @@ class StubsConstructorTest : AbstractStubsTest() {
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Child4 extends test.pkg.Constructors.Parent {
-                    Child4() { super(null, 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
+                    Child4() { super("", 0, 0, false, (short)0); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Parent {
@@ -635,7 +635,7 @@ class StubsConstructorTest : AbstractStubsTest() {
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class ClipDrawable extends test.pkg.Constructors2.DrawableWrapper {
-                    public ClipDrawable(test.pkg.Constructors2.Drawable drawable, int gravity, int orientation) { super(null); throw new RuntimeException("Stub!"); }
+                    public ClipDrawable(test.pkg.Constructors2.Drawable drawable, int gravity, int orientation) { super((test.pkg.Constructors2.Drawable)null); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class Drawable {
@@ -659,11 +659,11 @@ class StubsConstructorTest : AbstractStubsTest() {
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class TestSuite implements test.pkg.Constructors2.Test {
                     public TestSuite() { throw new RuntimeException("Stub!"); }
-                    public TestSuite(java.lang.Class<?> theClass) { throw new RuntimeException("Stub!"); }
                     public TestSuite(java.lang.Class<? extends test.pkg.Constructors2.TestCase> theClass, java.lang.String name) { throw new RuntimeException("Stub!"); }
-                    public TestSuite(java.lang.String name) { throw new RuntimeException("Stub!"); }
-                    public TestSuite(java.lang.Class<?>... classes) { throw new RuntimeException("Stub!"); }
                     public TestSuite(java.lang.Class<? extends test.pkg.Constructors2.TestCase>[] classes, java.lang.String name) { throw new RuntimeException("Stub!"); }
+                    public TestSuite(java.lang.Class<?> theClass) { throw new RuntimeException("Stub!"); }
+                    public TestSuite(java.lang.Class<?>... classes) { throw new RuntimeException("Stub!"); }
+                    public TestSuite(java.lang.String name) { throw new RuntimeException("Stub!"); }
                     }
                     }
                     """
@@ -725,7 +725,7 @@ class StubsConstructorTest : AbstractStubsTest() {
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class PropertyChangeListenerProxy extends test.pkg.PickConstructors2.EventListenerProxy<test.pkg.PickConstructors2.PropertyChangeListener> implements test.pkg.PickConstructors2.PropertyChangeListener {
-                    public PropertyChangeListenerProxy(java.lang.String propertyName, test.pkg.PickConstructors2.PropertyChangeListener listener) { super(null); throw new RuntimeException("Stub!"); }
+                    public PropertyChangeListenerProxy(java.lang.String propertyName, test.pkg.PickConstructors2.PropertyChangeListener listener) { super((test.pkg.PickConstructors2.PropertyChangeListener)null); throw new RuntimeException("Stub!"); }
                     }
                     }
                     """
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt
index 335bc283b..5213cd432 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt
@@ -139,9 +139,9 @@ class StubsEnumTest : AbstractStubsTest() {
                 package test.pkg;
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public enum Alignment {
+                ALIGN_CENTER,
                 ALIGN_NORMAL,
-                ALIGN_OPPOSITE,
-                ALIGN_CENTER;
+                ALIGN_OPPOSITE;
                 }
             """
         )
@@ -193,12 +193,12 @@ class StubsEnumTest : AbstractStubsTest() {
                 package test.pkg;
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public enum ChronUnit implements test.pkg.TempUnit {
-                C,
+                A,
                 B,
-                A;
+                C;
+                public java.lang.String toString() { throw new RuntimeException("Stub!"); }
                 public java.lang.String valueOf(int x) { throw new RuntimeException("Stub!"); }
                 public java.lang.String values(java.lang.String separator) { throw new RuntimeException("Stub!"); }
-                public java.lang.String toString() { throw new RuntimeException("Stub!"); }
                 }
             """
         )
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsGenericTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsGenericTest.kt
index 142ee4f72..611bca67c 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsGenericTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsGenericTest.kt
@@ -156,8 +156,8 @@ class StubsGenericTest : AbstractStubsTest() {
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public abstract class Collections {
                 public Collections() { throw new RuntimeException("Stub!"); }
-                public static <T extends java.lang.Object & java.lang.Comparable<? super T>> T max(java.util.Collection<? extends T> collection) { throw new RuntimeException("Stub!"); }
                 public abstract <T extends java.util.Collection<java.lang.String>> T addAllTo(T t);
+                public static <T extends java.lang.Object & java.lang.Comparable<? super T>> T max(java.util.Collection<? extends T> collection) { throw new RuntimeException("Stub!"); }
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public final class Range<T extends java.lang.Comparable<? super T>> {
                 public Range() { throw new RuntimeException("Stub!"); }
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt
index 8fd50d26f..b143212b1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt
@@ -16,13 +16,9 @@
 
 package com.android.tools.metalava.stub
 
-import com.android.tools.metalava.ARG_KOTLIN_STUBS
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
-import com.android.tools.metalava.model.provider.Capability
-import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.testing.java
-import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
 @SuppressWarnings("ALL")
@@ -279,12 +275,12 @@ class StubsInterfaceTest : AbstractStubsTest() {
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public class MyClass extends test.pkg.PublicSuperParent implements test.pkg.PublicInterface, test.pkg.PublicInterface2 {
                 public MyClass() { throw new RuntimeException("Stub!"); }
+                public void inheritedMethod2() { throw new RuntimeException("Stub!"); }
                 public void myMethod() { throw new RuntimeException("Stub!"); }
+                public void publicInterfaceMethod() { throw new RuntimeException("Stub!"); }
                 public void publicInterfaceMethod2() { throw new RuntimeException("Stub!"); }
                 public void publicMethod() { throw new RuntimeException("Stub!"); }
                 public void publicMethod2() { throw new RuntimeException("Stub!"); }
-                public void publicInterfaceMethod() { throw new RuntimeException("Stub!"); }
-                public void inheritedMethod2() { throw new RuntimeException("Stub!"); }
                 public static final int MY_CONSTANT = 5; // 0x5
                 }
                 """
@@ -391,8 +387,8 @@ class StubsInterfaceTest : AbstractStubsTest() {
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public class MyClass<X, Y extends java.lang.Number> extends test.pkg.Generics.PublicParent<X,Y> implements test.pkg.Generics.PublicInterface<X,Y> {
                 public MyClass() { throw new RuntimeException("Stub!"); }
-                protected java.util.List<X> foo() { throw new RuntimeException("Stub!"); }
                 public java.util.Map<X,java.util.Map<Y,java.lang.String>> createMap(java.util.List<X> list) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+                protected java.util.List<X> foo() { throw new RuntimeException("Stub!"); }
                 }
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public static interface PublicInterface<A, B> {
@@ -458,7 +454,7 @@ class StubsInterfaceTest : AbstractStubsTest() {
                         """
                     package android.content.res;
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public interface XmlResourceParser extends org.xmlpull.v1.XmlPullParser, android.util.AttributeSet, java.lang.AutoCloseable {
+                    public interface XmlResourceParser extends android.util.AttributeSet, java.lang.AutoCloseable, org.xmlpull.v1.XmlPullParser {
                     public void close();
                     }
                     """
@@ -498,39 +494,6 @@ class StubsInterfaceTest : AbstractStubsTest() {
         )
     }
 
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Extends and implements multiple interfaces in Kotlin Stubs`() {
-        check(
-            extraArguments = arrayOf(ARG_KOTLIN_STUBS),
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        """
-                    package test.pkg
-                    class MainClass: MyParentClass(), MyInterface1, MyInterface2
-
-                    open class MyParentClass
-                    interface MyInterface1
-                    interface MyInterface2
-                """
-                    )
-                ),
-            stubFiles =
-                arrayOf(
-                    kotlin(
-                        """
-                        package test.pkg
-                        @file:Suppress("ALL")
-                        class MainClass : test.pkg.MyParentClass(), test.pkg.MyInterface1, test.pkg.MyInterface2 {
-                        open fun MainClass(): test.pkg.MainClass = error("Stub!")
-                        }
-                    """
-                    )
-                )
-        )
-    }
-
     @Test
     fun `Extends and implements multiple interfaces`() {
         check(
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
index 09ccaebf2..202a81fa9 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
@@ -16,13 +16,13 @@
 
 package com.android.tools.metalava.stub
 
-import com.android.tools.metalava.ARG_HIDE_PACKAGE
 import com.android.tools.metalava.ARG_PASS_THROUGH_ANNOTATION
 import com.android.tools.metalava.androidxNullableSource
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.restrictToSource
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.html
 import com.android.tools.metalava.testing.java
 import org.junit.Test
@@ -50,7 +50,9 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                     }
                     """
                     ),
-                    androidxNullableSource
+                    androidxNullableSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             warnings = "",
             api =
@@ -68,8 +70,6 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                 """,
             extraArguments =
                 arrayOf(
-                    ARG_HIDE_PACKAGE,
-                    "androidx.annotation",
                     // By default metalava rewrites androidx.annotation.Nullable to
                     // android.annotation.Nullable, but the latter does not have target PACKAGE thus
                     // fails to compile. This forces stubs keep the androidx annotation.
@@ -182,7 +182,9 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                         )
                         .indented(),
                     java("""package test.pkg; public abstract class Class1 { }"""),
-                    restrictToSource
+                    restrictToSource,
+                    // Hide androidx.annotation classes.
+                    KnownSourceFiles.androidxAnnotationHide,
                 ),
             api =
                 """
@@ -207,7 +209,6 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                     """
                     )
                 ),
-            extraArguments = arrayOf(ARG_HIDE_PACKAGE, "androidx.annotation")
         )
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
index b10f2d797..d40d69036 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
@@ -18,7 +18,6 @@ package com.android.tools.metalava.stub
 
 import com.android.tools.metalava.ARG_API_CLASS_RESOLUTION
 import com.android.tools.metalava.ARG_EXCLUDE_DOCUMENTATION_FROM_STUBS
-import com.android.tools.metalava.ARG_KOTLIN_STUBS
 import com.android.tools.metalava.deprecatedForSdkSource
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
@@ -622,8 +621,8 @@ class StubsTest : AbstractStubsTest() {
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public class MyClass<X, Y extends java.lang.Number> extends test.pkg.Generics.PublicParent<X,Y> implements test.pkg.Generics.PublicInterface<X,Y> {
                     public MyClass() { throw new RuntimeException("Stub!"); }
-                    protected java.util.List<X> foo() { throw new RuntimeException("Stub!"); }
                     public java.util.Map<X,java.util.Map<Y,java.lang.String>> createMap(java.util.List<X> list) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+                    protected java.util.List<X> foo() { throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static interface PublicInterface<A, B> {
@@ -928,7 +927,7 @@ class StubsTest : AbstractStubsTest() {
                     public Properties() { throw new RuntimeException("Stub!"); }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public abstract class IntProperty<T> extends test.pkg.Properties.Property<T,java.lang.Integer> {
-                    public IntProperty(java.lang.String name) { super((java.lang.Class)null, (java.lang.String)null); throw new RuntimeException("Stub!"); }
+                    public IntProperty(java.lang.String name) { super((java.lang.Class)null, ""); throw new RuntimeException("Stub!"); }
                     }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public abstract class Property<T, V> {
@@ -1137,85 +1136,6 @@ class StubsTest : AbstractStubsTest() {
         )
     }
 
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Basic Kotlin stubs`() {
-        check(
-            extraArguments = arrayOf(ARG_KOTLIN_STUBS),
-            sourceFiles =
-                arrayOf(
-                    kotlin(
-                        """
-                    /* My file header */
-                    // Another comment
-                    @file:JvmName("Driver")
-                    package test.pkg
-                    /** My class doc */
-                    class Kotlin(
-                        val property1: String = "Default Value",
-                        arg2: Int
-                    ) : Parent() {
-                        override fun method() = "Hello World"
-                        /** My method doc */
-                        fun otherMethod(ok: Boolean, times: Int) {
-                        }
-
-                        /** property doc */
-                        var property2: String? = null
-
-                        /** @hide */
-                        var hiddenProperty: String? = "hidden"
-
-                        private var someField = 42
-                        @JvmField
-                        var someField2 = 42
-                    }
-
-                    /** Parent class doc */
-                    open class Parent {
-                        open fun method(): String? = null
-                        open fun method2(value1: Boolean, value2: Boolean?): String? = null
-                        open fun method3(value1: Int?, value2: Int): Int = null
-                    }
-                    """
-                    ),
-                    kotlin(
-                        """
-                    package test.pkg
-                    open class ExtendableClass<T>
-                """
-                    )
-                ),
-            stubFiles =
-                arrayOf(
-                    kotlin(
-                        """
-                        /* My file header */
-                        // Another comment
-                        package test.pkg
-                        /** My class doc */
-                        @file:Suppress("ALL")
-                        class Kotlin : test.pkg.Parent() {
-                        open fun Kotlin(open property1: java.lang.String, open arg2: int): test.pkg.Kotlin = error("Stub!")
-                        open fun method(): java.lang.String = error("Stub!")
-                        /** My method doc */
-                        open fun otherMethod(open ok: boolean, open times: int): void = error("Stub!")
-                        }
-                    """
-                    ),
-                    kotlin(
-                        """
-                        package test.pkg
-                        @file:Suppress("ALL")
-                        open class ExtendableClass<T> {
-                        open fun ExtendableClass(): test.pkg.ExtendableClass<T> = error("Stub!")
-                        }
-                    """
-                    )
-                )
-        )
-    }
-
     @Test
     fun `NaN constants`() {
         check(
@@ -1600,7 +1520,7 @@ class StubsTest : AbstractStubsTest() {
                     package test.pkg;
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class Child extends test.pkg.Parent {
-                    protected Child(java.lang.String arg1) { super(null); throw new RuntimeException("Stub!"); }
+                    protected Child(java.lang.String arg1) { super(""); throw new RuntimeException("Stub!"); }
                     }
                     """
                     ),
@@ -1647,7 +1567,7 @@ class StubsTest : AbstractStubsTest() {
                     protected Format() { throw new RuntimeException("Stub!"); }
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public static class Field extends java.text.AttributedCharacterIterator.Attribute {
-                    protected Field(java.lang.String arg1) { super(null); throw new RuntimeException("Stub!"); }
+                    protected Field(java.lang.String arg1) { super(""); throw new RuntimeException("Stub!"); }
                     }
                     }
                     """
diff --git a/metalava/src/test/resources/source-model-provider-baseline.txt b/metalava/src/test/resources/source-model-provider-baseline.txt
index bc283d497..a6dafa86f 100644
--- a/metalava/src/test/resources/source-model-provider-baseline.txt
+++ b/metalava/src/test/resources/source-model-provider-baseline.txt
@@ -2,7 +2,6 @@ com.android.tools.metalava.AndroidApiChecksTest
   Document Permissions[turbine]
 
 com.android.tools.metalava.AnnotationsMergerTest
-  Merge @FlaggedApi inclusion annotations from Java stub files[turbine]
   Merge Contract and Language annotations from XML files[turbine]
   Merge Contract and Language annotations from signature files[turbine]
   Merge type use qualifier annotations from Java stub files[turbine]
@@ -10,12 +9,10 @@ com.android.tools.metalava.AnnotationsMergerTest
 
 com.android.tools.metalava.ApiAnalyzerTest
   Test PrivateSuperclass for inner class[turbine]
-  Test deprecated status not propagated to removed items[turbine]
   Test references deprecated errors do not apply to inner class of deprecated class[turbine]
   Test that usage of effectively deprecated class is flagged[turbine]
 
 com.android.tools.metalava.ApiFileTest
-  Annotation class extraction[turbine]
   Annotation value visibility[turbine]
   Check @remove class[turbine]
   Check basic @remove scenarios[turbine]
@@ -23,17 +20,13 @@ com.android.tools.metalava.ApiFileTest
   Check skipping implicit final or deprecated override[turbine]
   Check various generics signature subtleties[turbine]
   Kotlin expect-actual with JvmOverloads[psi,k2]
-  Remove findViewById type nullness annotation[turbine]
-  Subclass definition is not included in removed api file[turbine]
-  Test KDoc suppress[turbine]
-  Type-use annotations can be included in signature files[turbine]
 
 com.android.tools.metalava.CoreApiTest
   Hidden with --hide-annotation[turbine]
   Hidden with package javadoc and hiding default constructor explicitly[turbine]
 
-com.android.tools.metalava.DeprecatedTestCase
-  Test deprecated not written out for contents of a removed class[turbine]
+com.android.tools.metalava.DuplicateClassTest
+  Test duplicate classes[turbine]
 
 com.android.tools.metalava.ExtractAnnotationsTest
   Check java typedef extraction and warning about non-source retention of typedefs[turbine]
@@ -63,24 +56,12 @@ com.android.tools.metalava.FlaggedApiTest
   Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public without flagged api, with foo_bar]
   Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system with flagged api]
   Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system without flagged api, with foo_bar]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,module_lib with flagged api]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,module_lib without  flagged api]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,module_lib without flagged api, with foo_bar]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,public with flagged api]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,public without  flagged api]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,public without flagged api, with foo_bar]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,system with flagged api]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,system without  flagged api]
-  Test that previously released APIs which are now public and flagged are not removed[turbine,system without flagged api, with foo_bar]
   Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib with flagged api]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib without  flagged api]
   Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib without flagged api, with foo_bar]
   Test that previously released APIs which are now system and flagged are not removed[turbine,system with flagged api]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,system without  flagged api]
   Test that previously released APIs which are now system and flagged are not removed[turbine,system without flagged api, with foo_bar]
-
-com.android.tools.metalava.HideAnnotationTest
-  Using hide annotation interface order[turbine]
+  Test that pulling method up into super class can be reverted[turbine,public with flagged api]
+  Test that pulling method up into super class can be reverted[turbine,public without flagged api, with foo_bar]
 
 com.android.tools.metalava.Java9LanguageFeaturesTest
   Basic class signature extraction[turbine]
@@ -148,6 +129,9 @@ com.android.tools.metalava.SystemServiceCheckTest
   SystemService OK, loaded from source[turbine]
   Warning suppressed via annotation[turbine]
 
+com.android.tools.metalava.TypeUseAnnotationFilteringTest
+  Keep type use annotations[turbine]
+
 com.android.tools.metalava.UnhideApisTest
   Including private interfaces from types[turbine]
 
@@ -169,22 +153,14 @@ com.android.tools.metalava.compatibility.CheckAndroidApisShard3Test
   Test All Android API levels[turbine,25 to 26]
 
 com.android.tools.metalava.compatibility.CompatibilityCheckTest
-  Change item in nested SystemApi[turbine]
   Conversion from AutoCloseable to Closeable is not API-breaking[turbine]
   Conversion from MutableCollection to AbstractMutableCollection is not API-breaking[turbine]
   Empty bundle files[turbine]
   Expected API changes converting collections to Kotlin[turbine]
-  Implementing undefined interface[turbine]
   Incompatible method change -- final[turbine]
   No issues using the same classpath class twice[turbine]
   Removed method from classpath[turbine]
 
-com.android.tools.metalava.compatibility.FastPathTest
-  Check fast path not taken for removed[turbine]
-  Check fast path not taken[turbine]
-  Check fast path taken for removed[turbine]
-  Check fast path taken[turbine]
-
 com.android.tools.metalava.compatibility.ParameterNameChangeTest
   Flag renaming a parameter from the classpath[turbine]
 
@@ -196,8 +172,6 @@ com.android.tools.metalava.doc.DocAnalyzerRangeTest
   Add to existing parameter[turbine]
   Add to existing return value (ensuring it appears last)[turbine]
   Document ranges[turbine]
-  Merge API levels[turbine]
-  Trailing comment close[turbine]
   Typedefs combined with ranges[turbine]
   Typedefs[turbine]
 
@@ -207,27 +181,20 @@ com.android.tools.metalava.doc.DocAnalyzerTest
   Add to existing multi-line method documentation[turbine]
   Add to existing single-line method documentation[turbine]
   Add to method when there are existing parameter docs and appear before these[turbine]
-  Annotation annotating itself indirectly[turbine]
   Api levels around current and preview[turbine]
   Basic documentation generation test[turbine]
   Check RequiresApi handling[turbine]
-  Check construct ApiLookup works correctly[turbine]
   Create method documentation from nothing[turbine]
   Document Permissions[turbine]
-  Generate API level javadocs[turbine]
   Generate overview html docs[turbine]
   Merge Multiple sections[turbine]
-  Merge deprecation levels[turbine]
   Merging in documentation snippets from annotation memberDoc and classDoc[turbine]
-  No api levels on SystemApi only elements[turbine]
   Test Column annotation[turbine]
   Warn about missing field[turbine]
   Warn about multiple threading annotations[turbine]
   memberDoc crash[turbine]
 
 com.android.tools.metalava.lint.ApiLintTest
-  Check package layering[turbine]
-  Check suppress works on inherited methods[turbine]
   CompletableFuture and plain Future not allowed[turbine]
   Listener replaceable with OutcomeReceiver or ListenableFuture[turbine]
   Typedef must be hidden[turbine]
@@ -236,8 +203,6 @@ com.android.tools.metalava.lint.CheckBuilderTest
   Check builders[turbine]
 
 com.android.tools.metalava.lint.FlaggedApiLintTest
-  Dont require @FlaggedApi on existing items inherited into new SystemApi classes[turbine]
-  Require @FlaggedApi on APIs whose modifiers have changed[turbine]
   Require @FlaggedApi on new APIs[turbine]
   Require @FlaggedApi to reference generated fields[turbine]
 
@@ -263,7 +228,6 @@ com.android.tools.metalava.stub.StubsInterfaceTest
 
 com.android.tools.metalava.stub.StubsPackageInfoTest
   Check writing package info file[turbine]
-  Check writing package info from package html file[turbine]
   Test package-info documentation in doc stubs[turbine]
   Test package-info documentation in stubs[turbine]
 
@@ -279,4 +243,3 @@ com.android.tools.metalava.stub.StubsTest
   Picking super class throwables[turbine]
   Skip type variables in casts[turbine]
   Translate DeprecatedForSdk to Deprecated[turbine]
-  Type-use annotations are not included in stubs[turbine]
diff --git a/scripts/gather-android-metalava-artifacts.py b/scripts/gather-android-metalava-artifacts.py
new file mode 100755
index 000000000..188c13a6f
--- /dev/null
+++ b/scripts/gather-android-metalava-artifacts.py
@@ -0,0 +1,215 @@
+#!/usr/bin/env -S python3 -u
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+import argparse
+import os
+from pathlib import Path
+import shutil
+import subprocess
+import sys
+
+# Formatted using: pyformat -s 4 --force_quote_type double -i scripts/gather-android-metalava-artifacts.py
+
+
+def parse_command_line_args(args):
+    """Define the command line options and the parse the command line arguments with them.
+
+    :param args: the command line arguments :return: Return the result of
+    parsing the command line arguments.
+    """
+    args_parser = argparse.ArgumentParser(
+        description=(
+            "Gather Android artifacts created by Metalava. This will build and"
+            " then copy a set of targets to the output directory. If no custom"
+            " targets are provided then a set of default ones will be provided"
+            " that covers stub generation, signature to JDiff conversion and"
+            " api-versions.xml file generation. The intent is that this would"
+            " be run this before and after making the change to build and copy"
+            " the artifacts into two separate directories that can then be"
+            " compared to see what, if any, changes have happened. This does"
+            " not check signature file generation as that can be easily checked"
+            " by running `m checkapi`."
+        ),
+    )
+    args_parser.add_argument(
+        "directory",
+        help="Output directory into which artifacts will be copied.",
+    )
+    args_parser.add_argument(
+        "--stub-src-jar",
+        action="append",
+        help="Additional stub jar to gather",
+    )
+
+    return args_parser.parse_args(args)
+
+
+def default_stub_files():
+    """:return: A representative sample list of stub source jars generated by the Android build using Metalava"""
+    return [
+        f"out/target/common/docs/{x}-stubs.srcjar"
+        for x in [
+            "api-stubs-docs-non-updatable",
+            "system-api-stubs-docs-non-updatable",
+            "test-api-stubs-docs-non-updatable",
+            "module-lib-api-stubs-docs-non-updatable",
+        ]
+    ]
+
+
+def default_doc_stub_files():
+    """:return: A representative sample list of doc stub source jars generated by the Android build using Metalava"""
+    return [
+        "out/target/common/docs/framework-doc-stubs-stubs.srcjar",
+        "out/target/common/docs/framework-doc-system-stubs-stubs.srcjar",
+    ]
+
+
+def default_api_version_files():
+    """:return: A representative sample list of `api-versions.xml` files generated by the Android build using
+
+    Metalava.
+    """
+    return [
+        "out/soong/lint/api_versions_public.xml",
+        "out/soong/lint/api_versions_system.xml",
+        "out/soong/lint/api_versions_module_lib.xml",
+        "out/soong/lint/api_versions_system_server.xml",
+    ]
+
+
+def default_jdiff_files():
+    """:return: A representative sample list of JDiff files created by the Android build using Metalava."""
+    return [
+        # JDiff files generated from jar files.
+        "out/target/common/obj/api.xml",
+        "out/target/common/obj/system-api.xml",
+        "out/target/common/obj/module-lib-api.xml",
+        "out/target/common/obj/system-server-api.xml",
+        "out/target/common/obj/test-api.xml",
+        # JDiff files generated from txt files.
+        "out/soong/.intermediates/packages/services/Car/car-lib/android.car-test-stubs-jdiff/gen/car-test-api.xml",
+        "out/soong/.intermediates/packages/services/Car/car-lib/android.car-stubs-jdiff/gen/car-api.xml",
+        "out/soong/.intermediates/packages/services/Car/car-lib/android.car-system-stubs-jdiff/gen/car-system-api.xml",
+        ""# JDiff files generated from txt files and then compressed using gzip..
+        "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-base-current-api-gz/gen/android-test-base-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-mock-current-api-gz/gen/android-test-mock-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-runner-current-api-gz/gen/android-test-runner-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-apache-http-legacy-current-api-gz/gen/apache-http-legacy-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-car-system-current-api-gz/gen/car-system-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-current-api-gz/gen/current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-system-current-api-gz/gen/system-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-system-removed-api-gz/gen/system-removed.api.gz",
+
+    ]
+
+
+def default_dex_writer_files():
+    """:return: A representative sample list of dex writer related files created by the Android build using Metalava."""
+    return [
+        # This is not actually a dex writer file but it contains information derived from lots of dex writer files so
+        # any differences in the dex writer files will affect this file.
+        "out/soong/hiddenapi/hiddenapi-flags.csv",
+    ]
+
+
+def default_custom_files(top):
+    """Returns a representative sample list of custom files created by the Android build using a custom tool based, at
+
+    least in part, on Metalava.
+    :return: A list of custom files.
+    """
+    product_out = Path(os.environ.get("ANDROID_PRODUCT_OUT")).relative_to(top)
+    return [
+        f"{product_out}/obj/ETC/flag-api-mapping-{surface}_intermediates/flag-api-mapping-{surface}"
+        for surface in [
+            "PublicApi",
+            "SystemApi",
+            "ModuleLibApi",
+            "SystemServerApi",
+        ]
+    ]
+
+
+def construct_target_list(args, top):
+    """Generate a list of targets from the supplied arguments
+
+    :param args: the command line arguments.
+    :return: a non-empty list of targets to build.
+    """
+    targets = []
+    # If any custom options have been provided then build them.
+    if args.stub_src_jar:
+        targets += args.stub_src_jar
+    # If no custom targets have been provided then use the default targets.
+    if not targets:
+        targets += default_stub_files()
+        targets += default_doc_stub_files()
+        targets += default_jdiff_files()
+        targets += default_api_version_files()
+        targets += default_dex_writer_files()
+        targets += default_custom_files(top)
+    return targets
+
+
+def main(args):
+    top = os.environ.get("ANDROID_BUILD_TOP")
+    if not top:
+        raise Exception("ANDROID_BUILD_TOP not specified")
+    os.chdir(top)
+
+    # Parse command line arguments.
+    args = parse_command_line_args(args)
+
+    # Make sure that the output directory does not already exist.
+    output_dir = Path(args.directory)
+    if output_dir.exists():
+        raise Exception(f"{output_dir} exists, please delete or change")
+
+    # Construct the list of targets to build, using defaults where required.
+    targets = construct_target_list(args, top)
+
+    # Build the targets.
+    build_targets(targets)
+
+    # Create the output directory and copy the targets into it.
+    copy_targets(output_dir, targets)
+
+
+def copy_targets(output_dir, targets):
+    print(f"Making output directory: '{output_dir}'")
+    os.mkdir(output_dir)
+    print()
+    print(f"Copying the following targets into '{output_dir}':")
+    for t in targets:
+        print(f"    {t}")
+        shutil.copy(t, output_dir)
+    print()
+
+
+def build_targets(targets):
+    print()
+    print("Building the following targets:")
+    for t in targets:
+        print(f"    {t}")
+    print()
+    subprocess.run(
+        ["build/soong/soong_ui.bash", "--make-mode"] + targets, check=True
+    )
+    print()
+
+
+if __name__ == "__main__":
+    main(sys.argv[1:])
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 15c5e8bac..f95a6a016 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -61,6 +61,7 @@ if (!System.getenv("INTEGRATION").isNullOrBlank()) {
 include(":metalava")
 include(":metalava-model")
 include(":metalava-model-psi")
+include(":metalava-model-snapshot-testing")
 include(":metalava-model-source")
 include(":metalava-model-testsuite")
 include(":metalava-model-testsuite-cli")
diff --git a/version.properties b/version.properties
index 38c08bf9e..69621fcf4 100644
--- a/version.properties
+++ b/version.properties
@@ -2,4 +2,4 @@
 # Version definition
 # This file is read by gradle build scripts, but also packaged with metalava
 # as a resource for the Version classes to read.
-metalavaVersion=1.0.0-alpha10
+metalavaVersion=1.0.0-alpha12
```

