```diff
diff --git a/generic_access_policy/lib.rs b/generic_access_policy/lib.rs
index 1e0f9e7..a600433 100644
--- a/generic_access_policy/lib.rs
+++ b/generic_access_policy/lib.rs
@@ -18,7 +18,7 @@
 
 use tipc::Uuid;
 
-const ACCESSIBLE_UUIDS: [Uuid; 4] = [
+pub const KEYMINT_ACCESSIBLE_UUIDS: [Uuid; 4] = [
     /* gatekeeper uuid */
     Uuid::new(0x38ba0cdc, 0xdf0e, 0x11e4, [0x98, 0x69, 0x23, 0x3f, 0xb6, 0xae, 0x47, 0x95]),
     /* confirmation UI uuid */
@@ -29,13 +29,6 @@ const ACCESSIBLE_UUIDS: [Uuid; 4] = [
     Uuid::new(0xd322eec9, 0x6d03, 0x49fa, [0x82, 0x1c, 0x1c, 0xcd, 0x27, 0x05, 0x71, 0x9c]),
 ];
 
-pub fn keymint_check_target_access_policy(uuid: &Uuid) -> bool {
-    if ACCESSIBLE_UUIDS.contains(uuid) {
-        return true;
-    }
-    return false;
-}
-
 pub fn keymint_check_secure_target_access_policy_provisioning(_uuid: &Uuid) -> bool {
     /* Not Supported */
     return false;
diff --git a/ipc_manager.rs b/ipc_manager.rs
index 702c0c1..3df9694 100644
--- a/ipc_manager.rs
+++ b/ipc_manager.rs
@@ -18,14 +18,15 @@ use crate::secure_storage_manager;
 use alloc::{rc::Rc, vec::Vec};
 use core::{cell::RefCell, mem};
 use keymint_access_policy::{
-    keymint_check_secure_target_access_policy_provisioning, keymint_check_target_access_policy,
+    keymint_check_secure_target_access_policy_provisioning, KEYMINT_ACCESSIBLE_UUIDS,
 };
 use kmr_common::{
     crypto, km_err,
     wire::legacy::{
-        self, AppendAttestationCertChainResponse, ClearAttestationCertChainResponse,
+        self, AppendAttestationCertChainResponse, AppendUdsCertificateResponse,
+        ClearAttestationCertChainResponse, ClearUdsCertificateResponse,
         ConfigureBootPatchlevelResponse, GetAuthTokenKeyResponse, GetDeviceInfoResponse,
-        GetVersion2Response, GetVersionResponse, SetAttestationIdsKM3Response,
+        GetUdsCertsResponse, GetVersion2Response, GetVersionResponse, SetAttestationIdsKM3Response,
         SetAttestationIdsResponse, SetAttestationKeyResponse, SetBootParamsResponse,
         SetWrappedAttestationKeyResponse, TrustyMessageId, TrustyPerformOpReq, TrustyPerformOpRsp,
         TrustyPerformSecureOpReq, TrustyPerformSecureOpRsp,
@@ -384,6 +385,14 @@ impl KMLegacyService {
                 )?;
                 Ok(TrustyPerformOpRsp::SetAttestationIdsKM3(SetAttestationIdsKM3Response {}))
             }
+            TrustyPerformOpReq::AppendUdsCertificate(req) => {
+                secure_storage_manager::append_uds_cert_chain(&req.cert_data)?;
+                Ok(TrustyPerformOpRsp::AppendUdsCertificate(AppendUdsCertificateResponse {}))
+            }
+            TrustyPerformOpReq::ClearUdsCertificate(..) => {
+                secure_storage_manager::maybe_delete_uds_cert_chain()?;
+                Ok(TrustyPerformOpRsp::ClearUdsCertificate(ClearUdsCertificateResponse {}))
+            }
         }
     }
 }
@@ -468,6 +477,11 @@ impl KMSecureService {
                     device_ids: self.km_ta.borrow().rpc_device_info()?,
                 }))
             }
+            TrustyPerformSecureOpReq::GetUdsCerts(_) => {
+                Ok(TrustyPerformSecureOpRsp::GetUdsCerts(GetUdsCertsResponse {
+                    uds_certs: self.km_ta.borrow().uds_certs()?,
+                }))
+            }
             TrustyPerformSecureOpReq::SetAttestationIds(req) => {
                 secure_storage_manager::provision_attestation_id_file(
                     &req.brand,
@@ -496,10 +510,6 @@ impl Service for KMSecureService {
         _handle: &Handle,
         peer: &Uuid,
     ) -> tipc::Result<ConnectResult<Self::Connection>> {
-        if !keymint_check_target_access_policy(peer) {
-            error!("access policy rejected the uuid: {:?}", peer);
-            return Ok(ConnectResult::CloseConnection);
-        }
         debug!("Accepted connection from uuid {:?}.", peer);
         Ok(ConnectResult::Accept(Context { uuid: peer.clone() }))
     }
@@ -594,7 +604,8 @@ pub fn handle_port_connections(
                 e
             )
         })?
-        .allow_ta_connect();
+        .allow_ta_connect()
+        .allowed_uuids(&KEYMINT_ACCESSIBLE_UUIDS);
     dispatcher.add_service(Rc::new(sec_service), cfg).map_err(|e| {
         km_err!(UnknownError, "could not add secure service to dispatcher: {:?}", e)
     })?;
diff --git a/keymaster_attributes.rs b/keymaster_attributes.rs
index e23fa28..c71c8a2 100644
--- a/keymaster_attributes.rs
+++ b/keymaster_attributes.rs
@@ -1,5 +1,7 @@
 // This file is generated by rust-protobuf 2.27.1. Do not edit
 // @generated
+// Generate steps:
+// 1. protoc --rust_out . ../keymaster/keymaster_attributes.proto
 
 // https://github.com/rust-lang/rust-clippy/issues/702
 #![allow(unknown_lints)]
@@ -1219,6 +1221,172 @@ impl ::protobuf::reflect::ProtobufValue for AttestationCert {
     }
 }
 
+#[derive(PartialEq,Clone,Default)]
+pub struct UdsCerts {
+    // message fields
+    pub certs: ::protobuf::RepeatedField<AttestationCert>,
+    // special fields
+    pub unknown_fields: ::protobuf::UnknownFields,
+    pub cached_size: ::protobuf::CachedSize,
+}
+
+impl<'a> ::std::default::Default for &'a UdsCerts {
+    fn default() -> &'a UdsCerts {
+        <UdsCerts as ::protobuf::Message>::default_instance()
+    }
+}
+
+impl UdsCerts {
+    pub fn new() -> UdsCerts {
+        ::std::default::Default::default()
+    }
+
+    // repeated .AttestationCert certs = 1;
+
+
+    pub fn get_certs(&self) -> &[AttestationCert] {
+        &self.certs
+    }
+    pub fn clear_certs(&mut self) {
+        self.certs.clear();
+    }
+
+    // Param is passed by value, moved
+    pub fn set_certs(&mut self, v: ::protobuf::RepeatedField<AttestationCert>) {
+        self.certs = v;
+    }
+
+    // Mutable pointer to the field.
+    pub fn mut_certs(&mut self) -> &mut ::protobuf::RepeatedField<AttestationCert> {
+        &mut self.certs
+    }
+
+    // Take field
+    pub fn take_certs(&mut self) -> ::protobuf::RepeatedField<AttestationCert> {
+        ::std::mem::replace(&mut self.certs, ::protobuf::RepeatedField::new())
+    }
+}
+
+impl ::protobuf::Message for UdsCerts {
+    fn is_initialized(&self) -> bool {
+        for v in &self.certs {
+            if !v.is_initialized() {
+                return false;
+            }
+        };
+        true
+    }
+
+    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
+        while !is.eof()? {
+            let (field_number, wire_type) = is.read_tag_unpack()?;
+            match field_number {
+                1 => {
+                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.certs)?;
+                },
+                _ => {
+                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
+                },
+            };
+        }
+        ::std::result::Result::Ok(())
+    }
+
+    // Compute sizes of nested messages
+    #[allow(unused_variables)]
+    fn compute_size(&self) -> u32 {
+        let mut my_size = 0;
+        for value in &self.certs {
+            let len = value.compute_size();
+            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
+        };
+        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
+        self.cached_size.set(my_size);
+        my_size
+    }
+
+    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
+        for v in &self.certs {
+            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
+            os.write_raw_varint32(v.get_cached_size())?;
+            v.write_to_with_cached_sizes(os)?;
+        };
+        os.write_unknown_fields(self.get_unknown_fields())?;
+        ::std::result::Result::Ok(())
+    }
+
+    fn get_cached_size(&self) -> u32 {
+        self.cached_size.get()
+    }
+
+    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
+        &self.unknown_fields
+    }
+
+    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
+        &mut self.unknown_fields
+    }
+
+    fn as_any(&self) -> &dyn (::std::any::Any) {
+        self as &dyn (::std::any::Any)
+    }
+    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
+        self as &mut dyn (::std::any::Any)
+    }
+    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
+        self
+    }
+
+    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
+        Self::descriptor_static()
+    }
+
+    fn new() -> UdsCerts {
+        UdsCerts::new()
+    }
+
+    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
+        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
+        descriptor.get(|| {
+            let mut fields = ::std::vec::Vec::new();
+            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttestationCert>>(
+                "certs",
+                |m: &UdsCerts| { &m.certs },
+                |m: &mut UdsCerts| { &mut m.certs },
+            ));
+            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UdsCerts>(
+                "UdsCerts",
+                fields,
+                file_descriptor_proto()
+            )
+        })
+    }
+
+    fn default_instance() -> &'static UdsCerts {
+        static instance: ::protobuf::rt::LazyV2<UdsCerts> = ::protobuf::rt::LazyV2::INIT;
+        instance.get(UdsCerts::new)
+    }
+}
+
+impl ::protobuf::Clear for UdsCerts {
+    fn clear(&mut self) {
+        self.certs.clear();
+        self.unknown_fields.clear();
+    }
+}
+
+impl ::std::fmt::Debug for UdsCerts {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
+        ::protobuf::text_format::fmt(self, f)
+    }
+}
+
+impl ::protobuf::reflect::ProtobufValue for UdsCerts {
+    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
+        ::protobuf::reflect::ReflectValueRef::Message(self)
+    }
+}
+
 static file_descriptor_proto_data: &'static [u8] = b"\
     \n\x1akeymaster_attributes.proto\x1a\x0cnanopb.proto\"V\n\x13KeymasterAt\
     tributes\x12\x19\n\x04uuid\x18\x01\x20\x01(\x0cR\x04uuidB\x05\x92?\x02\
@@ -1236,110 +1404,118 @@ static file_descriptor_proto_data: &'static [u8] = b"\
     \x18\n\x03key\x18\x01\x20\x01(\x0cR\x03keyB\x06\x92?\x03\x08\x80\x10\x12\
     -\n\x05certs\x18\x02\x20\x03(\x0b2\x10.AttestationCertR\x05certsB\x05\
     \x92?\x02\x10\x03\"3\n\x0fAttestationCert\x12\x20\n\x07content\x18\x01\
-    \x20\x02(\x0cR\x07contentB\x06\x92?\x03\x08\x80\x10J\x94\x18\n\x06\x12\
-    \x04%\0A\x02\n\xa6\x0c\n\x01\x0c\x12\x03%\0\x122\xcc\x04\n\x20Copyright\
-    \x20(C)\x202018\x20The\x20Android\x20Open\x20Source\x20Project\n\n\x20Li\
-    censed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
-    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
-    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
-    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20\
-    \x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\
-    \x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20s\
-    oftware\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\
-    \x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\
-    \x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20impli\
-    ed.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20\
-    governing\x20permissions\x20and\n\x20limitations\x20under\x20the\x20Lice\
-    nse.\n2\xcc\x07\x20We\x20check\x20in\x20the\x20prebuilt\x20nanopb\x20pro\
-    tobuf\x20file\x20under\x20the\x20current\x20folder\n\x20because\x20the\
-    \x20compile\x20tool\x20chain\x20using\x20trusty/user/base/make/compile_p\
-    roto.mk\n\x20might\x20not\x20work\x20under\x20certain\x20environment\x20\
-    with\x20lower\x20version\x20of\x20python\n\x20protobuf\x20installed.\x20\
-    You\x20need\x20to\x20generate\x20and\x20check\x20in\x20the\x20new\x20pro\
-    tobuf\x20file\n\x20if\x20you\x20change\x20this\x20file\x20in\x20order\
-    \x20for\x20the\x20change\x20to\x20take\x20effect!\n\n\x20To\x20generate\
-    \x20the\x20file\x20using\x20the\x20tool\x20chain\x20in\x20trusty\x20tree\
-    ,\x20add\x20the\x20following\n\x20command\x20to\x20rules.mk:\n\n\x20PB_G\
-    EN_DIR\x20:=\x20[Your\x20generation\x20folder]\n\x20include\x20trusty/us\
-    er/base/make/compile_proto.mk\n\x20$(eval\x20$(call\x20compile_proto,$(K\
-    EYMASTER_DIR)/keymaster_attributes.proto,$(PB_GEN_DIR)))\n\n\x20The\x20g\
-    enerated\x20.pb.c\x20and\x20.pb.h\x20file\x20would\x20be\x20under\x20PB_\
-    GEN_DIR,\x20include\x20them\n\x20to\x20the\x20source\x20path.\n\n\x20To\
-    \x20generate\x20the\x20file\x20using\x20your\x20own\x20tool\x20chain,\
-    \x20please\x20follow\x20the\x20guide\x20at\n\x20https://github.com/nanop\
-    b/nanopb.\n\x20Please\x20check\x20the\x20nanopb\x20version\x20in\x20trus\
-    ty\x20tree\x20at\x20external/nanopb-c\x20to\x20make\n\x20sure\x20you\x20\
-    are\x20using\x20the\x20same\x20nanopb\x20version.\n\n\t\n\x02\x03\0\x12\
-    \x03'\0\x16\n\n\n\x02\x04\0\x12\x04)\0,\x01\n\n\n\x03\x04\0\x01\x12\x03)\
-    \x08\x1b\n\x0b\n\x04\x04\0\x02\0\x12\x03*\x021\n\x0c\n\x05\x04\0\x02\0\
-    \x04\x12\x03*\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03*\x0b\x10\n\x0c\n\
-    \x05\x04\0\x02\0\x01\x12\x03*\x11\x15\n\x0c\n\x05\x04\0\x02\0\x03\x12\
-    \x03*\x18\x19\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03*\x1a0\n\x0f\n\x08\x04\
-    \0\x02\0\x08\xf2\x07\x01\x12\x03*\x1b/\n\x0b\n\x04\x04\0\x02\x01\x12\x03\
-    +\x027\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\0\
-    \x02\x01\x05\x12\x03+\x0b\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03+\x11\
-    \x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03+\x1e\x1f\n\x0c\n\x05\x04\0\
-    \x02\x01\x08\x12\x03+\x206\n\x0f\n\x08\x04\0\x02\x01\x08\xf2\x07\x01\x12\
-    \x03+!5\n\n\n\x02\x04\x01\x12\x04.\08\x01\n\n\n\x03\x04\x01\x01\x12\x03.\
-    \x08\x16\n\x0b\n\x04\x04\x01\x02\0\x12\x03/\x044\n\x0c\n\x05\x04\x01\x02\
-    \0\x04\x12\x03/\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03/\r\x12\n\
-    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03/\x13\x18\n\x0c\n\x05\x04\x01\x02\0\
-    \x03\x12\x03/\x1b\x1c\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03/\x1d3\n\x0f\
-    \n\x08\x04\x01\x02\0\x08\xf2\x07\x01\x12\x03/\x1e2\n\x0b\n\x04\x04\x01\
-    \x02\x01\x12\x030\x045\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x030\x04\x0c\
-    \n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x030\r\x12\n\x0c\n\x05\x04\x01\x02\
-    \x01\x01\x12\x030\x13\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x030\x1c\
-    \x1d\n\x0c\n\x05\x04\x01\x02\x01\x08\x12\x030\x1e4\n\x0f\n\x08\x04\x01\
-    \x02\x01\x08\xf2\x07\x01\x12\x030\x1f3\n\x0b\n\x04\x04\x01\x02\x02\x12\
-    \x031\x046\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x031\x04\x0c\n\x0c\n\x05\
-    \x04\x01\x02\x02\x05\x12\x031\r\x12\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\
-    \x031\x13\x1a\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x031\x1d\x1e\n\x0c\n\
-    \x05\x04\x01\x02\x02\x08\x12\x031\x1f5\n\x0f\n\x08\x04\x01\x02\x02\x08\
-    \xf2\x07\x01\x12\x031\x204\n\x0b\n\x04\x04\x01\x02\x03\x12\x032\x045\n\
-    \x0c\n\x05\x04\x01\x02\x03\x04\x12\x032\x04\x0c\n\x0c\n\x05\x04\x01\x02\
-    \x03\x05\x12\x032\r\x12\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x032\x13\x19\
-    \n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x032\x1c\x1d\n\x0c\n\x05\x04\x01\
-    \x02\x03\x08\x12\x032\x1e4\n\x0f\n\x08\x04\x01\x02\x03\x08\xf2\x07\x01\
-    \x12\x032\x1f3\n\x0b\n\x04\x04\x01\x02\x04\x12\x033\x043\n\x0c\n\x05\x04\
-    \x01\x02\x04\x04\x12\x033\x04\x0c\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\
-    \x033\r\x12\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x033\x13\x17\n\x0c\n\x05\
-    \x04\x01\x02\x04\x03\x12\x033\x1a\x1b\n\x0c\n\x05\x04\x01\x02\x04\x08\
-    \x12\x033\x1c2\n\x0f\n\x08\x04\x01\x02\x04\x08\xf2\x07\x01\x12\x033\x1d1\
-    \n\x0b\n\x04\x04\x01\x02\x05\x12\x034\x043\n\x0c\n\x05\x04\x01\x02\x05\
-    \x04\x12\x034\x04\x0c\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x034\r\x12\n\
-    \x0c\n\x05\x04\x01\x02\x05\x01\x12\x034\x13\x17\n\x0c\n\x05\x04\x01\x02\
-    \x05\x03\x12\x034\x1a\x1b\n\x0c\n\x05\x04\x01\x02\x05\x08\x12\x034\x1c2\
-    \n\x0f\n\x08\x04\x01\x02\x05\x08\xf2\x07\x01\x12\x034\x1d1\n\x0b\n\x04\
-    \x04\x01\x02\x06\x12\x035\x04;\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x035\
-    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x035\r\x12\n\x0c\n\x05\x04\
-    \x01\x02\x06\x01\x12\x035\x13\x1f\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\
-    \x035\"#\n\x0c\n\x05\x04\x01\x02\x06\x08\x12\x035$:\n\x0f\n\x08\x04\x01\
-    \x02\x06\x08\xf2\x07\x01\x12\x035%9\n\x0b\n\x04\x04\x01\x02\x07\x12\x036\
-    \x044\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x036\x04\x0c\n\x0c\n\x05\x04\
-    \x01\x02\x07\x05\x12\x036\r\x12\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x036\
-    \x13\x18\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x036\x1b\x1c\n\x0c\n\x05\
-    \x04\x01\x02\x07\x08\x12\x036\x1d3\n\x0f\n\x08\x04\x01\x02\x07\x08\xf2\
-    \x07\x01\x12\x036\x1e2\n\x0b\n\x04\x04\x01\x02\x08\x12\x037\x04:\n\x0c\n\
-    \x05\x04\x01\x02\x08\x04\x12\x037\x04\x0c\n\x0c\n\x05\x04\x01\x02\x08\
-    \x05\x12\x037\r\x12\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x037\x13\x1e\n\
-    \x0c\n\x05\x04\x01\x02\x08\x03\x12\x037!\"\n\x0c\n\x05\x04\x01\x02\x08\
-    \x08\x12\x037#9\n\x0f\n\x08\x04\x01\x02\x08\x08\xf2\x07\x01\x12\x037$8\n\
-    \n\n\x02\x04\x02\x12\x04:\0=\x01\n\n\n\x03\x04\x02\x01\x12\x03:\x08\x16\
-    \n\x0b\n\x04\x04\x02\x02\0\x12\x03;\x022\n\x0c\n\x05\x04\x02\x02\0\x04\
-    \x12\x03;\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03;\x0b\x10\n\x0c\n\
-    \x05\x04\x02\x02\0\x01\x12\x03;\x11\x14\n\x0c\n\x05\x04\x02\x02\0\x03\
-    \x12\x03;\x17\x18\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03;\x191\n\x0f\n\
-    \x08\x04\x02\x02\0\x08\xf2\x07\x01\x12\x03;\x1a0\n\x0b\n\x04\x04\x02\x02\
-    \x01\x12\x03<\x02<\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03<\x02\n\n\x0c\
-    \n\x05\x04\x02\x02\x01\x06\x12\x03<\x0b\x1a\n\x0c\n\x05\x04\x02\x02\x01\
-    \x01\x12\x03<\x1b\x20\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03<#$\n\x0c\n\
-    \x05\x04\x02\x02\x01\x08\x12\x03<%;\n\x0f\n\x08\x04\x02\x02\x01\x08\xf2\
-    \x07\x02\x12\x03<&:\n\n\n\x02\x04\x03\x12\x04?\0A\x01\n\n\n\x03\x04\x03\
-    \x01\x12\x03?\x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\x03@\x026\n\x0c\n\
-    \x05\x04\x03\x02\0\x04\x12\x03@\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\
-    \x03@\x0b\x10\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03@\x11\x18\n\x0c\n\x05\
-    \x04\x03\x02\0\x03\x12\x03@\x1b\x1c\n\x0c\n\x05\x04\x03\x02\0\x08\x12\
-    \x03@\x1d5\n\x0f\n\x08\x04\x03\x02\0\x08\xf2\x07\x01\x12\x03@\x1e4\
+    \x20\x02(\x0cR\x07contentB\x06\x92?\x03\x08\x80\x10\"9\n\x08UdsCerts\x12\
+    -\n\x05certs\x18\x01\x20\x03(\x0b2\x10.AttestationCertR\x05certsB\x05\
+    \x92?\x02\x10\x03J\x90\x19\n\x06\x12\x04%\0E\x02\n\xa6\x0c\n\x01\x0c\x12\
+    \x03%\0\x122\xcc\x04\n\x20Copyright\x20(C)\x202018\x20The\x20Android\x20\
+    Open\x20Source\x20Project\n\n\x20Licensed\x20under\x20the\x20Apache\x20L\
+    icense,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20no\
+    t\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\
+    \x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20Lice\
+    nse\x20at\n\n\x20\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICE\
+    NSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20ag\
+    reed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20th\
+    e\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\
+    \n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\
+    \x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20fo\
+    r\x20the\x20specific\x20language\x20governing\x20permissions\x20and\n\
+    \x20limitations\x20under\x20the\x20License.\n2\xcc\x07\x20We\x20check\
+    \x20in\x20the\x20prebuilt\x20nanopb\x20protobuf\x20file\x20under\x20the\
+    \x20current\x20folder\n\x20because\x20the\x20compile\x20tool\x20chain\
+    \x20using\x20trusty/user/base/make/compile_proto.mk\n\x20might\x20not\
+    \x20work\x20under\x20certain\x20environment\x20with\x20lower\x20version\
+    \x20of\x20python\n\x20protobuf\x20installed.\x20You\x20need\x20to\x20gen\
+    erate\x20and\x20check\x20in\x20the\x20new\x20protobuf\x20file\n\x20if\
+    \x20you\x20change\x20this\x20file\x20in\x20order\x20for\x20the\x20change\
+    \x20to\x20take\x20effect!\n\n\x20To\x20generate\x20the\x20file\x20using\
+    \x20the\x20tool\x20chain\x20in\x20trusty\x20tree,\x20add\x20the\x20follo\
+    wing\n\x20command\x20to\x20rules.mk:\n\n\x20PB_GEN_DIR\x20:=\x20[Your\
+    \x20generation\x20folder]\n\x20include\x20trusty/user/base/make/compile_\
+    proto.mk\n\x20$(eval\x20$(call\x20compile_proto,$(KEYMASTER_DIR)/keymast\
+    er_attributes.proto,$(PB_GEN_DIR)))\n\n\x20The\x20generated\x20.pb.c\x20\
+    and\x20.pb.h\x20file\x20would\x20be\x20under\x20PB_GEN_DIR,\x20include\
+    \x20them\n\x20to\x20the\x20source\x20path.\n\n\x20To\x20generate\x20the\
+    \x20file\x20using\x20your\x20own\x20tool\x20chain,\x20please\x20follow\
+    \x20the\x20guide\x20at\n\x20https://github.com/nanopb/nanopb.\n\x20Pleas\
+    e\x20check\x20the\x20nanopb\x20version\x20in\x20trusty\x20tree\x20at\x20\
+    external/nanopb-c\x20to\x20make\n\x20sure\x20you\x20are\x20using\x20the\
+    \x20same\x20nanopb\x20version.\n\n\t\n\x02\x03\0\x12\x03'\0\x16\n\n\n\
+    \x02\x04\0\x12\x04)\0,\x01\n\n\n\x03\x04\0\x01\x12\x03)\x08\x1b\n\x0b\n\
+    \x04\x04\0\x02\0\x12\x03*\x021\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03*\x02\
+    \n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03*\x0b\x10\n\x0c\n\x05\x04\0\x02\0\
+    \x01\x12\x03*\x11\x15\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03*\x18\x19\n\x0c\
+    \n\x05\x04\0\x02\0\x08\x12\x03*\x1a0\n\x0f\n\x08\x04\0\x02\0\x08\xf2\x07\
+    \x01\x12\x03*\x1b/\n\x0b\n\x04\x04\0\x02\x01\x12\x03+\x027\n\x0c\n\x05\
+    \x04\0\x02\x01\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03+\
+    \x0b\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03+\x11\x1b\n\x0c\n\x05\x04\
+    \0\x02\x01\x03\x12\x03+\x1e\x1f\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03+\
+    \x206\n\x0f\n\x08\x04\0\x02\x01\x08\xf2\x07\x01\x12\x03+!5\n\n\n\x02\x04\
+    \x01\x12\x04.\08\x01\n\n\n\x03\x04\x01\x01\x12\x03.\x08\x16\n\x0b\n\x04\
+    \x04\x01\x02\0\x12\x03/\x044\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03/\x04\
+    \x0c\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03/\r\x12\n\x0c\n\x05\x04\x01\
+    \x02\0\x01\x12\x03/\x13\x18\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03/\x1b\
+    \x1c\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03/\x1d3\n\x0f\n\x08\x04\x01\x02\
+    \0\x08\xf2\x07\x01\x12\x03/\x1e2\n\x0b\n\x04\x04\x01\x02\x01\x12\x030\
+    \x045\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x030\x04\x0c\n\x0c\n\x05\x04\
+    \x01\x02\x01\x05\x12\x030\r\x12\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x030\
+    \x13\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x030\x1c\x1d\n\x0c\n\x05\
+    \x04\x01\x02\x01\x08\x12\x030\x1e4\n\x0f\n\x08\x04\x01\x02\x01\x08\xf2\
+    \x07\x01\x12\x030\x1f3\n\x0b\n\x04\x04\x01\x02\x02\x12\x031\x046\n\x0c\n\
+    \x05\x04\x01\x02\x02\x04\x12\x031\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\
+    \x05\x12\x031\r\x12\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x031\x13\x1a\n\
+    \x0c\n\x05\x04\x01\x02\x02\x03\x12\x031\x1d\x1e\n\x0c\n\x05\x04\x01\x02\
+    \x02\x08\x12\x031\x1f5\n\x0f\n\x08\x04\x01\x02\x02\x08\xf2\x07\x01\x12\
+    \x031\x204\n\x0b\n\x04\x04\x01\x02\x03\x12\x032\x045\n\x0c\n\x05\x04\x01\
+    \x02\x03\x04\x12\x032\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x032\r\
+    \x12\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x032\x13\x19\n\x0c\n\x05\x04\
+    \x01\x02\x03\x03\x12\x032\x1c\x1d\n\x0c\n\x05\x04\x01\x02\x03\x08\x12\
+    \x032\x1e4\n\x0f\n\x08\x04\x01\x02\x03\x08\xf2\x07\x01\x12\x032\x1f3\n\
+    \x0b\n\x04\x04\x01\x02\x04\x12\x033\x043\n\x0c\n\x05\x04\x01\x02\x04\x04\
+    \x12\x033\x04\x0c\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x033\r\x12\n\x0c\n\
+    \x05\x04\x01\x02\x04\x01\x12\x033\x13\x17\n\x0c\n\x05\x04\x01\x02\x04\
+    \x03\x12\x033\x1a\x1b\n\x0c\n\x05\x04\x01\x02\x04\x08\x12\x033\x1c2\n\
+    \x0f\n\x08\x04\x01\x02\x04\x08\xf2\x07\x01\x12\x033\x1d1\n\x0b\n\x04\x04\
+    \x01\x02\x05\x12\x034\x043\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x034\x04\
+    \x0c\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x034\r\x12\n\x0c\n\x05\x04\x01\
+    \x02\x05\x01\x12\x034\x13\x17\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x034\
+    \x1a\x1b\n\x0c\n\x05\x04\x01\x02\x05\x08\x12\x034\x1c2\n\x0f\n\x08\x04\
+    \x01\x02\x05\x08\xf2\x07\x01\x12\x034\x1d1\n\x0b\n\x04\x04\x01\x02\x06\
+    \x12\x035\x04;\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x035\x04\x0c\n\x0c\n\
+    \x05\x04\x01\x02\x06\x05\x12\x035\r\x12\n\x0c\n\x05\x04\x01\x02\x06\x01\
+    \x12\x035\x13\x1f\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x035\"#\n\x0c\n\
+    \x05\x04\x01\x02\x06\x08\x12\x035$:\n\x0f\n\x08\x04\x01\x02\x06\x08\xf2\
+    \x07\x01\x12\x035%9\n\x0b\n\x04\x04\x01\x02\x07\x12\x036\x044\n\x0c\n\
+    \x05\x04\x01\x02\x07\x04\x12\x036\x04\x0c\n\x0c\n\x05\x04\x01\x02\x07\
+    \x05\x12\x036\r\x12\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x036\x13\x18\n\
+    \x0c\n\x05\x04\x01\x02\x07\x03\x12\x036\x1b\x1c\n\x0c\n\x05\x04\x01\x02\
+    \x07\x08\x12\x036\x1d3\n\x0f\n\x08\x04\x01\x02\x07\x08\xf2\x07\x01\x12\
+    \x036\x1e2\n\x0b\n\x04\x04\x01\x02\x08\x12\x037\x04:\n\x0c\n\x05\x04\x01\
+    \x02\x08\x04\x12\x037\x04\x0c\n\x0c\n\x05\x04\x01\x02\x08\x05\x12\x037\r\
+    \x12\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x037\x13\x1e\n\x0c\n\x05\x04\
+    \x01\x02\x08\x03\x12\x037!\"\n\x0c\n\x05\x04\x01\x02\x08\x08\x12\x037#9\
+    \n\x0f\n\x08\x04\x01\x02\x08\x08\xf2\x07\x01\x12\x037$8\n\n\n\x02\x04\
+    \x02\x12\x04:\0=\x01\n\n\n\x03\x04\x02\x01\x12\x03:\x08\x16\n\x0b\n\x04\
+    \x04\x02\x02\0\x12\x03;\x022\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03;\x02\
+    \n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03;\x0b\x10\n\x0c\n\x05\x04\x02\
+    \x02\0\x01\x12\x03;\x11\x14\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03;\x17\
+    \x18\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03;\x191\n\x0f\n\x08\x04\x02\x02\
+    \0\x08\xf2\x07\x01\x12\x03;\x1a0\n\x0b\n\x04\x04\x02\x02\x01\x12\x03<\
+    \x02<\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03<\x02\n\n\x0c\n\x05\x04\x02\
+    \x02\x01\x06\x12\x03<\x0b\x1a\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03<\
+    \x1b\x20\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03<#$\n\x0c\n\x05\x04\x02\
+    \x02\x01\x08\x12\x03<%;\n\x0f\n\x08\x04\x02\x02\x01\x08\xf2\x07\x02\x12\
+    \x03<&:\n\n\n\x02\x04\x03\x12\x04?\0A\x01\n\n\n\x03\x04\x03\x01\x12\x03?\
+    \x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\x03@\x026\n\x0c\n\x05\x04\x03\x02\
+    \0\x04\x12\x03@\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03@\x0b\x10\n\
+    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03@\x11\x18\n\x0c\n\x05\x04\x03\x02\0\
+    \x03\x12\x03@\x1b\x1c\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x03@\x1d5\n\x0f\
+    \n\x08\x04\x03\x02\0\x08\xf2\x07\x01\x12\x03@\x1e4\n\n\n\x02\x04\x04\x12\
+    \x04C\0E\x01\n\n\n\x03\x04\x04\x01\x12\x03C\x08\x10\n\x0b\n\x04\x04\x04\
+    \x02\0\x12\x03D\x02<\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03D\x02\n\n\x0c\
+    \n\x05\x04\x04\x02\0\x06\x12\x03D\x0b\x1a\n\x0c\n\x05\x04\x04\x02\0\x01\
+    \x12\x03D\x1b\x20\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03D#$\n\x0c\n\x05\
+    \x04\x04\x02\0\x08\x12\x03D%;\n\x0f\n\x08\x04\x04\x02\0\x08\xf2\x07\x02\
+    \x12\x03D&:\
 ";
 
 static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
diff --git a/rpc.rs b/rpc.rs
index 44a432c..75065c4 100644
--- a/rpc.rs
+++ b/rpc.rs
@@ -16,6 +16,7 @@
 //! Trusty implementation of `RetrieveRpcArtifacts`. Currently, this supports
 //! only IRPC V3.
 
+use crate::secure_storage_manager;
 use hwbcc::{get_bcc, sign_data, HwBccMode, SigningAlgorithm, HWBCC_MAX_RESP_PAYLOAD_LENGTH};
 use hwkey::{Hwkey, KdfVersion};
 use kmr_common::{crypto, rpc_err, vec_try, Error};
@@ -29,6 +30,10 @@ use kmr_wire::{cbor::value::Value, rpc};
 // trusty/user/app/keymaster/trusty_remote_provisioning_context.cpp
 const HBK_KEY_DERIVATION_DATA: &[u8] = b"RemoteKeyProvisioningMasterKey";
 
+// SignerName is a string identifier that indicates both the signing authority
+// as well as the format of the UdsCertChain
+const SIGNER_NAME: &str = "GSMIRkpSecp384r1";
+
 pub struct TrustyRpc;
 
 impl RetrieveRpcArtifacts for TrustyRpc {
@@ -55,8 +60,23 @@ impl RetrieveRpcArtifacts for TrustyRpc {
         // Note: Test mode is ignored as this currently supports only IRPC V3.
         let bcc = get_bcc(HwBccMode::Release, &mut bcc_buf)
             .map_err(|e| rpc_err!(Failed, "failed to get DICE Info: {:?}", e))?;
-        // Construct `UdsCerts` as an empty CBOR map
-        let uds_certs_data = serialize_cbor(&Value::Map(Vec::new()))?;
+        // Construct `UdsCerts` as an empty CBOR map if not exist
+        let uds_certs_data = match secure_storage_manager::read_uds_cert() {
+            Ok(uds_certs) => {
+                let encoded_certs = uds_certs
+                    .into_iter()
+                    .map(|cert| Value::Bytes(cert.encoded_certificate))
+                    .collect::<Vec<_>>();
+                serialize_cbor(&Value::Map(vec![(
+                    Value::Text(SIGNER_NAME.to_string()),
+                    Value::Array(encoded_certs),
+                )]))
+            }
+            Err(err) => {
+                log::warn!("Failed to read UDS certificates: {:?}", err);
+                serialize_cbor(&Value::Map(Vec::new()))
+            }
+        }?;
         let pub_dice_artifacts =
             PubDiceArtifacts { uds_certs: uds_certs_data, dice_cert_chain: bcc.to_vec() };
         let dice_info = DiceInfo {
diff --git a/secure_storage_manager.rs b/secure_storage_manager.rs
index 031c91a..be7100e 100644
--- a/secure_storage_manager.rs
+++ b/secure_storage_manager.rs
@@ -17,6 +17,7 @@
 use crate::keybox;
 use crate::keymaster_attributes;
 use alloc::{format, string::String, vec::Vec};
+use keymaster_attributes::UdsCerts;
 use kmr_common::{
     crypto::{self, KeyMaterial},
     km_err, try_to_vec, vec_try, vec_try_with_capacity,
@@ -27,7 +28,7 @@ use kmr_common::{
 use kmr_ta::device::{
     RetrieveAttestationIds, RetrieveCertSigningInfo, SigningAlgorithm, SigningKeyType,
 };
-use log::info;
+use log::{error, info};
 use protobuf::{self, Message};
 use storage::{OpenMode, Port, SecureFile, Session};
 
@@ -42,11 +43,17 @@ const KM_ATTESTATION_ID_FILENAME: &str = "AttestationIds";
 /// `kAttestKeyCertPrefix` value in `secure_storage_manager.cpp` for back-compatibility.
 const KM_ATTESTATION_KEY_CERT_PREFIX: &str = "AttestKeyCert";
 
+/// Filename for holding UDS Certificate.
+const KM_RKP_UDS_CERT_FILENAME: &str = "UdsCerts";
+
 /// Maximum size of each attestation certificate
 const MAX_CERT_SIZE: usize = 2048;
 /// Maximum number of attestation certificates
 const MAX_CERT_CHAIN_LEN: usize = 3;
 
+/// Maximum number of UDS certificates
+const MAX_UDS_CERT_CHAIN_LEN: usize = 3;
+
 /// Return the filename for the file holding attestation keys and certificates for the specified
 /// signing algorithm.
 fn get_key_slot_file_name(algorithm: SigningAlgorithm) -> String {
@@ -158,6 +165,68 @@ pub(crate) fn provision_attestation_key_file(
     write_protobuf_to_attestation_key_file(algorithm, attestation_key)
 }
 
+/// Creates and empty UDS certificates file
+fn create_uds_cert_file() -> Result<OpenSecureFile, Error> {
+    OpenSecureFile::new(KM_RKP_UDS_CERT_FILENAME)
+}
+
+/// Delete the existing UDS certificates file
+fn delete_uds_cert_file() -> Result<(), Error> {
+    let mut session = Session::new(Port::TamperProof, true).map_err(|e| {
+        km_err!(SecureHwCommunicationFailed, "failed to connect to storage port: {:?}", e)
+    })?;
+    session.remove(KM_RKP_UDS_CERT_FILENAME).map_err(|e| {
+        km_err!(
+            SecureHwCommunicationFailed,
+            "failed to delete {:?}: {:?}",
+            KM_RKP_UDS_CERT_FILENAME,
+            e
+        )
+    })?;
+    Ok(())
+}
+
+fn write_protobuf_to_uds_cert_file(uds_cert_pb: UdsCerts) -> Result<(), Error> {
+    let serialized_buffer = uds_cert_pb.write_to_bytes().map_err(|e| {
+        km_err!(SecureHwCommunicationFailed, "couldn't serialize UdsCerts: {:?}", e)
+    })?;
+
+    let mut file = create_uds_cert_file()?;
+    file.write_all(&serialized_buffer).map_err(|e| {
+        km_err!(SecureHwCommunicationFailed, "failed to provision UdsCerts file: {:?}", e)
+    })?;
+    Ok(())
+}
+
+/// Tries to read the file containing the UdsCerts and append a cert on it.
+/// If the file doesn't exist it will create it and save the provided key.
+pub(crate) fn append_uds_cert_chain(cert_data: &[u8]) -> Result<(), Error> {
+    if cert_data.is_empty() || cert_data.len() > MAX_CERT_SIZE {
+        return Err(km_err!(
+            InvalidArgument,
+            "Invalid certificate size: {}, max size {}",
+            cert_data.len(),
+            MAX_CERT_SIZE
+        ));
+    }
+
+    let mut uds_cert_pb = read_uds_cert_content()?;
+    let cert_chain_len = uds_cert_pb.get_certs().len();
+    if cert_chain_len >= MAX_UDS_CERT_CHAIN_LEN {
+        return Err(km_err!(
+            InvalidArgument,
+            "cannot accept more certificates, {} already provisioned",
+            cert_chain_len
+        ));
+    }
+
+    let mut cert = keymaster_attributes::AttestationCert::new();
+    cert.set_content(try_to_vec(cert_data)?);
+    uds_cert_pb.mut_certs().push(cert);
+
+    write_protobuf_to_uds_cert_file(uds_cert_pb)
+}
+
 /// Tries to read the file containing the attestation key and certificates and adds a certificate to
 /// it if there is still space left on the certificate section. If the file doesn't exist it will
 /// create it and save the provided certificate.
@@ -196,6 +265,27 @@ pub(crate) fn append_attestation_cert_chain(
     write_protobuf_to_attestation_key_file(algorithm, attestation_key_data)
 }
 
+/// Tries to read the file containing the UdsCert. It's fine if that file is clear, or will try to
+/// delete it. After this call, all "read" operation will get a default <UdsCerts> object.
+pub(crate) fn maybe_delete_uds_cert_chain() -> Result<(), Error> {
+    let mut uds_cert_pb = read_uds_cert_content()?;
+    if uds_cert_pb.get_certs().is_empty() {
+        // No certs found, nothing to delete.
+        return Ok(());
+    }
+    delete_uds_cert_file()?;
+    uds_cert_pb = read_uds_cert_content()?;
+    let cert_chain_len = uds_cert_pb.get_certs().len();
+    if cert_chain_len != 0 {
+        return Err(km_err!(
+            UnknownError,
+            "couldn't delete all certificates, found {}",
+            cert_chain_len
+        ));
+    }
+    Ok(())
+}
+
 /// Tries to read the file containing the attestation key delete only the certificate section.
 pub(crate) fn clear_attestation_cert_chain(algorithm: SigningAlgorithm) -> Result<(), Error> {
     let mut attestation_key_data = read_attestation_key_content(algorithm)?;
@@ -209,7 +299,7 @@ pub(crate) fn clear_attestation_cert_chain(algorithm: SigningAlgorithm) -> Resul
     let attestation_key_data = read_attestation_key_content(algorithm)?;
     let cert_chain_len = attestation_key_data.get_certs().len();
     if cert_chain_len != 0 {
-        log::error!("Couldn't delete all certificates, found {}", cert_chain_len);
+        error!("Couldn't delete all certificates, found {}", cert_chain_len);
         return Err(km_err!(
             UnknownError,
             "couldn't delete all certificates, found {}",
@@ -298,7 +388,10 @@ fn get_file_contents(file_name: &str) -> Result<Option<Vec<u8>>, Error> {
     // retrieving attestation IDs on unprovisioned devices.
     let file = match session.open_file(file_name, OpenMode::Open) {
         Ok(file) => file,
-        Err(storage::Error::Code(trusty_sys::Error::NotFound)) => return Ok(None),
+        Err(storage::Error::Code(trusty_sys::Error::NotFound)) => {
+            info!("{file_name:?} NotFound");
+            return Ok(None);
+        }
         Err(e) => {
             return Err(km_err!(
                 SecureHwCommunicationFailed,
@@ -370,6 +463,34 @@ fn read_attestation_key_content(
     Ok(pb)
 }
 
+/// Retrieve that Uds certificate information
+/// Returns an empty protobuf when file is not found to match c++ behavior
+fn read_uds_cert_content() -> Result<UdsCerts, Error> {
+    let uds_cert_file_pb = match get_file_contents(KM_RKP_UDS_CERT_FILENAME)? {
+        Some(content) => Message::parse_from_bytes(&content)
+            .map_err(|e| km_err!(UnknownError, "failed to parse UdsCerts proto: {:?}", e))?,
+        None => UdsCerts::new(),
+    };
+    Ok(uds_cert_file_pb)
+}
+
+/// Retrieve the UdsCerts from the file in secure storage.
+pub(crate) fn read_uds_cert() -> Result<Vec<keymint::Certificate>, Error> {
+    let mut uds_certs_pb: UdsCerts = read_uds_cert_content()?;
+
+    let certs = uds_certs_pb.take_certs();
+    let num_certs = certs.len();
+    if num_certs == 0 {
+        return Err(km_err!(UnknownError, "UdsCerts file found but it had nothing"));
+    }
+    let mut certificates = vec_try_with_capacity!(num_certs)?;
+    for mut cert in certs {
+        let km_cert_pb = keymint::Certificate { encoded_certificate: cert.take_content() };
+        certificates.push(km_cert_pb);
+    }
+    Ok(certificates)
+}
+
 /// Tries to parse an EC private key as a SEC1 private EC key. If that fails, it tries to parse it
 /// as a PKCS#8 encoded key.
 fn import_ec_key(key_buffer: &[u8]) -> Result<KeyMaterial, Error> {
@@ -510,6 +631,12 @@ mod tests {
         session.open_file(&file_name, OpenMode::Open).is_ok()
     }
 
+    fn check_uds_certs_file_exists() -> bool {
+        let mut session =
+            Session::new(Port::TamperProof, true).expect("Couldn't connect to storage");
+        session.open_file(KM_RKP_UDS_CERT_FILENAME, OpenMode::Open).is_ok()
+    }
+
     fn delete_attestation_id_file() {
         let mut session =
             Session::new(Port::TamperProof, true).expect("Couldn't connect to storage");
@@ -829,6 +956,66 @@ mod tests {
         clear_certificate_chain_works_impl(SigningAlgorithm::Rsa);
     }
 
+    // This test should be run manually as it writes to storage.
+    // #[test]
+    fn provision_uds_certs_works() {
+        if check_uds_certs_file_exists() {
+            delete_uds_cert_file().expect("Couldn't delete UdsCerts file");
+        }
+        let cert1 = [b'a'; 500].as_slice();
+        let cert2 = [b'b'; 500].as_slice();
+        let cert3 = [b'c'; 500].as_slice();
+        let certs = [cert1, cert2, cert3];
+        for cert_data in certs.iter() {
+            append_uds_cert_chain(cert_data).expect("Couldn't provision UdsCerts");
+        }
+        expect!(
+            append_uds_cert_chain(cert3).is_err(),
+            "Shouldn't be able to add more certificates"
+        );
+
+        let read_uds_certs = read_uds_cert().expect("Couldn't read attestation key");
+        for i in 0..certs.len() {
+            expect_eq!(certs[i], read_uds_certs[i].encoded_certificate, "Uds Certs didn't match");
+        }
+
+        delete_uds_cert_file().expect("Couldn't delete UdsCerts file");
+    }
+
+    // This test should be run manually as it writes to storage.
+    // #[test]
+    fn clear_uds_certs_works() {
+        if check_uds_certs_file_exists() {
+            delete_uds_cert_file().expect("Couldn't delete UdsCerts file");
+        }
+        let cert = [b'a'; 500].as_slice();
+        append_uds_cert_chain(cert).expect("Couldn't provision certificate");
+        let read_certs = read_uds_cert().expect("Couldn't get UdsCerts from storage");
+        expect_eq!(read_certs.len(), 1, "Didn't get all certificates back");
+
+        maybe_delete_uds_cert_chain().expect("Couldn't delete UdsCerts file");
+
+        expect!(read_uds_cert().is_err(), "Certificates were not deleted");
+    }
+
+    // This test should be run manually as it writes to storage.
+    // #[test]
+    fn get_clear_uds_certs_after_delete_works() {
+        if check_uds_certs_file_exists() {
+            delete_uds_cert_file().expect("Couldn't delete UdsCerts file");
+        }
+        let cert = [b'a'; 500].as_slice();
+        append_uds_cert_chain(cert).expect("Couldn't provision certificate");
+        let read_certs = read_uds_cert().expect("Couldn't get UdsCerts from storage");
+        expect_eq!(read_certs.len(), 1, "Didn't get all certificates back");
+
+        maybe_delete_uds_cert_chain().expect("couldn't delete UdsCerts file");
+
+        let expected_clear_uds_cert =
+            read_uds_cert_content().expect("Couldn't get a default UdsCerts objec");
+        expect_eq!(expected_clear_uds_cert.certs.len(), 0, "Not a clear UdsCerts object");
+    }
+
     // This test should be run manually as it writes to storage.
     // #[test]
     fn unprovisioned_attestation_ids_do_not_error() {
```

